var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var content = function() {
  var _isTopFrame, _abortController, _locationWatcher, _stopOldScripts, stopOldScripts_fn, _listenForNewerScripts, listenForNewerScripts_fn, _a2;
  "use strict";
  function defineContentScript(definition2) {
    return definition2;
  }
  const definition = defineContentScript({
    matches: ["*://*/*"],
    allFrames: true,
    runAt: "document_start",
    main(_ctx) {
      window.global = window.global ?? window;
      Promise.resolve().then(() => wrappedIndex);
    }
  });
  content;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getAugmentedNamespace(n2) {
    if (n2.__esModule)
      return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a.prototype = f2.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", {
      value: true
    });
    Object.keys(n2).forEach(function(k2) {
      var d2 = Object.getOwnPropertyDescriptor(n2, k2);
      Object.defineProperty(a, k2, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n2[k2];
        }
      });
    });
    return a;
  }
  var browserPolyfill = { exports: {} };
  (function(module2, exports2) {
    (function(global2, factory) {
      {
        factory(module2);
      }
    })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : commonjsGlobal, function(module3) {
      if (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {
        throw new Error("This script should only be loaded in a browser extension.");
      }
      if (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {
        const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
        const wrapAPIs = (extensionAPIs) => {
          const apiMetadata = {
            "alarms": {
              "clear": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "clearAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "get": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "bookmarks": {
              "create": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getChildren": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getRecent": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getSubTree": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTree": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "move": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeTree": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "browserAction": {
              "disable": {
                "minArgs": 0,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "enable": {
                "minArgs": 0,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "getBadgeBackgroundColor": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getBadgeText": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getPopup": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTitle": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "openPopup": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "setBadgeBackgroundColor": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setBadgeText": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setIcon": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "setPopup": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setTitle": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "browsingData": {
              "remove": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "removeCache": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeCookies": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeDownloads": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeFormData": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeHistory": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeLocalStorage": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removePasswords": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removePluginData": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "settings": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "commands": {
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "contextMenus": {
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "cookies": {
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAllCookieStores": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "set": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "devtools": {
              "inspectedWindow": {
                "eval": {
                  "minArgs": 1,
                  "maxArgs": 2,
                  "singleCallbackArg": false
                }
              },
              "panels": {
                "create": {
                  "minArgs": 3,
                  "maxArgs": 3,
                  "singleCallbackArg": true
                },
                "elements": {
                  "createSidebarPane": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                }
              }
            },
            "downloads": {
              "cancel": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "download": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "erase": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getFileIcon": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "open": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "pause": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeFile": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "resume": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "show": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "extension": {
              "isAllowedFileSchemeAccess": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "isAllowedIncognitoAccess": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "history": {
              "addUrl": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "deleteAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "deleteRange": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "deleteUrl": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getVisits": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "i18n": {
              "detectLanguage": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAcceptLanguages": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "identity": {
              "launchWebAuthFlow": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "idle": {
              "queryState": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "management": {
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getSelf": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "setEnabled": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "uninstallSelf": {
                "minArgs": 0,
                "maxArgs": 1
              }
            },
            "notifications": {
              "clear": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "create": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getPermissionLevel": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "pageAction": {
              "getPopup": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTitle": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "hide": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setIcon": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "setPopup": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setTitle": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "show": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "permissions": {
              "contains": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "request": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "runtime": {
              "getBackgroundPage": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getPlatformInfo": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "openOptionsPage": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "requestUpdateCheck": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "sendMessage": {
                "minArgs": 1,
                "maxArgs": 3
              },
              "sendNativeMessage": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "setUninstallURL": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "sessions": {
              "getDevices": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getRecentlyClosed": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "restore": {
                "minArgs": 0,
                "maxArgs": 1
              }
            },
            "storage": {
              "local": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "managed": {
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "sync": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              }
            },
            "tabs": {
              "captureVisibleTab": {
                "minArgs": 0,
                "maxArgs": 2
              },
              "create": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "detectLanguage": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "discard": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "duplicate": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "executeScript": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getCurrent": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getZoom": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getZoomSettings": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "goBack": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "goForward": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "highlight": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "insertCSS": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "move": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "query": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "reload": {
                "minArgs": 0,
                "maxArgs": 2
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeCSS": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "sendMessage": {
                "minArgs": 2,
                "maxArgs": 3
              },
              "setZoom": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "setZoomSettings": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "update": {
                "minArgs": 1,
                "maxArgs": 2
              }
            },
            "topSites": {
              "get": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "webNavigation": {
              "getAllFrames": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getFrame": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "webRequest": {
              "handlerBehaviorChanged": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "windows": {
              "create": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getCurrent": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getLastFocused": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            }
          };
          if (Object.keys(apiMetadata).length === 0) {
            throw new Error("api-metadata.json has not been included in browser-polyfill");
          }
          class DefaultWeakMap extends WeakMap {
            constructor(createItem, items = void 0) {
              super(items);
              this.createItem = createItem;
            }
            get(key) {
              if (!this.has(key)) {
                this.set(key, this.createItem(key));
              }
              return super.get(key);
            }
          }
          const isThenable2 = (value) => {
            return value && typeof value === "object" && typeof value.then === "function";
          };
          const makeCallback = (promise, metadata) => {
            return (...callbackArgs) => {
              if (extensionAPIs.runtime.lastError) {
                promise.reject(new Error(extensionAPIs.runtime.lastError.message));
              } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
                promise.resolve(callbackArgs[0]);
              } else {
                promise.resolve(callbackArgs);
              }
            };
          };
          const pluralizeArguments = (numArgs) => numArgs == 1 ? "argument" : "arguments";
          const wrapAsyncFunction = (name, metadata) => {
            return function asyncFunctionWrapper(target, ...args) {
              if (args.length < metadata.minArgs) {
                throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
              }
              if (args.length > metadata.maxArgs) {
                throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
              }
              return new Promise((resolve, reject) => {
                if (metadata.fallbackToNoCallback) {
                  try {
                    target[name](...args, makeCallback({
                      resolve,
                      reject
                    }, metadata));
                  } catch (cbError) {
                    console.warn(`${name} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, cbError);
                    target[name](...args);
                    metadata.fallbackToNoCallback = false;
                    metadata.noCallback = true;
                    resolve();
                  }
                } else if (metadata.noCallback) {
                  target[name](...args);
                  resolve();
                } else {
                  target[name](...args, makeCallback({
                    resolve,
                    reject
                  }, metadata));
                }
              });
            };
          };
          const wrapMethod = (target, method, wrapper) => {
            return new Proxy(method, {
              apply(targetMethod, thisObj, args) {
                return wrapper.call(thisObj, target, ...args);
              }
            });
          };
          let hasOwnProperty2 = Function.call.bind(Object.prototype.hasOwnProperty);
          const wrapObject = (target, wrappers = {}, metadata = {}) => {
            let cache2 = /* @__PURE__ */ Object.create(null);
            let handlers2 = {
              has(proxyTarget2, prop) {
                return prop in target || prop in cache2;
              },
              get(proxyTarget2, prop, receiver) {
                if (prop in cache2) {
                  return cache2[prop];
                }
                if (!(prop in target)) {
                  return void 0;
                }
                let value = target[prop];
                if (typeof value === "function") {
                  if (typeof wrappers[prop] === "function") {
                    value = wrapMethod(target, target[prop], wrappers[prop]);
                  } else if (hasOwnProperty2(metadata, prop)) {
                    let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                    value = wrapMethod(target, target[prop], wrapper);
                  } else {
                    value = value.bind(target);
                  }
                } else if (typeof value === "object" && value !== null && (hasOwnProperty2(wrappers, prop) || hasOwnProperty2(metadata, prop))) {
                  value = wrapObject(value, wrappers[prop], metadata[prop]);
                } else if (hasOwnProperty2(metadata, "*")) {
                  value = wrapObject(value, wrappers[prop], metadata["*"]);
                } else {
                  Object.defineProperty(cache2, prop, {
                    configurable: true,
                    enumerable: true,
                    get() {
                      return target[prop];
                    },
                    set(value2) {
                      target[prop] = value2;
                    }
                  });
                  return value;
                }
                cache2[prop] = value;
                return value;
              },
              set(proxyTarget2, prop, value, receiver) {
                if (prop in cache2) {
                  cache2[prop] = value;
                } else {
                  target[prop] = value;
                }
                return true;
              },
              defineProperty(proxyTarget2, prop, desc) {
                return Reflect.defineProperty(cache2, prop, desc);
              },
              deleteProperty(proxyTarget2, prop) {
                return Reflect.deleteProperty(cache2, prop);
              }
            };
            let proxyTarget = Object.create(target);
            return new Proxy(proxyTarget, handlers2);
          };
          const wrapEvent = (wrapperMap) => ({
            addListener(target, listener, ...args) {
              target.addListener(wrapperMap.get(listener), ...args);
            },
            hasListener(target, listener) {
              return target.hasListener(wrapperMap.get(listener));
            },
            removeListener(target, listener) {
              target.removeListener(wrapperMap.get(listener));
            }
          });
          const onRequestFinishedWrappers = new DefaultWeakMap((listener) => {
            if (typeof listener !== "function") {
              return listener;
            }
            return function onRequestFinished(req) {
              const wrappedReq = wrapObject(req, {}, {
                getContent: {
                  minArgs: 0,
                  maxArgs: 0
                }
              });
              listener(wrappedReq);
            };
          });
          const onMessageWrappers = new DefaultWeakMap((listener) => {
            if (typeof listener !== "function") {
              return listener;
            }
            return function onMessage(message, sender, sendResponse) {
              let didCallSendResponse = false;
              let wrappedSendResponse;
              let sendResponsePromise = new Promise((resolve) => {
                wrappedSendResponse = function(response) {
                  didCallSendResponse = true;
                  resolve(response);
                };
              });
              let result2;
              try {
                result2 = listener(message, sender, wrappedSendResponse);
              } catch (err) {
                result2 = Promise.reject(err);
              }
              const isResultThenable = result2 !== true && isThenable2(result2);
              if (result2 !== true && !isResultThenable && !didCallSendResponse) {
                return false;
              }
              const sendPromisedResult = (promise) => {
                promise.then((msg) => {
                  sendResponse(msg);
                }, (error2) => {
                  let message2;
                  if (error2 && (error2 instanceof Error || typeof error2.message === "string")) {
                    message2 = error2.message;
                  } else {
                    message2 = "An unexpected error occurred";
                  }
                  sendResponse({
                    __mozWebExtensionPolyfillReject__: true,
                    message: message2
                  });
                }).catch((err) => {
                  console.error("Failed to send onMessage rejected reply", err);
                });
              };
              if (isResultThenable) {
                sendPromisedResult(result2);
              } else {
                sendPromisedResult(sendResponsePromise);
              }
              return true;
            };
          });
          const wrappedSendMessageCallback = ({
            reject,
            resolve
          }, reply) => {
            if (extensionAPIs.runtime.lastError) {
              if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
                resolve();
              } else {
                reject(new Error(extensionAPIs.runtime.lastError.message));
              }
            } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
              reject(new Error(reply.message));
            } else {
              resolve(reply);
            }
          };
          const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
            if (args.length < metadata.minArgs) {
              throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
            }
            if (args.length > metadata.maxArgs) {
              throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
            }
            return new Promise((resolve, reject) => {
              const wrappedCb = wrappedSendMessageCallback.bind(null, {
                resolve,
                reject
              });
              args.push(wrappedCb);
              apiNamespaceObj.sendMessage(...args);
            });
          };
          const staticWrappers = {
            devtools: {
              network: {
                onRequestFinished: wrapEvent(onRequestFinishedWrappers)
              }
            },
            runtime: {
              onMessage: wrapEvent(onMessageWrappers),
              onMessageExternal: wrapEvent(onMessageWrappers),
              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                minArgs: 1,
                maxArgs: 3
              })
            },
            tabs: {
              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                minArgs: 2,
                maxArgs: 3
              })
            }
          };
          const settingMetadata = {
            clear: {
              minArgs: 1,
              maxArgs: 1
            },
            get: {
              minArgs: 1,
              maxArgs: 1
            },
            set: {
              minArgs: 1,
              maxArgs: 1
            }
          };
          apiMetadata.privacy = {
            network: {
              "*": settingMetadata
            },
            services: {
              "*": settingMetadata
            },
            websites: {
              "*": settingMetadata
            }
          };
          return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
        };
        module3.exports = wrapAPIs(chrome);
      } else {
        module3.exports = globalThis.browser;
      }
    });
  })(browserPolyfill);
  var browserPolyfillExports = browserPolyfill.exports;
  const browser$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserPolyfillExports);
  const browser = browser$1;
  function print$1(method, ...args) {
    return;
  }
  const logger$3 = {
    debug: (...args) => print$1(console.debug, ...args),
    log: (...args) => print$1(console.log, ...args),
    warn: (...args) => print$1(console.warn, ...args),
    error: (...args) => print$1(console.error, ...args)
  };
  const _WxtLocationChangeEvent = class _WxtLocationChangeEvent extends Event {
    constructor(newUrl, oldUrl) {
      super(_WxtLocationChangeEvent.EVENT_NAME, {});
      this.newUrl = newUrl;
      this.oldUrl = oldUrl;
    }
  };
  __publicField(_WxtLocationChangeEvent, "EVENT_NAME", getUniqueEventName("wxt:locationchange"));
  let WxtLocationChangeEvent = _WxtLocationChangeEvent;
  function getUniqueEventName(eventName) {
    var _a3;
    const entrypointName = typeof { "VITE_UNSAFE_USE_HTTP": "", "VITE_AUDITLOG_SERVER": "", "VITE_BACKEND_SERVER": "", "VITE_FRONTEND_SERVER": "", "VITE_CJS_IGNORE_WARNING": "true", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false, "MANIFEST_VERSION": 2, "BROWSER": "all", "CHROME": false, "FIREFOX": false, "SAFARI": false, "EDGE": false, "OPERA": false, "COMMAND": "build", "ENTRYPOINT": "content" } === "undefined" ? "build" : "content";
    return `${(_a3 = browser == null ? void 0 : browser.runtime) == null ? void 0 : _a3.id}:${entrypointName}:${eventName}`;
  }
  function createLocationWatcher(ctx) {
    let interval;
    let oldUrl;
    return {
      /**
       * Ensure the location watcher is actively looking for URL changes. If it's already watching,
       * this is a noop.
       */
      run() {
        if (interval != null)
          return;
        oldUrl = new URL(location.href);
        interval = ctx.setInterval(() => {
          let newUrl = new URL(location.href);
          if (newUrl.href !== oldUrl.href) {
            window.dispatchEvent(new WxtLocationChangeEvent(newUrl, oldUrl));
            oldUrl = newUrl;
          }
        }, 1e3);
      }
    };
  }
  const _ContentScriptContext = class _ContentScriptContext {
    constructor(contentScriptName, options) {
      __privateAdd(this, _stopOldScripts);
      __privateAdd(this, _listenForNewerScripts);
      __privateAdd(this, _isTopFrame, window.self === window.top);
      __privateAdd(this, _abortController, void 0);
      __privateAdd(this, _locationWatcher, createLocationWatcher(this));
      this.contentScriptName = contentScriptName;
      this.options = options;
      __privateSet(this, _abortController, new AbortController());
      if (__privateGet(this, _isTopFrame)) {
        __privateMethod(this, _listenForNewerScripts, listenForNewerScripts_fn).call(this, { ignoreFirstEvent: true });
        __privateMethod(this, _stopOldScripts, stopOldScripts_fn).call(this);
      } else {
        __privateMethod(this, _listenForNewerScripts, listenForNewerScripts_fn).call(this);
      }
    }
    get signal() {
      return __privateGet(this, _abortController).signal;
    }
    abort(reason) {
      return __privateGet(this, _abortController).abort(reason);
    }
    get isInvalid() {
      if (browser.runtime.id == null) {
        this.notifyInvalidated();
      }
      return this.signal.aborted;
    }
    get isValid() {
      return !this.isInvalid;
    }
    /**
     * Add a listener that is called when the content script's context is invalidated.
     *
     * @returns A function to remove the listener.
     *
     * @example
     * browser.runtime.onMessage.addListener(cb);
     * const removeInvalidatedListener = ctx.onInvalidated(() => {
     *   browser.runtime.onMessage.removeListener(cb);
     * })
     * // ...
     * removeInvalidatedListener();
     */
    onInvalidated(cb2) {
      this.signal.addEventListener("abort", cb2);
      return () => this.signal.removeEventListener("abort", cb2);
    }
    /**
     * Return a promise that never resolves. Useful if you have an async function that shouldn't run
     * after the context is expired.
     *
     * @example
     * const getValueFromStorage = async () => {
     *   if (ctx.isInvalid) return ctx.block();
     *
     *   // ...
     * }
     */
    block() {
      return new Promise(() => {
      });
    }
    /**
     * Wrapper around `window.setInterval` that automatically clears the interval when invalidated.
     */
    setInterval(handler, timeout) {
      const id2 = setInterval(() => {
        if (this.isValid)
          handler();
      }, timeout);
      this.onInvalidated(() => clearInterval(id2));
      return id2;
    }
    /**
     * Wrapper around `window.setTimeout` that automatically clears the interval when invalidated.
     */
    setTimeout(handler, timeout) {
      const id2 = setTimeout(() => {
        if (this.isValid)
          handler();
      }, timeout);
      this.onInvalidated(() => clearTimeout(id2));
      return id2;
    }
    /**
     * Wrapper around `window.requestAnimationFrame` that automatically cancels the request when
     * invalidated.
     */
    requestAnimationFrame(callback) {
      const id2 = requestAnimationFrame((...args) => {
        if (this.isValid)
          callback(...args);
      });
      this.onInvalidated(() => cancelAnimationFrame(id2));
      return id2;
    }
    /**
     * Wrapper around `window.requestIdleCallback` that automatically cancels the request when
     * invalidated.
     */
    requestIdleCallback(callback, options) {
      const id2 = requestIdleCallback((...args) => {
        if (!this.signal.aborted)
          callback(...args);
      }, options);
      this.onInvalidated(() => cancelIdleCallback(id2));
      return id2;
    }
    /**
     * Call `target.addEventListener` and remove the event listener when the context is invalidated.
     *
     * Includes additional events useful for content scripts:
     *
     * - `"wxt:locationchange"` - Triggered when HTML5 history mode is used to change URL. Content
     *   scripts are not reloaded when navigating this way, so this can be used to reset the content
     *   script state on URL change, or run custom code.
     *
     * @example
     * ctx.addEventListener(document, "visibilitychange", () => {
     *   // ...
     * });
     * ctx.addEventListener(document, "wxt:locationchange", () => {
     *   // ...
     * });
     */
    addEventListener(target, type, handler, options) {
      var _a3;
      if (type === "wxt:locationchange") {
        if (this.isValid)
          __privateGet(this, _locationWatcher).run();
      }
      (_a3 = target.addEventListener) == null ? void 0 : _a3.call(
        target,
        type.startsWith("wxt:") ? getUniqueEventName(type) : type,
        // @ts-expect-error: Event don't match, but that's OK, EventTarget doesn't allow custom types in the callback
        handler,
        {
          ...options,
          signal: this.signal
        }
      );
    }
    /**
     * @internal
     * Abort the abort controller and execute all `onInvalidated` listeners.
     */
    notifyInvalidated() {
      this.abort("Content script context invalidated");
      logger$3.debug(
        `Content script "${this.contentScriptName}" context invalidated`
      );
    }
  };
  _isTopFrame = new WeakMap();
  _abortController = new WeakMap();
  _locationWatcher = new WeakMap();
  _stopOldScripts = new WeakSet();
  stopOldScripts_fn = function() {
    window.postMessage(
      {
        type: _ContentScriptContext.SCRIPT_STARTED_MESSAGE_TYPE,
        contentScriptName: this.contentScriptName
      },
      "*"
    );
  };
  _listenForNewerScripts = new WeakSet();
  listenForNewerScripts_fn = function(options) {
    let isFirst = true;
    const cb2 = (event) => {
      var _a3, _b;
      if (((_a3 = event.data) == null ? void 0 : _a3.type) === _ContentScriptContext.SCRIPT_STARTED_MESSAGE_TYPE && ((_b = event.data) == null ? void 0 : _b.contentScriptName) === this.contentScriptName) {
        const wasFirst = isFirst;
        isFirst = false;
        if (wasFirst && (options == null ? void 0 : options.ignoreFirstEvent))
          return;
        this.notifyInvalidated();
      }
    };
    addEventListener("message", cb2);
    this.onInvalidated(() => removeEventListener("message", cb2));
  };
  __publicField(_ContentScriptContext, "SCRIPT_STARTED_MESSAGE_TYPE", "wxt:content-script-started");
  let ContentScriptContext = _ContentScriptContext;
  function initPlugins() {
  }
  function print(method, ...args) {
    return;
  }
  const logger$2 = {
    debug: (...args) => print(console.debug, ...args),
    log: (...args) => print(console.log, ...args),
    warn: (...args) => print(console.warn, ...args),
    error: (...args) => print(console.error, ...args)
  };
  const result = (async () => {
    try {
      initPlugins();
      const {
        main,
        ...options
      } = definition;
      const ctx = new ContentScriptContext("content", options);
      return await main(ctx);
    } catch (err) {
      logger$2.error(`The content script "${"content"}" crashed on startup!`, err);
      throw err;
    }
  })();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  function assert$6(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }
  const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
  function getEnumType(enumObject) {
    const t2 = enumObject[enumTypeSymbol];
    assert$6(t2, "missing enum type on enum object");
    return t2;
  }
  function setEnumType(enumObject, typeName, values2, opt) {
    enumObject[enumTypeSymbol] = makeEnumType(typeName, values2.map((v2) => ({
      no: v2.no,
      name: v2.name,
      localName: enumObject[v2.no]
    })));
  }
  function makeEnumType(typeName, values2, _opt) {
    const names = /* @__PURE__ */ Object.create(null);
    const numbers = /* @__PURE__ */ Object.create(null);
    const normalValues = [];
    for (const value of values2) {
      const n2 = normalizeEnumValue(value);
      normalValues.push(n2);
      names[value.name] = n2;
      numbers[value.no] = n2;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no2) {
        return numbers[no2];
      }
    };
  }
  function makeEnum(typeName, values2, opt) {
    const enumObject = {};
    for (const value of values2) {
      const n2 = normalizeEnumValue(value);
      enumObject[n2.localName] = n2.no;
      enumObject[n2.no] = n2.localName;
    }
    setEnumType(enumObject, typeName, values2);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ("localName" in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), { localName: value.name });
  }
  class Message {
    /**
     * Compare with a message of the same type.
     * Note that this function disregards extensions and unknown fields.
     */
    equals(other) {
      return this.getType().runtime.util.equals(this.getType(), this, other);
    }
    /**
     * Create a deep copy.
     */
    clone() {
      return this.getType().runtime.util.clone(this);
    }
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    fromBinary(bytes, options) {
      const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
      format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
      return this;
    }
    /**
     * Parse a message from a JSON value.
     */
    fromJson(jsonValue, options) {
      const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
      format.readMessage(type, jsonValue, opt, this);
      return this;
    }
    /**
     * Parse a message from a JSON string.
     */
    fromJsonString(jsonString, options) {
      let json;
      try {
        json = JSON.parse(jsonString);
      } catch (e2) {
        throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e2 instanceof Error ? e2.message : String(e2)}`);
      }
      return this.fromJson(json, options);
    }
    /**
     * Serialize the message to binary data.
     */
    toBinary(options) {
      const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
      bin.writeMessage(this, writer, opt);
      return writer.finish();
    }
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
    toJson(options) {
      const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
      return json.writeMessage(this, opt);
    }
    /**
     * Serialize the message to a JSON string.
     */
    toJsonString(options) {
      var _a3;
      const value = this.toJson(options);
      return JSON.stringify(value, null, (_a3 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a3 !== void 0 ? _a3 : 0);
    }
    /**
     * Override for serialization behavior. This will be invoked when calling
     * JSON.stringify on this message (i.e. JSON.stringify(msg)).
     *
     * Note that this will not serialize google.protobuf.Any with a packed
     * message because the protobuf JSON format specifies that it needs to be
     * unpacked, and this is only possible with a type registry to look up the
     * message type.  As a result, attempting to serialize a message with this
     * type will throw an Error.
     *
     * This method is protected because you should not need to invoke it
     * directly -- instead use JSON.stringify or toJsonString for
     * stringified JSON.  Alternatively, if actual JSON is desired, you should
     * use toJson.
     */
    toJSON() {
      return this.toJson({
        emitDefaultValues: true
      });
    }
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
    getType() {
      return Object.getPrototypeOf(this).constructor;
    }
  }
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a3;
    const localName = (_a3 = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a3 !== void 0 ? _a3 : typeName.substring(typeName.lastIndexOf(".") + 1);
    const type = {
      [localName]: function(data) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data, this);
      }
    }[localName];
    Object.setPrototypeOf(type.prototype, new Message());
    Object.assign(type, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type().fromJsonString(jsonString, options);
      },
      equals(a, b2) {
        return runtime.util.equals(type, a, b2);
      }
    });
    return type;
  }
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b2 = this.buf[this.pos++];
      lowBits |= (b2 & 127) << shift;
      if ((b2 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b2 = this.buf[this.pos++];
      highBits |= (b2 & 127) << shift;
      if ((b2 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  function varint64write(lo2, hi2, bytes) {
    for (let i2 = 0; i2 < 28; i2 = i2 + 7) {
      const shift = lo2 >>> i2;
      const hasNext = !(shift >>> 7 == 0 && hi2 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo2 >>> 28 & 15 | (hi2 & 7) << 4;
    const hasMoreBits = !(hi2 >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i2 = 3; i2 < 31; i2 = i2 + 7) {
      const shift = hi2 >>> i2;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi2 >>> 31 & 1);
  }
  const TWO_PWR_32_DBL = 4294967296;
  function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
      dec = dec.slice(1);
    }
    const base2 = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base2;
      lowBits = lowBits * base2 + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
  }
  function int64ToString(lo2, hi2) {
    let bits = newBits(lo2, hi2);
    const negative = bits.hi & 2147483648;
    if (negative) {
      bits = negate(bits.lo, bits.hi);
    }
    const result2 = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result2 : result2;
  }
  function uInt64ToString(lo2, hi2) {
    ({ lo: lo2, hi: hi2 } = toUnsigned(lo2, hi2));
    if (hi2 <= 2097151) {
      return String(TWO_PWR_32_DBL * hi2 + lo2);
    }
    const low = lo2 & 16777215;
    const mid = (lo2 >>> 24 | hi2 << 8) & 16777215;
    const high = hi2 >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base2 = 1e7;
    if (digitA >= base2) {
      digitB += Math.floor(digitA / base2);
      digitA %= base2;
    }
    if (digitB >= base2) {
      digitC += Math.floor(digitB / base2);
      digitB %= base2;
    }
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
  }
  function toUnsigned(lo2, hi2) {
    return { lo: lo2 >>> 0, hi: hi2 >>> 0 };
  }
  function newBits(lo2, hi2) {
    return { lo: lo2 | 0, hi: hi2 | 0 };
  }
  function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  const decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
  };
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i2 = 0; i2 < 9; i2++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  function varint32read() {
    let b2 = this.buf[this.pos++];
    let result2 = b2 & 127;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result2;
    }
    b2 = this.buf[this.pos++];
    result2 |= (b2 & 127) << 7;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result2;
    }
    b2 = this.buf[this.pos++];
    result2 |= (b2 & 127) << 14;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result2;
    }
    b2 = this.buf[this.pos++];
    result2 |= (b2 & 127) << 21;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result2;
    }
    b2 = this.buf[this.pos++];
    result2 |= (b2 & 15) << 28;
    for (let readBytes = 5; (b2 & 128) !== 0 && readBytes < 10; readBytes++)
      b2 = this.buf[this.pos++];
    if ((b2 & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result2 >>> 0;
  }
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok2 = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
    if (ok2) {
      const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi2 = typeof value == "bigint" ? value : BigInt(value);
          if (bi2 > MAX || bi2 < MIN) {
            throw new Error(`int64 invalid: ${value}`);
          }
          return bi2;
        },
        uParse(value) {
          const bi2 = typeof value == "bigint" ? value : BigInt(value);
          if (bi2 > UMAX || bi2 < UMIN) {
            throw new Error(`uint64 invalid: ${value}`);
          }
          return bi2;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        dec(lo2, hi2) {
          dv.setInt32(0, lo2, true);
          dv.setInt32(4, hi2, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo2, hi2) {
          dv.setInt32(0, lo2, true);
          dv.setInt32(4, hi2, true);
          return dv.getBigUint64(0, true);
        }
      };
    }
    const assertInt64String = (value) => assert$6(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
    const assertUInt64String = (value) => assert$6(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
    return {
      zero: "0",
      supported: false,
      parse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo2, hi2) {
        return int64ToString(lo2, hi2);
      },
      uDec(lo2, hi2) {
        return uInt64ToString(lo2, hi2);
      }
    };
  }
  const protoInt64 = makeInt64Support();
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType || (ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
  })(LongType || (LongType = {}));
  function scalarEquals(type, a, b2) {
    if (a === b2) {
      return true;
    }
    if (type == ScalarType.BYTES) {
      if (!(a instanceof Uint8Array) || !(b2 instanceof Uint8Array)) {
        return false;
      }
      if (a.length !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b2[i2]) {
          return false;
        }
      }
      return true;
    }
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return a == b2;
    }
    return false;
  }
  function scalarZeroValue(type, longType) {
    switch (type) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return longType == 0 ? protoInt64.zero : "0";
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function isScalarZeroValue(type, value) {
    switch (type) {
      case ScalarType.BOOL:
        return value === false;
      case ScalarType.STRING:
        return value === "";
      case ScalarType.BYTES:
        return value instanceof Uint8Array && !value.byteLength;
      default:
        return value == 0;
    }
  }
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType || (WireType = {}));
  class BinaryWriter {
    constructor(textEncoder) {
      this.stack = [];
      this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
      this.chunks = [];
      this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i2 = 0; i2 < this.chunks.length; i2++)
        len += this.chunks[i2].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i2 = 0; i2 < this.chunks.length; i2++) {
        bytes.set(this.chunks[i2], offset);
        offset += this.chunks[i2].length;
      }
      this.chunks = [];
      return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
      this.stack.push({ chunks: this.chunks, buf: this.buf });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev)
        throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
      assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
      assertInt32(value);
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
      assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
      assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
      assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
      assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc2 = protoInt64.enc(value);
      view.setInt32(0, tc2.lo, true);
      view.setInt32(4, tc2.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc2 = protoInt64.uEnc(value);
      view.setInt32(0, tc2.lo, true);
      view.setInt32(4, tc2.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
      let tc2 = protoInt64.enc(value);
      varint64write(tc2.lo, tc2.hi, this.buf);
      return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
      let tc2 = protoInt64.enc(value), sign2 = tc2.hi >> 31, lo2 = tc2.lo << 1 ^ sign2, hi2 = (tc2.hi << 1 | tc2.lo >>> 31) ^ sign2;
      varint64write(lo2, hi2, this.buf);
      return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
      let tc2 = protoInt64.uEnc(value);
      varint64write(tc2.lo, tc2.hi, this.buf);
      return this;
    }
  }
  class BinaryReader {
    constructor(buf, textDecoder) {
      this.varint64 = varint64read;
      this.uint32 = varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
    skip(wireType, fieldNo) {
      let start = this.pos;
      switch (wireType) {
        case WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        case WireType.Bit64:
          this.pos += 4;
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case WireType.StartGroup:
          for (; ; ) {
            const [fn, wt] = this.tag();
            if (wt === WireType.EndGroup) {
              if (fieldNo !== void 0 && fn !== fieldNo) {
                throw new Error("invalid end group tag");
              }
              break;
            }
            this.skip(wt, fn);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
      if (this.pos > this.len)
        throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
      return protoInt64.dec(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
      return protoInt64.uDec(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
      let [lo2, hi2] = this.varint64();
      let s2 = -(lo2 & 1);
      lo2 = (lo2 >>> 1 | (hi2 & 1) << 31) ^ s2;
      hi2 = hi2 >>> 1 ^ s2;
      return protoInt64.dec(lo2, hi2);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
      let [lo2, hi2] = this.varint64();
      return lo2 !== 0 || hi2 !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
      let len = this.uint32(), start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }
  function makeExtension(runtime, typeName, extendee, field) {
    let fi2;
    return {
      typeName,
      extendee,
      get field() {
        if (!fi2) {
          const i2 = typeof field == "function" ? field() : field;
          i2.name = typeName.split(".").pop();
          i2.jsonName = `[${typeName}]`;
          fi2 = runtime.util.newFieldList([i2]).list()[0];
        }
        return fi2;
      },
      runtime
    };
  }
  function createExtensionContainer(extension) {
    const localName = extension.field.localName;
    const container = /* @__PURE__ */ Object.create(null);
    container[localName] = initExtensionField(extension);
    return [container, () => container[localName]];
  }
  function initExtensionField(ext) {
    const field = ext.field;
    if (field.repeated) {
      return [];
    }
    if (field.default !== void 0) {
      return field.default;
    }
    switch (field.kind) {
      case "enum":
        return field.T.values[0].no;
      case "scalar":
        return scalarZeroValue(field.T, field.L);
      case "message":
        const T2 = field.T, value = new T2();
        return T2.fieldWrapper ? T2.fieldWrapper.unwrapField(value) : value;
      case "map":
        throw "map fields are not allowed to be extensions";
    }
  }
  function filterUnknownFields(unknownFields, field) {
    if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
      for (let i2 = unknownFields.length - 1; i2 >= 0; --i2) {
        if (unknownFields[i2].no == field.no) {
          return [unknownFields[i2]];
        }
      }
      return [];
    }
    return unknownFields.filter((uf2) => uf2.no === field.no);
  }
  let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  let decTable = [];
  for (let i2 = 0; i2 < encTable.length; i2++)
    decTable[encTable[i2].charCodeAt(0)] = i2;
  decTable["-".charCodeAt(0)] = encTable.indexOf("+");
  decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  const protoBase64 = {
    /**
     * Decodes a base64 string to a byte array.
     *
     * - ignores white-space, including line breaks and tabs
     * - allows inner padding (can decode concatenated base64 strings)
     * - does not require padding
     * - understands base64url encoding:
     *   "-" instead of "+",
     *   "_" instead of "/",
     *   no padding
     */
    dec(base64Str) {
      let es2 = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=")
        es2 -= 2;
      else if (base64Str[base64Str.length - 1] == "=")
        es2 -= 1;
      let bytes = new Uint8Array(es2), bytePos = 0, groupPos = 0, b2, p2 = 0;
      for (let i2 = 0; i2 < base64Str.length; i2++) {
        b2 = decTable[base64Str.charCodeAt(i2)];
        if (b2 === void 0) {
          switch (base64Str[i2]) {
            case "=":
              groupPos = 0;
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            default:
              throw Error("invalid base64 string.");
          }
        }
        switch (groupPos) {
          case 0:
            p2 = b2;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p2 << 2 | (b2 & 48) >> 4;
            p2 = b2;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p2 & 15) << 4 | (b2 & 60) >> 2;
            p2 = b2;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p2 & 3) << 6 | b2;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1)
        throw Error("invalid base64 string.");
      return bytes.subarray(0, bytePos);
    },
    /**
     * Encode a byte array to a base64 string.
     */
    enc(bytes) {
      let base64 = "", groupPos = 0, b2, p2 = 0;
      for (let i2 = 0; i2 < bytes.length; i2++) {
        b2 = bytes[i2];
        switch (groupPos) {
          case 0:
            base64 += encTable[b2 >> 2];
            p2 = (b2 & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += encTable[p2 | b2 >> 4];
            p2 = (b2 & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += encTable[p2 | b2 >> 6];
            base64 += encTable[b2 & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += encTable[p2];
        base64 += "=";
        if (groupPos == 1)
          base64 += "=";
      }
      return base64;
    }
  };
  function getExtension(message, extension, options) {
    assertExtendee(extension, message);
    const opt = extension.runtime.bin.makeReadOptions(options);
    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
    const [container, get] = createExtensionContainer(extension);
    for (const uf2 of ufs) {
      extension.runtime.bin.readField(container, opt.readerFactory(uf2.data), extension.field, uf2.wireType, opt);
    }
    return get();
  }
  function setExtension(message, extension, value, options) {
    assertExtendee(extension, message);
    const readOpt = extension.runtime.bin.makeReadOptions(options);
    const writeOpt = extension.runtime.bin.makeWriteOptions(options);
    if (hasExtension(message, extension)) {
      const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf2) => uf2.no != extension.field.no);
      message.getType().runtime.bin.discardUnknownFields(message);
      for (const uf2 of ufs) {
        message.getType().runtime.bin.onUnknownField(message, uf2.no, uf2.wireType, uf2.data);
      }
    }
    const writer = writeOpt.writerFactory();
    let f2 = extension.field;
    if (!f2.opt && !f2.repeated && (f2.kind == "enum" || f2.kind == "scalar")) {
      f2 = Object.assign(Object.assign({}, extension.field), { opt: true });
    }
    extension.runtime.bin.writeField(f2, value, writer, writeOpt);
    const reader = readOpt.readerFactory(writer.finish());
    while (reader.pos < reader.len) {
      const [no2, wireType] = reader.tag();
      const data = reader.skip(wireType, no2);
      message.getType().runtime.bin.onUnknownField(message, no2, wireType, data);
    }
  }
  function hasExtension(message, extension) {
    const messageType = message.getType();
    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf2) => uf2.no == extension.field.no);
  }
  function assertExtendee(extension, message) {
    assert$6(extension.extendee.typeName == message.getType().typeName, `extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
  }
  function isFieldSet(field, target) {
    const localName = field.localName;
    if (field.repeated) {
      return target[localName].length > 0;
    }
    if (field.oneof) {
      return target[field.oneof.localName].case === localName;
    }
    switch (field.kind) {
      case "enum":
      case "scalar":
        if (field.opt || field.req) {
          return target[localName] !== void 0;
        }
        if (field.kind == "enum") {
          return target[localName] !== field.T.values[0].no;
        }
        return !isScalarZeroValue(field.T, target[localName]);
      case "message":
        return target[localName] !== void 0;
      case "map":
        return Object.keys(target[localName]).length > 0;
    }
  }
  function clearField(field, target) {
    const localName = field.localName;
    const implicitPresence = !field.opt && !field.req;
    if (field.repeated) {
      target[localName] = [];
    } else if (field.oneof) {
      target[field.oneof.localName] = { case: void 0 };
    } else {
      switch (field.kind) {
        case "map":
          target[localName] = {};
          break;
        case "enum":
          target[localName] = implicitPresence ? field.T.values[0].no : void 0;
          break;
        case "scalar":
          target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
          break;
        case "message":
          target[localName] = void 0;
          break;
      }
    }
  }
  function isMessage(arg, type) {
    if (arg === null || typeof arg != "object") {
      return false;
    }
    if (!Object.getOwnPropertyNames(Message.prototype).every((m2) => m2 in arg && typeof arg[m2] == "function")) {
      return false;
    }
    const actualType = arg.getType();
    if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
      return false;
    }
    return type === void 0 ? true : actualType.typeName == type.typeName;
  }
  function wrapField(type, value) {
    if (isMessage(value) || !type.fieldWrapper) {
      return value;
    }
    return type.fieldWrapper.wrapField(value);
  }
  ({
    "google.protobuf.DoubleValue": ScalarType.DOUBLE,
    "google.protobuf.FloatValue": ScalarType.FLOAT,
    "google.protobuf.Int64Value": ScalarType.INT64,
    "google.protobuf.UInt64Value": ScalarType.UINT64,
    "google.protobuf.Int32Value": ScalarType.INT32,
    "google.protobuf.UInt32Value": ScalarType.UINT32,
    "google.protobuf.BoolValue": ScalarType.BOOL,
    "google.protobuf.StringValue": ScalarType.STRING,
    "google.protobuf.BytesValue": ScalarType.BYTES
  });
  const jsonReadDefaults = {
    ignoreUnknownFields: false
  };
  const jsonWriteDefaults = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  function makeReadOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
  }
  const tokenNull = Symbol();
  const tokenIgnoredUnknownEnum = Symbol();
  function makeJsonFormat() {
    return {
      makeReadOptions: makeReadOptions$1,
      makeWriteOptions: makeWriteOptions$1,
      readMessage(type, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != "object") {
          throw new Error(`cannot decode message ${type.typeName} from JSON: ${debugJsonValue(json)}`);
        }
        message = message !== null && message !== void 0 ? message : new type();
        const oneofSeen = /* @__PURE__ */ new Map();
        const registry = options.typeRegistry;
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type.fields.findJsonName(jsonKey);
          if (field) {
            if (field.oneof) {
              if (jsonValue === null && field.kind == "scalar") {
                continue;
              }
              const seen = oneofSeen.get(field.oneof);
              if (seen !== void 0) {
                throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
              }
              oneofSeen.set(field.oneof, jsonKey);
            }
            readField$1(message, jsonValue, field, options, type);
          } else {
            let found = false;
            if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
              const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
              if (ext && ext.extendee.typeName == type.typeName) {
                found = true;
                const [container, get] = createExtensionContainer(ext);
                readField$1(container, jsonValue, ext.field, options, ext);
                setExtension(message, ext, get(), options);
              }
            }
            if (!found && !options.ignoreUnknownFields) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: key "${jsonKey}" is unknown`);
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type = message.getType();
        const json = {};
        let field;
        try {
          for (field of type.fields.byNumber()) {
            if (!isFieldSet(field, message)) {
              if (field.req) {
                throw `required field not set`;
              }
              if (!options.emitDefaultValues) {
                continue;
              }
              if (!canEmitFieldDefaultValue(field)) {
                continue;
              }
            }
            const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
            const jsonValue = writeField$1(field, value, options);
            if (jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
          const registry = options.typeRegistry;
          if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
            for (const uf2 of type.runtime.bin.listUnknownFields(message)) {
              const ext = registry.findExtensionFor(type.typeName, uf2.no);
              if (ext && hasExtension(message, ext)) {
                const value = getExtension(message, ext, options);
                const jsonValue = writeField$1(ext.field, value, options);
                if (jsonValue !== void 0) {
                  json[ext.field.jsonName] = jsonValue;
                }
              }
            }
          }
        } catch (e2) {
          const m2 = field ? `cannot encode field ${type.typeName}.${field.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;
          const r2 = e2 instanceof Error ? e2.message : String(e2);
          throw new Error(m2 + (r2.length > 0 ? `: ${r2}` : ""));
        }
        return json;
      },
      readScalar(type, json, longType) {
        return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
      },
      writeScalar(type, value, emitDefaultValues) {
        if (value === void 0) {
          return void 0;
        }
        if (emitDefaultValues || isScalarZeroValue(type, value)) {
          return writeScalar$1(type, value);
        }
        return void 0;
      },
      debug: debugJsonValue
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return "null";
    }
    switch (typeof json) {
      case "object":
        return Array.isArray(json) ? "array" : "object";
      case "string":
        return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
      default:
        return String(json);
    }
  }
  function readField$1(target, jsonValue, field, options, parentType) {
    let localName = field.localName;
    if (field.repeated) {
      assert$6(field.kind != "map");
      if (jsonValue === null) {
        return;
      }
      if (!Array.isArray(jsonValue)) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
      }
      const targetArray = target[localName];
      for (const jsonItem of jsonValue) {
        if (jsonItem === null) {
          throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`);
        }
        switch (field.kind) {
          case "message":
            targetArray.push(field.T.fromJson(jsonItem, options));
            break;
          case "enum":
            const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetArray.push(enumValue);
            }
            break;
          case "scalar":
            try {
              targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));
            } catch (e2) {
              let m2 = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`;
              if (e2 instanceof Error && e2.message.length > 0) {
                m2 += `: ${e2.message}`;
              }
              throw new Error(m2);
            }
            break;
        }
      }
    } else if (field.kind == "map") {
      if (jsonValue === null) {
        return;
      }
      if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
      }
      const targetMap = target[localName];
      for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
        if (jsonMapValue === null) {
          throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: map value null`);
        }
        let key;
        try {
          key = readMapKey(field.K, jsonMapKey);
        } catch (e2) {
          let m2 = `cannot decode map key for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
          if (e2 instanceof Error && e2.message.length > 0) {
            m2 += `: ${e2.message}`;
          }
          throw new Error(m2);
        }
        switch (field.V.kind) {
          case "message":
            targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
            break;
          case "enum":
            const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetMap[key] = enumValue;
            }
            break;
          case "scalar":
            try {
              targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);
            } catch (e2) {
              let m2 = `cannot decode map value for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
              if (e2 instanceof Error && e2.message.length > 0) {
                m2 += `: ${e2.message}`;
              }
              throw new Error(m2);
            }
            break;
        }
      }
    } else {
      if (field.oneof) {
        target = target[field.oneof.localName] = { case: localName };
        localName = "value";
      }
      switch (field.kind) {
        case "message":
          const messageType = field.T;
          if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
            return;
          }
          let currentValue = target[localName];
          if (isMessage(currentValue)) {
            currentValue.fromJson(jsonValue, options);
          } else {
            target[localName] = currentValue = messageType.fromJson(jsonValue, options);
            if (messageType.fieldWrapper && !field.oneof) {
              target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
            }
          }
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
          switch (enumValue) {
            case tokenNull:
              clearField(field, target);
              break;
            case tokenIgnoredUnknownEnum:
              break;
            default:
              target[localName] = enumValue;
              break;
          }
          break;
        case "scalar":
          try {
            const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);
            switch (scalarValue) {
              case tokenNull:
                clearField(field, target);
                break;
              default:
                target[localName] = scalarValue;
                break;
            }
          } catch (e2) {
            let m2 = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
            if (e2 instanceof Error && e2.message.length > 0) {
              m2 += `: ${e2.message}`;
            }
            throw new Error(m2);
          }
          break;
      }
    }
  }
  function readMapKey(type, json) {
    if (type === ScalarType.BOOL) {
      switch (json) {
        case "true":
          json = true;
          break;
        case "false":
          json = false;
          break;
      }
    }
    return readScalar$1(type, json, LongType.BIGINT, true).toString();
  }
  function readScalar$1(type, json, longType, nullAsZeroValue) {
    if (json === null) {
      if (nullAsZeroValue) {
        return scalarZeroValue(type, longType);
      }
      return tokenNull;
    }
    switch (type) {
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === "NaN")
          return Number.NaN;
        if (json === "Infinity")
          return Number.POSITIVE_INFINITY;
        if (json === "-Infinity")
          return Number.NEGATIVE_INFINITY;
        if (json === "") {
          break;
        }
        if (typeof json == "string" && json.trim().length !== json.length) {
          break;
        }
        if (typeof json != "string" && typeof json != "number") {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          break;
        }
        if (!Number.isFinite(float)) {
          break;
        }
        if (type == ScalarType.FLOAT)
          assertFloat32(float);
        return float;
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        let int32;
        if (typeof json == "number")
          int32 = json;
        else if (typeof json == "string" && json.length > 0) {
          if (json.trim().length === json.length)
            int32 = Number(json);
        }
        if (int32 === void 0)
          break;
        if (type == ScalarType.UINT32 || type == ScalarType.FIXED32)
          assertUInt32(int32);
        else
          assertInt32(int32);
        return int32;
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const long = protoInt64.parse(json);
        return longType ? long.toString() : long;
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const uLong = protoInt64.uParse(json);
        return longType ? uLong.toString() : uLong;
      case ScalarType.BOOL:
        if (typeof json !== "boolean")
          break;
        return json;
      case ScalarType.STRING:
        if (typeof json !== "string") {
          break;
        }
        try {
          encodeURIComponent(json);
        } catch (e2) {
          throw new Error("invalid UTF8");
        }
        return json;
      case ScalarType.BYTES:
        if (json === "")
          return new Uint8Array(0);
        if (typeof json !== "string")
          break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
    if (json === null) {
      if (type.typeName == "google.protobuf.NullValue") {
        return 0;
      }
      return nullAsZeroValue ? type.values[0].no : tokenNull;
    }
    switch (typeof json) {
      case "number":
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case "string":
        const value = type.findName(json);
        if (value !== void 0) {
          return value.no;
        }
        if (ignoreUnknownFields) {
          return tokenIgnoredUnknownEnum;
        }
        break;
    }
    throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);
  }
  function canEmitFieldDefaultValue(field) {
    if (field.repeated || field.kind == "map") {
      return true;
    }
    if (field.oneof) {
      return false;
    }
    if (field.kind == "message") {
      return false;
    }
    if (field.opt || field.req) {
      return false;
    }
    return true;
  }
  function writeField$1(field, value, options) {
    if (field.kind == "map") {
      assert$6(typeof value == "object" && value != null);
      const jsonObj = {};
      const entries = Object.entries(value);
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue);
          }
          break;
        case "message":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = entryValue.toJson(options);
          }
          break;
        case "enum":
          const enumType2 = field.V.T;
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeEnum(enumType2, entryValue, options.enumAsInteger);
          }
          break;
      }
      return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
    }
    if (field.repeated) {
      assert$6(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(writeScalar$1(field.T, value[i2]));
          }
          break;
        case "enum":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(writeEnum(field.T, value[i2], options.enumAsInteger));
          }
          break;
        case "message":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(value[i2].toJson(options));
          }
          break;
      }
      return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
    }
    switch (field.kind) {
      case "scalar":
        return writeScalar$1(field.T, value);
      case "enum":
        return writeEnum(field.T, value, options.enumAsInteger);
      case "message":
        return wrapField(field.T, value).toJson(options);
    }
  }
  function writeEnum(type, value, enumAsInteger) {
    var _a3;
    assert$6(typeof value == "number");
    if (type.typeName == "google.protobuf.NullValue") {
      return null;
    }
    if (enumAsInteger) {
      return value;
    }
    const val = type.findNumber(value);
    return (_a3 = val === null || val === void 0 ? void 0 : val.name) !== null && _a3 !== void 0 ? _a3 : value;
  }
  function writeScalar$1(type, value) {
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert$6(typeof value == "number");
        return value;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        assert$6(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      case ScalarType.STRING:
        assert$6(typeof value == "string");
        return value;
      case ScalarType.BOOL:
        assert$6(typeof value == "boolean");
        return value;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert$6(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
        return value.toString();
      case ScalarType.BYTES:
        assert$6(value instanceof Uint8Array);
        return protoBase64.enc(value);
    }
  }
  const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
  const readDefaults = {
    readUnknownFields: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  const writeDefaults = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter()
  };
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormat() {
    return {
      makeReadOptions,
      makeWriteOptions,
      listUnknownFields(message) {
        var _a3;
        return (_a3 = message[unknownFieldsSymbol]) !== null && _a3 !== void 0 ? _a3 : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer) {
        const m2 = message;
        const c2 = m2[unknownFieldsSymbol];
        if (c2) {
          for (const f2 of c2) {
            writer.tag(f2.no, f2.wireType).raw(f2.data);
          }
        }
      },
      onUnknownField(message, no2, wireType, data) {
        const m2 = message;
        if (!Array.isArray(m2[unknownFieldsSymbol])) {
          m2[unknownFieldsSymbol] = [];
        }
        m2[unknownFieldsSymbol].push({ no: no2, wireType, data });
      },
      readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
        const type = message.getType();
        const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
        let fieldNo, wireType;
        while (reader.pos < end) {
          [fieldNo, wireType] = reader.tag();
          if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
            break;
          }
          const field = type.fields.find(fieldNo);
          if (!field) {
            const data = reader.skip(wireType, fieldNo);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data);
            }
            continue;
          }
          readField(message, reader, field, wireType, options);
        }
        if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
        (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
          throw new Error(`invalid end group tag`);
        }
      },
      readField,
      writeMessage(message, writer, options) {
        const type = message.getType();
        for (const field of type.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw new Error(`cannot encode field ${type.typeName}.${field.name} to binary: required field not set`);
            }
            continue;
          }
          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          writeField(field, value, writer, options);
        }
        if (options.writeUnknownFields) {
          this.writeUnknownFields(message, writer);
        }
        return writer;
      },
      writeField(field, value, writer, options) {
        if (value === void 0) {
          return void 0;
        }
        writeField(field, value, writer, options);
      }
    };
  }
  function readField(target, reader, field, wireType, options) {
    let { repeated, localName } = field;
    if (field.oneof) {
      target = target[field.oneof.localName];
      if (target.case != localName) {
        delete target.value;
      }
      target.case = localName;
      localName = "value";
    }
    switch (field.kind) {
      case "scalar":
      case "enum":
        const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        let read = readScalar;
        if (field.kind == "scalar" && field.L > 0) {
          read = readScalarLTString;
        }
        if (repeated) {
          let arr = target[localName];
          const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
          if (isPacked) {
            let e2 = reader.uint32() + reader.pos;
            while (reader.pos < e2) {
              arr.push(read(reader, scalarType));
            }
          } else {
            arr.push(read(reader, scalarType));
          }
        } else {
          target[localName] = read(reader, scalarType);
        }
        break;
      case "message":
        const messageType = field.T;
        if (repeated) {
          target[localName].push(readMessageField(reader, new messageType(), options, field));
        } else {
          if (isMessage(target[localName])) {
            readMessageField(reader, target[localName], options, field);
          } else {
            target[localName] = readMessageField(reader, new messageType(), options, field);
            if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
              target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
            }
          }
        }
        break;
      case "map":
        let [mapKey, mapVal] = readMapEntry(field, reader, options);
        target[localName][mapKey] = mapVal;
        break;
    }
  }
  function readMessageField(reader, message, options, field) {
    const format = message.getType().runtime.bin;
    const delimited = field === null || field === void 0 ? void 0 : field.delimited;
    format.readMessage(
      message,
      reader,
      delimited ? field.no : reader.uint32(),
      // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      options,
      delimited
    );
    return message;
  }
  function readMapEntry(field, reader, options) {
    const length = reader.uint32(), end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
      const [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = readScalar(reader, field.V.T);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = readMessageField(reader, new field.V.T(), options, void 0);
              break;
          }
          break;
      }
    }
    if (key === void 0) {
      key = scalarZeroValue(field.K, LongType.BIGINT);
    }
    if (typeof key != "string" && typeof key != "number") {
      key = key.toString();
    }
    if (val === void 0) {
      switch (field.V.kind) {
        case "scalar":
          val = scalarZeroValue(field.V.T, LongType.BIGINT);
          break;
        case "enum":
          val = field.V.T.values[0].no;
          break;
        case "message":
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  function readScalarLTString(reader, type) {
    const v2 = readScalar(reader, type);
    return typeof v2 == "bigint" ? v2.toString() : v2;
  }
  function readScalar(reader, type) {
    switch (type) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeField(field, value, writer, options) {
    assert$6(value !== void 0);
    const repeated = field.repeated;
    switch (field.kind) {
      case "scalar":
      case "enum":
        let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (repeated) {
          assert$6(Array.isArray(value));
          if (field.packed) {
            writePacked(writer, scalarType, field.no, value);
          } else {
            for (const item of value) {
              writeScalar(writer, scalarType, field.no, item);
            }
          }
        } else {
          writeScalar(writer, scalarType, field.no, value);
        }
        break;
      case "message":
        if (repeated) {
          assert$6(Array.isArray(value));
          for (const item of value) {
            writeMessageField(writer, options, field, item);
          }
        } else {
          writeMessageField(writer, options, field, value);
        }
        break;
      case "map":
        assert$6(typeof value == "object" && value != null);
        for (const [key, val] of Object.entries(value)) {
          writeMapEntry(writer, options, field, key, val);
        }
        break;
    }
  }
  function writeMapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert$6(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    writeScalar(writer, field.K, 1, keyValue);
    switch (field.V.kind) {
      case "scalar":
        writeScalar(writer, field.V.T, 2, value);
        break;
      case "enum":
        writeScalar(writer, ScalarType.INT32, 2, value);
        break;
      case "message":
        assert$6(value !== void 0);
        writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
        break;
    }
    writer.join();
  }
  function writeMessageField(writer, options, field, value) {
    const message = wrapField(field.T, value);
    if (field.delimited)
      writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
    else
      writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
  }
  function writeScalar(writer, type, fieldNo, value) {
    assert$6(value !== void 0);
    let [wireType, method] = scalarTypeInfo(type);
    writer.tag(fieldNo, wireType)[method](value);
  }
  function writePacked(writer, type, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i2 = 0; i2 < value.length; i2++) {
      writer[method](value[i2]);
    }
    writer.join();
  }
  function scalarTypeInfo(type) {
    let wireType = WireType.Varint;
    switch (type) {
      case ScalarType.BYTES:
      case ScalarType.STRING:
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.DOUBLE:
      case ScalarType.FIXED64:
      case ScalarType.SFIXED64:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
    }
    const method = ScalarType[type].toLowerCase();
    return [wireType, method];
  }
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source, target) {
        if (source === void 0) {
          return;
        }
        const type = target.getType();
        for (const member of type.fields.byMember()) {
          const localName = member.localName, t2 = target, s2 = source;
          if (s2[localName] == null) {
            continue;
          }
          switch (member.kind) {
            case "oneof":
              const sk2 = s2[localName].case;
              if (sk2 === void 0) {
                continue;
              }
              const sourceField = member.findField(sk2);
              let val = s2[localName].value;
              if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t2[localName] = { case: sk2, value: val };
              break;
            case "scalar":
            case "enum":
              let copy = s2[localName];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t2[localName] = copy;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k2, v2] of Object.entries(s2[localName])) {
                      t2[localName][k2] = toU8Arr(v2);
                    }
                  } else {
                    Object.assign(t2[localName], s2[localName]);
                  }
                  break;
                case "message":
                  const messageType = member.V.T;
                  for (const k2 of Object.keys(s2[localName])) {
                    let val2 = s2[localName][k2];
                    if (!messageType.fieldWrapper) {
                      val2 = new messageType(val2);
                    }
                    t2[localName][k2] = val2;
                  }
                  break;
              }
              break;
            case "message":
              const mt = member.T;
              if (member.repeated) {
                t2[localName] = s2[localName].map((val2) => isMessage(val2, mt) ? val2 : new mt(val2));
              } else {
                const val2 = s2[localName];
                if (mt.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt.typeName === "google.protobuf.BytesValue"
                  ) {
                    t2[localName] = toU8Arr(val2);
                  } else {
                    t2[localName] = val2;
                  }
                } else {
                  t2[localName] = isMessage(val2, mt) ? val2 : new mt(val2);
                }
              }
              break;
          }
        }
      },
      // TODO use isFieldSet() here to support future field presence
      equals(type, a, b2) {
        if (a === b2) {
          return true;
        }
        if (!a || !b2) {
          return false;
        }
        return type.fields.byMember().every((m2) => {
          const va2 = a[m2.localName];
          const vb2 = b2[m2.localName];
          if (m2.repeated) {
            if (va2.length !== vb2.length) {
              return false;
            }
            switch (m2.kind) {
              case "message":
                return va2.every((a2, i2) => m2.T.equals(a2, vb2[i2]));
              case "scalar":
                return va2.every((a2, i2) => scalarEquals(m2.T, a2, vb2[i2]));
              case "enum":
                return va2.every((a2, i2) => scalarEquals(ScalarType.INT32, a2, vb2[i2]));
            }
            throw new Error(`repeated cannot contain ${m2.kind}`);
          }
          switch (m2.kind) {
            case "message":
              return m2.T.equals(va2, vb2);
            case "enum":
              return scalarEquals(ScalarType.INT32, va2, vb2);
            case "scalar":
              return scalarEquals(m2.T, va2, vb2);
            case "oneof":
              if (va2.case !== vb2.case) {
                return false;
              }
              const s2 = m2.findField(va2.case);
              if (s2 === void 0) {
                return true;
              }
              switch (s2.kind) {
                case "message":
                  return s2.T.equals(va2.value, vb2.value);
                case "enum":
                  return scalarEquals(ScalarType.INT32, va2.value, vb2.value);
                case "scalar":
                  return scalarEquals(s2.T, va2.value, vb2.value);
              }
              throw new Error(`oneof cannot contain ${s2.kind}`);
            case "map":
              const keys2 = Object.keys(va2).concat(Object.keys(vb2));
              switch (m2.V.kind) {
                case "message":
                  const messageType = m2.V.T;
                  return keys2.every((k2) => messageType.equals(va2[k2], vb2[k2]));
                case "enum":
                  return keys2.every((k2) => scalarEquals(ScalarType.INT32, va2[k2], vb2[k2]));
                case "scalar":
                  const scalarType = m2.V.T;
                  return keys2.every((k2) => scalarEquals(scalarType, va2[k2], vb2[k2]));
              }
              break;
          }
        });
      },
      // TODO use isFieldSet() here to support future field presence
      clone(message) {
        const type = message.getType(), target = new type(), any2 = target;
        for (const member of type.fields.byMember()) {
          const source = message[member.localName];
          let copy;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy = any2[member.localName];
            for (const [key, v2] of Object.entries(source)) {
              copy[key] = cloneSingularField(v2);
            }
          } else if (member.kind == "oneof") {
            const f2 = member.findField(source.case);
            copy = f2 ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
          } else {
            copy = cloneSingularField(source);
          }
          any2[member.localName] = copy;
        }
        for (const uf2 of type.runtime.bin.listUnknownFields(message)) {
          type.runtime.bin.onUnknownField(any2, uf2.no, uf2.wireType, uf2.data);
        }
        return target;
      }
    };
  }
  function cloneSingularField(value) {
    if (value === void 0) {
      return value;
    }
    if (isMessage(value)) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c2 = new Uint8Array(value.byteLength);
      c2.set(value);
      return c2;
    }
    return value;
  }
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }
  function makeProtoRuntime(syntax, newFieldList, initFields) {
    return {
      syntax,
      json: makeJsonFormat(),
      bin: makeBinaryFormat(),
      util: Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList,
        initFields
      }),
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType,
      makeExtension(typeName, extendee, field) {
        return makeExtension(this, typeName, extendee, field);
      }
    };
  }
  class InternalFieldList {
    constructor(fields, normalizer) {
      this._fields = fields;
      this._normalizer = normalizer;
    }
    findJsonName(jsonName) {
      if (!this.jsonNames) {
        const t2 = {};
        for (const f2 of this.list()) {
          t2[f2.jsonName] = t2[f2.name] = f2;
        }
        this.jsonNames = t2;
      }
      return this.jsonNames[jsonName];
    }
    find(fieldNo) {
      if (!this.numbers) {
        const t2 = {};
        for (const f2 of this.list()) {
          t2[f2.no] = f2;
        }
        this.numbers = t2;
      }
      return this.numbers[fieldNo];
    }
    list() {
      if (!this.all) {
        this.all = this._normalizer(this._fields);
      }
      return this.all;
    }
    byNumber() {
      if (!this.numbersAsc) {
        this.numbersAsc = this.list().concat().sort((a, b2) => a.no - b2.no);
      }
      return this.numbersAsc;
    }
    byMember() {
      if (!this.members) {
        this.members = [];
        const a = this.members;
        let o2;
        for (const f2 of this.list()) {
          if (f2.oneof) {
            if (f2.oneof !== o2) {
              o2 = f2.oneof;
              a.push(o2);
            }
          } else {
            a.push(f2);
          }
        }
      }
      return this.members;
    }
  }
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  const fieldJsonName = protoCamelCase;
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b2 = [];
    for (let i2 = 0; i2 < snakeCase.length; i2++) {
      let c2 = snakeCase.charAt(i2);
      switch (c2) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b2.push(c2);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c2 = c2.toUpperCase();
          }
          b2.push(c2);
          break;
      }
    }
    return b2.join("");
  }
  const reservedObjectProperties = /* @__PURE__ */ new Set([
    // names reserved by JavaScript
    "constructor",
    "toString",
    "toJSON",
    "valueOf"
  ]);
  const reservedMessageProperties = /* @__PURE__ */ new Set([
    // names reserved by the runtime
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    // names reserved by the runtime for the future
    "toObject"
  ]);
  const fallback = (name) => `${name}$`;
  const safeMessageProperty = (name) => {
    if (reservedMessageProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  const safeObjectProperty = (name) => {
    if (reservedObjectProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  class InternalOneofInfo {
    constructor(name) {
      this.kind = "oneof";
      this.repeated = false;
      this.packed = false;
      this.opt = false;
      this.req = false;
      this.default = void 0;
      this.fields = [];
      this.name = name;
      this.localName = localOneofName(name);
    }
    addField(field) {
      assert$6(field.oneof === this, `field ${field.name} not one of ${this.name}`);
      this.fields.push(field);
    }
    findField(localName) {
      if (!this._lookup) {
        this._lookup = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < this.fields.length; i2++) {
          this._lookup[this.fields[i2].localName] = this.fields[i2];
        }
      }
      return this._lookup[localName];
    }
  }
  function normalizeFieldInfos(fieldInfos, packedByDefault) {
    var _a3, _b, _c2, _d, _e, _f;
    const r2 = [];
    let o2;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f2 = field;
      f2.localName = localFieldName(field.name, field.oneof !== void 0);
      f2.jsonName = (_a3 = field.jsonName) !== null && _a3 !== void 0 ? _a3 : fieldJsonName(field.name);
      f2.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      if (field.kind == "scalar") {
        f2.L = (_c2 = field.L) !== null && _c2 !== void 0 ? _c2 : LongType.BIGINT;
      }
      f2.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
      f2.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;
      f2.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
      if (field.packed === void 0) {
        if (packedByDefault) {
          f2.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
        } else {
          f2.packed = false;
        }
      }
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o2 || o2.name != ooname) {
          o2 = new InternalOneofInfo(ooname);
        }
        f2.oneof = o2;
        o2.addField(f2);
      }
      r2.push(f2);
    }
    return r2;
  }
  const proto3 = makeProtoRuntime(
    "proto3",
    (fields) => {
      return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, true));
    },
    // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
    (target) => {
      for (const member of target.getType().fields.byMember()) {
        if (member.opt) {
          continue;
        }
        const name = member.localName, t2 = target;
        if (member.repeated) {
          t2[name] = [];
          continue;
        }
        switch (member.kind) {
          case "oneof":
            t2[name] = { case: void 0 };
            break;
          case "enum":
            t2[name] = 0;
            break;
          case "map":
            t2[name] = {};
            break;
          case "scalar":
            t2[name] = scalarZeroValue(member.T, member.L);
            break;
        }
      }
    }
  );
  var MethodKind;
  (function(MethodKind2) {
    MethodKind2[MethodKind2["Unary"] = 0] = "Unary";
    MethodKind2[MethodKind2["ServerStreaming"] = 1] = "ServerStreaming";
    MethodKind2[MethodKind2["ClientStreaming"] = 2] = "ClientStreaming";
    MethodKind2[MethodKind2["BiDiStreaming"] = 3] = "BiDiStreaming";
  })(MethodKind || (MethodKind = {}));
  var MethodIdempotency;
  (function(MethodIdempotency2) {
    MethodIdempotency2[MethodIdempotency2["NoSideEffects"] = 1] = "NoSideEffects";
    MethodIdempotency2[MethodIdempotency2["Idempotent"] = 2] = "Idempotent";
  })(MethodIdempotency || (MethodIdempotency = {}));
  class Timestamp extends Message {
    constructor(data) {
      super();
      this.seconds = protoInt64.zero;
      this.nanos = 0;
      proto3.util.initPartial(data, this);
    }
    fromJson(json, options) {
      if (typeof json !== "string") {
        throw new Error(`cannot decode google.protobuf.Timestamp from JSON: ${proto3.json.debug(json)}`);
      }
      const matches2 = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches2) {
        throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
      }
      const ms = Date.parse(matches2[1] + "-" + matches2[2] + "-" + matches2[3] + "T" + matches2[4] + ":" + matches2[5] + ":" + matches2[6] + (matches2[8] ? matches2[8] : "Z"));
      if (Number.isNaN(ms)) {
        throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
      }
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error(`cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
      }
      this.seconds = protoInt64.parse(ms / 1e3);
      this.nanos = 0;
      if (matches2[7]) {
        this.nanos = parseInt("1" + matches2[7] + "0".repeat(9 - matches2[7].length)) - 1e9;
      }
      return this;
    }
    toJson(options) {
      const ms = Number(this.seconds) * 1e3;
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error(`cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
      }
      if (this.nanos < 0) {
        throw new Error(`cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative`);
      }
      let z2 = "Z";
      if (this.nanos > 0) {
        const nanosStr = (this.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000") {
          z2 = "." + nanosStr.substring(0, 3) + "Z";
        } else if (nanosStr.substring(6) === "000") {
          z2 = "." + nanosStr.substring(0, 6) + "Z";
        } else {
          z2 = "." + nanosStr + "Z";
        }
      }
      return new Date(ms).toISOString().replace(".000Z", z2);
    }
    toDate() {
      return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
    }
    static now() {
      return Timestamp.fromDate(/* @__PURE__ */ new Date());
    }
    static fromDate(date2) {
      const ms = date2.getTime();
      return new Timestamp({
        seconds: protoInt64.parse(Math.floor(ms / 1e3)),
        nanos: ms % 1e3 * 1e6
      });
    }
    static fromBinary(bytes, options) {
      return new Timestamp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Timestamp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Timestamp().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(Timestamp, a, b2);
    }
  }
  Timestamp.runtime = proto3;
  Timestamp.typeName = "google.protobuf.Timestamp";
  Timestamp.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "seconds",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: "nanos",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class Any extends Message {
    constructor(data) {
      super();
      this.typeUrl = "";
      this.value = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      var _a3;
      if (this.typeUrl === "") {
        return {};
      }
      const typeName = this.typeUrlToName(this.typeUrl);
      const messageType = (_a3 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a3 === void 0 ? void 0 : _a3.findMessage(typeName);
      if (!messageType) {
        throw new Error(`cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`);
      }
      const message = messageType.fromBinary(this.value);
      let json = message.toJson(options);
      if (typeName.startsWith("google.protobuf.") || (json === null || Array.isArray(json) || typeof json !== "object")) {
        json = { value: json };
      }
      json["@type"] = this.typeUrl;
      return json;
    }
    fromJson(json, options) {
      var _a3;
      if (json === null || Array.isArray(json) || typeof json != "object") {
        throw new Error(`cannot decode message google.protobuf.Any from JSON: expected object but got ${json === null ? "null" : Array.isArray(json) ? "array" : typeof json}`);
      }
      if (Object.keys(json).length == 0) {
        return this;
      }
      const typeUrl = json["@type"];
      if (typeof typeUrl != "string" || typeUrl == "") {
        throw new Error(`cannot decode message google.protobuf.Any from JSON: "@type" is empty`);
      }
      const typeName = this.typeUrlToName(typeUrl), messageType = (_a3 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a3 === void 0 ? void 0 : _a3.findMessage(typeName);
      if (!messageType) {
        throw new Error(`cannot decode message google.protobuf.Any from JSON: ${typeUrl} is not in the type registry`);
      }
      let message;
      if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json, "value")) {
        message = messageType.fromJson(json["value"], options);
      } else {
        const copy = Object.assign({}, json);
        delete copy["@type"];
        message = messageType.fromJson(copy, options);
      }
      this.packFrom(message);
      return this;
    }
    packFrom(message) {
      this.value = message.toBinary();
      this.typeUrl = this.typeNameToUrl(message.getType().typeName);
    }
    unpackTo(target) {
      if (!this.is(target.getType())) {
        return false;
      }
      target.fromBinary(this.value);
      return true;
    }
    unpack(registry) {
      if (this.typeUrl === "") {
        return void 0;
      }
      const messageType = registry.findMessage(this.typeUrlToName(this.typeUrl));
      if (!messageType) {
        return void 0;
      }
      return messageType.fromBinary(this.value);
    }
    is(type) {
      if (this.typeUrl === "") {
        return false;
      }
      const name = this.typeUrlToName(this.typeUrl);
      let typeName = "";
      if (typeof type === "string") {
        typeName = type;
      } else {
        typeName = type.typeName;
      }
      return name === typeName;
    }
    typeNameToUrl(name) {
      return `type.googleapis.com/${name}`;
    }
    typeUrlToName(url) {
      if (!url.length) {
        throw new Error(`invalid type url: ${url}`);
      }
      const slash = url.lastIndexOf("/");
      const name = slash >= 0 ? url.substring(slash + 1) : url;
      if (!name.length) {
        throw new Error(`invalid type url: ${url}`);
      }
      return name;
    }
    static pack(message) {
      const any2 = new Any();
      any2.packFrom(message);
      return any2;
    }
    static fromBinary(bytes, options) {
      return new Any().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Any().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Any().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(Any, a, b2);
    }
  }
  Any.runtime = proto3;
  Any.typeName = "google.protobuf.Any";
  Any.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "type_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "value",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class DoubleValue extends Message {
    constructor(data) {
      super();
      this.value = 0;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.DOUBLE, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.DOUBLE, json);
      } catch (e2) {
        let m2 = `cannot decode message google.protobuf.DoubleValue from JSON"`;
        if (e2 instanceof Error && e2.message.length > 0) {
          m2 += `: ${e2.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new DoubleValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DoubleValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DoubleValue().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DoubleValue, a, b2);
    }
  }
  DoubleValue.runtime = proto3;
  DoubleValue.typeName = "google.protobuf.DoubleValue";
  DoubleValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    }
  ]);
  DoubleValue.fieldWrapper = {
    wrapField(value) {
      return new DoubleValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class FloatValue extends Message {
    constructor(data) {
      super();
      this.value = 0;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.FLOAT, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.FLOAT, json);
      } catch (e2) {
        let m2 = `cannot decode message google.protobuf.FloatValue from JSON"`;
        if (e2 instanceof Error && e2.message.length > 0) {
          m2 += `: ${e2.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new FloatValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new FloatValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new FloatValue().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(FloatValue, a, b2);
    }
  }
  FloatValue.runtime = proto3;
  FloatValue.typeName = "google.protobuf.FloatValue";
  FloatValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 2
      /* ScalarType.FLOAT */
    }
  ]);
  FloatValue.fieldWrapper = {
    wrapField(value) {
      return new FloatValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class Int64Value extends Message {
    constructor(data) {
      super();
      this.value = protoInt64.zero;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.INT64, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.INT64, json);
      } catch (e2) {
        let m2 = `cannot decode message google.protobuf.Int64Value from JSON"`;
        if (e2 instanceof Error && e2.message.length > 0) {
          m2 += `: ${e2.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new Int64Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Int64Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Int64Value().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(Int64Value, a, b2);
    }
  }
  Int64Value.runtime = proto3;
  Int64Value.typeName = "google.protobuf.Int64Value";
  Int64Value.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]);
  Int64Value.fieldWrapper = {
    wrapField(value) {
      return new Int64Value({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class UInt64Value extends Message {
    constructor(data) {
      super();
      this.value = protoInt64.zero;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.UINT64, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.UINT64, json);
      } catch (e2) {
        let m2 = `cannot decode message google.protobuf.UInt64Value from JSON"`;
        if (e2 instanceof Error && e2.message.length > 0) {
          m2 += `: ${e2.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new UInt64Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UInt64Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UInt64Value().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UInt64Value, a, b2);
    }
  }
  UInt64Value.runtime = proto3;
  UInt64Value.typeName = "google.protobuf.UInt64Value";
  UInt64Value.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    }
  ]);
  UInt64Value.fieldWrapper = {
    wrapField(value) {
      return new UInt64Value({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class Int32Value extends Message {
    constructor(data) {
      super();
      this.value = 0;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.INT32, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.INT32, json);
      } catch (e2) {
        let m2 = `cannot decode message google.protobuf.Int32Value from JSON"`;
        if (e2 instanceof Error && e2.message.length > 0) {
          m2 += `: ${e2.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new Int32Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Int32Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Int32Value().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(Int32Value, a, b2);
    }
  }
  Int32Value.runtime = proto3;
  Int32Value.typeName = "google.protobuf.Int32Value";
  Int32Value.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  Int32Value.fieldWrapper = {
    wrapField(value) {
      return new Int32Value({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class UInt32Value extends Message {
    constructor(data) {
      super();
      this.value = 0;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.UINT32, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.UINT32, json);
      } catch (e2) {
        let m2 = `cannot decode message google.protobuf.UInt32Value from JSON"`;
        if (e2 instanceof Error && e2.message.length > 0) {
          m2 += `: ${e2.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new UInt32Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UInt32Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UInt32Value().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UInt32Value, a, b2);
    }
  }
  UInt32Value.runtime = proto3;
  UInt32Value.typeName = "google.protobuf.UInt32Value";
  UInt32Value.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]);
  UInt32Value.fieldWrapper = {
    wrapField(value) {
      return new UInt32Value({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class BoolValue extends Message {
    constructor(data) {
      super();
      this.value = false;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.BOOL, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.BOOL, json);
      } catch (e2) {
        let m2 = `cannot decode message google.protobuf.BoolValue from JSON"`;
        if (e2 instanceof Error && e2.message.length > 0) {
          m2 += `: ${e2.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new BoolValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new BoolValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new BoolValue().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(BoolValue, a, b2);
    }
  }
  BoolValue.runtime = proto3;
  BoolValue.typeName = "google.protobuf.BoolValue";
  BoolValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  BoolValue.fieldWrapper = {
    wrapField(value) {
      return new BoolValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class StringValue extends Message {
    constructor(data) {
      super();
      this.value = "";
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.STRING, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.STRING, json);
      } catch (e2) {
        let m2 = `cannot decode message google.protobuf.StringValue from JSON"`;
        if (e2 instanceof Error && e2.message.length > 0) {
          m2 += `: ${e2.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new StringValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new StringValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new StringValue().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(StringValue, a, b2);
    }
  }
  StringValue.runtime = proto3;
  StringValue.typeName = "google.protobuf.StringValue";
  StringValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  StringValue.fieldWrapper = {
    wrapField(value) {
      return new StringValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class BytesValue extends Message {
    constructor(data) {
      super();
      this.value = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.BYTES, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.BYTES, json);
      } catch (e2) {
        let m2 = `cannot decode message google.protobuf.BytesValue from JSON"`;
        if (e2 instanceof Error && e2.message.length > 0) {
          m2 += `: ${e2.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new BytesValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new BytesValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new BytesValue().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(BytesValue, a, b2);
    }
  }
  BytesValue.runtime = proto3;
  BytesValue.typeName = "google.protobuf.BytesValue";
  BytesValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  BytesValue.fieldWrapper = {
    wrapField(value) {
      return new BytesValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  var RegistrationInfoStatus;
  (function(RegistrationInfoStatus2) {
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNKNOWN"] = 0] = "UNKNOWN";
    RegistrationInfoStatus2[RegistrationInfoStatus2["AVAILABLE_FREE"] = 1] = "AVAILABLE_FREE";
    RegistrationInfoStatus2[RegistrationInfoStatus2["AVAILABLE_START_CODE_REQUIRED"] = 2] = "AVAILABLE_START_CODE_REQUIRED";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_RESERVED_VERIFIED_DOMAIN"] = 3] = "UNAVAILABLE_RESERVED_VERIFIED_DOMAIN";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_RECOVER_VIA_BACKUP_CODE"] = 4] = "UNAVAILABLE_RECOVER_VIA_BACKUP_CODE";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_RECOVER_VIA_ADMIN"] = 5] = "UNAVAILABLE_RECOVER_VIA_ADMIN";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_RECOVER_VIA_BACKUP_CODE_OR_ADMIN"] = 6] = "UNAVAILABLE_RECOVER_VIA_BACKUP_CODE_OR_ADMIN";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_ADMIN_ACTION_REQUIRED"] = 7] = "UNAVAILABLE_ADMIN_ACTION_REQUIRED";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_NOT_RECOVERABLE"] = 8] = "UNAVAILABLE_NOT_RECOVERABLE";
  })(RegistrationInfoStatus || (RegistrationInfoStatus = {}));
  proto3.util.setEnumType(RegistrationInfoStatus, "domain.RegistrationInfoStatus", [
    { no: 0, name: "REGISTRATION_INFO_STATUS_UNKNOWN" },
    { no: 1, name: "REGISTRATION_INFO_STATUS_AVAILABLE_FREE" },
    { no: 2, name: "REGISTRATION_INFO_STATUS_AVAILABLE_START_CODE_REQUIRED" },
    { no: 3, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_RESERVED_VERIFIED_DOMAIN" },
    { no: 4, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_RECOVER_VIA_BACKUP_CODE" },
    { no: 5, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_RECOVER_VIA_ADMIN" },
    { no: 6, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_RECOVER_VIA_BACKUP_CODE_OR_ADMIN" },
    { no: 7, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_ADMIN_ACTION_REQUIRED" },
    { no: 8, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_NOT_RECOVERABLE" }
  ]);
  const errorGroupFactor = 1e6;
  const pleaseUpdate$3 = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
  var ErrorGroup$1;
  (function(ErrorGroup2) {
    ErrorGroup2[ErrorGroup2["Backend"] = 0] = "Backend";
    ErrorGroup2[ErrorGroup2["BackendClient"] = 1e6] = "BackendClient";
    ErrorGroup2[ErrorGroup2["ClientCore"] = 2e6] = "ClientCore";
    ErrorGroup2[ErrorGroup2["LibVaultCrypto"] = 3e6] = "LibVaultCrypto";
    ErrorGroup2[ErrorGroup2["ClientNodeBridge"] = 4e6] = "ClientNodeBridge";
    ErrorGroup2[ErrorGroup2["ClientWebSdk"] = 5e6] = "ClientWebSdk";
    ErrorGroup2[ErrorGroup2["Heymerge"] = 6e6] = "Heymerge";
  })(ErrorGroup$1 || (ErrorGroup$1 = {}));
  let DomainError$1 = class DomainError extends Error {
    constructor(code, short, userTitle, userDetail) {
      super(short);
      this.code = code;
      this.short = short;
      this.userTitle = userTitle;
      this.userDetail = userDetail;
      this.name = "DomainError";
      Object.setPrototypeOf(this, new.target.prototype);
    }
    codeGroup() {
      return this.code - this.code % errorGroupFactor;
    }
    isClientError() {
      return this.codeGroup() === ErrorGroup$1.ClientCore;
    }
    isBackendError() {
      return this.codeGroup() === ErrorGroup$1.Backend;
    }
    isLibVaultCryptoError() {
      return this.codeGroup() === ErrorGroup$1.LibVaultCrypto;
    }
    isClientWebSdkError() {
      return this.codeGroup() === ErrorGroup$1.ClientWebSdk;
    }
    isHeymergeError() {
      return this.codeGroup() === ErrorGroup$1.Heymerge;
    }
  };
  var BackendClientErrorCode;
  (function(BackendClientErrorCode2) {
    BackendClientErrorCode2[BackendClientErrorCode2["NoResponse"] = 1000400] = "NoResponse";
    BackendClientErrorCode2[BackendClientErrorCode2["InvalidChannelMessage"] = 1000410] = "InvalidChannelMessage";
    BackendClientErrorCode2[BackendClientErrorCode2["InvalidGrpcResponse"] = 1000420] = "InvalidGrpcResponse";
    BackendClientErrorCode2[BackendClientErrorCode2["RequiredFieldMissing"] = 1000430] = "RequiredFieldMissing";
  })(BackendClientErrorCode || (BackendClientErrorCode = {}));
  class BackendClientDomainError extends DomainError$1 {
    constructor(code, short, userTitle, userDetail) {
      super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate$3);
    }
  }
  class NoResponseError extends BackendClientDomainError {
    constructor() {
      super(BackendClientErrorCode.NoResponse, "no response", "No response", `Our server did not respond to the client's request. ${pleaseUpdate$3}`);
    }
  }
  class InvalidGrpcResponseError extends BackendClientDomainError {
    constructor(grpcStatusCode) {
      super(BackendClientErrorCode.InvalidGrpcResponse, `invalid response (${grpcStatusCode})`, "invalid response", `Received an unexpected reply from the server. ${pleaseUpdate$3}`);
      this.grpcStatusCode = grpcStatusCode;
    }
  }
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
  
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
  
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
  function __read$1(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2)
      return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error2) {
      e2 = { error: error2 };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  }
  function __spread$1() {
    for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
      ar = ar.concat(__read$1(arguments[i2]));
    return ar;
  }
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
  
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
  
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
  var __assign$4 = function() {
    __assign$4 = Object.assign || function __assign2(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign$4.apply(this, arguments);
  };
  function __values$1(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2)
      return m2.call(o2);
    if (o2 && typeof o2.length === "number")
      return {
        next: function() {
          if (o2 && i2 >= o2.length)
            o2 = void 0;
          return { value: o2 && o2[i2++], done: !o2 };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2)
      return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error2) {
      e2 = { error: error2 };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
      ar = ar.concat(__read(arguments[i2]));
    return ar;
  }
  function isBrowserBundle() {
    return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
  }
  function isNodeEnv() {
    return !isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
  }
  function dynamicRequire(mod, request) {
    return mod.require(request);
  }
  var fallbackGlobalObject = {};
  function getGlobalObject$1() {
    return isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
  }
  function getGlobalSingleton$1(name, creator, obj) {
    var global2 = obj || getGlobalObject$1();
    var __SENTRY__ = global2.__SENTRY__ = global2.__SENTRY__ || {};
    var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton;
  }
  var objectToString$3 = Object.prototype.toString;
  function isBuiltin$1(wat, ty) {
    return objectToString$3.call(wat) === "[object " + ty + "]";
  }
  function isPlainObject$2(wat) {
    return isBuiltin$1(wat, "Object");
  }
  function isThenable$1(wat) {
    return Boolean(wat && wat.then && typeof wat.then === "function");
  }
  var IS_DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;
  var global$1 = getGlobalObject$1();
  var PREFIX$1 = "Sentry Logger ";
  var CONSOLE_LEVELS$1 = ["debug", "info", "warn", "error", "log", "assert"];
  function consoleSandbox$1(callback) {
    var global2 = getGlobalObject$1();
    if (!("console" in global2)) {
      return callback();
    }
    var originalConsole = global2.console;
    var wrappedLevels = {};
    CONSOLE_LEVELS$1.forEach(function(level) {
      var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
      if (level in global2.console && originalWrappedFunc) {
        wrappedLevels[level] = originalConsole[level];
        originalConsole[level] = originalWrappedFunc;
      }
    });
    try {
      return callback();
    } finally {
      Object.keys(wrappedLevels).forEach(function(level) {
        originalConsole[level] = wrappedLevels[level];
      });
    }
  }
  function makeLogger$1() {
    var enabled = false;
    var logger2 = {
      enable: function() {
        enabled = true;
      },
      disable: function() {
        enabled = false;
      }
    };
    if (IS_DEBUG_BUILD$1) {
      CONSOLE_LEVELS$1.forEach(function(name) {
        logger2[name] = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (enabled) {
            consoleSandbox$1(function() {
              var _a3;
              (_a3 = global$1.console)[name].apply(_a3, __spread([PREFIX$1 + "[" + name + "]:"], args));
            });
          }
        };
      });
    } else {
      CONSOLE_LEVELS$1.forEach(function(name) {
        logger2[name] = function() {
          return void 0;
        };
      });
    }
    return logger2;
  }
  var logger$1;
  if (IS_DEBUG_BUILD$1) {
    logger$1 = getGlobalSingleton$1("logger", makeLogger$1);
  } else {
    logger$1 = makeLogger$1();
  }
  function dropUndefinedKeys$1(val) {
    var e_1, _a3;
    if (isPlainObject$2(val)) {
      var rv = {};
      try {
        for (var _b = __values$1(Object.keys(val)), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
          var key = _c2.value;
          if (typeof val[key] !== "undefined") {
            rv[key] = dropUndefinedKeys$1(val[key]);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return rv;
    }
    if (Array.isArray(val)) {
      return val.map(dropUndefinedKeys$1);
    }
    return val;
  }
  function uuid4$1() {
    var global2 = getGlobalObject$1();
    var crypto2 = global2.crypto || global2.msCrypto;
    if (!(crypto2 === void 0) && crypto2.getRandomValues) {
      var arr = new Uint16Array(8);
      crypto2.getRandomValues(arr);
      arr[3] = arr[3] & 4095 | 16384;
      arr[4] = arr[4] & 16383 | 32768;
      var pad = function(num) {
        var v2 = num.toString(16);
        while (v2.length < 4) {
          v2 = "0" + v2;
        }
        return v2;
      };
      return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    }
    return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
      var r2 = Math.random() * 16 | 0;
      var v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  }
  var SyncPromise$1 = (
    /** @class */
    function() {
      function SyncPromise2(executor) {
        var _this = this;
        this._state = 0;
        this._handlers = [];
        this._resolve = function(value) {
          _this._setResult(1, value);
        };
        this._reject = function(reason) {
          _this._setResult(2, reason);
        };
        this._setResult = function(state, value) {
          if (_this._state !== 0) {
            return;
          }
          if (isThenable$1(value)) {
            void value.then(_this._resolve, _this._reject);
            return;
          }
          _this._state = state;
          _this._value = value;
          _this._executeHandlers();
        };
        this._executeHandlers = function() {
          if (_this._state === 0) {
            return;
          }
          var cachedHandlers = _this._handlers.slice();
          _this._handlers = [];
          cachedHandlers.forEach(function(handler) {
            if (handler[0]) {
              return;
            }
            if (_this._state === 1) {
              handler[1](_this._value);
            }
            if (_this._state === 2) {
              handler[2](_this._value);
            }
            handler[0] = true;
          });
        };
        try {
          executor(this._resolve, this._reject);
        } catch (e2) {
          this._reject(e2);
        }
      }
      SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
        var _this = this;
        return new SyncPromise2(function(resolve, reject) {
          _this._handlers.push([
            false,
            function(result2) {
              if (!onfulfilled) {
                resolve(result2);
              } else {
                try {
                  resolve(onfulfilled(result2));
                } catch (e2) {
                  reject(e2);
                }
              }
            },
            function(reason) {
              if (!onrejected) {
                reject(reason);
              } else {
                try {
                  resolve(onrejected(reason));
                } catch (e2) {
                  reject(e2);
                }
              }
            }
          ]);
          _this._executeHandlers();
        });
      };
      SyncPromise2.prototype.catch = function(onrejected) {
        return this.then(function(val) {
          return val;
        }, onrejected);
      };
      SyncPromise2.prototype.finally = function(onfinally) {
        var _this = this;
        return new SyncPromise2(function(resolve, reject) {
          var val;
          var isRejected;
          return _this.then(function(value) {
            isRejected = false;
            val = value;
            if (onfinally) {
              onfinally();
            }
          }, function(reason) {
            isRejected = true;
            val = reason;
            if (onfinally) {
              onfinally();
            }
          }).then(function() {
            if (isRejected) {
              reject(val);
              return;
            }
            resolve(val);
          });
        });
      };
      return SyncPromise2;
    }()
  );
  var dateTimestampSource = {
    nowSeconds: function() {
      return Date.now() / 1e3;
    }
  };
  function getBrowserPerformance() {
    var performance2 = getGlobalObject$1().performance;
    if (!performance2 || !performance2.now) {
      return void 0;
    }
    var timeOrigin = Date.now() - performance2.now();
    return {
      now: function() {
        return performance2.now();
      },
      timeOrigin
    };
  }
  function getNodePerformance() {
    try {
      var perfHooks = dynamicRequire(module, "perf_hooks");
      return perfHooks.performance;
    } catch (_2) {
      return void 0;
    }
  }
  var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
  var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
    nowSeconds: function() {
      return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
    }
  };
  var dateTimestampInSeconds$1 = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
  var timestampInSeconds$1 = timestampSource.nowSeconds.bind(timestampSource);
  (function() {
    var performance2 = getGlobalObject$1().performance;
    if (!performance2 || !performance2.now) {
      return void 0;
    }
    var threshold = 3600 * 1e3;
    var performanceNow = performance2.now();
    var dateNow = Date.now();
    var timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
    var timeOriginIsReliable = timeOriginDelta < threshold;
    var navigationStart = performance2.timing && performance2.timing.navigationStart;
    var hasNavigationStart = typeof navigationStart === "number";
    var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    var navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
      if (timeOriginDelta <= navigationStartDelta) {
        return performance2.timeOrigin;
      } else {
        return navigationStart;
      }
    }
    return dateNow;
  })();
  var MAX_BREADCRUMBS = 100;
  var Scope$1 = (
    /** @class */
    function() {
      function Scope2() {
        this._notifyingListeners = false;
        this._scopeListeners = [];
        this._eventProcessors = [];
        this._breadcrumbs = [];
        this._user = {};
        this._tags = {};
        this._extra = {};
        this._contexts = {};
        this._sdkProcessingMetadata = {};
      }
      Scope2.clone = function(scope) {
        var newScope = new Scope2();
        if (scope) {
          newScope._breadcrumbs = __spread(scope._breadcrumbs);
          newScope._tags = __assign$4({}, scope._tags);
          newScope._extra = __assign$4({}, scope._extra);
          newScope._contexts = __assign$4({}, scope._contexts);
          newScope._user = scope._user;
          newScope._level = scope._level;
          newScope._span = scope._span;
          newScope._session = scope._session;
          newScope._transactionName = scope._transactionName;
          newScope._fingerprint = scope._fingerprint;
          newScope._eventProcessors = __spread(scope._eventProcessors);
          newScope._requestSession = scope._requestSession;
        }
        return newScope;
      };
      Scope2.prototype.addScopeListener = function(callback) {
        this._scopeListeners.push(callback);
      };
      Scope2.prototype.addEventProcessor = function(callback) {
        this._eventProcessors.push(callback);
        return this;
      };
      Scope2.prototype.setUser = function(user) {
        this._user = user || {};
        if (this._session) {
          this._session.update({ user });
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getUser = function() {
        return this._user;
      };
      Scope2.prototype.getRequestSession = function() {
        return this._requestSession;
      };
      Scope2.prototype.setRequestSession = function(requestSession) {
        this._requestSession = requestSession;
        return this;
      };
      Scope2.prototype.setTags = function(tags) {
        this._tags = __assign$4(__assign$4({}, this._tags), tags);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTag = function(key, value) {
        var _a3;
        this._tags = __assign$4(__assign$4({}, this._tags), (_a3 = {}, _a3[key] = value, _a3));
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setExtras = function(extras) {
        this._extra = __assign$4(__assign$4({}, this._extra), extras);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setExtra = function(key, extra) {
        var _a3;
        this._extra = __assign$4(__assign$4({}, this._extra), (_a3 = {}, _a3[key] = extra, _a3));
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setFingerprint = function(fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setLevel = function(level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTransactionName = function(name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTransaction = function(name) {
        return this.setTransactionName(name);
      };
      Scope2.prototype.setContext = function(key, context) {
        var _a3;
        if (context === null) {
          delete this._contexts[key];
        } else {
          this._contexts = __assign$4(__assign$4({}, this._contexts), (_a3 = {}, _a3[key] = context, _a3));
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setSpan = function(span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getSpan = function() {
        return this._span;
      };
      Scope2.prototype.getTransaction = function() {
        var span = this.getSpan();
        return span && span.transaction;
      };
      Scope2.prototype.setSession = function(session) {
        if (!session) {
          delete this._session;
        } else {
          this._session = session;
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getSession = function() {
        return this._session;
      };
      Scope2.prototype.update = function(captureContext) {
        if (!captureContext) {
          return this;
        }
        if (typeof captureContext === "function") {
          var updatedScope = captureContext(this);
          return updatedScope instanceof Scope2 ? updatedScope : this;
        }
        if (captureContext instanceof Scope2) {
          this._tags = __assign$4(__assign$4({}, this._tags), captureContext._tags);
          this._extra = __assign$4(__assign$4({}, this._extra), captureContext._extra);
          this._contexts = __assign$4(__assign$4({}, this._contexts), captureContext._contexts);
          if (captureContext._user && Object.keys(captureContext._user).length) {
            this._user = captureContext._user;
          }
          if (captureContext._level) {
            this._level = captureContext._level;
          }
          if (captureContext._fingerprint) {
            this._fingerprint = captureContext._fingerprint;
          }
          if (captureContext._requestSession) {
            this._requestSession = captureContext._requestSession;
          }
        } else if (isPlainObject$2(captureContext)) {
          captureContext = captureContext;
          this._tags = __assign$4(__assign$4({}, this._tags), captureContext.tags);
          this._extra = __assign$4(__assign$4({}, this._extra), captureContext.extra);
          this._contexts = __assign$4(__assign$4({}, this._contexts), captureContext.contexts);
          if (captureContext.user) {
            this._user = captureContext.user;
          }
          if (captureContext.level) {
            this._level = captureContext.level;
          }
          if (captureContext.fingerprint) {
            this._fingerprint = captureContext.fingerprint;
          }
          if (captureContext.requestSession) {
            this._requestSession = captureContext.requestSession;
          }
        }
        return this;
      };
      Scope2.prototype.clear = function() {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = void 0;
        this._transactionName = void 0;
        this._fingerprint = void 0;
        this._requestSession = void 0;
        this._span = void 0;
        this._session = void 0;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
        var maxCrumbs = typeof maxBreadcrumbs === "number" ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
        if (maxCrumbs <= 0) {
          return this;
        }
        var mergedBreadcrumb = __assign$4({ timestamp: dateTimestampInSeconds$1() }, breadcrumb);
        this._breadcrumbs = __spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.clearBreadcrumbs = function() {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.applyToEvent = function(event, hint) {
        if (this._extra && Object.keys(this._extra).length) {
          event.extra = __assign$4(__assign$4({}, this._extra), event.extra);
        }
        if (this._tags && Object.keys(this._tags).length) {
          event.tags = __assign$4(__assign$4({}, this._tags), event.tags);
        }
        if (this._user && Object.keys(this._user).length) {
          event.user = __assign$4(__assign$4({}, this._user), event.user);
        }
        if (this._contexts && Object.keys(this._contexts).length) {
          event.contexts = __assign$4(__assign$4({}, this._contexts), event.contexts);
        }
        if (this._level) {
          event.level = this._level;
        }
        if (this._transactionName) {
          event.transaction = this._transactionName;
        }
        if (this._span) {
          event.contexts = __assign$4({ trace: this._span.getTraceContext() }, event.contexts);
          var transactionName = this._span.transaction && this._span.transaction.name;
          if (transactionName) {
            event.tags = __assign$4({ transaction: transactionName }, event.tags);
          }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = __spread(event.breadcrumbs || [], this._breadcrumbs);
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
        event.sdkProcessingMetadata = this._sdkProcessingMetadata;
        return this._notifyEventProcessors(__spread(getGlobalEventProcessors$1(), this._eventProcessors), event, hint);
      };
      Scope2.prototype.setSDKProcessingMetadata = function(newData) {
        this._sdkProcessingMetadata = __assign$4(__assign$4({}, this._sdkProcessingMetadata), newData);
        return this;
      };
      Scope2.prototype._notifyEventProcessors = function(processors, event, hint, index2) {
        var _this = this;
        if (index2 === void 0) {
          index2 = 0;
        }
        return new SyncPromise$1(function(resolve, reject) {
          var processor = processors[index2];
          if (event === null || typeof processor !== "function") {
            resolve(event);
          } else {
            var result2 = processor(__assign$4({}, event), hint);
            if (isThenable$1(result2)) {
              void result2.then(function(final) {
                return _this._notifyEventProcessors(processors, final, hint, index2 + 1).then(resolve);
              }).then(null, reject);
            } else {
              void _this._notifyEventProcessors(processors, result2, hint, index2 + 1).then(resolve).then(null, reject);
            }
          }
        });
      };
      Scope2.prototype._notifyScopeListeners = function() {
        var _this = this;
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach(function(callback) {
            callback(_this);
          });
          this._notifyingListeners = false;
        }
      };
      Scope2.prototype._applyFingerprint = function(event) {
        event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
        if (this._fingerprint) {
          event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        if (event.fingerprint && !event.fingerprint.length) {
          delete event.fingerprint;
        }
      };
      return Scope2;
    }()
  );
  function getGlobalEventProcessors$1() {
    return getGlobalSingleton$1("globalEventProcessors", function() {
      return [];
    });
  }
  var Session$1 = (
    /** @class */
    function() {
      function Session2(context) {
        this.errors = 0;
        this.sid = uuid4$1();
        this.duration = 0;
        this.status = "ok";
        this.init = true;
        this.ignoreDuration = false;
        var startingTime = timestampInSeconds$1();
        this.timestamp = startingTime;
        this.started = startingTime;
        if (context) {
          this.update(context);
        }
      }
      Session2.prototype.update = function(context) {
        if (context === void 0) {
          context = {};
        }
        if (context.user) {
          if (!this.ipAddress && context.user.ip_address) {
            this.ipAddress = context.user.ip_address;
          }
          if (!this.did && !context.did) {
            this.did = context.user.id || context.user.email || context.user.username;
          }
        }
        this.timestamp = context.timestamp || timestampInSeconds$1();
        if (context.ignoreDuration) {
          this.ignoreDuration = context.ignoreDuration;
        }
        if (context.sid) {
          this.sid = context.sid.length === 32 ? context.sid : uuid4$1();
        }
        if (context.init !== void 0) {
          this.init = context.init;
        }
        if (!this.did && context.did) {
          this.did = "" + context.did;
        }
        if (typeof context.started === "number") {
          this.started = context.started;
        }
        if (this.ignoreDuration) {
          this.duration = void 0;
        } else if (typeof context.duration === "number") {
          this.duration = context.duration;
        } else {
          var duration = this.timestamp - this.started;
          this.duration = duration >= 0 ? duration : 0;
        }
        if (context.release) {
          this.release = context.release;
        }
        if (context.environment) {
          this.environment = context.environment;
        }
        if (!this.ipAddress && context.ipAddress) {
          this.ipAddress = context.ipAddress;
        }
        if (!this.userAgent && context.userAgent) {
          this.userAgent = context.userAgent;
        }
        if (typeof context.errors === "number") {
          this.errors = context.errors;
        }
        if (context.status) {
          this.status = context.status;
        }
      };
      Session2.prototype.close = function(status) {
        if (status) {
          this.update({ status });
        } else if (this.status === "ok") {
          this.update({ status: "exited" });
        } else {
          this.update();
        }
      };
      Session2.prototype.toJSON = function() {
        return dropUndefinedKeys$1({
          sid: "" + this.sid,
          init: this.init,
          // Make sure that sec is converted to ms for date constructor
          started: new Date(this.started * 1e3).toISOString(),
          timestamp: new Date(this.timestamp * 1e3).toISOString(),
          status: this.status,
          errors: this.errors,
          did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
          duration: this.duration,
          attrs: {
            release: this.release,
            environment: this.environment,
            ip_address: this.ipAddress,
            user_agent: this.userAgent
          }
        });
      };
      return Session2;
    }()
  );
  var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;
  var API_VERSION$1 = 4;
  var DEFAULT_BREADCRUMBS$1 = 100;
  var Hub$1 = (
    /** @class */
    function() {
      function Hub2(client, scope, _version) {
        if (scope === void 0) {
          scope = new Scope$1();
        }
        if (_version === void 0) {
          _version = API_VERSION$1;
        }
        this._version = _version;
        this._stack = [{}];
        this.getStackTop().scope = scope;
        if (client) {
          this.bindClient(client);
        }
      }
      Hub2.prototype.isOlderThan = function(version) {
        return this._version < version;
      };
      Hub2.prototype.bindClient = function(client) {
        var top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
          client.setupIntegrations();
        }
      };
      Hub2.prototype.pushScope = function() {
        var scope = Scope$1.clone(this.getScope());
        this.getStack().push({
          client: this.getClient(),
          scope
        });
        return scope;
      };
      Hub2.prototype.popScope = function() {
        if (this.getStack().length <= 1)
          return false;
        return !!this.getStack().pop();
      };
      Hub2.prototype.withScope = function(callback) {
        var scope = this.pushScope();
        try {
          callback(scope);
        } finally {
          this.popScope();
        }
      };
      Hub2.prototype.getClient = function() {
        return this.getStackTop().client;
      };
      Hub2.prototype.getScope = function() {
        return this.getStackTop().scope;
      };
      Hub2.prototype.getStack = function() {
        return this._stack;
      };
      Hub2.prototype.getStackTop = function() {
        return this._stack[this._stack.length - 1];
      };
      Hub2.prototype.captureException = function(exception, hint) {
        var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4$1();
        var finalHint = hint;
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error("Sentry syntheticException");
          } catch (exception2) {
            syntheticException = exception2;
          }
          finalHint = {
            originalException: exception,
            syntheticException
          };
        }
        this._invokeClient("captureException", exception, __assign$4(__assign$4({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.captureMessage = function(message, level, hint) {
        var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4$1();
        var finalHint = hint;
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error(message);
          } catch (exception) {
            syntheticException = exception;
          }
          finalHint = {
            originalException: message,
            syntheticException
          };
        }
        this._invokeClient("captureMessage", message, level, __assign$4(__assign$4({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.captureEvent = function(event, hint) {
        var eventId = hint && hint.event_id ? hint.event_id : uuid4$1();
        if (event.type !== "transaction") {
          this._lastEventId = eventId;
        }
        this._invokeClient("captureEvent", event, __assign$4(__assign$4({}, hint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.lastEventId = function() {
        return this._lastEventId;
      };
      Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
        var _a3 = this.getStackTop(), scope = _a3.scope, client = _a3.client;
        if (!scope || !client)
          return;
        var _b = client.getOptions && client.getOptions() || {}, _c2 = _b.beforeBreadcrumb, beforeBreadcrumb = _c2 === void 0 ? null : _c2, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS$1 : _d;
        if (maxBreadcrumbs <= 0)
          return;
        var timestamp = dateTimestampInSeconds$1();
        var mergedBreadcrumb = __assign$4({ timestamp }, breadcrumb);
        var finalBreadcrumb = beforeBreadcrumb ? consoleSandbox$1(function() {
          return beforeBreadcrumb(mergedBreadcrumb, hint);
        }) : mergedBreadcrumb;
        if (finalBreadcrumb === null)
          return;
        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
      };
      Hub2.prototype.setUser = function(user) {
        var scope = this.getScope();
        if (scope)
          scope.setUser(user);
      };
      Hub2.prototype.setTags = function(tags) {
        var scope = this.getScope();
        if (scope)
          scope.setTags(tags);
      };
      Hub2.prototype.setExtras = function(extras) {
        var scope = this.getScope();
        if (scope)
          scope.setExtras(extras);
      };
      Hub2.prototype.setTag = function(key, value) {
        var scope = this.getScope();
        if (scope)
          scope.setTag(key, value);
      };
      Hub2.prototype.setExtra = function(key, extra) {
        var scope = this.getScope();
        if (scope)
          scope.setExtra(key, extra);
      };
      Hub2.prototype.setContext = function(name, context) {
        var scope = this.getScope();
        if (scope)
          scope.setContext(name, context);
      };
      Hub2.prototype.configureScope = function(callback) {
        var _a3 = this.getStackTop(), scope = _a3.scope, client = _a3.client;
        if (scope && client) {
          callback(scope);
        }
      };
      Hub2.prototype.run = function(callback) {
        var oldHub = makeMain$1(this);
        try {
          callback(this);
        } finally {
          makeMain$1(oldHub);
        }
      };
      Hub2.prototype.getIntegration = function(integration) {
        var client = this.getClient();
        if (!client)
          return null;
        try {
          return client.getIntegration(integration);
        } catch (_oO) {
          IS_DEBUG_BUILD && logger$1.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
          return null;
        }
      };
      Hub2.prototype.startSpan = function(context) {
        return this._callExtensionMethod("startSpan", context);
      };
      Hub2.prototype.startTransaction = function(context, customSamplingContext) {
        return this._callExtensionMethod("startTransaction", context, customSamplingContext);
      };
      Hub2.prototype.traceHeaders = function() {
        return this._callExtensionMethod("traceHeaders");
      };
      Hub2.prototype.captureSession = function(endSession2) {
        if (endSession2 === void 0) {
          endSession2 = false;
        }
        if (endSession2) {
          return this.endSession();
        }
        this._sendSessionUpdate();
      };
      Hub2.prototype.endSession = function() {
        var layer = this.getStackTop();
        var scope = layer && layer.scope;
        var session = scope && scope.getSession();
        if (session) {
          session.close();
        }
        this._sendSessionUpdate();
        if (scope) {
          scope.setSession();
        }
      };
      Hub2.prototype.startSession = function(context) {
        var _a3 = this.getStackTop(), scope = _a3.scope, client = _a3.client;
        var _b = client && client.getOptions() || {}, release = _b.release, environment = _b.environment;
        var global2 = getGlobalObject$1();
        var userAgent = (global2.navigator || {}).userAgent;
        var session = new Session$1(__assign$4(__assign$4(__assign$4({
          release,
          environment
        }, scope && { user: scope.getUser() }), userAgent && { userAgent }), context));
        if (scope) {
          var currentSession = scope.getSession && scope.getSession();
          if (currentSession && currentSession.status === "ok") {
            currentSession.update({ status: "exited" });
          }
          this.endSession();
          scope.setSession(session);
        }
        return session;
      };
      Hub2.prototype._sendSessionUpdate = function() {
        var _a3 = this.getStackTop(), scope = _a3.scope, client = _a3.client;
        if (!scope)
          return;
        var session = scope.getSession && scope.getSession();
        if (session) {
          if (client && client.captureSession) {
            client.captureSession(session);
          }
        }
      };
      Hub2.prototype._invokeClient = function(method) {
        var _a3;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
        if (client && client[method]) {
          (_a3 = client)[method].apply(_a3, __spread(args, [scope]));
        }
      };
      Hub2.prototype._callExtensionMethod = function(method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var carrier = getMainCarrier$1();
        var sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
          return sentry.extensions[method].apply(this, args);
        }
        IS_DEBUG_BUILD && logger$1.warn("Extension method " + method + " couldn't be found, doing nothing.");
      };
      return Hub2;
    }()
  );
  function getMainCarrier$1() {
    var carrier = getGlobalObject$1();
    carrier.__SENTRY__ = carrier.__SENTRY__ || {
      extensions: {},
      hub: void 0
    };
    return carrier;
  }
  function makeMain$1(hub) {
    var registry = getMainCarrier$1();
    var oldHub = getHubFromCarrier$1(registry);
    setHubOnCarrier$1(registry, hub);
    return oldHub;
  }
  function getCurrentHub$1() {
    var registry = getMainCarrier$1();
    if (!hasHubOnCarrier$1(registry) || getHubFromCarrier$1(registry).isOlderThan(API_VERSION$1)) {
      setHubOnCarrier$1(registry, new Hub$1());
    }
    if (isNodeEnv()) {
      return getHubFromActiveDomain(registry);
    }
    return getHubFromCarrier$1(registry);
  }
  function getHubFromActiveDomain(registry) {
    try {
      var sentry = getMainCarrier$1().__SENTRY__;
      var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
      if (!activeDomain) {
        return getHubFromCarrier$1(registry);
      }
      if (!hasHubOnCarrier$1(activeDomain) || getHubFromCarrier$1(activeDomain).isOlderThan(API_VERSION$1)) {
        var registryHubTopStack = getHubFromCarrier$1(registry).getStackTop();
        setHubOnCarrier$1(activeDomain, new Hub$1(registryHubTopStack.client, Scope$1.clone(registryHubTopStack.scope)));
      }
      return getHubFromCarrier$1(activeDomain);
    } catch (_Oo) {
      return getHubFromCarrier$1(registry);
    }
  }
  function hasHubOnCarrier$1(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
  }
  function getHubFromCarrier$1(carrier) {
    return getGlobalSingleton$1("hub", function() {
      return new Hub$1();
    }, carrier);
  }
  function setHubOnCarrier$1(carrier, hub) {
    if (!carrier)
      return false;
    var __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    __SENTRY__.hub = hub;
    return true;
  }
  function callOnHub(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var hub = getCurrentHub$1();
    if (hub && hub[method]) {
      return hub[method].apply(hub, __spread$1(args));
    }
    throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
  }
  function captureException$1(exception, captureContext) {
    var syntheticException = new Error("Sentry syntheticException");
    return callOnHub("captureException", exception, {
      captureContext,
      originalException: exception,
      syntheticException
    });
  }
  function addBreadcrumb$1(breadcrumb) {
    callOnHub("addBreadcrumb", breadcrumb);
  }
  function withScope$1(callback) {
    callOnHub("withScope", callback);
  }
  const anyMap$1 = /* @__PURE__ */ new WeakMap();
  const eventsMap$1 = /* @__PURE__ */ new WeakMap();
  const producersMap$1 = /* @__PURE__ */ new WeakMap();
  const anyProducer$1 = Symbol("anyProducer");
  const resolvedPromise$1 = Promise.resolve();
  const listenerAdded$1 = Symbol("listenerAdded");
  const listenerRemoved$1 = Symbol("listenerRemoved");
  function assertEventName$1(eventName) {
    if (typeof eventName !== "string" && typeof eventName !== "symbol") {
      throw new TypeError("eventName must be a string or a symbol");
    }
  }
  function assertListener$1(listener) {
    if (typeof listener !== "function") {
      throw new TypeError("listener must be a function");
    }
  }
  function getListeners$1(instance, eventName) {
    const events = eventsMap$1.get(instance);
    if (!events.has(eventName)) {
      events.set(eventName, /* @__PURE__ */ new Set());
    }
    return events.get(eventName);
  }
  function getEventProducers$1(instance, eventName) {
    const key = typeof eventName === "string" ? eventName : anyProducer$1;
    const producers = producersMap$1.get(instance);
    if (!producers.has(key)) {
      producers.set(key, /* @__PURE__ */ new Set());
    }
    return producers.get(key);
  }
  function enqueueProducers$1(instance, eventName, eventData) {
    const producers = producersMap$1.get(instance);
    if (producers.has(eventName)) {
      for (const producer of producers.get(eventName)) {
        producer.enqueue(eventData);
      }
    }
    if (producers.has(anyProducer$1)) {
      const item = Promise.all([eventName, eventData]);
      for (const producer of producers.get(anyProducer$1)) {
        producer.enqueue(item);
      }
    }
  }
  function iterator$1(instance, eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    let isFinished = false;
    let flush = () => {
    };
    let queue = [];
    const producer = {
      enqueue(item) {
        queue.push(item);
        flush();
      },
      finish() {
        isFinished = true;
        flush();
      }
    };
    for (const eventName of eventNames) {
      getEventProducers$1(instance, eventName).add(producer);
    }
    return {
      async next() {
        if (!queue) {
          return { done: true };
        }
        if (queue.length === 0) {
          if (isFinished) {
            queue = void 0;
            return this.next();
          }
          await new Promise((resolve) => {
            flush = resolve;
          });
          return this.next();
        }
        return {
          done: false,
          value: await queue.shift()
        };
      },
      async return(value) {
        queue = void 0;
        for (const eventName of eventNames) {
          getEventProducers$1(instance, eventName).delete(producer);
        }
        flush();
        return arguments.length > 0 ? { done: true, value: await value } : { done: true };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function defaultMethodNamesOrAssert$1(methodNames) {
    if (methodNames === void 0) {
      return allEmitteryMethods$1;
    }
    if (!Array.isArray(methodNames)) {
      throw new TypeError("`methodNames` must be an array of strings");
    }
    for (const methodName of methodNames) {
      if (!allEmitteryMethods$1.includes(methodName)) {
        if (typeof methodName !== "string") {
          throw new TypeError("`methodNames` element must be a string");
        }
        throw new Error(`${methodName} is not Emittery method`);
      }
    }
    return methodNames;
  }
  const isListenerSymbol$1 = (symbol) => symbol === listenerAdded$1 || symbol === listenerRemoved$1;
  let Emittery$2 = class Emittery2 {
    static mixin(emitteryPropertyName, methodNames) {
      methodNames = defaultMethodNamesOrAssert$1(methodNames);
      return (target) => {
        if (typeof target !== "function") {
          throw new TypeError("`target` must be function");
        }
        for (const methodName of methodNames) {
          if (target.prototype[methodName] !== void 0) {
            throw new Error(`The property \`${methodName}\` already exists on \`target\``);
          }
        }
        function getEmitteryProperty() {
          Object.defineProperty(this, emitteryPropertyName, {
            enumerable: false,
            value: new Emittery2()
          });
          return this[emitteryPropertyName];
        }
        Object.defineProperty(target.prototype, emitteryPropertyName, {
          enumerable: false,
          get: getEmitteryProperty
        });
        const emitteryMethodCaller = (methodName) => function(...args) {
          return this[emitteryPropertyName][methodName](...args);
        };
        for (const methodName of methodNames) {
          Object.defineProperty(target.prototype, methodName, {
            enumerable: false,
            value: emitteryMethodCaller(methodName)
          });
        }
        return target;
      };
    }
    constructor() {
      anyMap$1.set(this, /* @__PURE__ */ new Set());
      eventsMap$1.set(this, /* @__PURE__ */ new Map());
      producersMap$1.set(this, /* @__PURE__ */ new Map());
    }
    on(eventNames, listener) {
      assertListener$1(listener);
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName$1(eventName);
        getListeners$1(this, eventName).add(listener);
        if (!isListenerSymbol$1(eventName)) {
          this.emit(listenerAdded$1, { eventName, listener });
        }
      }
      return this.off.bind(this, eventNames, listener);
    }
    off(eventNames, listener) {
      assertListener$1(listener);
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName$1(eventName);
        getListeners$1(this, eventName).delete(listener);
        if (!isListenerSymbol$1(eventName)) {
          this.emit(listenerRemoved$1, { eventName, listener });
        }
      }
    }
    once(eventNames) {
      return new Promise((resolve) => {
        const off = this.on(eventNames, (data) => {
          off();
          resolve(data);
        });
      });
    }
    events(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName$1(eventName);
      }
      return iterator$1(this, eventNames);
    }
    async emit(eventName, eventData) {
      assertEventName$1(eventName);
      enqueueProducers$1(this, eventName, eventData);
      const listeners = getListeners$1(this, eventName);
      const anyListeners = anyMap$1.get(this);
      const staticListeners = [...listeners];
      const staticAnyListeners = isListenerSymbol$1(eventName) ? [] : [...anyListeners];
      await resolvedPromise$1;
      await Promise.all([
        ...staticListeners.map(async (listener) => {
          if (listeners.has(listener)) {
            return listener(eventData);
          }
        }),
        ...staticAnyListeners.map(async (listener) => {
          if (anyListeners.has(listener)) {
            return listener(eventName, eventData);
          }
        })
      ]);
    }
    async emitSerial(eventName, eventData) {
      assertEventName$1(eventName);
      const listeners = getListeners$1(this, eventName);
      const anyListeners = anyMap$1.get(this);
      const staticListeners = [...listeners];
      const staticAnyListeners = [...anyListeners];
      await resolvedPromise$1;
      for (const listener of staticListeners) {
        if (listeners.has(listener)) {
          await listener(eventData);
        }
      }
      for (const listener of staticAnyListeners) {
        if (anyListeners.has(listener)) {
          await listener(eventName, eventData);
        }
      }
    }
    onAny(listener) {
      assertListener$1(listener);
      anyMap$1.get(this).add(listener);
      this.emit(listenerAdded$1, { listener });
      return this.offAny.bind(this, listener);
    }
    anyEvent() {
      return iterator$1(this);
    }
    offAny(listener) {
      assertListener$1(listener);
      this.emit(listenerRemoved$1, { listener });
      anyMap$1.get(this).delete(listener);
    }
    clearListeners(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        if (typeof eventName === "string") {
          getListeners$1(this, eventName).clear();
          const producers = getEventProducers$1(this, eventName);
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
        } else {
          anyMap$1.get(this).clear();
          for (const listeners of eventsMap$1.get(this).values()) {
            listeners.clear();
          }
          for (const producers of producersMap$1.get(this).values()) {
            for (const producer of producers) {
              producer.finish();
            }
            producers.clear();
          }
        }
      }
    }
    listenerCount(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      let count = 0;
      for (const eventName of eventNames) {
        if (typeof eventName === "string") {
          count += anyMap$1.get(this).size + getListeners$1(this, eventName).size + getEventProducers$1(this, eventName).size + getEventProducers$1(this).size;
          continue;
        }
        if (typeof eventName !== "undefined") {
          assertEventName$1(eventName);
        }
        count += anyMap$1.get(this).size;
        for (const value of eventsMap$1.get(this).values()) {
          count += value.size;
        }
        for (const value of producersMap$1.get(this).values()) {
          count += value.size;
        }
      }
      return count;
    }
    bindMethods(target, methodNames) {
      if (typeof target !== "object" || target === null) {
        throw new TypeError("`target` must be an object");
      }
      methodNames = defaultMethodNamesOrAssert$1(methodNames);
      for (const methodName of methodNames) {
        if (target[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
        Object.defineProperty(target, methodName, {
          enumerable: false,
          value: this[methodName].bind(this)
        });
      }
    }
  };
  const allEmitteryMethods$1 = Object.getOwnPropertyNames(Emittery$2.prototype).filter((v2) => v2 !== "constructor");
  Emittery$2.Typed = class extends Emittery$2 {
  };
  Object.defineProperty(Emittery$2.Typed, "Typed", {
    enumerable: false,
    value: void 0
  });
  Object.defineProperty(Emittery$2, "listenerAdded", {
    value: listenerAdded$1,
    writable: false,
    enumerable: true,
    configurable: false
  });
  Object.defineProperty(Emittery$2, "listenerRemoved", {
    value: listenerRemoved$1,
    writable: false,
    enumerable: true,
    configurable: false
  });
  var emittery$1 = Emittery$2;
  const Emittery$3 = /* @__PURE__ */ getDefaultExportFromCjs(emittery$1);
  class Cancel extends Error {
  }
  const SHOW_DEBUG_MESSAGES_PROP = "showDebugMessages";
  function createProxiedConsole() {
    let showDebugMessages = false;
    const proxyHandler = {
      get(target, prop, receiver) {
        if (prop === SHOW_DEBUG_MESSAGES_PROP) {
          return showDebugMessages;
        }
        if (!showDebugMessages) {
          return () => {
          };
        }
        return Reflect.get(target, prop, receiver);
      },
      set(obj, prop, value) {
        if (prop === SHOW_DEBUG_MESSAGES_PROP) {
          showDebugMessages = value;
          return true;
        }
        return Reflect.set(obj, prop, value);
      }
    };
    return new Proxy(console, proxyHandler);
  }
  const debugConsole = createProxiedConsole();
  var AuthenticatorType;
  (function(AuthenticatorType2) {
    AuthenticatorType2[AuthenticatorType2["UNKNOWN"] = 0] = "UNKNOWN";
    AuthenticatorType2[AuthenticatorType2["PUSH"] = 1] = "PUSH";
    AuthenticatorType2[AuthenticatorType2["BACKUP_CODE"] = 2] = "BACKUP_CODE";
    AuthenticatorType2[AuthenticatorType2["BACKUP_OS"] = 3] = "BACKUP_OS";
    AuthenticatorType2[AuthenticatorType2["DUMMY"] = 4] = "DUMMY";
    AuthenticatorType2[AuthenticatorType2["ORGANIZATION_ADMIN"] = 5] = "ORGANIZATION_ADMIN";
    AuthenticatorType2[AuthenticatorType2["SESSION_UNLOCK"] = 6] = "SESSION_UNLOCK";
    AuthenticatorType2[AuthenticatorType2["WEBAUTHN"] = 7] = "WEBAUTHN";
    AuthenticatorType2[AuthenticatorType2["ORGANIZATION_SERVICE"] = 8] = "ORGANIZATION_SERVICE";
  })(AuthenticatorType || (AuthenticatorType = {}));
  proto3.util.setEnumType(AuthenticatorType, "domain.AuthenticatorType", [
    { no: 0, name: "AUTHENTICATOR_TYPE_UNKNOWN" },
    { no: 1, name: "AUTHENTICATOR_TYPE_PUSH" },
    { no: 2, name: "AUTHENTICATOR_TYPE_BACKUP_CODE" },
    { no: 3, name: "AUTHENTICATOR_TYPE_BACKUP_OS" },
    { no: 4, name: "AUTHENTICATOR_TYPE_DUMMY" },
    { no: 5, name: "AUTHENTICATOR_TYPE_ORGANIZATION_ADMIN" },
    { no: 6, name: "AUTHENTICATOR_TYPE_SESSION_UNLOCK" },
    { no: 7, name: "AUTHENTICATOR_TYPE_WEBAUTHN" },
    { no: 8, name: "AUTHENTICATOR_TYPE_ORGANIZATION_SERVICE" }
  ]);
  var CredentialType;
  (function(CredentialType2) {
    CredentialType2[CredentialType2["UNKNOWN"] = 0] = "UNKNOWN";
    CredentialType2[CredentialType2["SECURITY_KEY"] = 1] = "SECURITY_KEY";
    CredentialType2[CredentialType2["PASSKEY"] = 2] = "PASSKEY";
  })(CredentialType || (CredentialType = {}));
  proto3.util.setEnumType(CredentialType, "domain.CredentialType", [
    { no: 0, name: "CREDENTIAL_TYPE_UNKNOWN" },
    { no: 1, name: "CREDENTIAL_TYPE_SECURITY_KEY" },
    { no: 2, name: "CREDENTIAL_TYPE_PASSKEY" }
  ]);
  var SessionType;
  (function(SessionType2) {
    SessionType2[SessionType2["UNKNOWN"] = 0] = "UNKNOWN";
    SessionType2[SessionType2["SELF_UNLOCKING_PRIMARY"] = 1] = "SELF_UNLOCKING_PRIMARY";
    SessionType2[SessionType2["SELF_UNLOCKING_SECONDARY"] = 2] = "SELF_UNLOCKING_SECONDARY";
    SessionType2[SessionType2["BACKUP_OS"] = 3] = "BACKUP_OS";
    SessionType2[SessionType2["BACKUP_CODE"] = 4] = "BACKUP_CODE";
    SessionType2[SessionType2["CONNECTED"] = 5] = "CONNECTED";
  })(SessionType || (SessionType = {}));
  proto3.util.setEnumType(SessionType, "domain.SessionType", [
    { no: 0, name: "SESSION_TYPE_UNKNOWN" },
    { no: 1, name: "SESSION_TYPE_SELF_UNLOCKING_PRIMARY" },
    { no: 2, name: "SESSION_TYPE_SELF_UNLOCKING_SECONDARY" },
    { no: 3, name: "SESSION_TYPE_BACKUP_OS" },
    { no: 4, name: "SESSION_TYPE_BACKUP_CODE" },
    { no: 5, name: "SESSION_TYPE_CONNECTED" }
  ]);
  var Achievement;
  (function(Achievement2) {
    Achievement2[Achievement2["UNKNOWN"] = 0] = "UNKNOWN";
    Achievement2[Achievement2["BAE_REGISTER_ANDROID"] = 1] = "BAE_REGISTER_ANDROID";
    Achievement2[Achievement2["BAE_REGISTER_IOS"] = 2] = "BAE_REGISTER_IOS";
    Achievement2[Achievement2["BAE_REGISTER_WEB"] = 11] = "BAE_REGISTER_WEB";
    Achievement2[Achievement2["BAE_REGISTER_BAK"] = 12] = "BAE_REGISTER_BAK";
    Achievement2[Achievement2["BAE_INACTIVE_MARKED_FOR_DELETION"] = 3] = "BAE_INACTIVE_MARKED_FOR_DELETION";
    Achievement2[Achievement2["BAE_REACTIVATED"] = 4] = "BAE_REACTIVATED";
    Achievement2[Achievement2["BAE_ORG_ICON_FOUND"] = 5] = "BAE_ORG_ICON_FOUND";
    Achievement2[Achievement2["BAE_LOGIN_RECOVERY"] = 6] = "BAE_LOGIN_RECOVERY";
    Achievement2[Achievement2["BAE_LOGIN_BACKUP"] = 7] = "BAE_LOGIN_BACKUP";
    Achievement2[Achievement2["BAE_PRIVATE_PROFILE_DELETE"] = 8] = "BAE_PRIVATE_PROFILE_DELETE";
    Achievement2[Achievement2["BAE_LOGIN_INBOX_CREATE"] = 9] = "BAE_LOGIN_INBOX_CREATE";
    Achievement2[Achievement2["BAE_LOGIN_INBOX_MESSAGE"] = 10] = "BAE_LOGIN_INBOX_MESSAGE";
    Achievement2[Achievement2["AND_AUTOFILL_SETUP"] = 1e6] = "AND_AUTOFILL_SETUP";
    Achievement2[Achievement2["AND_AUTOFILL_ENABLE"] = 1000001] = "AND_AUTOFILL_ENABLE";
    Achievement2[Achievement2["AND_AUTOFILL_INSERT"] = 1000002] = "AND_AUTOFILL_INSERT";
    Achievement2[Achievement2["AND_AUTOFILL_UPDATE"] = 1000003] = "AND_AUTOFILL_UPDATE";
    Achievement2[Achievement2["AND_BACKUP_REGULAR"] = 1000100] = "AND_BACKUP_REGULAR";
    Achievement2[Achievement2["AND_BACKUP_E2E"] = 1000101] = "AND_BACKUP_E2E";
    Achievement2[Achievement2["AND_BACKUP_TRANSFER"] = 1000102] = "AND_BACKUP_TRANSFER";
    Achievement2[Achievement2["AND_REVIEW_CONDITIONS_FULFILLED"] = 1000200] = "AND_REVIEW_CONDITIONS_FULFILLED";
    Achievement2[Achievement2["AND_REVIEW_SHOWN"] = 1000201] = "AND_REVIEW_SHOWN";
    Achievement2[Achievement2["AND_REVIEW_STAYED_3_SECONDS"] = 1000202] = "AND_REVIEW_STAYED_3_SECONDS";
    Achievement2[Achievement2["AND_SCAN_CAMERA_REQUESTED"] = 1000300] = "AND_SCAN_CAMERA_REQUESTED";
    Achievement2[Achievement2["AND_SCAN_CAMERA_GRANTED"] = 1000301] = "AND_SCAN_CAMERA_GRANTED";
    Achievement2[Achievement2["AND_SCAN_SCANNED"] = 1000302] = "AND_SCAN_SCANNED";
    Achievement2[Achievement2["AND_SCAN_FROM_EXTERNAL"] = 1000303] = "AND_SCAN_FROM_EXTERNAL";
    Achievement2[Achievement2["AND_KEYSTORE_LOST_SHOWN_NO_BACKUP"] = 1000400] = "AND_KEYSTORE_LOST_SHOWN_NO_BACKUP";
    Achievement2[Achievement2["AND_KEYSTORE_LOST_SHOWN_BACKUP_AVAILABLE"] = 1000401] = "AND_KEYSTORE_LOST_SHOWN_BACKUP_AVAILABLE";
    Achievement2[Achievement2["AND_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED"] = 1000500] = "AND_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED";
    Achievement2[Achievement2["WEB_SESSION_CREATE"] = 2e6] = "WEB_SESSION_CREATE";
    Achievement2[Achievement2["WEB_SESSION_UNLOCK"] = 2000001] = "WEB_SESSION_UNLOCK";
    Achievement2[Achievement2["WEB_SESSION_PHONE"] = 2000010] = "WEB_SESSION_PHONE";
    Achievement2[Achievement2["WEB_SESSION_TABLET"] = 2000011] = "WEB_SESSION_TABLET";
    Achievement2[Achievement2["WEB_IMPORT_HEYLOGIN"] = 2000100] = "WEB_IMPORT_HEYLOGIN";
    Achievement2[Achievement2["WEB_IMPORT_BITWARDEN"] = 2000101] = "WEB_IMPORT_BITWARDEN";
    Achievement2[Achievement2["WEB_IMPORT_LASTPASS"] = 2000102] = "WEB_IMPORT_LASTPASS";
    Achievement2[Achievement2["WEB_IMPORT_CHROME"] = 2000103] = "WEB_IMPORT_CHROME";
    Achievement2[Achievement2["WEB_IMPORT_FIREFOX"] = 2000104] = "WEB_IMPORT_FIREFOX";
    Achievement2[Achievement2["WEB_IMPORT_DASHLANE"] = 2000105] = "WEB_IMPORT_DASHLANE";
    Achievement2[Achievement2["WEB_IMPORT_ONEPASSWORD"] = 2000106] = "WEB_IMPORT_ONEPASSWORD";
    Achievement2[Achievement2["WEB_IMPORT_KEEPASS"] = 2000107] = "WEB_IMPORT_KEEPASS";
    Achievement2[Achievement2["WEB_IMPORT_SAFARI"] = 2000108] = "WEB_IMPORT_SAFARI";
    Achievement2[Achievement2["WEB_IMPORT_NORDPASS"] = 2000109] = "WEB_IMPORT_NORDPASS";
    Achievement2[Achievement2["WEB_IMPORT_STICKYPASSWORD"] = 2000110] = "WEB_IMPORT_STICKYPASSWORD";
    Achievement2[Achievement2["WEB_IMPORT_CSV"] = 2000111] = "WEB_IMPORT_CSV";
    Achievement2[Achievement2["WEB_IMPORT_EXCEL"] = 2000112] = "WEB_IMPORT_EXCEL";
    Achievement2[Achievement2["WEB_IMPORT_ENPASS"] = 2000113] = "WEB_IMPORT_ENPASS";
    Achievement2[Achievement2["WEB_EXPORT"] = 2000200] = "WEB_EXPORT";
    Achievement2[Achievement2["WEB_LOGIN_ADD"] = 2000300] = "WEB_LOGIN_ADD";
    Achievement2[Achievement2["WEB_LOGIN_ADD_FIRST_MANUAL"] = 2000301] = "WEB_LOGIN_ADD_FIRST_MANUAL";
    Achievement2[Achievement2["WEB_USE_SEARCH_SHORTCUT"] = 2000302] = "WEB_USE_SEARCH_SHORTCUT";
    Achievement2[Achievement2["WEB_LOGIN_CREATE_SHARE_LINK"] = 2000303] = "WEB_LOGIN_CREATE_SHARE_LINK";
    Achievement2[Achievement2["WEB_PADDLE_SUBSCRIBE_OPENED"] = 2000400] = "WEB_PADDLE_SUBSCRIBE_OPENED";
    Achievement2[Achievement2["WEB_PADDLE_SUBSCRIBE_CLOSED"] = 2000401] = "WEB_PADDLE_SUBSCRIBE_CLOSED";
    Achievement2[Achievement2["WEB_PADDLE_SUBSCRIBE_COMPLETED"] = 2000402] = "WEB_PADDLE_SUBSCRIBE_COMPLETED";
    Achievement2[Achievement2["WEB_PADDLE_MANAGE_OPENED"] = 2000420] = "WEB_PADDLE_MANAGE_OPENED";
    Achievement2[Achievement2["WEB_PADDLE_MANAGE_CLOSED"] = 2000421] = "WEB_PADDLE_MANAGE_CLOSED";
    Achievement2[Achievement2["WEB_PADDLE_MANAGE_COMPLETED"] = 2000422] = "WEB_PADDLE_MANAGE_COMPLETED";
    Achievement2[Achievement2["WEB_ORGANIZATION_CREATE"] = 2000500] = "WEB_ORGANIZATION_CREATE";
    Achievement2[Achievement2["WEB_ORGANIZATION_JOIN"] = 2000501] = "WEB_ORGANIZATION_JOIN";
    Achievement2[Achievement2["WEB_ORGANIZATION_ADMIN_ACCESS_PERSONAL"] = 2000502] = "WEB_ORGANIZATION_ADMIN_ACCESS_PERSONAL";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_ADD_EXISTING"] = 2000510] = "WEB_ORGANIZATION_USER_ADD_EXISTING";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_REMOVE_EXISTING"] = 2000511] = "WEB_ORGANIZATION_USER_REMOVE_EXISTING";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_ADD_NEW"] = 2000512] = "WEB_ORGANIZATION_USER_ADD_NEW";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_REMOVE_NEW"] = 2000513] = "WEB_ORGANIZATION_USER_REMOVE_NEW";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_CHANGE_ACCESS_LEVEL"] = 2000514] = "WEB_ORGANIZATION_USER_CHANGE_ACCESS_LEVEL";
    Achievement2[Achievement2["WEB_ORGANIZATION_TEAM_CREATE"] = 2000520] = "WEB_ORGANIZATION_TEAM_CREATE";
    Achievement2[Achievement2["EXT_INSTALL"] = 3e6] = "EXT_INSTALL";
    Achievement2[Achievement2["EXT_DISABLE_FOR_PAGE"] = 3000001] = "EXT_DISABLE_FOR_PAGE";
    Achievement2[Achievement2["EXT_REPORT_PAGE"] = 3000002] = "EXT_REPORT_PAGE";
    Achievement2[Achievement2["EXT_LOGIN_INSERT"] = 3000100] = "EXT_LOGIN_INSERT";
    Achievement2[Achievement2["EXT_LOGIN_UPDATE"] = 3000101] = "EXT_LOGIN_UPDATE";
    Achievement2[Achievement2["EXT_AUTOSNATCH_FROM_LOGIN"] = 3000110] = "EXT_AUTOSNATCH_FROM_LOGIN";
    Achievement2[Achievement2["EXT_AUTOSNATCH_FROM_REGISTRATION"] = 3000111] = "EXT_AUTOSNATCH_FROM_REGISTRATION";
    Achievement2[Achievement2["EXT_OVERLAY_LOGIN"] = 3000200] = "EXT_OVERLAY_LOGIN";
    Achievement2[Achievement2["EXT_OVERLAY_UNLOCK"] = 3000201] = "EXT_OVERLAY_UNLOCK";
    Achievement2[Achievement2["EXT_OVERLAY_UPDATE_GENERATED_PASSWORD"] = 3000204] = "EXT_OVERLAY_UPDATE_GENERATED_PASSWORD";
    Achievement2[Achievement2["EXT_OVERLAY_DISABLE_AUTOSNATCH"] = 3000004] = "EXT_OVERLAY_DISABLE_AUTOSNATCH";
    Achievement2[Achievement2["EXT_OVERLAY_SAW_NAG_SCREEN"] = 3000005] = "EXT_OVERLAY_SAW_NAG_SCREEN";
    Achievement2[Achievement2["EXT_POPUP_OPEN"] = 3000300] = "EXT_POPUP_OPEN";
    Achievement2[Achievement2["EXT_POPUP_UNLOCK"] = 3000301] = "EXT_POPUP_UNLOCK";
    Achievement2[Achievement2["EXT_POPUP_DISABLE_AUTOSNATCH"] = 3000003] = "EXT_POPUP_DISABLE_AUTOSNATCH";
    Achievement2[Achievement2["EXT_OMNIBOX_INPUT_CHANGED"] = 3000400] = "EXT_OMNIBOX_INPUT_CHANGED";
    Achievement2[Achievement2["EXT_OMNIBOX_INPUT_ENTERED"] = 3000401] = "EXT_OMNIBOX_INPUT_ENTERED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_HEYLOGIN_ENABLED"] = 3000500] = "EXT_CONTEXT_MENU_HEYLOGIN_ENABLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_USERNAME_FILLED"] = 3000510] = "EXT_CONTEXT_MENU_USERNAME_FILLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_PASSWORD_FILLED"] = 3000511] = "EXT_CONTEXT_MENU_PASSWORD_FILLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_CUSTOM_TOTP_FILLED"] = 3000512] = "EXT_CONTEXT_MENU_CUSTOM_TOTP_FILLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_CUSTOM_PLAIN_FILLED"] = 3000513] = "EXT_CONTEXT_MENU_CUSTOM_PLAIN_FILLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_CUSTOM_PROTECTED_FILLED"] = 3000514] = "EXT_CONTEXT_MENU_CUSTOM_PROTECTED_FILLED";
    Achievement2[Achievement2["EXT_GLOBAL_SEARCH_OPEN"] = 3000600] = "EXT_GLOBAL_SEARCH_OPEN";
    Achievement2[Achievement2["EXT_GLOBAL_SEARCH_UNLOCK"] = 3000601] = "EXT_GLOBAL_SEARCH_UNLOCK";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_1"] = 4e6] = "COR_LOGINS_TOTAL_1";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_2"] = 4000001] = "COR_LOGINS_TOTAL_2";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_4"] = 4000002] = "COR_LOGINS_TOTAL_4";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_8"] = 4000003] = "COR_LOGINS_TOTAL_8";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_16"] = 4000004] = "COR_LOGINS_TOTAL_16";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_32"] = 4000005] = "COR_LOGINS_TOTAL_32";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_64"] = 4000006] = "COR_LOGINS_TOTAL_64";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_128"] = 4000007] = "COR_LOGINS_TOTAL_128";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_256"] = 4000008] = "COR_LOGINS_TOTAL_256";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_512"] = 4000009] = "COR_LOGINS_TOTAL_512";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_1024"] = 4000010] = "COR_LOGINS_TOTAL_1024";
    Achievement2[Achievement2["COR_STORE_BACKUP_CODE_META_VAULT"] = 4000011] = "COR_STORE_BACKUP_CODE_META_VAULT";
    Achievement2[Achievement2["COR_LINKED_LOGIN_CREATE_PERSONAL"] = 4000012] = "COR_LINKED_LOGIN_CREATE_PERSONAL";
    Achievement2[Achievement2["COR_LINKED_LOGIN_CREATE_TEAM"] = 4000013] = "COR_LINKED_LOGIN_CREATE_TEAM";
    Achievement2[Achievement2["IOS_AUTOFILL_GUIDE_SETUP"] = 5e6] = "IOS_AUTOFILL_GUIDE_SETUP";
    Achievement2[Achievement2["IOS_AUTOFILL_ENABLE"] = 5000001] = "IOS_AUTOFILL_ENABLE";
    Achievement2[Achievement2["IOS_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED"] = 5000100] = "IOS_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED";
  })(Achievement || (Achievement = {}));
  proto3.util.setEnumType(Achievement, "domain.Achievement", [
    { no: 0, name: "UNKNOWN" },
    { no: 1, name: "BAE_REGISTER_ANDROID" },
    { no: 2, name: "BAE_REGISTER_IOS" },
    { no: 11, name: "BAE_REGISTER_WEB" },
    { no: 12, name: "BAE_REGISTER_BAK" },
    { no: 3, name: "BAE_INACTIVE_MARKED_FOR_DELETION" },
    { no: 4, name: "BAE_REACTIVATED" },
    { no: 5, name: "BAE_ORG_ICON_FOUND" },
    { no: 6, name: "BAE_LOGIN_RECOVERY" },
    { no: 7, name: "BAE_LOGIN_BACKUP" },
    { no: 8, name: "BAE_PRIVATE_PROFILE_DELETE" },
    { no: 9, name: "BAE_LOGIN_INBOX_CREATE" },
    { no: 10, name: "BAE_LOGIN_INBOX_MESSAGE" },
    { no: 1e6, name: "AND_AUTOFILL_SETUP" },
    { no: 1000001, name: "AND_AUTOFILL_ENABLE" },
    { no: 1000002, name: "AND_AUTOFILL_INSERT" },
    { no: 1000003, name: "AND_AUTOFILL_UPDATE" },
    { no: 1000100, name: "AND_BACKUP_REGULAR" },
    { no: 1000101, name: "AND_BACKUP_E2E" },
    { no: 1000102, name: "AND_BACKUP_TRANSFER" },
    { no: 1000200, name: "AND_REVIEW_CONDITIONS_FULFILLED" },
    { no: 1000201, name: "AND_REVIEW_SHOWN" },
    { no: 1000202, name: "AND_REVIEW_STAYED_3_SECONDS" },
    { no: 1000300, name: "AND_SCAN_CAMERA_REQUESTED" },
    { no: 1000301, name: "AND_SCAN_CAMERA_GRANTED" },
    { no: 1000302, name: "AND_SCAN_SCANNED" },
    { no: 1000303, name: "AND_SCAN_FROM_EXTERNAL" },
    { no: 1000400, name: "AND_KEYSTORE_LOST_SHOWN_NO_BACKUP" },
    { no: 1000401, name: "AND_KEYSTORE_LOST_SHOWN_BACKUP_AVAILABLE" },
    { no: 1000500, name: "AND_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED" },
    { no: 2e6, name: "WEB_SESSION_CREATE" },
    { no: 2000001, name: "WEB_SESSION_UNLOCK" },
    { no: 2000010, name: "WEB_SESSION_PHONE" },
    { no: 2000011, name: "WEB_SESSION_TABLET" },
    { no: 2000100, name: "WEB_IMPORT_HEYLOGIN" },
    { no: 2000101, name: "WEB_IMPORT_BITWARDEN" },
    { no: 2000102, name: "WEB_IMPORT_LASTPASS" },
    { no: 2000103, name: "WEB_IMPORT_CHROME" },
    { no: 2000104, name: "WEB_IMPORT_FIREFOX" },
    { no: 2000105, name: "WEB_IMPORT_DASHLANE" },
    { no: 2000106, name: "WEB_IMPORT_ONEPASSWORD" },
    { no: 2000107, name: "WEB_IMPORT_KEEPASS" },
    { no: 2000108, name: "WEB_IMPORT_SAFARI" },
    { no: 2000109, name: "WEB_IMPORT_NORDPASS" },
    { no: 2000110, name: "WEB_IMPORT_STICKYPASSWORD" },
    { no: 2000111, name: "WEB_IMPORT_CSV" },
    { no: 2000112, name: "WEB_IMPORT_EXCEL" },
    { no: 2000113, name: "WEB_IMPORT_ENPASS" },
    { no: 2000200, name: "WEB_EXPORT" },
    { no: 2000300, name: "WEB_LOGIN_ADD" },
    { no: 2000301, name: "WEB_LOGIN_ADD_FIRST_MANUAL" },
    { no: 2000302, name: "WEB_USE_SEARCH_SHORTCUT" },
    { no: 2000303, name: "WEB_LOGIN_CREATE_SHARE_LINK" },
    { no: 2000400, name: "WEB_PADDLE_SUBSCRIBE_OPENED" },
    { no: 2000401, name: "WEB_PADDLE_SUBSCRIBE_CLOSED" },
    { no: 2000402, name: "WEB_PADDLE_SUBSCRIBE_COMPLETED" },
    { no: 2000420, name: "WEB_PADDLE_MANAGE_OPENED" },
    { no: 2000421, name: "WEB_PADDLE_MANAGE_CLOSED" },
    { no: 2000422, name: "WEB_PADDLE_MANAGE_COMPLETED" },
    { no: 2000500, name: "WEB_ORGANIZATION_CREATE" },
    { no: 2000501, name: "WEB_ORGANIZATION_JOIN" },
    { no: 2000502, name: "WEB_ORGANIZATION_ADMIN_ACCESS_PERSONAL" },
    { no: 2000510, name: "WEB_ORGANIZATION_USER_ADD_EXISTING" },
    { no: 2000511, name: "WEB_ORGANIZATION_USER_REMOVE_EXISTING" },
    { no: 2000512, name: "WEB_ORGANIZATION_USER_ADD_NEW" },
    { no: 2000513, name: "WEB_ORGANIZATION_USER_REMOVE_NEW" },
    { no: 2000514, name: "WEB_ORGANIZATION_USER_CHANGE_ACCESS_LEVEL" },
    { no: 2000520, name: "WEB_ORGANIZATION_TEAM_CREATE" },
    { no: 3e6, name: "EXT_INSTALL" },
    { no: 3000001, name: "EXT_DISABLE_FOR_PAGE" },
    { no: 3000002, name: "EXT_REPORT_PAGE" },
    { no: 3000100, name: "EXT_LOGIN_INSERT" },
    { no: 3000101, name: "EXT_LOGIN_UPDATE" },
    { no: 3000110, name: "EXT_AUTOSNATCH_FROM_LOGIN" },
    { no: 3000111, name: "EXT_AUTOSNATCH_FROM_REGISTRATION" },
    { no: 3000200, name: "EXT_OVERLAY_LOGIN" },
    { no: 3000201, name: "EXT_OVERLAY_UNLOCK" },
    { no: 3000204, name: "EXT_OVERLAY_UPDATE_GENERATED_PASSWORD" },
    { no: 3000004, name: "EXT_OVERLAY_DISABLE_AUTOSNATCH" },
    { no: 3000005, name: "EXT_OVERLAY_SAW_NAG_SCREEN" },
    { no: 3000300, name: "EXT_POPUP_OPEN" },
    { no: 3000301, name: "EXT_POPUP_UNLOCK" },
    { no: 3000003, name: "EXT_POPUP_DISABLE_AUTOSNATCH" },
    { no: 3000400, name: "EXT_OMNIBOX_INPUT_CHANGED" },
    { no: 3000401, name: "EXT_OMNIBOX_INPUT_ENTERED" },
    { no: 3000500, name: "EXT_CONTEXT_MENU_HEYLOGIN_ENABLED" },
    { no: 3000510, name: "EXT_CONTEXT_MENU_USERNAME_FILLED" },
    { no: 3000511, name: "EXT_CONTEXT_MENU_PASSWORD_FILLED" },
    { no: 3000512, name: "EXT_CONTEXT_MENU_CUSTOM_TOTP_FILLED" },
    { no: 3000513, name: "EXT_CONTEXT_MENU_CUSTOM_PLAIN_FILLED" },
    { no: 3000514, name: "EXT_CONTEXT_MENU_CUSTOM_PROTECTED_FILLED" },
    { no: 3000600, name: "EXT_GLOBAL_SEARCH_OPEN" },
    { no: 3000601, name: "EXT_GLOBAL_SEARCH_UNLOCK" },
    { no: 4e6, name: "COR_LOGINS_TOTAL_1" },
    { no: 4000001, name: "COR_LOGINS_TOTAL_2" },
    { no: 4000002, name: "COR_LOGINS_TOTAL_4" },
    { no: 4000003, name: "COR_LOGINS_TOTAL_8" },
    { no: 4000004, name: "COR_LOGINS_TOTAL_16" },
    { no: 4000005, name: "COR_LOGINS_TOTAL_32" },
    { no: 4000006, name: "COR_LOGINS_TOTAL_64" },
    { no: 4000007, name: "COR_LOGINS_TOTAL_128" },
    { no: 4000008, name: "COR_LOGINS_TOTAL_256" },
    { no: 4000009, name: "COR_LOGINS_TOTAL_512" },
    { no: 4000010, name: "COR_LOGINS_TOTAL_1024" },
    { no: 4000011, name: "COR_STORE_BACKUP_CODE_META_VAULT" },
    { no: 4000012, name: "COR_LINKED_LOGIN_CREATE_PERSONAL" },
    { no: 4000013, name: "COR_LINKED_LOGIN_CREATE_TEAM" },
    { no: 5e6, name: "IOS_AUTOFILL_GUIDE_SETUP" },
    { no: 5000001, name: "IOS_AUTOFILL_ENABLE" },
    { no: 5000100, name: "IOS_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED" }
  ]);
  class UnlockTimeLimit extends Message {
    constructor(data) {
      super();
      this.enabled = false;
      this.minutes = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockTimeLimit().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockTimeLimit().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockTimeLimit().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UnlockTimeLimit, a, b2);
    }
  }
  UnlockTimeLimit.runtime = proto3;
  UnlockTimeLimit.typeName = "domain.UnlockTimeLimit";
  UnlockTimeLimit.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "minutes",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]);
  var VaultType;
  (function(VaultType2) {
    VaultType2[VaultType2["UNKNOWN"] = 0] = "UNKNOWN";
    VaultType2[VaultType2["META"] = 1] = "META";
    VaultType2[VaultType2["PRIVATE"] = 2] = "PRIVATE";
    VaultType2[VaultType2["TEAM"] = 3] = "TEAM";
    VaultType2[VaultType2["TEAM_META"] = 4] = "TEAM_META";
    VaultType2[VaultType2["LEGACY_ORGANIZATION_ADMIN"] = 5] = "LEGACY_ORGANIZATION_ADMIN";
    VaultType2[VaultType2["ORGANIZATION_PERSONAL"] = 6] = "ORGANIZATION_PERSONAL";
    VaultType2[VaultType2["INBOX"] = 7] = "INBOX";
    VaultType2[VaultType2["INBOX_META"] = 8] = "INBOX_META";
    VaultType2[VaultType2["ORGANIZATION_ADMIN"] = 9] = "ORGANIZATION_ADMIN";
  })(VaultType || (VaultType = {}));
  proto3.util.setEnumType(VaultType, "domain.VaultType", [
    { no: 0, name: "VAULT_TYPE_UNKNOWN" },
    { no: 1, name: "VAULT_TYPE_META" },
    { no: 2, name: "VAULT_TYPE_PRIVATE" },
    { no: 3, name: "VAULT_TYPE_TEAM" },
    { no: 4, name: "VAULT_TYPE_TEAM_META" },
    { no: 5, name: "VAULT_TYPE_LEGACY_ORGANIZATION_ADMIN" },
    { no: 6, name: "VAULT_TYPE_ORGANIZATION_PERSONAL" },
    { no: 7, name: "VAULT_TYPE_INBOX" },
    { no: 8, name: "VAULT_TYPE_INBOX_META" },
    { no: 9, name: "VAULT_TYPE_ORGANIZATION_ADMIN" }
  ]);
  var WebauthnPrfSupportStatus;
  (function(WebauthnPrfSupportStatus2) {
    WebauthnPrfSupportStatus2[WebauthnPrfSupportStatus2["UNKNOWN"] = 0] = "UNKNOWN";
    WebauthnPrfSupportStatus2[WebauthnPrfSupportStatus2["UNAVAILABLE"] = 1] = "UNAVAILABLE";
    WebauthnPrfSupportStatus2[WebauthnPrfSupportStatus2["AVAILABLE"] = 2] = "AVAILABLE";
  })(WebauthnPrfSupportStatus || (WebauthnPrfSupportStatus = {}));
  proto3.util.setEnumType(WebauthnPrfSupportStatus, "domain.WebauthnPrfSupportStatus", [
    { no: 0, name: "WEBAUTHN_PRF_SUPPORT_STATUS_UNKNOWN" },
    { no: 1, name: "WEBAUTHN_PRF_SUPPORT_STATUS_UNAVAILABLE" },
    { no: 2, name: "WEBAUTHN_PRF_SUPPORT_STATUS_AVAILABLE" }
  ]);
  var OrganizationType;
  (function(OrganizationType2) {
    OrganizationType2[OrganizationType2["UNKNOWN"] = 0] = "UNKNOWN";
    OrganizationType2[OrganizationType2["COMPANY"] = 1] = "COMPANY";
  })(OrganizationType || (OrganizationType = {}));
  proto3.util.setEnumType(OrganizationType, "domain.OrganizationType", [
    { no: 0, name: "ORGANIZATION_TYPE_UNKNOWN" },
    { no: 1, name: "ORGANIZATION_TYPE_COMPANY" }
  ]);
  let VaultAuthenticatorLock$1 = class VaultAuthenticatorLock2 extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      this.encryptedStorableVaultKey = new Uint8Array(0);
      this.encryptedHighSecurityVaultKey = new Uint8Array(0);
      this.encryptedVaultMessagePrivateKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultAuthenticatorLock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultAuthenticatorLock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultAuthenticatorLock2().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(VaultAuthenticatorLock2, a, b2);
    }
  };
  VaultAuthenticatorLock$1.runtime = proto3;
  VaultAuthenticatorLock$1.typeName = "domain.VaultAuthenticatorLock";
  VaultAuthenticatorLock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  let VaultProfileLock$1 = class VaultProfileLock2 extends Message {
    constructor(data) {
      super();
      this.lockingProfileId = "";
      this.lockingProfileKeyGenerationId = "";
      this.encryptedStorableVaultKey = new Uint8Array(0);
      this.encryptedHighSecurityVaultKey = new Uint8Array(0);
      this.encryptedVaultMessagePrivateKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultProfileLock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultProfileLock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultProfileLock2().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(VaultProfileLock2, a, b2);
    }
  };
  VaultProfileLock$1.runtime = proto3;
  VaultProfileLock$1.typeName = "domain.VaultProfileLock";
  VaultProfileLock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "locking_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "locking_profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  let ProfileAuthenticatorLock$1 = class ProfileAuthenticatorLock2 extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      this.encryptedHighSecurityProfileSeed = new Uint8Array(0);
      this.encryptedStorableProfileSeed = new Uint8Array(0);
      this.profileId = "";
      this.profileKeyGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileAuthenticatorLock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileAuthenticatorLock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileAuthenticatorLock2().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ProfileAuthenticatorLock2, a, b2);
    }
  };
  ProfileAuthenticatorLock$1.runtime = proto3;
  ProfileAuthenticatorLock$1.typeName = "domain.ProfileAuthenticatorLock";
  ProfileAuthenticatorLock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_high_security_profile_seed",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "encrypted_storable_profile_seed",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class VaultLockCreationData extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.associatedVaultId = "";
      this.associatedGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultLockCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultLockCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultLockCreationData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(VaultLockCreationData, a, b2);
    }
  }
  VaultLockCreationData.runtime = proto3;
  VaultLockCreationData.typeName = "domain.VaultLockCreationData";
  VaultLockCreationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 4,
      name: "associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "associated_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "associated_lock", kind: "message", T: VaultProfileLock$1 }
  ]);
  let ProfileProfileLock$1 = class ProfileProfileLock2 extends Message {
    constructor(data) {
      super();
      this.lockingProfileId = "";
      this.lockingProfileKeyGenerationId = "";
      this.encryptedHighSecurityProfileSeed = new Uint8Array(0);
      this.encryptedStorableProfileSeed = new Uint8Array(0);
      this.profileId = "";
      this.profileKeyGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileProfileLock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileProfileLock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileProfileLock2().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ProfileProfileLock2, a, b2);
    }
  };
  ProfileProfileLock$1.runtime = proto3;
  ProfileProfileLock$1.typeName = "domain.ProfileProfileLock";
  ProfileProfileLock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "locking_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "locking_profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "encrypted_high_security_profile_seed",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "encrypted_storable_profile_seed",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class AuthenticatorData extends Message {
    constructor(data) {
      super();
      this.authenticatorType = AuthenticatorType.UNKNOWN;
      this.highSecurityLoginSigPubKey = new Uint8Array(0);
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.secretInfo = "";
      this.secretSalt = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AuthenticatorData, a, b2);
    }
  }
  AuthenticatorData.runtime = proto3;
  AuthenticatorData.typeName = "domain.AuthenticatorData";
  AuthenticatorData.fields = proto3.util.newFieldList(() => [
    { no: 12, name: "authenticator_type", kind: "enum", T: proto3.getEnumType(AuthenticatorType) },
    {
      no: 2,
      name: "high_security_login_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "secret_info",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "secret_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 13, name: "webauthn", kind: "message", T: AuthenticatorData_Webauthn }
  ]);
  class AuthenticatorData_Webauthn extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      this.prfSalt = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorData_Webauthn().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorData_Webauthn().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorData_Webauthn().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AuthenticatorData_Webauthn, a, b2);
    }
  }
  AuthenticatorData_Webauthn.runtime = proto3;
  AuthenticatorData_Webauthn.typeName = "domain.AuthenticatorData.Webauthn";
  AuthenticatorData_Webauthn.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "prf_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class AuthenticatorCreationData extends Message {
    constructor(data) {
      super();
      this.profileLocks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorCreationData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AuthenticatorCreationData, a, b2);
    }
  }
  AuthenticatorCreationData.runtime = proto3;
  AuthenticatorCreationData.typeName = "domain.AuthenticatorCreationData";
  AuthenticatorCreationData.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: AuthenticatorData },
    { no: 2, name: "profile_locks", kind: "message", T: ProfileAuthenticatorLock$1, repeated: true },
    { no: 3, name: "webauthn", kind: "message", T: AuthenticatorCreationData_WebauthnAuthenticatorCreationData }
  ]);
  class AuthenticatorCreationData_WebauthnAuthenticatorCreationData extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      this.prfSalt = new Uint8Array(0);
      this.prfSupportStatus = WebauthnPrfSupportStatus.UNKNOWN;
      this.registerRequestId = "";
      this.responseJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorCreationData_WebauthnAuthenticatorCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorCreationData_WebauthnAuthenticatorCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorCreationData_WebauthnAuthenticatorCreationData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AuthenticatorCreationData_WebauthnAuthenticatorCreationData, a, b2);
    }
  }
  AuthenticatorCreationData_WebauthnAuthenticatorCreationData.runtime = proto3;
  AuthenticatorCreationData_WebauthnAuthenticatorCreationData.typeName = "domain.AuthenticatorCreationData.WebauthnAuthenticatorCreationData";
  AuthenticatorCreationData_WebauthnAuthenticatorCreationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "prf_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 3, name: "prf_support_status", kind: "enum", T: proto3.getEnumType(WebauthnPrfSupportStatus) },
    {
      no: 4,
      name: "register_request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  let Authenticator$1 = class Authenticator2 extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new Authenticator2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Authenticator2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Authenticator2().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(Authenticator2, a, b2);
    }
  };
  Authenticator$1.runtime = proto3;
  Authenticator$1.typeName = "domain.Authenticator";
  Authenticator$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "data", kind: "message", T: AuthenticatorData }
  ]);
  let AuthenticatorBlock$1 = class AuthenticatorBlock2 extends Message {
    constructor(data) {
      super();
      this.blob = new Uint8Array(0);
      this.signature = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorBlock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorBlock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorBlock2().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AuthenticatorBlock2, a, b2);
    }
  };
  AuthenticatorBlock$1.runtime = proto3;
  AuthenticatorBlock$1.typeName = "domain.AuthenticatorBlock";
  AuthenticatorBlock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  var LicenseType;
  (function(LicenseType2) {
    LicenseType2[LicenseType2["UNKNOWN"] = 0] = "UNKNOWN";
    LicenseType2[LicenseType2["NONE"] = 1] = "NONE";
    LicenseType2[LicenseType2["COUPON"] = 2] = "COUPON";
    LicenseType2[LicenseType2["PADDLE"] = 3] = "PADDLE";
    LicenseType2[LicenseType2["NONPROFIT"] = 4] = "NONPROFIT";
    LicenseType2[LicenseType2["CONTRACT"] = 5] = "CONTRACT";
    LicenseType2[LicenseType2["CUSTOM"] = 6] = "CUSTOM";
    LicenseType2[LicenseType2["MSP"] = 7] = "MSP";
    LicenseType2[LicenseType2["EXAMPLE"] = 8] = "EXAMPLE";
  })(LicenseType || (LicenseType = {}));
  proto3.util.setEnumType(LicenseType, "domain.LicenseType", [
    { no: 0, name: "LICENSE_TYPE_UNKNOWN" },
    { no: 1, name: "LICENSE_TYPE_NONE" },
    { no: 2, name: "LICENSE_TYPE_COUPON" },
    { no: 3, name: "LICENSE_TYPE_PADDLE" },
    { no: 4, name: "LICENSE_TYPE_NONPROFIT" },
    { no: 5, name: "LICENSE_TYPE_CONTRACT" },
    { no: 6, name: "LICENSE_TYPE_CUSTOM" },
    { no: 7, name: "LICENSE_TYPE_MSP" },
    { no: 8, name: "LICENSE_TYPE_EXAMPLE" }
  ]);
  var PrimaryLoginDevice;
  (function(PrimaryLoginDevice2) {
    PrimaryLoginDevice2[PrimaryLoginDevice2["UNKNOWN"] = 0] = "UNKNOWN";
    PrimaryLoginDevice2[PrimaryLoginDevice2["NONE"] = 1] = "NONE";
    PrimaryLoginDevice2[PrimaryLoginDevice2["PHONE"] = 2] = "PHONE";
    PrimaryLoginDevice2[PrimaryLoginDevice2["SECURITY_KEY"] = 3] = "SECURITY_KEY";
    PrimaryLoginDevice2[PrimaryLoginDevice2["SERVICE"] = 4] = "SERVICE";
  })(PrimaryLoginDevice || (PrimaryLoginDevice = {}));
  proto3.util.setEnumType(PrimaryLoginDevice, "domain.PrimaryLoginDevice", [
    { no: 0, name: "PRIMARY_LOGIN_DEVICE_UNKNOWN" },
    { no: 1, name: "PRIMARY_LOGIN_DEVICE_NONE" },
    { no: 2, name: "PRIMARY_LOGIN_DEVICE_PHONE" },
    { no: 3, name: "PRIMARY_LOGIN_DEVICE_SECURITY_KEY" },
    { no: 4, name: "PRIMARY_LOGIN_DEVICE_SERVICE" }
  ]);
  var ProfileType;
  (function(ProfileType2) {
    ProfileType2[ProfileType2["UNKNOWN"] = 0] = "UNKNOWN";
    ProfileType2[ProfileType2["PREFERENCES"] = 1] = "PREFERENCES";
    ProfileType2[ProfileType2["INBOX"] = 2] = "INBOX";
    ProfileType2[ProfileType2["PRIVATE"] = 3] = "PRIVATE";
    ProfileType2[ProfileType2["ORGANIZATION"] = 4] = "ORGANIZATION";
    ProfileType2[ProfileType2["ORGANIZATION_ADMIN"] = 5] = "ORGANIZATION_ADMIN";
    ProfileType2[ProfileType2["ORGANIZATION_SERVICE"] = 6] = "ORGANIZATION_SERVICE";
  })(ProfileType || (ProfileType = {}));
  proto3.util.setEnumType(ProfileType, "domain.ProfileType", [
    { no: 0, name: "PROFILE_TYPE_UNKNOWN" },
    { no: 1, name: "PROFILE_TYPE_PREFERENCES" },
    { no: 2, name: "PROFILE_TYPE_INBOX" },
    { no: 3, name: "PROFILE_TYPE_PRIVATE" },
    { no: 4, name: "PROFILE_TYPE_ORGANIZATION" },
    { no: 5, name: "PROFILE_TYPE_ORGANIZATION_ADMIN" },
    { no: 6, name: "PROFILE_TYPE_ORGANIZATION_SERVICE" }
  ]);
  var MaintenanceTask;
  (function(MaintenanceTask2) {
    MaintenanceTask2[MaintenanceTask2["UNKNOWN"] = 0] = "UNKNOWN";
    MaintenanceTask2[MaintenanceTask2["TEAM_SYNC_ORGANIZATION_MEMBERS_V2"] = 9] = "TEAM_SYNC_ORGANIZATION_MEMBERS_V2";
    MaintenanceTask2[MaintenanceTask2["ORGANIZATION_PRELIMINARY_PROFILES_V3"] = 12] = "ORGANIZATION_PRELIMINARY_PROFILES_V3";
    MaintenanceTask2[MaintenanceTask2["ORGANIZATION_MIGRATE_TO_ADMIN_PROFILE_V2"] = 15] = "ORGANIZATION_MIGRATE_TO_ADMIN_PROFILE_V2";
    MaintenanceTask2[MaintenanceTask2["PROCESS_VAULT_MESSAGES_V2"] = 11] = "PROCESS_VAULT_MESSAGES_V2";
    MaintenanceTask2[MaintenanceTask2["MIGRATE_TO_PROFILES_V1"] = 7] = "MIGRATE_TO_PROFILES_V1";
    MaintenanceTask2[MaintenanceTask2["ENABLE_PRF_OPPORTUNISTICALLY_V1"] = 14] = "ENABLE_PRF_OPPORTUNISTICALLY_V1";
  })(MaintenanceTask || (MaintenanceTask = {}));
  proto3.util.setEnumType(MaintenanceTask, "domain.MaintenanceTask", [
    { no: 0, name: "MAINTENANCE_TASK_UNKNOWN" },
    { no: 9, name: "MAINTENANCE_TASK_TEAM_SYNC_ORGANIZATION_MEMBERS_V2" },
    { no: 12, name: "MAINTENANCE_TASK_ORGANIZATION_PRELIMINARY_PROFILES_V3" },
    { no: 15, name: "MAINTENANCE_TASK_ORGANIZATION_MIGRATE_TO_ADMIN_PROFILE_V2" },
    { no: 11, name: "MAINTENANCE_TASK_PROCESS_VAULT_MESSAGES_V2" },
    { no: 7, name: "MAINTENANCE_TASK_MIGRATE_TO_PROFILES_V1" },
    { no: 14, name: "MAINTENANCE_TASK_ENABLE_PRF_OPPORTUNISTICALLY_V1" }
  ]);
  var SyncUpdateField;
  (function(SyncUpdateField2) {
    SyncUpdateField2[SyncUpdateField2["SU_UNKNOWN"] = 0] = "SU_UNKNOWN";
    SyncUpdateField2[SyncUpdateField2["SU_USER"] = 1] = "SU_USER";
    SyncUpdateField2[SyncUpdateField2["SU_SESSIONS"] = 2] = "SU_SESSIONS";
    SyncUpdateField2[SyncUpdateField2["SU_VAULTS"] = 3] = "SU_VAULTS";
    SyncUpdateField2[SyncUpdateField2["SU_ACHIEVEMENTS"] = 4] = "SU_ACHIEVEMENTS";
    SyncUpdateField2[SyncUpdateField2["SU_CHANNELS"] = 5] = "SU_CHANNELS";
    SyncUpdateField2[SyncUpdateField2["SU_ORGANIZATIONS"] = 6] = "SU_ORGANIZATIONS";
    SyncUpdateField2[SyncUpdateField2["SU_RELATED_PROFILES"] = 7] = "SU_RELATED_PROFILES";
    SyncUpdateField2[SyncUpdateField2["SU_PROFILES"] = 8] = "SU_PROFILES";
    SyncUpdateField2[SyncUpdateField2["SU_MAINTENANCE_SETTINGS"] = 9] = "SU_MAINTENANCE_SETTINGS";
  })(SyncUpdateField || (SyncUpdateField = {}));
  proto3.util.setEnumType(SyncUpdateField, "domain.SyncUpdateField", [
    { no: 0, name: "SU_UNKNOWN" },
    { no: 1, name: "SU_USER" },
    { no: 2, name: "SU_SESSIONS" },
    { no: 3, name: "SU_VAULTS" },
    { no: 4, name: "SU_ACHIEVEMENTS" },
    { no: 5, name: "SU_CHANNELS" },
    { no: 6, name: "SU_ORGANIZATIONS" },
    { no: 7, name: "SU_RELATED_PROFILES" },
    { no: 8, name: "SU_PROFILES" },
    { no: 9, name: "SU_MAINTENANCE_SETTINGS" }
  ]);
  var SubscriptionError;
  (function(SubscriptionError2) {
    SubscriptionError2[SubscriptionError2["OK"] = 0] = "OK";
    SubscriptionError2[SubscriptionError2["TRIAL_EXCEEDED"] = 1] = "TRIAL_EXCEEDED";
    SubscriptionError2[SubscriptionError2["PADDLE_PAUSED"] = 2] = "PADDLE_PAUSED";
  })(SubscriptionError || (SubscriptionError = {}));
  proto3.util.setEnumType(SubscriptionError, "domain.SubscriptionError", [
    { no: 0, name: "SUBSCRIPTION_ERROR_OK" },
    { no: 1, name: "SUBSCRIPTION_ERROR_TRIAL_EXCEEDED" },
    { no: 2, name: "SUBSCRIPTION_ERROR_PADDLE_PAUSED" }
  ]);
  class SyncUpdate extends Message {
    constructor(data) {
      super();
      this.syncVersion = protoInt64.zero;
      this.tokenRefreshNeeded = false;
      this.clientOutdated = false;
      this.updatedFields = [];
      this.sessions = [];
      this.vaults = [];
      this.achievements = [];
      this.channels = [];
      this.organizations = [];
      this.relatedProfiles = [];
      this.profiles = [];
      this.preliminaryProfiles = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate, a, b2);
    }
  }
  SyncUpdate.runtime = proto3;
  SyncUpdate.typeName = "domain.SyncUpdate";
  SyncUpdate.fields = proto3.util.newFieldList(() => [
    { no: 7, name: "server_time", kind: "message", T: Timestamp },
    {
      no: 15,
      name: "sync_version",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 21,
      name: "token_refresh_needed",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 22,
      name: "client_outdated",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 11, name: "updated_fields", kind: "enum", T: proto3.getEnumType(SyncUpdateField), repeated: true },
    { no: 4, name: "session_unlock", kind: "message", T: SyncUpdate_SessionUnlock },
    { no: 8, name: "user", kind: "message", T: SyncUpdate_User },
    { no: 1, name: "sessions", kind: "message", T: SyncUpdate_Session, repeated: true },
    { no: 2, name: "vaults", kind: "message", T: SyncUpdate_Vault, repeated: true },
    { no: 6, name: "achievements", kind: "enum", T: proto3.getEnumType(Achievement), repeated: true },
    { no: 3, name: "channels", kind: "message", T: SyncUpdate_Channel, repeated: true },
    { no: 13, name: "organizations", kind: "message", T: SyncUpdate_Organization, repeated: true },
    { no: 18, name: "related_profiles", kind: "message", T: SyncUpdate_RelatedProfile, repeated: true },
    { no: 17, name: "profiles", kind: "message", T: SyncUpdate_Profile, repeated: true },
    { no: 19, name: "maintenance_settings", kind: "message", T: SyncUpdate_MaintenanceSettings },
    { no: 20, name: "preliminary_profiles", kind: "message", T: SyncUpdate_PreliminaryProfile, repeated: true }
  ]);
  class SyncUpdate_Session extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.sessionType = SessionType.UNKNOWN;
      this.clientSettings = "";
      this.enabledProfileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Session().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Session().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Session().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Session, a, b2);
    }
  }
  SyncUpdate_Session.runtime = proto3;
  SyncUpdate_Session.typeName = "domain.SyncUpdate.Session";
  SyncUpdate_Session.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "last_used_at", kind: "message", T: Timestamp },
    { no: 4, name: "unlocked_at", kind: "message", T: Timestamp },
    { no: 5, name: "unlocked_until", kind: "message", T: Timestamp },
    { no: 6, name: "unlock_requested_at", kind: "message", T: Timestamp },
    { no: 12, name: "unlock_extend_at", kind: "message", T: Timestamp },
    { no: 7, name: "created_at", kind: "message", T: Timestamp },
    { no: 9, name: "session_type", kind: "enum", T: proto3.getEnumType(SessionType) },
    {
      no: 8,
      name: "client_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 10, name: "enabled_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 11, name: "unlock_time_limit", kind: "message", T: UnlockTimeLimit }
  ]);
  class SyncUpdate_Vault extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.commitId = "";
      this.generationId = "";
      this.associatedVaultId = "";
      this.organizationId = "";
      this.users = [];
      this.profiles = [];
      this.vaultType = VaultType.UNKNOWN;
      this.dirty = false;
      this.profileKeyGenerationId = "";
      this.adminProfileKeyGenerationId = "";
      this.messagePublicKey = new Uint8Array(0);
      this.hasMessagesQueued = false;
      this.inboxSlug = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Vault().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Vault().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Vault().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Vault, a, b2);
    }
  }
  SyncUpdate_Vault.runtime = proto3;
  SyncUpdate_Vault.typeName = "domain.SyncUpdate.Vault";
  SyncUpdate_Vault.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "users", kind: "message", T: SyncUpdate_Vault_User, repeated: true },
    { no: 11, name: "profiles", kind: "message", T: SyncUpdate_Vault_Profile, repeated: true },
    { no: 5, name: "vault_type", kind: "enum", T: proto3.getEnumType(VaultType) },
    {
      no: 19,
      name: "dirty",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 12,
      name: "profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 18,
      name: "admin_profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 15,
      name: "message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 16,
      name: "has_messages_queued",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 17,
      name: "inbox_slug",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Vault_User extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Vault_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Vault_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Vault_User().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Vault_User, a, b2);
    }
  }
  SyncUpdate_Vault_User.runtime = proto3;
  SyncUpdate_Vault_User.typeName = "domain.SyncUpdate.Vault.User";
  SyncUpdate_Vault_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Vault_Profile extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Vault_Profile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Vault_Profile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Vault_Profile().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Vault_Profile, a, b2);
    }
  }
  SyncUpdate_Vault_Profile.runtime = proto3;
  SyncUpdate_Vault_Profile.typeName = "domain.SyncUpdate.Vault.Profile";
  SyncUpdate_Vault_Profile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Channel extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.channelType = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Channel().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Channel().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Channel().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Channel, a, b2);
    }
  }
  SyncUpdate_Channel.runtime = proto3;
  SyncUpdate_Channel.typeName = "domain.SyncUpdate.Channel";
  SyncUpdate_Channel.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "channel_type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_SessionUnlock extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_SessionUnlock().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_SessionUnlock().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_SessionUnlock().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_SessionUnlock, a, b2);
    }
  }
  SyncUpdate_SessionUnlock.runtime = proto3;
  SyncUpdate_SessionUnlock.typeName = "domain.SyncUpdate.SessionUnlock";
  SyncUpdate_SessionUnlock.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Authenticator extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.authenticatorType = AuthenticatorType.UNKNOWN;
      this.highSecurityLoginSigPubKey = new Uint8Array(0);
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.secretInfo = "";
      this.secretSalt = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Authenticator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Authenticator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Authenticator().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Authenticator, a, b2);
    }
  }
  SyncUpdate_Authenticator.runtime = proto3;
  SyncUpdate_Authenticator.typeName = "domain.SyncUpdate.Authenticator";
  SyncUpdate_Authenticator.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 13, name: "authenticator_type", kind: "enum", T: proto3.getEnumType(AuthenticatorType) },
    {
      no: 3,
      name: "high_security_login_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 11,
      name: "secret_info",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: "secret_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class SyncUpdate_User extends Message {
    constructor(data) {
      super();
      this.serverSideSettings = "";
      this.authenticatorBlockHash = new Uint8Array(0);
      this.preferredLocale = "";
      this.emails = [];
      this.preliminaryEmail = "";
      this.webauthnCredentials = [];
      this.userClientSettings = "";
      this.openUserConfirmationIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_User().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_User, a, b2);
    }
  }
  SyncUpdate_User.runtime = proto3;
  SyncUpdate_User.typeName = "domain.SyncUpdate.User";
  SyncUpdate_User.fields = proto3.util.newFieldList(() => [
    {
      no: 3,
      name: "server_side_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "authenticator_block_hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "preferred_locale",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 7, name: "emails", kind: "message", T: SyncUpdate_User_Email, repeated: true },
    {
      no: 8,
      name: "preliminary_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "webauthn_credentials", kind: "message", T: SyncUpdate_User_WebauthnCredential, repeated: true },
    {
      no: 10,
      name: "user_client_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 11, name: "open_user_confirmation_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class SyncUpdate_User_Email extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.verificationPending = false;
      this.primary = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_User_Email().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_User_Email().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_User_Email().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_User_Email, a, b2);
    }
  }
  SyncUpdate_User_Email.runtime = proto3;
  SyncUpdate_User_Email.typeName = "domain.SyncUpdate.User.Email";
  SyncUpdate_User_Email.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "verification_pending",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: "primary",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class SyncUpdate_User_WebauthnCredential extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      this.aaguid = "";
      this.credentialType = CredentialType.UNKNOWN;
      this.sessionId = "";
      this.prfSupportStatus = WebauthnPrfSupportStatus.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_User_WebauthnCredential().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_User_WebauthnCredential().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_User_WebauthnCredential().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_User_WebauthnCredential, a, b2);
    }
  }
  SyncUpdate_User_WebauthnCredential.runtime = proto3;
  SyncUpdate_User_WebauthnCredential.typeName = "domain.SyncUpdate.User.WebauthnCredential";
  SyncUpdate_User_WebauthnCredential.fields = proto3.util.newFieldList(() => [
    {
      no: 7,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "aaguid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "last_used_at", kind: "message", T: Timestamp },
    { no: 5, name: "credential_type", kind: "enum", T: proto3.getEnumType(CredentialType) },
    {
      no: 6,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 8, name: "prf_support_status", kind: "enum", T: proto3.getEnumType(WebauthnPrfSupportStatus) }
  ]);
  class SyncUpdate_Organization extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.organizationType = OrganizationType.UNKNOWN;
      this.profiles = [];
      this.name = "";
      this.icon = "";
      this.restrictCreateTeam = false;
      this.restrictPersonalLogins = false;
      this.auditlogEnable = false;
      this.childOrganizationManagementEnable = false;
      this.passwordPolicy = "";
      this.isPreliminary = false;
      this.isAdmin = false;
      this.isManager = false;
      this.superUserId = "";
      this.adminProfileId = "";
      this.subscriptionError = SubscriptionError.OK;
      this.verifiedDomain = "";
      this.clientSettings = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Organization().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Organization().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Organization().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Organization, a, b2);
    }
  }
  SyncUpdate_Organization.runtime = proto3;
  SyncUpdate_Organization.typeName = "domain.SyncUpdate.Organization";
  SyncUpdate_Organization.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 20, name: "organization_type", kind: "enum", T: proto3.getEnumType(OrganizationType) },
    { no: 10, name: "profiles", kind: "message", T: SyncUpdate_OrganizationProfile, repeated: true },
    {
      no: 3,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: "restrict_create_team",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 19,
      name: "restrict_personal_logins",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 14,
      name: "auditlog_enable",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 21,
      name: "child_organization_management_enable",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 23,
      name: "password_policy",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 26, name: "unlock_time_limit", kind: "message", T: UnlockTimeLimit },
    {
      no: 13,
      name: "is_preliminary",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: "is_admin",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 24,
      name: "is_manager",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 7,
      name: "super_user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 16,
      name: "admin_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 15, name: "admin_info", kind: "message", T: SyncUpdate_Organization_AdminInfo },
    { no: 11, name: "subscription_error", kind: "enum", T: proto3.getEnumType(SubscriptionError) },
    {
      no: 17,
      name: "verified_domain",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 25,
      name: "client_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 27, name: "parent_organization_info", kind: "message", T: SyncUpdate_Organization_ParentOrganizationInfo }
  ]);
  class SyncUpdate_Organization_AdminInfo extends Message {
    constructor(data) {
      super();
      this.legacyAdminVaultId = "";
      this.entraTenantId = "";
      this.csvIntegrationActive = false;
      this.googleWorkspaceIntegrationActive = false;
      this.licenseType = LicenseType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Organization_AdminInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Organization_AdminInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Organization_AdminInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Organization_AdminInfo, a, b2);
    }
  }
  SyncUpdate_Organization_AdminInfo.runtime = proto3;
  SyncUpdate_Organization_AdminInfo.typeName = "domain.SyncUpdate.Organization.AdminInfo";
  SyncUpdate_Organization_AdminInfo.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "legacy_admin_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "authenticator", kind: "message", T: Authenticator$1 },
    { no: 9, name: "admin_profile", kind: "message", T: SyncUpdate_Profile },
    {
      no: 6,
      name: "entra_tenant_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "csv_integration_active",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 8,
      name: "google_workspace_integration_active",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 10, name: "trial_end_date", kind: "message", T: Timestamp },
    { no: 11, name: "license_type", kind: "enum", T: proto3.getEnumType(LicenseType) }
  ]);
  class SyncUpdate_Organization_ParentOrganizationInfo extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.name = "";
      this.icon = "";
      this.metadata = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Organization_ParentOrganizationInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Organization_ParentOrganizationInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Organization_ParentOrganizationInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Organization_ParentOrganizationInfo, a, b2);
    }
  }
  SyncUpdate_Organization_ParentOrganizationInfo.runtime = proto3;
  SyncUpdate_Organization_ParentOrganizationInfo.typeName = "domain.SyncUpdate.Organization.ParentOrganizationInfo";
  SyncUpdate_Organization_ParentOrganizationInfo.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_OrganizationProfile extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      this.isAdmin = false;
      this.isNotConnected = false;
      this.isManager = false;
      this.isService = false;
      this.personalVaultId = "";
      this.preliminaryUserId = "";
      this.startCode = "";
      this.primaryLoginDevice = PrimaryLoginDevice.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_OrganizationProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_OrganizationProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_OrganizationProfile().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_OrganizationProfile, a, b2);
    }
  }
  SyncUpdate_OrganizationProfile.runtime = proto3;
  SyncUpdate_OrganizationProfile.typeName = "domain.SyncUpdate.OrganizationProfile";
  SyncUpdate_OrganizationProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "is_admin",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 4,
      name: "is_not_connected",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 14,
      name: "is_manager",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 15,
      name: "is_service",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 8,
      name: "personal_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "preliminary_user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "start_code",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 10, name: "start_code_generated_at", kind: "message", T: Timestamp },
    { no: 11, name: "start_code_email_sent_at", kind: "message", T: Timestamp },
    { no: 12, name: "primary_login_device", kind: "enum", T: proto3.getEnumType(PrimaryLoginDevice) },
    { no: 13, name: "last_active_at", kind: "message", T: Timestamp }
  ]);
  class SyncUpdate_RelatedProfile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_RelatedProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_RelatedProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_RelatedProfile().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_RelatedProfile, a, b2);
    }
  }
  SyncUpdate_RelatedProfile.runtime = proto3;
  SyncUpdate_RelatedProfile.typeName = "domain.SyncUpdate.RelatedProfile";
  SyncUpdate_RelatedProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Profile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.profileType = ProfileType.UNKNOWN;
      this.keyGenerationId = "";
      this.organizationId = "";
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKey = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableProfileSeedEncPubKey = new Uint8Array(0);
      this.storableProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.authenticatorLocks = [];
      this.email = "";
      this.unverifiedEmail = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Profile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Profile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Profile().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_Profile, a, b2);
    }
  }
  SyncUpdate_Profile.runtime = proto3;
  SyncUpdate_Profile.typeName = "domain.SyncUpdate.Profile";
  SyncUpdate_Profile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile_type", kind: "enum", T: proto3.getEnumType(ProfileType) },
    {
      no: 3,
      name: "key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "high_security_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "high_security_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 11,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 12,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 13,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 14,
      name: "storable_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 15,
      name: "storable_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 16, name: "authenticator_locks", kind: "message", T: ProfileAuthenticatorLock$1, repeated: true },
    { no: 19, name: "profile_lock", kind: "message", T: ProfileProfileLock$1 },
    {
      no: 17,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 18,
      name: "unverified_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_PreliminaryProfile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.email = "";
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_PreliminaryProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_PreliminaryProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_PreliminaryProfile().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_PreliminaryProfile, a, b2);
    }
  }
  SyncUpdate_PreliminaryProfile.runtime = proto3;
  SyncUpdate_PreliminaryProfile.typeName = "domain.SyncUpdate.PreliminaryProfile";
  SyncUpdate_PreliminaryProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_MaintenanceSettings extends Message {
    constructor(data) {
      super();
      this.allowedTasks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_MaintenanceSettings().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_MaintenanceSettings().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_MaintenanceSettings().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncUpdate_MaintenanceSettings, a, b2);
    }
  }
  SyncUpdate_MaintenanceSettings.runtime = proto3;
  SyncUpdate_MaintenanceSettings.typeName = "domain.SyncUpdate.MaintenanceSettings";
  SyncUpdate_MaintenanceSettings.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed_tasks", kind: "enum", T: proto3.getEnumType(MaintenanceTask), repeated: true }
  ]);
  const trackErrorEmitterInternal = new Emittery$3.Typed();
  function trackError(errorObject) {
    let error2;
    trackErrorEmitterInternal.emit("error", errorObject).catch(suppressError);
    if (typeof errorObject === "object" && errorObject != null && "stack" in errorObject && errorObject.stack) {
      error2 = errorObject;
      debugConsole.error(error2);
    } else if (typeof errorObject === "object" && errorObject !== null) {
      const keys2 = Object.keys(errorObject).join(", ");
      if (hasMessage(errorObject)) {
        const message = errorObject.message;
        error2 = new Error(`Non-error object captured with message "${message}" and keys: ${keys2}`);
      } else {
        error2 = new Error(`Non-error object captured with keys: ${keys2}`);
      }
      debugConsole.error(error2, errorObject);
    } else {
      error2 = new Error(`Non-error captured`);
      debugConsole.error(error2, errorObject);
    }
    withScope$1((localScope) => {
      localScope.setExtra("__serialized__", errorObject);
      captureException$1(error2);
    });
  }
  function hasMessage(obj) {
    return "message" in obj;
  }
  function suppressError(_e) {
  }
  function promiseWithResolvers() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    return { promise, resolve, reject };
  }
  var ChannelRecipient;
  (function(ChannelRecipient2) {
    ChannelRecipient2[ChannelRecipient2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    ChannelRecipient2[ChannelRecipient2["CLIENT"] = 1] = "CLIENT";
    ChannelRecipient2[ChannelRecipient2["AUTHENTICATOR"] = 2] = "AUTHENTICATOR";
  })(ChannelRecipient || (ChannelRecipient = {}));
  proto3.util.setEnumType(ChannelRecipient, "domain.ChannelRecipient", [
    { no: 0, name: "CHANNEL_RECIPIENT_UNSPECIFIED" },
    { no: 1, name: "CHANNEL_RECIPIENT_CLIENT" },
    { no: 2, name: "CHANNEL_RECIPIENT_AUTHENTICATOR" }
  ]);
  class CreateChannelRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.data = new Uint8Array(0);
      this.exposed = false;
      this.channelType = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateChannelRequest, a, b2);
    }
  }
  CreateChannelRequest.runtime = proto3;
  CreateChannelRequest.typeName = "domain.CreateChannelRequest";
  CreateChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "exposed",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 4,
      name: "channel_type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateChannelResponse extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateChannelResponse, a, b2);
    }
  }
  CreateChannelResponse.runtime = proto3;
  CreateChannelResponse.typeName = "domain.CreateChannelResponse";
  CreateChannelResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ClaimChannelRequest extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      this.authenticatorId = "";
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ClaimChannelRequest, a, b2);
    }
  }
  ClaimChannelRequest.runtime = proto3;
  ClaimChannelRequest.typeName = "domain.ClaimChannelRequest";
  ClaimChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ClaimChannelResponse extends Message {
    constructor(data) {
      super();
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ClaimChannelResponse, a, b2);
    }
  }
  ClaimChannelResponse.runtime = proto3;
  ClaimChannelResponse.typeName = "domain.ClaimChannelResponse";
  ClaimChannelResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ReadChannelRequest extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      this.recipient = ChannelRecipient.UNSPECIFIED;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReadChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReadChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReadChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ReadChannelRequest, a, b2);
    }
  }
  ReadChannelRequest.runtime = proto3;
  ReadChannelRequest.typeName = "domain.ReadChannelRequest";
  ReadChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "recipient", kind: "enum", T: proto3.getEnumType(ChannelRecipient) }
  ]);
  class ReadChannelResponse extends Message {
    constructor(data) {
      super();
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReadChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReadChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReadChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ReadChannelResponse, a, b2);
    }
  }
  ReadChannelResponse.runtime = proto3;
  ReadChannelResponse.typeName = "domain.ReadChannelResponse";
  ReadChannelResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class WriteChannelRequest extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      this.recipient = ChannelRecipient.UNSPECIFIED;
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(WriteChannelRequest, a, b2);
    }
  }
  WriteChannelRequest.runtime = proto3;
  WriteChannelRequest.typeName = "domain.WriteChannelRequest";
  WriteChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "recipient", kind: "enum", T: proto3.getEnumType(ChannelRecipient) },
    {
      no: 3,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class WriteChannelResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(WriteChannelResponse, a, b2);
    }
  }
  WriteChannelResponse.runtime = proto3;
  WriteChannelResponse.typeName = "domain.WriteChannelResponse";
  WriteChannelResponse.fields = proto3.util.newFieldList(() => []);
  class DeleteChannelRequest extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteChannelRequest, a, b2);
    }
  }
  DeleteChannelRequest.runtime = proto3;
  DeleteChannelRequest.typeName = "domain.DeleteChannelRequest";
  DeleteChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteChannelResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteChannelResponse, a, b2);
    }
  }
  DeleteChannelResponse.runtime = proto3;
  DeleteChannelResponse.typeName = "domain.DeleteChannelResponse";
  DeleteChannelResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ProfileData extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.keyGenerationId = "";
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKey = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableProfileSeedEncPubKey = new Uint8Array(0);
      this.storableProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.authenticatorLocks = [];
      this.upstreamProfileLocks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ProfileData, a, b2);
    }
  }
  ProfileData.runtime = proto3;
  ProfileData.typeName = "domain.ProfileData";
  ProfileData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "high_security_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "high_security_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 11,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 12,
      name: "storable_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 13,
      name: "storable_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 14, name: "authenticator_locks", kind: "message", T: ProfileAuthenticatorLock$1, repeated: true },
    { no: 16, name: "upstream_profile_locks", kind: "message", T: ProfileProfileLock$1, repeated: true }
  ]);
  class ForeignProfile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.keyGenerationId = "";
      this.profileType = ProfileType.UNKNOWN;
      this.organizationId = "";
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKey = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableProfileSeedEncPubKey = new Uint8Array(0);
      this.storableProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ForeignProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ForeignProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ForeignProfile().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ForeignProfile, a, b2);
    }
  }
  ForeignProfile.runtime = proto3;
  ForeignProfile.typeName = "domain.ForeignProfile";
  ForeignProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "profile_type", kind: "enum", T: proto3.getEnumType(ProfileType) },
    {
      no: 4,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "high_security_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "high_security_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 11,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 12,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 13,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 14,
      name: "storable_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 15,
      name: "storable_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 16,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ProfileRegenerateData extends Message {
    constructor(data) {
      super();
      this.vaultLocks = [];
      this.downstreamProfileLocks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileRegenerateData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileRegenerateData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileRegenerateData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ProfileRegenerateData, a, b2);
    }
  }
  ProfileRegenerateData.runtime = proto3;
  ProfileRegenerateData.typeName = "domain.ProfileRegenerateData";
  ProfileRegenerateData.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profile", kind: "message", T: ProfileData },
    { no: 2, name: "vault_locks", kind: "message", T: VaultLockCreationData, repeated: true },
    { no: 3, name: "downstream_profile_locks", kind: "message", T: ProfileProfileLock$1, repeated: true }
  ]);
  var AuditlogEventTypeGroup;
  (function(AuditlogEventTypeGroup2) {
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["UNKNOWN"] = 0] = "UNKNOWN";
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["LOGIN_MIN"] = 1] = "LOGIN_MIN";
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["LOGIN_MAX"] = 29999] = "LOGIN_MAX";
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["PROFILE_MIN"] = 30001] = "PROFILE_MIN";
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["PROFILE_MAX"] = 39999] = "PROFILE_MAX";
  })(AuditlogEventTypeGroup || (AuditlogEventTypeGroup = {}));
  proto3.util.setEnumType(AuditlogEventTypeGroup, "domain.AuditlogEventTypeGroup", [
    { no: 0, name: "AUDITLOG_EVENT_TYPE_GROUP_UNKNOWN" },
    { no: 1, name: "AUDITLOG_EVENT_TYPE_GROUP_LOGIN_MIN" },
    { no: 29999, name: "AUDITLOG_EVENT_TYPE_GROUP_LOGIN_MAX" },
    { no: 30001, name: "AUDITLOG_EVENT_TYPE_GROUP_PROFILE_MIN" },
    { no: 39999, name: "AUDITLOG_EVENT_TYPE_GROUP_PROFILE_MAX" }
  ]);
  var AuditlogEventType;
  (function(AuditlogEventType2) {
    AuditlogEventType2[AuditlogEventType2["UNKNOWN"] = 0] = "UNKNOWN";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_AUTOFILL"] = 1] = "LOGIN_R_AUTOFILL";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_PASSWORD_SHOW"] = 100] = "LOGIN_R_PASSWORD_SHOW";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_PASSWORD_COPY"] = 101] = "LOGIN_R_PASSWORD_COPY";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_PASSWORD_INSERT_CONTEXT_MENU"] = 102] = "LOGIN_R_PASSWORD_INSERT_CONTEXT_MENU";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_CUSTOM_FIELD_SHOW"] = 200] = "LOGIN_R_CUSTOM_FIELD_SHOW";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_CUSTOM_FIELD_COPY"] = 201] = "LOGIN_R_CUSTOM_FIELD_COPY";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_CUSTOM_FIELD_INSERT_CONTEXT_MENU"] = 202] = "LOGIN_R_CUSTOM_FIELD_INSERT_CONTEXT_MENU";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_TOTP_SECRET_SHOW"] = 300] = "LOGIN_R_TOTP_SECRET_SHOW";
    AuditlogEventType2[AuditlogEventType2["CREDIT_CARD_R_SECURITY_CODE_SHOW"] = 400] = "CREDIT_CARD_R_SECURITY_CODE_SHOW";
    AuditlogEventType2[AuditlogEventType2["CREDIT_CARD_R_SECURITY_CODE_COPY"] = 401] = "CREDIT_CARD_R_SECURITY_CODE_COPY";
    AuditlogEventType2[AuditlogEventType2["CREDIT_CARD_R_PIN_SHOW"] = 402] = "CREDIT_CARD_R_PIN_SHOW";
    AuditlogEventType2[AuditlogEventType2["CREDIT_CARD_R_PIN_COPY"] = 403] = "CREDIT_CARD_R_PIN_COPY";
    AuditlogEventType2[AuditlogEventType2["WIFI_R_QR_SHOW"] = 500] = "WIFI_R_QR_SHOW";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_CREATE"] = 10001] = "LOGIN_W_CREATE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_CHANGE"] = 10002] = "LOGIN_W_CHANGE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_DELETE"] = 10003] = "LOGIN_W_DELETE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_ARCHIVE"] = 10004] = "LOGIN_W_ARCHIVE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_RESTORE_FROM_ARCHIVE"] = 10005] = "LOGIN_W_RESTORE_FROM_ARCHIVE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_SHARE_LINK_CREATE"] = 20001] = "LOGIN_SHARE_LINK_CREATE";
    AuditlogEventType2[AuditlogEventType2["PROFILE_CREATE"] = 30001] = "PROFILE_CREATE";
    AuditlogEventType2[AuditlogEventType2["PROFILE_DELETE"] = 30002] = "PROFILE_DELETE";
    AuditlogEventType2[AuditlogEventType2["PROFILE_CLAIM_WITH_START_CODE"] = 30003] = "PROFILE_CLAIM_WITH_START_CODE";
    AuditlogEventType2[AuditlogEventType2["PROFILE_DISCONNECT"] = 30004] = "PROFILE_DISCONNECT";
    AuditlogEventType2[AuditlogEventType2["PROFILE_PROMOTE_TO_ADMIN"] = 30005] = "PROFILE_PROMOTE_TO_ADMIN";
    AuditlogEventType2[AuditlogEventType2["PROFILE_DEMOTE_ADMIN"] = 30006] = "PROFILE_DEMOTE_ADMIN";
  })(AuditlogEventType || (AuditlogEventType = {}));
  proto3.util.setEnumType(AuditlogEventType, "domain.AuditlogEventType", [
    { no: 0, name: "AUDITLOG_EVENT_TYPE_UNKNOWN" },
    { no: 1, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_AUTOFILL" },
    { no: 100, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_PASSWORD_SHOW" },
    { no: 101, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_PASSWORD_COPY" },
    { no: 102, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_PASSWORD_INSERT_CONTEXT_MENU" },
    { no: 200, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_CUSTOM_FIELD_SHOW" },
    { no: 201, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_CUSTOM_FIELD_COPY" },
    { no: 202, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_CUSTOM_FIELD_INSERT_CONTEXT_MENU" },
    { no: 300, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_TOTP_SECRET_SHOW" },
    { no: 400, name: "AUDITLOG_EVENT_TYPE_CREDIT_CARD_R_SECURITY_CODE_SHOW" },
    { no: 401, name: "AUDITLOG_EVENT_TYPE_CREDIT_CARD_R_SECURITY_CODE_COPY" },
    { no: 402, name: "AUDITLOG_EVENT_TYPE_CREDIT_CARD_R_PIN_SHOW" },
    { no: 403, name: "AUDITLOG_EVENT_TYPE_CREDIT_CARD_R_PIN_COPY" },
    { no: 500, name: "AUDITLOG_EVENT_TYPE_WIFI_R_QR_SHOW" },
    { no: 10001, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_CREATE" },
    { no: 10002, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_CHANGE" },
    { no: 10003, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_DELETE" },
    { no: 10004, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_ARCHIVE" },
    { no: 10005, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_RESTORE_FROM_ARCHIVE" },
    { no: 20001, name: "AUDITLOG_EVENT_TYPE_LOGIN_SHARE_LINK_CREATE" },
    { no: 30001, name: "AUDITLOG_EVENT_TYPE_PROFILE_CREATE" },
    { no: 30002, name: "AUDITLOG_EVENT_TYPE_PROFILE_DELETE" },
    { no: 30003, name: "AUDITLOG_EVENT_TYPE_PROFILE_CLAIM_WITH_START_CODE" },
    { no: 30004, name: "AUDITLOG_EVENT_TYPE_PROFILE_DISCONNECT" },
    { no: 30005, name: "AUDITLOG_EVENT_TYPE_PROFILE_PROMOTE_TO_ADMIN" },
    { no: 30006, name: "AUDITLOG_EVENT_TYPE_PROFILE_DEMOTE_ADMIN" }
  ]);
  var ErrorGroup;
  (function(ErrorGroup2) {
    ErrorGroup2[ErrorGroup2["EG_UNDEFINED"] = 0] = "EG_UNDEFINED";
    ErrorGroup2[ErrorGroup2["EG_UNSPECIFIC"] = 1e4] = "EG_UNSPECIFIC";
    ErrorGroup2[ErrorGroup2["EG_ACCOUNT"] = 2e4] = "EG_ACCOUNT";
    ErrorGroup2[ErrorGroup2["EG_CREDENTIAL"] = 3e4] = "EG_CREDENTIAL";
    ErrorGroup2[ErrorGroup2["EG_AUTHENTICATOR"] = 4e4] = "EG_AUTHENTICATOR";
    ErrorGroup2[ErrorGroup2["EG_VAULT"] = 5e4] = "EG_VAULT";
    ErrorGroup2[ErrorGroup2["EG_ORGANIZATION"] = 6e4] = "EG_ORGANIZATION";
    ErrorGroup2[ErrorGroup2["EG_PROFILE"] = 7e4] = "EG_PROFILE";
    ErrorGroup2[ErrorGroup2["EG_INTEGRATION"] = 8e4] = "EG_INTEGRATION";
    ErrorGroup2[ErrorGroup2["EG_AUDITLOG"] = 9e4] = "EG_AUDITLOG";
    ErrorGroup2[ErrorGroup2["EG_WEBAUTHN"] = 1e5] = "EG_WEBAUTHN";
    ErrorGroup2[ErrorGroup2["EG_SHARELINK"] = 11e4] = "EG_SHARELINK";
    ErrorGroup2[ErrorGroup2["EG_USER_CONFIRMATION"] = 12e4] = "EG_USER_CONFIRMATION";
  })(ErrorGroup || (ErrorGroup = {}));
  proto3.util.setEnumType(ErrorGroup, "domainerr.ErrorGroup", [
    { no: 0, name: "EG_UNDEFINED" },
    { no: 1e4, name: "EG_UNSPECIFIC" },
    { no: 2e4, name: "EG_ACCOUNT" },
    { no: 3e4, name: "EG_CREDENTIAL" },
    { no: 4e4, name: "EG_AUTHENTICATOR" },
    { no: 5e4, name: "EG_VAULT" },
    { no: 6e4, name: "EG_ORGANIZATION" },
    { no: 7e4, name: "EG_PROFILE" },
    { no: 8e4, name: "EG_INTEGRATION" },
    { no: 9e4, name: "EG_AUDITLOG" },
    { no: 1e5, name: "EG_WEBAUTHN" },
    { no: 11e4, name: "EG_SHARELINK" },
    { no: 12e4, name: "EG_USER_CONFIRMATION" }
  ]);
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2[ErrorCode2["UNDEFINED"] = 0] = "UNDEFINED";
    ErrorCode2[ErrorCode2["PERMISSION_DENIED"] = 10100] = "PERMISSION_DENIED";
    ErrorCode2[ErrorCode2["TIMEOUT"] = 10200] = "TIMEOUT";
    ErrorCode2[ErrorCode2["CANCELED"] = 10300] = "CANCELED";
    ErrorCode2[ErrorCode2["BAD_REQUEST"] = 10400] = "BAD_REQUEST";
    ErrorCode2[ErrorCode2["CLIENT_OUTDATED"] = 10426] = "CLIENT_OUTDATED";
    ErrorCode2[ErrorCode2["INTERNAL"] = 10500] = "INTERNAL";
    ErrorCode2[ErrorCode2["EMAIL_TAKEN"] = 20100] = "EMAIL_TAKEN";
    ErrorCode2[ErrorCode2["INVALID_EMAIL"] = 20101] = "INVALID_EMAIL";
    ErrorCode2[ErrorCode2["EMAIL_ALREADY_VERIFIED"] = 20102] = "EMAIL_ALREADY_VERIFIED";
    ErrorCode2[ErrorCode2["EMAIL_REQUIRED"] = 20103] = "EMAIL_REQUIRED";
    ErrorCode2[ErrorCode2["INVALID_LOCALE"] = 20105] = "INVALID_LOCALE";
    ErrorCode2[ErrorCode2["EMAIL_INVITE_NOT_ACTIVE"] = 20106] = "EMAIL_INVITE_NOT_ACTIVE";
    ErrorCode2[ErrorCode2["EMAIL_TAKEN_NOT_RECOVERABLE"] = 20107] = "EMAIL_TAKEN_NOT_RECOVERABLE";
    ErrorCode2[ErrorCode2["MALFORMED_USER_SETTINGS"] = 20108] = "MALFORMED_USER_SETTINGS";
    ErrorCode2[ErrorCode2["EMAIL_TAKEN_VERIFIED_DOMAIN"] = 20109] = "EMAIL_TAKEN_VERIFIED_DOMAIN";
    ErrorCode2[ErrorCode2["EMAIL_TAKEN_ORG_ADMIN_RECOVERABLE"] = 20110] = "EMAIL_TAKEN_ORG_ADMIN_RECOVERABLE";
    ErrorCode2[ErrorCode2["USER_NOT_FOUND"] = 20400] = "USER_NOT_FOUND";
    ErrorCode2[ErrorCode2["SESSION_NOT_FOUND"] = 20410] = "SESSION_NOT_FOUND";
    ErrorCode2[ErrorCode2["INVALID_TIMEOUT"] = 20420] = "INVALID_TIMEOUT";
    ErrorCode2[ErrorCode2["SESSION_ALREADY_UNLOCKED"] = 20430] = "SESSION_ALREADY_UNLOCKED";
    ErrorCode2[ErrorCode2["SESSION_NOT_UNLOCKED"] = 20431] = "SESSION_NOT_UNLOCKED";
    ErrorCode2[ErrorCode2["INVITATION_NOT_FOUND"] = 20450] = "INVITATION_NOT_FOUND";
    ErrorCode2[ErrorCode2["INVALID_VERIFICATION_TOKEN"] = 20460] = "INVALID_VERIFICATION_TOKEN";
    ErrorCode2[ErrorCode2["NOT_ALLOWED_FOR_USER_TYPE"] = 20470] = "NOT_ALLOWED_FOR_USER_TYPE";
    ErrorCode2[ErrorCode2["MALFORMED_CLIENT_SETTINGS"] = 20480] = "MALFORMED_CLIENT_SETTINGS";
    ErrorCode2[ErrorCode2["REGISTER_USE_LEGACY"] = 20500] = "REGISTER_USE_LEGACY";
    ErrorCode2[ErrorCode2["MISSING_CREDENTIALS"] = 30100] = "MISSING_CREDENTIALS";
    ErrorCode2[ErrorCode2["INVALID_SIGNATURE"] = 30400] = "INVALID_SIGNATURE";
    ErrorCode2[ErrorCode2["INVALID_CHALLENGE"] = 30410] = "INVALID_CHALLENGE";
    ErrorCode2[ErrorCode2["INVALID_CREDENTIALS"] = 30420] = "INVALID_CREDENTIALS";
    ErrorCode2[ErrorCode2["CHALLENGE_USER_MISMATCH"] = 30430] = "CHALLENGE_USER_MISMATCH";
    ErrorCode2[ErrorCode2["LONG_POLL_CHANNEL_NOT_FOUND"] = 30440] = "LONG_POLL_CHANNEL_NOT_FOUND";
    ErrorCode2[ErrorCode2["LONG_POLL_CHANNEL_ALREADY_EXISTS"] = 30441] = "LONG_POLL_CHANNEL_ALREADY_EXISTS";
    ErrorCode2[ErrorCode2["INVALID_USER_SWITCH"] = 30450] = "INVALID_USER_SWITCH";
    ErrorCode2[ErrorCode2["INVALID_SESSION_TYPE"] = 30460] = "INVALID_SESSION_TYPE";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_BLOCK_OUT_OF_SYNC"] = 40100] = "AUTHENTICATOR_BLOCK_OUT_OF_SYNC";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_NOT_FOUND"] = 40400] = "AUTHENTICATOR_NOT_FOUND";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_CHANNEL_NOT_FOUND"] = 40410] = "AUTHENTICATOR_CHANNEL_NOT_FOUND";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_CHANNEL_ALREADY_CLAIMED"] = 40411] = "AUTHENTICATOR_CHANNEL_ALREADY_CLAIMED";
    ErrorCode2[ErrorCode2["NO_AUTHENTICATOR_OPERATION"] = 40420] = "NO_AUTHENTICATOR_OPERATION";
    ErrorCode2[ErrorCode2["MISSING_AUTHENTICATOR_BLOCK"] = 40430] = "MISSING_AUTHENTICATOR_BLOCK";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_BLOCK_NOT_FOUND"] = 40440] = "AUTHENTICATOR_BLOCK_NOT_FOUND";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_BLOCK_EXISTS"] = 40450] = "AUTHENTICATOR_BLOCK_EXISTS";
    ErrorCode2[ErrorCode2["INVALID_AUTHENTICATOR_TYPE"] = 40460] = "INVALID_AUTHENTICATOR_TYPE";
    ErrorCode2[ErrorCode2["INVALID_RECIPIENT"] = 40500] = "INVALID_RECIPIENT";
    ErrorCode2[ErrorCode2["VAULT_OUT_OF_SYNC"] = 50100] = "VAULT_OUT_OF_SYNC";
    ErrorCode2[ErrorCode2["NOT_ALLOWED_FOR_VAULT"] = 50110] = "NOT_ALLOWED_FOR_VAULT";
    ErrorCode2[ErrorCode2["VAULT_INSUFFICIENT_ACCESS"] = 50120] = "VAULT_INSUFFICIENT_ACCESS";
    ErrorCode2[ErrorCode2["EMPTY_COMMIT"] = 50200] = "EMPTY_COMMIT";
    ErrorCode2[ErrorCode2["VAULT_NOT_FOUND"] = 50400] = "VAULT_NOT_FOUND";
    ErrorCode2[ErrorCode2["MISSING_VAULT_AUTHENTICATOR_LOCK"] = 50410] = "MISSING_VAULT_AUTHENTICATOR_LOCK";
    ErrorCode2[ErrorCode2["MISSING_VAULT_PROFILE_LOCK"] = 50411] = "MISSING_VAULT_PROFILE_LOCK";
    ErrorCode2[ErrorCode2["MISSING_VAULT"] = 50420] = "MISSING_VAULT";
    ErrorCode2[ErrorCode2["INVALID_UPDATE_TIME"] = 50430] = "INVALID_UPDATE_TIME";
    ErrorCode2[ErrorCode2["INVALID_VAULT_TYPE"] = 50431] = "INVALID_VAULT_TYPE";
    ErrorCode2[ErrorCode2["MISSING_VAULT_ADMIN"] = 50440] = "MISSING_VAULT_ADMIN";
    ErrorCode2[ErrorCode2["VAULT_DIRTY"] = 50450] = "VAULT_DIRTY";
    ErrorCode2[ErrorCode2["MISSING_ENCRYPTED_VAULT_MESSAGE_PRIVATE_KEY"] = 50460] = "MISSING_ENCRYPTED_VAULT_MESSAGE_PRIVATE_KEY";
    ErrorCode2[ErrorCode2["MISSING_VAULT_MESSAGE_PUBLIC_KEY"] = 50461] = "MISSING_VAULT_MESSAGE_PUBLIC_KEY";
    ErrorCode2[ErrorCode2["UNHANDLED_VAULT_MESSAGE"] = 50462] = "UNHANDLED_VAULT_MESSAGE";
    ErrorCode2[ErrorCode2["INVALID_VAULT_MESSAGE_TYPE"] = 50463] = "INVALID_VAULT_MESSAGE_TYPE";
    ErrorCode2[ErrorCode2["VAULT_MESSAGE_NOT_FOUND"] = 50464] = "VAULT_MESSAGE_NOT_FOUND";
    ErrorCode2[ErrorCode2["VAULT_INBOX_SLUG_INVALID"] = 50470] = "VAULT_INBOX_SLUG_INVALID";
    ErrorCode2[ErrorCode2["VAULT_INBOX_SLUG_TAKEN"] = 50471] = "VAULT_INBOX_SLUG_TAKEN";
    ErrorCode2[ErrorCode2["ORGANIZATION_INSUEFFICIENT_ACCESS"] = 60100] = "ORGANIZATION_INSUEFFICIENT_ACCESS";
    ErrorCode2[ErrorCode2["NOT_ALLOWED_FOR_ORGANIZATION"] = 60101] = "NOT_ALLOWED_FOR_ORGANIZATION";
    ErrorCode2[ErrorCode2["ORGANIZATION_NOT_FOUND"] = 60400] = "ORGANIZATION_NOT_FOUND";
    ErrorCode2[ErrorCode2["USER_ALREADY_IN_ORGANIZATION"] = 60401] = "USER_ALREADY_IN_ORGANIZATION";
    ErrorCode2[ErrorCode2["ORGANIZATION_MISSING_ADMIN"] = 60410] = "ORGANIZATION_MISSING_ADMIN";
    ErrorCode2[ErrorCode2["INVALID_ORGANIZATION_NAME"] = 60430] = "INVALID_ORGANIZATION_NAME";
    ErrorCode2[ErrorCode2["ORGANIZATION_INVALID_CONTACT"] = 60431] = "ORGANIZATION_INVALID_CONTACT";
    ErrorCode2[ErrorCode2["COUPON_INVALID"] = 60440] = "COUPON_INVALID";
    ErrorCode2[ErrorCode2["COUPON_ALREADY_REDEEMED"] = 60441] = "COUPON_ALREADY_REDEEMED";
    ErrorCode2[ErrorCode2["OTHER_PROFILE_EMAIL_CONFLICTS"] = 60450] = "OTHER_PROFILE_EMAIL_CONFLICTS";
    ErrorCode2[ErrorCode2["INVALID_ORGANIZATION_DELETION_TOKEN"] = 60460] = "INVALID_ORGANIZATION_DELETION_TOKEN";
    ErrorCode2[ErrorCode2["MALFORMED_PASSWORD_POLICY"] = 60470] = "MALFORMED_PASSWORD_POLICY";
    ErrorCode2[ErrorCode2["MALFORMED_PARENT_ORGANIZATION_METADATA"] = 60471] = "MALFORMED_PARENT_ORGANIZATION_METADATA";
    ErrorCode2[ErrorCode2["PROFILE_NOT_FOUND"] = 70400] = "PROFILE_NOT_FOUND";
    ErrorCode2[ErrorCode2["PROFILE_ALREADY_ENABLED"] = 70401] = "PROFILE_ALREADY_ENABLED";
    ErrorCode2[ErrorCode2["PROFILE_ALREADY_CONNECTED"] = 70402] = "PROFILE_ALREADY_CONNECTED";
    ErrorCode2[ErrorCode2["PROFILE_STARTCODE_INACTIVE"] = 70403] = "PROFILE_STARTCODE_INACTIVE";
    ErrorCode2[ErrorCode2["MISSING_PROFILE_AUTHENTICATOR_LOCK"] = 70410] = "MISSING_PROFILE_AUTHENTICATOR_LOCK";
    ErrorCode2[ErrorCode2["PROFILE_OUT_OF_SYNC"] = 70411] = "PROFILE_OUT_OF_SYNC";
    ErrorCode2[ErrorCode2["MISSING_PROFILE_PROFILE_LOCK"] = 70412] = "MISSING_PROFILE_PROFILE_LOCK";
    ErrorCode2[ErrorCode2["START_CODE_INVALID"] = 70430] = "START_CODE_INVALID";
    ErrorCode2[ErrorCode2["START_CODE_BLOCKED"] = 70431] = "START_CODE_BLOCKED";
    ErrorCode2[ErrorCode2["START_CODE_MISSING"] = 70432] = "START_CODE_MISSING";
    ErrorCode2[ErrorCode2["NOT_ALLOWED_FOR_PROFILE"] = 70433] = "NOT_ALLOWED_FOR_PROFILE";
    ErrorCode2[ErrorCode2["INTEGRATION_NOT_INITIALIZED"] = 80400] = "INTEGRATION_NOT_INITIALIZED";
    ErrorCode2[ErrorCode2["INTEGRATION_UNAUTHORIZED"] = 80401] = "INTEGRATION_UNAUTHORIZED";
    ErrorCode2[ErrorCode2["INTEGRATION_INTERNAL"] = 80500] = "INTEGRATION_INTERNAL";
    ErrorCode2[ErrorCode2["AUDITLOG_MALFORMED_EVENT"] = 90400] = "AUDITLOG_MALFORMED_EVENT";
    ErrorCode2[ErrorCode2["AUDITLOG_ADMIN_INVALID_CREDENTIALS"] = 90420] = "AUDITLOG_ADMIN_INVALID_CREDENTIALS";
    ErrorCode2[ErrorCode2["AUDITLOG_WRITE_INVALID_CREDENTIALS"] = 90421] = "AUDITLOG_WRITE_INVALID_CREDENTIALS";
    ErrorCode2[ErrorCode2["AUDITLOG_SUBMISSION_ERROR"] = 90500] = "AUDITLOG_SUBMISSION_ERROR";
    ErrorCode2[ErrorCode2["WEBAUTHN_VALIDATE_ERROR"] = 100400] = "WEBAUTHN_VALIDATE_ERROR";
    ErrorCode2[ErrorCode2["WEBAUTHN_DATA_ERROR"] = 100401] = "WEBAUTHN_DATA_ERROR";
    ErrorCode2[ErrorCode2["WEBAUTHN_REQUEST_NOT_FOUND"] = 100402] = "WEBAUTHN_REQUEST_NOT_FOUND";
    ErrorCode2[ErrorCode2["WEBAUTHN_INVALID_TRANSPORT"] = 100403] = "WEBAUTHN_INVALID_TRANSPORT";
    ErrorCode2[ErrorCode2["MISSING_WEBAUTHN_CREDENTIAL"] = 100404] = "MISSING_WEBAUTHN_CREDENTIAL";
    ErrorCode2[ErrorCode2["MISSING_WEBAUTHN_RESPONSE"] = 100405] = "MISSING_WEBAUTHN_RESPONSE";
    ErrorCode2[ErrorCode2["WEBAUTHN_MISSING_USER_VERIFICATION"] = 100406] = "WEBAUTHN_MISSING_USER_VERIFICATION";
    ErrorCode2[ErrorCode2["SHARE_LINK_NOT_FOUND"] = 110400] = "SHARE_LINK_NOT_FOUND";
    ErrorCode2[ErrorCode2["USER_CONFIRMATION_NOT_FOUND"] = 120400] = "USER_CONFIRMATION_NOT_FOUND";
  })(ErrorCode || (ErrorCode = {}));
  proto3.util.setEnumType(ErrorCode, "domainerr.ErrorCode", [
    { no: 0, name: "UNDEFINED" },
    { no: 10100, name: "PERMISSION_DENIED" },
    { no: 10200, name: "TIMEOUT" },
    { no: 10300, name: "CANCELED" },
    { no: 10400, name: "BAD_REQUEST" },
    { no: 10426, name: "CLIENT_OUTDATED" },
    { no: 10500, name: "INTERNAL" },
    { no: 20100, name: "EMAIL_TAKEN" },
    { no: 20101, name: "INVALID_EMAIL" },
    { no: 20102, name: "EMAIL_ALREADY_VERIFIED" },
    { no: 20103, name: "EMAIL_REQUIRED" },
    { no: 20105, name: "INVALID_LOCALE" },
    { no: 20106, name: "EMAIL_INVITE_NOT_ACTIVE" },
    { no: 20107, name: "EMAIL_TAKEN_NOT_RECOVERABLE" },
    { no: 20108, name: "MALFORMED_USER_SETTINGS" },
    { no: 20109, name: "EMAIL_TAKEN_VERIFIED_DOMAIN" },
    { no: 20110, name: "EMAIL_TAKEN_ORG_ADMIN_RECOVERABLE" },
    { no: 20400, name: "USER_NOT_FOUND" },
    { no: 20410, name: "SESSION_NOT_FOUND" },
    { no: 20420, name: "INVALID_TIMEOUT" },
    { no: 20430, name: "SESSION_ALREADY_UNLOCKED" },
    { no: 20431, name: "SESSION_NOT_UNLOCKED" },
    { no: 20450, name: "INVITATION_NOT_FOUND" },
    { no: 20460, name: "INVALID_VERIFICATION_TOKEN" },
    { no: 20470, name: "NOT_ALLOWED_FOR_USER_TYPE" },
    { no: 20480, name: "MALFORMED_CLIENT_SETTINGS" },
    { no: 20500, name: "REGISTER_USE_LEGACY" },
    { no: 30100, name: "MISSING_CREDENTIALS" },
    { no: 30400, name: "INVALID_SIGNATURE" },
    { no: 30410, name: "INVALID_CHALLENGE" },
    { no: 30420, name: "INVALID_CREDENTIALS" },
    { no: 30430, name: "CHALLENGE_USER_MISMATCH" },
    { no: 30440, name: "LONG_POLL_CHANNEL_NOT_FOUND" },
    { no: 30441, name: "LONG_POLL_CHANNEL_ALREADY_EXISTS" },
    { no: 30450, name: "INVALID_USER_SWITCH" },
    { no: 30460, name: "INVALID_SESSION_TYPE" },
    { no: 40100, name: "AUTHENTICATOR_BLOCK_OUT_OF_SYNC" },
    { no: 40400, name: "AUTHENTICATOR_NOT_FOUND" },
    { no: 40410, name: "AUTHENTICATOR_CHANNEL_NOT_FOUND" },
    { no: 40411, name: "AUTHENTICATOR_CHANNEL_ALREADY_CLAIMED" },
    { no: 40420, name: "NO_AUTHENTICATOR_OPERATION" },
    { no: 40430, name: "MISSING_AUTHENTICATOR_BLOCK" },
    { no: 40440, name: "AUTHENTICATOR_BLOCK_NOT_FOUND" },
    { no: 40450, name: "AUTHENTICATOR_BLOCK_EXISTS" },
    { no: 40460, name: "INVALID_AUTHENTICATOR_TYPE" },
    { no: 40500, name: "INVALID_RECIPIENT" },
    { no: 50100, name: "VAULT_OUT_OF_SYNC" },
    { no: 50110, name: "NOT_ALLOWED_FOR_VAULT" },
    { no: 50120, name: "VAULT_INSUFFICIENT_ACCESS" },
    { no: 50200, name: "EMPTY_COMMIT" },
    { no: 50400, name: "VAULT_NOT_FOUND" },
    { no: 50410, name: "MISSING_VAULT_AUTHENTICATOR_LOCK" },
    { no: 50411, name: "MISSING_VAULT_PROFILE_LOCK" },
    { no: 50420, name: "MISSING_VAULT" },
    { no: 50430, name: "INVALID_UPDATE_TIME" },
    { no: 50431, name: "INVALID_VAULT_TYPE" },
    { no: 50440, name: "MISSING_VAULT_ADMIN" },
    { no: 50450, name: "VAULT_DIRTY" },
    { no: 50460, name: "MISSING_ENCRYPTED_VAULT_MESSAGE_PRIVATE_KEY" },
    { no: 50461, name: "MISSING_VAULT_MESSAGE_PUBLIC_KEY" },
    { no: 50462, name: "UNHANDLED_VAULT_MESSAGE" },
    { no: 50463, name: "INVALID_VAULT_MESSAGE_TYPE" },
    { no: 50464, name: "VAULT_MESSAGE_NOT_FOUND" },
    { no: 50470, name: "VAULT_INBOX_SLUG_INVALID" },
    { no: 50471, name: "VAULT_INBOX_SLUG_TAKEN" },
    { no: 60100, name: "ORGANIZATION_INSUEFFICIENT_ACCESS" },
    { no: 60101, name: "NOT_ALLOWED_FOR_ORGANIZATION" },
    { no: 60400, name: "ORGANIZATION_NOT_FOUND" },
    { no: 60401, name: "USER_ALREADY_IN_ORGANIZATION" },
    { no: 60410, name: "ORGANIZATION_MISSING_ADMIN" },
    { no: 60430, name: "INVALID_ORGANIZATION_NAME" },
    { no: 60431, name: "ORGANIZATION_INVALID_CONTACT" },
    { no: 60440, name: "COUPON_INVALID" },
    { no: 60441, name: "COUPON_ALREADY_REDEEMED" },
    { no: 60450, name: "OTHER_PROFILE_EMAIL_CONFLICTS" },
    { no: 60460, name: "INVALID_ORGANIZATION_DELETION_TOKEN" },
    { no: 60470, name: "MALFORMED_PASSWORD_POLICY" },
    { no: 60471, name: "MALFORMED_PARENT_ORGANIZATION_METADATA" },
    { no: 70400, name: "PROFILE_NOT_FOUND" },
    { no: 70401, name: "PROFILE_ALREADY_ENABLED" },
    { no: 70402, name: "PROFILE_ALREADY_CONNECTED" },
    { no: 70403, name: "PROFILE_STARTCODE_INACTIVE" },
    { no: 70410, name: "MISSING_PROFILE_AUTHENTICATOR_LOCK" },
    { no: 70411, name: "PROFILE_OUT_OF_SYNC" },
    { no: 70412, name: "MISSING_PROFILE_PROFILE_LOCK" },
    { no: 70430, name: "START_CODE_INVALID" },
    { no: 70431, name: "START_CODE_BLOCKED" },
    { no: 70432, name: "START_CODE_MISSING" },
    { no: 70433, name: "NOT_ALLOWED_FOR_PROFILE" },
    { no: 80400, name: "INTEGRATION_NOT_INITIALIZED" },
    { no: 80401, name: "INTEGRATION_UNAUTHORIZED" },
    { no: 80500, name: "INTEGRATION_INTERNAL" },
    { no: 90400, name: "AUDITLOG_MALFORMED_EVENT" },
    { no: 90420, name: "AUDITLOG_ADMIN_INVALID_CREDENTIALS" },
    { no: 90421, name: "AUDITLOG_WRITE_INVALID_CREDENTIALS" },
    { no: 90500, name: "AUDITLOG_SUBMISSION_ERROR" },
    { no: 100400, name: "WEBAUTHN_VALIDATE_ERROR" },
    { no: 100401, name: "WEBAUTHN_DATA_ERROR" },
    { no: 100402, name: "WEBAUTHN_REQUEST_NOT_FOUND" },
    { no: 100403, name: "WEBAUTHN_INVALID_TRANSPORT" },
    { no: 100404, name: "MISSING_WEBAUTHN_CREDENTIAL" },
    { no: 100405, name: "MISSING_WEBAUTHN_RESPONSE" },
    { no: 100406, name: "WEBAUTHN_MISSING_USER_VERIFICATION" },
    { no: 110400, name: "SHARE_LINK_NOT_FOUND" },
    { no: 120400, name: "USER_CONFIRMATION_NOT_FOUND" }
  ]);
  var ReportPageProblem;
  (function(ReportPageProblem2) {
    ReportPageProblem2[ReportPageProblem2["UNKNOWN"] = 0] = "UNKNOWN";
    ReportPageProblem2[ReportPageProblem2["OTHER"] = 1] = "OTHER";
    ReportPageProblem2[ReportPageProblem2["DETECTION"] = 2] = "DETECTION";
    ReportPageProblem2[ReportPageProblem2["POSITION"] = 3] = "POSITION";
    ReportPageProblem2[ReportPageProblem2["SUBMISSION"] = 4] = "SUBMISSION";
    ReportPageProblem2[ReportPageProblem2["AUTOFILL"] = 5] = "AUTOFILL";
    ReportPageProblem2[ReportPageProblem2["FORM"] = 6] = "FORM";
  })(ReportPageProblem || (ReportPageProblem = {}));
  proto3.util.setEnumType(ReportPageProblem, "domain.ReportPageProblem", [
    { no: 0, name: "REPORT_PAGE_PROBLEM_UNKNOWN" },
    { no: 1, name: "REPORT_PAGE_PROBLEM_OTHER" },
    { no: 2, name: "REPORT_PAGE_PROBLEM_DETECTION" },
    { no: 3, name: "REPORT_PAGE_PROBLEM_POSITION" },
    { no: 4, name: "REPORT_PAGE_PROBLEM_SUBMISSION" },
    { no: 5, name: "REPORT_PAGE_PROBLEM_AUTOFILL" },
    { no: 6, name: "REPORT_PAGE_PROBLEM_FORM" }
  ]);
  class SendMessageRequest extends Message {
    constructor(data) {
      super();
      this.subject = "";
      this.message = "";
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendMessageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendMessageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendMessageRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SendMessageRequest, a, b2);
    }
  }
  SendMessageRequest.runtime = proto3;
  SendMessageRequest.typeName = "domain.SendMessageRequest";
  SendMessageRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "subject",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "message",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SendMessageResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendMessageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendMessageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendMessageResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SendMessageResponse, a, b2);
    }
  }
  SendMessageResponse.runtime = proto3;
  SendMessageResponse.typeName = "domain.SendMessageResponse";
  SendMessageResponse.fields = proto3.util.newFieldList(() => []);
  class ReportPageRequest extends Message {
    constructor(data) {
      super();
      this.url = "";
      this.problem = ReportPageProblem.UNKNOWN;
      this.comment = "";
      this.screenshot = "";
      this.hasLogin = false;
      this.hasHideSecretsLogin = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReportPageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReportPageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReportPageRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ReportPageRequest, a, b2);
    }
  }
  ReportPageRequest.runtime = proto3;
  ReportPageRequest.typeName = "domain.ReportPageRequest";
  ReportPageRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "problem", kind: "enum", T: proto3.getEnumType(ReportPageProblem) },
    {
      no: 3,
      name: "comment",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "screenshot",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "has_login",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: "has_hide_secrets_login",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ReportPageResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReportPageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReportPageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReportPageResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ReportPageResponse, a, b2);
    }
  }
  ReportPageResponse.runtime = proto3;
  ReportPageResponse.typeName = "domain.ReportPageResponse";
  ReportPageResponse.fields = proto3.util.newFieldList(() => []);
  var SubscriptionPlan;
  (function(SubscriptionPlan2) {
    SubscriptionPlan2[SubscriptionPlan2["UNKNOWN"] = 0] = "UNKNOWN";
    SubscriptionPlan2[SubscriptionPlan2["MONTHLY"] = 1] = "MONTHLY";
    SubscriptionPlan2[SubscriptionPlan2["YEARLY"] = 2] = "YEARLY";
  })(SubscriptionPlan || (SubscriptionPlan = {}));
  proto3.util.setEnumType(SubscriptionPlan, "domain.SubscriptionPlan", [
    { no: 0, name: "SUBSCRIPTION_PLAN_UNKNOWN" },
    { no: 1, name: "SUBSCRIPTION_PLAN_MONTHLY" },
    { no: 2, name: "SUBSCRIPTION_PLAN_YEARLY" }
  ]);
  var UserConfirmationResultType;
  (function(UserConfirmationResultType2) {
    UserConfirmationResultType2[UserConfirmationResultType2["OPEN"] = 0] = "OPEN";
    UserConfirmationResultType2[UserConfirmationResultType2["ACCEPTED"] = 1] = "ACCEPTED";
    UserConfirmationResultType2[UserConfirmationResultType2["REJECTED"] = 2] = "REJECTED";
  })(UserConfirmationResultType || (UserConfirmationResultType = {}));
  proto3.util.setEnumType(UserConfirmationResultType, "domain.UserConfirmationResultType", [
    { no: 0, name: "USER_CONFIRMATION_RESULT_TYPE_OPEN" },
    { no: 1, name: "USER_CONFIRMATION_RESULT_TYPE_ACCEPTED" },
    { no: 2, name: "USER_CONFIRMATION_RESULT_TYPE_REJECTED" }
  ]);
  var UserConfirmationType;
  (function(UserConfirmationType2) {
    UserConfirmationType2[UserConfirmationType2["UNKNOWN"] = 0] = "UNKNOWN";
    UserConfirmationType2[UserConfirmationType2["DEBUG"] = 1] = "DEBUG";
    UserConfirmationType2[UserConfirmationType2["USER_EXPORT_VAULT"] = 10001] = "USER_EXPORT_VAULT";
    UserConfirmationType2[UserConfirmationType2["USER_EXPORT_ALL"] = 10002] = "USER_EXPORT_ALL";
    UserConfirmationType2[UserConfirmationType2["ORG_ADMIN_DELETE_ORG"] = 3e4] = "ORG_ADMIN_DELETE_ORG";
  })(UserConfirmationType || (UserConfirmationType = {}));
  proto3.util.setEnumType(UserConfirmationType, "domain.UserConfirmationType", [
    { no: 0, name: "USER_CONFIRMATION_TYPE_UNKNOWN" },
    { no: 1, name: "USER_CONFIRMATION_TYPE_DEBUG" },
    { no: 10001, name: "USER_CONFIRMATION_TYPE_USER_EXPORT_VAULT" },
    { no: 10002, name: "USER_CONFIRMATION_TYPE_USER_EXPORT_ALL" },
    { no: 3e4, name: "USER_CONFIRMATION_TYPE_ORG_ADMIN_DELETE_ORG" }
  ]);
  var UserType;
  (function(UserType2) {
    UserType2[UserType2["DEFAULT"] = 0] = "DEFAULT";
    UserType2[UserType2["ORGANIZATION_SUPER"] = 1] = "ORGANIZATION_SUPER";
    UserType2[UserType2["ORGANIZATION_SERVICE"] = 2] = "ORGANIZATION_SERVICE";
  })(UserType || (UserType = {}));
  proto3.util.setEnumType(UserType, "domain.UserType", [
    { no: 0, name: "USER_TYPE_DEFAULT" },
    { no: 1, name: "USER_TYPE_ORGANIZATION_SUPER" },
    { no: 2, name: "USER_TYPE_ORGANIZATION_SERVICE" }
  ]);
  var VaultMessageType;
  (function(VaultMessageType2) {
    VaultMessageType2[VaultMessageType2["UNKNOWN"] = 0] = "UNKNOWN";
    VaultMessageType2[VaultMessageType2["LOGIN_INBOX_V1"] = 1] = "LOGIN_INBOX_V1";
    VaultMessageType2[VaultMessageType2["LINKED_VAULT_DELETED_V1"] = 3] = "LINKED_VAULT_DELETED_V1";
    VaultMessageType2[VaultMessageType2["SHARE_LINK_OPENED_V1"] = 4] = "SHARE_LINK_OPENED_V1";
    VaultMessageType2[VaultMessageType2["LINKED_LOGIN_UPDATE_V1"] = 2] = "LINKED_LOGIN_UPDATE_V1";
    VaultMessageType2[VaultMessageType2["DEBUG"] = 999999] = "DEBUG";
  })(VaultMessageType || (VaultMessageType = {}));
  proto3.util.setEnumType(VaultMessageType, "domain.VaultMessageType", [
    { no: 0, name: "VAULT_MESSAGE_TYPE_UNKNOWN" },
    { no: 1, name: "VAULT_MESSAGE_TYPE_LOGIN_INBOX_V1" },
    { no: 3, name: "VAULT_MESSAGE_TYPE_LINKED_VAULT_DELETED_V1" },
    { no: 4, name: "VAULT_MESSAGE_TYPE_SHARE_LINK_OPENED_V1" },
    { no: 2, name: "VAULT_MESSAGE_TYPE_LINKED_LOGIN_UPDATE_V1" },
    { no: 999999, name: "VAULT_MESSAGE_TYPE_DEBUG" }
  ]);
  var ClientType;
  (function(ClientType2) {
    ClientType2[ClientType2["UNKNOWN"] = 0] = "UNKNOWN";
    ClientType2[ClientType2["TEST"] = 1] = "TEST";
    ClientType2[ClientType2["WEB"] = 100] = "WEB";
    ClientType2[ClientType2["AND"] = 200] = "AND";
    ClientType2[ClientType2["IOS"] = 210] = "IOS";
    ClientType2[ClientType2["EXT"] = 300] = "EXT";
    ClientType2[ClientType2["EXT_IOS"] = 301] = "EXT_IOS";
    ClientType2[ClientType2["CLI"] = 400] = "CLI";
    ClientType2[ClientType2["BAK"] = 401] = "BAK";
    ClientType2[ClientType2["BAE_AUDITLOG"] = 500] = "BAE_AUDITLOG";
  })(ClientType || (ClientType = {}));
  proto3.util.setEnumType(ClientType, "domain.ClientType", [
    { no: 0, name: "CLIENT_TYPE_UNKNOWN" },
    { no: 1, name: "CLIENT_TYPE_TEST" },
    { no: 100, name: "CLIENT_TYPE_WEB" },
    { no: 200, name: "CLIENT_TYPE_AND" },
    { no: 210, name: "CLIENT_TYPE_IOS" },
    { no: 300, name: "CLIENT_TYPE_EXT" },
    { no: 301, name: "CLIENT_TYPE_EXT_IOS" },
    { no: 400, name: "CLIENT_TYPE_CLI" },
    { no: 401, name: "CLIENT_TYPE_BAK" },
    { no: 500, name: "CLIENT_TYPE_BAE_AUDITLOG" }
  ]);
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__asyncValues || function(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d2, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d2 });
      }, reject);
    }
  };
  class LinkedLoginUpdateMessage extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.type = VaultMessageType.UNKNOWN;
      this.encryptedData = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LinkedLoginUpdateMessage().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LinkedLoginUpdateMessage().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LinkedLoginUpdateMessage().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(LinkedLoginUpdateMessage, a, b2);
    }
  }
  LinkedLoginUpdateMessage.runtime = proto3;
  LinkedLoginUpdateMessage.typeName = "domain.LinkedLoginUpdateMessage";
  LinkedLoginUpdateMessage.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(VaultMessageType) },
    {
      no: 4,
      name: "encrypted_data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class VaultRegenerateData extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.latestCommitId = "";
      this.newAuthenticatorEncryptedStorableVaultKeys = [];
      this.newAuthenticatorEncryptedHighSecurityVaultKeys = [];
      this.newAuthenticatorEncryptedVaultMessagePrivateKeys = [];
      this.authenticatorLocks = [];
      this.profileLocks = [];
      this.squashedCommits = new Uint8Array(0);
      this.messagePublicKey = new Uint8Array(0);
      this.deleteMessageIds = [];
      this.regeneratedMessages = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultRegenerateData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultRegenerateData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultRegenerateData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(VaultRegenerateData, a, b2);
    }
  }
  VaultRegenerateData.runtime = proto3;
  VaultRegenerateData.typeName = "domain.VaultRegenerateData";
  VaultRegenerateData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "latest_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "new_authenticator_encrypted_storable_vault_keys", kind: "scalar", T: 12, repeated: true },
    { no: 4, name: "new_authenticator_encrypted_high_security_vault_keys", kind: "scalar", T: 12, repeated: true },
    { no: 10, name: "new_authenticator_encrypted_vault_message_private_keys", kind: "scalar", T: 12, repeated: true },
    { no: 6, name: "authenticator_locks", kind: "message", T: VaultAuthenticatorLock$1, repeated: true },
    { no: 7, name: "profile_locks", kind: "message", T: VaultProfileLock$1, repeated: true },
    {
      no: 5,
      name: "squashed_commits",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 9, name: "delete_message_ids", kind: "scalar", T: 9, repeated: true },
    { no: 11, name: "regenerated_messages", kind: "message", T: VaultRegenerateData_RegeneratedMessage, repeated: true }
  ]);
  class VaultRegenerateData_RegeneratedMessage extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.encryptedData = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultRegenerateData_RegeneratedMessage().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultRegenerateData_RegeneratedMessage().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultRegenerateData_RegeneratedMessage().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(VaultRegenerateData_RegeneratedMessage, a, b2);
    }
  }
  VaultRegenerateData_RegeneratedMessage.runtime = proto3;
  VaultRegenerateData_RegeneratedMessage.typeName = "domain.VaultRegenerateData.RegeneratedMessage";
  VaultRegenerateData_RegeneratedMessage.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class VaultCreationData extends Message {
    constructor(data) {
      super();
      this.firstCommitBlob = new Uint8Array(0);
      this.authenticatorLocks = [];
      this.organizationId = "";
      this.messagePublicKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultCreationData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(VaultCreationData, a, b2);
    }
  }
  VaultCreationData.runtime = proto3;
  VaultCreationData.typeName = "domain.VaultCreationData";
  VaultCreationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "first_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 2, name: "authenticator_locks", kind: "message", T: VaultAuthenticatorLock$1, repeated: true },
    { no: 4, name: "profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 3,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 6, name: "admin_profile_lock", kind: "message", T: VaultProfileLock$1 }
  ]);
  class VaultPairCreationData extends Message {
    constructor(data) {
      super();
      this.firstCommitBlob = new Uint8Array(0);
      this.authenticatorLocks = [];
      this.messagePublicKey = new Uint8Array(0);
      this.associatedFirstCommitBlob = new Uint8Array(0);
      this.associatedAuthenticatorLocks = [];
      this.associatedMessagePublicKey = new Uint8Array(0);
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultPairCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultPairCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultPairCreationData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(VaultPairCreationData, a, b2);
    }
  }
  VaultPairCreationData.runtime = proto3;
  VaultPairCreationData.typeName = "domain.VaultPairCreationData";
  VaultPairCreationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "first_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 2, name: "authenticator_locks", kind: "message", T: VaultAuthenticatorLock$1, repeated: true },
    { no: 7, name: "profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 9,
      name: "message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 11, name: "admin_profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 4,
      name: "associated_first_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 5, name: "associated_authenticator_locks", kind: "message", T: VaultAuthenticatorLock$1, repeated: true },
    { no: 8, name: "associated_profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 10,
      name: "associated_message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 12, name: "associated_admin_profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 6,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShareLinkUpdate extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.encryptedPayload = new Uint8Array(0);
      this.encryptedProtectedSecret = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShareLinkUpdate().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShareLinkUpdate().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShareLinkUpdate().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ShareLinkUpdate, a, b2);
    }
  }
  ShareLinkUpdate.runtime = proto3;
  ShareLinkUpdate.typeName = "domain.ShareLinkUpdate";
  ShareLinkUpdate.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_payload",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "encrypted_protected_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ShareLinksDelete extends Message {
    constructor(data) {
      super();
      this.keepShareLinkIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShareLinksDelete().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShareLinksDelete().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShareLinksDelete().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ShareLinksDelete, a, b2);
    }
  }
  ShareLinksDelete.runtime = proto3;
  ShareLinksDelete.typeName = "domain.ShareLinksDelete";
  ShareLinksDelete.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "keep_share_link_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class CreateCommitRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.latestCommitId = "";
      this.newCommitBlob = new Uint8Array(0);
      this.deleteMessageIds = [];
      this.linkedUpdateMessages = [];
      this.shareLinkUpdates = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateCommitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateCommitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateCommitRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateCommitRequest, a, b2);
    }
  }
  CreateCommitRequest.runtime = proto3;
  CreateCommitRequest.typeName = "domain.CreateCommitRequest";
  CreateCommitRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "latest_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "new_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 4, name: "update_time", kind: "message", T: Timestamp },
    { no: 7, name: "delete_message_ids", kind: "scalar", T: 9, repeated: true },
    { no: 8, name: "linked_update_messages", kind: "message", T: LinkedLoginUpdateMessage, repeated: true },
    { no: 9, name: "share_link_updates", kind: "message", T: ShareLinkUpdate, repeated: true },
    { no: 10, name: "delete_share_links", kind: "message", T: ShareLinksDelete }
  ]);
  class CreateCommitResponse extends Message {
    constructor(data) {
      super();
      this.commitId = "";
      this.linkedUpdateMessageIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateCommitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateCommitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateCommitResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateCommitResponse, a, b2);
    }
  }
  CreateCommitResponse.runtime = proto3;
  CreateCommitResponse.typeName = "domain.CreateCommitResponse";
  CreateCommitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "linked_update_message_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class CreateGenerationRequest extends Message {
    constructor(data) {
      super();
      this.linkedUpdateMessages = [];
      this.shareLinkUpdates = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateGenerationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateGenerationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateGenerationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateGenerationRequest, a, b2);
    }
  }
  CreateGenerationRequest.runtime = proto3;
  CreateGenerationRequest.typeName = "domain.CreateGenerationRequest";
  CreateGenerationRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "message", T: VaultRegenerateData },
    { no: 2, name: "linked_update_messages", kind: "message", T: LinkedLoginUpdateMessage, repeated: true },
    { no: 3, name: "delete_share_links", kind: "message", T: ShareLinksDelete },
    { no: 4, name: "share_link_updates", kind: "message", T: ShareLinkUpdate, repeated: true }
  ]);
  class CreateGenerationResponse extends Message {
    constructor(data) {
      super();
      this.commitId = "";
      this.generationId = "";
      this.linkedUpdateMessageIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateGenerationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateGenerationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateGenerationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateGenerationResponse, a, b2);
    }
  }
  CreateGenerationResponse.runtime = proto3;
  CreateGenerationResponse.typeName = "domain.CreateGenerationResponse";
  CreateGenerationResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "sync_update", kind: "message", T: SyncUpdate },
    { no: 4, name: "linked_update_message_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListCommitsRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.forceLocks = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListCommitsRequest, a, b2);
    }
  }
  ListCommitsRequest.runtime = proto3;
  ListCommitsRequest.typeName = "domain.ListCommitsRequest";
  ListCommitsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "latest_commit_id", kind: "message", T: StringValue },
    { no: 4, name: "latest_first_commit_id", kind: "message", T: StringValue },
    {
      no: 3,
      name: "force_locks",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ListCommitsResponse extends Message {
    constructor(data) {
      super();
      this.currentGenerationId = "";
      this.newerCommits = [];
      this.authenticatorLocks = [];
      this.firstCommitId = "";
      this.messages = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListCommitsResponse, a, b2);
    }
  }
  ListCommitsResponse.runtime = proto3;
  ListCommitsResponse.typeName = "domain.ListCommitsResponse";
  ListCommitsResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "current_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "newer_commits", kind: "message", T: ListCommitsResponse_Commit, repeated: true },
    { no: 3, name: "authenticator_locks", kind: "message", T: ListCommitsResponse_AuthenticatorLock, repeated: true },
    { no: 6, name: "profile_lock", kind: "message", T: VaultProfileLock$1 },
    { no: 8, name: "admin_profile_lock", kind: "message", T: VaultProfileLock$1 },
    { no: 4, name: "server_time", kind: "message", T: Timestamp },
    {
      no: 5,
      name: "first_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 7, name: "messages", kind: "message", T: ListCommitsResponse_Message, repeated: true }
  ]);
  class ListCommitsResponse_Commit extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.blob = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsResponse_Commit().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsResponse_Commit().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsResponse_Commit().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListCommitsResponse_Commit, a, b2);
    }
  }
  ListCommitsResponse_Commit.runtime = proto3;
  ListCommitsResponse_Commit.typeName = "domain.ListCommitsResponse.Commit";
  ListCommitsResponse_Commit.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ListCommitsResponse_AuthenticatorLock extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      this.encryptedStorableVaultKey = new Uint8Array(0);
      this.encryptedHighSecurityVaultKey = new Uint8Array(0);
      this.encryptedVaultMessagePrivateKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsResponse_AuthenticatorLock().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsResponse_AuthenticatorLock().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsResponse_AuthenticatorLock().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListCommitsResponse_AuthenticatorLock, a, b2);
    }
  }
  ListCommitsResponse_AuthenticatorLock.runtime = proto3;
  ListCommitsResponse_AuthenticatorLock.typeName = "domain.ListCommitsResponse.AuthenticatorLock";
  ListCommitsResponse_AuthenticatorLock.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ListCommitsResponse_Message extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.type = VaultMessageType.UNKNOWN;
      this.encryptedData = new Uint8Array(0);
      this.senderVaultId = "";
      this.backendMessage = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsResponse_Message().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsResponse_Message().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsResponse_Message().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListCommitsResponse_Message, a, b2);
    }
  }
  ListCommitsResponse_Message.runtime = proto3;
  ListCommitsResponse_Message.typeName = "domain.ListCommitsResponse.Message";
  ListCommitsResponse_Message.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(VaultMessageType) },
    {
      no: 3,
      name: "encrypted_data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "sender_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "backend_message",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateTeamRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTeamRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTeamRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTeamRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateTeamRequest, a, b2);
    }
  }
  CreateTeamRequest.runtime = proto3;
  CreateTeamRequest.typeName = "domain.CreateTeamRequest";
  CreateTeamRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "creation_data", kind: "message", T: VaultPairCreationData }
  ]);
  class CreateTeamResponse extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.associatedVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTeamResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTeamResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTeamResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateTeamResponse, a, b2);
    }
  }
  CreateTeamResponse.runtime = proto3;
  CreateTeamResponse.typeName = "domain.CreateTeamResponse";
  CreateTeamResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteTeamRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteTeamRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteTeamRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteTeamRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteTeamRequest, a, b2);
    }
  }
  DeleteTeamRequest.runtime = proto3;
  DeleteTeamRequest.typeName = "domain.DeleteTeamRequest";
  DeleteTeamRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteTeamResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteTeamResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteTeamResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteTeamResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteTeamResponse, a, b2);
    }
  }
  DeleteTeamResponse.runtime = proto3;
  DeleteTeamResponse.typeName = "domain.DeleteTeamResponse";
  DeleteTeamResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ModifyTeamUsersRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.addProfileOps = [];
      this.removeProfileIds = [];
      this.assocLatestCommitId = "";
      this.assocNewCommitBlob = new Uint8Array(0);
      this.generationId = "";
      this.assocGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyTeamUsersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyTeamUsersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyTeamUsersRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ModifyTeamUsersRequest, a, b2);
    }
  }
  ModifyTeamUsersRequest.runtime = proto3;
  ModifyTeamUsersRequest.typeName = "domain.ModifyTeamUsersRequest";
  ModifyTeamUsersRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 11, name: "add_profile_ops", kind: "message", T: ModifyTeamUsersRequest_AddProfileOperation, repeated: true },
    { no: 12, name: "remove_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 4, name: "regenerate_data", kind: "message", T: VaultRegenerateData },
    { no: 5, name: "associated_regenerate_data", kind: "message", T: VaultRegenerateData },
    { no: 6, name: "update_time", kind: "message", T: Timestamp },
    {
      no: 7,
      name: "assoc_latest_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "assoc_new_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "assoc_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ModifyTeamUsersRequest_AddProfileOperation extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyTeamUsersRequest_AddProfileOperation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyTeamUsersRequest_AddProfileOperation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyTeamUsersRequest_AddProfileOperation().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ModifyTeamUsersRequest_AddProfileOperation, a, b2);
    }
  }
  ModifyTeamUsersRequest_AddProfileOperation.runtime = proto3;
  ModifyTeamUsersRequest_AddProfileOperation.typeName = "domain.ModifyTeamUsersRequest.AddProfileOperation";
  ModifyTeamUsersRequest_AddProfileOperation.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "lock", kind: "message", T: VaultProfileLock$1 },
    { no: 3, name: "associated_lock", kind: "message", T: VaultProfileLock$1 }
  ]);
  class ModifyTeamUsersResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyTeamUsersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyTeamUsersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyTeamUsersResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ModifyTeamUsersResponse, a, b2);
    }
  }
  ModifyTeamUsersResponse.runtime = proto3;
  ModifyTeamUsersResponse.typeName = "domain.ModifyTeamUsersResponse";
  ModifyTeamUsersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CreateInboxVaultRequest extends Message {
    constructor(data) {
      super();
      this.slug = "";
      this.metadata = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateInboxVaultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateInboxVaultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateInboxVaultRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateInboxVaultRequest, a, b2);
    }
  }
  CreateInboxVaultRequest.runtime = proto3;
  CreateInboxVaultRequest.typeName = "domain.CreateInboxVaultRequest";
  CreateInboxVaultRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "creation_data", kind: "message", T: VaultPairCreationData },
    {
      no: 2,
      name: "slug",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateInboxVaultResponse extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.associatedVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateInboxVaultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateInboxVaultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateInboxVaultResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateInboxVaultResponse, a, b2);
    }
  }
  CreateInboxVaultResponse.runtime = proto3;
  CreateInboxVaultResponse.typeName = "domain.CreateInboxVaultResponse";
  CreateInboxVaultResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class UpdateInboxRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateInboxRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateInboxRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateInboxRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateInboxRequest, a, b2);
    }
  }
  UpdateInboxRequest.runtime = proto3;
  UpdateInboxRequest.typeName = "domain.UpdateInboxRequest";
  UpdateInboxRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "slug", kind: "message", T: StringValue },
    { no: 3, name: "metadata", kind: "message", T: StringValue }
  ]);
  class UpdateInboxResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateInboxResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateInboxResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateInboxResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateInboxResponse, a, b2);
    }
  }
  UpdateInboxResponse.runtime = proto3;
  UpdateInboxResponse.typeName = "domain.UpdateInboxResponse";
  UpdateInboxResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteInboxVaultRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteInboxVaultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteInboxVaultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteInboxVaultRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteInboxVaultRequest, a, b2);
    }
  }
  DeleteInboxVaultRequest.runtime = proto3;
  DeleteInboxVaultRequest.typeName = "domain.DeleteInboxVaultRequest";
  DeleteInboxVaultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteInboxVaultResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteInboxVaultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteInboxVaultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteInboxVaultResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteInboxVaultResponse, a, b2);
    }
  }
  DeleteInboxVaultResponse.runtime = proto3;
  DeleteInboxVaultResponse.typeName = "domain.DeleteInboxVaultResponse";
  DeleteInboxVaultResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ListMessagePublicKeysRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.vaultIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListMessagePublicKeysRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListMessagePublicKeysRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListMessagePublicKeysRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListMessagePublicKeysRequest, a, b2);
    }
  }
  ListMessagePublicKeysRequest.runtime = proto3;
  ListMessagePublicKeysRequest.typeName = "domain.ListMessagePublicKeysRequest";
  ListMessagePublicKeysRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "vault_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListMessagePublicKeysResponse extends Message {
    constructor(data) {
      super();
      this.messagePublicKeys = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListMessagePublicKeysResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListMessagePublicKeysResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListMessagePublicKeysResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListMessagePublicKeysResponse, a, b2);
    }
  }
  ListMessagePublicKeysResponse.runtime = proto3;
  ListMessagePublicKeysResponse.typeName = "domain.ListMessagePublicKeysResponse";
  ListMessagePublicKeysResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "message_public_keys", kind: "message", T: ListMessagePublicKeysResponse_MessagePublicKey, repeated: true }
  ]);
  class ListMessagePublicKeysResponse_MessagePublicKey extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.key = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListMessagePublicKeysResponse_MessagePublicKey().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListMessagePublicKeysResponse_MessagePublicKey().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListMessagePublicKeysResponse_MessagePublicKey().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListMessagePublicKeysResponse_MessagePublicKey, a, b2);
    }
  }
  ListMessagePublicKeysResponse_MessagePublicKey.runtime = proto3;
  ListMessagePublicKeysResponse_MessagePublicKey.typeName = "domain.ListMessagePublicKeysResponse.MessagePublicKey";
  ListMessagePublicKeysResponse_MessagePublicKey.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class WriteEventsRequest extends Message {
    constructor(data) {
      super();
      this.events = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteEventsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteEventsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteEventsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(WriteEventsRequest, a, b2);
    }
  }
  WriteEventsRequest.runtime = proto3;
  WriteEventsRequest.typeName = "domain.WriteEventsRequest";
  WriteEventsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: WriteEventsRequest_Event, repeated: true }
  ]);
  class WriteEventsRequest_Event extends Message {
    constructor(data) {
      super();
      this.eventJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteEventsRequest_Event().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteEventsRequest_Event().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteEventsRequest_Event().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(WriteEventsRequest_Event, a, b2);
    }
  }
  WriteEventsRequest_Event.runtime = proto3;
  WriteEventsRequest_Event.typeName = "domain.WriteEventsRequest.Event";
  WriteEventsRequest_Event.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "event_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "client_time", kind: "message", T: Timestamp },
    { no: 3, name: "last_known_server_time", kind: "message", T: Timestamp }
  ]);
  class WriteEventsResponse extends Message {
    constructor(data) {
      super();
      this.eventIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteEventsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteEventsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteEventsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(WriteEventsResponse, a, b2);
    }
  }
  WriteEventsResponse.runtime = proto3;
  WriteEventsResponse.typeName = "domain.WriteEventsResponse";
  WriteEventsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "event_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListEventsRequest extends Message {
    constructor(data) {
      super();
      this.page = 0;
      this.eventTypes = [];
      this.filterProfileIds = [];
      this.filterTargetProfileIds = [];
      this.filterVaultIds = [];
      this.filterLoginIds = [];
      this.filterIpPrefix = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListEventsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListEventsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListEventsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListEventsRequest, a, b2);
    }
  }
  ListEventsRequest.runtime = proto3;
  ListEventsRequest.typeName = "domain.ListEventsRequest";
  ListEventsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "time_anchor", kind: "message", T: Timestamp },
    {
      no: 2,
      name: "page",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 3, name: "from_time", kind: "message", T: Timestamp },
    { no: 4, name: "to_time", kind: "message", T: Timestamp },
    { no: 5, name: "event_types", kind: "enum", T: proto3.getEnumType(AuditlogEventType), repeated: true },
    { no: 6, name: "filter_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 11, name: "filter_target_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 7, name: "filter_vault_ids", kind: "scalar", T: 9, repeated: true },
    { no: 8, name: "filter_login_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 10,
      name: "filter_ip_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "additional_filter", kind: "message", T: ListEventsRequest_MatchAnyFilter }
  ]);
  class ListEventsRequest_MatchAnyFilter extends Message {
    constructor(data) {
      super();
      this.profileIds = [];
      this.targetProfileIds = [];
      this.vaultIds = [];
      this.loginIds = [];
      this.filterIpPrefix = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListEventsRequest_MatchAnyFilter().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListEventsRequest_MatchAnyFilter().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListEventsRequest_MatchAnyFilter().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListEventsRequest_MatchAnyFilter, a, b2);
    }
  }
  ListEventsRequest_MatchAnyFilter.runtime = proto3;
  ListEventsRequest_MatchAnyFilter.typeName = "domain.ListEventsRequest.MatchAnyFilter";
  ListEventsRequest_MatchAnyFilter.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 5, name: "target_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 2, name: "vault_ids", kind: "scalar", T: 9, repeated: true },
    { no: 3, name: "login_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 4,
      name: "filter_ip_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ListEventsResponse extends Message {
    constructor(data) {
      super();
      this.envelopedEventJson = [];
      this.totalCount = protoInt64.zero;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListEventsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListEventsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListEventsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListEventsResponse, a, b2);
    }
  }
  ListEventsResponse.runtime = proto3;
  ListEventsResponse.typeName = "domain.ListEventsResponse";
  ListEventsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "enveloped_event_json", kind: "scalar", T: 9, repeated: true },
    {
      no: 2,
      name: "total_count",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 3, name: "time_anchor", kind: "message", T: Timestamp }
  ]);
  ({
    typeName: "domain.AuditlogService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - AuditlogMalformedEvent (90500)
       * - Internal (10500)
       *
       * @generated from rpc domain.AuditlogService.WriteEvents
       */
      writeEvents: {
        name: "WriteEvents",
        I: WriteEventsRequest,
        O: WriteEventsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.AuditlogService.ListEvents
       */
      listEvents: {
        name: "ListEvents",
        I: ListEventsRequest,
        O: ListEventsResponse,
        kind: MethodKind.Unary
      }
    }
  });
  const BackendErrorCode = ErrorCode;
  class BackendDomainError extends DomainError$1 {
    constructor(grpcStatus, code, short, userTitle, userDetail, requestId) {
      super(code, short, userTitle, userDetail);
      this.grpcStatus = grpcStatus;
      this.requestId = requestId;
      this.name = "BackendDomainError";
    }
  }
  class DomainError extends Message {
    constructor(data) {
      super();
      this.code = 0;
      this.userTitle = "";
      this.userDetail = "";
      this.requestId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DomainError().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DomainError().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DomainError().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DomainError, a, b2);
    }
  }
  DomainError.runtime = proto3;
  DomainError.typeName = "domain.DomainError";
  DomainError.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "code",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "user_title",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "user_detail",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class Status extends Message {
    constructor(data) {
      super();
      this.code = 0;
      this.message = "";
      this.details = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new Status().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Status().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Status().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(Status, a, b2);
    }
  }
  Status.runtime = proto3;
  Status.typeName = "domain.Status";
  Status.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "code",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: "message",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "details", kind: "message", T: Any, repeated: true }
  ]);
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__asyncValues || function(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d2, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d2 });
      }, reject);
    }
  };
  var __await = globalThis && globalThis.__await || function(v2) {
    return this instanceof __await ? (this.v = v2, this) : new __await(v2);
  };
  globalThis && globalThis.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function awaitReturn(f2) {
      return function(v2) {
        return Promise.resolve(v2).then(f2, reject);
      };
    }
    function verb(n2, f2) {
      if (g2[n2]) {
        i2[n2] = function(v2) {
          return new Promise(function(a, b2) {
            q2.push([n2, v2, a, b2]) > 1 || resume(n2, v2);
          });
        };
        if (f2)
          i2[n2] = f2(i2[n2]);
      }
    }
    function resume(n2, v2) {
      try {
        step(g2[n2](v2));
      } catch (e2) {
        settle(q2[0][3], e2);
      }
    }
    function step(r2) {
      r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v2) {
      if (f2(v2), q2.shift(), q2.length)
        resume(q2[0][0], q2[0][1]);
    }
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class LoginClientPubKeyBody extends Message {
    constructor(data) {
      super();
      this.clientPubKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LoginClientPubKeyBody().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LoginClientPubKeyBody().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LoginClientPubKeyBody().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(LoginClientPubKeyBody, a, b2);
    }
  }
  LoginClientPubKeyBody.runtime = proto3;
  LoginClientPubKeyBody.typeName = "domain.LoginClientPubKeyBody";
  LoginClientPubKeyBody.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "client_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class LoginAuthenticatorPubKeyBody extends Message {
    constructor(data) {
      super();
      this.authenticatorPubKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LoginAuthenticatorPubKeyBody().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LoginAuthenticatorPubKeyBody().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LoginAuthenticatorPubKeyBody().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(LoginAuthenticatorPubKeyBody, a, b2);
    }
  }
  LoginAuthenticatorPubKeyBody.runtime = proto3;
  LoginAuthenticatorPubKeyBody.typeName = "domain.LoginAuthenticatorPubKeyBody";
  LoginAuthenticatorPubKeyBody.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "authenticator_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class LoginHashCommitmentBody extends Message {
    constructor(data) {
      super();
      this.hashCommitment = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LoginHashCommitmentBody().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LoginHashCommitmentBody().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LoginHashCommitmentBody().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(LoginHashCommitmentBody, a, b2);
    }
  }
  LoginHashCommitmentBody.runtime = proto3;
  LoginHashCommitmentBody.typeName = "domain.LoginHashCommitmentBody";
  LoginHashCommitmentBody.fields = proto3.util.newFieldList(() => [
    {
      no: 3,
      name: "hash_commitment",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class LoginEncryptedSecretBody extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LoginEncryptedSecretBody().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LoginEncryptedSecretBody().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LoginEncryptedSecretBody().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(LoginEncryptedSecretBody, a, b2);
    }
  }
  LoginEncryptedSecretBody.runtime = proto3;
  LoginEncryptedSecretBody.typeName = "domain.LoginEncryptedSecretBody";
  LoginEncryptedSecretBody.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class Token extends Message {
    constructor(data) {
      super();
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new Token().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Token().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Token().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(Token, a, b2);
    }
  }
  Token.runtime = proto3;
  Token.typeName = "domain.Token";
  Token.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "expires_at", kind: "message", T: Timestamp }
  ]);
  class CreateChallengeRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.backupAuthenticatorId = "";
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChallengeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChallengeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChallengeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateChallengeRequest, a, b2);
    }
  }
  CreateChallengeRequest.runtime = proto3;
  CreateChallengeRequest.typeName = "domain.CreateChallengeRequest";
  CreateChallengeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "backup_authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateChallengeResponse extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.challenge = "";
      this.authenticators = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChallengeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChallengeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChallengeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateChallengeResponse, a, b2);
    }
  }
  CreateChallengeResponse.runtime = proto3;
  CreateChallengeResponse.typeName = "domain.CreateChallengeResponse";
  CreateChallengeResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "challenge",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "authenticators", kind: "message", T: CreateChallengeResponse_Authenticator, repeated: true }
  ]);
  class CreateChallengeResponse_Authenticator extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.authenticatorType = AuthenticatorType.UNKNOWN;
      this.secretInfo = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChallengeResponse_Authenticator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChallengeResponse_Authenticator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChallengeResponse_Authenticator().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateChallengeResponse_Authenticator, a, b2);
    }
  }
  CreateChallengeResponse_Authenticator.runtime = proto3;
  CreateChallengeResponse_Authenticator.typeName = "domain.CreateChallengeResponse.Authenticator";
  CreateChallengeResponse_Authenticator.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "authenticator_type", kind: "enum", T: proto3.getEnumType(AuthenticatorType) },
    {
      no: 3,
      name: "secret_info",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "webauthn", kind: "message", T: CreateChallengeResponse_Authenticator_Webauthn }
  ]);
  class CreateChallengeResponse_Authenticator_Webauthn extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      this.prfSalt = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChallengeResponse_Authenticator_Webauthn().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChallengeResponse_Authenticator_Webauthn().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChallengeResponse_Authenticator_Webauthn().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateChallengeResponse_Authenticator_Webauthn, a, b2);
    }
  }
  CreateChallengeResponse_Authenticator_Webauthn.runtime = proto3;
  CreateChallengeResponse_Authenticator_Webauthn.typeName = "domain.CreateChallengeResponse.Authenticator.Webauthn";
  CreateChallengeResponse_Authenticator_Webauthn.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "prf_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateLongPollChannelChallengeRequest extends Message {
    constructor(data) {
      super();
      this.publicKeyHash = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLongPollChannelChallengeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLongPollChannelChallengeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLongPollChannelChallengeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateLongPollChannelChallengeRequest, a, b2);
    }
  }
  CreateLongPollChannelChallengeRequest.runtime = proto3;
  CreateLongPollChannelChallengeRequest.typeName = "domain.CreateLongPollChannelChallengeRequest";
  CreateLongPollChannelChallengeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "public_key_hash",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateLongPollChannelChallengeResponse extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.challenge = "";
      this.authenticatorReply = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLongPollChannelChallengeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLongPollChannelChallengeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLongPollChannelChallengeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateLongPollChannelChallengeResponse, a, b2);
    }
  }
  CreateLongPollChannelChallengeResponse.runtime = proto3;
  CreateLongPollChannelChallengeResponse.typeName = "domain.CreateLongPollChannelChallengeResponse";
  CreateLongPollChannelChallengeResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "challenge",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "authenticator", kind: "message", T: CreateLongPollChannelChallengeResponse_Authenticator },
    {
      no: 4,
      name: "authenticator_reply",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateLongPollChannelChallengeResponse_Authenticator extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.authenticatorType = AuthenticatorType.UNKNOWN;
      this.secretInfo = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLongPollChannelChallengeResponse_Authenticator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLongPollChannelChallengeResponse_Authenticator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLongPollChannelChallengeResponse_Authenticator().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateLongPollChannelChallengeResponse_Authenticator, a, b2);
    }
  }
  CreateLongPollChannelChallengeResponse_Authenticator.runtime = proto3;
  CreateLongPollChannelChallengeResponse_Authenticator.typeName = "domain.CreateLongPollChannelChallengeResponse.Authenticator";
  CreateLongPollChannelChallengeResponse_Authenticator.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "authenticator_type", kind: "enum", T: proto3.getEnumType(AuthenticatorType) },
    {
      no: 3,
      name: "secret_info",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CompleteLongPollChannelRequest extends Message {
    constructor(data) {
      super();
      this.publicKeyHash = "";
      this.authenticatorId = "";
      this.authenticatorReply = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CompleteLongPollChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CompleteLongPollChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CompleteLongPollChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CompleteLongPollChannelRequest, a, b2);
    }
  }
  CompleteLongPollChannelRequest.runtime = proto3;
  CompleteLongPollChannelRequest.typeName = "domain.CompleteLongPollChannelRequest";
  CompleteLongPollChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "public_key_hash",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "authenticator_reply",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CompleteLongPollChannelResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CompleteLongPollChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CompleteLongPollChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CompleteLongPollChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CompleteLongPollChannelResponse, a, b2);
    }
  }
  CompleteLongPollChannelResponse.runtime = proto3;
  CompleteLongPollChannelResponse.typeName = "domain.CompleteLongPollChannelResponse";
  CompleteLongPollChannelResponse.fields = proto3.util.newFieldList(() => []);
  class CreateTokensRequest extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      this.challenge = "";
      this.response = new Uint8Array(0);
      this.sessionType = SessionType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTokensRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTokensRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTokensRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateTokensRequest, a, b2);
    }
  }
  CreateTokensRequest.runtime = proto3;
  CreateTokensRequest.typeName = "domain.CreateTokensRequest";
  CreateTokensRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "challenge",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "response",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 5, name: "session_unlock", kind: "message", T: CreateTokensRequest_SessionUnlock },
    { no: 6, name: "session_type", kind: "enum", T: proto3.getEnumType(SessionType) }
  ]);
  class CreateTokensRequest_SessionUnlock extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      this.singleUse = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTokensRequest_SessionUnlock().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTokensRequest_SessionUnlock().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTokensRequest_SessionUnlock().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateTokensRequest_SessionUnlock, a, b2);
    }
  }
  CreateTokensRequest_SessionUnlock.runtime = proto3;
  CreateTokensRequest_SessionUnlock.typeName = "domain.CreateTokensRequest.SessionUnlock";
  CreateTokensRequest_SessionUnlock.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 3, name: "expires_at", kind: "message", T: Timestamp },
    {
      no: 5,
      name: "single_use",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class CreateTokensResponse extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTokensResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTokensResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTokensResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateTokensResponse, a, b2);
    }
  }
  CreateTokensResponse.runtime = proto3;
  CreateTokensResponse.typeName = "domain.CreateTokensResponse";
  CreateTokensResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "access_token", kind: "message", T: Token },
    {
      no: 2,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CreateAuditlogWriteTokenRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAuditlogWriteTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAuditlogWriteTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAuditlogWriteTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateAuditlogWriteTokenRequest, a, b2);
    }
  }
  CreateAuditlogWriteTokenRequest.runtime = proto3;
  CreateAuditlogWriteTokenRequest.typeName = "domain.CreateAuditlogWriteTokenRequest";
  CreateAuditlogWriteTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateAuditlogWriteTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAuditlogWriteTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAuditlogWriteTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAuditlogWriteTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateAuditlogWriteTokenResponse, a, b2);
    }
  }
  CreateAuditlogWriteTokenResponse.runtime = proto3;
  CreateAuditlogWriteTokenResponse.typeName = "domain.CreateAuditlogWriteTokenResponse";
  CreateAuditlogWriteTokenResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "message", T: Token }
  ]);
  class CreateAuditlogAdminTokenRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAuditlogAdminTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAuditlogAdminTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAuditlogAdminTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateAuditlogAdminTokenRequest, a, b2);
    }
  }
  CreateAuditlogAdminTokenRequest.runtime = proto3;
  CreateAuditlogAdminTokenRequest.typeName = "domain.CreateAuditlogAdminTokenRequest";
  CreateAuditlogAdminTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateAuditlogAdminTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAuditlogAdminTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAuditlogAdminTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAuditlogAdminTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateAuditlogAdminTokenResponse, a, b2);
    }
  }
  CreateAuditlogAdminTokenResponse.runtime = proto3;
  CreateAuditlogAdminTokenResponse.typeName = "domain.CreateAuditlogAdminTokenResponse";
  CreateAuditlogAdminTokenResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "message", T: Token }
  ]);
  class CreateLFDOverridesAdminTokenRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLFDOverridesAdminTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLFDOverridesAdminTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLFDOverridesAdminTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateLFDOverridesAdminTokenRequest, a, b2);
    }
  }
  CreateLFDOverridesAdminTokenRequest.runtime = proto3;
  CreateLFDOverridesAdminTokenRequest.typeName = "domain.CreateLFDOverridesAdminTokenRequest";
  CreateLFDOverridesAdminTokenRequest.fields = proto3.util.newFieldList(() => []);
  class CreateLFDOverridesAdminTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLFDOverridesAdminTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLFDOverridesAdminTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLFDOverridesAdminTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateLFDOverridesAdminTokenResponse, a, b2);
    }
  }
  CreateLFDOverridesAdminTokenResponse.runtime = proto3;
  CreateLFDOverridesAdminTokenResponse.typeName = "domain.CreateLFDOverridesAdminTokenResponse";
  CreateLFDOverridesAdminTokenResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "message", T: Token }
  ]);
  class RefreshTokenRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RefreshTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RefreshTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RefreshTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RefreshTokenRequest, a, b2);
    }
  }
  RefreshTokenRequest.runtime = proto3;
  RefreshTokenRequest.typeName = "domain.RefreshTokenRequest";
  RefreshTokenRequest.fields = proto3.util.newFieldList(() => []);
  class RefreshTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RefreshTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RefreshTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RefreshTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RefreshTokenResponse, a, b2);
    }
  }
  RefreshTokenResponse.runtime = proto3;
  RefreshTokenResponse.typeName = "domain.RefreshTokenResponse";
  RefreshTokenResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "new_access_token", kind: "message", T: Token }
  ]);
  class GetRegistrationInfoRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetRegistrationInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetRegistrationInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetRegistrationInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetRegistrationInfoRequest, a, b2);
    }
  }
  GetRegistrationInfoRequest.runtime = proto3;
  GetRegistrationInfoRequest.typeName = "domain.GetRegistrationInfoRequest";
  GetRegistrationInfoRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetRegistrationInfoResponse extends Message {
    constructor(data) {
      super();
      this.status = RegistrationInfoStatus.UNKNOWN;
      this.webauthnAllowed = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetRegistrationInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetRegistrationInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetRegistrationInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetRegistrationInfoResponse, a, b2);
    }
  }
  GetRegistrationInfoResponse.runtime = proto3;
  GetRegistrationInfoResponse.typeName = "domain.GetRegistrationInfoResponse";
  GetRegistrationInfoResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(RegistrationInfoStatus) },
    { no: 2, name: "organization", kind: "message", T: GetRegistrationInfoResponse_Organization },
    {
      no: 3,
      name: "webauthn_allowed",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class GetRegistrationInfoResponse_Organization extends Message {
    constructor(data) {
      super();
      this.name = "";
      this.icon = "";
      this.id = "";
      this.profileId = "";
      this.startCodePrefix = "";
      this.organizationType = OrganizationType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetRegistrationInfoResponse_Organization().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetRegistrationInfoResponse_Organization().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetRegistrationInfoResponse_Organization().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetRegistrationInfoResponse_Organization, a, b2);
    }
  }
  GetRegistrationInfoResponse_Organization.runtime = proto3;
  GetRegistrationInfoResponse_Organization.typeName = "domain.GetRegistrationInfoResponse.Organization";
  GetRegistrationInfoResponse_Organization.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "start_code_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "organization_type", kind: "enum", T: proto3.getEnumType(OrganizationType) }
  ]);
  class CreateAccountWithProfileRequest extends Message {
    constructor(data) {
      super();
      this.authenticators = [];
      this.referrerId = "";
      this.authenticatorBlock = new Uint8Array(0);
      this.authenticatorBlockSignature = new Uint8Array(0);
      this.preliminaryEmail = "";
      this.startCode = "";
      this.startCodeProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAccountWithProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAccountWithProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAccountWithProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateAccountWithProfileRequest, a, b2);
    }
  }
  CreateAccountWithProfileRequest.runtime = proto3;
  CreateAccountWithProfileRequest.typeName = "domain.CreateAccountWithProfileRequest";
  CreateAccountWithProfileRequest.fields = proto3.util.newFieldList(() => [
    { no: 14, name: "authenticators", kind: "message", T: AuthenticatorCreationData, repeated: true },
    { no: 2, name: "preferences_profile", kind: "message", T: ProfileData },
    { no: 3, name: "inbox_profile", kind: "message", T: ProfileData },
    { no: 4, name: "meta_vault", kind: "message", T: VaultCreationData },
    {
      no: 5,
      name: "referrer_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "authenticator_block",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "authenticator_block_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "preliminary_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 13,
      name: "start_code",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 15, name: "session_unlock_data", kind: "message", T: CreateAccountWithProfileRequest_SessionUnlockData },
    { no: 16, name: "webauthn_credential_data", kind: "message", T: CreateAccountWithProfileRequest_WebauthnCredentialData },
    {
      no: 17,
      name: "start_code_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateAccountWithProfileRequest_WebauthnCredentialData extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.responseJson = "";
      this.prfSupportStatus = WebauthnPrfSupportStatus.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAccountWithProfileRequest_WebauthnCredentialData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAccountWithProfileRequest_WebauthnCredentialData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAccountWithProfileRequest_WebauthnCredentialData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateAccountWithProfileRequest_WebauthnCredentialData, a, b2);
    }
  }
  CreateAccountWithProfileRequest_WebauthnCredentialData.runtime = proto3;
  CreateAccountWithProfileRequest_WebauthnCredentialData.typeName = "domain.CreateAccountWithProfileRequest.WebauthnCredentialData";
  CreateAccountWithProfileRequest_WebauthnCredentialData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "prf_support_status", kind: "enum", T: proto3.getEnumType(WebauthnPrfSupportStatus) }
  ]);
  class CreateAccountWithProfileRequest_SessionUnlockData extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAccountWithProfileRequest_SessionUnlockData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAccountWithProfileRequest_SessionUnlockData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAccountWithProfileRequest_SessionUnlockData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateAccountWithProfileRequest_SessionUnlockData, a, b2);
    }
  }
  CreateAccountWithProfileRequest_SessionUnlockData.runtime = proto3;
  CreateAccountWithProfileRequest_SessionUnlockData.typeName = "domain.CreateAccountWithProfileRequest.SessionUnlockData";
  CreateAccountWithProfileRequest_SessionUnlockData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 2, name: "unlock_max_expires_at", kind: "message", T: Timestamp }
  ]);
  class CreateAccountWithProfileResponse extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.sessionId = "";
      this.authenticatorIds = [];
      this.preferencesProfileId = "";
      this.metaVaultId = "";
      this.inboxProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAccountWithProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAccountWithProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAccountWithProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateAccountWithProfileResponse, a, b2);
    }
  }
  CreateAccountWithProfileResponse.runtime = proto3;
  CreateAccountWithProfileResponse.typeName = "domain.CreateAccountWithProfileResponse";
  CreateAccountWithProfileResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "access_token", kind: "message", T: Token },
    {
      no: 3,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "authenticator_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 5,
      name: "preferences_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "meta_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "inbox_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class UpdateAccountRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateAccountRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateAccountRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateAccountRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateAccountRequest, a, b2);
    }
  }
  UpdateAccountRequest.runtime = proto3;
  UpdateAccountRequest.typeName = "domain.UpdateAccountRequest";
  UpdateAccountRequest.fields = proto3.util.newFieldList(() => [
    { no: 2, name: "preferred_locale", kind: "message", T: StringValue },
    { no: 3, name: "user_client_settings", kind: "message", T: StringValue }
  ]);
  class UpdateAccountResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateAccountResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateAccountResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateAccountResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateAccountResponse, a, b2);
    }
  }
  UpdateAccountResponse.runtime = proto3;
  UpdateAccountResponse.typeName = "domain.UpdateAccountResponse";
  UpdateAccountResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CreateReferrerRequest extends Message {
    constructor(data) {
      super();
      this.referrer = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateReferrerRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateReferrerRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateReferrerRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateReferrerRequest, a, b2);
    }
  }
  CreateReferrerRequest.runtime = proto3;
  CreateReferrerRequest.typeName = "domain.CreateReferrerRequest";
  CreateReferrerRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "referrer",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateReferrerResponse extends Message {
    constructor(data) {
      super();
      this.referrerId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateReferrerResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateReferrerResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateReferrerResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateReferrerResponse, a, b2);
    }
  }
  CreateReferrerResponse.runtime = proto3;
  CreateReferrerResponse.typeName = "domain.CreateReferrerResponse";
  CreateReferrerResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "referrer_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class AddAchievementsRequest extends Message {
    constructor(data) {
      super();
      this.achievements = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AddAchievementsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AddAchievementsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AddAchievementsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AddAchievementsRequest, a, b2);
    }
  }
  AddAchievementsRequest.runtime = proto3;
  AddAchievementsRequest.typeName = "domain.AddAchievementsRequest";
  AddAchievementsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "achievements", kind: "enum", T: proto3.getEnumType(Achievement), repeated: true }
  ]);
  class AddAchievementsResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AddAchievementsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AddAchievementsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AddAchievementsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AddAchievementsResponse, a, b2);
    }
  }
  AddAchievementsResponse.runtime = proto3;
  AddAchievementsResponse.typeName = "domain.AddAchievementsResponse";
  AddAchievementsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ListAccountsRequest extends Message {
    constructor(data) {
      super();
      this.users = [];
      this.emails = [];
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListAccountsRequest, a, b2);
    }
  }
  ListAccountsRequest.runtime = proto3;
  ListAccountsRequest.typeName = "domain.ListAccountsRequest";
  ListAccountsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "users", kind: "message", T: ListAccountsRequest_User, repeated: true },
    { no: 2, name: "emails", kind: "scalar", T: 9, repeated: true },
    { no: 3, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListAccountsRequest_User extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.authenticatorBlockHash = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsRequest_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsRequest_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsRequest_User().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListAccountsRequest_User, a, b2);
    }
  }
  ListAccountsRequest_User.runtime = proto3;
  ListAccountsRequest_User.typeName = "domain.ListAccountsRequest.User";
  ListAccountsRequest_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "authenticator_block_hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ListAccountsResponse extends Message {
    constructor(data) {
      super();
      this.users = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListAccountsResponse, a, b2);
    }
  }
  ListAccountsResponse.runtime = proto3;
  ListAccountsResponse.typeName = "domain.ListAccountsResponse";
  ListAccountsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "users", kind: "message", T: ListAccountsResponse_User, repeated: true }
  ]);
  class ListAccountsResponse_User extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.email = "";
      this.authenticators = [];
      this.authenticatorBlocks = [];
      this.isProfilesEnabled = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsResponse_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsResponse_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsResponse_User().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListAccountsResponse_User, a, b2);
    }
  }
  ListAccountsResponse_User.runtime = proto3;
  ListAccountsResponse_User.typeName = "domain.ListAccountsResponse.User";
  ListAccountsResponse_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "authenticators", kind: "message", T: ListAccountsResponse_User_ForeignAuthenticator, repeated: true },
    { no: 4, name: "authenticator_blocks", kind: "message", T: AuthenticatorBlock$1, repeated: true },
    {
      no: 5,
      name: "is_profiles_enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ListAccountsResponse_User_ForeignAuthenticator extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsResponse_User_ForeignAuthenticator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsResponse_User_ForeignAuthenticator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsResponse_User_ForeignAuthenticator().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListAccountsResponse_User_ForeignAuthenticator, a, b2);
    }
  }
  ListAccountsResponse_User_ForeignAuthenticator.runtime = proto3;
  ListAccountsResponse_User_ForeignAuthenticator.typeName = "domain.ListAccountsResponse.User.ForeignAuthenticator";
  ListAccountsResponse_User_ForeignAuthenticator.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ResolveEmailsRequest extends Message {
    constructor(data) {
      super();
      this.emails = [];
      this.failFast = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ResolveEmailsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ResolveEmailsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ResolveEmailsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ResolveEmailsRequest, a, b2);
    }
  }
  ResolveEmailsRequest.runtime = proto3;
  ResolveEmailsRequest.typeName = "domain.ResolveEmailsRequest";
  ResolveEmailsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "emails", kind: "scalar", T: 9, repeated: true },
    {
      no: 2,
      name: "fail_fast",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ResolveEmailsResponse extends Message {
    constructor(data) {
      super();
      this.emails = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ResolveEmailsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ResolveEmailsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ResolveEmailsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ResolveEmailsResponse, a, b2);
    }
  }
  ResolveEmailsResponse.runtime = proto3;
  ResolveEmailsResponse.typeName = "domain.ResolveEmailsResponse";
  ResolveEmailsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "emails", kind: "message", T: ResolveEmailsResponse_ResolvedEmail, repeated: true }
  ]);
  class ResolveEmailsResponse_ResolvedProfile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.organizationId = "";
      this.profileType = ProfileType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ResolveEmailsResponse_ResolvedProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ResolveEmailsResponse_ResolvedProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ResolveEmailsResponse_ResolvedProfile().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ResolveEmailsResponse_ResolvedProfile, a, b2);
    }
  }
  ResolveEmailsResponse_ResolvedProfile.runtime = proto3;
  ResolveEmailsResponse_ResolvedProfile.typeName = "domain.ResolveEmailsResponse.ResolvedProfile";
  ResolveEmailsResponse_ResolvedProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "profile_type", kind: "enum", T: proto3.getEnumType(ProfileType) }
  ]);
  class ResolveEmailsResponse_ResolvedEmail extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.emailInvalid = false;
      this.profiles = [];
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ResolveEmailsResponse_ResolvedEmail().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ResolveEmailsResponse_ResolvedEmail().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ResolveEmailsResponse_ResolvedEmail().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ResolveEmailsResponse_ResolvedEmail, a, b2);
    }
  }
  ResolveEmailsResponse_ResolvedEmail.runtime = proto3;
  ResolveEmailsResponse_ResolvedEmail.typeName = "domain.ResolveEmailsResponse.ResolvedEmail";
  ResolveEmailsResponse_ResolvedEmail.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "email_invalid",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 2, name: "profiles", kind: "message", T: ResolveEmailsResponse_ResolvedProfile, repeated: true },
    {
      no: 3,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetPaddleConfigRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetPaddleConfigRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetPaddleConfigRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetPaddleConfigRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetPaddleConfigRequest, a, b2);
    }
  }
  GetPaddleConfigRequest.runtime = proto3;
  GetPaddleConfigRequest.typeName = "domain.GetPaddleConfigRequest";
  GetPaddleConfigRequest.fields = proto3.util.newFieldList(() => []);
  class GetPaddleConfigResponse extends Message {
    constructor(data) {
      super();
      this.isSandbox = false;
      this.wrapperHost = "";
      this.vendorId = protoInt64.zero;
      this.productIdMonthly = protoInt64.zero;
      this.productIdYearly = protoInt64.zero;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetPaddleConfigResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetPaddleConfigResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetPaddleConfigResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetPaddleConfigResponse, a, b2);
    }
  }
  GetPaddleConfigResponse.runtime = proto3;
  GetPaddleConfigResponse.typeName = "domain.GetPaddleConfigResponse";
  GetPaddleConfigResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "is_sandbox",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "wrapper_host",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "vendor_id",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "product_id_monthly",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 5,
      name: "product_id_yearly",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]);
  class DeleteAccountRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteAccountRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteAccountRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteAccountRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteAccountRequest, a, b2);
    }
  }
  DeleteAccountRequest.runtime = proto3;
  DeleteAccountRequest.typeName = "domain.DeleteAccountRequest";
  DeleteAccountRequest.fields = proto3.util.newFieldList(() => []);
  class DeleteAccountResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteAccountResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteAccountResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteAccountResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteAccountResponse, a, b2);
    }
  }
  DeleteAccountResponse.runtime = proto3;
  DeleteAccountResponse.typeName = "domain.DeleteAccountResponse";
  DeleteAccountResponse.fields = proto3.util.newFieldList(() => []);
  class CreatePrivateProfileRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreatePrivateProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreatePrivateProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreatePrivateProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreatePrivateProfileRequest, a, b2);
    }
  }
  CreatePrivateProfileRequest.runtime = proto3;
  CreatePrivateProfileRequest.typeName = "domain.CreatePrivateProfileRequest";
  CreatePrivateProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "private_profile", kind: "message", T: ProfileData },
    { no: 3, name: "private_vault", kind: "message", T: VaultCreationData }
  ]);
  class CreatePrivateProfileResponse extends Message {
    constructor(data) {
      super();
      this.privateProfileId = "";
      this.privateVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreatePrivateProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreatePrivateProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreatePrivateProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreatePrivateProfileResponse, a, b2);
    }
  }
  CreatePrivateProfileResponse.runtime = proto3;
  CreatePrivateProfileResponse.typeName = "domain.CreatePrivateProfileResponse";
  CreatePrivateProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "private_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "private_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeletePrivateProfileRequest extends Message {
    constructor(data) {
      super();
      this.privateProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeletePrivateProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeletePrivateProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeletePrivateProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeletePrivateProfileRequest, a, b2);
    }
  }
  DeletePrivateProfileRequest.runtime = proto3;
  DeletePrivateProfileRequest.typeName = "domain.DeletePrivateProfileRequest";
  DeletePrivateProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "private_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeletePrivateProfileResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeletePrivateProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeletePrivateProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeletePrivateProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeletePrivateProfileResponse, a, b2);
    }
  }
  DeletePrivateProfileResponse.runtime = proto3;
  DeletePrivateProfileResponse.typeName = "domain.DeletePrivateProfileResponse";
  DeletePrivateProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RegenerateProfilesRequest extends Message {
    constructor(data) {
      super();
      this.profiles = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateProfilesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateProfilesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateProfilesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegenerateProfilesRequest, a, b2);
    }
  }
  RegenerateProfilesRequest.runtime = proto3;
  RegenerateProfilesRequest.typeName = "domain.RegenerateProfilesRequest";
  RegenerateProfilesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profiles", kind: "message", T: ProfileRegenerateData, repeated: true }
  ]);
  class RegenerateProfilesResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateProfilesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateProfilesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateProfilesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegenerateProfilesResponse, a, b2);
    }
  }
  RegenerateProfilesResponse.runtime = proto3;
  RegenerateProfilesResponse.typeName = "domain.RegenerateProfilesResponse";
  RegenerateProfilesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ListProfilesRequest extends Message {
    constructor(data) {
      super();
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListProfilesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListProfilesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListProfilesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListProfilesRequest, a, b2);
    }
  }
  ListProfilesRequest.runtime = proto3;
  ListProfilesRequest.typeName = "domain.ListProfilesRequest";
  ListProfilesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListProfilesResponse extends Message {
    constructor(data) {
      super();
      this.profiles = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListProfilesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListProfilesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListProfilesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListProfilesResponse, a, b2);
    }
  }
  ListProfilesResponse.runtime = proto3;
  ListProfilesResponse.typeName = "domain.ListProfilesResponse";
  ListProfilesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profiles", kind: "message", T: ForeignProfile, repeated: true }
  ]);
  class ProfileRequestEmailChangeRequest extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileRequestEmailChangeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileRequestEmailChangeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileRequestEmailChangeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ProfileRequestEmailChangeRequest, a, b2);
    }
  }
  ProfileRequestEmailChangeRequest.runtime = proto3;
  ProfileRequestEmailChangeRequest.typeName = "domain.ProfileRequestEmailChangeRequest";
  ProfileRequestEmailChangeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ProfileRequestEmailChangeResponse extends Message {
    constructor(data) {
      super();
      this.verificationEmailSent = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileRequestEmailChangeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileRequestEmailChangeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileRequestEmailChangeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ProfileRequestEmailChangeResponse, a, b2);
    }
  }
  ProfileRequestEmailChangeResponse.runtime = proto3;
  ProfileRequestEmailChangeResponse.typeName = "domain.ProfileRequestEmailChangeResponse";
  ProfileRequestEmailChangeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "verification_email_sent",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ProfileCancelEmailChangeRequest extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileCancelEmailChangeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileCancelEmailChangeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileCancelEmailChangeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ProfileCancelEmailChangeRequest, a, b2);
    }
  }
  ProfileCancelEmailChangeRequest.runtime = proto3;
  ProfileCancelEmailChangeRequest.typeName = "domain.ProfileCancelEmailChangeRequest";
  ProfileCancelEmailChangeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ProfileCancelEmailChangeResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileCancelEmailChangeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileCancelEmailChangeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileCancelEmailChangeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ProfileCancelEmailChangeResponse, a, b2);
    }
  }
  ProfileCancelEmailChangeResponse.runtime = proto3;
  ProfileCancelEmailChangeResponse.typeName = "domain.ProfileCancelEmailChangeResponse";
  ProfileCancelEmailChangeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class VerifyEmailAddressRequest extends Message {
    constructor(data) {
      super();
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VerifyEmailAddressRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VerifyEmailAddressRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VerifyEmailAddressRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(VerifyEmailAddressRequest, a, b2);
    }
  }
  VerifyEmailAddressRequest.runtime = proto3;
  VerifyEmailAddressRequest.typeName = "domain.VerifyEmailAddressRequest";
  VerifyEmailAddressRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class VerifyEmailAddressResponse extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VerifyEmailAddressResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VerifyEmailAddressResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VerifyEmailAddressResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(VerifyEmailAddressResponse, a, b2);
    }
  }
  VerifyEmailAddressResponse.runtime = proto3;
  VerifyEmailAddressResponse.typeName = "domain.VerifyEmailAddressResponse";
  VerifyEmailAddressResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ClaimWithStartCodeRequest extends Message {
    constructor(data) {
      super();
      this.startCode = "";
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimWithStartCodeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimWithStartCodeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimWithStartCodeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ClaimWithStartCodeRequest, a, b2);
    }
  }
  ClaimWithStartCodeRequest.runtime = proto3;
  ClaimWithStartCodeRequest.typeName = "domain.ClaimWithStartCodeRequest";
  ClaimWithStartCodeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "start_code",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ClaimWithStartCodeResponse extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimWithStartCodeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimWithStartCodeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimWithStartCodeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ClaimWithStartCodeResponse, a, b2);
    }
  }
  ClaimWithStartCodeResponse.runtime = proto3;
  ClaimWithStartCodeResponse.typeName = "domain.ClaimWithStartCodeResponse";
  ClaimWithStartCodeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetProfileInfoRequest extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetProfileInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetProfileInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetProfileInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetProfileInfoRequest, a, b2);
    }
  }
  GetProfileInfoRequest.runtime = proto3;
  GetProfileInfoRequest.typeName = "domain.GetProfileInfoRequest";
  GetProfileInfoRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetProfileInfoResponse extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.organizationId = "";
      this.organizationName = "";
      this.organizationIcon = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetProfileInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetProfileInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetProfileInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetProfileInfoResponse, a, b2);
    }
  }
  GetProfileInfoResponse.runtime = proto3;
  GetProfileInfoResponse.typeName = "domain.GetProfileInfoResponse";
  GetProfileInfoResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "organization_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "organization_icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CheckProfileStartCodeRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.startCode = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CheckProfileStartCodeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CheckProfileStartCodeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CheckProfileStartCodeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CheckProfileStartCodeRequest, a, b2);
    }
  }
  CheckProfileStartCodeRequest.runtime = proto3;
  CheckProfileStartCodeRequest.typeName = "domain.CheckProfileStartCodeRequest";
  CheckProfileStartCodeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "start_code",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CheckProfileStartCodeResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CheckProfileStartCodeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CheckProfileStartCodeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CheckProfileStartCodeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CheckProfileStartCodeResponse, a, b2);
    }
  }
  CheckProfileStartCodeResponse.runtime = proto3;
  CheckProfileStartCodeResponse.typeName = "domain.CheckProfileStartCodeResponse";
  CheckProfileStartCodeResponse.fields = proto3.util.newFieldList(() => []);
  ({
    typeName: "domain.AccountService",
    methods: {
      /**
       * - InvalidEmail (20101)
       * - Internal (10500)
       *
       * @generated from rpc domain.AccountService.GetRegistrationInfo
       */
      getRegistrationInfo: {
        name: "GetRegistrationInfo",
        I: GetRegistrationInfoRequest,
        O: GetRegistrationInfoResponse,
        kind: MethodKind.Unary
      },
      /**
       * - EmailTaken (20100): email address taken, backup code is available
       * - InvalidEmail (20101): invalid email address
       * - EmailInviteNotActive (20106): email belongs to an org profile that has no active email invite
       * - EmailTakenNotRecoverable (20107): email address taken, no backup code available
       * - ProfileNotFound (70400): profile not found, or is not an organization profile
       * - MissingProfileAuthenticatorLock (70410)
       * - InvalidProfileSignature (70420)
       * - NotAllowedForProfile (70433): service profile must be registered as service user
       * - WebathnDataError (1000401): there is a parsing error with the webauthn response
       * - WebauthnRequestNotFound (1000402)
       * - WebauthnValidateError (1000400): there is a cryptographic error with the webauthn response
       * - WebauthnInvalidTransport (1000403): tried to register with passkey
       * - StartCodeInvalid (70430)
       * - StartCodeBlocked (70431)
       * - StartCodeMissing (70432)
       * - Internal (10500): internal server error
       * - BadRequest (10400): no authenticators sent
       *
       * @generated from rpc domain.AccountService.CreateWithProfile
       */
      createWithProfile: {
        name: "CreateWithProfile",
        I: CreateAccountWithProfileRequest,
        O: CreateAccountWithProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - InvalidLocale (20105): invalid locale
       * - MalformedUserClientSettings (20108): user settings are not valid json
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.Update
       */
      update: {
        name: "Update",
        I: UpdateAccountRequest,
        O: UpdateAccountResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.CreateReferrer
       */
      createReferrer: {
        name: "CreateReferrer",
        I: CreateReferrerRequest,
        O: CreateReferrerResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.AddAchievements
       */
      addAchievements: {
        name: "AddAchievements",
        I: AddAchievementsRequest,
        O: AddAchievementsResponse,
        kind: MethodKind.Unary
      },
      /**
       * Deprecated, use ProfileService.VerifyEmailAddress instead
       * TODO: remove this (min client version 2024-08-05)
       * errors:
       * - PermissionDenied (10100): the credentials provided didn't match the verification token
       * - UserNotFound (20400): no user with that email address found
       * - InvalidVerificationToken (20460): the verification token provided is invalid or outdated or the email has been verified for another account
       * - Internal (10500): internal server error
       * This endpoint can be called with or without credentials. If credentials are given, they must
       * match with the verification token.
       *
       * @generated from rpc domain.AccountService.VerifyEmailAddress
       */
      verifyEmailAddress: {
        name: "VerifyEmailAddress",
        I: VerifyEmailAddressRequest,
        O: VerifyEmailAddressResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - InvalidEmail (20101): invalid email address
       * - UserNotFound (20400): user not found
       * - ProfileNotFound (70400): profile not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.List
       */
      list: {
        name: "List",
        I: ListAccountsRequest,
        O: ListAccountsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - InvalidEmail (20101): invalid email address (only if fail_fast is set)
       * - UserNotFound (20400): user not found (only if fail_fast is set)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.ResolveEmails
       */
      resolveEmails: {
        name: "ResolveEmails",
        I: ResolveEmailsRequest,
        O: ResolveEmailsResponse,
        kind: MethodKind.Unary
      },
      /**
       * no errors, this is a static endpoint
       *
       * @generated from rpc domain.AccountService.GetPaddleConfig
       */
      getPaddleConfig: {
        name: "GetPaddleConfig",
        I: GetPaddleConfigRequest,
        O: GetPaddleConfigResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationMissingAdmin (60410): user is last admin in an organization with other users
       * - UserNotFound (20400): user not found (this should never happen)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.Delete
       */
      delete: {
        name: "Delete",
        I: DeleteAccountRequest,
        O: DeleteAccountResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class ModifyAuthenticatorsRequest extends Message {
    constructor(data) {
      super();
      this.createAuthenticatorOps = [];
      this.deleteAuthenticatorIds = [];
      this.authenticatorBlock = new Uint8Array(0);
      this.authenticatorBlockSignature = new Uint8Array(0);
      this.profiles = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyAuthenticatorsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyAuthenticatorsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyAuthenticatorsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ModifyAuthenticatorsRequest, a, b2);
    }
  }
  ModifyAuthenticatorsRequest.runtime = proto3;
  ModifyAuthenticatorsRequest.typeName = "domain.ModifyAuthenticatorsRequest";
  ModifyAuthenticatorsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "create_authenticator_ops", kind: "message", T: AuthenticatorCreationData, repeated: true },
    { no: 2, name: "delete_authenticator_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 3,
      name: "authenticator_block",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "authenticator_block_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 5, name: "profiles", kind: "message", T: ProfileRegenerateData, repeated: true }
  ]);
  class ModifyAuthenticatorsResponse extends Message {
    constructor(data) {
      super();
      this.authenticatorIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyAuthenticatorsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyAuthenticatorsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyAuthenticatorsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ModifyAuthenticatorsResponse, a, b2);
    }
  }
  ModifyAuthenticatorsResponse.runtime = proto3;
  ModifyAuthenticatorsResponse.typeName = "domain.ModifyAuthenticatorsResponse";
  ModifyAuthenticatorsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    { no: 2, name: "authenticator_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class SetDeviceTokenRequest extends Message {
    constructor(data) {
      super();
      this.fcmDeviceToken = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SetDeviceTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SetDeviceTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SetDeviceTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SetDeviceTokenRequest, a, b2);
    }
  }
  SetDeviceTokenRequest.runtime = proto3;
  SetDeviceTokenRequest.typeName = "domain.SetDeviceTokenRequest";
  SetDeviceTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 3,
      name: "fcm_device_token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SetDeviceTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SetDeviceTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SetDeviceTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SetDeviceTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SetDeviceTokenResponse, a, b2);
    }
  }
  SetDeviceTokenResponse.runtime = proto3;
  SetDeviceTokenResponse.typeName = "domain.SetDeviceTokenResponse";
  SetDeviceTokenResponse.fields = proto3.util.newFieldList(() => []);
  class ListAuthenticatorsRequest extends Message {
    constructor(data) {
      super();
      this.latestAuthenticatorBlockHash = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAuthenticatorsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAuthenticatorsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAuthenticatorsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListAuthenticatorsRequest, a, b2);
    }
  }
  ListAuthenticatorsRequest.runtime = proto3;
  ListAuthenticatorsRequest.typeName = "domain.ListAuthenticatorsRequest";
  ListAuthenticatorsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "latest_authenticator_block_hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ListAuthenticatorsResponse extends Message {
    constructor(data) {
      super();
      this.authenticators = [];
      this.authenticatorBlocks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAuthenticatorsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAuthenticatorsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAuthenticatorsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListAuthenticatorsResponse, a, b2);
    }
  }
  ListAuthenticatorsResponse.runtime = proto3;
  ListAuthenticatorsResponse.typeName = "domain.ListAuthenticatorsResponse";
  ListAuthenticatorsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "authenticators", kind: "message", T: Authenticator$1, repeated: true },
    { no: 2, name: "authenticator_blocks", kind: "message", T: AuthenticatorBlock$1, repeated: true }
  ]);
  class CreateInitialAuthenticatorBlockRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateInitialAuthenticatorBlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateInitialAuthenticatorBlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateInitialAuthenticatorBlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateInitialAuthenticatorBlockRequest, a, b2);
    }
  }
  CreateInitialAuthenticatorBlockRequest.runtime = proto3;
  CreateInitialAuthenticatorBlockRequest.typeName = "domain.CreateInitialAuthenticatorBlockRequest";
  CreateInitialAuthenticatorBlockRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "authenticator_block", kind: "message", T: AuthenticatorBlock$1 }
  ]);
  class CreateInitialAuthenticatorBlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateInitialAuthenticatorBlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateInitialAuthenticatorBlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateInitialAuthenticatorBlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateInitialAuthenticatorBlockResponse, a, b2);
    }
  }
  CreateInitialAuthenticatorBlockResponse.runtime = proto3;
  CreateInitialAuthenticatorBlockResponse.typeName = "domain.CreateInitialAuthenticatorBlockResponse";
  CreateInitialAuthenticatorBlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  ({
    typeName: "domain.AuthenticatorService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorBlockOutOfSync (40100): the authenticator blocks parent hash does not match the latest authenticator block
       * - AuthenticatorNotFound (40400): authenticator not found
       * - MissingAuthenticatorBlock (40430): the request is lacking a follow-up authenticator block
       * - VaultNotFound (50400): vault not found
       * - VaultOutOfSync (50100): latest_commit_id does not match
       * - EmptyCommit (50200): commit blob is empty
       * - MissingLock (50410): a lock is missing for regneration or no keks were provided for a new authenticator
       * - MissingVault (50420): VaultRegenerateData is missing for a vault
       * - WebauthnValidateError (80400)
       * - WebauthnDataError (80401)
       * - WebauthnRequestNotFound (80402)
       * - MissingWebauthnCredential (80404)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AuthenticatorService.Modify
       */
      modify: {
        name: "Modify",
        I: ModifyAuthenticatorsRequest,
        O: ModifyAuthenticatorsResponse,
        kind: MethodKind.Unary
      },
      /**
       * DEPRECATED
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorNotFound (40400): combination of authenticator and user not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AuthenticatorService.SetDeviceToken
       */
      setDeviceToken: {
        name: "SetDeviceToken",
        I: SetDeviceTokenRequest,
        O: SetDeviceTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorBlockNotFound (40440): the authenticator block with given hash was not found or belongs to another user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AuthenticatorService.List
       */
      list: {
        name: "List",
        I: ListAuthenticatorsRequest,
        O: ListAuthenticatorsResponse,
        kind: MethodKind.Unary
      },
      /**
       * TODO: deprecate and later remove this endpoint once migration to authenticator blocks is completed
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorBlockExists (40450): the account already has an authenticator block
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AuthenticatorService.CreateInitialAuthenticatorBlock
       */
      createInitialAuthenticatorBlock: {
        name: "CreateInitialAuthenticatorBlock",
        I: CreateInitialAuthenticatorBlockRequest,
        O: CreateInitialAuthenticatorBlockResponse,
        kind: MethodKind.Unary
      }
    }
  });
  ({
    typeName: "domain.ChannelService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100): exposed == false and credentials are missing
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - PermissionDenied (10100): exposed == false and user_id does not match token
       * - UserNotFound (20400): user not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Create
       */
      create: {
        name: "Create",
        I: CreateChannelRequest,
        O: CreateChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): credentials are missing
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorNotFound (40400): authenticator not found
       * - AuthenticatorChannelNotFound (40410): channel not found
       * - AuthenticatorChannelAlreadyClaimed (40411): channel was already claimed
       * - PermissionDenied (10100): channel does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Claim
       */
      claim: {
        name: "Claim",
        I: ClaimChannelRequest,
        O: ClaimChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): channel is not exposed and no valid credentials were provided
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - PermissionDenied (10100): channel does not belong to user
       * - InvalidRecipient (40500): invalid recipient
       * - Timeout (10200): timeout, client might retry
       * - AuthenticatorChannelNotFound (40410): channel not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Read
       */
      read: {
        name: "Read",
        I: ReadChannelRequest,
        O: ReadChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): channel is not exposed and no valid credentials were provided
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - PermissionDenied (10100): channel does not belong to user
       * - InvalidRecipient (40500): invalid recipient
       * - AuthenticatorChannelNotFound (40410): channel not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Write
       */
      write: {
        name: "Write",
        I: WriteChannelRequest,
        O: WriteChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): channel is not exposed and no valid credentials were provided
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - PermissionDenied (10100): channel does not belong to user
       * - AuthenticatorChannelNotFound (40410): channel not found
       * - Internal (10500)(10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Delete
       */
      delete: {
        name: "Delete",
        I: DeleteChannelRequest,
        O: DeleteChannelResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class ListChildOrganizationsRequest extends Message {
    constructor(data) {
      super();
      this.parentOrganizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListChildOrganizationsRequest, a, b2);
    }
  }
  ListChildOrganizationsRequest.runtime = proto3;
  ListChildOrganizationsRequest.typeName = "domain.ListChildOrganizationsRequest";
  ListChildOrganizationsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "parent_organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ListChildOrganizationsResponse extends Message {
    constructor(data) {
      super();
      this.childOrganizations = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListChildOrganizationsResponse, a, b2);
    }
  }
  ListChildOrganizationsResponse.runtime = proto3;
  ListChildOrganizationsResponse.typeName = "domain.ListChildOrganizationsResponse";
  ListChildOrganizationsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "child_organizations", kind: "message", T: ListChildOrganizationsResponse_ChildOrganization, repeated: true }
  ]);
  class ListChildOrganizationsResponse_ChildOrganization extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.name = "";
      this.licenseCount = 0;
      this.users = [];
      this.managers = [];
      this.parentOrganizationMetadata = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsResponse_ChildOrganization().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsResponse_ChildOrganization().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsResponse_ChildOrganization().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListChildOrganizationsResponse_ChildOrganization, a, b2);
    }
  }
  ListChildOrganizationsResponse_ChildOrganization.runtime = proto3;
  ListChildOrganizationsResponse_ChildOrganization.typeName = "domain.ListChildOrganizationsResponse.ChildOrganization";
  ListChildOrganizationsResponse_ChildOrganization.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "license_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 4, name: "users", kind: "message", T: ListChildOrganizationsResponse_ChildOrganization_User, repeated: true },
    { no: 5, name: "managers", kind: "message", T: ListChildOrganizationsResponse_ChildOrganization_Manager, repeated: true },
    { no: 6, name: "created_at", kind: "message", T: Timestamp },
    {
      no: 7,
      name: "parent_organization_metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ListChildOrganizationsResponse_ChildOrganization_User extends Message {
    constructor(data) {
      super();
      this.isAdmin = false;
      this.isNotConnected = false;
      this.hasStartCode = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_User().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListChildOrganizationsResponse_ChildOrganization_User, a, b2);
    }
  }
  ListChildOrganizationsResponse_ChildOrganization_User.runtime = proto3;
  ListChildOrganizationsResponse_ChildOrganization_User.typeName = "domain.ListChildOrganizationsResponse.ChildOrganization.User";
  ListChildOrganizationsResponse_ChildOrganization_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "is_admin",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "is_not_connected",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: "has_start_code",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 4, name: "last_active_at", kind: "message", T: Timestamp }
  ]);
  class ListChildOrganizationsResponse_ChildOrganization_Manager extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      this.parentOrganizationProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_Manager().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_Manager().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_Manager().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListChildOrganizationsResponse_ChildOrganization_Manager, a, b2);
    }
  }
  ListChildOrganizationsResponse_ChildOrganization_Manager.runtime = proto3;
  ListChildOrganizationsResponse_ChildOrganization_Manager.typeName = "domain.ListChildOrganizationsResponse.ChildOrganization.Manager";
  ListChildOrganizationsResponse_ChildOrganization_Manager.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "parent_organization_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class AddManagerRequest extends Message {
    constructor(data) {
      super();
      this.childOrganizationId = "";
      this.parentOrganizationProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AddManagerRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AddManagerRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AddManagerRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AddManagerRequest, a, b2);
    }
  }
  AddManagerRequest.runtime = proto3;
  AddManagerRequest.typeName = "domain.AddManagerRequest";
  AddManagerRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "child_organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "parent_organization_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "profile", kind: "message", T: ProfileData },
    { no: 4, name: "personal_vault_data", kind: "message", T: VaultCreationData },
    { no: 5, name: "admin_profile_lock", kind: "message", T: ProfileProfileLock$1 },
    { no: 6, name: "legacy_admin_vault_lock", kind: "message", T: VaultLockCreationData }
  ]);
  class AddManagerResponse extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AddManagerResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AddManagerResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AddManagerResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AddManagerResponse, a, b2);
    }
  }
  AddManagerResponse.runtime = proto3;
  AddManagerResponse.typeName = "domain.AddManagerResponse";
  AddManagerResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class UpdateChildOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.childOrganizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateChildOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateChildOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateChildOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateChildOrganizationRequest, a, b2);
    }
  }
  UpdateChildOrganizationRequest.runtime = proto3;
  UpdateChildOrganizationRequest.typeName = "domain.UpdateChildOrganizationRequest";
  UpdateChildOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "child_organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "parent_organization_metadata", kind: "message", T: StringValue }
  ]);
  class UpdateChildOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateChildOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateChildOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateChildOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateChildOrganizationResponse, a, b2);
    }
  }
  UpdateChildOrganizationResponse.runtime = proto3;
  UpdateChildOrganizationResponse.typeName = "domain.UpdateChildOrganizationResponse";
  UpdateChildOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  ({
    typeName: "domain.ChildOrganizationService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400): not member of the given parent organization
       * - Internal (10500)
       *
       * @generated from rpc domain.ChildOrganizationService.List
       */
      list: {
        name: "List",
        I: ListChildOrganizationsRequest,
        O: ListChildOrganizationsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - ProfileNotFound (70400): profile in parent organization not found
       * - UserNotFound (20400): profile in parent organization is free
       * - UserAlreadyInOrganization(60401)
       * - EmailTaken(20100): A disconnected profile with the same email already exists in the child organization
       * - OrganizationNotFound (60400): not member of the parent or child organization or organization is no child organization
       * - OrganizationInsufficientAccess (60100): not admin of the child organization
       * - BadRequest (10400)
       * - ProfileOutOfSync (70411)
       * - MissingProfileProfileLock (70412): missing admin profile lock (for admin-profile-enabled orgs)
       * - AuthenticatorNotFound (40400): additional authenticator lock provided
       * - MissingProfileAuthenticatorLock (70410)
       * - VaultOutOfSync (50100)
       * - VaultNotFound (50400)
       * - MissingVault (50420): Missing personal vault data
       * - MissingVaultProfileLock (50411): missing personal vault lock or admin vault lock
       * - Internal (10500): Internal server error
       *
       * @generated from rpc domain.ChildOrganizationService.AddManager
       */
      addManager: {
        name: "AddManager",
        I: AddManagerRequest,
        O: AddManagerResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationInsufficientAccess (60100): not manager of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - Internal (10500):
       *
       * @generated from rpc domain.ChildOrganizationService.Update
       */
      update: {
        name: "Update",
        I: UpdateChildOrganizationRequest,
        O: UpdateChildOrganizationResponse,
        kind: MethodKind.Unary
      }
    }
  });
  ({
    typeName: "domain.CredentialService",
    methods: {
      /**
       * errors:
       * - UserNotFound (20400): email does not belong to a user
       * - AuthenticatorNotFound (40400): backup authenticator was not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.CredentialService.CreateChallenge
       */
      createChallenge: {
        name: "CreateChallenge",
        I: CreateChallengeRequest,
        O: CreateChallengeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.CredentialService.CreateLongPollChannelChallenge
       */
      createLongPollChannelChallenge: {
        name: "CreateLongPollChannelChallenge",
        I: CreateLongPollChannelChallengeRequest,
        O: CreateLongPollChannelChallengeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.CredentialService.CompleteLongPollChannel
       */
      completeLongPollChannel: {
        name: "CompleteLongPollChannel",
        I: CompleteLongPollChannelRequest,
        O: CompleteLongPollChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - InvalidTimeout (20420): expires_at of given session_unlock ist already expired
       * - AuthenticatorNotFound (40400): invalid combination of user_id and authenticator_id
       * - InvalidChallenge (30410): invalid challenge
       * - InvalidSignature (30400): invalid response fo the hcallenge
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.CredentialService.CreateTokens
       */
      createTokens: {
        name: "CreateTokens",
        I: CreateTokensRequest,
        O: CreateTokensResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100)
       * - OrganizationNotFound (60400): not member of the given organization, or auditlog not enabled
       * - Internal (10500)
       *
       * @generated from rpc domain.CredentialService.CreateAuditlogWriteToken
       */
      createAuditlogWriteToken: {
        name: "CreateAuditlogWriteToken",
        I: CreateAuditlogWriteTokenRequest,
        O: CreateAuditlogWriteTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100)
       * - OrganizationNotFound (60400): not member of the given organization, or auditlog not enabled
       * - OrganizationInsufficientAccess (60100)
       * - Internal (10500)
       *
       * @generated from rpc domain.CredentialService.CreateAuditlogAdminToken
       */
      createAuditlogAdminToken: {
        name: "CreateAuditlogAdminToken",
        I: CreateAuditlogAdminTokenRequest,
        O: CreateAuditlogAdminTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - PermissionDenied (10100)
       * - Internal (10500)
       *
       * @generated from rpc domain.CredentialService.CreateLFDOverridesAdminToken
       */
      createLFDOverridesAdminToken: {
        name: "CreateLFDOverridesAdminToken",
        I: CreateLFDOverridesAdminTokenRequest,
        O: CreateLFDOverridesAdminTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - Internal (10500)
       *
       * @generated from rpc domain.CredentialService.RefreshToken
       */
      refreshToken: {
        name: "RefreshToken",
        I: RefreshTokenRequest,
        O: RefreshTokenResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class PingRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new PingRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new PingRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new PingRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(PingRequest, a, b2);
    }
  }
  PingRequest.runtime = proto3;
  PingRequest.typeName = "domain.PingRequest";
  PingRequest.fields = proto3.util.newFieldList(() => []);
  class PingResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new PingResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new PingResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new PingResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(PingResponse, a, b2);
    }
  }
  PingResponse.runtime = proto3;
  PingResponse.typeName = "domain.PingResponse";
  PingResponse.fields = proto3.util.newFieldList(() => []);
  ({
    typeName: "domain.HealthService",
    methods: {
      /**
       * @generated from rpc domain.HealthService.Ping
       */
      ping: {
        name: "Ping",
        I: PingRequest,
        O: PingResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class EntraGetAuthorizeUriRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.redirectUri = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetAuthorizeUriRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetAuthorizeUriRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetAuthorizeUriRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraGetAuthorizeUriRequest, a, b2);
    }
  }
  EntraGetAuthorizeUriRequest.runtime = proto3;
  EntraGetAuthorizeUriRequest.typeName = "domain.EntraGetAuthorizeUriRequest";
  EntraGetAuthorizeUriRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "redirect_uri",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraGetAuthorizeUriResponse extends Message {
    constructor(data) {
      super();
      this.uri = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetAuthorizeUriResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetAuthorizeUriResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetAuthorizeUriResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraGetAuthorizeUriResponse, a, b2);
    }
  }
  EntraGetAuthorizeUriResponse.runtime = proto3;
  EntraGetAuthorizeUriResponse.typeName = "domain.EntraGetAuthorizeUriResponse";
  EntraGetAuthorizeUriResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "uri",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraFinishAuthorizationRequest extends Message {
    constructor(data) {
      super();
      this.resultQueryString = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraFinishAuthorizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraFinishAuthorizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraFinishAuthorizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraFinishAuthorizationRequest, a, b2);
    }
  }
  EntraFinishAuthorizationRequest.runtime = proto3;
  EntraFinishAuthorizationRequest.typeName = "domain.EntraFinishAuthorizationRequest";
  EntraFinishAuthorizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "result_query_string",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraFinishAuthorizationResponse extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraFinishAuthorizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraFinishAuthorizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraFinishAuthorizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraFinishAuthorizationResponse, a, b2);
    }
  }
  EntraFinishAuthorizationResponse.runtime = proto3;
  EntraFinishAuthorizationResponse.typeName = "domain.EntraFinishAuthorizationResponse";
  EntraFinishAuthorizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraGetTenantRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.forceRefresh = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetTenantRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetTenantRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetTenantRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraGetTenantRequest, a, b2);
    }
  }
  EntraGetTenantRequest.runtime = proto3;
  EntraGetTenantRequest.typeName = "domain.EntraGetTenantRequest";
  EntraGetTenantRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "force_refresh",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class EntraGetTenantResponse extends Message {
    constructor(data) {
      super();
      this.users = [];
      this.groups = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetTenantResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetTenantResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetTenantResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraGetTenantResponse, a, b2);
    }
  }
  EntraGetTenantResponse.runtime = proto3;
  EntraGetTenantResponse.typeName = "domain.EntraGetTenantResponse";
  EntraGetTenantResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "updated_at", kind: "message", T: Timestamp },
    { no: 2, name: "users", kind: "message", T: EntraGetTenantResponse_User, repeated: true },
    { no: 3, name: "groups", kind: "message", T: EntraGetTenantResponse_Group, repeated: true }
  ]);
  class EntraGetTenantResponse_User extends Message {
    constructor(data) {
      super();
      this.entraUserId = "";
      this.email = "";
      this.memberOf = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetTenantResponse_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetTenantResponse_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetTenantResponse_User().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraGetTenantResponse_User, a, b2);
    }
  }
  EntraGetTenantResponse_User.runtime = proto3;
  EntraGetTenantResponse_User.typeName = "domain.EntraGetTenantResponse.User";
  EntraGetTenantResponse_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "entra_user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "member_of", kind: "scalar", T: 9, repeated: true }
  ]);
  class EntraGetTenantResponse_Group extends Message {
    constructor(data) {
      super();
      this.entraGroupId = "";
      this.name = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetTenantResponse_Group().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetTenantResponse_Group().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetTenantResponse_Group().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraGetTenantResponse_Group, a, b2);
    }
  }
  EntraGetTenantResponse_Group.runtime = proto3;
  EntraGetTenantResponse_Group.typeName = "domain.EntraGetTenantResponse.Group";
  EntraGetTenantResponse_Group.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "entra_group_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraClearAuthorizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraClearAuthorizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraClearAuthorizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraClearAuthorizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraClearAuthorizationRequest, a, b2);
    }
  }
  EntraClearAuthorizationRequest.runtime = proto3;
  EntraClearAuthorizationRequest.typeName = "domain.EntraClearAuthorizationRequest";
  EntraClearAuthorizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraClearAuthorizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraClearAuthorizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraClearAuthorizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraClearAuthorizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EntraClearAuthorizationResponse, a, b2);
    }
  }
  EntraClearAuthorizationResponse.runtime = proto3;
  EntraClearAuthorizationResponse.typeName = "domain.EntraClearAuthorizationResponse";
  EntraClearAuthorizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CsvSetIntegrationDataRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.dataJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CsvSetIntegrationDataRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CsvSetIntegrationDataRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CsvSetIntegrationDataRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CsvSetIntegrationDataRequest, a, b2);
    }
  }
  CsvSetIntegrationDataRequest.runtime = proto3;
  CsvSetIntegrationDataRequest.typeName = "domain.CsvSetIntegrationDataRequest";
  CsvSetIntegrationDataRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "data_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CsvSetIntegrationDataResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CsvSetIntegrationDataResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CsvSetIntegrationDataResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CsvSetIntegrationDataResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CsvSetIntegrationDataResponse, a, b2);
    }
  }
  CsvSetIntegrationDataResponse.runtime = proto3;
  CsvSetIntegrationDataResponse.typeName = "domain.CsvSetIntegrationDataResponse";
  CsvSetIntegrationDataResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CsvGetIntegrationDataRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CsvGetIntegrationDataRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CsvGetIntegrationDataRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CsvGetIntegrationDataRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CsvGetIntegrationDataRequest, a, b2);
    }
  }
  CsvGetIntegrationDataRequest.runtime = proto3;
  CsvGetIntegrationDataRequest.typeName = "domain.CsvGetIntegrationDataRequest";
  CsvGetIntegrationDataRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CsvGetIntegrationDataResponse extends Message {
    constructor(data) {
      super();
      this.dataJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CsvGetIntegrationDataResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CsvGetIntegrationDataResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CsvGetIntegrationDataResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CsvGetIntegrationDataResponse, a, b2);
    }
  }
  CsvGetIntegrationDataResponse.runtime = proto3;
  CsvGetIntegrationDataResponse.typeName = "domain.CsvGetIntegrationDataResponse";
  CsvGetIntegrationDataResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "data_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceGetAuthorizeUriRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.redirectUri = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceGetAuthorizeUriRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceGetAuthorizeUriRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceGetAuthorizeUriRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GWorkspaceGetAuthorizeUriRequest, a, b2);
    }
  }
  GWorkspaceGetAuthorizeUriRequest.runtime = proto3;
  GWorkspaceGetAuthorizeUriRequest.typeName = "domain.GWorkspaceGetAuthorizeUriRequest";
  GWorkspaceGetAuthorizeUriRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "redirect_uri",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceGetAuthorizeUriResponse extends Message {
    constructor(data) {
      super();
      this.uri = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceGetAuthorizeUriResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceGetAuthorizeUriResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceGetAuthorizeUriResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GWorkspaceGetAuthorizeUriResponse, a, b2);
    }
  }
  GWorkspaceGetAuthorizeUriResponse.runtime = proto3;
  GWorkspaceGetAuthorizeUriResponse.typeName = "domain.GWorkspaceGetAuthorizeUriResponse";
  GWorkspaceGetAuthorizeUriResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "uri",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceFinishAuthorizationRequest extends Message {
    constructor(data) {
      super();
      this.resultQueryString = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceFinishAuthorizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceFinishAuthorizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceFinishAuthorizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GWorkspaceFinishAuthorizationRequest, a, b2);
    }
  }
  GWorkspaceFinishAuthorizationRequest.runtime = proto3;
  GWorkspaceFinishAuthorizationRequest.typeName = "domain.GWorkspaceFinishAuthorizationRequest";
  GWorkspaceFinishAuthorizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "result_query_string",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceFinishAuthorizationResponse extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceFinishAuthorizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceFinishAuthorizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceFinishAuthorizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GWorkspaceFinishAuthorizationResponse, a, b2);
    }
  }
  GWorkspaceFinishAuthorizationResponse.runtime = proto3;
  GWorkspaceFinishAuthorizationResponse.typeName = "domain.GWorkspaceFinishAuthorizationResponse";
  GWorkspaceFinishAuthorizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceClearAuthorizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceClearAuthorizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceClearAuthorizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceClearAuthorizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GWorkspaceClearAuthorizationRequest, a, b2);
    }
  }
  GWorkspaceClearAuthorizationRequest.runtime = proto3;
  GWorkspaceClearAuthorizationRequest.typeName = "domain.GWorkspaceClearAuthorizationRequest";
  GWorkspaceClearAuthorizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceClearAuthorizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceClearAuthorizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceClearAuthorizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceClearAuthorizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GWorkspaceClearAuthorizationResponse, a, b2);
    }
  }
  GWorkspaceClearAuthorizationResponse.runtime = proto3;
  GWorkspaceClearAuthorizationResponse.typeName = "domain.GWorkspaceClearAuthorizationResponse";
  GWorkspaceClearAuthorizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class GWorkspaceListRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.forceRefresh = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceListRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceListRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceListRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GWorkspaceListRequest, a, b2);
    }
  }
  GWorkspaceListRequest.runtime = proto3;
  GWorkspaceListRequest.typeName = "domain.GWorkspaceListRequest";
  GWorkspaceListRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "force_refresh",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class GWorkspaceListResponse extends Message {
    constructor(data) {
      super();
      this.users = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceListResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceListResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceListResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GWorkspaceListResponse, a, b2);
    }
  }
  GWorkspaceListResponse.runtime = proto3;
  GWorkspaceListResponse.typeName = "domain.GWorkspaceListResponse";
  GWorkspaceListResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "updated_at", kind: "message", T: Timestamp },
    { no: 2, name: "users", kind: "message", T: GWorkspaceListResponse_User, repeated: true }
  ]);
  class GWorkspaceListResponse_User extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceListResponse_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceListResponse_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceListResponse_User().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GWorkspaceListResponse_User, a, b2);
    }
  }
  GWorkspaceListResponse_User.runtime = proto3;
  GWorkspaceListResponse_User.typeName = "domain.GWorkspaceListResponse.User";
  GWorkspaceListResponse_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  ({
    typeName: "domain.IntegrationsService",
    methods: {
      /**
       * no errors
       *
       * @generated from rpc domain.IntegrationsService.EntraGetAuthorizeUri
       */
      entraGetAuthorizeUri: {
        name: "EntraGetAuthorizeUri",
        I: EntraGetAuthorizeUriRequest,
        O: EntraGetAuthorizeUriResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - BadRequest (10400): result_query_string failed to parse
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationUnauthorized (80401): if authorization failed for unknown reasons
       * - IntegrationNotInitialized (80400): the user canceled the authorization flow
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.EntraFinishAuthorization
       */
      entraFinishAuthorization: {
        name: "EntraFinishAuthorization",
        I: EntraFinishAuthorizationRequest,
        O: EntraFinishAuthorizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationNotInitialized (80400)
       * - IntegrationUnauthorized (80401)
       * - IntegrationInternal (80500)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.EntraGetTenant
       */
      entraGetTenant: {
        name: "EntraGetTenant",
        I: EntraGetTenantRequest,
        O: EntraGetTenantResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.EntraClearAuthorization
       */
      entraClearAuthorization: {
        name: "EntraClearAuthorization",
        I: EntraClearAuthorizationRequest,
        O: EntraClearAuthorizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100)
       * - OrganizationNotFound (60400)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.CsvSetIntegrationData
       */
      csvSetIntegrationData: {
        name: "CsvSetIntegrationData",
        I: CsvSetIntegrationDataRequest,
        O: CsvSetIntegrationDataResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100)
       * - OrganizationNotFound (60400)
       * - IntegrationNotInitialized (80400)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.CsvGetIntegrationData
       */
      csvGetIntegrationData: {
        name: "CsvGetIntegrationData",
        I: CsvGetIntegrationDataRequest,
        O: CsvGetIntegrationDataResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationUnauthorized (80401): if authorization initialization failed for unknown reasons
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.GWorkspaceGetAuthorizeUri
       */
      gWorkspaceGetAuthorizeUri: {
        name: "GWorkspaceGetAuthorizeUri",
        I: GWorkspaceGetAuthorizeUriRequest,
        O: GWorkspaceGetAuthorizeUriResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationUnauthorized (80401): if authorization failed for unknown reasons
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.GWorkspaceFinishAuthorization
       */
      gWorkspaceFinishAuthorization: {
        name: "GWorkspaceFinishAuthorization",
        I: GWorkspaceFinishAuthorizationRequest,
        O: GWorkspaceFinishAuthorizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.GWorkspaceClearAuthorization
       */
      gWorkspaceClearAuthorization: {
        name: "GWorkspaceClearAuthorization",
        I: GWorkspaceClearAuthorizationRequest,
        O: GWorkspaceClearAuthorizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationNotInitialized (80400)
       * - IntegrationUnauthorized (80401)
       * - IntegrationInternal (80500)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.GWorkspaceList
       */
      gWorkspaceList: {
        name: "GWorkspaceList",
        I: GWorkspaceListRequest,
        O: GWorkspaceListResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class ReplaceLFDOverridesRequest extends Message {
    constructor(data) {
      super();
      this.overrideJson = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReplaceLFDOverridesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReplaceLFDOverridesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReplaceLFDOverridesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ReplaceLFDOverridesRequest, a, b2);
    }
  }
  ReplaceLFDOverridesRequest.runtime = proto3;
  ReplaceLFDOverridesRequest.typeName = "domain.ReplaceLFDOverridesRequest";
  ReplaceLFDOverridesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "override_json", kind: "scalar", T: 9, repeated: true }
  ]);
  class ReplaceLFDOverridesResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReplaceLFDOverridesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReplaceLFDOverridesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReplaceLFDOverridesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ReplaceLFDOverridesResponse, a, b2);
    }
  }
  ReplaceLFDOverridesResponse.runtime = proto3;
  ReplaceLFDOverridesResponse.typeName = "domain.ReplaceLFDOverridesResponse";
  ReplaceLFDOverridesResponse.fields = proto3.util.newFieldList(() => []);
  class DeleteLFDOverridesRequest extends Message {
    constructor(data) {
      super();
      this.overrideIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteLFDOverridesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteLFDOverridesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteLFDOverridesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteLFDOverridesRequest, a, b2);
    }
  }
  DeleteLFDOverridesRequest.runtime = proto3;
  DeleteLFDOverridesRequest.typeName = "domain.DeleteLFDOverridesRequest";
  DeleteLFDOverridesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "override_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class DeleteLFDOverridesResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteLFDOverridesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteLFDOverridesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteLFDOverridesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteLFDOverridesResponse, a, b2);
    }
  }
  DeleteLFDOverridesResponse.runtime = proto3;
  DeleteLFDOverridesResponse.typeName = "domain.DeleteLFDOverridesResponse";
  DeleteLFDOverridesResponse.fields = proto3.util.newFieldList(() => []);
  class ListLFDOverridesRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListLFDOverridesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListLFDOverridesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListLFDOverridesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListLFDOverridesRequest, a, b2);
    }
  }
  ListLFDOverridesRequest.runtime = proto3;
  ListLFDOverridesRequest.typeName = "domain.ListLFDOverridesRequest";
  ListLFDOverridesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "last_known_overrides_update_time", kind: "message", T: Timestamp }
  ]);
  class ListLFDOverridesResponse extends Message {
    constructor(data) {
      super();
      this.overridesJson = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListLFDOverridesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListLFDOverridesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListLFDOverridesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ListLFDOverridesResponse, a, b2);
    }
  }
  ListLFDOverridesResponse.runtime = proto3;
  ListLFDOverridesResponse.typeName = "domain.ListLFDOverridesResponse";
  ListLFDOverridesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "overrides_update_time", kind: "message", T: Timestamp },
    { no: 2, name: "overrides_json", kind: "scalar", T: 9, repeated: true }
  ]);
  ({
    typeName: "domain.LFDOverridesService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - BadRequest (10400): if json is malformed or missing required attributes
       * - Internal (10500)
       *
       * @generated from rpc domain.LFDOverridesService.Replace
       */
      replace: {
        name: "Replace",
        I: ReplaceLFDOverridesRequest,
        O: ReplaceLFDOverridesResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.LFDOverridesService.Delete
       */
      delete: {
        name: "Delete",
        I: DeleteLFDOverridesRequest,
        O: DeleteLFDOverridesResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       *
       * @generated from rpc domain.LFDOverridesService.List
       */
      list: {
        name: "List",
        I: ListLFDOverridesRequest,
        O: ListLFDOverridesResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class ShowInboxRequest extends Message {
    constructor(data) {
      super();
      this.slug = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowInboxRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowInboxRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowInboxRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ShowInboxRequest, a, b2);
    }
  }
  ShowInboxRequest.runtime = proto3;
  ShowInboxRequest.typeName = "domain.ShowInboxRequest";
  ShowInboxRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "slug",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShowInboxResponse extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.publicKey = new Uint8Array(0);
      this.metadata = "";
      this.url = "";
      this.baseUrl = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowInboxResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowInboxResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowInboxResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ShowInboxResponse, a, b2);
    }
  }
  ShowInboxResponse.runtime = proto3;
  ShowInboxResponse.typeName = "domain.ShowInboxResponse";
  ShowInboxResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "organization_data", kind: "message", T: ShowInboxResponse_OrganizationData },
    {
      no: 6,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShowInboxResponse_OrganizationData extends Message {
    constructor(data) {
      super();
      this.name = "";
      this.icon = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowInboxResponse_OrganizationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowInboxResponse_OrganizationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowInboxResponse_OrganizationData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ShowInboxResponse_OrganizationData, a, b2);
    }
  }
  ShowInboxResponse_OrganizationData.runtime = proto3;
  ShowInboxResponse_OrganizationData.typeName = "domain.ShowInboxResponse.OrganizationData";
  ShowInboxResponse_OrganizationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateLoginInboxMessageRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.type = VaultMessageType.UNKNOWN;
      this.encryptedData = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLoginInboxMessageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLoginInboxMessageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLoginInboxMessageRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateLoginInboxMessageRequest, a, b2);
    }
  }
  CreateLoginInboxMessageRequest.runtime = proto3;
  CreateLoginInboxMessageRequest.typeName = "domain.CreateLoginInboxMessageRequest";
  CreateLoginInboxMessageRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(VaultMessageType) },
    {
      no: 4,
      name: "encrypted_data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateLoginInboxMessageResponse extends Message {
    constructor(data) {
      super();
      this.inboxMessageId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLoginInboxMessageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLoginInboxMessageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLoginInboxMessageResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateLoginInboxMessageResponse, a, b2);
    }
  }
  CreateLoginInboxMessageResponse.runtime = proto3;
  CreateLoginInboxMessageResponse.typeName = "domain.CreateLoginInboxMessageResponse";
  CreateLoginInboxMessageResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "inbox_message_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  ({
    typeName: "domain.LoginInboxService",
    methods: {
      /**
       * errors:
       * - VaultNotFound (50400): no vault for this slug
       * - VaultInboxSlugInvalid (50470)
       * - Internal (10500)
       *
       * @generated from rpc domain.LoginInboxService.Show
       */
      show: {
        name: "Show",
        I: ShowInboxRequest,
        O: ShowInboxResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - VaultNotFound (50400)
       * - InvalidVaultMessageType (50463): vault message type not allowed for this endpoint
       * - VaultOutOfSync (50100)
       * - Internal (10500)
       *
       * @generated from rpc domain.LoginInboxService.CreateMessage
       */
      createMessage: {
        name: "CreateMessage",
        I: CreateLoginInboxMessageRequest,
        O: CreateLoginInboxMessageResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class SubscriptionStatus extends Message {
    constructor(data) {
      super();
      this.status = { case: void 0 };
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus, a, b2);
    }
  }
  SubscriptionStatus.runtime = proto3;
  SubscriptionStatus.typeName = "domain.SubscriptionStatus";
  SubscriptionStatus.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "status_paddle_active", kind: "message", T: SubscriptionStatus_PaddleActive, oneof: "status" },
    { no: 2, name: "status_paddle_past_due", kind: "message", T: SubscriptionStatus_PaddlePastDue, oneof: "status" },
    { no: 3, name: "status_paddle_paused_delinquent", kind: "message", T: SubscriptionStatus_PaddlePausedDelinquent, oneof: "status" },
    { no: 4, name: "status_paddle_paused_voluntary", kind: "message", T: SubscriptionStatus_PaddlePausedVoluntary, oneof: "status" },
    { no: 5, name: "status_paddle_deleted", kind: "message", T: SubscriptionStatus_PaddleDeleted, oneof: "status" },
    { no: 6, name: "status_trial", kind: "message", T: SubscriptionStatus_Trial, oneof: "status" },
    { no: 7, name: "status_custom", kind: "message", T: SubscriptionStatus_Custom, oneof: "status" },
    { no: 8, name: "status_active_free", kind: "message", T: SubscriptionStatus_ActiveFree, oneof: "status" },
    { no: 9, name: "status_example", kind: "message", T: SubscriptionStatus_Example, oneof: "status" }
  ]);
  class SubscriptionStatus_PaddleActive extends Message {
    constructor(data) {
      super();
      this.baseUrl = "";
      this.freeMembers = 0;
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddleActive().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddleActive().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddleActive().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus_PaddleActive, a, b2);
    }
  }
  SubscriptionStatus_PaddleActive.runtime = proto3;
  SubscriptionStatus_PaddleActive.typeName = "domain.SubscriptionStatus.PaddleActive";
  SubscriptionStatus_PaddleActive.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "next_bill_date", kind: "message", T: Timestamp },
    {
      no: 3,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SubscriptionStatus_PaddlePastDue extends Message {
    constructor(data) {
      super();
      this.baseUrl = "";
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddlePastDue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddlePastDue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddlePastDue().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus_PaddlePastDue, a, b2);
    }
  }
  SubscriptionStatus_PaddlePastDue.runtime = proto3;
  SubscriptionStatus_PaddlePastDue.typeName = "domain.SubscriptionStatus.PaddlePastDue";
  SubscriptionStatus_PaddlePastDue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "next_bill_date", kind: "message", T: Timestamp },
    {
      no: 3,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_PaddlePausedDelinquent extends Message {
    constructor(data) {
      super();
      this.baseUrl = "";
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddlePausedDelinquent().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddlePausedDelinquent().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddlePausedDelinquent().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus_PaddlePausedDelinquent, a, b2);
    }
  }
  SubscriptionStatus_PaddlePausedDelinquent.runtime = proto3;
  SubscriptionStatus_PaddlePausedDelinquent.typeName = "domain.SubscriptionStatus.PaddlePausedDelinquent";
  SubscriptionStatus_PaddlePausedDelinquent.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "paused_at", kind: "message", T: Timestamp },
    { no: 3, name: "paused_from", kind: "message", T: Timestamp },
    {
      no: 4,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_PaddlePausedVoluntary extends Message {
    constructor(data) {
      super();
      this.baseUrl = "";
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddlePausedVoluntary().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddlePausedVoluntary().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddlePausedVoluntary().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus_PaddlePausedVoluntary, a, b2);
    }
  }
  SubscriptionStatus_PaddlePausedVoluntary.runtime = proto3;
  SubscriptionStatus_PaddlePausedVoluntary.typeName = "domain.SubscriptionStatus.PaddlePausedVoluntary";
  SubscriptionStatus_PaddlePausedVoluntary.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "paused_at", kind: "message", T: Timestamp },
    { no: 3, name: "paused_from", kind: "message", T: Timestamp },
    {
      no: 4,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_PaddleDeleted extends Message {
    constructor(data) {
      super();
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddleDeleted().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddleDeleted().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddleDeleted().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus_PaddleDeleted, a, b2);
    }
  }
  SubscriptionStatus_PaddleDeleted.runtime = proto3;
  SubscriptionStatus_PaddleDeleted.typeName = "domain.SubscriptionStatus.PaddleDeleted";
  SubscriptionStatus_PaddleDeleted.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "cancellation_effective_date", kind: "message", T: Timestamp },
    {
      no: 2,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_Trial extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_Trial().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_Trial().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_Trial().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus_Trial, a, b2);
    }
  }
  SubscriptionStatus_Trial.runtime = proto3;
  SubscriptionStatus_Trial.typeName = "domain.SubscriptionStatus.Trial";
  SubscriptionStatus_Trial.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "trial_end_date", kind: "message", T: Timestamp }
  ]);
  class SubscriptionStatus_ActiveFree extends Message {
    constructor(data) {
      super();
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_ActiveFree().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_ActiveFree().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_ActiveFree().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus_ActiveFree, a, b2);
    }
  }
  SubscriptionStatus_ActiveFree.runtime = proto3;
  SubscriptionStatus_ActiveFree.typeName = "domain.SubscriptionStatus.ActiveFree";
  SubscriptionStatus_ActiveFree.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_Custom extends Message {
    constructor(data) {
      super();
      this.left = "";
      this.right = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_Custom().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_Custom().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_Custom().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus_Custom, a, b2);
    }
  }
  SubscriptionStatus_Custom.runtime = proto3;
  SubscriptionStatus_Custom.typeName = "domain.SubscriptionStatus.Custom";
  SubscriptionStatus_Custom.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "left",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "right",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SubscriptionStatus_Example extends Message {
    constructor(data) {
      super();
      this.left = "";
      this.right = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_Example().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_Example().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_Example().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SubscriptionStatus_Example, a, b2);
    }
  }
  SubscriptionStatus_Example.runtime = proto3;
  SubscriptionStatus_Example.typeName = "domain.SubscriptionStatus.Example";
  SubscriptionStatus_Example.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "left",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "right",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.name = "";
      this.icon = "";
      this.email = "";
      this.authenticatorBlock = new Uint8Array(0);
      this.authenticatorBlockSignature = new Uint8Array(0);
      this.personalVaultSuperuserEncryptedStorableVaultKey = new Uint8Array(0);
      this.personalVaultSuperuserEncryptedHighSecurityVaultKey = new Uint8Array(0);
      this.personalVaultSuperuserEncryptedVaultMessagePrivateKey = new Uint8Array(0);
      this.teamVaultSuperuserEncryptedStorableVaultKey = new Uint8Array(0);
      this.teamVaultSuperuserEncryptedHighSecurityVaultKey = new Uint8Array(0);
      this.teamVaultSuperuserEncryptedVaultMessagePrivateKey = new Uint8Array(0);
      this.teamAssociatedVaultSuperuserEncryptedStorableVaultKey = new Uint8Array(0);
      this.teamAssociatedVaultSuperuserEncryptedHighSecurityVaultKey = new Uint8Array(0);
      this.teamAssociatedVaultSuperuserEncryptedVaultMessagePrivateKey = new Uint8Array(0);
      this.contactJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateOrganizationRequest, a, b2);
    }
  }
  CreateOrganizationRequest.runtime = proto3;
  CreateOrganizationRequest.typeName = "domain.CreateOrganizationRequest";
  CreateOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 17,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 16, name: "user_profile", kind: "message", T: ProfileData },
    { no: 21, name: "admin_profile", kind: "message", T: ProfileData },
    { no: 3, name: "authenticator", kind: "message", T: AuthenticatorData },
    { no: 4, name: "legacy_admin_vault_data", kind: "message", T: VaultCreationData },
    {
      no: 5,
      name: "authenticator_block",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "authenticator_block_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 23, name: "admin_vault_data", kind: "message", T: VaultCreationData },
    { no: 7, name: "personal_vault_data", kind: "message", T: VaultCreationData },
    {
      no: 8,
      name: "personal_vault_superuser_encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "personal_vault_superuser_encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 18,
      name: "personal_vault_superuser_encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 10, name: "team_vault_data", kind: "message", T: VaultPairCreationData },
    {
      no: 11,
      name: "team_vault_superuser_encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 12,
      name: "team_vault_superuser_encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 19,
      name: "team_vault_superuser_encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 13,
      name: "team_associated_vault_superuser_encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 14,
      name: "team_associated_vault_superuser_encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 20,
      name: "team_associated_vault_superuser_encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 15,
      name: "contact_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 22, name: "parent_organization_info", kind: "message", T: CreateOrganizationRequest_ParentOrganizationInfo }
  ]);
  class CreateOrganizationRequest_ParentOrganizationInfo extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateOrganizationRequest_ParentOrganizationInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateOrganizationRequest_ParentOrganizationInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateOrganizationRequest_ParentOrganizationInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateOrganizationRequest_ParentOrganizationInfo, a, b2);
    }
  }
  CreateOrganizationRequest_ParentOrganizationInfo.runtime = proto3;
  CreateOrganizationRequest_ParentOrganizationInfo.typeName = "domain.CreateOrganizationRequest.ParentOrganizationInfo";
  CreateOrganizationRequest_ParentOrganizationInfo.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateOrganizationResponse extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.superUserId = "";
      this.authenticatorId = "";
      this.legacyAdminVaultId = "";
      this.personalVaultId = "";
      this.teamVaultId = "";
      this.teamAssociatedVaultId = "";
      this.profileId = "";
      this.adminProfileId = "";
      this.adminVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateOrganizationResponse, a, b2);
    }
  }
  CreateOrganizationResponse.runtime = proto3;
  CreateOrganizationResponse.typeName = "domain.CreateOrganizationResponse";
  CreateOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "super_user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "legacy_admin_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "personal_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "team_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "team_associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "admin_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "admin_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class UpdateOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateOrganizationRequest, a, b2);
    }
  }
  UpdateOrganizationRequest.runtime = proto3;
  UpdateOrganizationRequest.typeName = "domain.UpdateOrganizationRequest";
  UpdateOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "name", kind: "message", T: StringValue },
    { no: 3, name: "icon", kind: "message", T: StringValue },
    { no: 4, name: "restrict_create_team", kind: "message", T: BoolValue },
    { no: 5, name: "auditlog_enable", kind: "message", T: BoolValue },
    { no: 11, name: "child_organization_management_enable", kind: "message", T: BoolValue },
    { no: 8, name: "restrict_personal_logins", kind: "message", T: BoolValue },
    { no: 7, name: "monitored_domains", kind: "message", T: UpdateOrganizationRequest_StringArray },
    { no: 9, name: "password_policy", kind: "message", T: StringValue },
    { no: 10, name: "unlock_time_limit", kind: "message", T: UnlockTimeLimit },
    { no: 12, name: "client_settings", kind: "message", T: StringValue }
  ]);
  class UpdateOrganizationRequest_StringArray extends Message {
    constructor(data) {
      super();
      this.value = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateOrganizationRequest_StringArray().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateOrganizationRequest_StringArray().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateOrganizationRequest_StringArray().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateOrganizationRequest_StringArray, a, b2);
    }
  }
  UpdateOrganizationRequest_StringArray.runtime = proto3;
  UpdateOrganizationRequest_StringArray.typeName = "domain.UpdateOrganizationRequest.StringArray";
  UpdateOrganizationRequest_StringArray.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9, repeated: true }
  ]);
  class UpdateOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateOrganizationResponse, a, b2);
    }
  }
  UpdateOrganizationResponse.runtime = proto3;
  UpdateOrganizationResponse.typeName = "domain.UpdateOrganizationResponse";
  UpdateOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ModifyMembersRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.createProfileOps = [];
      this.updateProfileOps = [];
      this.deleteProfileIds = [];
      this.legacyAdminVaultGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyMembersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyMembersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyMembersRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ModifyMembersRequest, a, b2);
    }
  }
  ModifyMembersRequest.runtime = proto3;
  ModifyMembersRequest.typeName = "domain.ModifyMembersRequest";
  ModifyMembersRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 7, name: "create_profile_ops", kind: "message", T: ModifyMembersRequest_CreateProfileOperation, repeated: true },
    { no: 8, name: "update_profile_ops", kind: "message", T: ModifyMembersRequest_UpdateProfileOperation, repeated: true },
    { no: 9, name: "delete_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 5, name: "legacy_admin_vault_regenerate_data", kind: "message", T: VaultRegenerateData },
    {
      no: 10,
      name: "legacy_admin_vault_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ModifyMembersRequest_CreateProfileOperation extends Message {
    constructor(data) {
      super();
      this.isAdmin = false;
      this.email = "";
      this.createStartCodeAndSendMail = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyMembersRequest_CreateProfileOperation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyMembersRequest_CreateProfileOperation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyMembersRequest_CreateProfileOperation().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ModifyMembersRequest_CreateProfileOperation, a, b2);
    }
  }
  ModifyMembersRequest_CreateProfileOperation.runtime = proto3;
  ModifyMembersRequest_CreateProfileOperation.typeName = "domain.ModifyMembersRequest.CreateProfileOperation";
  ModifyMembersRequest_CreateProfileOperation.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "is_admin",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 3, name: "personal_vault_data", kind: "message", T: VaultCreationData },
    { no: 4, name: "profile", kind: "message", T: ProfileData },
    { no: 5, name: "legacy_admin_vault_lock", kind: "message", T: VaultProfileLock$1 },
    { no: 9, name: "admin_profile_lock", kind: "message", T: ProfileProfileLock$1 },
    {
      no: 6,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "create_start_code_and_send_mail",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ModifyMembersRequest_UpdateProfileOperation extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyMembersRequest_UpdateProfileOperation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyMembersRequest_UpdateProfileOperation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyMembersRequest_UpdateProfileOperation().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ModifyMembersRequest_UpdateProfileOperation, a, b2);
    }
  }
  ModifyMembersRequest_UpdateProfileOperation.runtime = proto3;
  ModifyMembersRequest_UpdateProfileOperation.typeName = "domain.ModifyMembersRequest.UpdateProfileOperation";
  ModifyMembersRequest_UpdateProfileOperation.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "is_admin", kind: "message", T: BoolValue },
    { no: 4, name: "admin_profile_lock", kind: "message", T: ProfileProfileLock$1 }
  ]);
  class ModifyMembersResponse extends Message {
    constructor(data) {
      super();
      this.personalVaultIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyMembersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyMembersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyMembersResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ModifyMembersResponse, a, b2);
    }
  }
  ModifyMembersResponse.runtime = proto3;
  ModifyMembersResponse.typeName = "domain.ModifyMembersResponse";
  ModifyMembersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    { no: 2, name: "personal_vault_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class CreateServiceProfileRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateServiceProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateServiceProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateServiceProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateServiceProfileRequest, a, b2);
    }
  }
  CreateServiceProfileRequest.runtime = proto3;
  CreateServiceProfileRequest.typeName = "domain.CreateServiceProfileRequest";
  CreateServiceProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile", kind: "message", T: ProfileData },
    { no: 3, name: "downstream_admin_profile_lock", kind: "message", T: ProfileProfileLock$1 }
  ]);
  class CreateServiceProfileResponse extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateServiceProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateServiceProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateServiceProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateServiceProfileResponse, a, b2);
    }
  }
  CreateServiceProfileResponse.runtime = proto3;
  CreateServiceProfileResponse.typeName = "domain.CreateServiceProfileResponse";
  CreateServiceProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class LeaveOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LeaveOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LeaveOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LeaveOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(LeaveOrganizationRequest, a, b2);
    }
  }
  LeaveOrganizationRequest.runtime = proto3;
  LeaveOrganizationRequest.typeName = "domain.LeaveOrganizationRequest";
  LeaveOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class LeaveOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LeaveOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LeaveOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LeaveOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(LeaveOrganizationResponse, a, b2);
    }
  }
  LeaveOrganizationResponse.runtime = proto3;
  LeaveOrganizationResponse.typeName = "domain.LeaveOrganizationResponse";
  LeaveOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class AcceptInviteRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AcceptInviteRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AcceptInviteRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AcceptInviteRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AcceptInviteRequest, a, b2);
    }
  }
  AcceptInviteRequest.runtime = proto3;
  AcceptInviteRequest.typeName = "domain.AcceptInviteRequest";
  AcceptInviteRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class AcceptInviteResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AcceptInviteResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AcceptInviteResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AcceptInviteResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AcceptInviteResponse, a, b2);
    }
  }
  AcceptInviteResponse.runtime = proto3;
  AcceptInviteResponse.typeName = "domain.AcceptInviteResponse";
  AcceptInviteResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RedeemCouponRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.couponText = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RedeemCouponRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RedeemCouponRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RedeemCouponRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RedeemCouponRequest, a, b2);
    }
  }
  RedeemCouponRequest.runtime = proto3;
  RedeemCouponRequest.typeName = "domain.RedeemCouponRequest";
  RedeemCouponRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "coupon_text",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RedeemCouponResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RedeemCouponResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RedeemCouponResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RedeemCouponResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RedeemCouponResponse, a, b2);
    }
  }
  RedeemCouponResponse.runtime = proto3;
  RedeemCouponResponse.typeName = "domain.RedeemCouponResponse";
  RedeemCouponResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteOrganizationRequest, a, b2);
    }
  }
  DeleteOrganizationRequest.runtime = proto3;
  DeleteOrganizationRequest.typeName = "domain.DeleteOrganizationRequest";
  DeleteOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteOrganizationResponse, a, b2);
    }
  }
  DeleteOrganizationResponse.runtime = proto3;
  DeleteOrganizationResponse.typeName = "domain.DeleteOrganizationResponse";
  DeleteOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class GetSubscriptionDetailsRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetSubscriptionDetailsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetSubscriptionDetailsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetSubscriptionDetailsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetSubscriptionDetailsRequest, a, b2);
    }
  }
  GetSubscriptionDetailsRequest.runtime = proto3;
  GetSubscriptionDetailsRequest.typeName = "domain.GetSubscriptionDetailsRequest";
  GetSubscriptionDetailsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetSubscriptionDetailsResponse extends Message {
    constructor(data) {
      super();
      this.payments = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetSubscriptionDetailsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetSubscriptionDetailsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetSubscriptionDetailsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetSubscriptionDetailsResponse, a, b2);
    }
  }
  GetSubscriptionDetailsResponse.runtime = proto3;
  GetSubscriptionDetailsResponse.typeName = "domain.GetSubscriptionDetailsResponse";
  GetSubscriptionDetailsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "payments", kind: "message", T: GetSubscriptionDetailsResponse_Payment, repeated: true },
    { no: 4, name: "paddle_subscription", kind: "message", T: GetSubscriptionDetailsResponse_PaddleSubscription },
    { no: 5, name: "status", kind: "message", T: SubscriptionStatus }
  ]);
  class GetSubscriptionDetailsResponse_Payment extends Message {
    constructor(data) {
      super();
      this.receiptUrl = "";
      this.saleGrossCents = protoInt64.zero;
      this.paymentTaxCents = protoInt64.zero;
      this.currency = "";
      this.orderId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetSubscriptionDetailsResponse_Payment().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetSubscriptionDetailsResponse_Payment().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetSubscriptionDetailsResponse_Payment().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetSubscriptionDetailsResponse_Payment, a, b2);
    }
  }
  GetSubscriptionDetailsResponse_Payment.runtime = proto3;
  GetSubscriptionDetailsResponse_Payment.typeName = "domain.GetSubscriptionDetailsResponse.Payment";
  GetSubscriptionDetailsResponse_Payment.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "event_time", kind: "message", T: Timestamp },
    {
      no: 2,
      name: "receipt_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "sale_gross_cents",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "payment_tax_cents",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 5,
      name: "currency",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "order_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetSubscriptionDetailsResponse_PaddleSubscription extends Message {
    constructor(data) {
      super();
      this.plan = SubscriptionPlan.UNKNOWN;
      this.quantity = 0;
      this.unitPriceCents = 0;
      this.totalPriceCents = 0;
      this.currency = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetSubscriptionDetailsResponse_PaddleSubscription().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetSubscriptionDetailsResponse_PaddleSubscription().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetSubscriptionDetailsResponse_PaddleSubscription().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetSubscriptionDetailsResponse_PaddleSubscription, a, b2);
    }
  }
  GetSubscriptionDetailsResponse_PaddleSubscription.runtime = proto3;
  GetSubscriptionDetailsResponse_PaddleSubscription.typeName = "domain.GetSubscriptionDetailsResponse.PaddleSubscription";
  GetSubscriptionDetailsResponse_PaddleSubscription.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "plan", kind: "enum", T: proto3.getEnumType(SubscriptionPlan) },
    {
      no: 2,
      name: "quantity",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "unit_price_cents",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: "total_price_cents",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 5,
      name: "currency",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "next_bill_date", kind: "message", T: Timestamp }
  ]);
  class RegenerateOrganizationProfileRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateOrganizationProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateOrganizationProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateOrganizationProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegenerateOrganizationProfileRequest, a, b2);
    }
  }
  RegenerateOrganizationProfileRequest.runtime = proto3;
  RegenerateOrganizationProfileRequest.typeName = "domain.RegenerateOrganizationProfileRequest";
  RegenerateOrganizationProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile", kind: "message", T: ProfileRegenerateData },
    {
      no: 3,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RegenerateOrganizationProfileResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateOrganizationProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateOrganizationProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateOrganizationProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegenerateOrganizationProfileResponse, a, b2);
    }
  }
  RegenerateOrganizationProfileResponse.runtime = proto3;
  RegenerateOrganizationProfileResponse.typeName = "domain.RegenerateOrganizationProfileResponse";
  RegenerateOrganizationProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ClaimPreliminaryProfileRequest extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimPreliminaryProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimPreliminaryProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimPreliminaryProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ClaimPreliminaryProfileRequest, a, b2);
    }
  }
  ClaimPreliminaryProfileRequest.runtime = proto3;
  ClaimPreliminaryProfileRequest.typeName = "domain.ClaimPreliminaryProfileRequest";
  ClaimPreliminaryProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ClaimPreliminaryProfileResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimPreliminaryProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimPreliminaryProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimPreliminaryProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ClaimPreliminaryProfileResponse, a, b2);
    }
  }
  ClaimPreliminaryProfileResponse.runtime = proto3;
  ClaimPreliminaryProfileResponse.typeName = "domain.ClaimPreliminaryProfileResponse";
  ClaimPreliminaryProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RegenerateAdminProfileRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateAdminProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateAdminProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateAdminProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegenerateAdminProfileRequest, a, b2);
    }
  }
  RegenerateAdminProfileRequest.runtime = proto3;
  RegenerateAdminProfileRequest.typeName = "domain.RegenerateAdminProfileRequest";
  RegenerateAdminProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile", kind: "message", T: ProfileRegenerateData },
    { no: 3, name: "admin_vault_data", kind: "message", T: VaultCreationData }
  ]);
  class RegenerateAdminProfileResponse extends Message {
    constructor(data) {
      super();
      this.adminProfileId = "";
      this.adminProfileKeyGenerationId = "";
      this.adminVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateAdminProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateAdminProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateAdminProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegenerateAdminProfileResponse, a, b2);
    }
  }
  RegenerateAdminProfileResponse.runtime = proto3;
  RegenerateAdminProfileResponse.typeName = "domain.RegenerateAdminProfileResponse";
  RegenerateAdminProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "admin_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "admin_profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "admin_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RenewProfileStartCodeRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RenewProfileStartCodeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RenewProfileStartCodeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RenewProfileStartCodeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RenewProfileStartCodeRequest, a, b2);
    }
  }
  RenewProfileStartCodeRequest.runtime = proto3;
  RenewProfileStartCodeRequest.typeName = "domain.RenewProfileStartCodeRequest";
  RenewProfileStartCodeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class RenewProfileStartCodeResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RenewProfileStartCodeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RenewProfileStartCodeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RenewProfileStartCodeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RenewProfileStartCodeResponse, a, b2);
    }
  }
  RenewProfileStartCodeResponse.runtime = proto3;
  RenewProfileStartCodeResponse.typeName = "domain.RenewProfileStartCodeResponse";
  RenewProfileStartCodeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class SendStartCodeEmailRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendStartCodeEmailRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendStartCodeEmailRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendStartCodeEmailRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SendStartCodeEmailRequest, a, b2);
    }
  }
  SendStartCodeEmailRequest.runtime = proto3;
  SendStartCodeEmailRequest.typeName = "domain.SendStartCodeEmailRequest";
  SendStartCodeEmailRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class SendStartCodeEmailResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendStartCodeEmailResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendStartCodeEmailResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendStartCodeEmailResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SendStartCodeEmailResponse, a, b2);
    }
  }
  SendStartCodeEmailResponse.runtime = proto3;
  SendStartCodeEmailResponse.typeName = "domain.SendStartCodeEmailResponse";
  SendStartCodeEmailResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RevokeProfileStartCodeRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RevokeProfileStartCodeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RevokeProfileStartCodeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RevokeProfileStartCodeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RevokeProfileStartCodeRequest, a, b2);
    }
  }
  RevokeProfileStartCodeRequest.runtime = proto3;
  RevokeProfileStartCodeRequest.typeName = "domain.RevokeProfileStartCodeRequest";
  RevokeProfileStartCodeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class RevokeProfileStartCodeResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RevokeProfileStartCodeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RevokeProfileStartCodeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RevokeProfileStartCodeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RevokeProfileStartCodeResponse, a, b2);
    }
  }
  RevokeProfileStartCodeResponse.runtime = proto3;
  RevokeProfileStartCodeResponse.typeName = "domain.RevokeProfileStartCodeResponse";
  RevokeProfileStartCodeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class GetOrganizationDeletionInfoRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetOrganizationDeletionInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetOrganizationDeletionInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetOrganizationDeletionInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetOrganizationDeletionInfoRequest, a, b2);
    }
  }
  GetOrganizationDeletionInfoRequest.runtime = proto3;
  GetOrganizationDeletionInfoRequest.typeName = "domain.GetOrganizationDeletionInfoRequest";
  GetOrganizationDeletionInfoRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetOrganizationDeletionInfoResponse extends Message {
    constructor(data) {
      super();
      this.organizationName = "";
      this.requestedByEmail = "";
      this.userCount = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetOrganizationDeletionInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetOrganizationDeletionInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetOrganizationDeletionInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetOrganizationDeletionInfoResponse, a, b2);
    }
  }
  GetOrganizationDeletionInfoResponse.runtime = proto3;
  GetOrganizationDeletionInfoResponse.typeName = "domain.GetOrganizationDeletionInfoResponse";
  GetOrganizationDeletionInfoResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "requested_by_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "user_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 4, name: "requested_at", kind: "message", T: Timestamp }
  ]);
  class DeleteOrganizationWithTokenRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteOrganizationWithTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteOrganizationWithTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteOrganizationWithTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteOrganizationWithTokenRequest, a, b2);
    }
  }
  DeleteOrganizationWithTokenRequest.runtime = proto3;
  DeleteOrganizationWithTokenRequest.typeName = "domain.DeleteOrganizationWithTokenRequest";
  DeleteOrganizationWithTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteOrganizationWithTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteOrganizationWithTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteOrganizationWithTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteOrganizationWithTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteOrganizationWithTokenResponse, a, b2);
    }
  }
  DeleteOrganizationWithTokenResponse.runtime = proto3;
  DeleteOrganizationWithTokenResponse.typeName = "domain.DeleteOrganizationWithTokenResponse";
  DeleteOrganizationWithTokenResponse.fields = proto3.util.newFieldList(() => []);
  class RemoveOrganizationDeletionTokenRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RemoveOrganizationDeletionTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RemoveOrganizationDeletionTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RemoveOrganizationDeletionTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RemoveOrganizationDeletionTokenRequest, a, b2);
    }
  }
  RemoveOrganizationDeletionTokenRequest.runtime = proto3;
  RemoveOrganizationDeletionTokenRequest.typeName = "domain.RemoveOrganizationDeletionTokenRequest";
  RemoveOrganizationDeletionTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RemoveOrganizationDeletionTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RemoveOrganizationDeletionTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RemoveOrganizationDeletionTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RemoveOrganizationDeletionTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RemoveOrganizationDeletionTokenResponse, a, b2);
    }
  }
  RemoveOrganizationDeletionTokenResponse.runtime = proto3;
  RemoveOrganizationDeletionTokenResponse.typeName = "domain.RemoveOrganizationDeletionTokenResponse";
  RemoveOrganizationDeletionTokenResponse.fields = proto3.util.newFieldList(() => []);
  class GetBreachDataRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetBreachDataRequest, a, b2);
    }
  }
  GetBreachDataRequest.runtime = proto3;
  GetBreachDataRequest.typeName = "domain.GetBreachDataRequest";
  GetBreachDataRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetBreachDataResponse extends Message {
    constructor(data) {
      super();
      this.domains = [];
      this.totalPwnCountBillions = 0;
      this.totalBreachCount = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetBreachDataResponse, a, b2);
    }
  }
  GetBreachDataResponse.runtime = proto3;
  GetBreachDataResponse.typeName = "domain.GetBreachDataResponse";
  GetBreachDataResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "domains", kind: "message", T: GetBreachDataResponse_MonitoredDomain, repeated: true },
    { no: 2, name: "last_check_date", kind: "message", T: Timestamp },
    {
      no: 3,
      name: "total_pwn_count_billions",
      kind: "scalar",
      T: 2
      /* ScalarType.FLOAT */
    },
    {
      no: 4,
      name: "total_breach_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class GetBreachDataResponse_BreachModel extends Message {
    constructor(data) {
      super();
      this.name = "";
      this.title = "";
      this.dataClasses = [];
      this.logoPath = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataResponse_BreachModel().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataResponse_BreachModel().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataResponse_BreachModel().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetBreachDataResponse_BreachModel, a, b2);
    }
  }
  GetBreachDataResponse_BreachModel.runtime = proto3;
  GetBreachDataResponse_BreachModel.typeName = "domain.GetBreachDataResponse.BreachModel";
  GetBreachDataResponse_BreachModel.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "title",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "breach_date", kind: "message", T: Timestamp },
    { no: 4, name: "added_date", kind: "message", T: Timestamp },
    { no: 5, name: "data_classes", kind: "scalar", T: 9, repeated: true },
    {
      no: 6,
      name: "logo_path",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetBreachDataResponse_Breach extends Message {
    constructor(data) {
      super();
      this.aliases = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataResponse_Breach().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataResponse_Breach().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataResponse_Breach().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetBreachDataResponse_Breach, a, b2);
    }
  }
  GetBreachDataResponse_Breach.runtime = proto3;
  GetBreachDataResponse_Breach.typeName = "domain.GetBreachDataResponse.Breach";
  GetBreachDataResponse_Breach.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "model", kind: "message", T: GetBreachDataResponse_BreachModel },
    { no: 2, name: "aliases", kind: "scalar", T: 9, repeated: true }
  ]);
  class GetBreachDataResponse_MonitoredDomain extends Message {
    constructor(data) {
      super();
      this.domain = "";
      this.breaches = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataResponse_MonitoredDomain().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataResponse_MonitoredDomain().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataResponse_MonitoredDomain().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetBreachDataResponse_MonitoredDomain, a, b2);
    }
  }
  GetBreachDataResponse_MonitoredDomain.runtime = proto3;
  GetBreachDataResponse_MonitoredDomain.typeName = "domain.GetBreachDataResponse.MonitoredDomain";
  GetBreachDataResponse_MonitoredDomain.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "domain",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "breaches", kind: "message", T: GetBreachDataResponse_Breach, repeated: true }
  ]);
  ({
    typeName: "domain.OrganizationService",
    methods: {
      /**
       * errors:
       * - EmailTaken (20100): email address taken
       * - InvalidEmail (20101): invalid email address
       * - NotAllowedForUserType (20470)
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - UserNotFound (20400): no account matching credentials
       * - MissingAuthenticatorBlock (40430): the request is lacking a follow-up authenticator block
       * - InvalidAuthenticatorType (40460): The given authenticator is no organization authenticator
       * - InvalidOrganizationName (60430): name is empty or contains unprintable characters
       * - OrganizationInvalidContact (60431): contact is not json-formatted
       * - ProfileNotFound (70400): tried to create with profile when account is not profile enabled
       * - ProfileAlreadyEnabled (70401): tried to create without profile when account is profile enabled
       * - ClientOutdated (10426): tried to create admin profile org with legacy admin vault
       * - Internal (10500): Internal server error
       *
       * @generated from rpc domain.OrganizationService.Create
       */
      create: {
        name: "Create",
        I: CreateOrganizationRequest,
        O: CreateOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - InvalidOrganizationName (60430): name is empty or contains unprintable characters
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.Update
       */
      update: {
        name: "Update",
        I: UpdateOrganizationRequest,
        O: UpdateOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - EmailTaken (20100): email address taken
       * - InvalidEmail (20101): invalid email address
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - UserNotFound (20400): A user added to the organization was not found
       * - UserAlreadyInOrganization (60401): A user added to the organization is already in it
       * - OrganizationInsufficientAccess (60100): Tried to manipulate other members without admin access
       * - OrganizationMissingAdmin (60410): after the call there would be no admin left
       * - NotAllowedForUserType (20470): Tried to manipulate a non-default user
       * - VaultOutOfSync (50100)
       * - MissingVault (50420): Tried to add admin without admin vault regenerate data
       * - NotAllowedForProfile (70433): tried to demote an organization manager
       * - AuditlogSubmissionError (90500)
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.ModifyMembers
       */
      modifyMembers: {
        name: "ModifyMembers",
        I: ModifyMembersRequest,
        O: ModifyMembersResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - BadRequest (10400): called on an org without admin profiles
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - NotAllowedForOrganization (60101): organization must have admin profiles enabled
       * - OrganizationNotFound (60400): not member of the given organization
       * - UserAlreadyInOrganization (60401): A service user already exists in this organization
       * - OrganizationInsufficientAccess (60100)
       * - MissingProfileProfileLock (70412)
       * - AuditlogSubmissionError (90500)
       * - Internal (10500)
       *
       * @generated from rpc domain.OrganizationService.CreateServiceProfile
       */
      createServiceProfile: {
        name: "CreateServiceProfile",
        I: CreateServiceProfileRequest,
        O: CreateServiceProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationNotFound (60400): not member of the given organization
       * - OrganizationMissingAdmin (60410): after the call there would be no admin left
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.Leave
       */
      leave: {
        name: "Leave",
        I: LeaveOrganizationRequest,
        O: LeaveOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationNotFound (60400): not member of the given organization
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.AcceptInvite
       */
      acceptInvite: {
        name: "AcceptInvite",
        I: AcceptInviteRequest,
        O: AcceptInviteResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - CouponInvalid (60440)
       * - CouponAlreadyRedeemed (60441)
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.RedeemCoupon
       */
      redeemCoupon: {
        name: "RedeemCoupon",
        I: RedeemCouponRequest,
        O: RedeemCouponResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.Delete
       */
      delete: {
        name: "Delete",
        I: DeleteOrganizationRequest,
        O: DeleteOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100): not logged in
       * - UserNotFound (20400): no account matching credentials
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.GetSubscriptionDetails
       */
      getSubscriptionDetails: {
        name: "GetSubscriptionDetails",
        I: GetSubscriptionDetailsRequest,
        O: GetSubscriptionDetailsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - UserNotFound (20400): user to assign profile was not found
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - UserAlreadyInOrganization (60401): user to assign profile is already in organization
       * - OtherProfileEmailConflicts (60450): another profile with this email address exists
       * - ProfileNotFound (70400): if profile not found, or is user's own profile
       * - ProfileOutOfSync (70400): if KeyGenerationId is not the null uuid, or authenticator locks are not empty
       * - MissingProfileAuthenticatorLock (70410)
       * - AuditlogSubmissionError (90500)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.RegenerateOrganizationProfile
       */
      regenerateOrganizationProfile: {
        name: "RegenerateOrganizationProfile",
        I: RegenerateOrganizationProfileRequest,
        O: RegenerateOrganizationProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - BadRequest (10400): if authenticator locks are not empty and org is admin profile enabled
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - VaultOutOfSync (50100)
       * - EmptyCommit (50200)
       * - MissingVault (50420): admin vault creation data is missing
       * - VaultOutOfSync (50100): admin vault already exists, but creation data was provided
       * - MissingVaultProfileLock (50411): if vault profile locks do not match all organization vaults
       * - OrganizationInsufficientAccess (60100)
       * - ProfileOutOfSync (70400): if KeyGenerationId does not match / is the null uuid for creation
       * - Internal (10500)
       *
       * @generated from rpc domain.OrganizationService.RegenerateAdminProfile
       */
      regenerateAdminProfile: {
        name: "RegenerateAdminProfile",
        I: RegenerateAdminProfileRequest,
        O: RegenerateAdminProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - ProfileNotFound (70400): if profile not found or is not free
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.RenewProfileStartCode
       */
      renewProfileStartCode: {
        name: "RenewProfileStartCode",
        I: RenewProfileStartCodeRequest,
        O: RenewProfileStartCodeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - ProfileNotFound (70400): if profile not found, is not free or has no start code
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.SendStartCodeEmail
       */
      sendStartCodeEmail: {
        name: "SendStartCodeEmail",
        I: SendStartCodeEmailRequest,
        O: SendStartCodeEmailResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - ProfileNotFound (70400): if profile not found or is not free
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.RevokeProfileStartCode
       */
      revokeProfileStartCode: {
        name: "RevokeProfileStartCode",
        I: RevokeProfileStartCodeRequest,
        O: RevokeProfileStartCodeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - OrganizationNotFound (60400)
       * - InvalidOrganizationDeletionToken (60460)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.GetDeletionInfo
       */
      getDeletionInfo: {
        name: "GetDeletionInfo",
        I: GetOrganizationDeletionInfoRequest,
        O: GetOrganizationDeletionInfoResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - OrganizationNotFound (60400)
       * - InvalidOrganizationDeletionToken (60460)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.DeleteWithToken
       */
      deleteWithToken: {
        name: "DeleteWithToken",
        I: DeleteOrganizationWithTokenRequest,
        O: DeleteOrganizationWithTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - OrganizationNotFound (60400)
       * - InvalidOrganizationDeletionToken (60460)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.RemoveDeletionToken
       */
      removeDeletionToken: {
        name: "RemoveDeletionToken",
        I: RemoveOrganizationDeletionTokenRequest,
        O: RemoveOrganizationDeletionTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - OrganizationNotFound (60400)
       *
       * @generated from rpc domain.OrganizationService.GetBreachData
       */
      getBreachData: {
        name: "GetBreachData",
        I: GetBreachDataRequest,
        O: GetBreachDataResponse,
        kind: MethodKind.Unary
      }
    }
  });
  ({
    typeName: "domain.ProfileService",
    methods: {
      /**
       * errors:
       * - EmailTaken (20100): email address taken
       * - InvalidEmail (20101): invalid email address
       * - NotAllowedForUserType (20470)
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - ProfileNotFound (70400): account is not profile enabled
       * - ProfileAlreadyEnabled (70401): private profile already exists
       * - MissingProfileAuthenticatorLock (70410): a profile lock is missing for an authenticator
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ProfileService.CreatePrivate
       */
      createPrivate: {
        name: "CreatePrivate",
        I: CreatePrivateProfileRequest,
        O: CreatePrivateProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - ProfileNotFound (70400): profile could not be found by id
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ProfileService.DeletePrivate
       */
      deletePrivate: {
        name: "DeletePrivate",
        I: DeletePrivateProfileRequest,
        O: DeletePrivateProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultOutOfSync (50100): generation_id does not match for some vault
       * - VaultNotFound (50400): some vault profile lock had an unknown vault_id
       * - MissingLock (70510): missing locks for one or more authenticators
       * - ProfileNotFound (70400): some profile could not be found by id
       * - MissingProfileLock (70410): missing profile locks for one or more authenticators
       * - ProfileOutOfSync (70411): key_generation_id does not match for some profile
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ProfileService.Regenerate
       */
      regenerate: {
        name: "Regenerate",
        I: RegenerateProfilesRequest,
        O: RegenerateProfilesResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - ProfileNotFound (70400): if any profile id could not be found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ProfileService.List
       */
      list: {
        name: "List",
        I: ListProfilesRequest,
        O: ListProfilesResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - InvalidEmail (20101)
       * - EmailTaken (20100)
       * - ProfileNotFound (70400): profile doesn't exist or can't have an email address
       * - Internal (10500)
       *
       * @generated from rpc domain.ProfileService.RequestEmailChange
       */
      requestEmailChange: {
        name: "RequestEmailChange",
        I: ProfileRequestEmailChangeRequest,
        O: ProfileRequestEmailChangeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - PermissionDenied (10100): email change may not be cancelled (in semi-verified state)
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - ProfileNotFound (70400): profile doesn't exist or can't have an email address
       * - Internal (10500)
       *
       * @generated from rpc domain.ProfileService.CancelEmailChange
       */
      cancelEmailChange: {
        name: "CancelEmailChange",
        I: ProfileCancelEmailChangeRequest,
        O: ProfileCancelEmailChangeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - PermissionDenied (10100): the credentials provided didn't match the verification token
       * - InvalidVerificationToken (20460): the verification token provided is invalid or outdated or the email has been verified for another account
       * - Internal (10500): internal server error
       * This endpoint can be called with or without credentials. If credentials are given, they must
       * match with the verification token.
       *
       * @generated from rpc domain.ProfileService.VerifyEmailAddress
       */
      verifyEmailAddress: {
        name: "VerifyEmailAddress",
        I: VerifyEmailAddressRequest,
        O: VerifyEmailAddressResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - ProfileNotFound (70400): profile not found, or is not an organization profile
       * - ProfileAlreadyConnected (70402)
       * - ProfileStartCodeInactive (70403)
       * - UserAlreadyInOrganization (60401)
       * - StartCodeInvalid (70430)
       * - StartCodeBlocked (70431)
       * - EmailTaken (20100)
       * - AuditlogSubmissionError (90500)
       * - Internal (10500)
       *
       * @generated from rpc domain.ProfileService.ClaimWithStartCode
       */
      claimWithStartCode: {
        name: "ClaimWithStartCode",
        I: ClaimWithStartCodeRequest,
        O: ClaimWithStartCodeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - ProfileNotFound (70400)
       * - Internal (10500)
       *
       * @generated from rpc domain.ProfileService.GetProfileInfo
       */
      getProfileInfo: {
        name: "GetProfileInfo",
        I: GetProfileInfoRequest,
        O: GetProfileInfoResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - InvalidEmail (20101)
       * - EmailInviteNotActive (20106)
       * - ProfileNotFound (70400)
       * - StartCodeInvalid (70430)
       * - StartCodeBlocked (70431)
       * - EmailInviteNotActive (20106)
       *
       * @generated from rpc domain.ProfileService.CheckStartCode
       */
      checkStartCode: {
        name: "CheckStartCode",
        I: CheckProfileStartCodeRequest,
        O: CheckProfileStartCodeResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class DeleteSessionRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteSessionRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteSessionRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteSessionRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteSessionRequest, a, b2);
    }
  }
  DeleteSessionRequest.runtime = proto3;
  DeleteSessionRequest.typeName = "domain.DeleteSessionRequest";
  DeleteSessionRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteSessionResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteSessionResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteSessionResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteSessionResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteSessionResponse, a, b2);
    }
  }
  DeleteSessionResponse.runtime = proto3;
  DeleteSessionResponse.typeName = "domain.DeleteSessionResponse";
  DeleteSessionResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CreateSessionUnlockRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.encryptedSecret = new Uint8Array(0);
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateSessionUnlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateSessionUnlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateSessionUnlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateSessionUnlockRequest, a, b2);
    }
  }
  CreateSessionUnlockRequest.runtime = proto3;
  CreateSessionUnlockRequest.typeName = "domain.CreateSessionUnlockRequest";
  CreateSessionUnlockRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "max_expires_at", kind: "message", T: Timestamp }
  ]);
  class CreateSessionUnlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateSessionUnlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateSessionUnlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateSessionUnlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateSessionUnlockResponse, a, b2);
    }
  }
  CreateSessionUnlockResponse.runtime = proto3;
  CreateSessionUnlockResponse.typeName = "domain.CreateSessionUnlockResponse";
  CreateSessionUnlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteSessionUnlockRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.onlyPendingRequest = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteSessionUnlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteSessionUnlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteSessionUnlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteSessionUnlockRequest, a, b2);
    }
  }
  DeleteSessionUnlockRequest.runtime = proto3;
  DeleteSessionUnlockRequest.typeName = "domain.DeleteSessionUnlockRequest";
  DeleteSessionUnlockRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "only_pending_request",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class DeleteSessionUnlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteSessionUnlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteSessionUnlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteSessionUnlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteSessionUnlockResponse, a, b2);
    }
  }
  DeleteSessionUnlockResponse.runtime = proto3;
  DeleteSessionUnlockResponse.typeName = "domain.DeleteSessionUnlockResponse";
  DeleteSessionUnlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RequestSessionUnlockRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RequestSessionUnlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RequestSessionUnlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RequestSessionUnlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RequestSessionUnlockRequest, a, b2);
    }
  }
  RequestSessionUnlockRequest.runtime = proto3;
  RequestSessionUnlockRequest.typeName = "domain.RequestSessionUnlockRequest";
  RequestSessionUnlockRequest.fields = proto3.util.newFieldList(() => []);
  class RequestSessionUnlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RequestSessionUnlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RequestSessionUnlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RequestSessionUnlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RequestSessionUnlockResponse, a, b2);
    }
  }
  RequestSessionUnlockResponse.runtime = proto3;
  RequestSessionUnlockResponse.typeName = "domain.RequestSessionUnlockResponse";
  RequestSessionUnlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ExtendSessionUnlockRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ExtendSessionUnlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ExtendSessionUnlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ExtendSessionUnlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ExtendSessionUnlockRequest, a, b2);
    }
  }
  ExtendSessionUnlockRequest.runtime = proto3;
  ExtendSessionUnlockRequest.typeName = "domain.ExtendSessionUnlockRequest";
  ExtendSessionUnlockRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "last_user_activity", kind: "message", T: Timestamp }
  ]);
  class ExtendSessionUnlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ExtendSessionUnlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ExtendSessionUnlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ExtendSessionUnlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ExtendSessionUnlockResponse, a, b2);
    }
  }
  ExtendSessionUnlockResponse.runtime = proto3;
  ExtendSessionUnlockResponse.typeName = "domain.ExtendSessionUnlockResponse";
  ExtendSessionUnlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class SendSessionMessageRequest extends Message {
    constructor(data) {
      super();
      this.messages = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendSessionMessageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendSessionMessageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendSessionMessageRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SendSessionMessageRequest, a, b2);
    }
  }
  SendSessionMessageRequest.runtime = proto3;
  SendSessionMessageRequest.typeName = "domain.SendSessionMessageRequest";
  SendSessionMessageRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "messages", kind: "message", T: SendSessionMessageRequest_Message, repeated: true }
  ]);
  class SendSessionMessageRequest_Message extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.payload = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendSessionMessageRequest_Message().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendSessionMessageRequest_Message().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendSessionMessageRequest_Message().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SendSessionMessageRequest_Message, a, b2);
    }
  }
  SendSessionMessageRequest_Message.runtime = proto3;
  SendSessionMessageRequest_Message.typeName = "domain.SendSessionMessageRequest.Message";
  SendSessionMessageRequest_Message.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "payload",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class SendSessionMessageResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendSessionMessageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendSessionMessageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendSessionMessageResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SendSessionMessageResponse, a, b2);
    }
  }
  SendSessionMessageResponse.runtime = proto3;
  SendSessionMessageResponse.typeName = "domain.SendSessionMessageResponse";
  SendSessionMessageResponse.fields = proto3.util.newFieldList(() => []);
  class UpdateSessionRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.fieldsToUpdate = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateSessionRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateSessionRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateSessionRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateSessionRequest, a, b2);
    }
  }
  UpdateSessionRequest.runtime = proto3;
  UpdateSessionRequest.typeName = "domain.UpdateSessionRequest";
  UpdateSessionRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "fields_to_update", kind: "enum", T: proto3.getEnumType(SyncUpdateField), repeated: true },
    { no: 3, name: "client_settings", kind: "message", T: StringValue },
    { no: 4, name: "enabled_profiles", kind: "message", T: UpdateSessionRequest_EnabledProfiles },
    { no: 5, name: "unlock_time_limit", kind: "message", T: UnlockTimeLimit },
    { no: 6, name: "fcm_device_token", kind: "message", T: StringValue }
  ]);
  class UpdateSessionRequest_EnabledProfiles extends Message {
    constructor(data) {
      super();
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateSessionRequest_EnabledProfiles().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateSessionRequest_EnabledProfiles().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateSessionRequest_EnabledProfiles().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateSessionRequest_EnabledProfiles, a, b2);
    }
  }
  UpdateSessionRequest_EnabledProfiles.runtime = proto3;
  UpdateSessionRequest_EnabledProfiles.typeName = "domain.UpdateSessionRequest.EnabledProfiles";
  UpdateSessionRequest_EnabledProfiles.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class UpdateSessionResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateSessionResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateSessionResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateSessionResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UpdateSessionResponse, a, b2);
    }
  }
  UpdateSessionResponse.runtime = proto3;
  UpdateSessionResponse.typeName = "domain.UpdateSessionResponse";
  UpdateSessionResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class SetClientSettingsRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.clientSettings = "";
      this.fieldsToUpdate = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SetClientSettingsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SetClientSettingsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SetClientSettingsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SetClientSettingsRequest, a, b2);
    }
  }
  SetClientSettingsRequest.runtime = proto3;
  SetClientSettingsRequest.typeName = "domain.SetClientSettingsRequest";
  SetClientSettingsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "client_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "fields_to_update", kind: "enum", T: proto3.getEnumType(SyncUpdateField), repeated: true }
  ]);
  class SetClientSettingsResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SetClientSettingsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SetClientSettingsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SetClientSettingsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SetClientSettingsResponse, a, b2);
    }
  }
  SetClientSettingsResponse.runtime = proto3;
  SetClientSettingsResponse.typeName = "domain.SetClientSettingsResponse";
  SetClientSettingsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  ({
    typeName: "domain.SessionService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session_id not in database
       * - PermissionDenied (10100) : session does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.DeleteSession
       */
      deleteSession: {
        name: "DeleteSession",
        I: DeleteSessionRequest,
        O: DeleteSessionResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - InvalidTimeout (20420): expires_at ist already expired
       * - AuthenticatorNotFound (40400): authenticator does not belong to user
       * - SessionNotFound (20410): session does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.CreateSessionUnlock
       */
      createSessionUnlock: {
        name: "CreateSessionUnlock",
        I: CreateSessionUnlockRequest,
        O: CreateSessionUnlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.DeleteSessionUnlock
       */
      deleteSessionUnlock: {
        name: "DeleteSessionUnlock",
        I: DeleteSessionUnlockRequest,
        O: DeleteSessionUnlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.RequestSessionUnlock
       */
      requestSessionUnlock: {
        name: "RequestSessionUnlock",
        I: RequestSessionUnlockRequest,
        O: RequestSessionUnlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - SessionNotFound (20410)
       * - SessionNotUnlocked (20431)
       * - Internal (10500)
       *
       * @generated from rpc domain.SessionService.ExtendSessionUnlock
       */
      extendSessionUnlock: {
        name: "ExtendSessionUnlock",
        I: ExtendSessionUnlockRequest,
        O: ExtendSessionUnlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * TODO Note: currently only sends FCM messages, thus only works for authenticator sessions
       * Note: This call does not throw an error even if no messages was actually sent.
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.SendSessionMessage
       */
      sendSessionMessage: {
        name: "SendSessionMessage",
        I: SendSessionMessageRequest,
        O: SendSessionMessageResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - MalformedClientSettings (20480): the client settings are not valid JSON
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.Update
       */
      update: {
        name: "Update",
        I: UpdateSessionRequest,
        O: UpdateSessionResponse,
        kind: MethodKind.Unary
      },
      /**
       * deprecated, use UpdateSession endpoint
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - MalformedClientSettings (20480): the client settings are not valid JSON
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.SetClientSettings
       */
      setClientSettings: {
        name: "SetClientSettings",
        I: SetClientSettingsRequest,
        O: SetClientSettingsResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class PreviewShareLinkRequest extends Message {
    constructor(data) {
      super();
      this.shareLinkId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new PreviewShareLinkRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new PreviewShareLinkRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new PreviewShareLinkRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(PreviewShareLinkRequest, a, b2);
    }
  }
  PreviewShareLinkRequest.runtime = proto3;
  PreviewShareLinkRequest.typeName = "domain.PreviewShareLinkRequest";
  PreviewShareLinkRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "share_link_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class PreviewShareLinkResponse extends Message {
    constructor(data) {
      super();
      this.encryptedPayload = new Uint8Array(0);
      this.senderEmail = "";
      this.organizationName = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new PreviewShareLinkResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new PreviewShareLinkResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new PreviewShareLinkResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(PreviewShareLinkResponse, a, b2);
    }
  }
  PreviewShareLinkResponse.runtime = proto3;
  PreviewShareLinkResponse.typeName = "domain.PreviewShareLinkResponse";
  PreviewShareLinkResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_payload",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "sender_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "organization_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShowShareLinkRequest extends Message {
    constructor(data) {
      super();
      this.shareLinkId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowShareLinkRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowShareLinkRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowShareLinkRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ShowShareLinkRequest, a, b2);
    }
  }
  ShowShareLinkRequest.runtime = proto3;
  ShowShareLinkRequest.typeName = "domain.ShowShareLinkRequest";
  ShowShareLinkRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "share_link_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShowShareLinkResponse extends Message {
    constructor(data) {
      super();
      this.encryptedPayload = new Uint8Array(0);
      this.encryptedProtectedSecret = new Uint8Array(0);
      this.senderEmail = "";
      this.organizationName = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowShareLinkResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowShareLinkResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowShareLinkResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(ShowShareLinkResponse, a, b2);
    }
  }
  ShowShareLinkResponse.runtime = proto3;
  ShowShareLinkResponse.typeName = "domain.ShowShareLinkResponse";
  ShowShareLinkResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_payload",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "encrypted_protected_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "sender_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "organization_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  ({
    typeName: "domain.ShareLinkService",
    methods: {
      /**
       * errors:
       * - ShareLinkNotFound (110400): share link not found or already used
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ShareLinkService.Preview
       */
      preview: {
        name: "Preview",
        I: PreviewShareLinkRequest,
        O: PreviewShareLinkResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - ShareLinkNotFound (110400): share link not found or already used
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ShareLinkService.Show
       */
      show: {
        name: "Show",
        I: ShowShareLinkRequest,
        O: ShowShareLinkResponse,
        kind: MethodKind.Unary
      }
    }
  });
  ({
    typeName: "domain.SupportService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationNotFound (60400): not member of the given organization
       * - ProfileNotFound (): not a profile of this user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SupportService.SendMessage
       */
      sendMessage: {
        name: "SendMessage",
        I: SendMessageRequest,
        O: SendMessageResponse,
        kind: MethodKind.Unary
      },
      /**
       * @generated from rpc domain.SupportService.ReportPage
       */
      reportPage: {
        name: "ReportPage",
        I: ReportPageRequest,
        O: ReportPageResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class StreamingSyncRequest extends Message {
    constructor(data) {
      super();
      this.resetAndRequestSessionUnlock = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new StreamingSyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new StreamingSyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new StreamingSyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(StreamingSyncRequest, a, b2);
    }
  }
  StreamingSyncRequest.runtime = proto3;
  StreamingSyncRequest.typeName = "domain.StreamingSyncRequest";
  StreamingSyncRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "reset_and_request_session_unlock",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class LongPollSyncRequest extends Message {
    constructor(data) {
      super();
      this.resetAndRequestSessionUnlock = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LongPollSyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LongPollSyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LongPollSyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(LongPollSyncRequest, a, b2);
    }
  }
  LongPollSyncRequest.runtime = proto3;
  LongPollSyncRequest.typeName = "domain.LongPollSyncRequest";
  LongPollSyncRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "reset_and_request_session_unlock",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class SyncRequest extends Message {
    constructor(data) {
      super();
      this.fcmMessageId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncRequest, a, b2);
    }
  }
  SyncRequest.runtime = proto3;
  SyncRequest.typeName = "domain.SyncRequest";
  SyncRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "fcm_message_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SyncResponse, a, b2);
    }
  }
  SyncResponse.runtime = proto3;
  SyncResponse.typeName = "domain.SyncResponse";
  SyncResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  ({
    typeName: "domain.SyncService",
    methods: {
      /**
       * The StreamingSync call is an event stream that will send a SyncResponse to the client whenever
       * updates are available. This only includes updates that originate from a different client-id
       * than the StreamingSync call.
       *
       * This call takes an optional request_session_unlock parameter, which requests the session to be
       * unlocked if set. This allows clients to refresh their StreamingSync connection at the same time
       * as requesting an unlock, which is a typical initiation point for user interaction.
       *
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - Timeout (10200): timed out
       *
       * @generated from rpc domain.SyncService.StreamingSync
       */
      streamingSync: {
        name: "StreamingSync",
        I: StreamingSyncRequest,
        O: SyncResponse,
        kind: MethodKind.ServerStreaming
      },
      /**
       * The Sync call is a single unary request for a SyncResponse, but returns only once the user
       * syncVersion is bigger than the client-specified one.
       *
       * This call takes an optional request_session_unlock parameter, as above.
       *
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SyncService.LongPollSync
       */
      longPollSync: {
        name: "LongPollSync",
        I: LongPollSyncRequest,
        O: SyncResponse,
        kind: MethodKind.Unary
      },
      /**
       * The Sync call is a single unary request for a SyncResponse.
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SyncService.Sync
       */
      sync: {
        name: "Sync",
        I: SyncRequest,
        O: SyncResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class UserConfirmationData extends Message {
    constructor(data) {
      super();
      this.type = UserConfirmationType.UNKNOWN;
      this.vaultId = "";
      this.loginId = "";
      this.profileId = "";
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UserConfirmationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UserConfirmationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UserConfirmationData().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UserConfirmationData, a, b2);
    }
  }
  UserConfirmationData.runtime = proto3;
  UserConfirmationData.typeName = "domain.UserConfirmationData";
  UserConfirmationData.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(UserConfirmationType) },
    {
      no: 2,
      name: "vaultId",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "loginId",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "profileId",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "organizationId",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateUserConfirmationRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateUserConfirmationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateUserConfirmationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateUserConfirmationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateUserConfirmationRequest, a, b2);
    }
  }
  CreateUserConfirmationRequest.runtime = proto3;
  CreateUserConfirmationRequest.typeName = "domain.CreateUserConfirmationRequest";
  CreateUserConfirmationRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: UserConfirmationData }
  ]);
  class CreateUserConfirmationResponse extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.webauthnOptionsJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateUserConfirmationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateUserConfirmationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateUserConfirmationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateUserConfirmationResponse, a, b2);
    }
  }
  CreateUserConfirmationResponse.runtime = proto3;
  CreateUserConfirmationResponse.typeName = "domain.CreateUserConfirmationResponse";
  CreateUserConfirmationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "webauthn_options_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetUserConfirmationRequest extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetUserConfirmationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetUserConfirmationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetUserConfirmationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetUserConfirmationRequest, a, b2);
    }
  }
  GetUserConfirmationRequest.runtime = proto3;
  GetUserConfirmationRequest.typeName = "domain.GetUserConfirmationRequest";
  GetUserConfirmationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetUserConfirmationResponse extends Message {
    constructor(data) {
      super();
      this.requestingSessionId = "";
      this.fallbackString = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetUserConfirmationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetUserConfirmationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetUserConfirmationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(GetUserConfirmationResponse, a, b2);
    }
  }
  GetUserConfirmationResponse.runtime = proto3;
  GetUserConfirmationResponse.typeName = "domain.GetUserConfirmationResponse";
  GetUserConfirmationResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "requesting_session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "data", kind: "message", T: UserConfirmationData },
    {
      no: 3,
      name: "fallback_string",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SendUserConfirmationResultRequest extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.type = UserConfirmationResultType.OPEN;
      this.webauthnResponseJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendUserConfirmationResultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendUserConfirmationResultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendUserConfirmationResultRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SendUserConfirmationResultRequest, a, b2);
    }
  }
  SendUserConfirmationResultRequest.runtime = proto3;
  SendUserConfirmationResultRequest.typeName = "domain.SendUserConfirmationResultRequest";
  SendUserConfirmationResultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(UserConfirmationResultType) },
    {
      no: 3,
      name: "webauthn_response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SendUserConfirmationResultResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendUserConfirmationResultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendUserConfirmationResultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendUserConfirmationResultResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(SendUserConfirmationResultResponse, a, b2);
    }
  }
  SendUserConfirmationResultResponse.runtime = proto3;
  SendUserConfirmationResultResponse.typeName = "domain.SendUserConfirmationResultResponse";
  SendUserConfirmationResultResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RetrieveUserConfirmationResultRequest extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RetrieveUserConfirmationResultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RetrieveUserConfirmationResultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RetrieveUserConfirmationResultRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RetrieveUserConfirmationResultRequest, a, b2);
    }
  }
  RetrieveUserConfirmationResultRequest.runtime = proto3;
  RetrieveUserConfirmationResultRequest.typeName = "domain.RetrieveUserConfirmationResultRequest";
  RetrieveUserConfirmationResultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RetrieveUserConfirmationResultResponse extends Message {
    constructor(data) {
      super();
      this.resultType = UserConfirmationResultType.OPEN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RetrieveUserConfirmationResultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RetrieveUserConfirmationResultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RetrieveUserConfirmationResultResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RetrieveUserConfirmationResultResponse, a, b2);
    }
  }
  RetrieveUserConfirmationResultResponse.runtime = proto3;
  RetrieveUserConfirmationResultResponse.typeName = "domain.RetrieveUserConfirmationResultResponse";
  RetrieveUserConfirmationResultResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "result_type", kind: "enum", T: proto3.getEnumType(UserConfirmationResultType) }
  ]);
  class CancelUserConfirmationRequest extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CancelUserConfirmationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CancelUserConfirmationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CancelUserConfirmationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CancelUserConfirmationRequest, a, b2);
    }
  }
  CancelUserConfirmationRequest.runtime = proto3;
  CancelUserConfirmationRequest.typeName = "domain.CancelUserConfirmationRequest";
  CancelUserConfirmationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CancelUserConfirmationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CancelUserConfirmationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CancelUserConfirmationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CancelUserConfirmationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CancelUserConfirmationResponse, a, b2);
    }
  }
  CancelUserConfirmationResponse.runtime = proto3;
  CancelUserConfirmationResponse.typeName = "domain.CancelUserConfirmationResponse";
  CancelUserConfirmationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  ({
    typeName: "domain.UserConfirmationService",
    methods: {
      /**
       * errors:
       * - BadRequest (10400): user confirmation data is invalid
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.Create
       */
      create: {
        name: "Create",
        I: CreateUserConfirmationRequest,
        O: CreateUserConfirmationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - UserConfirmationNotFound (120400)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.Get
       */
      get: {
        name: "Get",
        I: GetUserConfirmationRequest,
        O: GetUserConfirmationResponse,
        kind: MethodKind.Unary
      },
      /**
       * Restricted to authenticator sessions, unless called with webauthn_credential_data filled.
       * errors:
       * - BadRequest (10400): invalid result type was sent, or by session that is not self unlocking
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - UserConfirmationNotFound (120400)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.SendResult
       */
      sendResult: {
        name: "SendResult",
        I: SendUserConfirmationResultRequest,
        O: SendUserConfirmationResultResponse,
        kind: MethodKind.Unary
      },
      /**
       * Restricted to session which created the UserConfirmation. Calling this endpoint clears the
       * UserConfirmation on the backend as well.
       * errors:
       * - BadRequest (10400): user confirmation did not have a result yet, or did not belong to session
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - UserConfirmationNotFound (120400)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.RetrieveResult
       */
      retrieveResult: {
        name: "RetrieveResult",
        I: RetrieveUserConfirmationResultRequest,
        O: RetrieveUserConfirmationResultResponse,
        kind: MethodKind.Unary
      },
      /**
       * Restricted to session which created the UserConfirmation. This endpoint is idempotent, and
       * returns success if a confirmation was already cancelled or resolved.
       * errors:
       * - BadRequest (10400): user confirmation did not belong to session
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.Cancel
       */
      cancel: {
        name: "Cancel",
        I: CancelUserConfirmationRequest,
        O: CancelUserConfirmationResponse,
        kind: MethodKind.Unary
      }
    }
  });
  ({
    typeName: "domain.VaultService",
    methods: {
      /**
       * errors:
       * - BadRequest (10400): trying to update share link from another vault
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultNotFound (50400)
       * - InvalidUpdateTime (50430): invalid update time
       * - VaultDirty (50450): vault needs to be regenerated before commit can be made (is flagged dirty)
       * - EmptyCommit (50200): commit blob is empty
       * - PermissionDenied (10100): insufficient permissions
       * - VaultOutOfSync (50100): latest_commit_id does not match, or generation_id of message does not match
       * - NotAllowedForVault (50110): target vault of vault message not valid
       * - MissingVaultMessagePublicKey (50461): the vault has no message public key, but it is required for the operation
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.CreateCommit
       */
      createCommit: {
        name: "CreateCommit",
        I: CreateCommitRequest,
        O: CreateCommitResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultNotFound (50400): vault not found
       * - EmptyCommit (50200): commit blob is empty
       * - PermissionDenied (10100): insufficient permissions
       * - VaultOutOfSync (50100): latest_commit_id does not match, or generation_id of message does not match
       * - NotAllowedForVault (50110): target vault of vault message not valid
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.CreateGeneration
       */
      createGeneration: {
        name: "CreateGeneration",
        I: CreateGenerationRequest,
        O: CreateGenerationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultNotFound (50400): vault not found
       * - PermissionDenied (10100): insufficient permissions
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.ListCommits
       */
      listCommits: {
        name: "ListCommits",
        I: ListCommitsRequest,
        O: ListCommitsResponse,
        kind: MethodKind.Unary
      },
      /**
       * Create creates a new vault for the authenticated user.
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - UserNotFound (20400): user not found
       * - InvalidVaultType (50431): given vault types are not allowed
       * - OrganizationInsufficientAccess (60100): user may not create team in specified organization
       * - OrganizationNotFound (60400): organization does not exist or user is not a member
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.CreateTeam
       */
      createTeam: {
        name: "CreateTeam",
        I: CreateTeamRequest,
        O: CreateTeamResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultNotFound (50400): vault not found
       * - PermissionDenied (10100): insufficient permissions
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.DeleteTeam
       */
      deleteTeam: {
        name: "DeleteTeam",
        I: DeleteTeamRequest,
        O: DeleteTeamResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - UserNotFound (20400): one of the users to add was not found
       * - NotAllowedForUserType (20470): tried to add/remove an organization user
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - NotAllowedForVault (50110): tried to change users on a personal vault
       * - VaultNotFound (50400): vault not found or associated vault id does not match
       * - EmptyCommit (50200): commit blob is empty
       * - InvalidUpdateTime (50430): invalid update time
       * - VaultOutOfSync (50100): latest_commit_id, generation_id or assoc_generation_id does not match
       * - MissingLock (50410): a lock is missing for regneration or no keks were provided for a new authenticator
       * - MissingVault (50420): missing associated regenerate data
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.ModifyTeamUsers
       */
      modifyTeamUsers: {
        name: "ModifyTeamUsers",
        I: ModifyTeamUsersRequest,
        O: ModifyTeamUsersResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - MissingVaultAuthenticatorLock (50410): a vault authenticator lock is missing
       * - MissingVault (50420): missing VaultPairCreationData
       * - MissingEncryptedVaultMessagePrivateKey (50460): a lock is missing the encrypted private key
       * - MissingVaultMessagePublicKey (50461): no message public key was provided
       * - VaultInboxSlugInvalid (50470): the inbox slug is invalid
       * - VaultInboxSlugTaken (50471): the inbox slug is already in use
       * - OrganizationInsufficientAccess (60100): not allowed to create vaults in organization
       * - OrganizationNotFound (60400): organization not found or no access
       * - ProfileNotFound (70400): the profile was not found for the user
       * - ProfileAlreadyEnabled (70401): got authenticatelocks for profile-enabled user
       * - ProfileOutOfSync (70411): ProfileLock does not have curren KeyGenerationId
       * - Internal (10500)
       *
       * @generated from rpc domain.VaultService.CreateInboxVault
       */
      createInboxVault: {
        name: "CreateInboxVault",
        I: CreateInboxVaultRequest,
        O: CreateInboxVaultResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - PermissionDenied (10100): no access to the vault
       * - NotAllowedForVault (50110): specified vault is not an inbox Vault
       * - VaultInboxSlugInvalid (50470)
       * - VaultInboxSlugTaken (50471)
       * - Internal (10500)
       *
       * @generated from rpc domain.VaultService.UpdateInbox
       */
      updateInbox: {
        name: "UpdateInbox",
        I: UpdateInboxRequest,
        O: UpdateInboxResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - VaultNotFound (50400)
       * - NotAllowedForVault (50110): specified vault is not an inbox Vault
       * - PermissionDenied (10100): no access to the vault
       * - Internal (10500)
       *
       * @generated from rpc domain.VaultService.DeleteInboxVault
       */
      deleteInboxVault: {
        name: "DeleteInboxVault",
        I: DeleteInboxVaultRequest,
        O: DeleteInboxVaultResponse,
        kind: MethodKind.Unary
      },
      /**
       * Note this method does not throw VaultNotFound.
       * Missing vaults will just be missing from the result.
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - Internal (10500)
       *
       * @generated from rpc domain.VaultService.ListMessagePublicKeys
       */
      listMessagePublicKeys: {
        name: "ListMessagePublicKeys",
        I: ListMessagePublicKeysRequest,
        O: ListMessagePublicKeysResponse,
        kind: MethodKind.Unary
      }
    }
  });
  class RegisterCredentialInitRequest extends Message {
    constructor(data) {
      super();
      this.credentialType = CredentialType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialInitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialInitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialInitRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegisterCredentialInitRequest, a, b2);
    }
  }
  RegisterCredentialInitRequest.runtime = proto3;
  RegisterCredentialInitRequest.typeName = "domain.RegisterCredentialInitRequest";
  RegisterCredentialInitRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "credential_type", kind: "enum", T: proto3.getEnumType(CredentialType) }
  ]);
  class RegisterCredentialInitResponse extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.optionsJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialInitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialInitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialInitResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegisterCredentialInitResponse, a, b2);
    }
  }
  RegisterCredentialInitResponse.runtime = proto3;
  RegisterCredentialInitResponse.typeName = "domain.RegisterCredentialInitResponse";
  RegisterCredentialInitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "options_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RegisterCredentialForAccountCreationInitRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialForAccountCreationInitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialForAccountCreationInitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialForAccountCreationInitRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegisterCredentialForAccountCreationInitRequest, a, b2);
    }
  }
  RegisterCredentialForAccountCreationInitRequest.runtime = proto3;
  RegisterCredentialForAccountCreationInitRequest.typeName = "domain.RegisterCredentialForAccountCreationInitRequest";
  RegisterCredentialForAccountCreationInitRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RegisterCredentialForAccountCreationInitResponse extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.optionsJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialForAccountCreationInitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialForAccountCreationInitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialForAccountCreationInitResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegisterCredentialForAccountCreationInitResponse, a, b2);
    }
  }
  RegisterCredentialForAccountCreationInitResponse.runtime = proto3;
  RegisterCredentialForAccountCreationInitResponse.typeName = "domain.RegisterCredentialForAccountCreationInitResponse";
  RegisterCredentialForAccountCreationInitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "options_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RegisterCredentialFinishRequest extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.responseJson = "";
      this.prfSupportStatus = WebauthnPrfSupportStatus.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialFinishRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialFinishRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialFinishRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegisterCredentialFinishRequest, a, b2);
    }
  }
  RegisterCredentialFinishRequest.runtime = proto3;
  RegisterCredentialFinishRequest.typeName = "domain.RegisterCredentialFinishRequest";
  RegisterCredentialFinishRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "prf_support_status", kind: "enum", T: proto3.getEnumType(WebauthnPrfSupportStatus) }
  ]);
  class RegisterCredentialFinishResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialFinishResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialFinishResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialFinishResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(RegisterCredentialFinishResponse, a, b2);
    }
  }
  RegisterCredentialFinishResponse.runtime = proto3;
  RegisterCredentialFinishResponse.typeName = "domain.RegisterCredentialFinishResponse";
  RegisterCredentialFinishResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class UnlockSessionInitRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockSessionInitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockSessionInitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockSessionInitRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UnlockSessionInitRequest, a, b2);
    }
  }
  UnlockSessionInitRequest.runtime = proto3;
  UnlockSessionInitRequest.typeName = "domain.UnlockSessionInitRequest";
  UnlockSessionInitRequest.fields = proto3.util.newFieldList(() => []);
  class UnlockSessionInitResponse extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.optionsJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockSessionInitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockSessionInitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockSessionInitResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UnlockSessionInitResponse, a, b2);
    }
  }
  UnlockSessionInitResponse.runtime = proto3;
  UnlockSessionInitResponse.typeName = "domain.UnlockSessionInitResponse";
  UnlockSessionInitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "options_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class UnlockSessionFinishRequest extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.responseJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockSessionFinishRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockSessionFinishRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockSessionFinishRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UnlockSessionFinishRequest, a, b2);
    }
  }
  UnlockSessionFinishRequest.runtime = proto3;
  UnlockSessionFinishRequest.typeName = "domain.UnlockSessionFinishRequest";
  UnlockSessionFinishRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "max_expires_at", kind: "message", T: Timestamp }
  ]);
  class UnlockSessionFinishResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockSessionFinishResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockSessionFinishResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockSessionFinishResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(UnlockSessionFinishResponse, a, b2);
    }
  }
  UnlockSessionFinishResponse.runtime = proto3;
  UnlockSessionFinishResponse.typeName = "domain.UnlockSessionFinishResponse";
  UnlockSessionFinishResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteCredentialsRequest extends Message {
    constructor(data) {
      super();
      this.webauthnIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteCredentialsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteCredentialsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteCredentialsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteCredentialsRequest, a, b2);
    }
  }
  DeleteCredentialsRequest.runtime = proto3;
  DeleteCredentialsRequest.typeName = "domain.DeleteCredentialsRequest";
  DeleteCredentialsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "webauthn_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class DeleteCredentialsResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteCredentialsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteCredentialsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteCredentialsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(DeleteCredentialsResponse, a, b2);
    }
  }
  DeleteCredentialsResponse.runtime = proto3;
  DeleteCredentialsResponse.typeName = "domain.DeleteCredentialsResponse";
  DeleteCredentialsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  ({
    typeName: "domain.WebauthnService",
    methods: {
      /**
       * errors:
       * - BadRequest (10400): if an unknown credential type is given
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - SessionNotUnlocked (20431)
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.RegisterCredentialInit
       */
      registerCredentialInit: {
        name: "RegisterCredentialInit",
        I: RegisterCredentialInitRequest,
        O: RegisterCredentialInitResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - InvalidEmail (20101)
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.RegisterCredentialForAccountCreationInit
       */
      registerCredentialForAccountCreationInit: {
        name: "RegisterCredentialForAccountCreationInit",
        I: RegisterCredentialForAccountCreationInitRequest,
        O: RegisterCredentialForAccountCreationInitResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - SessionNotUnlocked (20431)
       * - WebauthnValidateError (80400): there is a cryptographic error with the response
       * - WebauthnDataError (80401): there is a parsing error with the response
       * - WebauthnInvalidTransport (80403): credential had an invalid transport (for its type)
       * - WebauthnRequestNotFound (80402): the request_id was not found, or timed out
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.RegisterCredentialFinish
       */
      registerCredentialFinish: {
        name: "RegisterCredentialFinish",
        I: RegisterCredentialFinishRequest,
        O: RegisterCredentialFinishResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - SessionNotUnlocked (20431): session can't be unlocked due to missing encrypted_session_unlock
       * - MissingWebauthnCredential (80404): if no webauthn credentials are registered
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.UnlockSessionInit
       */
      unlockSessionInit: {
        name: "UnlockSessionInit",
        I: UnlockSessionInitRequest,
        O: UnlockSessionInitResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - InvalidTimeout (20420): expires_at is already expired
       * - WebauthnValidateError (80400): there is a cryptographic error with the response
       * - WebauthnDataError (80401): there is a parsing error with the response
       * - WebauthnRequestNotFound (80402): the request_id was not found, or timed out
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.UnlockSessionFinish
       */
      unlockSessionFinish: {
        name: "UnlockSessionFinish",
        I: UnlockSessionFinishRequest,
        O: UnlockSessionFinishResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.DeleteCredentials
       */
      deleteCredentials: {
        name: "DeleteCredentials",
        I: DeleteCredentialsRequest,
        O: DeleteCredentialsResponse,
        kind: MethodKind.Unary
      }
    }
  });
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __awaiter$W = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class CancelToken {
    constructor() {
      this.isCancelled = false;
      this.emitter = new Emittery$3.Typed();
    }
    static create() {
      return new CancelToken();
    }
    cancel() {
      this.performCancel().catch(trackError);
    }
    onCancel(cancelHandler) {
      if (this.isCancelled) {
        cancelHandler();
      } else {
        this.emitter.on("cancel", cancelHandler);
      }
    }
    offCancel(cancelHandler) {
      this.emitter.off("cancel", cancelHandler);
    }
    get signal() {
      if (!this.abortController) {
        this.abortController = new AbortController();
        if (this.isCancelled) {
          this.abortController.abort();
        }
      }
      return this.abortController.signal;
    }
    performCancel() {
      var _a3;
      return __awaiter$W(this, void 0, void 0, function* () {
        if (!this.isCancelled) {
          this.isCancelled = true;
          yield this.emitter.emit("cancel");
          this.emitter.clearListeners("cancel");
          (_a3 = this.abortController) === null || _a3 === void 0 ? void 0 : _a3.abort();
        }
      });
    }
  }
  class AuthenticatorReply extends Message {
    constructor(data) {
      super();
      this.replyOneof = { case: void 0 };
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorReply().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorReply().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorReply().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(AuthenticatorReply, a, b2);
    }
  }
  AuthenticatorReply.runtime = proto3;
  AuthenticatorReply.typeName = "domain.AuthenticatorReply";
  AuthenticatorReply.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "encrypted_secret_reply", kind: "message", T: EncryptedSecretAuthenticatorReply, oneof: "reply_oneof" }
  ]);
  class EncryptedSecretAuthenticatorReply extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      this.registration = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EncryptedSecretAuthenticatorReply().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EncryptedSecretAuthenticatorReply().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EncryptedSecretAuthenticatorReply().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(EncryptedSecretAuthenticatorReply, a, b2);
    }
  }
  EncryptedSecretAuthenticatorReply.runtime = proto3;
  EncryptedSecretAuthenticatorReply.typeName = "domain.EncryptedSecretAuthenticatorReply";
  EncryptedSecretAuthenticatorReply.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "registration",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  function createEncryptedSecretAuthenticatorReply(dto) {
    const reply = new AuthenticatorReply({
      replyOneof: { case: "encryptedSecretReply", value: dto }
    });
    return reply.toBinary();
  }
  class TestingDropLatestCommitRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDropLatestCommitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDropLatestCommitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDropLatestCommitRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDropLatestCommitRequest, a, b2);
    }
  }
  TestingDropLatestCommitRequest.runtime = proto3;
  TestingDropLatestCommitRequest.typeName = "domain.TestingDropLatestCommitRequest";
  TestingDropLatestCommitRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDropLatestCommitResponse extends Message {
    constructor(data) {
      super();
      this.latestCommitId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDropLatestCommitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDropLatestCommitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDropLatestCommitResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDropLatestCommitResponse, a, b2);
    }
  }
  TestingDropLatestCommitResponse.runtime = proto3;
  TestingDropLatestCommitResponse.typeName = "domain.TestingDropLatestCommitResponse";
  TestingDropLatestCommitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "latest_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingListEmailsRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingListEmailsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingListEmailsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingListEmailsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingListEmailsRequest, a, b2);
    }
  }
  TestingListEmailsRequest.runtime = proto3;
  TestingListEmailsRequest.typeName = "domain.TestingListEmailsRequest";
  TestingListEmailsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingListEmailsResponse extends Message {
    constructor(data) {
      super();
      this.emails = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingListEmailsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingListEmailsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingListEmailsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingListEmailsResponse, a, b2);
    }
  }
  TestingListEmailsResponse.runtime = proto3;
  TestingListEmailsResponse.typeName = "domain.TestingListEmailsResponse";
  TestingListEmailsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "emails", kind: "message", T: TestingListEmailsResponse_Email, repeated: true }
  ]);
  class TestingListEmailsResponse_Email extends Message {
    constructor(data) {
      super();
      this.to = "";
      this.template = "";
      this.data = {};
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingListEmailsResponse_Email().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingListEmailsResponse_Email().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingListEmailsResponse_Email().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingListEmailsResponse_Email, a, b2);
    }
  }
  TestingListEmailsResponse_Email.runtime = proto3;
  TestingListEmailsResponse_Email.typeName = "domain.TestingListEmailsResponse.Email";
  TestingListEmailsResponse_Email.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "to",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "template",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "data", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } }
  ]);
  class TestingSetServerSideSettingsRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.serverSideSettings = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingSetServerSideSettingsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingSetServerSideSettingsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingSetServerSideSettingsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingSetServerSideSettingsRequest, a, b2);
    }
  }
  TestingSetServerSideSettingsRequest.runtime = proto3;
  TestingSetServerSideSettingsRequest.typeName = "domain.TestingSetServerSideSettingsRequest";
  TestingSetServerSideSettingsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "server_side_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingSetServerSideSettingsResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingSetServerSideSettingsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingSetServerSideSettingsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingSetServerSideSettingsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingSetServerSideSettingsResponse, a, b2);
    }
  }
  TestingSetServerSideSettingsResponse.runtime = proto3;
  TestingSetServerSideSettingsResponse.typeName = "domain.TestingSetServerSideSettingsResponse";
  TestingSetServerSideSettingsResponse.fields = proto3.util.newFieldList(() => []);
  class TestingDeleteUserRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteUserRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteUserRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteUserRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDeleteUserRequest, a, b2);
    }
  }
  TestingDeleteUserRequest.runtime = proto3;
  TestingDeleteUserRequest.typeName = "domain.TestingDeleteUserRequest";
  TestingDeleteUserRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDeleteUserResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteUserResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteUserResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteUserResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDeleteUserResponse, a, b2);
    }
  }
  TestingDeleteUserResponse.runtime = proto3;
  TestingDeleteUserResponse.typeName = "domain.TestingDeleteUserResponse";
  TestingDeleteUserResponse.fields = proto3.util.newFieldList(() => []);
  class TestingAddAuthenticatorRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingAddAuthenticatorRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingAddAuthenticatorRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingAddAuthenticatorRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingAddAuthenticatorRequest, a, b2);
    }
  }
  TestingAddAuthenticatorRequest.runtime = proto3;
  TestingAddAuthenticatorRequest.typeName = "domain.TestingAddAuthenticatorRequest";
  TestingAddAuthenticatorRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "authenticator", kind: "message", T: AuthenticatorData },
    { no: 3, name: "block", kind: "message", T: AuthenticatorBlock$1 }
  ]);
  class TestingAddAuthenticatorResponse extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingAddAuthenticatorResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingAddAuthenticatorResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingAddAuthenticatorResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingAddAuthenticatorResponse, a, b2);
    }
  }
  TestingAddAuthenticatorResponse.runtime = proto3;
  TestingAddAuthenticatorResponse.typeName = "domain.TestingAddAuthenticatorResponse";
  TestingAddAuthenticatorResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDeleteAuthenticatorRequest extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteAuthenticatorRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteAuthenticatorRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteAuthenticatorRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDeleteAuthenticatorRequest, a, b2);
    }
  }
  TestingDeleteAuthenticatorRequest.runtime = proto3;
  TestingDeleteAuthenticatorRequest.typeName = "domain.TestingDeleteAuthenticatorRequest";
  TestingDeleteAuthenticatorRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDeleteAuthenticatorResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteAuthenticatorResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteAuthenticatorResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteAuthenticatorResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDeleteAuthenticatorResponse, a, b2);
    }
  }
  TestingDeleteAuthenticatorResponse.runtime = proto3;
  TestingDeleteAuthenticatorResponse.typeName = "domain.TestingDeleteAuthenticatorResponse";
  TestingDeleteAuthenticatorResponse.fields = proto3.util.newFieldList(() => []);
  class TestingEditAuthenticatorRequest extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingEditAuthenticatorRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingEditAuthenticatorRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingEditAuthenticatorRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingEditAuthenticatorRequest, a, b2);
    }
  }
  TestingEditAuthenticatorRequest.runtime = proto3;
  TestingEditAuthenticatorRequest.typeName = "domain.TestingEditAuthenticatorRequest";
  TestingEditAuthenticatorRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "data", kind: "message", T: AuthenticatorData }
  ]);
  class TestingEditAuthenticatorResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingEditAuthenticatorResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingEditAuthenticatorResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingEditAuthenticatorResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingEditAuthenticatorResponse, a, b2);
    }
  }
  TestingEditAuthenticatorResponse.runtime = proto3;
  TestingEditAuthenticatorResponse.typeName = "domain.TestingEditAuthenticatorResponse";
  TestingEditAuthenticatorResponse.fields = proto3.util.newFieldList(() => []);
  class TestingDeleteAuthenticatorBlockRequest extends Message {
    constructor(data) {
      super();
      this.hash = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteAuthenticatorBlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteAuthenticatorBlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteAuthenticatorBlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDeleteAuthenticatorBlockRequest, a, b2);
    }
  }
  TestingDeleteAuthenticatorBlockRequest.runtime = proto3;
  TestingDeleteAuthenticatorBlockRequest.typeName = "domain.TestingDeleteAuthenticatorBlockRequest";
  TestingDeleteAuthenticatorBlockRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class TestingDeleteAuthenticatorBlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteAuthenticatorBlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteAuthenticatorBlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteAuthenticatorBlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDeleteAuthenticatorBlockResponse, a, b2);
    }
  }
  TestingDeleteAuthenticatorBlockResponse.runtime = proto3;
  TestingDeleteAuthenticatorBlockResponse.typeName = "domain.TestingDeleteAuthenticatorBlockResponse";
  TestingDeleteAuthenticatorBlockResponse.fields = proto3.util.newFieldList(() => []);
  class TestingDeleteVaultRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteVaultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteVaultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteVaultRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDeleteVaultRequest, a, b2);
    }
  }
  TestingDeleteVaultRequest.runtime = proto3;
  TestingDeleteVaultRequest.typeName = "domain.TestingDeleteVaultRequest";
  TestingDeleteVaultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDeleteVaultResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteVaultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteVaultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteVaultResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingDeleteVaultResponse, a, b2);
    }
  }
  TestingDeleteVaultResponse.runtime = proto3;
  TestingDeleteVaultResponse.typeName = "domain.TestingDeleteVaultResponse";
  TestingDeleteVaultResponse.fields = proto3.util.newFieldList(() => []);
  class TestingInjectPaddleWebhookRequest extends Message {
    constructor(data) {
      super();
      this.dataJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingInjectPaddleWebhookRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingInjectPaddleWebhookRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingInjectPaddleWebhookRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingInjectPaddleWebhookRequest, a, b2);
    }
  }
  TestingInjectPaddleWebhookRequest.runtime = proto3;
  TestingInjectPaddleWebhookRequest.typeName = "domain.TestingInjectPaddleWebhookRequest";
  TestingInjectPaddleWebhookRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "data_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingInjectPaddleWebhookResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingInjectPaddleWebhookResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingInjectPaddleWebhookResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingInjectPaddleWebhookResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingInjectPaddleWebhookResponse, a, b2);
    }
  }
  TestingInjectPaddleWebhookResponse.runtime = proto3;
  TestingInjectPaddleWebhookResponse.typeName = "domain.TestingInjectPaddleWebhookResponse";
  TestingInjectPaddleWebhookResponse.fields = proto3.util.newFieldList(() => []);
  class TestingUpdatePaddleRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingUpdatePaddleRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingUpdatePaddleRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingUpdatePaddleRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingUpdatePaddleRequest, a, b2);
    }
  }
  TestingUpdatePaddleRequest.runtime = proto3;
  TestingUpdatePaddleRequest.typeName = "domain.TestingUpdatePaddleRequest";
  TestingUpdatePaddleRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingUpdatePaddleResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingUpdatePaddleResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingUpdatePaddleResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingUpdatePaddleResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingUpdatePaddleResponse, a, b2);
    }
  }
  TestingUpdatePaddleResponse.runtime = proto3;
  TestingUpdatePaddleResponse.typeName = "domain.TestingUpdatePaddleResponse";
  TestingUpdatePaddleResponse.fields = proto3.util.newFieldList(() => []);
  class TestingCreateCouponRequest extends Message {
    constructor(data) {
      super();
      this.couponText = "";
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingCreateCouponRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingCreateCouponRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingCreateCouponRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingCreateCouponRequest, a, b2);
    }
  }
  TestingCreateCouponRequest.runtime = proto3;
  TestingCreateCouponRequest.typeName = "domain.TestingCreateCouponRequest";
  TestingCreateCouponRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "coupon_text",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class TestingCreateCouponResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingCreateCouponResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingCreateCouponResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingCreateCouponResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingCreateCouponResponse, a, b2);
    }
  }
  TestingCreateCouponResponse.runtime = proto3;
  TestingCreateCouponResponse.typeName = "domain.TestingCreateCouponResponse";
  TestingCreateCouponResponse.fields = proto3.util.newFieldList(() => []);
  class TestingUpdateOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.licenseType = LicenseType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingUpdateOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingUpdateOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingUpdateOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingUpdateOrganizationRequest, a, b2);
    }
  }
  TestingUpdateOrganizationRequest.runtime = proto3;
  TestingUpdateOrganizationRequest.typeName = "domain.TestingUpdateOrganizationRequest";
  TestingUpdateOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "license_type", kind: "enum", T: proto3.getEnumType(LicenseType) }
  ]);
  class TestingUpdateOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingUpdateOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingUpdateOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingUpdateOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingUpdateOrganizationResponse, a, b2);
    }
  }
  TestingUpdateOrganizationResponse.runtime = proto3;
  TestingUpdateOrganizationResponse.typeName = "domain.TestingUpdateOrganizationResponse";
  TestingUpdateOrganizationResponse.fields = proto3.util.newFieldList(() => []);
  class CreateVaultMessageRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.type = VaultMessageType.UNKNOWN;
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateVaultMessageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateVaultMessageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateVaultMessageRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateVaultMessageRequest, a, b2);
    }
  }
  CreateVaultMessageRequest.runtime = proto3;
  CreateVaultMessageRequest.typeName = "domain.CreateVaultMessageRequest";
  CreateVaultMessageRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(VaultMessageType) },
    {
      no: 3,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateVaultMessageResponse extends Message {
    constructor(data) {
      super();
      this.messageId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateVaultMessageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateVaultMessageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateVaultMessageResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(CreateVaultMessageResponse, a, b2);
    }
  }
  CreateVaultMessageResponse.runtime = proto3;
  CreateVaultMessageResponse.typeName = "domain.CreateVaultMessageResponse";
  CreateVaultMessageResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "message_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingWebauthnCreateCredentialRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.credentialType = CredentialType.UNKNOWN;
      this.credentialJson = "";
      this.sessionId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingWebauthnCreateCredentialRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingWebauthnCreateCredentialRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingWebauthnCreateCredentialRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingWebauthnCreateCredentialRequest, a, b2);
    }
  }
  TestingWebauthnCreateCredentialRequest.runtime = proto3;
  TestingWebauthnCreateCredentialRequest.typeName = "domain.TestingWebauthnCreateCredentialRequest";
  TestingWebauthnCreateCredentialRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "credential_type", kind: "enum", T: proto3.getEnumType(CredentialType) },
    {
      no: 3,
      name: "credential_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingWebauthnCreateCredentialResponse extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingWebauthnCreateCredentialResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingWebauthnCreateCredentialResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingWebauthnCreateCredentialResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingWebauthnCreateCredentialResponse, a, b2);
    }
  }
  TestingWebauthnCreateCredentialResponse.runtime = proto3;
  TestingWebauthnCreateCredentialResponse.typeName = "domain.TestingWebauthnCreateCredentialResponse";
  TestingWebauthnCreateCredentialResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingManipulateVaultRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingManipulateVaultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingManipulateVaultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingManipulateVaultRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingManipulateVaultRequest, a, b2);
    }
  }
  TestingManipulateVaultRequest.runtime = proto3;
  TestingManipulateVaultRequest.typeName = "domain.TestingManipulateVaultRequest";
  TestingManipulateVaultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "dirty", kind: "scalar", T: 8, opt: true },
    { no: 3, name: "message_public_key", kind: "scalar", T: 12, opt: true }
  ]);
  class TestingManipulateVaultResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingManipulateVaultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingManipulateVaultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingManipulateVaultResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingManipulateVaultResponse, a, b2);
    }
  }
  TestingManipulateVaultResponse.runtime = proto3;
  TestingManipulateVaultResponse.typeName = "domain.TestingManipulateVaultResponse";
  TestingManipulateVaultResponse.fields = proto3.util.newFieldList(() => []);
  class TestingCancelUserStreamingRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingCancelUserStreamingRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingCancelUserStreamingRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingCancelUserStreamingRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingCancelUserStreamingRequest, a, b2);
    }
  }
  TestingCancelUserStreamingRequest.runtime = proto3;
  TestingCancelUserStreamingRequest.typeName = "domain.TestingCancelUserStreamingRequest";
  TestingCancelUserStreamingRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingCancelUserStreamingResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingCancelUserStreamingResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingCancelUserStreamingResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingCancelUserStreamingResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingCancelUserStreamingResponse, a, b2);
    }
  }
  TestingCancelUserStreamingResponse.runtime = proto3;
  TestingCancelUserStreamingResponse.typeName = "domain.TestingCancelUserStreamingResponse";
  TestingCancelUserStreamingResponse.fields = proto3.util.newFieldList(() => []);
  class TestingGetEmailStateRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingGetEmailStateRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingGetEmailStateRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingGetEmailStateRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingGetEmailStateRequest, a, b2);
    }
  }
  TestingGetEmailStateRequest.runtime = proto3;
  TestingGetEmailStateRequest.typeName = "domain.TestingGetEmailStateRequest";
  TestingGetEmailStateRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingGetEmailStateResponse extends Message {
    constructor(data) {
      super();
      this.privateProfileExists = false;
      this.freeOrgProfileCount = 0;
      this.connectedOrgProfileCount = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingGetEmailStateResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingGetEmailStateResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingGetEmailStateResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b2) {
      return proto3.util.equals(TestingGetEmailStateResponse, a, b2);
    }
  }
  TestingGetEmailStateResponse.runtime = proto3;
  TestingGetEmailStateResponse.typeName = "domain.TestingGetEmailStateResponse";
  TestingGetEmailStateResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "private_profile_exists",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "free_org_profile_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "connected_org_profile_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  ({
    typeName: "domain.TestingService",
    methods: {
      /**
       * errors:
       * - VaultNotFound (50400): vault not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingDropLatestCommit
       */
      testingDropLatestCommit: {
        name: "TestingDropLatestCommit",
        I: TestingDropLatestCommitRequest,
        O: TestingDropLatestCommitResponse,
        kind: MethodKind.Unary
      },
      /**
       * no errors
       *
       * @generated from rpc domain.TestingService.TestingListEmails
       */
      testingListEmails: {
        name: "TestingListEmails",
        I: TestingListEmailsRequest,
        O: TestingListEmailsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingSetServerSideSettings
       */
      testingSetServerSideSettings: {
        name: "TestingSetServerSideSettings",
        I: TestingSetServerSideSettingsRequest,
        O: TestingSetServerSideSettingsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - UserNotFound (20400): user not found
       * - Internal (10500): internal server error
       * NOTE: this endpoint is mapped to the corresponding admin interface endpoint
       *
       * @generated from rpc domain.TestingService.TestingDeleteUser
       */
      testingDeleteUser: {
        name: "TestingDeleteUser",
        I: TestingDeleteUserRequest,
        O: TestingDeleteUserResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - UserNotFound (20400): user not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingAddAuthenticator
       */
      testingAddAuthenticator: {
        name: "TestingAddAuthenticator",
        I: TestingAddAuthenticatorRequest,
        O: TestingAddAuthenticatorResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - AuthenticatorNotFound (40400): authenticator not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingDeleteAuthenticator
       */
      testingDeleteAuthenticator: {
        name: "TestingDeleteAuthenticator",
        I: TestingDeleteAuthenticatorRequest,
        O: TestingDeleteAuthenticatorResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - AuthenticatorNotFound (40400): authenticator not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingEditAuthenticator
       */
      testingEditAuthenticator: {
        name: "TestingEditAuthenticator",
        I: TestingEditAuthenticatorRequest,
        O: TestingEditAuthenticatorResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - AuthenticatorBlockNotFound (40440): the authenticator block with given hash was not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingDeleteAuthenticatorBlock
       */
      testingDeleteAuthenticatorBlock: {
        name: "TestingDeleteAuthenticatorBlock",
        I: TestingDeleteAuthenticatorBlockRequest,
        O: TestingDeleteAuthenticatorBlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - VaultNotFound (50400)
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingDeleteVault
       */
      testingDeleteVault: {
        name: "TestingDeleteVault",
        I: TestingDeleteVaultRequest,
        O: TestingDeleteVaultResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       * - OrganizationNotFound (60400)
       *
       * @generated from rpc domain.TestingService.TestingInjectPaddleWebhook
       */
      testingInjectPaddleWebhook: {
        name: "TestingInjectPaddleWebhook",
        I: TestingInjectPaddleWebhookRequest,
        O: TestingInjectPaddleWebhookResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingUpdatePaddle
       */
      testingUpdatePaddle: {
        name: "TestingUpdatePaddle",
        I: TestingUpdatePaddleRequest,
        O: TestingUpdatePaddleResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingCreateCoupon
       */
      testingCreateCoupon: {
        name: "TestingCreateCoupon",
        I: TestingCreateCouponRequest,
        O: TestingCreateCouponResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       * - OrganizationNotFound (60400)
       *
       * @generated from rpc domain.TestingService.TestingUpdateOrganization
       */
      testingUpdateOrganization: {
        name: "TestingUpdateOrganization",
        I: TestingUpdateOrganizationRequest,
        O: TestingUpdateOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - VaultNotFound (50400)
       * - InvalidVaultMessageType (50463): The message provided has invalid type
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.CreateVaultMessage
       */
      createVaultMessage: {
        name: "CreateVaultMessage",
        I: CreateVaultMessageRequest,
        O: CreateVaultMessageResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingWebauthnCreateCredential
       */
      testingWebauthnCreateCredential: {
        name: "TestingWebauthnCreateCredential",
        I: TestingWebauthnCreateCredentialRequest,
        O: TestingWebauthnCreateCredentialResponse,
        kind: MethodKind.Unary
      },
      /**
       * this endpoint can be used to manipulate vaults in a couple of ways
       * errors:
       * - VaultNotFound (50400)
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingManipulateVault
       */
      testingManipulateVault: {
        name: "TestingManipulateVault",
        I: TestingManipulateVaultRequest,
        O: TestingManipulateVaultResponse,
        kind: MethodKind.Unary
      },
      /**
       * this endpoint cancels all active streaming sync
       * no errors
       *
       * @generated from rpc domain.TestingService.TestingCancelUserStreaming
       */
      testingCancelUserStreaming: {
        name: "TestingCancelUserStreaming",
        I: TestingCancelUserStreamingRequest,
        O: TestingCancelUserStreamingResponse,
        kind: MethodKind.Unary
      },
      /**
       * this endpoint give information of how and where an email address is used
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingGetEmailState
       */
      testingGetEmailState: {
        name: "TestingGetEmailState",
        I: TestingGetEmailStateRequest,
        O: TestingGetEmailStateResponse,
        kind: MethodKind.Unary
      }
    }
  });
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function assertExhaustive(_val) {
    throw new Error("This should never happen");
  }
  const objectToString$2 = Object.prototype.toString;
  function isError$1(wat) {
    switch (objectToString$2.call(wat)) {
      case "[object Error]":
      case "[object Exception]":
      case "[object DOMException]":
        return true;
      default:
        return isInstanceOf(wat, Error);
    }
  }
  function isBuiltin(wat, className) {
    return objectToString$2.call(wat) === `[object ${className}]`;
  }
  function isErrorEvent$1(wat) {
    return isBuiltin(wat, "ErrorEvent");
  }
  function isDOMError(wat) {
    return isBuiltin(wat, "DOMError");
  }
  function isDOMException(wat) {
    return isBuiltin(wat, "DOMException");
  }
  function isString$6(wat) {
    return isBuiltin(wat, "String");
  }
  function isParameterizedString(wat) {
    return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
  }
  function isPrimitive$2(wat) {
    return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
  }
  function isPlainObject$1(wat) {
    return isBuiltin(wat, "Object");
  }
  function isEvent(wat) {
    return typeof Event !== "undefined" && isInstanceOf(wat, Event);
  }
  function isElement$1(wat) {
    return typeof Element !== "undefined" && isInstanceOf(wat, Element);
  }
  function isRegExp$1(wat) {
    return isBuiltin(wat, "RegExp");
  }
  function isThenable(wat) {
    return Boolean(wat && wat.then && typeof wat.then === "function");
  }
  function isSyntheticEvent(wat) {
    return isPlainObject$1(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
  }
  function isNaN$1(wat) {
    return typeof wat === "number" && wat !== wat;
  }
  function isInstanceOf(wat, base2) {
    try {
      return wat instanceof base2;
    } catch (_e) {
      return false;
    }
  }
  function isVueViewModel(wat) {
    return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
  }
  function truncate(str, max2 = 0) {
    if (typeof str !== "string" || max2 === 0) {
      return str;
    }
    return str.length <= max2 ? str : `${str.slice(0, max2)}...`;
  }
  function safeJoin(input, delimiter2) {
    if (!Array.isArray(input)) {
      return "";
    }
    const output = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const value = input[i2];
      try {
        if (isVueViewModel(value)) {
          output.push("[VueViewModel]");
        } else {
          output.push(String(value));
        }
      } catch (e2) {
        output.push("[value cannot be serialized]");
      }
    }
    return output.join(delimiter2);
  }
  function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
    if (!isString$6(value)) {
      return false;
    }
    if (isRegExp$1(pattern)) {
      return pattern.test(value);
    }
    if (isString$6(pattern)) {
      return requireExactStringMatch ? value === pattern : value.includes(pattern);
    }
    return false;
  }
  function stringMatchesSomePattern(testString, patterns2 = [], requireExactStringMatch = false) {
    return patterns2.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
  }
  function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key, limit, event, hint) {
    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
      return;
    }
    const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
    if (originalException) {
      event.exception.values = truncateAggregateExceptions(
        aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          hint.originalException,
          key,
          event.exception.values,
          originalException,
          0
        ),
        maxValueLimit
      );
    }
  }
  function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error2, key, prevExceptions, exception, exceptionId) {
    if (prevExceptions.length >= limit + 1) {
      return prevExceptions;
    }
    let newExceptions = [...prevExceptions];
    if (isInstanceOf(error2[key], Error)) {
      applyExceptionGroupFieldsForParentException(exception, exceptionId);
      const newException = exceptionFromErrorImplementation(parser, error2[key]);
      const newExceptionId = newExceptions.length;
      applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
      newExceptions = aggregateExceptionsFromError(
        exceptionFromErrorImplementation,
        parser,
        limit,
        error2[key],
        key,
        [newException, ...newExceptions],
        newException,
        newExceptionId
      );
    }
    if (Array.isArray(error2.errors)) {
      error2.errors.forEach((childError, i2) => {
        if (isInstanceOf(childError, Error)) {
          applyExceptionGroupFieldsForParentException(exception, exceptionId);
          const newException = exceptionFromErrorImplementation(parser, childError);
          const newExceptionId = newExceptions.length;
          applyExceptionGroupFieldsForChildException(newException, `errors[${i2}]`, newExceptionId, exceptionId);
          newExceptions = aggregateExceptionsFromError(
            exceptionFromErrorImplementation,
            parser,
            limit,
            childError,
            key,
            [newException, ...newExceptions],
            newException,
            newExceptionId
          );
        }
      });
    }
    return newExceptions;
  }
  function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
    exception.mechanism = exception.mechanism || { type: "generic", handled: true };
    exception.mechanism = {
      ...exception.mechanism,
      ...exception.type === "AggregateError" && { is_exception_group: true },
      exception_id: exceptionId
    };
  }
  function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
    exception.mechanism = exception.mechanism || { type: "generic", handled: true };
    exception.mechanism = {
      ...exception.mechanism,
      type: "chained",
      source,
      exception_id: exceptionId,
      parent_id: parentId
    };
  }
  function truncateAggregateExceptions(exceptions, maxValueLength) {
    return exceptions.map((exception) => {
      if (exception.value) {
        exception.value = truncate(exception.value, maxValueLength);
      }
      return exception;
    });
  }
  function isGlobalObj(obj) {
    return obj && obj.Math == Math ? obj : void 0;
  }
  const GLOBAL_OBJ = typeof globalThis == "object" && isGlobalObj(globalThis) || // eslint-disable-next-line no-restricted-globals
  typeof window == "object" && isGlobalObj(window) || typeof self == "object" && isGlobalObj(self) || typeof global == "object" && isGlobalObj(global) || function() {
    return this;
  }() || {};
  function getGlobalObject() {
    return GLOBAL_OBJ;
  }
  function getGlobalSingleton(name, creator, obj) {
    const gbl = obj || GLOBAL_OBJ;
    const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
    const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton;
  }
  const WINDOW$6 = getGlobalObject();
  const DEFAULT_MAX_STRING_LENGTH = 80;
  function htmlTreeAsString(elem, options = {}) {
    if (!elem) {
      return "<unknown>";
    }
    try {
      let currentElem = elem;
      const MAX_TRAVERSE_HEIGHT = 5;
      const out = [];
      let height = 0;
      let len = 0;
      const separator = " > ";
      const sepLength = separator.length;
      let nextStr;
      const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
      const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
      while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
        nextStr = _htmlElementAsString(currentElem, keyAttrs);
        if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
          break;
        }
        out.push(nextStr);
        len += nextStr.length;
        currentElem = currentElem.parentNode;
      }
      return out.reverse().join(separator);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function _htmlElementAsString(el2, keyAttrs) {
    const elem = el2;
    const out = [];
    let className;
    let classes;
    let key;
    let attr2;
    let i2;
    if (!elem || !elem.tagName) {
      return "";
    }
    if (WINDOW$6.HTMLElement) {
      if (elem instanceof HTMLElement && elem.dataset && elem.dataset["sentryComponent"]) {
        return elem.dataset["sentryComponent"];
      }
    }
    out.push(elem.tagName.toLowerCase());
    const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
    if (keyAttrPairs && keyAttrPairs.length) {
      keyAttrPairs.forEach((keyAttrPair) => {
        out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
      });
    } else {
      if (elem.id) {
        out.push(`#${elem.id}`);
      }
      className = elem.className;
      if (className && isString$6(className)) {
        classes = className.split(/\s+/);
        for (i2 = 0; i2 < classes.length; i2++) {
          out.push(`.${classes[i2]}`);
        }
      }
    }
    const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
    for (i2 = 0; i2 < allowedAttrs.length; i2++) {
      key = allowedAttrs[i2];
      attr2 = elem.getAttribute(key);
      if (attr2) {
        out.push(`[${key}="${attr2}"]`);
      }
    }
    return out.join("");
  }
  function getLocationHref() {
    try {
      return WINDOW$6.document.location.href;
    } catch (oO) {
      return "";
    }
  }
  function getComponentName(elem) {
    if (!WINDOW$6.HTMLElement) {
      return null;
    }
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    for (let i2 = 0; i2 < MAX_TRAVERSE_HEIGHT; i2++) {
      if (!currentElem) {
        return null;
      }
      if (currentElem instanceof HTMLElement && currentElem.dataset["sentryComponent"]) {
        return currentElem.dataset["sentryComponent"];
      }
      currentElem = currentElem.parentNode;
    }
    return null;
  }
  const DEBUG_BUILD$2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  const PREFIX = "Sentry Logger ";
  const CONSOLE_LEVELS = [
    "debug",
    "info",
    "warn",
    "error",
    "log",
    "assert",
    "trace"
  ];
  const originalConsoleMethods = {};
  function consoleSandbox(callback) {
    if (!("console" in GLOBAL_OBJ)) {
      return callback();
    }
    const console2 = GLOBAL_OBJ.console;
    const wrappedFuncs = {};
    const wrappedLevels = Object.keys(originalConsoleMethods);
    wrappedLevels.forEach((level) => {
      const originalConsoleMethod = originalConsoleMethods[level];
      wrappedFuncs[level] = console2[level];
      console2[level] = originalConsoleMethod;
    });
    try {
      return callback();
    } finally {
      wrappedLevels.forEach((level) => {
        console2[level] = wrappedFuncs[level];
      });
    }
  }
  function makeLogger() {
    let enabled = false;
    const logger2 = {
      enable: () => {
        enabled = true;
      },
      disable: () => {
        enabled = false;
      },
      isEnabled: () => enabled
    };
    if (DEBUG_BUILD$2) {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = (...args) => {
          if (enabled) {
            consoleSandbox(() => {
              GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
            });
          }
        };
      });
    } else {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = () => void 0;
      });
    }
    return logger2;
  }
  const logger = makeLogger();
  const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
  function isValidProtocol(protocol) {
    return protocol === "http" || protocol === "https";
  }
  function dsnToString(dsn, withPassword = false) {
    const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
    return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path ? `${path}/` : path}${projectId}`;
  }
  function dsnFromString(str) {
    const match2 = DSN_REGEX.exec(str);
    if (!match2) {
      consoleSandbox(() => {
        console.error(`Invalid Sentry Dsn: ${str}`);
      });
      return void 0;
    }
    const [protocol, publicKey, pass = "", host, port = "", lastPath] = match2.slice(1);
    let path = "";
    let projectId = lastPath;
    const split = projectId.split("/");
    if (split.length > 1) {
      path = split.slice(0, -1).join("/");
      projectId = split.pop();
    }
    if (projectId) {
      const projectMatch = projectId.match(/^\d+/);
      if (projectMatch) {
        projectId = projectMatch[0];
      }
    }
    return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
  }
  function dsnFromComponents(components) {
    return {
      protocol: components.protocol,
      publicKey: components.publicKey || "",
      pass: components.pass || "",
      host: components.host,
      port: components.port || "",
      path: components.path || "",
      projectId: components.projectId
    };
  }
  function validateDsn(dsn) {
    if (!DEBUG_BUILD$2) {
      return true;
    }
    const { port, projectId, protocol } = dsn;
    const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
    const hasMissingRequiredComponent = requiredComponents.find((component) => {
      if (!dsn[component]) {
        logger.error(`Invalid Sentry Dsn: ${component} missing`);
        return true;
      }
      return false;
    });
    if (hasMissingRequiredComponent) {
      return false;
    }
    if (!projectId.match(/^\d+$/)) {
      logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
      return false;
    }
    if (!isValidProtocol(protocol)) {
      logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
      return false;
    }
    if (port && isNaN(parseInt(port, 10))) {
      logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
      return false;
    }
    return true;
  }
  function makeDsn(from) {
    const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
    if (!components || !validateDsn(components)) {
      return void 0;
    }
    return components;
  }
  class SentryError extends Error {
    /** Display name of this error instance. */
    constructor(message, logLevel = "warn") {
      super(message);
      this.message = message;
      this.name = new.target.prototype.constructor.name;
      Object.setPrototypeOf(this, new.target.prototype);
      this.logLevel = logLevel;
    }
  }
  function fill(source, name, replacementFactory) {
    if (!(name in source)) {
      return;
    }
    const original = source[name];
    const wrapped = replacementFactory(original);
    if (typeof wrapped === "function") {
      markFunctionWrapped(wrapped, original);
    }
    source[name] = wrapped;
  }
  function addNonEnumerableProperty(obj, name, value) {
    try {
      Object.defineProperty(obj, name, {
        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
        value,
        writable: true,
        configurable: true
      });
    } catch (o_O) {
      DEBUG_BUILD$2 && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
    }
  }
  function markFunctionWrapped(wrapped, original) {
    try {
      const proto2 = original.prototype || {};
      wrapped.prototype = original.prototype = proto2;
      addNonEnumerableProperty(wrapped, "__sentry_original__", original);
    } catch (o_O) {
    }
  }
  function getOriginalFunction(func) {
    return func.__sentry_original__;
  }
  function urlEncode(object) {
    return Object.keys(object).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join("&");
  }
  function convertToPlainObject(value) {
    if (isError$1(value)) {
      return {
        message: value.message,
        name: value.name,
        stack: value.stack,
        ...getOwnProperties(value)
      };
    } else if (isEvent(value)) {
      const newObj = {
        type: value.type,
        target: serializeEventTarget(value.target),
        currentTarget: serializeEventTarget(value.currentTarget),
        ...getOwnProperties(value)
      };
      if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
        newObj.detail = value.detail;
      }
      return newObj;
    } else {
      return value;
    }
  }
  function serializeEventTarget(target) {
    try {
      return isElement$1(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function getOwnProperties(obj) {
    if (typeof obj === "object" && obj !== null) {
      const extractedProps = {};
      for (const property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
          extractedProps[property] = obj[property];
        }
      }
      return extractedProps;
    } else {
      return {};
    }
  }
  function extractExceptionKeysForMessage(exception, maxLength = 40) {
    const keys2 = Object.keys(convertToPlainObject(exception));
    keys2.sort();
    if (!keys2.length) {
      return "[object has no keys]";
    }
    if (keys2[0].length >= maxLength) {
      return truncate(keys2[0], maxLength);
    }
    for (let includedKeys = keys2.length; includedKeys > 0; includedKeys--) {
      const serialized = keys2.slice(0, includedKeys).join(", ");
      if (serialized.length > maxLength) {
        continue;
      }
      if (includedKeys === keys2.length) {
        return serialized;
      }
      return truncate(serialized, maxLength);
    }
    return "";
  }
  function dropUndefinedKeys(inputValue) {
    const memoizationMap = /* @__PURE__ */ new Map();
    return _dropUndefinedKeys(inputValue, memoizationMap);
  }
  function _dropUndefinedKeys(inputValue, memoizationMap) {
    if (isPojo(inputValue)) {
      const memoVal = memoizationMap.get(inputValue);
      if (memoVal !== void 0) {
        return memoVal;
      }
      const returnValue = {};
      memoizationMap.set(inputValue, returnValue);
      for (const key of Object.keys(inputValue)) {
        if (typeof inputValue[key] !== "undefined") {
          returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
        }
      }
      return returnValue;
    }
    if (Array.isArray(inputValue)) {
      const memoVal = memoizationMap.get(inputValue);
      if (memoVal !== void 0) {
        return memoVal;
      }
      const returnValue = [];
      memoizationMap.set(inputValue, returnValue);
      inputValue.forEach((item) => {
        returnValue.push(_dropUndefinedKeys(item, memoizationMap));
      });
      return returnValue;
    }
    return inputValue;
  }
  function isPojo(input) {
    if (!isPlainObject$1(input)) {
      return false;
    }
    try {
      const name = Object.getPrototypeOf(input).constructor.name;
      return !name || name === "Object";
    } catch (e2) {
      return true;
    }
  }
  const STACKTRACE_FRAME_LIMIT = 50;
  const WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
  const STRIP_FRAME_REGEXP = /captureMessage|captureException/;
  function createStackParser(...parsers) {
    const sortedParsers = parsers.sort((a, b2) => a[0] - b2[0]).map((p2) => p2[1]);
    return (stack, skipFirst = 0) => {
      const frames = [];
      const lines = stack.split("\n");
      for (let i2 = skipFirst; i2 < lines.length; i2++) {
        const line = lines[i2];
        if (line.length > 1024) {
          continue;
        }
        const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
        if (cleanedLine.match(/\S*Error: /)) {
          continue;
        }
        for (const parser of sortedParsers) {
          const frame = parser(cleanedLine);
          if (frame) {
            frames.push(frame);
            break;
          }
        }
        if (frames.length >= STACKTRACE_FRAME_LIMIT) {
          break;
        }
      }
      return stripSentryFramesAndReverse(frames);
    };
  }
  function stackParserFromStackParserOptions(stackParser) {
    if (Array.isArray(stackParser)) {
      return createStackParser(...stackParser);
    }
    return stackParser;
  }
  function stripSentryFramesAndReverse(stack) {
    if (!stack.length) {
      return [];
    }
    const localStack = Array.from(stack);
    if (/sentryWrapped/.test(localStack[localStack.length - 1].function || "")) {
      localStack.pop();
    }
    localStack.reverse();
    if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
      localStack.pop();
      if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
        localStack.pop();
      }
    }
    return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
      ...frame,
      filename: frame.filename || localStack[localStack.length - 1].filename,
      function: frame.function || "?"
    }));
  }
  const defaultFunctionName = "<anonymous>";
  function getFunctionName(fn) {
    try {
      if (!fn || typeof fn !== "function") {
        return defaultFunctionName;
      }
      return fn.name || defaultFunctionName;
    } catch (e2) {
      return defaultFunctionName;
    }
  }
  const handlers = {};
  const instrumented = {};
  function addHandler(type, handler) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(handler);
  }
  function maybeInstrument(type, instrumentFn) {
    if (!instrumented[type]) {
      instrumentFn();
      instrumented[type] = true;
    }
  }
  function triggerHandlers(type, data) {
    const typeHandlers = type && handlers[type];
    if (!typeHandlers) {
      return;
    }
    for (const handler of typeHandlers) {
      try {
        handler(data);
      } catch (e2) {
        DEBUG_BUILD$2 && logger.error(
          `Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`,
          e2
        );
      }
    }
  }
  function addConsoleInstrumentationHandler(handler) {
    const type = "console";
    addHandler(type, handler);
    maybeInstrument(type, instrumentConsole);
  }
  function instrumentConsole() {
    if (!("console" in GLOBAL_OBJ)) {
      return;
    }
    CONSOLE_LEVELS.forEach(function(level) {
      if (!(level in GLOBAL_OBJ.console)) {
        return;
      }
      fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
        originalConsoleMethods[level] = originalConsoleMethod;
        return function(...args) {
          const handlerData = { args, level };
          triggerHandlers("console", handlerData);
          const log = originalConsoleMethods[level];
          log && log.apply(GLOBAL_OBJ.console, args);
        };
      });
    });
  }
  function uuid4() {
    const gbl = GLOBAL_OBJ;
    const crypto2 = gbl.crypto || gbl.msCrypto;
    let getRandomByte = () => Math.random() * 16;
    try {
      if (crypto2 && crypto2.randomUUID) {
        return crypto2.randomUUID().replace(/-/g, "");
      }
      if (crypto2 && crypto2.getRandomValues) {
        getRandomByte = () => {
          const typedArray = new Uint8Array(1);
          crypto2.getRandomValues(typedArray);
          return typedArray[0];
        };
      }
    } catch (_2) {
    }
    return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(
      /[018]/g,
      (c2) => (
        // eslint-disable-next-line no-bitwise
        (c2 ^ (getRandomByte() & 15) >> c2 / 4).toString(16)
      )
    );
  }
  function getFirstException(event) {
    return event.exception && event.exception.values ? event.exception.values[0] : void 0;
  }
  function getEventDescription(event) {
    const { message, event_id: eventId } = event;
    if (message) {
      return message;
    }
    const firstException = getFirstException(event);
    if (firstException) {
      if (firstException.type && firstException.value) {
        return `${firstException.type}: ${firstException.value}`;
      }
      return firstException.type || firstException.value || eventId || "<unknown>";
    }
    return eventId || "<unknown>";
  }
  function addExceptionTypeValue(event, value, type) {
    const exception = event.exception = event.exception || {};
    const values2 = exception.values = exception.values || [];
    const firstException = values2[0] = values2[0] || {};
    if (!firstException.value) {
      firstException.value = value || "";
    }
    if (!firstException.type) {
      firstException.type = type || "Error";
    }
  }
  function addExceptionMechanism(event, newMechanism) {
    const firstException = getFirstException(event);
    if (!firstException) {
      return;
    }
    const defaultMechanism = { type: "generic", handled: true };
    const currentMechanism = firstException.mechanism;
    firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
    if (newMechanism && "data" in newMechanism) {
      const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
      firstException.mechanism.data = mergedData;
    }
  }
  function checkOrSetAlreadyCaught(exception) {
    if (exception && exception.__sentry_captured__) {
      return true;
    }
    try {
      addNonEnumerableProperty(exception, "__sentry_captured__", true);
    } catch (err) {
    }
    return false;
  }
  function arrayify(maybeArray) {
    return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
  }
  const WINDOW$5 = GLOBAL_OBJ;
  const DEBOUNCE_DURATION = 1e3;
  let debounceTimerID;
  let lastCapturedEventType;
  let lastCapturedEventTargetId;
  function addClickKeypressInstrumentationHandler(handler) {
    const type = "dom";
    addHandler(type, handler);
    maybeInstrument(type, instrumentDOM);
  }
  function instrumentDOM() {
    if (!WINDOW$5.document) {
      return;
    }
    const triggerDOMHandler = triggerHandlers.bind(null, "dom");
    const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    WINDOW$5.document.addEventListener("click", globalDOMEventHandler, false);
    WINDOW$5.document.addEventListener("keypress", globalDOMEventHandler, false);
    ["EventTarget", "Node"].forEach((target) => {
      const proto2 = WINDOW$5[target] && WINDOW$5[target].prototype;
      if (!proto2 || !proto2.hasOwnProperty || !proto2.hasOwnProperty("addEventListener")) {
        return;
      }
      fill(proto2, "addEventListener", function(originalAddEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              const el2 = this;
              const handlers2 = el2.__sentry_instrumentation_handlers__ = el2.__sentry_instrumentation_handlers__ || {};
              const handlerForType = handlers2[type] = handlers2[type] || { refCount: 0 };
              if (!handlerForType.handler) {
                const handler = makeDOMEventHandler(triggerDOMHandler);
                handlerForType.handler = handler;
                originalAddEventListener.call(this, type, handler, options);
              }
              handlerForType.refCount++;
            } catch (e2) {
            }
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
      });
      fill(
        proto2,
        "removeEventListener",
        function(originalRemoveEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                const el2 = this;
                const handlers2 = el2.__sentry_instrumentation_handlers__ || {};
                const handlerForType = handlers2[type];
                if (handlerForType) {
                  handlerForType.refCount--;
                  if (handlerForType.refCount <= 0) {
                    originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                    handlerForType.handler = void 0;
                    delete handlers2[type];
                  }
                  if (Object.keys(handlers2).length === 0) {
                    delete el2.__sentry_instrumentation_handlers__;
                  }
                }
              } catch (e2) {
              }
            }
            return originalRemoveEventListener.call(this, type, listener, options);
          };
        }
      );
    });
  }
  function isSimilarToLastCapturedEvent(event) {
    if (event.type !== lastCapturedEventType) {
      return false;
    }
    try {
      if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {
        return false;
      }
    } catch (e2) {
    }
    return true;
  }
  function shouldSkipDOMEvent(eventType, target) {
    if (eventType !== "keypress") {
      return false;
    }
    if (!target || !target.tagName) {
      return true;
    }
    if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
      return false;
    }
    return true;
  }
  function makeDOMEventHandler(handler, globalListener = false) {
    return (event) => {
      if (!event || event["_sentryCaptured"]) {
        return;
      }
      const target = getEventTarget(event);
      if (shouldSkipDOMEvent(event.type, target)) {
        return;
      }
      addNonEnumerableProperty(event, "_sentryCaptured", true);
      if (target && !target._sentryId) {
        addNonEnumerableProperty(target, "_sentryId", uuid4());
      }
      const name = event.type === "keypress" ? "input" : event.type;
      if (!isSimilarToLastCapturedEvent(event)) {
        const handlerData = { event, name, global: globalListener };
        handler(handlerData);
        lastCapturedEventType = event.type;
        lastCapturedEventTargetId = target ? target._sentryId : void 0;
      }
      clearTimeout(debounceTimerID);
      debounceTimerID = WINDOW$5.setTimeout(() => {
        lastCapturedEventTargetId = void 0;
        lastCapturedEventType = void 0;
      }, DEBOUNCE_DURATION);
    };
  }
  function getEventTarget(event) {
    try {
      return event.target;
    } catch (e2) {
      return null;
    }
  }
  const WINDOW$4 = getGlobalObject();
  function supportsFetch() {
    if (!("fetch" in WINDOW$4)) {
      return false;
    }
    try {
      new Headers();
      new Request("http://www.example.com");
      new Response();
      return true;
    } catch (e2) {
      return false;
    }
  }
  function isNativeFetch(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
  }
  function supportsNativeFetch() {
    if (typeof EdgeRuntime === "string") {
      return true;
    }
    if (!supportsFetch()) {
      return false;
    }
    if (isNativeFetch(WINDOW$4.fetch)) {
      return true;
    }
    let result2 = false;
    const doc = WINDOW$4.document;
    if (doc && typeof doc.createElement === "function") {
      try {
        const sandbox = doc.createElement("iframe");
        sandbox.hidden = true;
        doc.head.appendChild(sandbox);
        if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
          result2 = isNativeFetch(sandbox.contentWindow.fetch);
        }
        doc.head.removeChild(sandbox);
      } catch (err) {
        DEBUG_BUILD$2 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
      }
    }
    return result2;
  }
  function addFetchInstrumentationHandler(handler) {
    const type = "fetch";
    addHandler(type, handler);
    maybeInstrument(type, instrumentFetch);
  }
  function instrumentFetch() {
    if (!supportsNativeFetch()) {
      return;
    }
    fill(GLOBAL_OBJ, "fetch", function(originalFetch) {
      return function(...args) {
        const { method, url } = parseFetchArgs(args);
        const handlerData = {
          args,
          fetchData: {
            method,
            url
          },
          startTimestamp: Date.now()
        };
        triggerHandlers("fetch", {
          ...handlerData
        });
        return originalFetch.apply(GLOBAL_OBJ, args).then(
          (response) => {
            const finishedHandlerData = {
              ...handlerData,
              endTimestamp: Date.now(),
              response
            };
            triggerHandlers("fetch", finishedHandlerData);
            return response;
          },
          (error2) => {
            const erroredHandlerData = {
              ...handlerData,
              endTimestamp: Date.now(),
              error: error2
            };
            triggerHandlers("fetch", erroredHandlerData);
            throw error2;
          }
        );
      };
    });
  }
  function hasProp$1(obj, prop) {
    return !!obj && typeof obj === "object" && !!obj[prop];
  }
  function getUrlFromResource(resource) {
    if (typeof resource === "string") {
      return resource;
    }
    if (!resource) {
      return "";
    }
    if (hasProp$1(resource, "url")) {
      return resource.url;
    }
    if (resource.toString) {
      return resource.toString();
    }
    return "";
  }
  function parseFetchArgs(fetchArgs) {
    if (fetchArgs.length === 0) {
      return { method: "GET", url: "" };
    }
    if (fetchArgs.length === 2) {
      const [url, options] = fetchArgs;
      return {
        url: getUrlFromResource(url),
        method: hasProp$1(options, "method") ? String(options.method).toUpperCase() : "GET"
      };
    }
    const arg = fetchArgs[0];
    return {
      url: getUrlFromResource(arg),
      method: hasProp$1(arg, "method") ? String(arg.method).toUpperCase() : "GET"
    };
  }
  let _oldOnErrorHandler = null;
  function addGlobalErrorInstrumentationHandler(handler) {
    const type = "error";
    addHandler(type, handler);
    maybeInstrument(type, instrumentError);
  }
  function instrumentError() {
    _oldOnErrorHandler = GLOBAL_OBJ.onerror;
    GLOBAL_OBJ.onerror = function(msg, url, line, column, error2) {
      const handlerData = {
        column,
        error: error2,
        line,
        msg,
        url
      };
      triggerHandlers("error", handlerData);
      if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {
        return _oldOnErrorHandler.apply(this, arguments);
      }
      return false;
    };
    GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
  }
  let _oldOnUnhandledRejectionHandler = null;
  function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
    const type = "unhandledrejection";
    addHandler(type, handler);
    maybeInstrument(type, instrumentUnhandledRejection);
  }
  function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
    GLOBAL_OBJ.onunhandledrejection = function(e2) {
      const handlerData = e2;
      triggerHandlers("unhandledrejection", handlerData);
      if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {
        return _oldOnUnhandledRejectionHandler.apply(this, arguments);
      }
      return true;
    };
    GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
  }
  const WINDOW$3 = getGlobalObject();
  function supportsHistory() {
    const chromeVar = WINDOW$3.chrome;
    const isChromePackagedApp = chromeVar && chromeVar.app && chromeVar.app.runtime;
    const hasHistoryApi = "history" in WINDOW$3 && !!WINDOW$3.history.pushState && !!WINDOW$3.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
  }
  const WINDOW$2 = GLOBAL_OBJ;
  let lastHref;
  function addHistoryInstrumentationHandler(handler) {
    const type = "history";
    addHandler(type, handler);
    maybeInstrument(type, instrumentHistory);
  }
  function instrumentHistory() {
    if (!supportsHistory()) {
      return;
    }
    const oldOnPopState = WINDOW$2.onpopstate;
    WINDOW$2.onpopstate = function(...args) {
      const to2 = WINDOW$2.location.href;
      const from = lastHref;
      lastHref = to2;
      const handlerData = { from, to: to2 };
      triggerHandlers("history", handlerData);
      if (oldOnPopState) {
        try {
          return oldOnPopState.apply(this, args);
        } catch (_oO) {
        }
      }
    };
    function historyReplacementFunction(originalHistoryFunction) {
      return function(...args) {
        const url = args.length > 2 ? args[2] : void 0;
        if (url) {
          const from = lastHref;
          const to2 = String(url);
          lastHref = to2;
          const handlerData = { from, to: to2 };
          triggerHandlers("history", handlerData);
        }
        return originalHistoryFunction.apply(this, args);
      };
    }
    fill(WINDOW$2.history, "pushState", historyReplacementFunction);
    fill(WINDOW$2.history, "replaceState", historyReplacementFunction);
  }
  const WINDOW$1 = GLOBAL_OBJ;
  const SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
  function addXhrInstrumentationHandler(handler) {
    const type = "xhr";
    addHandler(type, handler);
    maybeInstrument(type, instrumentXHR);
  }
  function instrumentXHR() {
    if (!WINDOW$1.XMLHttpRequest) {
      return;
    }
    const xhrproto = XMLHttpRequest.prototype;
    fill(xhrproto, "open", function(originalOpen) {
      return function(...args) {
        const startTimestamp = Date.now();
        const method = isString$6(args[0]) ? args[0].toUpperCase() : void 0;
        const url = parseUrl$1(args[1]);
        if (!method || !url) {
          return originalOpen.apply(this, args);
        }
        this[SENTRY_XHR_DATA_KEY] = {
          method,
          url,
          request_headers: {}
        };
        if (method === "POST" && url.match(/sentry_key/)) {
          this.__sentry_own_request__ = true;
        }
        const onreadystatechangeHandler = () => {
          const xhrInfo = this[SENTRY_XHR_DATA_KEY];
          if (!xhrInfo) {
            return;
          }
          if (this.readyState === 4) {
            try {
              xhrInfo.status_code = this.status;
            } catch (e2) {
            }
            const handlerData = {
              args: [method, url],
              endTimestamp: Date.now(),
              startTimestamp,
              xhr: this
            };
            triggerHandlers("xhr", handlerData);
          }
        };
        if ("onreadystatechange" in this && typeof this.onreadystatechange === "function") {
          fill(this, "onreadystatechange", function(original) {
            return function(...readyStateArgs) {
              onreadystatechangeHandler();
              return original.apply(this, readyStateArgs);
            };
          });
        } else {
          this.addEventListener("readystatechange", onreadystatechangeHandler);
        }
        fill(this, "setRequestHeader", function(original) {
          return function(...setRequestHeaderArgs) {
            const [header, value] = setRequestHeaderArgs;
            const xhrInfo = this[SENTRY_XHR_DATA_KEY];
            if (xhrInfo && isString$6(header) && isString$6(value)) {
              xhrInfo.request_headers[header.toLowerCase()] = value;
            }
            return original.apply(this, setRequestHeaderArgs);
          };
        });
        return originalOpen.apply(this, args);
      };
    });
    fill(xhrproto, "send", function(originalSend) {
      return function(...args) {
        const sentryXhrData = this[SENTRY_XHR_DATA_KEY];
        if (!sentryXhrData) {
          return originalSend.apply(this, args);
        }
        if (args[0] !== void 0) {
          sentryXhrData.body = args[0];
        }
        const handlerData = {
          args: [sentryXhrData.method, sentryXhrData.url],
          startTimestamp: Date.now(),
          xhr: this
        };
        triggerHandlers("xhr", handlerData);
        return originalSend.apply(this, args);
      };
    });
  }
  function parseUrl$1(url) {
    if (isString$6(url)) {
      return url;
    }
    try {
      return url.toString();
    } catch (e2) {
    }
    return void 0;
  }
  function getSDKSource() {
    return "npm";
  }
  function memoBuilder() {
    const hasWeakSet2 = typeof WeakSet === "function";
    const inner = hasWeakSet2 ? /* @__PURE__ */ new WeakSet() : [];
    function memoize2(obj) {
      if (hasWeakSet2) {
        if (inner.has(obj)) {
          return true;
        }
        inner.add(obj);
        return false;
      }
      for (let i2 = 0; i2 < inner.length; i2++) {
        const value = inner[i2];
        if (value === obj) {
          return true;
        }
      }
      inner.push(obj);
      return false;
    }
    function unmemoize(obj) {
      if (hasWeakSet2) {
        inner.delete(obj);
      } else {
        for (let i2 = 0; i2 < inner.length; i2++) {
          if (inner[i2] === obj) {
            inner.splice(i2, 1);
            break;
          }
        }
      }
    }
    return [memoize2, unmemoize];
  }
  function normalize(input, depth = 100, maxProperties = Infinity) {
    try {
      return visit("", input, depth, maxProperties);
    } catch (err) {
      return { ERROR: `**non-serializable** (${err})` };
    }
  }
  function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
    const normalized = normalize(object, depth);
    if (jsonSize(normalized) > maxSize) {
      return normalizeToSize(object, depth - 1, maxSize);
    }
    return normalized;
  }
  function visit(key, value, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {
    const [memoize2, unmemoize] = memo;
    if (value == null || // this matches null and undefined -> eqeq not eqeqeq
    ["number", "boolean", "string"].includes(typeof value) && !isNaN$1(value)) {
      return value;
    }
    const stringified = stringifyValue(key, value);
    if (!stringified.startsWith("[object ")) {
      return stringified;
    }
    if (value["__sentry_skip_normalization__"]) {
      return value;
    }
    const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
    if (remainingDepth === 0) {
      return stringified.replace("object ", "");
    }
    if (memoize2(value)) {
      return "[Circular ~]";
    }
    const valueWithToJSON = value;
    if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
      try {
        const jsonValue = valueWithToJSON.toJSON();
        return visit("", jsonValue, remainingDepth - 1, maxProperties, memo);
      } catch (err) {
      }
    }
    const normalized = Array.isArray(value) ? [] : {};
    let numAdded = 0;
    const visitable = convertToPlainObject(value);
    for (const visitKey in visitable) {
      if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
        continue;
      }
      if (numAdded >= maxProperties) {
        normalized[visitKey] = "[MaxProperties ~]";
        break;
      }
      const visitValue = visitable[visitKey];
      normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);
      numAdded++;
    }
    unmemoize(value);
    return normalized;
  }
  function stringifyValue(key, value) {
    try {
      if (key === "domain" && value && typeof value === "object" && value._events) {
        return "[Domain]";
      }
      if (key === "domainEmitter") {
        return "[DomainEmitter]";
      }
      if (typeof global !== "undefined" && value === global) {
        return "[Global]";
      }
      if (typeof window !== "undefined" && value === window) {
        return "[Window]";
      }
      if (typeof document !== "undefined" && value === document) {
        return "[Document]";
      }
      if (isVueViewModel(value)) {
        return "[VueViewModel]";
      }
      if (isSyntheticEvent(value)) {
        return "[SyntheticEvent]";
      }
      if (typeof value === "number" && value !== value) {
        return "[NaN]";
      }
      if (typeof value === "function") {
        return `[Function: ${getFunctionName(value)}]`;
      }
      if (typeof value === "symbol") {
        return `[${String(value)}]`;
      }
      if (typeof value === "bigint") {
        return `[BigInt: ${String(value)}]`;
      }
      const objName = getConstructorName(value);
      if (/^HTML(\w*)Element$/.test(objName)) {
        return `[HTMLElement: ${objName}]`;
      }
      return `[object ${objName}]`;
    } catch (err) {
      return `**non-serializable** (${err})`;
    }
  }
  function getConstructorName(value) {
    const prototype = Object.getPrototypeOf(value);
    return prototype ? prototype.constructor.name : "null prototype";
  }
  function utf8Length(value) {
    return ~-encodeURI(value).split(/%..|./).length;
  }
  function jsonSize(value) {
    return utf8Length(JSON.stringify(value));
  }
  var States;
  (function(States2) {
    const PENDING = 0;
    States2[States2["PENDING"] = PENDING] = "PENDING";
    const RESOLVED = 1;
    States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
    const REJECTED = 2;
    States2[States2["REJECTED"] = REJECTED] = "REJECTED";
  })(States || (States = {}));
  function resolvedSyncPromise(value) {
    return new SyncPromise((resolve) => {
      resolve(value);
    });
  }
  function rejectedSyncPromise(reason) {
    return new SyncPromise((_2, reject) => {
      reject(reason);
    });
  }
  class SyncPromise {
    constructor(executor) {
      SyncPromise.prototype.__init.call(this);
      SyncPromise.prototype.__init2.call(this);
      SyncPromise.prototype.__init3.call(this);
      SyncPromise.prototype.__init4.call(this);
      this._state = States.PENDING;
      this._handlers = [];
      try {
        executor(this._resolve, this._reject);
      } catch (e2) {
        this._reject(e2);
      }
    }
    /** JSDoc */
    then(onfulfilled, onrejected) {
      return new SyncPromise((resolve, reject) => {
        this._handlers.push([
          false,
          (result2) => {
            if (!onfulfilled) {
              resolve(result2);
            } else {
              try {
                resolve(onfulfilled(result2));
              } catch (e2) {
                reject(e2);
              }
            }
          },
          (reason) => {
            if (!onrejected) {
              reject(reason);
            } else {
              try {
                resolve(onrejected(reason));
              } catch (e2) {
                reject(e2);
              }
            }
          }
        ]);
        this._executeHandlers();
      });
    }
    /** JSDoc */
    catch(onrejected) {
      return this.then((val) => val, onrejected);
    }
    /** JSDoc */
    finally(onfinally) {
      return new SyncPromise((resolve, reject) => {
        let val;
        let isRejected;
        return this.then(
          (value) => {
            isRejected = false;
            val = value;
            if (onfinally) {
              onfinally();
            }
          },
          (reason) => {
            isRejected = true;
            val = reason;
            if (onfinally) {
              onfinally();
            }
          }
        ).then(() => {
          if (isRejected) {
            reject(val);
            return;
          }
          resolve(val);
        });
      });
    }
    /** JSDoc */
    __init() {
      this._resolve = (value) => {
        this._setResult(States.RESOLVED, value);
      };
    }
    /** JSDoc */
    __init2() {
      this._reject = (reason) => {
        this._setResult(States.REJECTED, reason);
      };
    }
    /** JSDoc */
    __init3() {
      this._setResult = (state, value) => {
        if (this._state !== States.PENDING) {
          return;
        }
        if (isThenable(value)) {
          void value.then(this._resolve, this._reject);
          return;
        }
        this._state = state;
        this._value = value;
        this._executeHandlers();
      };
    }
    /** JSDoc */
    __init4() {
      this._executeHandlers = () => {
        if (this._state === States.PENDING) {
          return;
        }
        const cachedHandlers = this._handlers.slice();
        this._handlers = [];
        cachedHandlers.forEach((handler) => {
          if (handler[0]) {
            return;
          }
          if (this._state === States.RESOLVED) {
            handler[1](this._value);
          }
          if (this._state === States.REJECTED) {
            handler[2](this._value);
          }
          handler[0] = true;
        });
      };
    }
  }
  function makePromiseBuffer(limit) {
    const buffer = [];
    function isReady() {
      return limit === void 0 || buffer.length < limit;
    }
    function remove(task) {
      return buffer.splice(buffer.indexOf(task), 1)[0];
    }
    function add(taskProducer) {
      if (!isReady()) {
        return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
      }
      const task = taskProducer();
      if (buffer.indexOf(task) === -1) {
        buffer.push(task);
      }
      void task.then(() => remove(task)).then(
        null,
        () => remove(task).then(null, () => {
        })
      );
      return task;
    }
    function drain(timeout) {
      return new SyncPromise((resolve, reject) => {
        let counter = buffer.length;
        if (!counter) {
          return resolve(true);
        }
        const capturedSetTimeout = setTimeout(() => {
          if (timeout && timeout > 0) {
            resolve(false);
          }
        }, timeout);
        buffer.forEach((item) => {
          void resolvedSyncPromise(item).then(() => {
            if (!--counter) {
              clearTimeout(capturedSetTimeout);
              resolve(true);
            }
          }, reject);
        });
      });
    }
    return {
      $: buffer,
      add,
      drain
    };
  }
  function parseUrl(url) {
    if (!url) {
      return {};
    }
    const match2 = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match2) {
      return {};
    }
    const query = match2[6] || "";
    const fragment = match2[8] || "";
    return {
      host: match2[4],
      path: match2[5],
      protocol: match2[2],
      search: query,
      hash: fragment,
      relative: match2[5] + query + fragment
      // everything minus origin
    };
  }
  const validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];
  function severityLevelFromString(level) {
    return level === "warn" ? "warning" : validSeverityLevels.includes(level) ? level : "log";
  }
  const ONE_SECOND_IN_MS = 1e3;
  function dateTimestampInSeconds() {
    return Date.now() / ONE_SECOND_IN_MS;
  }
  function createUnixTimestampInSecondsFunc() {
    const { performance: performance2 } = GLOBAL_OBJ;
    if (!performance2 || !performance2.now) {
      return dateTimestampInSeconds;
    }
    const approxStartingTimeOrigin = Date.now() - performance2.now();
    const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
    return () => {
      return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
    };
  }
  const timestampInSeconds = createUnixTimestampInSecondsFunc();
  (() => {
    const { performance: performance2 } = GLOBAL_OBJ;
    if (!performance2 || !performance2.now) {
      return void 0;
    }
    const threshold = 3600 * 1e3;
    const performanceNow = performance2.now();
    const dateNow = Date.now();
    const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
    const timeOriginIsReliable = timeOriginDelta < threshold;
    const navigationStart = performance2.timing && performance2.timing.navigationStart;
    const hasNavigationStart = typeof navigationStart === "number";
    const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    const navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
      if (timeOriginDelta <= navigationStartDelta) {
        return performance2.timeOrigin;
      } else {
        return navigationStart;
      }
    }
    return dateNow;
  })();
  function createEnvelope(headers, items = []) {
    return [headers, items];
  }
  function addItemToEnvelope(envelope, newItem) {
    const [headers, items] = envelope;
    return [headers, [...items, newItem]];
  }
  function forEachEnvelopeItem(envelope, callback) {
    const envelopeItems = envelope[1];
    for (const envelopeItem of envelopeItems) {
      const envelopeItemType = envelopeItem[0].type;
      const result2 = callback(envelopeItem, envelopeItemType);
      if (result2) {
        return true;
      }
    }
    return false;
  }
  function encodeUTF8(input, textEncoder) {
    const utf8 = textEncoder || new TextEncoder();
    return utf8.encode(input);
  }
  function serializeEnvelope(envelope, textEncoder) {
    const [envHeaders, items] = envelope;
    let parts = JSON.stringify(envHeaders);
    function append(next) {
      if (typeof parts === "string") {
        parts = typeof next === "string" ? parts + next : [encodeUTF8(parts, textEncoder), next];
      } else {
        parts.push(typeof next === "string" ? encodeUTF8(next, textEncoder) : next);
      }
    }
    for (const item of items) {
      const [itemHeaders, payload] = item;
      append(`
${JSON.stringify(itemHeaders)}
`);
      if (typeof payload === "string" || payload instanceof Uint8Array) {
        append(payload);
      } else {
        let stringifiedPayload;
        try {
          stringifiedPayload = JSON.stringify(payload);
        } catch (e2) {
          stringifiedPayload = JSON.stringify(normalize(payload));
        }
        append(stringifiedPayload);
      }
    }
    return typeof parts === "string" ? parts : concatBuffers(parts);
  }
  function concatBuffers(buffers) {
    const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
    const merged = new Uint8Array(totalLength);
    let offset = 0;
    for (const buffer of buffers) {
      merged.set(buffer, offset);
      offset += buffer.length;
    }
    return merged;
  }
  function createAttachmentEnvelopeItem(attachment, textEncoder) {
    const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data, textEncoder) : attachment.data;
    return [
      dropUndefinedKeys({
        type: "attachment",
        length: buffer.length,
        filename: attachment.filename,
        content_type: attachment.contentType,
        attachment_type: attachment.attachmentType
      }),
      buffer
    ];
  }
  const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
    session: "session",
    sessions: "session",
    attachment: "attachment",
    transaction: "transaction",
    event: "error",
    client_report: "internal",
    user_report: "default",
    profile: "profile",
    replay_event: "replay",
    replay_recording: "replay",
    check_in: "monitor",
    feedback: "feedback",
    span: "span",
    statsd: "metric_bucket"
  };
  function envelopeItemTypeToDataCategory(type) {
    return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
  }
  function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
    if (!metadataOrEvent || !metadataOrEvent.sdk) {
      return;
    }
    const { name, version } = metadataOrEvent.sdk;
    return { name, version };
  }
  function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
    const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
    return {
      event_id: event.event_id,
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...sdkInfo && { sdk: sdkInfo },
      ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
      ...dynamicSamplingContext && {
        trace: dropUndefinedKeys({ ...dynamicSamplingContext })
      }
    };
  }
  function createClientReportEnvelope(discarded_events, dsn, timestamp) {
    const clientReportItem = [
      { type: "client_report" },
      {
        timestamp: timestamp || dateTimestampInSeconds(),
        discarded_events
      }
    ];
    return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
  }
  const DEFAULT_RETRY_AFTER = 60 * 1e3;
  function parseRetryAfterHeader(header, now = Date.now()) {
    const headerDelay = parseInt(`${header}`, 10);
    if (!isNaN(headerDelay)) {
      return headerDelay * 1e3;
    }
    const headerDate = Date.parse(`${header}`);
    if (!isNaN(headerDate)) {
      return headerDate - now;
    }
    return DEFAULT_RETRY_AFTER;
  }
  function disabledUntil(limits, dataCategory) {
    return limits[dataCategory] || limits.all || 0;
  }
  function isRateLimited(limits, dataCategory, now = Date.now()) {
    return disabledUntil(limits, dataCategory) > now;
  }
  function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
    const updatedRateLimits = {
      ...limits
    };
    const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
    const retryAfterHeader = headers && headers["retry-after"];
    if (rateLimitHeader) {
      for (const limit of rateLimitHeader.trim().split(",")) {
        const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
        const headerDelay = parseInt(retryAfter, 10);
        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
        if (!categories) {
          updatedRateLimits.all = now + delay;
        } else {
          for (const category of categories.split(";")) {
            if (category === "metric_bucket") {
              if (!namespaces || namespaces.split(";").includes("custom")) {
                updatedRateLimits[category] = now + delay;
              }
            } else {
              updatedRateLimits[category] = now + delay;
            }
          }
        }
      }
    } else if (retryAfterHeader) {
      updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
    } else if (statusCode === 429) {
      updatedRateLimits.all = now + 60 * 1e3;
    }
    return updatedRateLimits;
  }
  const DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  const DEFAULT_ENVIRONMENT = "production";
  function getGlobalEventProcessors() {
    return getGlobalSingleton("globalEventProcessors", () => []);
  }
  function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
  }
  function notifyEventProcessors(processors, event, hint, index2 = 0) {
    return new SyncPromise((resolve, reject) => {
      const processor = processors[index2];
      if (event === null || typeof processor !== "function") {
        resolve(event);
      } else {
        const result2 = processor({ ...event }, hint);
        DEBUG_BUILD$1 && processor.id && result2 === null && logger.log(`Event processor "${processor.id}" dropped event`);
        if (isThenable(result2)) {
          void result2.then((final) => notifyEventProcessors(processors, final, hint, index2 + 1).then(resolve)).then(null, reject);
        } else {
          void notifyEventProcessors(processors, result2, hint, index2 + 1).then(resolve).then(null, reject);
        }
      }
    });
  }
  function makeSession(context) {
    const startingTime = timestampInSeconds();
    const session = {
      sid: uuid4(),
      init: true,
      timestamp: startingTime,
      started: startingTime,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: false,
      toJSON: () => sessionToJSON(session)
    };
    if (context) {
      updateSession(session, context);
    }
    return session;
  }
  function updateSession(session, context = {}) {
    if (context.user) {
      if (!session.ipAddress && context.user.ip_address) {
        session.ipAddress = context.user.ip_address;
      }
      if (!session.did && !context.did) {
        session.did = context.user.id || context.user.email || context.user.username;
      }
    }
    session.timestamp = context.timestamp || timestampInSeconds();
    if (context.abnormal_mechanism) {
      session.abnormal_mechanism = context.abnormal_mechanism;
    }
    if (context.ignoreDuration) {
      session.ignoreDuration = context.ignoreDuration;
    }
    if (context.sid) {
      session.sid = context.sid.length === 32 ? context.sid : uuid4();
    }
    if (context.init !== void 0) {
      session.init = context.init;
    }
    if (!session.did && context.did) {
      session.did = `${context.did}`;
    }
    if (typeof context.started === "number") {
      session.started = context.started;
    }
    if (session.ignoreDuration) {
      session.duration = void 0;
    } else if (typeof context.duration === "number") {
      session.duration = context.duration;
    } else {
      const duration = session.timestamp - session.started;
      session.duration = duration >= 0 ? duration : 0;
    }
    if (context.release) {
      session.release = context.release;
    }
    if (context.environment) {
      session.environment = context.environment;
    }
    if (!session.ipAddress && context.ipAddress) {
      session.ipAddress = context.ipAddress;
    }
    if (!session.userAgent && context.userAgent) {
      session.userAgent = context.userAgent;
    }
    if (typeof context.errors === "number") {
      session.errors = context.errors;
    }
    if (context.status) {
      session.status = context.status;
    }
  }
  function closeSession(session, status) {
    let context = {};
    if (status) {
      context = { status };
    } else if (session.status === "ok") {
      context = { status: "exited" };
    }
    updateSession(session, context);
  }
  function sessionToJSON(session) {
    return dropUndefinedKeys({
      sid: `${session.sid}`,
      init: session.init,
      // Make sure that sec is converted to ms for date constructor
      started: new Date(session.started * 1e3).toISOString(),
      timestamp: new Date(session.timestamp * 1e3).toISOString(),
      status: session.status,
      errors: session.errors,
      did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
      duration: session.duration,
      abnormal_mechanism: session.abnormal_mechanism,
      attrs: {
        release: session.release,
        environment: session.environment,
        ip_address: session.ipAddress,
        user_agent: session.userAgent
      }
    });
  }
  const TRACE_FLAG_SAMPLED = 1;
  function spanToTraceContext(span) {
    const { spanId: span_id, traceId: trace_id } = span.spanContext();
    const { data, op, parent_span_id, status, tags, origin } = spanToJSON(span);
    return dropUndefinedKeys({
      data,
      op,
      parent_span_id,
      span_id,
      status,
      tags,
      trace_id,
      origin
    });
  }
  function spanToJSON(span) {
    if (spanIsSpanClass(span)) {
      return span.getSpanJSON();
    }
    if (typeof span.toJSON === "function") {
      return span.toJSON();
    }
    return {};
  }
  function spanIsSpanClass(span) {
    return typeof span.getSpanJSON === "function";
  }
  function spanIsSampled(span) {
    const { traceFlags } = span.spanContext();
    return Boolean(traceFlags & TRACE_FLAG_SAMPLED);
  }
  function prepareEvent(options, event, hint, scope, client, isolationScope) {
    const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;
    const prepared = {
      ...event,
      event_id: event.event_id || hint.event_id || uuid4(),
      timestamp: event.timestamp || dateTimestampInSeconds()
    };
    const integrations = hint.integrations || options.integrations.map((i2) => i2.name);
    applyClientOptions(prepared, options);
    applyIntegrationsMetadata(prepared, integrations);
    if (event.type === void 0) {
      applyDebugIds(prepared, options.stackParser);
    }
    const finalScope = getFinalScope(scope, hint.captureContext);
    if (hint.mechanism) {
      addExceptionMechanism(prepared, hint.mechanism);
    }
    const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];
    const data = getGlobalScope().getScopeData();
    if (isolationScope) {
      const isolationData = isolationScope.getScopeData();
      mergeScopeData(data, isolationData);
    }
    if (finalScope) {
      const finalScopeData = finalScope.getScopeData();
      mergeScopeData(data, finalScopeData);
    }
    const attachments = [...hint.attachments || [], ...data.attachments];
    if (attachments.length) {
      hint.attachments = attachments;
    }
    applyScopeDataToEvent(prepared, data);
    const eventProcessors = [
      ...clientEventProcessors,
      // eslint-disable-next-line deprecation/deprecation
      ...getGlobalEventProcessors(),
      // Run scope event processors _after_ all other processors
      ...data.eventProcessors
    ];
    const result2 = notifyEventProcessors(eventProcessors, prepared, hint);
    return result2.then((evt) => {
      if (evt) {
        applyDebugMeta(evt);
      }
      if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
        return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
      }
      return evt;
    });
  }
  function applyClientOptions(event, options) {
    const { environment, release, dist: dist2, maxValueLength = 250 } = options;
    if (!("environment" in event)) {
      event.environment = "environment" in options ? environment : DEFAULT_ENVIRONMENT;
    }
    if (event.release === void 0 && release !== void 0) {
      event.release = release;
    }
    if (event.dist === void 0 && dist2 !== void 0) {
      event.dist = dist2;
    }
    if (event.message) {
      event.message = truncate(event.message, maxValueLength);
    }
    const exception = event.exception && event.exception.values && event.exception.values[0];
    if (exception && exception.value) {
      exception.value = truncate(exception.value, maxValueLength);
    }
    const request = event.request;
    if (request && request.url) {
      request.url = truncate(request.url, maxValueLength);
    }
  }
  const debugIdStackParserCache = /* @__PURE__ */ new WeakMap();
  function applyDebugIds(event, stackParser) {
    const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
    if (!debugIdMap) {
      return;
    }
    let debugIdStackFramesCache;
    const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
    if (cachedDebugIdStackFrameCache) {
      debugIdStackFramesCache = cachedDebugIdStackFrameCache;
    } else {
      debugIdStackFramesCache = /* @__PURE__ */ new Map();
      debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);
    }
    const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {
      let parsedStack;
      const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
      if (cachedParsedStack) {
        parsedStack = cachedParsedStack;
      } else {
        parsedStack = stackParser(debugIdStackTrace);
        debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);
      }
      for (let i2 = parsedStack.length - 1; i2 >= 0; i2--) {
        const stackFrame = parsedStack[i2];
        if (stackFrame.filename) {
          acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];
          break;
        }
      }
      return acc;
    }, {});
    try {
      event.exception.values.forEach((exception) => {
        exception.stacktrace.frames.forEach((frame) => {
          if (frame.filename) {
            frame.debug_id = filenameDebugIdMap[frame.filename];
          }
        });
      });
    } catch (e2) {
    }
  }
  function applyDebugMeta(event) {
    const filenameDebugIdMap = {};
    try {
      event.exception.values.forEach((exception) => {
        exception.stacktrace.frames.forEach((frame) => {
          if (frame.debug_id) {
            if (frame.abs_path) {
              filenameDebugIdMap[frame.abs_path] = frame.debug_id;
            } else if (frame.filename) {
              filenameDebugIdMap[frame.filename] = frame.debug_id;
            }
            delete frame.debug_id;
          }
        });
      });
    } catch (e2) {
    }
    if (Object.keys(filenameDebugIdMap).length === 0) {
      return;
    }
    event.debug_meta = event.debug_meta || {};
    event.debug_meta.images = event.debug_meta.images || [];
    const images = event.debug_meta.images;
    Object.keys(filenameDebugIdMap).forEach((filename) => {
      images.push({
        type: "sourcemap",
        code_file: filename,
        debug_id: filenameDebugIdMap[filename]
      });
    });
  }
  function applyIntegrationsMetadata(event, integrationNames) {
    if (integrationNames.length > 0) {
      event.sdk = event.sdk || {};
      event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
    }
  }
  function normalizeEvent(event, depth, maxBreadth) {
    if (!event) {
      return null;
    }
    const normalized = {
      ...event,
      ...event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map((b2) => ({
          ...b2,
          ...b2.data && {
            data: normalize(b2.data, depth, maxBreadth)
          }
        }))
      },
      ...event.user && {
        user: normalize(event.user, depth, maxBreadth)
      },
      ...event.contexts && {
        contexts: normalize(event.contexts, depth, maxBreadth)
      },
      ...event.extra && {
        extra: normalize(event.extra, depth, maxBreadth)
      }
    };
    if (event.contexts && event.contexts.trace && normalized.contexts) {
      normalized.contexts.trace = event.contexts.trace;
      if (event.contexts.trace.data) {
        normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
      }
    }
    if (event.spans) {
      normalized.spans = event.spans.map((span) => {
        const data = spanToJSON(span).data;
        if (data) {
          span.data = normalize(data, depth, maxBreadth);
        }
        return span;
      });
    }
    return normalized;
  }
  function getFinalScope(scope, captureContext) {
    if (!captureContext) {
      return scope;
    }
    const finalScope = scope ? scope.clone() : new Scope();
    finalScope.update(captureContext);
    return finalScope;
  }
  function parseEventHintOrCaptureContext(hint) {
    if (!hint) {
      return void 0;
    }
    if (hintIsScopeOrFunction(hint)) {
      return { captureContext: hint };
    }
    if (hintIsScopeContext(hint)) {
      return {
        captureContext: hint
      };
    }
    return hint;
  }
  function hintIsScopeOrFunction(hint) {
    return hint instanceof Scope || typeof hint === "function";
  }
  const captureContextKeys = [
    "user",
    "level",
    "extra",
    "contexts",
    "tags",
    "fingerprint",
    "requestSession",
    "propagationContext"
  ];
  function hintIsScopeContext(hint) {
    return Object.keys(hint).some((key) => captureContextKeys.includes(key));
  }
  function captureException(exception, hint) {
    return getCurrentHub().captureException(exception, parseEventHintOrCaptureContext(hint));
  }
  function captureMessage(message, captureContext) {
    const level = typeof captureContext === "string" ? captureContext : void 0;
    const context = typeof captureContext !== "string" ? { captureContext } : void 0;
    return getCurrentHub().captureMessage(message, level, context);
  }
  function captureEvent(event, hint) {
    return getCurrentHub().captureEvent(event, hint);
  }
  function configureScope$1(callback) {
    getCurrentHub().configureScope(callback);
  }
  function addBreadcrumb(breadcrumb, hint) {
    getCurrentHub().addBreadcrumb(breadcrumb, hint);
  }
  function withScope(...rest) {
    const hub = getCurrentHub();
    if (rest.length === 2) {
      const [scope, callback] = rest;
      if (!scope) {
        return hub.withScope(callback);
      }
      return hub.withScope(() => {
        hub.getStackTop().scope = scope;
        return callback(scope);
      });
    }
    return hub.withScope(rest[0]);
  }
  function getClient() {
    return getCurrentHub().getClient();
  }
  function getCurrentScope() {
    return getCurrentHub().getScope();
  }
  function startSession(context) {
    const client = getClient();
    const isolationScope = getIsolationScope();
    const currentScope = getCurrentScope();
    const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
    const { userAgent } = GLOBAL_OBJ.navigator || {};
    const session = makeSession({
      release,
      environment,
      user: currentScope.getUser() || isolationScope.getUser(),
      ...userAgent && { userAgent },
      ...context
    });
    const currentSession = isolationScope.getSession();
    if (currentSession && currentSession.status === "ok") {
      updateSession(currentSession, { status: "exited" });
    }
    endSession();
    isolationScope.setSession(session);
    currentScope.setSession(session);
    return session;
  }
  function endSession() {
    const isolationScope = getIsolationScope();
    const currentScope = getCurrentScope();
    const session = currentScope.getSession() || isolationScope.getSession();
    if (session) {
      closeSession(session);
    }
    _sendSessionUpdate();
    isolationScope.setSession();
    currentScope.setSession();
  }
  function _sendSessionUpdate() {
    const isolationScope = getIsolationScope();
    const currentScope = getCurrentScope();
    const client = getClient();
    const session = currentScope.getSession() || isolationScope.getSession();
    if (session && client && client.captureSession) {
      client.captureSession(session);
    }
  }
  function captureSession(end = false) {
    if (end) {
      endSession();
      return;
    }
    _sendSessionUpdate();
  }
  function getRootSpan(span) {
    return span.transaction;
  }
  function getDynamicSamplingContextFromClient(trace_id, client, scope) {
    const options = client.getOptions();
    const { publicKey: public_key } = client.getDsn() || {};
    const { segment: user_segment } = scope && scope.getUser() || {};
    const dsc = dropUndefinedKeys({
      environment: options.environment || DEFAULT_ENVIRONMENT,
      release: options.release,
      user_segment,
      public_key,
      trace_id
    });
    client.emit && client.emit("createDsc", dsc);
    return dsc;
  }
  function getDynamicSamplingContextFromSpan(span) {
    const client = getClient();
    if (!client) {
      return {};
    }
    const dsc = getDynamicSamplingContextFromClient(spanToJSON(span).trace_id || "", client, getCurrentScope());
    const txn = getRootSpan(span);
    if (!txn) {
      return dsc;
    }
    const v7FrozenDsc = txn && txn._frozenDynamicSamplingContext;
    if (v7FrozenDsc) {
      return v7FrozenDsc;
    }
    const { sampleRate: maybeSampleRate, source } = txn.metadata;
    if (maybeSampleRate != null) {
      dsc.sample_rate = `${maybeSampleRate}`;
    }
    const jsonSpan = spanToJSON(txn);
    if (source && source !== "url") {
      dsc.transaction = jsonSpan.description;
    }
    dsc.sampled = String(spanIsSampled(txn));
    client.emit && client.emit("createDsc", dsc);
    return dsc;
  }
  function applyScopeDataToEvent(event, data) {
    const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
    applyDataToEvent(event, data);
    if (span) {
      applySpanToEvent(event, span);
    }
    applyFingerprintToEvent(event, fingerprint);
    applyBreadcrumbsToEvent(event, breadcrumbs);
    applySdkMetadataToEvent(event, sdkProcessingMetadata);
  }
  function mergeScopeData(data, mergeData) {
    const {
      extra,
      tags,
      user,
      contexts,
      level,
      sdkProcessingMetadata,
      breadcrumbs,
      fingerprint,
      eventProcessors,
      attachments,
      propagationContext,
      // eslint-disable-next-line deprecation/deprecation
      transactionName,
      span
    } = mergeData;
    mergeAndOverwriteScopeData(data, "extra", extra);
    mergeAndOverwriteScopeData(data, "tags", tags);
    mergeAndOverwriteScopeData(data, "user", user);
    mergeAndOverwriteScopeData(data, "contexts", contexts);
    mergeAndOverwriteScopeData(data, "sdkProcessingMetadata", sdkProcessingMetadata);
    if (level) {
      data.level = level;
    }
    if (transactionName) {
      data.transactionName = transactionName;
    }
    if (span) {
      data.span = span;
    }
    if (breadcrumbs.length) {
      data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
    }
    if (fingerprint.length) {
      data.fingerprint = [...data.fingerprint, ...fingerprint];
    }
    if (eventProcessors.length) {
      data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
    }
    if (attachments.length) {
      data.attachments = [...data.attachments, ...attachments];
    }
    data.propagationContext = { ...data.propagationContext, ...propagationContext };
  }
  function mergeAndOverwriteScopeData(data, prop, mergeVal) {
    if (mergeVal && Object.keys(mergeVal).length) {
      data[prop] = { ...data[prop] };
      for (const key in mergeVal) {
        if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {
          data[prop][key] = mergeVal[key];
        }
      }
    }
  }
  function applyDataToEvent(event, data) {
    const {
      extra,
      tags,
      user,
      contexts,
      level,
      // eslint-disable-next-line deprecation/deprecation
      transactionName
    } = data;
    const cleanedExtra = dropUndefinedKeys(extra);
    if (cleanedExtra && Object.keys(cleanedExtra).length) {
      event.extra = { ...cleanedExtra, ...event.extra };
    }
    const cleanedTags = dropUndefinedKeys(tags);
    if (cleanedTags && Object.keys(cleanedTags).length) {
      event.tags = { ...cleanedTags, ...event.tags };
    }
    const cleanedUser = dropUndefinedKeys(user);
    if (cleanedUser && Object.keys(cleanedUser).length) {
      event.user = { ...cleanedUser, ...event.user };
    }
    const cleanedContexts = dropUndefinedKeys(contexts);
    if (cleanedContexts && Object.keys(cleanedContexts).length) {
      event.contexts = { ...cleanedContexts, ...event.contexts };
    }
    if (level) {
      event.level = level;
    }
    if (transactionName) {
      event.transaction = transactionName;
    }
  }
  function applyBreadcrumbsToEvent(event, breadcrumbs) {
    const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
    event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
  }
  function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
    event.sdkProcessingMetadata = {
      ...event.sdkProcessingMetadata,
      ...sdkProcessingMetadata
    };
  }
  function applySpanToEvent(event, span) {
    event.contexts = { trace: spanToTraceContext(span), ...event.contexts };
    const rootSpan = getRootSpan(span);
    if (rootSpan) {
      event.sdkProcessingMetadata = {
        dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
        ...event.sdkProcessingMetadata
      };
      const transactionName = spanToJSON(rootSpan).description;
      if (transactionName) {
        event.tags = { transaction: transactionName, ...event.tags };
      }
    }
  }
  function applyFingerprintToEvent(event, fingerprint) {
    event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];
    if (fingerprint) {
      event.fingerprint = event.fingerprint.concat(fingerprint);
    }
    if (event.fingerprint && !event.fingerprint.length) {
      delete event.fingerprint;
    }
  }
  const DEFAULT_MAX_BREADCRUMBS = 100;
  let globalScope;
  class Scope {
    /** Flag if notifying is happening. */
    /** Callback for client to receive scope changes. */
    /** Callback list that will be called after {@link applyToEvent}. */
    /** Array of breadcrumbs. */
    /** User */
    /** Tags */
    /** Extra */
    /** Contexts */
    /** Attachments */
    /** Propagation Context for distributed tracing */
    /**
     * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
     * sent to Sentry
     */
    /** Fingerprint */
    /** Severity */
    // eslint-disable-next-line deprecation/deprecation
    /**
     * Transaction Name
     */
    /** Span */
    /** Session */
    /** Request Mode Session Status */
    /** The client on this scope */
    // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
    constructor() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._attachments = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
      this._sdkProcessingMetadata = {};
      this._propagationContext = generatePropagationContext();
    }
    /**
     * Inherit values from the parent scope.
     * @deprecated Use `scope.clone()` and `new Scope()` instead.
     */
    static clone(scope) {
      return scope ? scope.clone() : new Scope();
    }
    /**
     * Clone this scope instance.
     */
    clone() {
      const newScope = new Scope();
      newScope._breadcrumbs = [...this._breadcrumbs];
      newScope._tags = { ...this._tags };
      newScope._extra = { ...this._extra };
      newScope._contexts = { ...this._contexts };
      newScope._user = this._user;
      newScope._level = this._level;
      newScope._span = this._span;
      newScope._session = this._session;
      newScope._transactionName = this._transactionName;
      newScope._fingerprint = this._fingerprint;
      newScope._eventProcessors = [...this._eventProcessors];
      newScope._requestSession = this._requestSession;
      newScope._attachments = [...this._attachments];
      newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
      newScope._propagationContext = { ...this._propagationContext };
      newScope._client = this._client;
      return newScope;
    }
    /** Update the client on the scope. */
    setClient(client) {
      this._client = client;
    }
    /**
     * Get the client assigned to this scope.
     *
     * It is generally recommended to use the global function `Sentry.getClient()` instead, unless you know what you are doing.
     */
    getClient() {
      return this._client;
    }
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    addScopeListener(callback) {
      this._scopeListeners.push(callback);
    }
    /**
     * @inheritDoc
     */
    addEventProcessor(callback) {
      this._eventProcessors.push(callback);
      return this;
    }
    /**
     * @inheritDoc
     */
    setUser(user) {
      this._user = user || {
        email: void 0,
        id: void 0,
        ip_address: void 0,
        segment: void 0,
        username: void 0
      };
      if (this._session) {
        updateSession(this._session, { user });
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    getUser() {
      return this._user;
    }
    /**
     * @inheritDoc
     */
    getRequestSession() {
      return this._requestSession;
    }
    /**
     * @inheritDoc
     */
    setRequestSession(requestSession) {
      this._requestSession = requestSession;
      return this;
    }
    /**
     * @inheritDoc
     */
    setTags(tags) {
      this._tags = {
        ...this._tags,
        ...tags
      };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setTag(key, value) {
      this._tags = { ...this._tags, [key]: value };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setExtras(extras) {
      this._extra = {
        ...this._extra,
        ...extras
      };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setExtra(key, extra) {
      this._extra = { ...this._extra, [key]: extra };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setFingerprint(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setLevel(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets the transaction name on the scope for future events.
     */
    setTransactionName(name) {
      this._transactionName = name;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setContext(key, context) {
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts[key] = context;
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets the Span on the scope.
     * @param span Span
     * @deprecated Instead of setting a span on a scope, use `startSpan()`/`startSpanManual()` instead.
     */
    setSpan(span) {
      this._span = span;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Returns the `Span` if there is one.
     * @deprecated Use `getActiveSpan()` instead.
     */
    getSpan() {
      return this._span;
    }
    /**
     * Returns the `Transaction` attached to the scope (if there is one).
     * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.
     */
    getTransaction() {
      const span = this._span;
      return span && span.transaction;
    }
    /**
     * @inheritDoc
     */
    setSession(session) {
      if (!session) {
        delete this._session;
      } else {
        this._session = session;
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    getSession() {
      return this._session;
    }
    /**
     * @inheritDoc
     */
    update(captureContext) {
      if (!captureContext) {
        return this;
      }
      const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
      if (scopeToMerge instanceof Scope) {
        const scopeData = scopeToMerge.getScopeData();
        this._tags = { ...this._tags, ...scopeData.tags };
        this._extra = { ...this._extra, ...scopeData.extra };
        this._contexts = { ...this._contexts, ...scopeData.contexts };
        if (scopeData.user && Object.keys(scopeData.user).length) {
          this._user = scopeData.user;
        }
        if (scopeData.level) {
          this._level = scopeData.level;
        }
        if (scopeData.fingerprint.length) {
          this._fingerprint = scopeData.fingerprint;
        }
        if (scopeToMerge.getRequestSession()) {
          this._requestSession = scopeToMerge.getRequestSession();
        }
        if (scopeData.propagationContext) {
          this._propagationContext = scopeData.propagationContext;
        }
      } else if (isPlainObject$1(scopeToMerge)) {
        const scopeContext = captureContext;
        this._tags = { ...this._tags, ...scopeContext.tags };
        this._extra = { ...this._extra, ...scopeContext.extra };
        this._contexts = { ...this._contexts, ...scopeContext.contexts };
        if (scopeContext.user) {
          this._user = scopeContext.user;
        }
        if (scopeContext.level) {
          this._level = scopeContext.level;
        }
        if (scopeContext.fingerprint) {
          this._fingerprint = scopeContext.fingerprint;
        }
        if (scopeContext.requestSession) {
          this._requestSession = scopeContext.requestSession;
        }
        if (scopeContext.propagationContext) {
          this._propagationContext = scopeContext.propagationContext;
        }
      }
      return this;
    }
    /**
     * @inheritDoc
     */
    clear() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = void 0;
      this._transactionName = void 0;
      this._fingerprint = void 0;
      this._requestSession = void 0;
      this._span = void 0;
      this._session = void 0;
      this._notifyScopeListeners();
      this._attachments = [];
      this._propagationContext = generatePropagationContext();
      return this;
    }
    /**
     * @inheritDoc
     */
    addBreadcrumb(breadcrumb, maxBreadcrumbs) {
      const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
      if (maxCrumbs <= 0) {
        return this;
      }
      const mergedBreadcrumb = {
        timestamp: dateTimestampInSeconds(),
        ...breadcrumb
      };
      const breadcrumbs = this._breadcrumbs;
      breadcrumbs.push(mergedBreadcrumb);
      this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    getLastBreadcrumb() {
      return this._breadcrumbs[this._breadcrumbs.length - 1];
    }
    /**
     * @inheritDoc
     */
    clearBreadcrumbs() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    addAttachment(attachment) {
      this._attachments.push(attachment);
      return this;
    }
    /**
     * @inheritDoc
     * @deprecated Use `getScopeData()` instead.
     */
    getAttachments() {
      const data = this.getScopeData();
      return data.attachments;
    }
    /**
     * @inheritDoc
     */
    clearAttachments() {
      this._attachments = [];
      return this;
    }
    /** @inheritDoc */
    getScopeData() {
      const {
        _breadcrumbs,
        _attachments,
        _contexts,
        _tags,
        _extra,
        _user,
        _level,
        _fingerprint,
        _eventProcessors,
        _propagationContext,
        _sdkProcessingMetadata,
        _transactionName,
        _span
      } = this;
      return {
        breadcrumbs: _breadcrumbs,
        attachments: _attachments,
        contexts: _contexts,
        tags: _tags,
        extra: _extra,
        user: _user,
        level: _level,
        fingerprint: _fingerprint || [],
        eventProcessors: _eventProcessors,
        propagationContext: _propagationContext,
        sdkProcessingMetadata: _sdkProcessingMetadata,
        transactionName: _transactionName,
        span: _span
      };
    }
    /**
     * Applies data from the scope to the event and runs all event processors on it.
     *
     * @param event Event
     * @param hint Object containing additional information about the original exception, for use by the event processors.
     * @hidden
     * @deprecated Use `applyScopeDataToEvent()` directly
     */
    applyToEvent(event, hint = {}, additionalEventProcessors = []) {
      applyScopeDataToEvent(event, this.getScopeData());
      const eventProcessors = [
        ...additionalEventProcessors,
        // eslint-disable-next-line deprecation/deprecation
        ...getGlobalEventProcessors(),
        ...this._eventProcessors
      ];
      return notifyEventProcessors(eventProcessors, event, hint);
    }
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry
     */
    setSDKProcessingMetadata(newData) {
      this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };
      return this;
    }
    /**
     * @inheritDoc
     */
    setPropagationContext(context) {
      this._propagationContext = context;
      return this;
    }
    /**
     * @inheritDoc
     */
    getPropagationContext() {
      return this._propagationContext;
    }
    /**
     * Capture an exception for this scope.
     *
     * @param exception The exception to capture.
     * @param hint Optinal additional data to attach to the Sentry event.
     * @returns the id of the captured Sentry event.
     */
    captureException(exception, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture exception!");
        return eventId;
      }
      const syntheticException = new Error("Sentry syntheticException");
      this._client.captureException(
        exception,
        {
          originalException: exception,
          syntheticException,
          ...hint,
          event_id: eventId
        },
        this
      );
      return eventId;
    }
    /**
     * Capture a message for this scope.
     *
     * @param message The message to capture.
     * @param level An optional severity level to report the message with.
     * @param hint Optional additional data to attach to the Sentry event.
     * @returns the id of the captured message.
     */
    captureMessage(message, level, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture message!");
        return eventId;
      }
      const syntheticException = new Error(message);
      this._client.captureMessage(
        message,
        level,
        {
          originalException: message,
          syntheticException,
          ...hint,
          event_id: eventId
        },
        this
      );
      return eventId;
    }
    /**
     * Captures a manually created event for this scope and sends it to Sentry.
     *
     * @param exception The event to capture.
     * @param hint Optional additional data to attach to the Sentry event.
     * @returns the id of the captured event.
     */
    captureEvent(event, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture event!");
        return eventId;
      }
      this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
      return eventId;
    }
    /**
     * This will be called on every set call.
     */
    _notifyScopeListeners() {
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach((callback) => {
          callback(this);
        });
        this._notifyingListeners = false;
      }
    }
  }
  function getGlobalScope() {
    if (!globalScope) {
      globalScope = new Scope();
    }
    return globalScope;
  }
  function generatePropagationContext() {
    return {
      traceId: uuid4(),
      spanId: uuid4().substring(16)
    };
  }
  const SDK_VERSION = "7.119.2";
  const API_VERSION = parseFloat(SDK_VERSION);
  const DEFAULT_BREADCRUMBS = 100;
  class Hub {
    /** Is a {@link Layer}[] containing the client and scope */
    /** Contains the last event id of a captured event.  */
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     *
     * @deprecated Instantiation of Hub objects is deprecated and the constructor will be removed in version 8 of the SDK.
     *
     * If you are currently using the Hub for multi-client use like so:
     *
     * ```
     * // OLD
     * const hub = new Hub();
     * hub.bindClient(client);
     * makeMain(hub)
     * ```
     *
     * instead initialize the client as follows:
     *
     * ```
     * // NEW
     * Sentry.withIsolationScope(() => {
     *    Sentry.setCurrentClient(client);
     *    client.init();
     * });
     * ```
     *
     * If you are using the Hub to capture events like so:
     *
     * ```
     * // OLD
     * const client = new Client();
     * const hub = new Hub(client);
     * hub.captureException()
     * ```
     *
     * instead capture isolated events as follows:
     *
     * ```
     * // NEW
     * const client = new Client();
     * const scope = new Scope();
     * scope.setClient(client);
     * scope.captureException();
     * ```
     */
    constructor(client, scope, isolationScope, _version = API_VERSION) {
      this._version = _version;
      let assignedScope;
      if (!scope) {
        assignedScope = new Scope();
        assignedScope.setClient(client);
      } else {
        assignedScope = scope;
      }
      let assignedIsolationScope;
      if (!isolationScope) {
        assignedIsolationScope = new Scope();
        assignedIsolationScope.setClient(client);
      } else {
        assignedIsolationScope = isolationScope;
      }
      this._stack = [{ scope: assignedScope }];
      if (client) {
        this.bindClient(client);
      }
      this._isolationScope = assignedIsolationScope;
    }
    /**
     * Checks if this hub's version is older than the given version.
     *
     * @param version A version number to compare to.
     * @return True if the given version is newer; otherwise false.
     *
     * @deprecated This will be removed in v8.
     */
    isOlderThan(version) {
      return this._version < version;
    }
    /**
     * This binds the given client to the current scope.
     * @param client An SDK client (client) instance.
     *
     * @deprecated Use `initAndBind()` directly, or `setCurrentClient()` and/or `client.init()` instead.
     */
    bindClient(client) {
      const top = this.getStackTop();
      top.client = client;
      top.scope.setClient(client);
      if (client && client.setupIntegrations) {
        client.setupIntegrations();
      }
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `withScope` instead.
     */
    pushScope() {
      const scope = this.getScope().clone();
      this.getStack().push({
        // eslint-disable-next-line deprecation/deprecation
        client: this.getClient(),
        scope
      });
      return scope;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `withScope` instead.
     */
    popScope() {
      if (this.getStack().length <= 1)
        return false;
      return !!this.getStack().pop();
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.withScope()` instead.
     */
    withScope(callback) {
      const scope = this.pushScope();
      let maybePromiseResult;
      try {
        maybePromiseResult = callback(scope);
      } catch (e2) {
        this.popScope();
        throw e2;
      }
      if (isThenable(maybePromiseResult)) {
        return maybePromiseResult.then(
          (res) => {
            this.popScope();
            return res;
          },
          (e2) => {
            this.popScope();
            throw e2;
          }
        );
      }
      this.popScope();
      return maybePromiseResult;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.getClient()` instead.
     */
    getClient() {
      return this.getStackTop().client;
    }
    /**
     * Returns the scope of the top stack.
     *
     * @deprecated Use `Sentry.getCurrentScope()` instead.
     */
    getScope() {
      return this.getStackTop().scope;
    }
    /**
     * @deprecated Use `Sentry.getIsolationScope()` instead.
     */
    getIsolationScope() {
      return this._isolationScope;
    }
    /**
     * Returns the scope stack for domains or the process.
     * @deprecated This will be removed in v8.
     */
    getStack() {
      return this._stack;
    }
    /**
     * Returns the topmost scope layer in the order domain > local > process.
     * @deprecated This will be removed in v8.
     */
    getStackTop() {
      return this._stack[this._stack.length - 1];
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.captureException()` instead.
     */
    captureException(exception, hint) {
      const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      const syntheticException = new Error("Sentry syntheticException");
      this.getScope().captureException(exception, {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      });
      return eventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use  `Sentry.captureMessage()` instead.
     */
    captureMessage(message, level, hint) {
      const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      const syntheticException = new Error(message);
      this.getScope().captureMessage(message, level, {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      });
      return eventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.captureEvent()` instead.
     */
    captureEvent(event, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!event.type) {
        this._lastEventId = eventId;
      }
      this.getScope().captureEvent(event, { ...hint, event_id: eventId });
      return eventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated This will be removed in v8.
     */
    lastEventId() {
      return this._lastEventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.addBreadcrumb()` instead.
     */
    addBreadcrumb(breadcrumb, hint) {
      const { scope, client } = this.getStackTop();
      if (!client)
        return;
      const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions && client.getOptions() || {};
      if (maxBreadcrumbs <= 0)
        return;
      const timestamp = dateTimestampInSeconds();
      const mergedBreadcrumb = { timestamp, ...breadcrumb };
      const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      if (client.emit) {
        client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
      }
      scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setUser()` instead.
     */
    setUser(user) {
      this.getScope().setUser(user);
      this.getIsolationScope().setUser(user);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setTags()` instead.
     */
    setTags(tags) {
      this.getScope().setTags(tags);
      this.getIsolationScope().setTags(tags);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setExtras()` instead.
     */
    setExtras(extras) {
      this.getScope().setExtras(extras);
      this.getIsolationScope().setExtras(extras);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setTag()` instead.
     */
    setTag(key, value) {
      this.getScope().setTag(key, value);
      this.getIsolationScope().setTag(key, value);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setExtra()` instead.
     */
    setExtra(key, extra) {
      this.getScope().setExtra(key, extra);
      this.getIsolationScope().setExtra(key, extra);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setContext()` instead.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setContext(name, context) {
      this.getScope().setContext(name, context);
      this.getIsolationScope().setContext(name, context);
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `getScope()` directly.
     */
    configureScope(callback) {
      const { scope, client } = this.getStackTop();
      if (client) {
        callback(scope);
      }
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line deprecation/deprecation
    run(callback) {
      const oldHub = makeMain(this);
      try {
        callback(this);
      } finally {
        makeMain(oldHub);
      }
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.getClient().getIntegrationByName()` instead.
     */
    getIntegration(integration) {
      const client = this.getClient();
      if (!client)
        return null;
      try {
        return client.getIntegration(integration);
      } catch (_oO) {
        DEBUG_BUILD$1 && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
        return null;
      }
    }
    /**
     * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
     *
     * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
     * new child span within the transaction or any span, call the respective `.startChild()` method.
     *
     * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
     *
     * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its
     * finished child spans will be sent to Sentry.
     *
     * @param context Properties of the new `Transaction`.
     * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
     * default values). See {@link Options.tracesSampler}.
     *
     * @returns The transaction which was just started
     *
     * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
     */
    startTransaction(context, customSamplingContext) {
      const result2 = this._callExtensionMethod("startTransaction", context, customSamplingContext);
      if (DEBUG_BUILD$1 && !result2) {
        const client = this.getClient();
        if (!client) {
          logger.warn(
            "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'"
          );
        } else {
          logger.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`);
        }
      }
      return result2;
    }
    /**
     * @inheritDoc
     * @deprecated Use `spanToTraceHeader()` instead.
     */
    traceHeaders() {
      return this._callExtensionMethod("traceHeaders");
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use top level `captureSession` instead.
     */
    captureSession(endSession2 = false) {
      if (endSession2) {
        return this.endSession();
      }
      this._sendSessionUpdate();
    }
    /**
     * @inheritDoc
     * @deprecated Use top level `endSession` instead.
     */
    endSession() {
      const layer = this.getStackTop();
      const scope = layer.scope;
      const session = scope.getSession();
      if (session) {
        closeSession(session);
      }
      this._sendSessionUpdate();
      scope.setSession();
    }
    /**
     * @inheritDoc
     * @deprecated Use top level `startSession` instead.
     */
    startSession(context) {
      const { scope, client } = this.getStackTop();
      const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
      const { userAgent } = GLOBAL_OBJ.navigator || {};
      const session = makeSession({
        release,
        environment,
        user: scope.getUser(),
        ...userAgent && { userAgent },
        ...context
      });
      const currentSession = scope.getSession && scope.getSession();
      if (currentSession && currentSession.status === "ok") {
        updateSession(currentSession, { status: "exited" });
      }
      this.endSession();
      scope.setSession(session);
      return session;
    }
    /**
     * Returns if default PII should be sent to Sentry and propagated in ourgoing requests
     * when Tracing is used.
     *
     * @deprecated Use top-level `getClient().getOptions().sendDefaultPii` instead. This function
     * only unnecessarily increased API surface but only wrapped accessing the option.
     */
    shouldSendDefaultPii() {
      const client = this.getClient();
      const options = client && client.getOptions();
      return Boolean(options && options.sendDefaultPii);
    }
    /**
     * Sends the current Session on the scope
     */
    _sendSessionUpdate() {
      const { scope, client } = this.getStackTop();
      const session = scope.getSession();
      if (session && client && client.captureSession) {
        client.captureSession(session);
      }
    }
    /**
     * Calls global extension method and binding current instance to the function call
     */
    // @ts-expect-error Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _callExtensionMethod(method, ...args) {
      const carrier = getMainCarrier();
      const sentry = carrier.__SENTRY__;
      if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
        return sentry.extensions[method].apply(this, args);
      }
      DEBUG_BUILD$1 && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);
    }
  }
  function getMainCarrier() {
    GLOBAL_OBJ.__SENTRY__ = GLOBAL_OBJ.__SENTRY__ || {
      extensions: {},
      hub: void 0
    };
    return GLOBAL_OBJ;
  }
  function makeMain(hub) {
    const registry = getMainCarrier();
    const oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
  }
  function getCurrentHub() {
    const registry = getMainCarrier();
    if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
      const hub = registry.__SENTRY__.acs.getCurrentHub();
      if (hub) {
        return hub;
      }
    }
    return getGlobalHub(registry);
  }
  function getIsolationScope() {
    return getCurrentHub().getIsolationScope();
  }
  function getGlobalHub(registry = getMainCarrier()) {
    if (!hasHubOnCarrier(registry) || // eslint-disable-next-line deprecation/deprecation
    getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
      setHubOnCarrier(registry, new Hub());
    }
    return getHubFromCarrier(registry);
  }
  function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
  }
  function getHubFromCarrier(carrier) {
    return getGlobalSingleton("hub", () => new Hub(), carrier);
  }
  function setHubOnCarrier(carrier, hub) {
    if (!carrier)
      return false;
    const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    __SENTRY__.hub = hub;
    return true;
  }
  function enhanceEventWithSdkInfo(event, sdkInfo) {
    if (!sdkInfo) {
      return event;
    }
    event.sdk = event.sdk || {};
    event.sdk.name = event.sdk.name || sdkInfo.name;
    event.sdk.version = event.sdk.version || sdkInfo.version;
    event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
    event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
    return event;
  }
  function createSessionEnvelope(session, dsn, metadata, tunnel) {
    const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
    const envelopeHeaders = {
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...sdkInfo && { sdk: sdkInfo },
      ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
    };
    const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
    return createEnvelope(envelopeHeaders, [envelopeItem]);
  }
  function createEventEnvelope(event, dsn, metadata, tunnel) {
    const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
    const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
    enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
    const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
    delete event.sdkProcessingMetadata;
    const eventItem = [{ type: eventType }, event];
    return createEnvelope(envelopeHeaders, [eventItem]);
  }
  const SENTRY_API_VERSION = "7";
  function getBaseApiEndpoint(dsn) {
    const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
    const port = dsn.port ? `:${dsn.port}` : "";
    return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
  }
  function _getIngestEndpoint(dsn) {
    return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
  }
  function _encodedAuth(dsn, sdkInfo) {
    return urlEncode({
      // We send only the minimum set of required information. See
      // https://github.com/getsentry/sentry-javascript/issues/2572.
      sentry_key: dsn.publicKey,
      sentry_version: SENTRY_API_VERSION,
      ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }
    });
  }
  function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnelOrOptions = {}) {
    const tunnel = typeof tunnelOrOptions === "string" ? tunnelOrOptions : tunnelOrOptions.tunnel;
    const sdkInfo = typeof tunnelOrOptions === "string" || !tunnelOrOptions._metadata ? void 0 : tunnelOrOptions._metadata.sdk;
    return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
  }
  const installedIntegrations = [];
  function filterDuplicates(integrations) {
    const integrationsByName = {};
    integrations.forEach((currentInstance) => {
      const { name } = currentInstance;
      const existingInstance = integrationsByName[name];
      if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
        return;
      }
      integrationsByName[name] = currentInstance;
    });
    return Object.keys(integrationsByName).map((k2) => integrationsByName[k2]);
  }
  function getIntegrationsToSetup(options) {
    const defaultIntegrations2 = options.defaultIntegrations || [];
    const userIntegrations = options.integrations;
    defaultIntegrations2.forEach((integration) => {
      integration.isDefaultInstance = true;
    });
    let integrations;
    if (Array.isArray(userIntegrations)) {
      integrations = [...defaultIntegrations2, ...userIntegrations];
    } else if (typeof userIntegrations === "function") {
      integrations = arrayify(userIntegrations(defaultIntegrations2));
    } else {
      integrations = defaultIntegrations2;
    }
    const finalIntegrations = filterDuplicates(integrations);
    const debugIndex = findIndex(finalIntegrations, (integration) => integration.name === "Debug");
    if (debugIndex !== -1) {
      const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
      finalIntegrations.push(debugInstance);
    }
    return finalIntegrations;
  }
  function setupIntegrations(client, integrations) {
    const integrationIndex = {};
    integrations.forEach((integration) => {
      if (integration) {
        setupIntegration(client, integration, integrationIndex);
      }
    });
    return integrationIndex;
  }
  function afterSetupIntegrations(client, integrations) {
    for (const integration of integrations) {
      if (integration && integration.afterAllSetup) {
        integration.afterAllSetup(client);
      }
    }
  }
  function setupIntegration(client, integration, integrationIndex) {
    if (integrationIndex[integration.name]) {
      DEBUG_BUILD$1 && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
      return;
    }
    integrationIndex[integration.name] = integration;
    if (installedIntegrations.indexOf(integration.name) === -1) {
      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
      installedIntegrations.push(integration.name);
    }
    if (integration.setup && typeof integration.setup === "function") {
      integration.setup(client);
    }
    if (client.on && typeof integration.preprocessEvent === "function") {
      const callback = integration.preprocessEvent.bind(integration);
      client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
    }
    if (client.addEventProcessor && typeof integration.processEvent === "function") {
      const callback = integration.processEvent.bind(integration);
      const processor = Object.assign((event, hint) => callback(event, hint, client), {
        id: integration.name
      });
      client.addEventProcessor(processor);
    }
    DEBUG_BUILD$1 && logger.log(`Integration installed: ${integration.name}`);
  }
  function findIndex(arr, callback) {
    for (let i2 = 0; i2 < arr.length; i2++) {
      if (callback(arr[i2]) === true) {
        return i2;
      }
    }
    return -1;
  }
  function convertIntegrationFnToClass(name, fn) {
    return Object.assign(
      function ConvertedIntegration(...args) {
        return fn(...args);
      },
      { id: name }
    );
  }
  function defineIntegration(fn) {
    return fn;
  }
  function serializeMetricBuckets(metricBucketItems) {
    let out = "";
    for (const item of metricBucketItems) {
      const tagEntries = Object.entries(item.tags);
      const maybeTags = tagEntries.length > 0 ? `|#${tagEntries.map(([key, value]) => `${key}:${value}`).join(",")}` : "";
      out += `${item.name}@${item.unit}:${item.metric}|${item.metricType}${maybeTags}|T${item.timestamp}
`;
    }
    return out;
  }
  function createMetricEnvelope(metricBucketItems, dsn, metadata, tunnel) {
    const headers = {
      sent_at: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (metadata && metadata.sdk) {
      headers.sdk = {
        name: metadata.sdk.name,
        version: metadata.sdk.version
      };
    }
    if (!!tunnel && dsn) {
      headers.dsn = dsnToString(dsn);
    }
    const item = createMetricEnvelopeItem(metricBucketItems);
    return createEnvelope(headers, [item]);
  }
  function createMetricEnvelopeItem(metricBucketItems) {
    const payload = serializeMetricBuckets(metricBucketItems);
    const metricHeaders = {
      type: "statsd",
      length: payload.length
    };
    return [metricHeaders, payload];
  }
  const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
  class BaseClient {
    /**
     * A reference to a metrics aggregator
     *
     * @experimental Note this is alpha API. It may experience breaking changes in the future.
     */
    /** Options passed to the SDK. */
    /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
    /** Array of set up integrations. */
    /** Indicates whether this client's integrations have been set up. */
    /** Number of calls being processed */
    /** Holds flushable  */
    // eslint-disable-next-line @typescript-eslint/ban-types
    /**
     * Initializes this client instance.
     *
     * @param options Options for the client.
     */
    constructor(options) {
      this._options = options;
      this._integrations = {};
      this._integrationsInitialized = false;
      this._numProcessing = 0;
      this._outcomes = {};
      this._hooks = {};
      this._eventProcessors = [];
      if (options.dsn) {
        this._dsn = makeDsn(options.dsn);
      } else {
        DEBUG_BUILD$1 && logger.warn("No DSN provided, client will not send events.");
      }
      if (this._dsn) {
        const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);
        this._transport = options.transport({
          tunnel: this._options.tunnel,
          recordDroppedEvent: this.recordDroppedEvent.bind(this),
          ...options.transportOptions,
          url
        });
      }
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    captureException(exception, hint, scope) {
      if (checkOrSetAlreadyCaught(exception)) {
        DEBUG_BUILD$1 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      let eventId = hint && hint.event_id;
      this._process(
        this.eventFromException(exception, hint).then((event) => this._captureEvent(event, hint, scope)).then((result2) => {
          eventId = result2;
        })
      );
      return eventId;
    }
    /**
     * @inheritDoc
     */
    captureMessage(message, level, hint, scope) {
      let eventId = hint && hint.event_id;
      const eventMessage = isParameterizedString(message) ? message : String(message);
      const promisedEvent = isPrimitive$2(message) ? this.eventFromMessage(eventMessage, level, hint) : this.eventFromException(message, hint);
      this._process(
        promisedEvent.then((event) => this._captureEvent(event, hint, scope)).then((result2) => {
          eventId = result2;
        })
      );
      return eventId;
    }
    /**
     * @inheritDoc
     */
    captureEvent(event, hint, scope) {
      if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
        DEBUG_BUILD$1 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      let eventId = hint && hint.event_id;
      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
      const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
      this._process(
        this._captureEvent(event, hint, capturedSpanScope || scope).then((result2) => {
          eventId = result2;
        })
      );
      return eventId;
    }
    /**
     * @inheritDoc
     */
    captureSession(session) {
      if (!(typeof session.release === "string")) {
        DEBUG_BUILD$1 && logger.warn("Discarded session because of missing or non-string release");
      } else {
        this.sendSession(session);
        updateSession(session, { init: false });
      }
    }
    /**
     * @inheritDoc
     */
    getDsn() {
      return this._dsn;
    }
    /**
     * @inheritDoc
     */
    getOptions() {
      return this._options;
    }
    /**
     * @see SdkMetadata in @sentry/types
     *
     * @return The metadata of the SDK
     */
    getSdkMetadata() {
      return this._options._metadata;
    }
    /**
     * @inheritDoc
     */
    getTransport() {
      return this._transport;
    }
    /**
     * @inheritDoc
     */
    flush(timeout) {
      const transport = this._transport;
      if (transport) {
        if (this.metricsAggregator) {
          this.metricsAggregator.flush();
        }
        return this._isClientDoneProcessing(timeout).then((clientFinished) => {
          return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
        });
      } else {
        return resolvedSyncPromise(true);
      }
    }
    /**
     * @inheritDoc
     */
    close(timeout) {
      return this.flush(timeout).then((result2) => {
        this.getOptions().enabled = false;
        if (this.metricsAggregator) {
          this.metricsAggregator.close();
        }
        return result2;
      });
    }
    /** Get all installed event processors. */
    getEventProcessors() {
      return this._eventProcessors;
    }
    /** @inheritDoc */
    addEventProcessor(eventProcessor) {
      this._eventProcessors.push(eventProcessor);
    }
    /**
     * This is an internal function to setup all integrations that should run on the client.
     * @deprecated Use `client.init()` instead.
     */
    setupIntegrations(forceInitialize) {
      if (forceInitialize && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) {
        this._setupIntegrations();
      }
    }
    /** @inheritdoc */
    init() {
      if (this._isEnabled()) {
        this._setupIntegrations();
      }
    }
    /**
     * Gets an installed integration by its `id`.
     *
     * @returns The installed integration or `undefined` if no integration with that `id` was installed.
     * @deprecated Use `getIntegrationByName()` instead.
     */
    getIntegrationById(integrationId) {
      return this.getIntegrationByName(integrationId);
    }
    /**
     * Gets an installed integration by its name.
     *
     * @returns The installed integration or `undefined` if no integration with that `name` was installed.
     */
    getIntegrationByName(integrationName) {
      return this._integrations[integrationName];
    }
    /**
     * Returns the client's instance of the given integration class, it any.
     * @deprecated Use `getIntegrationByName()` instead.
     */
    getIntegration(integration) {
      try {
        return this._integrations[integration.id] || null;
      } catch (_oO) {
        DEBUG_BUILD$1 && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);
        return null;
      }
    }
    /**
     * @inheritDoc
     */
    addIntegration(integration) {
      const isAlreadyInstalled = this._integrations[integration.name];
      setupIntegration(this, integration, this._integrations);
      if (!isAlreadyInstalled) {
        afterSetupIntegrations(this, [integration]);
      }
    }
    /**
     * @inheritDoc
     */
    sendEvent(event, hint = {}) {
      this.emit("beforeSendEvent", event, hint);
      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
      for (const attachment of hint.attachments || []) {
        env = addItemToEnvelope(
          env,
          createAttachmentEnvelopeItem(
            attachment,
            this._options.transportOptions && this._options.transportOptions.textEncoder
          )
        );
      }
      const promise = this._sendEnvelope(env);
      if (promise) {
        promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
      }
    }
    /**
     * @inheritDoc
     */
    sendSession(session) {
      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
      this._sendEnvelope(env);
    }
    /**
     * @inheritDoc
     */
    recordDroppedEvent(reason, category, eventOrCount) {
      if (this._options.sendClientReports) {
        const count = typeof eventOrCount === "number" ? eventOrCount : 1;
        const key = `${reason}:${category}`;
        DEBUG_BUILD$1 && logger.log(`Recording outcome: "${key}"${count > 1 ? ` (${count} times)` : ""}`);
        this._outcomes[key] = (this._outcomes[key] || 0) + count;
      }
    }
    /**
     * @inheritDoc
     */
    captureAggregateMetrics(metricBucketItems) {
      DEBUG_BUILD$1 && logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);
      const metricsEnvelope = createMetricEnvelope(
        metricBucketItems,
        this._dsn,
        this._options._metadata,
        this._options.tunnel
      );
      this._sendEnvelope(metricsEnvelope);
    }
    // Keep on() & emit() signatures in sync with types' client.ts interface
    /* eslint-disable @typescript-eslint/unified-signatures */
    /** @inheritdoc */
    /** @inheritdoc */
    on(hook, callback) {
      if (!this._hooks[hook]) {
        this._hooks[hook] = [];
      }
      this._hooks[hook].push(callback);
    }
    /** @inheritdoc */
    /** @inheritdoc */
    emit(hook, ...rest) {
      if (this._hooks[hook]) {
        this._hooks[hook].forEach((callback) => callback(...rest));
      }
    }
    /* eslint-enable @typescript-eslint/unified-signatures */
    /** Setup integrations for this client. */
    _setupIntegrations() {
      const { integrations } = this._options;
      this._integrations = setupIntegrations(this, integrations);
      afterSetupIntegrations(this, integrations);
      this._integrationsInitialized = true;
    }
    /** Updates existing session based on the provided event */
    _updateSessionFromEvent(session, event) {
      let crashed = false;
      let errored = false;
      const exceptions = event.exception && event.exception.values;
      if (exceptions) {
        errored = true;
        for (const ex of exceptions) {
          const mechanism = ex.mechanism;
          if (mechanism && mechanism.handled === false) {
            crashed = true;
            break;
          }
        }
      }
      const sessionNonTerminal = session.status === "ok";
      const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
      if (shouldUpdateAndSend) {
        updateSession(session, {
          ...crashed && { status: "crashed" },
          errors: session.errors || Number(errored || crashed)
        });
        this.captureSession(session);
      }
    }
    /**
     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
     * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
     * `false` otherwise
     */
    _isClientDoneProcessing(timeout) {
      return new SyncPromise((resolve) => {
        let ticked = 0;
        const tick = 1;
        const interval = setInterval(() => {
          if (this._numProcessing == 0) {
            clearInterval(interval);
            resolve(true);
          } else {
            ticked += tick;
            if (timeout && ticked >= timeout) {
              clearInterval(interval);
              resolve(false);
            }
          }
        }, tick);
      });
    }
    /** Determines whether this SDK is enabled and a transport is present. */
    _isEnabled() {
      return this.getOptions().enabled !== false && this._transport !== void 0;
    }
    /**
     * Adds common information to events.
     *
     * The information includes release and environment from `options`,
     * breadcrumbs and context (extra, tags and user) from the scope.
     *
     * Information that is already present in the event is never overwritten. For
     * nested objects, such as the context, keys are merged.
     *
     * @param event The original event.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A new event with more information.
     */
    _prepareEvent(event, hint, scope, isolationScope = getIsolationScope()) {
      const options = this.getOptions();
      const integrations = Object.keys(this._integrations);
      if (!hint.integrations && integrations.length > 0) {
        hint.integrations = integrations;
      }
      this.emit("preprocessEvent", event, hint);
      return prepareEvent(options, event, hint, scope, this, isolationScope).then((evt) => {
        if (evt === null) {
          return evt;
        }
        const propagationContext = {
          ...isolationScope.getPropagationContext(),
          ...scope ? scope.getPropagationContext() : void 0
        };
        const trace = evt.contexts && evt.contexts.trace;
        if (!trace && propagationContext) {
          const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;
          evt.contexts = {
            trace: {
              trace_id,
              span_id: spanId,
              parent_span_id: parentSpanId
            },
            ...evt.contexts
          };
          const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this, scope);
          evt.sdkProcessingMetadata = {
            dynamicSamplingContext,
            ...evt.sdkProcessingMetadata
          };
        }
        return evt;
      });
    }
    /**
     * Processes the event and logs an error in case of rejection
     * @param event
     * @param hint
     * @param scope
     */
    _captureEvent(event, hint = {}, scope) {
      return this._processEvent(event, hint, scope).then(
        (finalEvent) => {
          return finalEvent.event_id;
        },
        (reason) => {
          if (DEBUG_BUILD$1) {
            const sentryError = reason;
            if (sentryError.logLevel === "log") {
              logger.log(sentryError.message);
            } else {
              logger.warn(sentryError);
            }
          }
          return void 0;
        }
      );
    }
    /**
     * Processes an event (either error or message) and sends it to Sentry.
     *
     * This also adds breadcrumbs and context information to the event. However,
     * platform specific meta data (such as the User's IP address) must be added
     * by the SDK implementor.
     *
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
     */
    _processEvent(event, hint, scope) {
      const options = this.getOptions();
      const { sampleRate } = options;
      const isTransaction = isTransactionEvent(event);
      const isError2 = isErrorEvent(event);
      const eventType = event.type || "error";
      const beforeSendLabel = `before send for type \`${eventType}\``;
      if (isError2 && typeof sampleRate === "number" && Math.random() > sampleRate) {
        this.recordDroppedEvent("sample_rate", "error", event);
        return rejectedSyncPromise(
          new SentryError(
            `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
            "log"
          )
        );
      }
      const dataCategory = eventType === "replay_event" ? "replay" : eventType;
      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
      const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
      return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope).then((prepared) => {
        if (prepared === null) {
          this.recordDroppedEvent("event_processor", dataCategory, event);
          throw new SentryError("An event processor returned `null`, will not send event.", "log");
        }
        const isInternalException = hint.data && hint.data.__sentry__ === true;
        if (isInternalException) {
          return prepared;
        }
        const result2 = processBeforeSend(options, prepared, hint);
        return _validateBeforeSendResult(result2, beforeSendLabel);
      }).then((processedEvent) => {
        if (processedEvent === null) {
          this.recordDroppedEvent("before_send", dataCategory, event);
          if (isTransaction) {
            const spans = event.spans || [];
            const spanCount = 1 + spans.length;
            this.recordDroppedEvent("before_send", "span", spanCount);
          }
          throw new SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
        }
        const session = scope && scope.getSession();
        if (!isTransaction && session) {
          this._updateSessionFromEvent(session, processedEvent);
        }
        if (isTransaction) {
          const spanCountBefore = processedEvent.sdkProcessingMetadata && processedEvent.sdkProcessingMetadata.spanCountBeforeProcessing || 0;
          const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;
          const droppedSpanCount = spanCountBefore - spanCountAfter;
          if (droppedSpanCount > 0) {
            this.recordDroppedEvent("before_send", "span", droppedSpanCount);
          }
        }
        const transactionInfo = processedEvent.transaction_info;
        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
          const source = "custom";
          processedEvent.transaction_info = {
            ...transactionInfo,
            source
          };
        }
        this.sendEvent(processedEvent, hint);
        return processedEvent;
      }).then(null, (reason) => {
        if (reason instanceof SentryError) {
          throw reason;
        }
        this.captureException(reason, {
          data: {
            __sentry__: true
          },
          originalException: reason
        });
        throw new SentryError(
          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
        );
      });
    }
    /**
     * Occupies the client with processing and event
     */
    _process(promise) {
      this._numProcessing++;
      void promise.then(
        (value) => {
          this._numProcessing--;
          return value;
        },
        (reason) => {
          this._numProcessing--;
          return reason;
        }
      );
    }
    /**
     * @inheritdoc
     */
    _sendEnvelope(envelope) {
      this.emit("beforeEnvelope", envelope);
      if (this._isEnabled() && this._transport) {
        return this._transport.send(envelope).then(null, (reason) => {
          DEBUG_BUILD$1 && logger.error("Error while sending event:", reason);
        });
      } else {
        DEBUG_BUILD$1 && logger.error("Transport disabled");
      }
    }
    /**
     * Clears outcomes on this client and returns them.
     */
    _clearOutcomes() {
      const outcomes = this._outcomes;
      this._outcomes = {};
      return Object.keys(outcomes).map((key) => {
        const [reason, category] = key.split(":");
        return {
          reason,
          category,
          quantity: outcomes[key]
        };
      });
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  }
  function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
    const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
    if (isThenable(beforeSendResult)) {
      return beforeSendResult.then(
        (event) => {
          if (!isPlainObject$1(event) && event !== null) {
            throw new SentryError(invalidValueError);
          }
          return event;
        },
        (e2) => {
          throw new SentryError(`${beforeSendLabel} rejected with ${e2}`);
        }
      );
    } else if (!isPlainObject$1(beforeSendResult) && beforeSendResult !== null) {
      throw new SentryError(invalidValueError);
    }
    return beforeSendResult;
  }
  function processBeforeSend(options, event, hint) {
    const { beforeSend, beforeSendTransaction } = options;
    if (isErrorEvent(event) && beforeSend) {
      return beforeSend(event, hint);
    }
    if (isTransactionEvent(event) && beforeSendTransaction) {
      if (event.spans) {
        const spanCountBefore = event.spans.length;
        event.sdkProcessingMetadata = {
          ...event.sdkProcessingMetadata,
          spanCountBeforeProcessing: spanCountBefore
        };
      }
      return beforeSendTransaction(event, hint);
    }
    return event;
  }
  function isErrorEvent(event) {
    return event.type === void 0;
  }
  function isTransactionEvent(event) {
    return event.type === "transaction";
  }
  function initAndBind(clientClass, options) {
    if (options.debug === true) {
      if (DEBUG_BUILD$1) {
        logger.enable();
      } else {
        consoleSandbox(() => {
          console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
        });
      }
    }
    const scope = getCurrentScope();
    scope.update(options.initialScope);
    const client = new clientClass(options);
    setCurrentClient(client);
    initializeClient(client);
  }
  function setCurrentClient(client) {
    const hub = getCurrentHub();
    const top = hub.getStackTop();
    top.client = client;
    top.scope.setClient(client);
  }
  function initializeClient(client) {
    if (client.init) {
      client.init();
    } else if (client.setupIntegrations) {
      client.setupIntegrations();
    }
  }
  const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
  function createTransport(options, makeRequest, buffer = makePromiseBuffer(
    options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
  )) {
    let rateLimits = {};
    const flush = (timeout) => buffer.drain(timeout);
    function send(envelope) {
      const filteredEnvelopeItems = [];
      forEachEnvelopeItem(envelope, (item, type) => {
        const dataCategory = envelopeItemTypeToDataCategory(type);
        if (isRateLimited(rateLimits, dataCategory)) {
          const event = getEventForEnvelopeItem(item, type);
          options.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
        } else {
          filteredEnvelopeItems.push(item);
        }
      });
      if (filteredEnvelopeItems.length === 0) {
        return resolvedSyncPromise();
      }
      const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
      const recordEnvelopeLoss = (reason) => {
        forEachEnvelopeItem(filteredEnvelope, (item, type) => {
          const event = getEventForEnvelopeItem(item, type);
          options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);
        });
      };
      const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(
        (response) => {
          if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
            DEBUG_BUILD$1 && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
          }
          rateLimits = updateRateLimits(rateLimits, response);
          return response;
        },
        (error2) => {
          recordEnvelopeLoss("network_error");
          throw error2;
        }
      );
      return buffer.add(requestTask).then(
        (result2) => result2,
        (error2) => {
          if (error2 instanceof SentryError) {
            DEBUG_BUILD$1 && logger.error("Skipped sending event because buffer is full.");
            recordEnvelopeLoss("queue_overflow");
            return resolvedSyncPromise();
          } else {
            throw error2;
          }
        }
      );
    }
    send.__sentry__baseTransport__ = true;
    return {
      send,
      flush
    };
  }
  function getEventForEnvelopeItem(item, type) {
    if (type !== "event" && type !== "transaction") {
      return void 0;
    }
    return Array.isArray(item) ? item[1] : void 0;
  }
  function applySdkMetadata(options, name, names = [name], source = "npm") {
    const metadata = options._metadata || {};
    if (!metadata.sdk) {
      metadata.sdk = {
        name: `sentry.javascript.${name}`,
        packages: names.map((name2) => ({
          name: `${source}:@sentry/${name2}`,
          version: SDK_VERSION
        })),
        version: SDK_VERSION
      };
    }
    options._metadata = metadata;
  }
  const DEFAULT_IGNORE_ERRORS = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/
  ];
  const DEFAULT_IGNORE_TRANSACTIONS = [
    /^.*\/healthcheck$/,
    /^.*\/healthy$/,
    /^.*\/live$/,
    /^.*\/ready$/,
    /^.*\/heartbeat$/,
    /^.*\/health$/,
    /^.*\/healthz$/
  ];
  const INTEGRATION_NAME$7 = "InboundFilters";
  const _inboundFiltersIntegration = (options = {}) => {
    return {
      name: INTEGRATION_NAME$7,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      processEvent(event, _hint, client) {
        const clientOptions = client.getOptions();
        const mergedOptions = _mergeOptions(options, clientOptions);
        return _shouldDropEvent$1(event, mergedOptions) ? null : event;
      }
    };
  };
  const inboundFiltersIntegration = defineIntegration(_inboundFiltersIntegration);
  convertIntegrationFnToClass(
    INTEGRATION_NAME$7,
    inboundFiltersIntegration
  );
  function _mergeOptions(internalOptions = {}, clientOptions = {}) {
    return {
      allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
      denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
      ignoreErrors: [
        ...internalOptions.ignoreErrors || [],
        ...clientOptions.ignoreErrors || [],
        ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
      ],
      ignoreTransactions: [
        ...internalOptions.ignoreTransactions || [],
        ...clientOptions.ignoreTransactions || [],
        ...internalOptions.disableTransactionDefaults ? [] : DEFAULT_IGNORE_TRANSACTIONS
      ],
      ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
    };
  }
  function _shouldDropEvent$1(event, options) {
    if (options.ignoreInternal && _isSentryError(event)) {
      DEBUG_BUILD$1 && logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${getEventDescription(event)}`);
      return true;
    }
    if (_isIgnoredError(event, options.ignoreErrors)) {
      DEBUG_BUILD$1 && logger.warn(
        `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
      DEBUG_BUILD$1 && logger.warn(
        `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
      DEBUG_BUILD$1 && logger.warn(
        `Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
      DEBUG_BUILD$1 && logger.warn(
        `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
    return false;
  }
  function _isIgnoredError(event, ignoreErrors) {
    if (event.type || !ignoreErrors || !ignoreErrors.length) {
      return false;
    }
    return _getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));
  }
  function _isIgnoredTransaction(event, ignoreTransactions) {
    if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
      return false;
    }
    const name = event.transaction;
    return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
  }
  function _isDeniedUrl(event, denyUrls) {
    if (!denyUrls || !denyUrls.length) {
      return false;
    }
    const url = _getEventFilterUrl(event);
    return !url ? false : stringMatchesSomePattern(url, denyUrls);
  }
  function _isAllowedUrl(event, allowUrls) {
    if (!allowUrls || !allowUrls.length) {
      return true;
    }
    const url = _getEventFilterUrl(event);
    return !url ? true : stringMatchesSomePattern(url, allowUrls);
  }
  function _getPossibleEventMessages(event) {
    const possibleMessages = [];
    if (event.message) {
      possibleMessages.push(event.message);
    }
    let lastException;
    try {
      lastException = event.exception.values[event.exception.values.length - 1];
    } catch (e2) {
    }
    if (lastException) {
      if (lastException.value) {
        possibleMessages.push(lastException.value);
        if (lastException.type) {
          possibleMessages.push(`${lastException.type}: ${lastException.value}`);
        }
      }
    }
    if (DEBUG_BUILD$1 && possibleMessages.length === 0) {
      logger.error(`Could not extract message for event ${getEventDescription(event)}`);
    }
    return possibleMessages;
  }
  function _isSentryError(event) {
    try {
      return event.exception.values[0].type === "SentryError";
    } catch (e2) {
    }
    return false;
  }
  function _getLastValidUrl(frames = []) {
    for (let i2 = frames.length - 1; i2 >= 0; i2--) {
      const frame = frames[i2];
      if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
        return frame.filename || null;
      }
    }
    return null;
  }
  function _getEventFilterUrl(event) {
    try {
      let frames;
      try {
        frames = event.exception.values[0].stacktrace.frames;
      } catch (e2) {
      }
      return frames ? _getLastValidUrl(frames) : null;
    } catch (oO) {
      DEBUG_BUILD$1 && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
      return null;
    }
  }
  let originalFunctionToString;
  const INTEGRATION_NAME$6 = "FunctionToString";
  const SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
  const _functionToStringIntegration = () => {
    return {
      name: INTEGRATION_NAME$6,
      setupOnce() {
        originalFunctionToString = Function.prototype.toString;
        try {
          Function.prototype.toString = function(...args) {
            const originalFunction = getOriginalFunction(this);
            const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== void 0 ? originalFunction : this;
            return originalFunctionToString.apply(context, args);
          };
        } catch (e2) {
        }
      },
      setup(client) {
        SETUP_CLIENTS.set(client, true);
      }
    };
  };
  const functionToStringIntegration = defineIntegration(_functionToStringIntegration);
  convertIntegrationFnToClass(
    INTEGRATION_NAME$6,
    functionToStringIntegration
  );
  const WINDOW = GLOBAL_OBJ;
  let ignoreOnError = 0;
  function shouldIgnoreOnError() {
    return ignoreOnError > 0;
  }
  function ignoreNextOnError() {
    ignoreOnError++;
    setTimeout(() => {
      ignoreOnError--;
    });
  }
  function wrap(fn, options = {}, before) {
    if (typeof fn !== "function") {
      return fn;
    }
    try {
      const wrapper = fn.__sentry_wrapped__;
      if (wrapper) {
        if (typeof wrapper === "function") {
          return wrapper;
        } else {
          return fn;
        }
      }
      if (getOriginalFunction(fn)) {
        return fn;
      }
    } catch (e2) {
      return fn;
    }
    const sentryWrapped = function() {
      const args = Array.prototype.slice.call(arguments);
      try {
        if (before && typeof before === "function") {
          before.apply(this, arguments);
        }
        const wrappedArguments = args.map((arg) => wrap(arg, options));
        return fn.apply(this, wrappedArguments);
      } catch (ex) {
        ignoreNextOnError();
        withScope((scope) => {
          scope.addEventProcessor((event) => {
            if (options.mechanism) {
              addExceptionTypeValue(event, void 0, void 0);
              addExceptionMechanism(event, options.mechanism);
            }
            event.extra = {
              ...event.extra,
              arguments: args
            };
            return event;
          });
          captureException(ex);
        });
        throw ex;
      }
    };
    try {
      for (const property in fn) {
        if (Object.prototype.hasOwnProperty.call(fn, property)) {
          sentryWrapped[property] = fn[property];
        }
      }
    } catch (_oO) {
    }
    markFunctionWrapped(sentryWrapped, fn);
    addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
    try {
      const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
      if (descriptor.configurable) {
        Object.defineProperty(sentryWrapped, "name", {
          get() {
            return fn.name;
          }
        });
      }
    } catch (_oO) {
    }
    return sentryWrapped;
  }
  const DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  function exceptionFromError(stackParser, ex) {
    const frames = parseStackFrames(stackParser, ex);
    const exception = {
      type: ex && ex.name,
      value: extractMessage(ex)
    };
    if (frames.length) {
      exception.stacktrace = { frames };
    }
    if (exception.type === void 0 && exception.value === "") {
      exception.value = "Unrecoverable error caught";
    }
    return exception;
  }
  function eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {
    const client = getClient();
    const normalizeDepth = client && client.getOptions().normalizeDepth;
    const event = {
      exception: {
        values: [
          {
            type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
            value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection })
          }
        ]
      },
      extra: {
        __serialized__: normalizeToSize(exception, normalizeDepth)
      }
    };
    if (syntheticException) {
      const frames = parseStackFrames(stackParser, syntheticException);
      if (frames.length) {
        event.exception.values[0].stacktrace = { frames };
      }
    }
    return event;
  }
  function eventFromError(stackParser, ex) {
    return {
      exception: {
        values: [exceptionFromError(stackParser, ex)]
      }
    };
  }
  function parseStackFrames(stackParser, ex) {
    const stacktrace = ex.stacktrace || ex.stack || "";
    const popSize = getPopSize(ex);
    try {
      return stackParser(stacktrace, popSize);
    } catch (e2) {
    }
    return [];
  }
  const reactMinifiedRegexp = /Minified React error #\d+;/i;
  function getPopSize(ex) {
    if (ex) {
      if (typeof ex.framesToPop === "number") {
        return ex.framesToPop;
      }
      if (reactMinifiedRegexp.test(ex.message)) {
        return 1;
      }
    }
    return 0;
  }
  function extractMessage(ex) {
    const message = ex && ex.message;
    if (!message) {
      return "No error message";
    }
    if (message.error && typeof message.error.message === "string") {
      return message.error.message;
    }
    return message;
  }
  function eventFromException(stackParser, exception, hint, attachStacktrace) {
    const syntheticException = hint && hint.syntheticException || void 0;
    const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
    addExceptionMechanism(event);
    event.level = "error";
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
    const syntheticException = hint && hint.syntheticException || void 0;
    const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
    event.level = level;
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {
    let event;
    if (isErrorEvent$1(exception) && exception.error) {
      const errorEvent = exception;
      return eventFromError(stackParser, errorEvent.error);
    }
    if (isDOMError(exception) || isDOMException(exception)) {
      const domException = exception;
      if ("stack" in exception) {
        event = eventFromError(stackParser, exception);
      } else {
        const name = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
        const message = domException.message ? `${name}: ${domException.message}` : name;
        event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
        addExceptionTypeValue(event, message);
      }
      if ("code" in domException) {
        event.tags = { ...event.tags, "DOMException.code": `${domException.code}` };
      }
      return event;
    }
    if (isError$1(exception)) {
      return eventFromError(stackParser, exception);
    }
    if (isPlainObject$1(exception) || isEvent(exception)) {
      const objectException = exception;
      event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
      addExceptionMechanism(event, {
        synthetic: true
      });
      return event;
    }
    event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);
    addExceptionTypeValue(event, `${exception}`, void 0);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  function eventFromString(stackParser, message, syntheticException, attachStacktrace) {
    const event = {};
    if (attachStacktrace && syntheticException) {
      const frames = parseStackFrames(stackParser, syntheticException);
      if (frames.length) {
        event.exception = {
          values: [{ value: message, stacktrace: { frames } }]
        };
      }
    }
    if (isParameterizedString(message)) {
      const { __sentry_template_string__, __sentry_template_values__ } = message;
      event.logentry = {
        message: __sentry_template_string__,
        params: __sentry_template_values__
      };
      return event;
    }
    event.message = message;
    return event;
  }
  function getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }) {
    const keys2 = extractExceptionKeysForMessage(exception);
    const captureType = isUnhandledRejection ? "promise rejection" : "exception";
    if (isErrorEvent$1(exception)) {
      return `Event \`ErrorEvent\` captured as ${captureType} with message \`${exception.message}\``;
    }
    if (isEvent(exception)) {
      const className = getObjectClassName(exception);
      return `Event \`${className}\` (type=${exception.type}) captured as ${captureType}`;
    }
    return `Object captured as ${captureType} with keys: ${keys2}`;
  }
  function getObjectClassName(obj) {
    try {
      const prototype = Object.getPrototypeOf(obj);
      return prototype ? prototype.constructor.name : void 0;
    } catch (e2) {
    }
  }
  function createUserFeedbackEnvelope(feedback, {
    metadata,
    tunnel,
    dsn
  }) {
    const headers = {
      event_id: feedback.event_id,
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...metadata && metadata.sdk && {
        sdk: {
          name: metadata.sdk.name,
          version: metadata.sdk.version
        }
      },
      ...!!tunnel && !!dsn && { dsn: dsnToString(dsn) }
    };
    const item = createUserFeedbackEnvelopeItem(feedback);
    return createEnvelope(headers, [item]);
  }
  function createUserFeedbackEnvelopeItem(feedback) {
    const feedbackHeaders = {
      type: "user_report"
    };
    return [feedbackHeaders, feedback];
  }
  class BrowserClient extends BaseClient {
    /**
     * Creates a new Browser SDK instance.
     *
     * @param options Configuration options for this SDK.
     */
    constructor(options) {
      const sdkSource = WINDOW.SENTRY_SDK_SOURCE || getSDKSource();
      applySdkMetadata(options, "browser", ["browser"], sdkSource);
      super(options);
      if (options.sendClientReports && WINDOW.document) {
        WINDOW.document.addEventListener("visibilitychange", () => {
          if (WINDOW.document.visibilityState === "hidden") {
            this._flushOutcomes();
          }
        });
      }
    }
    /**
     * @inheritDoc
     */
    eventFromException(exception, hint) {
      return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
    }
    /**
     * @inheritDoc
     */
    eventFromMessage(message, level = "info", hint) {
      return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
    }
    /**
     * Sends user feedback to Sentry.
     */
    captureUserFeedback(feedback) {
      if (!this._isEnabled()) {
        DEBUG_BUILD && logger.warn("SDK not enabled, will not capture user feedback.");
        return;
      }
      const envelope = createUserFeedbackEnvelope(feedback, {
        metadata: this.getSdkMetadata(),
        dsn: this.getDsn(),
        tunnel: this.getOptions().tunnel
      });
      this._sendEnvelope(envelope);
    }
    /**
     * @inheritDoc
     */
    _prepareEvent(event, hint, scope) {
      event.platform = event.platform || "javascript";
      return super._prepareEvent(event, hint, scope);
    }
    /**
     * Sends client reports as an envelope.
     */
    _flushOutcomes() {
      const outcomes = this._clearOutcomes();
      if (outcomes.length === 0) {
        DEBUG_BUILD && logger.log("No outcomes to send");
        return;
      }
      if (!this._dsn) {
        DEBUG_BUILD && logger.log("No dsn provided, will not send outcomes");
        return;
      }
      DEBUG_BUILD && logger.log("Sending outcomes:", outcomes);
      const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
      this._sendEnvelope(envelope);
    }
  }
  let cachedFetchImpl = void 0;
  function getNativeFetchImplementation() {
    if (cachedFetchImpl) {
      return cachedFetchImpl;
    }
    if (isNativeFetch(WINDOW.fetch)) {
      return cachedFetchImpl = WINDOW.fetch.bind(WINDOW);
    }
    const document2 = WINDOW.document;
    let fetchImpl = WINDOW.fetch;
    if (document2 && typeof document2.createElement === "function") {
      try {
        const sandbox = document2.createElement("iframe");
        sandbox.hidden = true;
        document2.head.appendChild(sandbox);
        const contentWindow = sandbox.contentWindow;
        if (contentWindow && contentWindow.fetch) {
          fetchImpl = contentWindow.fetch;
        }
        document2.head.removeChild(sandbox);
      } catch (e2) {
        DEBUG_BUILD && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e2);
      }
    }
    return cachedFetchImpl = fetchImpl.bind(WINDOW);
  }
  function clearCachedFetchImplementation() {
    cachedFetchImpl = void 0;
  }
  function makeFetchTransport(options, nativeFetch = getNativeFetchImplementation()) {
    let pendingBodySize = 0;
    let pendingCount = 0;
    function makeRequest(request) {
      const requestSize = request.body.length;
      pendingBodySize += requestSize;
      pendingCount++;
      const requestOptions = {
        body: request.body,
        method: "POST",
        referrerPolicy: "origin",
        headers: options.headers,
        // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
        // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
        // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
        // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
        // Gotchas:
        // - `keepalive` isn't supported by Firefox
        // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
        //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
        //   We will therefore only activate the flag when we're below that limit.
        // There is also a limit of requests that can be open at the same time, so we also limit this to 15
        // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
        keepalive: pendingBodySize <= 6e4 && pendingCount < 15,
        ...options.fetchOptions
      };
      try {
        return nativeFetch(options.url, requestOptions).then((response) => {
          pendingBodySize -= requestSize;
          pendingCount--;
          return {
            statusCode: response.status,
            headers: {
              "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
              "retry-after": response.headers.get("Retry-After")
            }
          };
        });
      } catch (e2) {
        clearCachedFetchImplementation();
        pendingBodySize -= requestSize;
        pendingCount--;
        return rejectedSyncPromise(e2);
      }
    }
    return createTransport(options, makeRequest);
  }
  const XHR_READYSTATE_DONE = 4;
  function makeXHRTransport(options) {
    function makeRequest(request) {
      return new SyncPromise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.onerror = reject;
        xhr.onreadystatechange = () => {
          if (xhr.readyState === XHR_READYSTATE_DONE) {
            resolve({
              statusCode: xhr.status,
              headers: {
                "x-sentry-rate-limits": xhr.getResponseHeader("X-Sentry-Rate-Limits"),
                "retry-after": xhr.getResponseHeader("Retry-After")
              }
            });
          }
        };
        xhr.open("POST", options.url);
        for (const header in options.headers) {
          if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
            xhr.setRequestHeader(header, options.headers[header]);
          }
        }
        xhr.send(request.body);
      });
    }
    return createTransport(options, makeRequest);
  }
  const UNKNOWN_FUNCTION = "?";
  const CHROME_PRIORITY = 30;
  const WINJS_PRIORITY = 40;
  const GECKO_PRIORITY = 50;
  function createFrame(filename, func, lineno, colno) {
    const frame = {
      filename,
      function: func,
      in_app: true
      // All browser frames are considered in_app
    };
    if (lineno !== void 0) {
      frame.lineno = lineno;
    }
    if (colno !== void 0) {
      frame.colno = colno;
    }
    return frame;
  }
  const chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  const chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  const chromeStackParserFn = (line) => {
    const parts = chromeRegex.exec(line);
    if (parts) {
      const isEval = parts[2] && parts[2].indexOf("eval") === 0;
      if (isEval) {
        const subMatch = chromeEvalRegex.exec(parts[2]);
        if (subMatch) {
          parts[2] = subMatch[1];
          parts[3] = subMatch[2];
          parts[4] = subMatch[3];
        }
      }
      const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);
      return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
    }
    return;
  };
  const chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];
  const geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
  const geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  const gecko = (line) => {
    const parts = geckoREgex.exec(line);
    if (parts) {
      const isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
      if (isEval) {
        const subMatch = geckoEvalRegex.exec(parts[3]);
        if (subMatch) {
          parts[1] = parts[1] || "eval";
          parts[3] = subMatch[1];
          parts[4] = subMatch[2];
          parts[5] = "";
        }
      }
      let filename = parts[3];
      let func = parts[1] || UNKNOWN_FUNCTION;
      [func, filename] = extractSafariExtensionDetails(func, filename);
      return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
    }
    return;
  };
  const geckoStackLineParser = [GECKO_PRIORITY, gecko];
  const winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  const winjs = (line) => {
    const parts = winjsRegex.exec(line);
    return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
  };
  const winjsStackLineParser = [WINJS_PRIORITY, winjs];
  const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];
  const defaultStackParser = createStackParser(...defaultStackLineParsers);
  const extractSafariExtensionDetails = (func, filename) => {
    const isSafariExtension = func.indexOf("safari-extension") !== -1;
    const isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
    return isSafariExtension || isSafariWebExtension ? [
      func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
      isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`
    ] : [func, filename];
  };
  const MAX_ALLOWED_STRING_LENGTH = 1024;
  const INTEGRATION_NAME$5 = "Breadcrumbs";
  const _breadcrumbsIntegration = (options = {}) => {
    const _options = {
      console: true,
      dom: true,
      fetch: true,
      history: true,
      sentry: true,
      xhr: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME$5,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      setup(client) {
        if (_options.console) {
          addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(client));
        }
        if (_options.dom) {
          addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(client, _options.dom));
        }
        if (_options.xhr) {
          addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(client));
        }
        if (_options.fetch) {
          addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(client));
        }
        if (_options.history) {
          addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(client));
        }
        if (_options.sentry && client.on) {
          client.on("beforeSendEvent", _getSentryBreadcrumbHandler(client));
        }
      }
    };
  };
  const breadcrumbsIntegration = defineIntegration(_breadcrumbsIntegration);
  convertIntegrationFnToClass(INTEGRATION_NAME$5, breadcrumbsIntegration);
  function _getSentryBreadcrumbHandler(client) {
    return function addSentryBreadcrumb(event) {
      if (getClient() !== client) {
        return;
      }
      addBreadcrumb(
        {
          category: `sentry.${event.type === "transaction" ? "transaction" : "event"}`,
          event_id: event.event_id,
          level: event.level,
          message: getEventDescription(event)
        },
        {
          event
        }
      );
    };
  }
  function _getDomBreadcrumbHandler(client, dom) {
    return function _innerDomBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      let target;
      let componentName;
      let keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
      let maxStringLength = typeof dom === "object" && typeof dom.maxStringLength === "number" ? dom.maxStringLength : void 0;
      if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {
        DEBUG_BUILD && logger.warn(
          `\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`
        );
        maxStringLength = MAX_ALLOWED_STRING_LENGTH;
      }
      if (typeof keyAttrs === "string") {
        keyAttrs = [keyAttrs];
      }
      try {
        const event = handlerData.event;
        const element = _isEvent(event) ? event.target : event;
        target = htmlTreeAsString(element, { keyAttrs, maxStringLength });
        componentName = getComponentName(element);
      } catch (e2) {
        target = "<unknown>";
      }
      if (target.length === 0) {
        return;
      }
      const breadcrumb = {
        category: `ui.${handlerData.name}`,
        message: target
      };
      if (componentName) {
        breadcrumb.data = { "ui.component_name": componentName };
      }
      addBreadcrumb(breadcrumb, {
        event: handlerData.event,
        name: handlerData.name,
        global: handlerData.global
      });
    };
  }
  function _getConsoleBreadcrumbHandler(client) {
    return function _consoleBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      const breadcrumb = {
        category: "console",
        data: {
          arguments: handlerData.args,
          logger: "console"
        },
        level: severityLevelFromString(handlerData.level),
        message: safeJoin(handlerData.args, " ")
      };
      if (handlerData.level === "assert") {
        if (handlerData.args[0] === false) {
          breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), " ") || "console.assert"}`;
          breadcrumb.data.arguments = handlerData.args.slice(1);
        } else {
          return;
        }
      }
      addBreadcrumb(breadcrumb, {
        input: handlerData.args,
        level: handlerData.level
      });
    };
  }
  function _getXhrBreadcrumbHandler(client) {
    return function _xhrBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      const { startTimestamp, endTimestamp } = handlerData;
      const sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];
      if (!startTimestamp || !endTimestamp || !sentryXhrData) {
        return;
      }
      const { method, url, status_code, body } = sentryXhrData;
      const data = {
        method,
        url,
        status_code
      };
      const hint = {
        xhr: handlerData.xhr,
        input: body,
        startTimestamp,
        endTimestamp
      };
      addBreadcrumb(
        {
          category: "xhr",
          data,
          type: "http"
        },
        hint
      );
    };
  }
  function _getFetchBreadcrumbHandler(client) {
    return function _fetchBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      const { startTimestamp, endTimestamp } = handlerData;
      if (!endTimestamp) {
        return;
      }
      if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
        return;
      }
      if (handlerData.error) {
        const data = handlerData.fetchData;
        const hint = {
          data: handlerData.error,
          input: handlerData.args,
          startTimestamp,
          endTimestamp
        };
        addBreadcrumb(
          {
            category: "fetch",
            data,
            level: "error",
            type: "http"
          },
          hint
        );
      } else {
        const response = handlerData.response;
        const data = {
          ...handlerData.fetchData,
          status_code: response && response.status
        };
        const hint = {
          input: handlerData.args,
          response,
          startTimestamp,
          endTimestamp
        };
        addBreadcrumb(
          {
            category: "fetch",
            data,
            type: "http"
          },
          hint
        );
      }
    };
  }
  function _getHistoryBreadcrumbHandler(client) {
    return function _historyBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      let from = handlerData.from;
      let to2 = handlerData.to;
      const parsedLoc = parseUrl(WINDOW.location.href);
      let parsedFrom = from ? parseUrl(from) : void 0;
      const parsedTo = parseUrl(to2);
      if (!parsedFrom || !parsedFrom.path) {
        parsedFrom = parsedLoc;
      }
      if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
        to2 = parsedTo.relative;
      }
      if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
        from = parsedFrom.relative;
      }
      addBreadcrumb({
        category: "navigation",
        data: {
          from,
          to: to2
        }
      });
    };
  }
  function _isEvent(event) {
    return !!event && !!event.target;
  }
  const INTEGRATION_NAME$4 = "Dedupe";
  const _dedupeIntegration = () => {
    let previousEvent;
    return {
      name: INTEGRATION_NAME$4,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      processEvent(currentEvent) {
        if (currentEvent.type) {
          return currentEvent;
        }
        try {
          if (_shouldDropEvent(currentEvent, previousEvent)) {
            DEBUG_BUILD && logger.warn("Event dropped due to being a duplicate of previously captured event.");
            return null;
          }
        } catch (_oO) {
        }
        return previousEvent = currentEvent;
      }
    };
  };
  const dedupeIntegration = defineIntegration(_dedupeIntegration);
  convertIntegrationFnToClass(INTEGRATION_NAME$4, dedupeIntegration);
  function _shouldDropEvent(currentEvent, previousEvent) {
    if (!previousEvent) {
      return false;
    }
    if (_isSameMessageEvent(currentEvent, previousEvent)) {
      return true;
    }
    if (_isSameExceptionEvent(currentEvent, previousEvent)) {
      return true;
    }
    return false;
  }
  function _isSameMessageEvent(currentEvent, previousEvent) {
    const currentMessage = currentEvent.message;
    const previousMessage = previousEvent.message;
    if (!currentMessage && !previousMessage) {
      return false;
    }
    if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
      return false;
    }
    if (currentMessage !== previousMessage) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameExceptionEvent(currentEvent, previousEvent) {
    const previousException = _getExceptionFromEvent(previousEvent);
    const currentException = _getExceptionFromEvent(currentEvent);
    if (!previousException || !currentException) {
      return false;
    }
    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameStacktrace(currentEvent, previousEvent) {
    let currentFrames = _getFramesFromEvent(currentEvent);
    let previousFrames = _getFramesFromEvent(previousEvent);
    if (!currentFrames && !previousFrames) {
      return true;
    }
    if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
      return false;
    }
    currentFrames = currentFrames;
    previousFrames = previousFrames;
    if (previousFrames.length !== currentFrames.length) {
      return false;
    }
    for (let i2 = 0; i2 < previousFrames.length; i2++) {
      const frameA = previousFrames[i2];
      const frameB = currentFrames[i2];
      if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
        return false;
      }
    }
    return true;
  }
  function _isSameFingerprint(currentEvent, previousEvent) {
    let currentFingerprint = currentEvent.fingerprint;
    let previousFingerprint = previousEvent.fingerprint;
    if (!currentFingerprint && !previousFingerprint) {
      return true;
    }
    if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
      return false;
    }
    currentFingerprint = currentFingerprint;
    previousFingerprint = previousFingerprint;
    try {
      return !!(currentFingerprint.join("") === previousFingerprint.join(""));
    } catch (_oO) {
      return false;
    }
  }
  function _getExceptionFromEvent(event) {
    return event.exception && event.exception.values && event.exception.values[0];
  }
  function _getFramesFromEvent(event) {
    const exception = event.exception;
    if (exception) {
      try {
        return exception.values[0].stacktrace.frames;
      } catch (_oO) {
        return void 0;
      }
    }
    return void 0;
  }
  const INTEGRATION_NAME$3 = "GlobalHandlers";
  const _globalHandlersIntegration = (options = {}) => {
    const _options = {
      onerror: true,
      onunhandledrejection: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME$3,
      setupOnce() {
        Error.stackTraceLimit = 50;
      },
      setup(client) {
        if (_options.onerror) {
          _installGlobalOnErrorHandler(client);
          globalHandlerLog("onerror");
        }
        if (_options.onunhandledrejection) {
          _installGlobalOnUnhandledRejectionHandler(client);
          globalHandlerLog("onunhandledrejection");
        }
      }
    };
  };
  const globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);
  convertIntegrationFnToClass(
    INTEGRATION_NAME$3,
    globalHandlersIntegration
  );
  function _installGlobalOnErrorHandler(client) {
    addGlobalErrorInstrumentationHandler((data) => {
      const { stackParser, attachStacktrace } = getOptions();
      if (getClient() !== client || shouldIgnoreOnError()) {
        return;
      }
      const { msg, url, line, column, error: error2 } = data;
      const event = error2 === void 0 && isString$6(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(
        eventFromUnknownInput(stackParser, error2 || msg, void 0, attachStacktrace, false),
        url,
        line,
        column
      );
      event.level = "error";
      captureEvent(event, {
        originalException: error2,
        mechanism: {
          handled: false,
          type: "onerror"
        }
      });
    });
  }
  function _installGlobalOnUnhandledRejectionHandler(client) {
    addGlobalUnhandledRejectionInstrumentationHandler((e2) => {
      const { stackParser, attachStacktrace } = getOptions();
      if (getClient() !== client || shouldIgnoreOnError()) {
        return;
      }
      const error2 = _getUnhandledRejectionError(e2);
      const event = isPrimitive$2(error2) ? _eventFromRejectionWithPrimitive(error2) : eventFromUnknownInput(stackParser, error2, void 0, attachStacktrace, true);
      event.level = "error";
      captureEvent(event, {
        originalException: error2,
        mechanism: {
          handled: false,
          type: "onunhandledrejection"
        }
      });
    });
  }
  function _getUnhandledRejectionError(error2) {
    if (isPrimitive$2(error2)) {
      return error2;
    }
    const e2 = error2;
    try {
      if ("reason" in e2) {
        return e2.reason;
      } else if ("detail" in e2 && "reason" in e2.detail) {
        return e2.detail.reason;
      }
    } catch (e22) {
    }
    return error2;
  }
  function _eventFromRejectionWithPrimitive(reason) {
    return {
      exception: {
        values: [
          {
            type: "UnhandledRejection",
            // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
            value: `Non-Error promise rejection captured with value: ${String(reason)}`
          }
        ]
      }
    };
  }
  function _eventFromIncompleteOnError(msg, url, line, column) {
    const ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
    let message = isErrorEvent$1(msg) ? msg.message : msg;
    let name = "Error";
    const groups = message.match(ERROR_TYPES_RE);
    if (groups) {
      name = groups[1];
      message = groups[2];
    }
    const event = {
      exception: {
        values: [
          {
            type: name,
            value: message
          }
        ]
      }
    };
    return _enhanceEventWithInitialFrame(event, url, line, column);
  }
  function _enhanceEventWithInitialFrame(event, url, line, column) {
    const e2 = event.exception = event.exception || {};
    const ev = e2.values = e2.values || [];
    const ev0 = ev[0] = ev[0] || {};
    const ev0s = ev0.stacktrace = ev0.stacktrace || {};
    const ev0sf = ev0s.frames = ev0s.frames || [];
    const colno = isNaN(parseInt(column, 10)) ? void 0 : column;
    const lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
    const filename = isString$6(url) && url.length > 0 ? url : getLocationHref();
    if (ev0sf.length === 0) {
      ev0sf.push({
        colno,
        filename,
        function: "?",
        in_app: true,
        lineno
      });
    }
    return event;
  }
  function globalHandlerLog(type) {
    DEBUG_BUILD && logger.log(`Global Handler attached: ${type}`);
  }
  function getOptions() {
    const client = getClient();
    const options = client && client.getOptions() || {
      stackParser: () => [],
      attachStacktrace: false
    };
    return options;
  }
  const INTEGRATION_NAME$2 = "HttpContext";
  const _httpContextIntegration = () => {
    return {
      name: INTEGRATION_NAME$2,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      preprocessEvent(event) {
        if (!WINDOW.navigator && !WINDOW.location && !WINDOW.document) {
          return;
        }
        const url = event.request && event.request.url || WINDOW.location && WINDOW.location.href;
        const { referrer } = WINDOW.document || {};
        const { userAgent } = WINDOW.navigator || {};
        const headers = {
          ...event.request && event.request.headers,
          ...referrer && { Referer: referrer },
          ...userAgent && { "User-Agent": userAgent }
        };
        const request = { ...event.request, ...url && { url }, headers };
        event.request = request;
      }
    };
  };
  const httpContextIntegration = defineIntegration(_httpContextIntegration);
  convertIntegrationFnToClass(INTEGRATION_NAME$2, httpContextIntegration);
  const DEFAULT_KEY = "cause";
  const DEFAULT_LIMIT = 5;
  const INTEGRATION_NAME$1 = "LinkedErrors";
  const _linkedErrorsIntegration = (options = {}) => {
    const limit = options.limit || DEFAULT_LIMIT;
    const key = options.key || DEFAULT_KEY;
    return {
      name: INTEGRATION_NAME$1,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      preprocessEvent(event, hint, client) {
        const options2 = client.getOptions();
        applyAggregateErrorsToEvent(
          // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
          exceptionFromError,
          options2.stackParser,
          options2.maxValueLength,
          key,
          limit,
          event,
          hint
        );
      }
    };
  };
  const linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);
  convertIntegrationFnToClass(INTEGRATION_NAME$1, linkedErrorsIntegration);
  const DEFAULT_EVENT_TARGET = [
    "EventTarget",
    "Window",
    "Node",
    "ApplicationCache",
    "AudioTrackList",
    "BroadcastChannel",
    "ChannelMergerNode",
    "CryptoOperation",
    "EventSource",
    "FileReader",
    "HTMLUnknownElement",
    "IDBDatabase",
    "IDBRequest",
    "IDBTransaction",
    "KeyOperation",
    "MediaController",
    "MessagePort",
    "ModalWindow",
    "Notification",
    "SVGElementInstance",
    "Screen",
    "SharedWorker",
    "TextTrack",
    "TextTrackCue",
    "TextTrackList",
    "WebSocket",
    "WebSocketWorker",
    "Worker",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestUpload"
  ];
  const INTEGRATION_NAME = "TryCatch";
  const _browserApiErrorsIntegration = (options = {}) => {
    const _options = {
      XMLHttpRequest: true,
      eventTarget: true,
      requestAnimationFrame: true,
      setInterval: true,
      setTimeout: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME,
      // TODO: This currently only works for the first client this is setup
      // We may want to adjust this to check for client etc.
      setupOnce() {
        if (_options.setTimeout) {
          fill(WINDOW, "setTimeout", _wrapTimeFunction);
        }
        if (_options.setInterval) {
          fill(WINDOW, "setInterval", _wrapTimeFunction);
        }
        if (_options.requestAnimationFrame) {
          fill(WINDOW, "requestAnimationFrame", _wrapRAF);
        }
        if (_options.XMLHttpRequest && "XMLHttpRequest" in WINDOW) {
          fill(XMLHttpRequest.prototype, "send", _wrapXHR);
        }
        const eventTargetOption = _options.eventTarget;
        if (eventTargetOption) {
          const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
          eventTarget.forEach(_wrapEventTarget);
        }
      }
    };
  };
  const browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);
  convertIntegrationFnToClass(
    INTEGRATION_NAME,
    browserApiErrorsIntegration
  );
  function _wrapTimeFunction(original) {
    return function(...args) {
      const originalCallback = args[0];
      args[0] = wrap(originalCallback, {
        mechanism: {
          data: { function: getFunctionName(original) },
          handled: false,
          type: "instrument"
        }
      });
      return original.apply(this, args);
    };
  }
  function _wrapRAF(original) {
    return function(callback) {
      return original.apply(this, [
        wrap(callback, {
          mechanism: {
            data: {
              function: "requestAnimationFrame",
              handler: getFunctionName(original)
            },
            handled: false,
            type: "instrument"
          }
        })
      ]);
    };
  }
  function _wrapXHR(originalSend) {
    return function(...args) {
      const xhr = this;
      const xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
      xmlHttpRequestProps.forEach((prop) => {
        if (prop in xhr && typeof xhr[prop] === "function") {
          fill(xhr, prop, function(original) {
            const wrapOptions = {
              mechanism: {
                data: {
                  function: prop,
                  handler: getFunctionName(original)
                },
                handled: false,
                type: "instrument"
              }
            };
            const originalFunction = getOriginalFunction(original);
            if (originalFunction) {
              wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
            }
            return wrap(original, wrapOptions);
          });
        }
      });
      return originalSend.apply(this, args);
    };
  }
  function _wrapEventTarget(target) {
    const globalObject = WINDOW;
    const proto2 = globalObject[target] && globalObject[target].prototype;
    if (!proto2 || !proto2.hasOwnProperty || !proto2.hasOwnProperty("addEventListener")) {
      return;
    }
    fill(proto2, "addEventListener", function(original) {
      return function(eventName, fn, options) {
        try {
          if (typeof fn.handleEvent === "function") {
            fn.handleEvent = wrap(fn.handleEvent, {
              mechanism: {
                data: {
                  function: "handleEvent",
                  handler: getFunctionName(fn),
                  target
                },
                handled: false,
                type: "instrument"
              }
            });
          }
        } catch (err) {
        }
        return original.apply(this, [
          eventName,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          wrap(fn, {
            mechanism: {
              data: {
                function: "addEventListener",
                handler: getFunctionName(fn),
                target
              },
              handled: false,
              type: "instrument"
            }
          }),
          options
        ]);
      };
    });
    fill(
      proto2,
      "removeEventListener",
      function(originalRemoveEventListener) {
        return function(eventName, fn, options) {
          const wrappedEventHandler = fn;
          try {
            const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
            if (originalEventHandler) {
              originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
            }
          } catch (e2) {
          }
          return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
        };
      }
    );
  }
  const defaultIntegrations = [
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    browserApiErrorsIntegration(),
    breadcrumbsIntegration(),
    globalHandlersIntegration(),
    linkedErrorsIntegration(),
    dedupeIntegration(),
    httpContextIntegration()
  ];
  function getDefaultIntegrations(_options) {
    return [
      // eslint-disable-next-line deprecation/deprecation
      ...defaultIntegrations
    ];
  }
  function init$2(options = {}) {
    if (options.defaultIntegrations === void 0) {
      options.defaultIntegrations = getDefaultIntegrations();
    }
    if (options.release === void 0) {
      if (typeof __SENTRY_RELEASE__ === "string") {
        options.release = __SENTRY_RELEASE__;
      }
      if (WINDOW.SENTRY_RELEASE && WINDOW.SENTRY_RELEASE.id) {
        options.release = WINDOW.SENTRY_RELEASE.id;
      }
    }
    if (options.autoSessionTracking === void 0) {
      options.autoSessionTracking = true;
    }
    if (options.sendClientReports === void 0) {
      options.sendClientReports = true;
    }
    const clientOptions = {
      ...options,
      stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
      integrations: getIntegrationsToSetup(options),
      transport: options.transport || (supportsFetch() ? makeFetchTransport : makeXHRTransport)
    };
    initAndBind(BrowserClient, clientOptions);
    if (options.autoSessionTracking) {
      startSessionTracking();
    }
  }
  function startSessionTracking() {
    if (typeof WINDOW.document === "undefined") {
      DEBUG_BUILD && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
      return;
    }
    startSession({ ignoreDuration: true });
    captureSession();
    addHistoryInstrumentationHandler(({ from, to: to2 }) => {
      if (from !== void 0 && from !== to2) {
        startSession({ ignoreDuration: true });
        captureSession();
      }
    });
  }
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  function init$1(options) {
    const opts = {
      ...options
    };
    applySdkMetadata(opts, "react");
    init$2(opts);
  }
  var reactIs$1 = { exports: {} };
  var reactIs_production_min$1 = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$3 = b$1 ? Symbol.for("react.portal") : 60106, e$3 = b$1 ? Symbol.for("react.fragment") : 60107, f$5 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$2 = b$1 ? Symbol.for("react.profiler") : 60114, h$4 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$3 = b$1 ? Symbol.for("react.async_mode") : 60111, m$3 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$5 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$3 = b$1 ? Symbol.for("react.suspense") : 60113, q$3 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$5 = b$1 ? Symbol.for("react.memo") : 60115, t$3 = b$1 ? Symbol.for("react.lazy") : 60116, v$2 = b$1 ? Symbol.for("react.block") : 60121, w$2 = b$1 ? Symbol.for("react.fundamental") : 60117, x$3 = b$1 ? Symbol.for("react.responder") : 60118, y$4 = b$1 ? Symbol.for("react.scope") : 60119;
  function z$3(a) {
    if ("object" === typeof a && null !== a) {
      var u2 = a.$$typeof;
      switch (u2) {
        case c$1:
          switch (a = a.type, a) {
            case l$3:
            case m$3:
            case e$3:
            case g$2:
            case f$5:
            case p$3:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k$1:
                case n$5:
                case t$3:
                case r$5:
                case h$4:
                  return a;
                default:
                  return u2;
              }
          }
        case d$3:
          return u2;
      }
    }
  }
  function A$2(a) {
    return z$3(a) === m$3;
  }
  reactIs_production_min$1.AsyncMode = l$3;
  reactIs_production_min$1.ConcurrentMode = m$3;
  reactIs_production_min$1.ContextConsumer = k$1;
  reactIs_production_min$1.ContextProvider = h$4;
  reactIs_production_min$1.Element = c$1;
  reactIs_production_min$1.ForwardRef = n$5;
  reactIs_production_min$1.Fragment = e$3;
  reactIs_production_min$1.Lazy = t$3;
  reactIs_production_min$1.Memo = r$5;
  reactIs_production_min$1.Portal = d$3;
  reactIs_production_min$1.Profiler = g$2;
  reactIs_production_min$1.StrictMode = f$5;
  reactIs_production_min$1.Suspense = p$3;
  reactIs_production_min$1.isAsyncMode = function(a) {
    return A$2(a) || z$3(a) === l$3;
  };
  reactIs_production_min$1.isConcurrentMode = A$2;
  reactIs_production_min$1.isContextConsumer = function(a) {
    return z$3(a) === k$1;
  };
  reactIs_production_min$1.isContextProvider = function(a) {
    return z$3(a) === h$4;
  };
  reactIs_production_min$1.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c$1;
  };
  reactIs_production_min$1.isForwardRef = function(a) {
    return z$3(a) === n$5;
  };
  reactIs_production_min$1.isFragment = function(a) {
    return z$3(a) === e$3;
  };
  reactIs_production_min$1.isLazy = function(a) {
    return z$3(a) === t$3;
  };
  reactIs_production_min$1.isMemo = function(a) {
    return z$3(a) === r$5;
  };
  reactIs_production_min$1.isPortal = function(a) {
    return z$3(a) === d$3;
  };
  reactIs_production_min$1.isProfiler = function(a) {
    return z$3(a) === g$2;
  };
  reactIs_production_min$1.isStrictMode = function(a) {
    return z$3(a) === f$5;
  };
  reactIs_production_min$1.isSuspense = function(a) {
    return z$3(a) === p$3;
  };
  reactIs_production_min$1.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e$3 || a === m$3 || a === g$2 || a === f$5 || a === p$3 || a === q$3 || "object" === typeof a && null !== a && (a.$$typeof === t$3 || a.$$typeof === r$5 || a.$$typeof === h$4 || a.$$typeof === k$1 || a.$$typeof === n$5 || a.$$typeof === w$2 || a.$$typeof === x$3 || a.$$typeof === y$4 || a.$$typeof === v$2);
  };
  reactIs_production_min$1.typeOf = z$3;
  {
    reactIs$1.exports = reactIs_production_min$1;
  }
  var reactIsExports = reactIs$1.exports;
  var reactIs = reactIsExports;
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty$4 = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
  var getPrototypeOf$1 = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf$1(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys2 = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols$1) {
        keys2 = keys2.concat(getOwnPropertySymbols$1(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i2 = 0; i2 < keys2.length; ++i2) {
        var key = keys2[i2];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor$2(sourceComponent, key);
          try {
            defineProperty$4(targetComponent, key, descriptor);
          } catch (e2) {
          }
        }
      }
    }
    return targetComponent;
  }
  var hoistNonReactStatics_cjs = hoistNonReactStatics;
  const hoistNonReactStatics$1 = /* @__PURE__ */ getDefaultExportFromCjs(hoistNonReactStatics_cjs);
  var react = { exports: {} };
  var react_production_min = {};
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty$c = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject$1(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i2 = 0; i2 < 10; i2++) {
        test2["_" + String.fromCharCode(i2)] = i2;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
        return test2[n2];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to2 = toObject$1(target);
    var symbols;
    for (var s2 = 1; s2 < arguments.length; s2++) {
      from = Object(arguments[s2]);
      for (var key in from) {
        if (hasOwnProperty$c.call(from, key)) {
          to2[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i2 = 0; i2 < symbols.length; i2++) {
          if (propIsEnumerable.call(from, symbols[i2])) {
            to2[symbols[i2]] = from[symbols[i2]];
          }
        }
      }
    }
    return to2;
  };
  /** @license React v17.0.1
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var l$2 = objectAssign, n$4 = 60103, p$2 = 60106;
  react_production_min.Fragment = 60107;
  react_production_min.StrictMode = 60108;
  react_production_min.Profiler = 60114;
  var q$2 = 60109, r$4 = 60110, t$2 = 60112;
  react_production_min.Suspense = 60113;
  var u$1 = 60115, v$1 = 60116;
  if ("function" === typeof Symbol && Symbol.for) {
    var w$1 = Symbol.for;
    n$4 = w$1("react.element");
    p$2 = w$1("react.portal");
    react_production_min.Fragment = w$1("react.fragment");
    react_production_min.StrictMode = w$1("react.strict_mode");
    react_production_min.Profiler = w$1("react.profiler");
    q$2 = w$1("react.provider");
    r$4 = w$1("react.context");
    t$2 = w$1("react.forward_ref");
    react_production_min.Suspense = w$1("react.suspense");
    u$1 = w$1("react.memo");
    v$1 = w$1("react.lazy");
  }
  var x$2 = "function" === typeof Symbol && Symbol.iterator;
  function y$3(a) {
    if (null === a || "object" !== typeof a)
      return null;
    a = x$2 && a[x$2] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  function z$2(a) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
      b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var A$1 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, B$2 = {};
  function C$1(a, b2, c2) {
    this.props = a;
    this.context = b2;
    this.refs = B$2;
    this.updater = c2 || A$1;
  }
  C$1.prototype.isReactComponent = {};
  C$1.prototype.setState = function(a, b2) {
    if ("object" !== typeof a && "function" !== typeof a && null != a)
      throw Error(z$2(85));
    this.updater.enqueueSetState(this, a, b2, "setState");
  };
  C$1.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function D$2() {
  }
  D$2.prototype = C$1.prototype;
  function E$3(a, b2, c2) {
    this.props = a;
    this.context = b2;
    this.refs = B$2;
    this.updater = c2 || A$1;
  }
  var F$2 = E$3.prototype = new D$2();
  F$2.constructor = E$3;
  l$2(F$2, C$1.prototype);
  F$2.isPureReactComponent = true;
  var G$3 = { current: null }, H$2 = Object.prototype.hasOwnProperty, I$2 = { key: true, ref: true, __self: true, __source: true };
  function J$1(a, b2, c2) {
    var e2, d2 = {}, k2 = null, h2 = null;
    if (null != b2)
      for (e2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
        H$2.call(b2, e2) && !I$2.hasOwnProperty(e2) && (d2[e2] = b2[e2]);
    var g2 = arguments.length - 2;
    if (1 === g2)
      d2.children = c2;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
        f2[m2] = arguments[m2 + 2];
      d2.children = f2;
    }
    if (a && a.defaultProps)
      for (e2 in g2 = a.defaultProps, g2)
        void 0 === d2[e2] && (d2[e2] = g2[e2]);
    return { $$typeof: n$4, type: a, key: k2, ref: h2, props: d2, _owner: G$3.current };
  }
  function K$1(a, b2) {
    return { $$typeof: n$4, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function L(a) {
    return "object" === typeof a && null !== a && a.$$typeof === n$4;
  }
  function escape$1(a) {
    var b2 = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b2[a2];
    });
  }
  var M$1 = /\/+/g;
  function N$1(a, b2) {
    return "object" === typeof a && null !== a && null != a.key ? escape$1("" + a.key) : b2.toString(36);
  }
  function O$1(a, b2, c2, e2, d2) {
    var k2 = typeof a;
    if ("undefined" === k2 || "boolean" === k2)
      a = null;
    var h2 = false;
    if (null === a)
      h2 = true;
    else
      switch (k2) {
        case "string":
        case "number":
          h2 = true;
          break;
        case "object":
          switch (a.$$typeof) {
            case n$4:
            case p$2:
              h2 = true;
          }
      }
    if (h2)
      return h2 = a, d2 = d2(h2), a = "" === e2 ? "." + N$1(h2, 0) : e2, Array.isArray(d2) ? (c2 = "", null != a && (c2 = a.replace(M$1, "$&/") + "/"), O$1(d2, b2, c2, "", function(a2) {
        return a2;
      })) : null != d2 && (L(d2) && (d2 = K$1(d2, c2 + (!d2.key || h2 && h2.key === d2.key ? "" : ("" + d2.key).replace(M$1, "$&/") + "/") + a)), b2.push(d2)), 1;
    h2 = 0;
    e2 = "" === e2 ? "." : e2 + ":";
    if (Array.isArray(a))
      for (var g2 = 0; g2 < a.length; g2++) {
        k2 = a[g2];
        var f2 = e2 + N$1(k2, g2);
        h2 += O$1(k2, b2, c2, f2, d2);
      }
    else if (f2 = y$3(a), "function" === typeof f2)
      for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
        k2 = k2.value, f2 = e2 + N$1(k2, g2++), h2 += O$1(k2, b2, c2, f2, d2);
    else if ("object" === k2)
      throw b2 = "" + a, Error(z$2(31, "[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2));
    return h2;
  }
  function P$2(a, b2, c2) {
    if (null == a)
      return a;
    var e2 = [], d2 = 0;
    O$1(a, e2, "", "", function(a2) {
      return b2.call(c2, a2, d2++);
    });
    return e2;
  }
  function Q(a) {
    if (-1 === a._status) {
      var b2 = a._result;
      b2 = b2();
      a._status = 0;
      a._result = b2;
      b2.then(function(b3) {
        0 === a._status && (b3 = b3.default, a._status = 1, a._result = b3);
      }, function(b3) {
        0 === a._status && (a._status = 2, a._result = b3);
      });
    }
    if (1 === a._status)
      return a._result;
    throw a._result;
  }
  var R$1 = { current: null };
  function S$1() {
    var a = R$1.current;
    if (null === a)
      throw Error(z$2(321));
    return a;
  }
  var T$2 = { ReactCurrentDispatcher: R$1, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$3, IsSomeRendererActing: { current: false }, assign: l$2 };
  react_production_min.Children = { map: P$2, forEach: function(a, b2, c2) {
    P$2(a, function() {
      b2.apply(this, arguments);
    }, c2);
  }, count: function(a) {
    var b2 = 0;
    P$2(a, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a) {
    return P$2(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!L(a))
      throw Error(z$2(143));
    return a;
  } };
  react_production_min.Component = C$1;
  react_production_min.PureComponent = E$3;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$2;
  react_production_min.cloneElement = function(a, b2, c2) {
    if (null === a || void 0 === a)
      throw Error(z$2(267, a));
    var e2 = l$2({}, a.props), d2 = a.key, k2 = a.ref, h2 = a._owner;
    if (null != b2) {
      void 0 !== b2.ref && (k2 = b2.ref, h2 = G$3.current);
      void 0 !== b2.key && (d2 = "" + b2.key);
      if (a.type && a.type.defaultProps)
        var g2 = a.type.defaultProps;
      for (f2 in b2)
        H$2.call(b2, f2) && !I$2.hasOwnProperty(f2) && (e2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2)
      e2.children = c2;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++)
        g2[m2] = arguments[m2 + 2];
      e2.children = g2;
    }
    return {
      $$typeof: n$4,
      type: a.type,
      key: d2,
      ref: k2,
      props: e2,
      _owner: h2
    };
  };
  react_production_min.createContext = function(a, b2) {
    void 0 === b2 && (b2 = null);
    a = { $$typeof: r$4, _calculateChangedBits: b2, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
    a.Provider = { $$typeof: q$2, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = J$1;
  react_production_min.createFactory = function(a) {
    var b2 = J$1.bind(null, a);
    b2.type = a;
    return b2;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: t$2, render: a };
  };
  react_production_min.isValidElement = L;
  react_production_min.lazy = function(a) {
    return { $$typeof: v$1, _payload: { _status: -1, _result: a }, _init: Q };
  };
  react_production_min.memo = function(a, b2) {
    return { $$typeof: u$1, type: a, compare: void 0 === b2 ? null : b2 };
  };
  react_production_min.useCallback = function(a, b2) {
    return S$1().useCallback(a, b2);
  };
  react_production_min.useContext = function(a, b2) {
    return S$1().useContext(a, b2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useEffect = function(a, b2) {
    return S$1().useEffect(a, b2);
  };
  react_production_min.useImperativeHandle = function(a, b2, c2) {
    return S$1().useImperativeHandle(a, b2, c2);
  };
  react_production_min.useLayoutEffect = function(a, b2) {
    return S$1().useLayoutEffect(a, b2);
  };
  react_production_min.useMemo = function(a, b2) {
    return S$1().useMemo(a, b2);
  };
  react_production_min.useReducer = function(a, b2, c2) {
    return S$1().useReducer(a, b2, c2);
  };
  react_production_min.useRef = function(a) {
    return S$1().useRef(a);
  };
  react_production_min.useState = function(a) {
    return S$1().useState(a);
  };
  react_production_min.version = "17.0.1";
  {
    react.exports = react_production_min;
  }
  var reactExports = react.exports;
  const we$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
  const BROWSER_ALIASES_MAP = {
    "Amazon Silk": "amazon_silk",
    "Android Browser": "android",
    Bada: "bada",
    BlackBerry: "blackberry",
    Chrome: "chrome",
    Chromium: "chromium",
    Electron: "electron",
    Epiphany: "epiphany",
    Firefox: "firefox",
    Focus: "focus",
    Generic: "generic",
    "Google Search": "google_search",
    Googlebot: "googlebot",
    "Internet Explorer": "ie",
    "K-Meleon": "k_meleon",
    Maxthon: "maxthon",
    "Microsoft Edge": "edge",
    "MZ Browser": "mz",
    "NAVER Whale Browser": "naver",
    Opera: "opera",
    "Opera Coast": "opera_coast",
    PhantomJS: "phantomjs",
    Puffin: "puffin",
    QupZilla: "qupzilla",
    QQ: "qq",
    QQLite: "qqlite",
    Safari: "safari",
    Sailfish: "sailfish",
    "Samsung Internet for Android": "samsung_internet",
    SeaMonkey: "seamonkey",
    Sleipnir: "sleipnir",
    Swing: "swing",
    Tizen: "tizen",
    "UC Browser": "uc",
    Vivaldi: "vivaldi",
    "WebOS Browser": "webos",
    WeChat: "wechat",
    "Yandex Browser": "yandex",
    Roku: "roku"
  };
  const BROWSER_MAP = {
    amazon_silk: "Amazon Silk",
    android: "Android Browser",
    bada: "Bada",
    blackberry: "BlackBerry",
    chrome: "Chrome",
    chromium: "Chromium",
    electron: "Electron",
    epiphany: "Epiphany",
    firefox: "Firefox",
    focus: "Focus",
    generic: "Generic",
    googlebot: "Googlebot",
    google_search: "Google Search",
    ie: "Internet Explorer",
    k_meleon: "K-Meleon",
    maxthon: "Maxthon",
    edge: "Microsoft Edge",
    mz: "MZ Browser",
    naver: "NAVER Whale Browser",
    opera: "Opera",
    opera_coast: "Opera Coast",
    phantomjs: "PhantomJS",
    puffin: "Puffin",
    qupzilla: "QupZilla",
    qq: "QQ Browser",
    qqlite: "QQ Browser Lite",
    safari: "Safari",
    sailfish: "Sailfish",
    samsung_internet: "Samsung Internet for Android",
    seamonkey: "SeaMonkey",
    sleipnir: "Sleipnir",
    swing: "Swing",
    tizen: "Tizen",
    uc: "UC Browser",
    vivaldi: "Vivaldi",
    webos: "WebOS Browser",
    wechat: "WeChat",
    yandex: "Yandex Browser"
  };
  const PLATFORMS_MAP = {
    tablet: "tablet",
    mobile: "mobile",
    desktop: "desktop",
    tv: "tv"
  };
  const OS_MAP = {
    WindowsPhone: "Windows Phone",
    Windows: "Windows",
    MacOS: "macOS",
    iOS: "iOS",
    Android: "Android",
    WebOS: "WebOS",
    BlackBerry: "BlackBerry",
    Bada: "Bada",
    Tizen: "Tizen",
    Linux: "Linux",
    ChromeOS: "Chrome OS",
    PlayStation4: "PlayStation 4",
    Roku: "Roku"
  };
  const ENGINE_MAP = {
    EdgeHTML: "EdgeHTML",
    Blink: "Blink",
    Trident: "Trident",
    Presto: "Presto",
    Gecko: "Gecko",
    WebKit: "WebKit"
  };
  class Utils {
    /**
     * Get first matched item for a string
     * @param {RegExp} regexp
     * @param {String} ua
     * @return {Array|{index: number, input: string}|*|boolean|string}
     */
    static getFirstMatch(regexp, ua2) {
      const match2 = ua2.match(regexp);
      return match2 && match2.length > 0 && match2[1] || "";
    }
    /**
     * Get second matched item for a string
     * @param regexp
     * @param {String} ua
     * @return {Array|{index: number, input: string}|*|boolean|string}
     */
    static getSecondMatch(regexp, ua2) {
      const match2 = ua2.match(regexp);
      return match2 && match2.length > 1 && match2[2] || "";
    }
    /**
     * Match a regexp and return a constant or undefined
     * @param {RegExp} regexp
     * @param {String} ua
     * @param {*} _const Any const that will be returned if regexp matches the string
     * @return {*}
     */
    static matchAndReturnConst(regexp, ua2, _const) {
      if (regexp.test(ua2)) {
        return _const;
      }
      return void 0;
    }
    static getWindowsVersionName(version) {
      switch (version) {
        case "NT":
          return "NT";
        case "XP":
          return "XP";
        case "NT 5.0":
          return "2000";
        case "NT 5.1":
          return "XP";
        case "NT 5.2":
          return "2003";
        case "NT 6.0":
          return "Vista";
        case "NT 6.1":
          return "7";
        case "NT 6.2":
          return "8";
        case "NT 6.3":
          return "8.1";
        case "NT 10.0":
          return "10";
        default:
          return void 0;
      }
    }
    /**
     * Get macOS version name
     *    10.5 - Leopard
     *    10.6 - Snow Leopard
     *    10.7 - Lion
     *    10.8 - Mountain Lion
     *    10.9 - Mavericks
     *    10.10 - Yosemite
     *    10.11 - El Capitan
     *    10.12 - Sierra
     *    10.13 - High Sierra
     *    10.14 - Mojave
     *    10.15 - Catalina
     *
     * @example
     *   getMacOSVersionName("10.14") // 'Mojave'
     *
     * @param  {string} version
     * @return {string} versionName
     */
    static getMacOSVersionName(version) {
      const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
      v2.push(0);
      if (v2[0] !== 10)
        return void 0;
      switch (v2[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return void 0;
      }
    }
    /**
     * Get Android version name
     *    1.5 - Cupcake
     *    1.6 - Donut
     *    2.0 - Eclair
     *    2.1 - Eclair
     *    2.2 - Froyo
     *    2.x - Gingerbread
     *    3.x - Honeycomb
     *    4.0 - Ice Cream Sandwich
     *    4.1 - Jelly Bean
     *    4.4 - KitKat
     *    5.x - Lollipop
     *    6.x - Marshmallow
     *    7.x - Nougat
     *    8.x - Oreo
     *    9.x - Pie
     *
     * @example
     *   getAndroidVersionName("7.0") // 'Nougat'
     *
     * @param  {string} version
     * @return {string} versionName
     */
    static getAndroidVersionName(version) {
      const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
      v2.push(0);
      if (v2[0] === 1 && v2[1] < 5)
        return void 0;
      if (v2[0] === 1 && v2[1] < 6)
        return "Cupcake";
      if (v2[0] === 1 && v2[1] >= 6)
        return "Donut";
      if (v2[0] === 2 && v2[1] < 2)
        return "Eclair";
      if (v2[0] === 2 && v2[1] === 2)
        return "Froyo";
      if (v2[0] === 2 && v2[1] > 2)
        return "Gingerbread";
      if (v2[0] === 3)
        return "Honeycomb";
      if (v2[0] === 4 && v2[1] < 1)
        return "Ice Cream Sandwich";
      if (v2[0] === 4 && v2[1] < 4)
        return "Jelly Bean";
      if (v2[0] === 4 && v2[1] >= 4)
        return "KitKat";
      if (v2[0] === 5)
        return "Lollipop";
      if (v2[0] === 6)
        return "Marshmallow";
      if (v2[0] === 7)
        return "Nougat";
      if (v2[0] === 8)
        return "Oreo";
      if (v2[0] === 9)
        return "Pie";
      return void 0;
    }
    /**
     * Get version precisions count
     *
     * @example
     *   getVersionPrecision("1.10.3") // 3
     *
     * @param  {string} version
     * @return {number}
     */
    static getVersionPrecision(version) {
      return version.split(".").length;
    }
    /**
     * Calculate browser version weight
     *
     * @example
     *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
     *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
     *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
     *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
     *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
     *
     * @param {String} versionA versions versions to compare
     * @param {String} versionB versions versions to compare
     * @param {boolean} [isLoose] enable loose comparison
     * @return {Number} comparison result: -1 when versionA is lower,
     * 1 when versionA is bigger, 0 when both equal
     */
    /* eslint consistent-return: 1 */
    static compareVersions(versionA, versionB, isLoose = false) {
      const versionAPrecision = Utils.getVersionPrecision(versionA);
      const versionBPrecision = Utils.getVersionPrecision(versionB);
      let precision = Math.max(versionAPrecision, versionBPrecision);
      let lastPrecision = 0;
      const chunks = Utils.map([versionA, versionB], (version) => {
        const delta = precision - Utils.getVersionPrecision(version);
        const _version = version + new Array(delta + 1).join(".0");
        return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
      });
      if (isLoose) {
        lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
      }
      precision -= 1;
      while (precision >= lastPrecision) {
        if (chunks[0][precision] > chunks[1][precision]) {
          return 1;
        }
        if (chunks[0][precision] === chunks[1][precision]) {
          if (precision === lastPrecision) {
            return 0;
          }
          precision -= 1;
        } else if (chunks[0][precision] < chunks[1][precision]) {
          return -1;
        }
      }
      return void 0;
    }
    /**
     * Array::map polyfill
     *
     * @param  {Array} arr
     * @param  {Function} iterator
     * @return {Array}
     */
    static map(arr, iterator2) {
      const result2 = [];
      let i2;
      if (Array.prototype.map) {
        return Array.prototype.map.call(arr, iterator2);
      }
      for (i2 = 0; i2 < arr.length; i2 += 1) {
        result2.push(iterator2(arr[i2]));
      }
      return result2;
    }
    /**
     * Array::find polyfill
     *
     * @param  {Array} arr
     * @param  {Function} predicate
     * @return {Array}
     */
    static find(arr, predicate) {
      let i2;
      let l2;
      if (Array.prototype.find) {
        return Array.prototype.find.call(arr, predicate);
      }
      for (i2 = 0, l2 = arr.length; i2 < l2; i2 += 1) {
        const value = arr[i2];
        if (predicate(value, i2)) {
          return value;
        }
      }
      return void 0;
    }
    /**
     * Object::assign polyfill
     *
     * @param  {Object} obj
     * @param  {Object} ...objs
     * @return {Object}
     */
    static assign(obj, ...assigners) {
      const result2 = obj;
      let i2;
      let l2;
      if (Object.assign) {
        return Object.assign(obj, ...assigners);
      }
      for (i2 = 0, l2 = assigners.length; i2 < l2; i2 += 1) {
        const assigner = assigners[i2];
        if (typeof assigner === "object" && assigner !== null) {
          const keys2 = Object.keys(assigner);
          keys2.forEach((key) => {
            result2[key] = assigner[key];
          });
        }
      }
      return obj;
    }
    /**
     * Get short version/alias for a browser name
     *
     * @example
     *   getBrowserAlias('Microsoft Edge') // edge
     *
     * @param  {string} browserName
     * @return {string}
     */
    static getBrowserAlias(browserName) {
      return BROWSER_ALIASES_MAP[browserName];
    }
    /**
     * Get short version/alias for a browser name
     *
     * @example
     *   getBrowserAlias('edge') // Microsoft Edge
     *
     * @param  {string} browserAlias
     * @return {string}
     */
    static getBrowserTypeByAlias(browserAlias) {
      return BROWSER_MAP[browserAlias] || "";
    }
  }
  const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
  const browsersList = [
    /* Googlebot */
    {
      test: [/googlebot/i],
      describe(ua2) {
        const browser2 = {
          name: "Googlebot"
        };
        const version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Opera < 13.0 */
    {
      test: [/opera/i],
      describe(ua2) {
        const browser2 = {
          name: "Opera"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Opera > 13.0 */
    {
      test: [/opr\/|opios/i],
      describe(ua2) {
        const browser2 = {
          name: "Opera"
        };
        const version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/SamsungBrowser/i],
      describe(ua2) {
        const browser2 = {
          name: "Samsung Internet for Android"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/Whale/i],
      describe(ua2) {
        const browser2 = {
          name: "NAVER Whale Browser"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/MZBrowser/i],
      describe(ua2) {
        const browser2 = {
          name: "MZ Browser"
        };
        const version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/focus/i],
      describe(ua2) {
        const browser2 = {
          name: "Focus"
        };
        const version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/swing/i],
      describe(ua2) {
        const browser2 = {
          name: "Swing"
        };
        const version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/coast/i],
      describe(ua2) {
        const browser2 = {
          name: "Opera Coast"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/opt\/\d+(?:.?_?\d+)+/i],
      describe(ua2) {
        const browser2 = {
          name: "Opera Touch"
        };
        const version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/yabrowser/i],
      describe(ua2) {
        const browser2 = {
          name: "Yandex Browser"
        };
        const version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/ucbrowser/i],
      describe(ua2) {
        const browser2 = {
          name: "UC Browser"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/Maxthon|mxios/i],
      describe(ua2) {
        const browser2 = {
          name: "Maxthon"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/epiphany/i],
      describe(ua2) {
        const browser2 = {
          name: "Epiphany"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/puffin/i],
      describe(ua2) {
        const browser2 = {
          name: "Puffin"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/sleipnir/i],
      describe(ua2) {
        const browser2 = {
          name: "Sleipnir"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/k-meleon/i],
      describe(ua2) {
        const browser2 = {
          name: "K-Meleon"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/micromessenger/i],
      describe(ua2) {
        const browser2 = {
          name: "WeChat"
        };
        const version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/qqbrowser/i],
      describe(ua2) {
        const browser2 = {
          name: /qqbrowserlite/i.test(ua2) ? "QQ Browser Lite" : "QQ Browser"
        };
        const version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/msie|trident/i],
      describe(ua2) {
        const browser2 = {
          name: "Internet Explorer"
        };
        const version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/\sedg\//i],
      describe(ua2) {
        const browser2 = {
          name: "Microsoft Edge"
        };
        const version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/edg([ea]|ios)/i],
      describe(ua2) {
        const browser2 = {
          name: "Microsoft Edge"
        };
        const version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/vivaldi/i],
      describe(ua2) {
        const browser2 = {
          name: "Vivaldi"
        };
        const version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/seamonkey/i],
      describe(ua2) {
        const browser2 = {
          name: "SeaMonkey"
        };
        const version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/sailfish/i],
      describe(ua2) {
        const browser2 = {
          name: "Sailfish"
        };
        const version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/silk/i],
      describe(ua2) {
        const browser2 = {
          name: "Amazon Silk"
        };
        const version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/phantom/i],
      describe(ua2) {
        const browser2 = {
          name: "PhantomJS"
        };
        const version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/slimerjs/i],
      describe(ua2) {
        const browser2 = {
          name: "SlimerJS"
        };
        const version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(ua2) {
        const browser2 = {
          name: "BlackBerry"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/(web|hpw)[o0]s/i],
      describe(ua2) {
        const browser2 = {
          name: "WebOS Browser"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/bada/i],
      describe(ua2) {
        const browser2 = {
          name: "Bada"
        };
        const version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/tizen/i],
      describe(ua2) {
        const browser2 = {
          name: "Tizen"
        };
        const version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/qupzilla/i],
      describe(ua2) {
        const browser2 = {
          name: "QupZilla"
        };
        const version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/firefox|iceweasel|fxios/i],
      describe(ua2) {
        const browser2 = {
          name: "Firefox"
        };
        const version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/electron/i],
      describe(ua2) {
        const browser2 = {
          name: "Electron"
        };
        const version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/MiuiBrowser/i],
      describe(ua2) {
        const browser2 = {
          name: "Miui"
        };
        const version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/chromium/i],
      describe(ua2) {
        const browser2 = {
          name: "Chromium"
        };
        const version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/chrome|crios|crmo/i],
      describe(ua2) {
        const browser2 = {
          name: "Chrome"
        };
        const version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/GSA/i],
      describe(ua2) {
        const browser2 = {
          name: "Google Search"
        };
        const version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Android Browser */
    {
      test(parser) {
        const notLikeAndroid = !parser.test(/like android/i);
        const butAndroid = parser.test(/android/i);
        return notLikeAndroid && butAndroid;
      },
      describe(ua2) {
        const browser2 = {
          name: "Android Browser"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* PlayStation 4 */
    {
      test: [/playstation 4/i],
      describe(ua2) {
        const browser2 = {
          name: "PlayStation 4"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Safari */
    {
      test: [/safari|applewebkit/i],
      describe(ua2) {
        const browser2 = {
          name: "Safari"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua2);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Something else */
    {
      test: [/.*/i],
      describe(ua2) {
        const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
        const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
        const hasDeviceSpec = ua2.search("\\(") !== -1;
        const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
        return {
          name: Utils.getFirstMatch(regexp, ua2),
          version: Utils.getSecondMatch(regexp, ua2)
        };
      }
    }
  ];
  const osParsersList = [
    /* Roku */
    {
      test: [/Roku\/DVP/],
      describe(ua2) {
        const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua2);
        return {
          name: OS_MAP.Roku,
          version
        };
      }
    },
    /* Windows Phone */
    {
      test: [/windows phone/i],
      describe(ua2) {
        const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua2);
        return {
          name: OS_MAP.WindowsPhone,
          version
        };
      }
    },
    /* Windows */
    {
      test: [/windows /i],
      describe(ua2) {
        const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua2);
        const versionName = Utils.getWindowsVersionName(version);
        return {
          name: OS_MAP.Windows,
          version,
          versionName
        };
      }
    },
    /* Firefox on iPad */
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe(ua2) {
        const result2 = {
          name: OS_MAP.iOS
        };
        const version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua2);
        if (version) {
          result2.version = version;
        }
        return result2;
      }
    },
    /* macOS */
    {
      test: [/macintosh/i],
      describe(ua2) {
        const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua2).replace(/[_\s]/g, ".");
        const versionName = Utils.getMacOSVersionName(version);
        const os2 = {
          name: OS_MAP.MacOS,
          version
        };
        if (versionName) {
          os2.versionName = versionName;
        }
        return os2;
      }
    },
    /* iOS */
    {
      test: [/(ipod|iphone|ipad)/i],
      describe(ua2) {
        const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua2).replace(/[_\s]/g, ".");
        return {
          name: OS_MAP.iOS,
          version
        };
      }
    },
    /* Android */
    {
      test(parser) {
        const notLikeAndroid = !parser.test(/like android/i);
        const butAndroid = parser.test(/android/i);
        return notLikeAndroid && butAndroid;
      },
      describe(ua2) {
        const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua2);
        const versionName = Utils.getAndroidVersionName(version);
        const os2 = {
          name: OS_MAP.Android,
          version
        };
        if (versionName) {
          os2.versionName = versionName;
        }
        return os2;
      }
    },
    /* WebOS */
    {
      test: [/(web|hpw)[o0]s/i],
      describe(ua2) {
        const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua2);
        const os2 = {
          name: OS_MAP.WebOS
        };
        if (version && version.length) {
          os2.version = version;
        }
        return os2;
      }
    },
    /* BlackBerry */
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(ua2) {
        const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua2) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua2) || Utils.getFirstMatch(/\bbb(\d+)/i, ua2);
        return {
          name: OS_MAP.BlackBerry,
          version
        };
      }
    },
    /* Bada */
    {
      test: [/bada/i],
      describe(ua2) {
        const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua2);
        return {
          name: OS_MAP.Bada,
          version
        };
      }
    },
    /* Tizen */
    {
      test: [/tizen/i],
      describe(ua2) {
        const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua2);
        return {
          name: OS_MAP.Tizen,
          version
        };
      }
    },
    /* Linux */
    {
      test: [/linux/i],
      describe() {
        return {
          name: OS_MAP.Linux
        };
      }
    },
    /* Chrome OS */
    {
      test: [/CrOS/],
      describe() {
        return {
          name: OS_MAP.ChromeOS
        };
      }
    },
    /* Playstation 4 */
    {
      test: [/PlayStation 4/],
      describe(ua2) {
        const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua2);
        return {
          name: OS_MAP.PlayStation4,
          version
        };
      }
    }
  ];
  const platformParsersList = [
    /* Googlebot */
    {
      test: [/googlebot/i],
      describe() {
        return {
          type: "bot",
          vendor: "Google"
        };
      }
    },
    /* Huawei */
    {
      test: [/huawei/i],
      describe(ua2) {
        const model = Utils.getFirstMatch(/(can-l01)/i, ua2) && "Nova";
        const platform = {
          type: PLATFORMS_MAP.mobile,
          vendor: "Huawei"
        };
        if (model) {
          platform.model = model;
        }
        return platform;
      }
    },
    /* Nexus Tablet */
    {
      test: [/nexus\s*(?:7|8|9|10).*/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Nexus"
        };
      }
    },
    /* iPad */
    {
      test: [/ipad/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Apple",
          model: "iPad"
        };
      }
    },
    /* Firefox on iPad */
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Apple",
          model: "iPad"
        };
      }
    },
    /* Amazon Kindle Fire */
    {
      test: [/kftt build/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Amazon",
          model: "Kindle Fire HD 7"
        };
      }
    },
    /* Another Amazon Tablet with Silk */
    {
      test: [/silk/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Amazon"
        };
      }
    },
    /* Tablet */
    {
      test: [/tablet(?! pc)/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet
        };
      }
    },
    /* iPod/iPhone */
    {
      test(parser) {
        const iDevice = parser.test(/ipod|iphone/i);
        const likeIDevice = parser.test(/like (ipod|iphone)/i);
        return iDevice && !likeIDevice;
      },
      describe(ua2) {
        const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua2);
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: "Apple",
          model
        };
      }
    },
    /* Nexus Mobile */
    {
      test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: "Nexus"
        };
      }
    },
    /* Mobile */
    {
      test: [/[^-]mobi/i],
      describe() {
        return {
          type: PLATFORMS_MAP.mobile
        };
      }
    },
    /* BlackBerry */
    {
      test(parser) {
        return parser.getBrowserName(true) === "blackberry";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: "BlackBerry"
        };
      }
    },
    /* Bada */
    {
      test(parser) {
        return parser.getBrowserName(true) === "bada";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile
        };
      }
    },
    /* Windows Phone */
    {
      test(parser) {
        return parser.getBrowserName() === "windows phone";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: "Microsoft"
        };
      }
    },
    /* Android Tablet */
    {
      test(parser) {
        const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
        return parser.getOSName(true) === "android" && osMajorVersion >= 3;
      },
      describe() {
        return {
          type: PLATFORMS_MAP.tablet
        };
      }
    },
    /* Android Mobile */
    {
      test(parser) {
        return parser.getOSName(true) === "android";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile
        };
      }
    },
    /* desktop */
    {
      test(parser) {
        return parser.getOSName(true) === "macos";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.desktop,
          vendor: "Apple"
        };
      }
    },
    /* Windows */
    {
      test(parser) {
        return parser.getOSName(true) === "windows";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.desktop
        };
      }
    },
    /* Linux */
    {
      test(parser) {
        return parser.getOSName(true) === "linux";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.desktop
        };
      }
    },
    /* PlayStation 4 */
    {
      test(parser) {
        return parser.getOSName(true) === "playstation 4";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.tv
        };
      }
    },
    /* Roku */
    {
      test(parser) {
        return parser.getOSName(true) === "roku";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.tv
        };
      }
    }
  ];
  const enginesParsersList = [
    /* EdgeHTML */
    {
      test(parser) {
        return parser.getBrowserName(true) === "microsoft edge";
      },
      describe(ua2) {
        const isBlinkBased = /\sedg\//i.test(ua2);
        if (isBlinkBased) {
          return {
            name: ENGINE_MAP.Blink
          };
        }
        const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua2);
        return {
          name: ENGINE_MAP.EdgeHTML,
          version
        };
      }
    },
    /* Trident */
    {
      test: [/trident/i],
      describe(ua2) {
        const engine = {
          name: ENGINE_MAP.Trident
        };
        const version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          engine.version = version;
        }
        return engine;
      }
    },
    /* Presto */
    {
      test(parser) {
        return parser.test(/presto/i);
      },
      describe(ua2) {
        const engine = {
          name: ENGINE_MAP.Presto
        };
        const version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          engine.version = version;
        }
        return engine;
      }
    },
    /* Gecko */
    {
      test(parser) {
        const isGecko = parser.test(/gecko/i);
        const likeGecko = parser.test(/like gecko/i);
        return isGecko && !likeGecko;
      },
      describe(ua2) {
        const engine = {
          name: ENGINE_MAP.Gecko
        };
        const version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          engine.version = version;
        }
        return engine;
      }
    },
    /* Blink */
    {
      test: [/(apple)?webkit\/537\.36/i],
      describe() {
        return {
          name: ENGINE_MAP.Blink
        };
      }
    },
    /* WebKit */
    {
      test: [/(apple)?webkit/i],
      describe(ua2) {
        const engine = {
          name: ENGINE_MAP.WebKit
        };
        const version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua2);
        if (version) {
          engine.version = version;
        }
        return engine;
      }
    }
  ];
  class Parser {
    /**
     * Create instance of Parser
     *
     * @param {String} UA User-Agent string
     * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
     * improvements if you need to make a more particular parsing
     * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
     *
     * @throw {Error} in case of empty UA String
     *
     * @constructor
     */
    constructor(UA, skipParsing = false) {
      if (UA === void 0 || UA === null || UA === "") {
        throw new Error("UserAgent parameter can't be empty");
      }
      this._ua = UA;
      this.parsedResult = {};
      if (skipParsing !== true) {
        this.parse();
      }
    }
    /**
     * Get UserAgent string of current Parser instance
     * @return {String} User-Agent String of the current <Parser> object
     *
     * @public
     */
    getUA() {
      return this._ua;
    }
    /**
     * Test a UA string for a regexp
     * @param {RegExp} regex
     * @return {Boolean}
     */
    test(regex2) {
      return regex2.test(this._ua);
    }
    /**
     * Get parsed browser object
     * @return {Object}
     */
    parseBrowser() {
      this.parsedResult.browser = {};
      const browserDescriptor = Utils.find(browsersList, (_browser) => {
        if (typeof _browser.test === "function") {
          return _browser.test(this);
        }
        if (_browser.test instanceof Array) {
          return _browser.test.some((condition) => this.test(condition));
        }
        throw new Error("Browser's test function is not valid");
      });
      if (browserDescriptor) {
        this.parsedResult.browser = browserDescriptor.describe(this.getUA());
      }
      return this.parsedResult.browser;
    }
    /**
     * Get parsed browser object
     * @return {Object}
     *
     * @public
     */
    getBrowser() {
      if (this.parsedResult.browser) {
        return this.parsedResult.browser;
      }
      return this.parseBrowser();
    }
    /**
     * Get browser's name
     * @return {String} Browser's name or an empty string
     *
     * @public
     */
    getBrowserName(toLowerCase) {
      if (toLowerCase) {
        return String(this.getBrowser().name).toLowerCase() || "";
      }
      return this.getBrowser().name || "";
    }
    /**
     * Get browser's version
     * @return {String} version of browser
     *
     * @public
     */
    getBrowserVersion() {
      return this.getBrowser().version;
    }
    /**
     * Get OS
     * @return {Object}
     *
     * @example
     * this.getOS();
     * {
     *   name: 'macOS',
     *   version: '10.11.12'
     * }
     */
    getOS() {
      if (this.parsedResult.os) {
        return this.parsedResult.os;
      }
      return this.parseOS();
    }
    /**
     * Parse OS and save it to this.parsedResult.os
     * @return {*|{}}
     */
    parseOS() {
      this.parsedResult.os = {};
      const os2 = Utils.find(osParsersList, (_os) => {
        if (typeof _os.test === "function") {
          return _os.test(this);
        }
        if (_os.test instanceof Array) {
          return _os.test.some((condition) => this.test(condition));
        }
        throw new Error("Browser's test function is not valid");
      });
      if (os2) {
        this.parsedResult.os = os2.describe(this.getUA());
      }
      return this.parsedResult.os;
    }
    /**
     * Get OS name
     * @param {Boolean} [toLowerCase] return lower-cased value
     * @return {String} name of the OS  macOS, Windows, Linux, etc.
     */
    getOSName(toLowerCase) {
      const { name } = this.getOS();
      if (toLowerCase) {
        return String(name).toLowerCase() || "";
      }
      return name || "";
    }
    /**
     * Get OS version
     * @return {String} full version with dots ('10.11.12', '5.6', etc)
     */
    getOSVersion() {
      return this.getOS().version;
    }
    /**
     * Get parsed platform
     * @return {{}}
     */
    getPlatform() {
      if (this.parsedResult.platform) {
        return this.parsedResult.platform;
      }
      return this.parsePlatform();
    }
    /**
     * Get platform name
     * @param {Boolean} [toLowerCase=false]
     * @return {*}
     */
    getPlatformType(toLowerCase = false) {
      const { type } = this.getPlatform();
      if (toLowerCase) {
        return String(type).toLowerCase() || "";
      }
      return type || "";
    }
    /**
     * Get parsed platform
     * @return {{}}
     */
    parsePlatform() {
      this.parsedResult.platform = {};
      const platform = Utils.find(platformParsersList, (_platform) => {
        if (typeof _platform.test === "function") {
          return _platform.test(this);
        }
        if (_platform.test instanceof Array) {
          return _platform.test.some((condition) => this.test(condition));
        }
        throw new Error("Browser's test function is not valid");
      });
      if (platform) {
        this.parsedResult.platform = platform.describe(this.getUA());
      }
      return this.parsedResult.platform;
    }
    /**
     * Get parsed engine
     * @return {{}}
     */
    getEngine() {
      if (this.parsedResult.engine) {
        return this.parsedResult.engine;
      }
      return this.parseEngine();
    }
    /**
     * Get engines's name
     * @return {String} Engines's name or an empty string
     *
     * @public
     */
    getEngineName(toLowerCase) {
      if (toLowerCase) {
        return String(this.getEngine().name).toLowerCase() || "";
      }
      return this.getEngine().name || "";
    }
    /**
     * Get parsed platform
     * @return {{}}
     */
    parseEngine() {
      this.parsedResult.engine = {};
      const engine = Utils.find(enginesParsersList, (_engine) => {
        if (typeof _engine.test === "function") {
          return _engine.test(this);
        }
        if (_engine.test instanceof Array) {
          return _engine.test.some((condition) => this.test(condition));
        }
        throw new Error("Browser's test function is not valid");
      });
      if (engine) {
        this.parsedResult.engine = engine.describe(this.getUA());
      }
      return this.parsedResult.engine;
    }
    /**
     * Parse full information about the browser
     * @returns {Parser}
     */
    parse() {
      this.parseBrowser();
      this.parseOS();
      this.parsePlatform();
      this.parseEngine();
      return this;
    }
    /**
     * Get parsed result
     * @return {ParsedResult}
     */
    getResult() {
      return Utils.assign({}, this.parsedResult);
    }
    /**
     * Check if parsed browser matches certain conditions
     *
     * @param {Object} checkTree It's one or two layered object,
     * which can include a platform or an OS on the first layer
     * and should have browsers specs on the bottom-laying layer
     *
     * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
     * Returns `undefined` when the browser is no described in the checkTree object.
     *
     * @example
     * const browser = Bowser.getParser(window.navigator.userAgent);
     * if (browser.satisfies({chrome: '>118.01.1322' }))
     * // or with os
     * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
     * // or with platforms
     * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
     */
    satisfies(checkTree) {
      const platformsAndOSes = {};
      let platformsAndOSCounter = 0;
      const browsers = {};
      let browsersCounter = 0;
      const allDefinitions = Object.keys(checkTree);
      allDefinitions.forEach((key) => {
        const currentDefinition = checkTree[key];
        if (typeof currentDefinition === "string") {
          browsers[key] = currentDefinition;
          browsersCounter += 1;
        } else if (typeof currentDefinition === "object") {
          platformsAndOSes[key] = currentDefinition;
          platformsAndOSCounter += 1;
        }
      });
      if (platformsAndOSCounter > 0) {
        const platformsAndOSNames = Object.keys(platformsAndOSes);
        const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
        if (OSMatchingDefinition) {
          const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
          if (osResult !== void 0) {
            return osResult;
          }
        }
        const platformMatchingDefinition = Utils.find(
          platformsAndOSNames,
          (name) => this.isPlatform(name)
        );
        if (platformMatchingDefinition) {
          const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
          if (platformResult !== void 0) {
            return platformResult;
          }
        }
      }
      if (browsersCounter > 0) {
        const browserNames = Object.keys(browsers);
        const matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, true));
        if (matchingDefinition !== void 0) {
          return this.compareVersion(browsers[matchingDefinition]);
        }
      }
      return void 0;
    }
    /**
     * Check if the browser name equals the passed string
     * @param browserName The string to compare with the browser name
     * @param [includingAlias=false] The flag showing whether alias will be included into comparison
     * @returns {boolean}
     */
    isBrowser(browserName, includingAlias = false) {
      const defaultBrowserName = this.getBrowserName().toLowerCase();
      let browserNameLower = browserName.toLowerCase();
      const alias = Utils.getBrowserTypeByAlias(browserNameLower);
      if (includingAlias && alias) {
        browserNameLower = alias.toLowerCase();
      }
      return browserNameLower === defaultBrowserName;
    }
    compareVersion(version) {
      let expectedResults = [0];
      let comparableVersion = version;
      let isLoose = false;
      const currentBrowserVersion = this.getBrowserVersion();
      if (typeof currentBrowserVersion !== "string") {
        return void 0;
      }
      if (version[0] === ">" || version[0] === "<") {
        comparableVersion = version.substr(1);
        if (version[1] === "=") {
          isLoose = true;
          comparableVersion = version.substr(2);
        } else {
          expectedResults = [];
        }
        if (version[0] === ">") {
          expectedResults.push(1);
        } else {
          expectedResults.push(-1);
        }
      } else if (version[0] === "=") {
        comparableVersion = version.substr(1);
      } else if (version[0] === "~") {
        isLoose = true;
        comparableVersion = version.substr(1);
      }
      return expectedResults.indexOf(
        Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
      ) > -1;
    }
    isOS(osName) {
      return this.getOSName(true) === String(osName).toLowerCase();
    }
    isPlatform(platformType) {
      return this.getPlatformType(true) === String(platformType).toLowerCase();
    }
    isEngine(engineName) {
      return this.getEngineName(true) === String(engineName).toLowerCase();
    }
    /**
     * Is anything? Check if the browser is called "anything",
     * the OS called "anything" or the platform called "anything"
     * @param {String} anything
     * @param [includingAlias=false] The flag showing whether alias will be included into comparison
     * @returns {Boolean}
     */
    is(anything, includingAlias = false) {
      return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
    }
    /**
     * Check if any of the given values satisfies this.is(anything)
     * @param {String[]} anythings
     * @returns {Boolean}
     */
    some(anythings = []) {
      return anythings.some((anything) => this.is(anything));
    }
  }
  /*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   */
  class Bowser {
    /**
     * Creates a {@link Parser} instance
     *
     * @param {String} UA UserAgent string
     * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
     * explicitly. Same as `skipParsing` for {@link Parser}.
     * @returns {Parser}
     * @throws {Error} when UA is not a String
     *
     * @example
     * const parser = Bowser.getParser(window.navigator.userAgent);
     * const result = parser.getResult();
     */
    static getParser(UA, skipParsing = false) {
      if (typeof UA !== "string") {
        throw new Error("UserAgent should be a string");
      }
      return new Parser(UA, skipParsing);
    }
    /**
     * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
     *
     * @param UA
     * @return {ParsedResult}
     *
     * @example
     * const result = Bowser.parse(window.navigator.userAgent);
     */
    static parse(UA) {
      return new Parser(UA).getResult();
    }
    static get BROWSER_MAP() {
      return BROWSER_MAP;
    }
    static get ENGINE_MAP() {
      return ENGINE_MAP;
    }
    static get OS_MAP() {
      return OS_MAP;
    }
    static get PLATFORMS_MAP() {
      return PLATFORMS_MAP;
    }
  }
  function isWebExtError(obj, ...errorTypes) {
    const message = getMessage(obj);
    if (message === void 0) {
      return false;
    }
    return errorTypes.some((errorType) => {
      const matcher = ERRORS[errorType];
      return typeof matcher === "string" ? matcher === message : matcher.test(message);
    });
  }
  function hasMessageProperty(obj) {
    return typeof obj === "object" && obj !== null && "message" in obj && typeof obj.message === "string";
  }
  function getMessage(obj) {
    if (typeof obj === "string") {
      return obj;
    }
    if (hasMessageProperty(obj)) {
      return obj.message;
    }
    return void 0;
  }
  const ERRORS = {
    // Happens in content scripts on sending messages, after the extension has been unloaded (e.g.
    // during update or uninstall).
    CONTEXT_INVALIDATED: "Extension context invalidated.",
    TAB_DRAG_IN_PROGRESS: "Tabs cannot be edited right now (user may be dragging a tab).",
    COULD_NOT_ESTABLISH_CONNECTION: "Could not establish connection. Receiving end does not exist.",
    MISSING_HOST_PERMISSION_FOR_TAB: "Missing host permission for the tab",
    TAB_CLOSED: "The tab was closed.",
    NO_TAB_WITH_ID: /^No tab with id: \d+\.$/,
    // Chrome
    INVALID_TAB_ID: /^Invalid tab ID: \d+$/,
    // Firefox
    ACTIVE_TAB_PERMISSION_NOT_IN_EFFECT: "The 'activeTab' permission is not in effect because this extension has not been in invoked.",
    CAPTURE_TAB_IMAGE_READBACK_FAILED: "Failed to capture tab: image readback failed",
    CANNOT_ACCESS_CONTENTS_OF_URL: 'Cannot access contents of url "". Extension manifest must request permission to access this host.',
    ALL_URLS_OR_ACTIVE_TAB_PERMISSION_REQUIRED: "Either the '<all_urls>' or 'activeTab' permission is required.",
    UNEXPECTED_ERROR: "An unexpected error occurred",
    ERROR_CAPTURING_VISIBLE_TAB: "Error capturing visible tab.",
    INVALID_VALUE_FOR_BOUNDS: "Invalid value for bounds. Bounds must be at least 50% within visible screen space.",
    CLOSED_BEFORE_RESPONSE_RECEIVED: "A listener indicated an asynchronous response by returning true, but the message channel closed before a response was received",
    PERMISSION_ERROR: "Invalid call to tabs.captureVisibleTab(). Either the 'activeTab' permission or granted host permissions for the current website are required."
  };
  content;
  function isMessageResponseEnvelope(response) {
    return typeof response === "object" && response !== null;
  }
  const messageError = Symbol("messageError");
  async function sendMessage(m2) {
    return doSendMessage(() => browser$1.runtime.sendMessage(m2));
  }
  async function doSendMessage(send) {
    try {
      const response = await send();
      if (response === null || response === void 0) {
        return messageError;
      }
      if (isMessageResponseEnvelope(response)) {
        return response.value;
      }
      trackError(new Error(`Received unexpected response sending message: ${JSON.stringify(response)}`));
      return messageError;
    } catch (e2) {
      reportMessageError(e2);
      return messageError;
    }
  }
  function makeMessageListener(handlers2) {
    return (msg, sender) => {
      const handler = handlers2[msg.type];
      if (handler) {
        try {
          return (async () => {
            const value = await handler(msg, sender);
            return {
              value
            };
          })();
        } catch (e2) {
          reportMessageError(e2);
        }
      }
      return void 0;
    };
  }
  const IGNORED_ERROR_MESSAGES = [
    // happens when the other side goes away unexpectedly (e.g. tab close)
    "COULD_NOT_ESTABLISH_CONNECTION",
    // for urls on which extensions are never allowed to run (e.g. chrome://*, some about:* pages)
    "MISSING_HOST_PERMISSION_FOR_TAB",
    // Sending message to tab that was closed in the meantime
    "TAB_CLOSED",
    "NO_TAB_WITH_ID",
    // Chrome
    "INVALID_TAB_ID",
    // Firefox
    // Should be handled by polyfill, but isn't - https://github.com/mozilla/webextension-polyfill/issues/384
    "CLOSED_BEFORE_RESPONSE_RECEIVED",
    // Seems to happen in Firefox for some messages: https://sentry.heylogin.dev/organizations/heylogin/issues/755
    "UNEXPECTED_ERROR",
    // No need to report this one.
    // FIXME: When this error comes up, the content script is no longer in a functional state and we
    // might as well unload it entirely. This happens e.g. with lingering content scripts after the
    // extension is unloaded/reloaded.
    "CONTEXT_INVALIDATED"
  ];
  function reportMessageError(e2) {
    if (isWebExtError(e2, ...IGNORED_ERROR_MESSAGES)) {
      return;
    }
    trackError(new Error("Failed to send message", {
      cause: e2
    }));
  }
  content;
  const HEYLOGIN_VERSION = "2024-11-29-99ee37d32";
  const AUTOSNATCH_OVERLAY_SHADOW_WIDTH_PX = 4;
  content;
  function getBackendUrl() {
    return "https://heylogin.app/api/v1";
  }
  function getFrontendServerHost() {
    return "heylogin.app";
  }
  content;
  function initSentry({
    entryPoint,
    contentScript,
    skipProductionCheck
  }) {
    var _a3;
    const prodOrStagingBackend = (_a3 = getBackendHostname()) == null ? void 0 : _a3.endsWith("heylogin.app");
    const isProdOrStaging = prodOrStagingBackend;
    if (!isProdOrStaging && !skipProductionCheck) {
      return;
    }
    if (browser$1.extension.inIncognitoContext) {
      return;
    }
    const browserInfo = Bowser.parse(navigator.userAgent);
    if (browserInfo.browser.name === "Firefox") {
      return;
    }
    try {
      init$1({
        dsn: "https://a84c0408f0864d0bb6002a42294d213b@stackreports.heylogin.app/5338044",
        release: HEYLOGIN_VERSION || "unknown version",
        // TODO reconsider this if we ever create staging build of the extension
        environment: "production",
        autoSessionTracking: false,
        integrations: (integrations) => {
          let filteredIntegrations = integrations;
          if (contentScript) {
            const disabledIntegrationNames = ["Breadcrumbs", "TryCatch", "GlobalHandlers"];
            filteredIntegrations = filteredIntegrations.filter((integration) => !disabledIntegrationNames.includes(integration.name));
          }
          return filteredIntegrations;
        },
        // see https://develop.sentry.dev/sdk/data-model/event-payloads/breadcrumbs/#breadcrumb-types
        beforeBreadcrumb: (breadcrumb, _hint) => {
          if (breadcrumb.type === "http") {
            if (breadcrumb.data && typeof breadcrumb.data.url === "string" && breadcrumb.data.url.startsWith("data:")) {
              return null;
            }
          }
          return breadcrumb;
        },
        beforeSend: (event) => {
          if (event.request) {
            event.request.url = void 0;
          }
          return event;
        },
        ignoreErrors: [
          // https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
          "ResizeObserver loop limit exceeded",
          "ResizeObserver loop completed with undelivered notifications.",
          // Temporary fix, to avoid exhausting our sentry quota with this error: https://sentry.io/organizations/heylogin/issues/2274010196/
          // This is due to a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1213925
          "Tabs cannot be queried right now (user may be dragging a tab).",
          // Nothing we can do about this error, no need to report
          "The browser is shutting down."
        ]
      });
      configureScope$1((scope) => {
        scope.setTag("entryPoint", entryPoint);
      });
      configureScope().catch(trackError);
      browser$1.runtime.onMessage.addListener(makeMessageListener({
        DataUpdate: configureScope
      }));
      if (!HEYLOGIN_VERSION && !skipProductionCheck && entryPoint === "background")
        ;
    } catch (e2) {
      console.error("Error while initializing error reporting \\_()_/", e2);
    }
  }
  async function configureScope() {
    const response = await sendMessage({
      type: "GetUser"
    });
    if (response === messageError) {
      return;
    }
    const {
      userId,
      clientId
    } = {
      userId: void 0,
      clientId: void 0,
      ...response
    };
    updateSentryScope(userId, clientId);
  }
  function updateSentryScope(userId, clientId) {
    configureScope$1((scope) => {
      scope.setUser({
        id: userId
      });
      scope.setTag("clientId", clientId ?? "empty");
    });
  }
  function getBackendHostname() {
    try {
      return new URL(getBackendUrl()).hostname;
    } catch (e2) {
      return void 0;
    }
  }
  content;
  var __awaiter$V = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let Semaphore$1 = class Semaphore {
    constructor(_maxConcurrency) {
      this._maxConcurrency = _maxConcurrency;
      this._queue = [];
      if (_maxConcurrency <= 0) {
        throw new Error("semaphore must be initialized to a positive value");
      }
      this._value = _maxConcurrency;
    }
    acquire() {
      const locked = this.isLocked();
      const ticket = new Promise((r2) => this._queue.push(r2));
      if (!locked)
        this._dispatch();
      return ticket;
    }
    runExclusive(callback) {
      return __awaiter$V(this, void 0, void 0, function* () {
        const [value, release] = yield this.acquire();
        try {
          return yield callback(value);
        } finally {
          release();
        }
      });
    }
    isLocked() {
      return this._value <= 0;
    }
    release() {
      if (this._maxConcurrency > 1) {
        throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
      }
      if (this._currentReleaser) {
        this._currentReleaser();
        this._currentReleaser = void 0;
      }
    }
    _dispatch() {
      const nextConsumer = this._queue.shift();
      if (!nextConsumer)
        return;
      let released = false;
      this._currentReleaser = () => {
        if (released)
          return;
        released = true;
        this._value++;
        this._dispatch();
      };
      nextConsumer([this._value--, this._currentReleaser]);
    }
  };
  var __awaiter$1$2 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let Mutex$1 = class Mutex {
    constructor() {
      this._semaphore = new Semaphore$1(1);
    }
    acquire() {
      return __awaiter$1$2(this, void 0, void 0, function* () {
        const [, releaser] = yield this._semaphore.acquire();
        return releaser;
      });
    }
    runExclusive(callback) {
      return this._semaphore.runExclusive(() => callback());
    }
    isLocked() {
      return this._semaphore.isLocked();
    }
    release() {
      this._semaphore.release();
    }
  };
  var dist$2 = {};
  var errors$1 = {};
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.errorMessages = exports2.ErrorType = void 0;
    var ErrorType;
    (function(ErrorType2) {
      ErrorType2["MalformedUnicode"] = "MALFORMED_UNICODE";
      ErrorType2["MalformedHexadecimal"] = "MALFORMED_HEXADECIMAL";
      ErrorType2["CodePointLimit"] = "CODE_POINT_LIMIT";
      ErrorType2["OctalDeprecation"] = "OCTAL_DEPRECATION";
      ErrorType2["EndOfString"] = "END_OF_STRING";
    })(ErrorType = exports2.ErrorType || (exports2.ErrorType = {}));
    exports2.errorMessages = /* @__PURE__ */ new Map([
      [ErrorType.MalformedUnicode, "malformed Unicode character escape sequence"],
      [
        ErrorType.MalformedHexadecimal,
        "malformed hexadecimal character escape sequence"
      ],
      [
        ErrorType.CodePointLimit,
        "Unicode codepoint must not be greater than 0x10FFFF in escape sequence"
      ],
      [
        ErrorType.OctalDeprecation,
        '"0"-prefixed octal literals and octal escape sequences are deprecated; for octal literals use the "0o" prefix instead'
      ],
      [ErrorType.EndOfString, "malformed escape sequence at end of string"]
    ]);
  })(errors$1);
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unraw = exports2.errorMessages = exports2.ErrorType = void 0;
    const errors_1 = errors$1;
    Object.defineProperty(exports2, "ErrorType", { enumerable: true, get: function() {
      return errors_1.ErrorType;
    } });
    Object.defineProperty(exports2, "errorMessages", { enumerable: true, get: function() {
      return errors_1.errorMessages;
    } });
    function parseHexToInt(hex) {
      const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);
      return isOnlyHexChars ? parseInt(hex, 16) : NaN;
    }
    function validateAndParseHex(hex, errorName, enforcedLength) {
      const parsedHex = parseHexToInt(hex);
      if (Number.isNaN(parsedHex) || enforcedLength !== void 0 && enforcedLength !== hex.length) {
        throw new SyntaxError(errors_1.errorMessages.get(errorName));
      }
      return parsedHex;
    }
    function parseHexadecimalCode(code) {
      const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);
      return String.fromCharCode(parsedCode);
    }
    function parseUnicodeCode(code, surrogateCode) {
      const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);
      if (surrogateCode !== void 0) {
        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);
        return String.fromCharCode(parsedCode, parsedSurrogateCode);
      }
      return String.fromCharCode(parsedCode);
    }
    function isCurlyBraced(text) {
      return text.charAt(0) === "{" && text.charAt(text.length - 1) === "}";
    }
    function parseUnicodeCodePointCode(codePoint) {
      if (!isCurlyBraced(codePoint)) {
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));
      }
      const withoutBraces = codePoint.slice(1, -1);
      const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);
      try {
        return String.fromCodePoint(parsedCode);
      } catch (err) {
        throw err instanceof RangeError ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit)) : err;
      }
    }
    function parseOctalCode(code, error2 = false) {
      if (error2) {
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));
      }
      const parsedCode = parseInt(code, 8);
      return String.fromCharCode(parsedCode);
    }
    const singleCharacterEscapes = /* @__PURE__ */ new Map([
      ["b", "\b"],
      ["f", "\f"],
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["v", "\v"],
      ["0", "\0"]
    ]);
    function parseSingleCharacterCode(code) {
      return singleCharacterEscapes.get(code) || code;
    }
    const escapeMatch = /\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;
    function unraw2(raw, allowOctals = false) {
      return raw.replace(escapeMatch, function(_2, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {
        if (backslash !== void 0) {
          return "\\";
        }
        if (hex !== void 0) {
          return parseHexadecimalCode(hex);
        }
        if (codePoint !== void 0) {
          return parseUnicodeCodePointCode(codePoint);
        }
        if (unicodeWithSurrogate !== void 0) {
          return parseUnicodeCode(unicodeWithSurrogate, surrogate);
        }
        if (unicode !== void 0) {
          return parseUnicodeCode(unicode);
        }
        if (octal === "0") {
          return "\0";
        }
        if (octal !== void 0) {
          return parseOctalCode(octal, !allowOctals);
        }
        if (singleCharacter !== void 0) {
          return parseSingleCharacterCode(singleCharacter);
        }
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));
      });
    }
    exports2.unraw = unraw2;
    exports2.default = unraw2;
  })(dist$2);
  const unraw = /* @__PURE__ */ getDefaultExportFromCjs(dist$2);
  const isString$5 = (s2) => typeof s2 === "string";
  const isFunction$3 = (f2) => typeof f2 === "function";
  const cache = /* @__PURE__ */ new Map();
  function normalizeLocales(locales) {
    const out = Array.isArray(locales) ? locales : [locales];
    return [...out, "en"];
  }
  function date(locales, value, format) {
    const _locales = normalizeLocales(locales);
    const formatter = getMemoized(
      () => cacheKey("date", _locales, format),
      () => new Intl.DateTimeFormat(_locales, format)
    );
    return formatter.format(isString$5(value) ? new Date(value) : value);
  }
  function number(locales, value, format) {
    const _locales = normalizeLocales(locales);
    const formatter = getMemoized(
      () => cacheKey("number", _locales, format),
      () => new Intl.NumberFormat(_locales, format)
    );
    return formatter.format(value);
  }
  function plural(locales, ordinal, value, { offset = 0, ...rules }) {
    const _locales = normalizeLocales(locales);
    const plurals = ordinal ? getMemoized(
      () => cacheKey("plural-ordinal", _locales),
      () => new Intl.PluralRules(_locales, { type: "ordinal" })
    ) : getMemoized(
      () => cacheKey("plural-cardinal", _locales),
      () => new Intl.PluralRules(_locales, { type: "cardinal" })
    );
    return rules[value] ?? rules[plurals.select(value - offset)] ?? rules.other;
  }
  function getMemoized(getKey, construct) {
    const key = getKey();
    let formatter = cache.get(key);
    if (!formatter) {
      formatter = construct();
      cache.set(key, formatter);
    }
    return formatter;
  }
  function cacheKey(type, locales, options) {
    const localeKey = locales.join("-");
    return `${type}-${localeKey}-${JSON.stringify(options)}`;
  }
  const UNICODE_REGEX = /\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/g;
  const getDefaultFormats = (locale, locales, formats = {}) => {
    locales = locales || locale;
    const style = (format) => isString$5(format) ? formats[format] || { style: format } : format;
    const replaceOctothorpe = (value, message) => {
      const numberFormat = Object.keys(formats).length ? style("number") : {};
      const valueStr = number(locales, value, numberFormat);
      return message.replace("#", valueStr);
    };
    return {
      plural: (value, cases) => {
        const { offset = 0 } = cases;
        const message = plural(locales, false, value, cases);
        return replaceOctothorpe(value - offset, message);
      },
      selectordinal: (value, cases) => {
        const { offset = 0 } = cases;
        const message = plural(locales, true, value, cases);
        return replaceOctothorpe(value - offset, message);
      },
      select: (value, rules) => rules[value] ?? rules.other,
      number: (value, format) => number(locales, value, style(format)),
      date: (value, format) => date(locales, value, style(format)),
      undefined: (value) => value
    };
  };
  function interpolate(translation, locale, locales) {
    return (values2, formats = {}) => {
      const formatters = getDefaultFormats(locale, locales, formats);
      const formatMessage = (message) => {
        if (!Array.isArray(message))
          return message;
        return message.reduce((message2, token) => {
          if (isString$5(token))
            return message2 + token;
          const [name, type, format] = token;
          let interpolatedFormat = {};
          if (format != null && !isString$5(format)) {
            Object.keys(format).forEach((key) => {
              interpolatedFormat[key] = formatMessage(format[key]);
            });
          } else {
            interpolatedFormat = format;
          }
          const value = formatters[type](values2[name], interpolatedFormat);
          if (value == null)
            return message2;
          return message2 + value;
        }, "");
      };
      const result2 = formatMessage(translation);
      if (isString$5(result2) && UNICODE_REGEX.test(result2)) {
        return unraw(result2.trim());
      }
      if (isString$5(result2))
        return result2.trim();
      return result2;
    };
  }
  var __defProp$1 = Object.defineProperty;
  var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$1 = (obj, key, value) => {
    __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  class EventEmitter {
    constructor() {
      __publicField$1(this, "_events", {});
    }
    on(event, listener) {
      if (!this._hasEvent(event))
        this._events[event] = [];
      this._events[event].push(listener);
      return () => this.removeListener(event, listener);
    }
    removeListener(event, listener) {
      if (!this._hasEvent(event))
        return;
      const index2 = this._events[event].indexOf(listener);
      if (~index2)
        this._events[event].splice(index2, 1);
    }
    emit(event, ...args) {
      if (!this._hasEvent(event))
        return;
      this._events[event].map((listener) => listener.apply(this, args));
    }
    _hasEvent(event) {
      return Array.isArray(this._events[event]);
    }
  }
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  class I18n extends EventEmitter {
    constructor(params) {
      super();
      __publicField2(this, "_locale");
      __publicField2(this, "_locales");
      __publicField2(this, "_localeData");
      __publicField2(this, "_messages");
      __publicField2(this, "_missing");
      __publicField2(this, "t", this._.bind(this));
      this._messages = {};
      this._localeData = {};
      if (params.missing != null)
        this._missing = params.missing;
      if (params.messages != null)
        this.load(params.messages);
      if (params.localeData != null)
        this.loadLocaleData(params.localeData);
      if (params.locale != null || params.locales != null) {
        this.activate(params.locale, params.locales);
      }
    }
    get locale() {
      return this._locale;
    }
    get locales() {
      return this._locales;
    }
    get messages() {
      return this._messages[this._locale] ?? {};
    }
    /**
     * @deprecated this has no effect. Please remove this from the code. Deprecated in v4
     */
    get localeData() {
      return this._localeData[this._locale] ?? {};
    }
    _loadLocaleData(locale, localeData) {
      if (this._localeData[locale] == null) {
        this._localeData[locale] = localeData;
      } else {
        Object.assign(this._localeData[locale], localeData);
      }
    }
    /**
     * @deprecated Plurals automatically used from Intl.PluralRules you can safely remove this call. Deprecated in v4
     */
    loadLocaleData(localeOrAllData, localeData) {
      if (localeData != null) {
        this._loadLocaleData(localeOrAllData, localeData);
      } else {
        Object.keys(localeOrAllData).forEach(
          (locale) => this._loadLocaleData(locale, localeOrAllData[locale])
        );
      }
      this.emit("change");
    }
    _load(locale, messages) {
      if (this._messages[locale] == null) {
        this._messages[locale] = messages;
      } else {
        Object.assign(this._messages[locale], messages);
      }
    }
    load(localeOrMessages, messages) {
      if (messages != null) {
        this._load(localeOrMessages, messages);
      } else {
        Object.keys(localeOrMessages).forEach(
          (locale) => this._load(locale, localeOrMessages[locale])
        );
      }
      this.emit("change");
    }
    /**
     * @param options {@link LoadAndActivateOptions}
     */
    loadAndActivate({ locale, locales, messages }) {
      this._locale = locale;
      this._locales = locales || void 0;
      this._messages[this._locale] = messages;
      this.emit("change");
    }
    activate(locale, locales) {
      this._locale = locale;
      this._locales = locales;
      this.emit("change");
    }
    _(id2, values2 = {}, { message, formats } = {}) {
      if (!isString$5(id2)) {
        values2 = id2.values || values2;
        message = id2.message;
        id2 = id2.id;
      }
      const messageMissing = !this.messages[id2];
      const missing = this._missing;
      if (missing && messageMissing) {
        return isFunction$3(missing) ? missing(this._locale, id2) : missing;
      }
      if (messageMissing) {
        this.emit("missing", { id: id2, locale: this._locale });
      }
      let translation = this.messages[id2] || message || id2;
      if (isString$5(translation) && UNICODE_REGEX.test(translation))
        return JSON.parse(`"${translation}"`);
      if (isString$5(translation))
        return translation;
      return interpolate(
        translation,
        this._locale,
        this._locales
      )(values2, formats);
    }
    date(value, format) {
      return date(this._locales || this._locale, value, format);
    }
    number(value, format) {
      return number(this._locales || this._locale, value, format);
    }
  }
  function setupI18n(params = {}) {
    return new I18n(params);
  }
  const i18n = setupI18n();
  var util$2;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever2(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever2;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
      const filtered = {};
      for (const k2 of validKeys) {
        filtered[k2] = obj[k2];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e2) {
        return obj[e2];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys2 = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys2.push(key);
        }
      }
      return keys2;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_2, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util$2 || (util$2 = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util$2.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util$2.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  class ZodError extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error2) => {
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i2 = 0;
            while (i2 < issue.path.length) {
              const el2 = issue.path[i2];
              const terminal = i2 === issue.path.length - 1;
              if (!terminal) {
                curr[el2] = curr[el2] || { _errors: [] };
              } else {
                curr[el2] = curr[el2] || { _errors: [] };
                curr[el2]._errors.push(mapper(issue));
              }
              curr = curr[el2];
              i2++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util$2.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error2 = new ZodError(issues);
    return error2;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$2.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util$2.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util$2.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util$2.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util$2.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util$2.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function setErrorMap(map2) {
    overrideErrorMap = map2;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
    for (const map2 of maps) {
      errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage
    };
  };
  const EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
        // then global default map
      ].filter((x2) => !!x2)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s2 of results) {
        if (s2.status === "aborted")
          return INVALID;
        if (s2.status === "dirty")
          status.dirty();
        arrayValue.push(s2.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x2) => x2.status === "aborted";
  const isDirty = (x2) => x2.status === "dirty";
  const isValid = (x2) => x2.status === "valid";
  const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result2) => {
    if (isValid(result2)) {
      return { success: true, data: result2.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error2 = new ZodError(ctx.common.issues);
          this._error = error2;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result2 = this._parse(input);
      if (isAsync(result2)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result2;
    }
    _parseAsync(input) {
      const result2 = this._parse(input);
      return Promise.resolve(result2);
    }
    parse(data, params) {
      const result2 = this.safeParse(data, params);
      if (result2.success)
        return result2.data;
      throw result2.error;
    }
    safeParse(data, params) {
      var _a3;
      const ctx = {
        common: {
          issues: [],
          async: (_a3 = params === null || params === void 0 ? void 0 : params.async) !== null && _a3 !== void 0 ? _a3 : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result2);
    }
    async parseAsync(data, params) {
      const result2 = await this.safeParseAsync(data, params);
      if (result2.success)
        return result2.data;
      throw result2.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result2);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result2 = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result2 instanceof Promise) {
          return result2.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result2) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[a-z][a-z0-9]*$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  const datetimeRegex = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
      }
    }
  };
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(
          ctx2,
          {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          }
          //
        );
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a3) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex2 = datetimeRegex(check);
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util$2.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex2, validation, message) {
      return this.refinement((data) => regex2.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a3;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a3 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a3 !== void 0 ? _a3 : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    regex(regex2, message) {
      return this._addCheck({
        kind: "regex",
        regex: regex2,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch2) => ch2.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch2) => ch2.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max2 = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max2 === null || ch2.value < max2)
            max2 = ch2.value;
        }
      }
      return max2;
    }
  }
  ZodString.create = (params) => {
    var _a3;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util$2.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util$2.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max2 = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max2 === null || ch2.value < max2)
            max2 = ch2.value;
        }
      }
      return max2;
    }
    get isInt() {
      return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util$2.isInteger(ch2.value));
    }
    get isFinite() {
      let max2 = null, min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
          return true;
        } else if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        } else if (ch2.kind === "max") {
          if (max2 === null || ch2.value < max2)
            max2 = ch2.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max2);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util$2.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max2 = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max2 === null || ch2.value < max2)
            max2 = ch2.value;
        }
      }
      return max2;
    }
  }
  ZodBigInt.create = (params) => {
    var _a3;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util$2.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max2 = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max2 === null || ch2.value < max2)
            max2 = ch2.value;
        }
      }
      return max2 != null ? new Date(max2) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i2) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        })).then((result3) => {
          return ParseStatus.mergeArray(status, result3);
        });
      }
      const result2 = [...ctx.data].map((item, i2) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      });
      return ParseStatus.mergeArray(status, result2);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys2 = util$2.objectKeys(shape);
      return this._cached = { shape, keys: keys2 };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip")
          ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a3, _b, _c2, _d;
            const defaultError = (_c2 = (_b = (_a3 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a3, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index2) {
      return new ZodObject({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      util$2.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util$2.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util$2.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util$2.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util$2.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result2 of results) {
          if (result2.result.status === "valid") {
            return result2.result;
          }
        }
        for (const result2 of results) {
          if (result2.result.status === "dirty") {
            ctx.common.issues.push(...result2.ctx.common.issues);
            return result2.result;
          }
        }
        const unionErrors = results.map((result2) => new ZodError(result2.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result2 = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result2.status === "valid") {
            return result2;
          } else if (result2.status === "dirty" && !dirty) {
            dirty = { result: result2, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else {
      return null;
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  function mergeValues(a, b2) {
    const aType = getParsedType(a);
    const bType = getParsedType(b2);
    if (a === b2) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util$2.objectKeys(b2);
      const sharedKeys = util$2.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b2 };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b2[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b2.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a.length; index2++) {
        const itemA = a[index2];
        const itemB = b2[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x2) => !!x2);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error2) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error2
          }
        });
      }
      function makeReturnsIssue(returns, error2) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error2
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me2 = this;
        return OK(async function(...args) {
          const error2 = new ZodError([]);
          const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
            error2.addIssue(makeArgsIssue(args, e2));
            throw error2;
          });
          const result2 = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me2._def.returns._def.type.parseAsync(result2, params).catch((e2) => {
            error2.addIssue(makeReturnsIssue(result2, e2));
            throw error2;
          });
          return parsedReturns;
        });
      } else {
        const me2 = this;
        return OK(function(...args) {
          const parsedArgs = me2._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result2 = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me2._def.returns.safeParse(result2, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result2, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values2, params) {
    return new ZodEnum({
      values: values2,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util$2.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values2) {
      return ZodEnum.create(values2);
    }
    exclude(values2) {
      return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
    }
  }
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util$2.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util$2.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util$2.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util$2.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  ZodNativeEnum.create = (values2, params) => {
    return new ZodNativeEnum({
      values: values2,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.issues.length) {
          return {
            status: "dirty",
            value: ctx.data
          };
        }
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => {
            return this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result2 = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result2);
          }
          if (result2 instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base2 = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base2))
            return base2;
          const result2 = effect.transform(base2.value, checkCtx);
          if (result2 instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result2 };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
            if (!isValid(base2))
              return base2;
            return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result2) => ({ status: status.value, value: result2 }));
          });
        }
      }
      util$2.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result2 = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result2)) {
        return result2.then((result3) => {
          return {
            status: "valid",
            value: result3.status === "valid" ? result3.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  const BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b2) {
      return new ZodPipeline({
        in: a,
        out: b2,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result2 = this._def.innerType._parse(input);
      if (isValid(result2)) {
        result2.value = Object.freeze(result2.value);
      }
      return result2;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  const custom = (check, params = {}, fatal) => {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a3, _b;
        if (!check(data)) {
          const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b = (_a3 = p2.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b !== void 0 ? _b : true;
          const p22 = typeof p2 === "string" ? { message: p2 } : p2;
          ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
        }
      });
    return ZodAny.create();
  };
  const late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const nanType = ZodNaN.create;
  const bigIntType = ZodBigInt.create;
  const booleanType = ZodBoolean.create;
  const dateType = ZodDate.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  const unknownType = ZodUnknown.create;
  const neverType = ZodNever.create;
  const voidType = ZodVoid.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  const intersectionType = ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const mapType = ZodMap.create;
  const setType = ZodSet.create;
  const functionType = ZodFunction.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  const nativeEnumType = ZodNativeEnum.create;
  const promiseType = ZodPromise.create;
  const effectsType = ZodEffects.create;
  const optionalType = ZodOptional.create;
  const nullableType = ZodNullable.create;
  const preprocessType = ZodEffects.createWithPreprocess;
  const pipelineType = ZodPipeline.create;
  const ostring = () => stringType().optional();
  const onumber = () => numberType().optional();
  const oboolean = () => booleanType().optional();
  const coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  const NEVER = INVALID;
  var z$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util$2;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });
  var naclFast = { exports: {} };
  const __viteBrowserExternal = {};
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  (function(module2) {
    (function(nacl) {
      var gf2 = function(init2) {
        var i2, r2 = new Float64Array(16);
        if (init2)
          for (i2 = 0; i2 < init2.length; i2++)
            r2[i2] = init2[i2];
        return r2;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf2(), gf1 = gf2([1]), _121665 = gf2([56129, 1]), D2 = gf2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x2, i2, h2, l2) {
        x2[i2] = h2 >> 24 & 255;
        x2[i2 + 1] = h2 >> 16 & 255;
        x2[i2 + 2] = h2 >> 8 & 255;
        x2[i2 + 3] = h2 & 255;
        x2[i2 + 4] = l2 >> 24 & 255;
        x2[i2 + 5] = l2 >> 16 & 255;
        x2[i2 + 6] = l2 >> 8 & 255;
        x2[i2 + 7] = l2 & 255;
      }
      function vn(x2, xi2, y2, yi2, n2) {
        var i2, d2 = 0;
        for (i2 = 0; i2 < n2; i2++)
          d2 |= x2[xi2 + i2] ^ y2[yi2 + i2];
        return (1 & d2 - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x2, xi2, y2, yi2) {
        return vn(x2, xi2, y2, yi2, 16);
      }
      function crypto_verify_32(x2, xi2, y2, yi2) {
        return vn(x2, xi2, y2, yi2, 32);
      }
      function core_salsa20(o2, p2, k2, c2) {
        var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x1 >>> 0 & 255;
        o2[5] = x1 >>> 8 & 255;
        o2[6] = x1 >>> 16 & 255;
        o2[7] = x1 >>> 24 & 255;
        o2[8] = x2 >>> 0 & 255;
        o2[9] = x2 >>> 8 & 255;
        o2[10] = x2 >>> 16 & 255;
        o2[11] = x2 >>> 24 & 255;
        o2[12] = x3 >>> 0 & 255;
        o2[13] = x3 >>> 8 & 255;
        o2[14] = x3 >>> 16 & 255;
        o2[15] = x3 >>> 24 & 255;
        o2[16] = x4 >>> 0 & 255;
        o2[17] = x4 >>> 8 & 255;
        o2[18] = x4 >>> 16 & 255;
        o2[19] = x4 >>> 24 & 255;
        o2[20] = x5 >>> 0 & 255;
        o2[21] = x5 >>> 8 & 255;
        o2[22] = x5 >>> 16 & 255;
        o2[23] = x5 >>> 24 & 255;
        o2[24] = x6 >>> 0 & 255;
        o2[25] = x6 >>> 8 & 255;
        o2[26] = x6 >>> 16 & 255;
        o2[27] = x6 >>> 24 & 255;
        o2[28] = x7 >>> 0 & 255;
        o2[29] = x7 >>> 8 & 255;
        o2[30] = x7 >>> 16 & 255;
        o2[31] = x7 >>> 24 & 255;
        o2[32] = x8 >>> 0 & 255;
        o2[33] = x8 >>> 8 & 255;
        o2[34] = x8 >>> 16 & 255;
        o2[35] = x8 >>> 24 & 255;
        o2[36] = x9 >>> 0 & 255;
        o2[37] = x9 >>> 8 & 255;
        o2[38] = x9 >>> 16 & 255;
        o2[39] = x9 >>> 24 & 255;
        o2[40] = x10 >>> 0 & 255;
        o2[41] = x10 >>> 8 & 255;
        o2[42] = x10 >>> 16 & 255;
        o2[43] = x10 >>> 24 & 255;
        o2[44] = x11 >>> 0 & 255;
        o2[45] = x11 >>> 8 & 255;
        o2[46] = x11 >>> 16 & 255;
        o2[47] = x11 >>> 24 & 255;
        o2[48] = x12 >>> 0 & 255;
        o2[49] = x12 >>> 8 & 255;
        o2[50] = x12 >>> 16 & 255;
        o2[51] = x12 >>> 24 & 255;
        o2[52] = x13 >>> 0 & 255;
        o2[53] = x13 >>> 8 & 255;
        o2[54] = x13 >>> 16 & 255;
        o2[55] = x13 >>> 24 & 255;
        o2[56] = x14 >>> 0 & 255;
        o2[57] = x14 >>> 8 & 255;
        o2[58] = x14 >>> 16 & 255;
        o2[59] = x14 >>> 24 & 255;
        o2[60] = x15 >>> 0 & 255;
        o2[61] = x15 >>> 8 & 255;
        o2[62] = x15 >>> 16 & 255;
        o2[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o2, p2, k2, c2) {
        var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x5 >>> 0 & 255;
        o2[5] = x5 >>> 8 & 255;
        o2[6] = x5 >>> 16 & 255;
        o2[7] = x5 >>> 24 & 255;
        o2[8] = x10 >>> 0 & 255;
        o2[9] = x10 >>> 8 & 255;
        o2[10] = x10 >>> 16 & 255;
        o2[11] = x10 >>> 24 & 255;
        o2[12] = x15 >>> 0 & 255;
        o2[13] = x15 >>> 8 & 255;
        o2[14] = x15 >>> 16 & 255;
        o2[15] = x15 >>> 24 & 255;
        o2[16] = x6 >>> 0 & 255;
        o2[17] = x6 >>> 8 & 255;
        o2[18] = x6 >>> 16 & 255;
        o2[19] = x6 >>> 24 & 255;
        o2[20] = x7 >>> 0 & 255;
        o2[21] = x7 >>> 8 & 255;
        o2[22] = x7 >>> 16 & 255;
        o2[23] = x7 >>> 24 & 255;
        o2[24] = x8 >>> 0 & 255;
        o2[25] = x8 >>> 8 & 255;
        o2[26] = x8 >>> 16 & 255;
        o2[27] = x8 >>> 24 & 255;
        o2[28] = x9 >>> 0 & 255;
        o2[29] = x9 >>> 8 & 255;
        o2[30] = x9 >>> 16 & 255;
        o2[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k2, c2) {
        core_salsa20(out, inp, k2, c2);
      }
      function crypto_core_hsalsa20(out, inp, k2, c2) {
        core_hsalsa20(out, inp, k2, c2);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c2, cpos, m2, mpos, b2, n2, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++)
          z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++)
          z2[i2] = n2[i2];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < 64; i2++)
            c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z2[i2] & 255) | 0;
            z2[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < b2; i2++)
            c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c2, cpos, b2, n2, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++)
          z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++)
          z2[i2] = n2[i2];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < 64; i2++)
            c2[cpos + i2] = x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z2[i2] & 255) | 0;
            z2[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < b2; i2++)
            c2[cpos + i2] = x2[i2];
        }
        return 0;
      }
      function crypto_stream(c2, cpos, d2, n2, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n2, k2, sigma);
        var sn2 = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++)
          sn2[i2] = n2[i2 + 16];
        return crypto_stream_salsa20(c2, cpos, d2, sn2, s2);
      }
      function crypto_stream_xor(c2, cpos, m2, mpos, d2, n2, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n2, k2, sigma);
        var sn2 = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++)
          sn2[i2] = n2[i2 + 16];
        return crypto_stream_salsa20_xor(c2, cpos, m2, mpos, d2, sn2, s2);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m2, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c2;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c2 = 0;
          d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c2 += d1 >>> 13;
          d1 &= 8191;
          d2 = c2;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c2 = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c2 += d2 >>> 13;
          d2 &= 8191;
          d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c2, mask, f2, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++)
            this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c2 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c2;
          c2 = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c2 * 5;
        c2 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c2;
        c2 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c2;
        g2[0] = this.h[0] + 5;
        c2 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g2[i2] = this.h[i2] + c2;
          c2 = g2[i2] >>> 13;
          g2[i2] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c2 ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++)
          g2[i2] &= mask;
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++)
          this.h[i2] = this.h[i2] & mask | g2[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f2 = this.h[0] + this.pad[0];
        this.h[0] = f2 & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f2 = (this.h[i2] + this.pad[i2] | 0) + (f2 >>> 16) | 0;
          this.h[i2] = f2 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m2, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m2[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m2, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++)
            this.buffer[this.leftover + i2] = m2[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m2, mpos, n2, k2) {
        var s2 = new poly1305(k2);
        s2.update(m2, mpos, n2);
        s2.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n2, k2) {
        var x2 = new Uint8Array(16);
        crypto_onetimeauth(x2, 0, m2, mpos, n2, k2);
        return crypto_verify_16(h2, hpos, x2, 0);
      }
      function crypto_secretbox(c2, m2, d2, n2, k2) {
        var i2;
        if (d2 < 32)
          return -1;
        crypto_stream_xor(c2, 0, m2, 0, d2, n2, k2);
        crypto_onetimeauth(c2, 16, c2, 32, d2 - 32, c2);
        for (i2 = 0; i2 < 16; i2++)
          c2[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m2, c2, d2, n2, k2) {
        var i2;
        var x2 = new Uint8Array(32);
        if (d2 < 32)
          return -1;
        crypto_stream(x2, 0, 32, n2, k2);
        if (crypto_onetimeauth_verify(c2, 16, c2, 32, d2 - 32, x2) !== 0)
          return -1;
        crypto_stream_xor(m2, 0, c2, 0, d2, n2, k2);
        for (i2 = 0; i2 < 32; i2++)
          m2[i2] = 0;
        return 0;
      }
      function set25519(r2, a) {
        var i2;
        for (i2 = 0; i2 < 16; i2++)
          r2[i2] = a[i2] | 0;
      }
      function car25519(o2) {
        var i2, v2, c2 = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v2 = o2[i2] + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          o2[i2] = v2 - c2 * 65536;
        }
        o2[0] += c2 - 1 + 37 * (c2 - 1);
      }
      function sel25519(p2, q2, b2) {
        var t2, c2 = ~(b2 - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t2 = c2 & (p2[i2] ^ q2[i2]);
          p2[i2] ^= t2;
          q2[i2] ^= t2;
        }
      }
      function pack25519(o2, n2) {
        var i2, j, b2;
        var m2 = gf2(), t2 = gf2();
        for (i2 = 0; i2 < 16; i2++)
          t2[i2] = n2[i2];
        car25519(t2);
        car25519(t2);
        car25519(t2);
        for (j = 0; j < 2; j++) {
          m2[0] = t2[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m2[i2] = t2[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
            m2[i2 - 1] &= 65535;
          }
          m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
          b2 = m2[15] >> 16 & 1;
          m2[14] &= 65535;
          sel25519(t2, m2, 1 - b2);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o2[2 * i2] = t2[i2] & 255;
          o2[2 * i2 + 1] = t2[i2] >> 8;
        }
      }
      function neq25519(a, b2) {
        var c2 = new Uint8Array(32), d2 = new Uint8Array(32);
        pack25519(c2, a);
        pack25519(d2, b2);
        return crypto_verify_32(c2, 0, d2, 0);
      }
      function par25519(a) {
        var d2 = new Uint8Array(32);
        pack25519(d2, a);
        return d2[0] & 1;
      }
      function unpack25519(o2, n2) {
        var i2;
        for (i2 = 0; i2 < 16; i2++)
          o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
        o2[15] &= 32767;
      }
      function A2(o2, a, b2) {
        for (var i2 = 0; i2 < 16; i2++)
          o2[i2] = a[i2] + b2[i2];
      }
      function Z2(o2, a, b2) {
        for (var i2 = 0; i2 < 16; i2++)
          o2[i2] = a[i2] - b2[i2];
      }
      function M2(o2, a, b2) {
        var v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
        v2 = a[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b22;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b22;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b22;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b22;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b22;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b22;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b22;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b22;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b22;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b22;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b22;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b22;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b22;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b22;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b22;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b22;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c2 = 1;
        v2 = t0 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t0 = v2 - c2 * 65536;
        v2 = t1 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t1 = v2 - c2 * 65536;
        v2 = t2 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t2 = v2 - c2 * 65536;
        v2 = t3 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t3 = v2 - c2 * 65536;
        v2 = t4 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t4 = v2 - c2 * 65536;
        v2 = t5 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t5 = v2 - c2 * 65536;
        v2 = t6 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t6 = v2 - c2 * 65536;
        v2 = t7 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t7 = v2 - c2 * 65536;
        v2 = t8 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t8 = v2 - c2 * 65536;
        v2 = t9 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t9 = v2 - c2 * 65536;
        v2 = t10 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t10 = v2 - c2 * 65536;
        v2 = t11 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t11 = v2 - c2 * 65536;
        v2 = t12 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t12 = v2 - c2 * 65536;
        v2 = t13 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t13 = v2 - c2 * 65536;
        v2 = t14 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t14 = v2 - c2 * 65536;
        v2 = t15 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t15 = v2 - c2 * 65536;
        t0 += c2 - 1 + 37 * (c2 - 1);
        c2 = 1;
        v2 = t0 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t0 = v2 - c2 * 65536;
        v2 = t1 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t1 = v2 - c2 * 65536;
        v2 = t2 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t2 = v2 - c2 * 65536;
        v2 = t3 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t3 = v2 - c2 * 65536;
        v2 = t4 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t4 = v2 - c2 * 65536;
        v2 = t5 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t5 = v2 - c2 * 65536;
        v2 = t6 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t6 = v2 - c2 * 65536;
        v2 = t7 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t7 = v2 - c2 * 65536;
        v2 = t8 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t8 = v2 - c2 * 65536;
        v2 = t9 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t9 = v2 - c2 * 65536;
        v2 = t10 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t10 = v2 - c2 * 65536;
        v2 = t11 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t11 = v2 - c2 * 65536;
        v2 = t12 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t12 = v2 - c2 * 65536;
        v2 = t13 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t13 = v2 - c2 * 65536;
        v2 = t14 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t14 = v2 - c2 * 65536;
        v2 = t15 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t15 = v2 - c2 * 65536;
        t0 += c2 - 1 + 37 * (c2 - 1);
        o2[0] = t0;
        o2[1] = t1;
        o2[2] = t2;
        o2[3] = t3;
        o2[4] = t4;
        o2[5] = t5;
        o2[6] = t6;
        o2[7] = t7;
        o2[8] = t8;
        o2[9] = t9;
        o2[10] = t10;
        o2[11] = t11;
        o2[12] = t12;
        o2[13] = t13;
        o2[14] = t14;
        o2[15] = t15;
      }
      function S2(o2, a) {
        M2(o2, a, a);
      }
      function inv25519(o2, i2) {
        var c2 = gf2();
        var a;
        for (a = 0; a < 16; a++)
          c2[a] = i2[a];
        for (a = 253; a >= 0; a--) {
          S2(c2, c2);
          if (a !== 2 && a !== 4)
            M2(c2, c2, i2);
        }
        for (a = 0; a < 16; a++)
          o2[a] = c2[a];
      }
      function pow2523(o2, i2) {
        var c2 = gf2();
        var a;
        for (a = 0; a < 16; a++)
          c2[a] = i2[a];
        for (a = 250; a >= 0; a--) {
          S2(c2, c2);
          if (a !== 1)
            M2(c2, c2, i2);
        }
        for (a = 0; a < 16; a++)
          o2[a] = c2[a];
      }
      function crypto_scalarmult(q2, n2, p2) {
        var z2 = new Uint8Array(32);
        var x2 = new Float64Array(80), r2, i2;
        var a = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e2 = gf2(), f2 = gf2();
        for (i2 = 0; i2 < 31; i2++)
          z2[i2] = n2[i2];
        z2[31] = n2[31] & 127 | 64;
        z2[0] &= 248;
        unpack25519(x2, p2);
        for (i2 = 0; i2 < 16; i2++) {
          b2[i2] = x2[i2];
          d2[i2] = a[i2] = c2[i2] = 0;
        }
        a[0] = d2[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r2 = z2[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a, b2, r2);
          sel25519(c2, d2, r2);
          A2(e2, a, c2);
          Z2(a, a, c2);
          A2(c2, b2, d2);
          Z2(b2, b2, d2);
          S2(d2, e2);
          S2(f2, a);
          M2(a, c2, a);
          M2(c2, b2, e2);
          A2(e2, a, c2);
          Z2(a, a, c2);
          S2(b2, a);
          Z2(c2, d2, f2);
          M2(a, c2, _121665);
          A2(a, a, d2);
          M2(c2, c2, a);
          M2(a, d2, f2);
          M2(d2, b2, x2);
          S2(b2, e2);
          sel25519(a, b2, r2);
          sel25519(c2, d2, r2);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x2[i2 + 16] = a[i2];
          x2[i2 + 32] = c2[i2];
          x2[i2 + 48] = b2[i2];
          x2[i2 + 64] = d2[i2];
        }
        var x32 = x2.subarray(32);
        var x16 = x2.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q2, x16);
        return 0;
      }
      function crypto_scalarmult_base(q2, n2) {
        return crypto_scalarmult(q2, n2, _9);
      }
      function crypto_box_keypair(y2, x2) {
        randombytes(x2, 32);
        return crypto_scalarmult_base(y2, x2);
      }
      function crypto_box_beforenm(k2, y2, x2) {
        var s2 = new Uint8Array(32);
        crypto_scalarmult(s2, x2, y2);
        return crypto_core_hsalsa20(k2, _0, s2, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c2, m2, d2, n2, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_afternm(c2, m2, d2, n2, k2);
      }
      function crypto_box_open(m2, c2, d2, n2, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_open_afternm(m2, c2, d2, n2, k2);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh2, hl2, m2, n2) {
        var wh2 = new Int32Array(16), wl2 = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th2, tl2, i2, j, h2, l2, a, b2, c2, d2;
        var ah0 = hh2[0], ah1 = hh2[1], ah2 = hh2[2], ah3 = hh2[3], ah4 = hh2[4], ah5 = hh2[5], ah6 = hh2[6], ah7 = hh2[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
        var pos = 0;
        while (n2 >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j = 8 * i2 + pos;
            wh2[i2] = m2[j + 0] << 24 | m2[j + 1] << 16 | m2[j + 2] << 8 | m2[j + 3];
            wl2[i2] = m2[j + 4] << 24 | m2[j + 5] << 16 | m2[j + 6] << 8 | m2[j + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l2 = al7;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l2 = al4 & al5 ^ ~al4 & al6;
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = K2[i2 * 2];
            l2 = K2[i2 * 2 + 1];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = wh2[i2 % 16];
            l2 = wl2[i2 % 16];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            th2 = c2 & 65535 | d2 << 16;
            tl2 = a & 65535 | b2 << 16;
            h2 = th2;
            l2 = tl2;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            bh7 = c2 & 65535 | d2 << 16;
            bl7 = a & 65535 | b2 << 16;
            h2 = bh3;
            l2 = bl3;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = th2;
            l2 = tl2;
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            bh3 = c2 & 65535 | d2 << 16;
            bl3 = a & 65535 | b2 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h2 = wh2[j];
                l2 = wl2[j];
                a = l2 & 65535;
                b2 = l2 >>> 16;
                c2 = h2 & 65535;
                d2 = h2 >>> 16;
                h2 = wh2[(j + 9) % 16];
                l2 = wl2[(j + 9) % 16];
                a += l2 & 65535;
                b2 += l2 >>> 16;
                c2 += h2 & 65535;
                d2 += h2 >>> 16;
                th2 = wh2[(j + 1) % 16];
                tl2 = wl2[(j + 1) % 16];
                h2 = (th2 >>> 1 | tl2 << 32 - 1) ^ (th2 >>> 8 | tl2 << 32 - 8) ^ th2 >>> 7;
                l2 = (tl2 >>> 1 | th2 << 32 - 1) ^ (tl2 >>> 8 | th2 << 32 - 8) ^ (tl2 >>> 7 | th2 << 32 - 7);
                a += l2 & 65535;
                b2 += l2 >>> 16;
                c2 += h2 & 65535;
                d2 += h2 >>> 16;
                th2 = wh2[(j + 14) % 16];
                tl2 = wl2[(j + 14) % 16];
                h2 = (th2 >>> 19 | tl2 << 32 - 19) ^ (tl2 >>> 61 - 32 | th2 << 32 - (61 - 32)) ^ th2 >>> 6;
                l2 = (tl2 >>> 19 | th2 << 32 - 19) ^ (th2 >>> 61 - 32 | tl2 << 32 - (61 - 32)) ^ (tl2 >>> 6 | th2 << 32 - 6);
                a += l2 & 65535;
                b2 += l2 >>> 16;
                c2 += h2 & 65535;
                d2 += h2 >>> 16;
                b2 += a >>> 16;
                c2 += b2 >>> 16;
                d2 += c2 >>> 16;
                wh2[j] = c2 & 65535 | d2 << 16;
                wl2[j] = a & 65535 | b2 << 16;
              }
            }
          }
          h2 = ah0;
          l2 = al0;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh2[0];
          l2 = hl2[0];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh2[0] = ah0 = c2 & 65535 | d2 << 16;
          hl2[0] = al0 = a & 65535 | b2 << 16;
          h2 = ah1;
          l2 = al1;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh2[1];
          l2 = hl2[1];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh2[1] = ah1 = c2 & 65535 | d2 << 16;
          hl2[1] = al1 = a & 65535 | b2 << 16;
          h2 = ah2;
          l2 = al2;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh2[2];
          l2 = hl2[2];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh2[2] = ah2 = c2 & 65535 | d2 << 16;
          hl2[2] = al2 = a & 65535 | b2 << 16;
          h2 = ah3;
          l2 = al3;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh2[3];
          l2 = hl2[3];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh2[3] = ah3 = c2 & 65535 | d2 << 16;
          hl2[3] = al3 = a & 65535 | b2 << 16;
          h2 = ah4;
          l2 = al4;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh2[4];
          l2 = hl2[4];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh2[4] = ah4 = c2 & 65535 | d2 << 16;
          hl2[4] = al4 = a & 65535 | b2 << 16;
          h2 = ah5;
          l2 = al5;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh2[5];
          l2 = hl2[5];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh2[5] = ah5 = c2 & 65535 | d2 << 16;
          hl2[5] = al5 = a & 65535 | b2 << 16;
          h2 = ah6;
          l2 = al6;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh2[6];
          l2 = hl2[6];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh2[6] = ah6 = c2 & 65535 | d2 << 16;
          hl2[6] = al6 = a & 65535 | b2 << 16;
          h2 = ah7;
          l2 = al7;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh2[7];
          l2 = hl2[7];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh2[7] = ah7 = c2 & 65535 | d2 << 16;
          hl2[7] = al7 = a & 65535 | b2 << 16;
          pos += 128;
          n2 -= 128;
        }
        return n2;
      }
      function crypto_hash(out, m2, n2) {
        var hh2 = new Int32Array(8), hl2 = new Int32Array(8), x2 = new Uint8Array(256), i2, b2 = n2;
        hh2[0] = 1779033703;
        hh2[1] = 3144134277;
        hh2[2] = 1013904242;
        hh2[3] = 2773480762;
        hh2[4] = 1359893119;
        hh2[5] = 2600822924;
        hh2[6] = 528734635;
        hh2[7] = 1541459225;
        hl2[0] = 4089235720;
        hl2[1] = 2227873595;
        hl2[2] = 4271175723;
        hl2[3] = 1595750129;
        hl2[4] = 2917565137;
        hl2[5] = 725511199;
        hl2[6] = 4215389547;
        hl2[7] = 327033209;
        crypto_hashblocks_hl(hh2, hl2, m2, n2);
        n2 %= 128;
        for (i2 = 0; i2 < n2; i2++)
          x2[i2] = m2[b2 - n2 + i2];
        x2[n2] = 128;
        n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
        x2[n2 - 9] = 0;
        ts64(x2, n2 - 8, b2 / 536870912 | 0, b2 << 3);
        crypto_hashblocks_hl(hh2, hl2, x2, n2);
        for (i2 = 0; i2 < 8; i2++)
          ts64(out, 8 * i2, hh2[i2], hl2[i2]);
        return 0;
      }
      function add(p2, q2) {
        var a = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e2 = gf2(), f2 = gf2(), g2 = gf2(), h2 = gf2(), t2 = gf2();
        Z2(a, p2[1], p2[0]);
        Z2(t2, q2[1], q2[0]);
        M2(a, a, t2);
        A2(b2, p2[0], p2[1]);
        A2(t2, q2[0], q2[1]);
        M2(b2, b2, t2);
        M2(c2, p2[3], q2[3]);
        M2(c2, c2, D22);
        M2(d2, p2[2], q2[2]);
        A2(d2, d2, d2);
        Z2(e2, b2, a);
        Z2(f2, d2, c2);
        A2(g2, d2, c2);
        A2(h2, b2, a);
        M2(p2[0], e2, f2);
        M2(p2[1], h2, g2);
        M2(p2[2], g2, f2);
        M2(p2[3], e2, h2);
      }
      function cswap(p2, q2, b2) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p2[i2], q2[i2], b2);
        }
      }
      function pack(r2, p2) {
        var tx = gf2(), ty = gf2(), zi2 = gf2();
        inv25519(zi2, p2[2]);
        M2(tx, p2[0], zi2);
        M2(ty, p2[1], zi2);
        pack25519(r2, ty);
        r2[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p2, q2, s2) {
        var b2, i2;
        set25519(p2[0], gf0);
        set25519(p2[1], gf1);
        set25519(p2[2], gf1);
        set25519(p2[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p2, q2, b2);
          add(q2, p2);
          add(p2, p2);
          cswap(p2, q2, b2);
        }
      }
      function scalarbase(p2, s2) {
        var q2 = [gf2(), gf2(), gf2(), gf2()];
        set25519(q2[0], X2);
        set25519(q2[1], Y2);
        set25519(q2[2], gf1);
        M2(q2[3], X2, Y2);
        scalarmult(p2, q2, s2);
      }
      function crypto_sign_keypair(pk2, sk2, seeded) {
        var d2 = new Uint8Array(64);
        var p2 = [gf2(), gf2(), gf2(), gf2()];
        var i2;
        if (!seeded)
          randombytes(sk2, 32);
        crypto_hash(d2, sk2, 32);
        d2[0] &= 248;
        d2[31] &= 127;
        d2[31] |= 64;
        scalarbase(p2, d2);
        pack(pk2, p2);
        for (i2 = 0; i2 < 32; i2++)
          sk2[i2 + 32] = pk2[i2];
        return 0;
      }
      var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r2, x2) {
        var carry, i2, j, k2;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j = i2 - 32, k2 = i2 - 12; j < k2; ++j) {
            x2[j] += carry - 16 * x2[i2] * L2[j - (i2 - 32)];
            carry = Math.floor((x2[j] + 128) / 256);
            x2[j] -= carry * 256;
          }
          x2[j] += carry;
          x2[i2] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x2[j] += carry - (x2[31] >> 4) * L2[j];
          carry = x2[j] >> 8;
          x2[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x2[j] -= carry * L2[j];
        for (i2 = 0; i2 < 32; i2++) {
          x2[i2 + 1] += x2[i2] >> 8;
          r2[i2] = x2[i2] & 255;
        }
      }
      function reduce(r2) {
        var x2 = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++)
          x2[i2] = r2[i2];
        for (i2 = 0; i2 < 64; i2++)
          r2[i2] = 0;
        modL(r2, x2);
      }
      function crypto_sign(sm, m2, n2, sk2) {
        var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r2 = new Uint8Array(64);
        var i2, j, x2 = new Float64Array(64);
        var p2 = [gf2(), gf2(), gf2(), gf2()];
        crypto_hash(d2, sk2, 32);
        d2[0] &= 248;
        d2[31] &= 127;
        d2[31] |= 64;
        var smlen = n2 + 64;
        for (i2 = 0; i2 < n2; i2++)
          sm[64 + i2] = m2[i2];
        for (i2 = 0; i2 < 32; i2++)
          sm[32 + i2] = d2[32 + i2];
        crypto_hash(r2, sm.subarray(32), n2 + 32);
        reduce(r2);
        scalarbase(p2, r2);
        pack(sm, p2);
        for (i2 = 32; i2 < 64; i2++)
          sm[i2] = sk2[i2];
        crypto_hash(h2, sm, n2 + 64);
        reduce(h2);
        for (i2 = 0; i2 < 64; i2++)
          x2[i2] = 0;
        for (i2 = 0; i2 < 32; i2++)
          x2[i2] = r2[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j = 0; j < 32; j++) {
            x2[i2 + j] += h2[i2] * d2[j];
          }
        }
        modL(sm.subarray(32), x2);
        return smlen;
      }
      function unpackneg(r2, p2) {
        var t2 = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
        set25519(r2[2], gf1);
        unpack25519(r2[1], p2);
        S2(num, r2[1]);
        M2(den, num, D2);
        Z2(num, num, r2[2]);
        A2(den, r2[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t2, den6, num);
        M2(t2, t2, den);
        pow2523(t2, t2);
        M2(t2, t2, num);
        M2(t2, t2, den);
        M2(t2, t2, den);
        M2(r2[0], t2, den);
        S2(chk, r2[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num))
          M2(r2[0], r2[0], I2);
        S2(chk, r2[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r2[0]) === p2[31] >> 7)
          Z2(r2[0], gf0, r2[0]);
        M2(r2[3], r2[0], r2[1]);
        return 0;
      }
      function crypto_sign_open(m2, sm, n2, pk2) {
        var i2;
        var t2 = new Uint8Array(32), h2 = new Uint8Array(64);
        var p2 = [gf2(), gf2(), gf2(), gf2()], q2 = [gf2(), gf2(), gf2(), gf2()];
        if (n2 < 64)
          return -1;
        if (unpackneg(q2, pk2))
          return -1;
        for (i2 = 0; i2 < n2; i2++)
          m2[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++)
          m2[i2 + 32] = pk2[i2];
        crypto_hash(h2, m2, n2);
        reduce(h2);
        scalarmult(p2, q2, h2);
        scalarbase(q2, sm.subarray(32));
        add(p2, q2);
        pack(t2, p2);
        n2 -= 64;
        if (crypto_verify_32(sm, 0, t2, 0)) {
          for (i2 = 0; i2 < n2; i2++)
            m2[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n2; i2++)
          m2[i2] = sm[i2 + 64];
        return n2;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf: gf2,
        D: D2,
        L: L2,
        pack25519,
        unpack25519,
        M: M2,
        A: A2,
        S: S2,
        Z: Z2,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k2, n2) {
        if (k2.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n2.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk2, sk2) {
        if (pk2.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk2.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++)
          arr[i2] = 0;
      }
      nacl.randomBytes = function(n2) {
        var b2 = new Uint8Array(n2);
        randombytes(b2, n2);
        return b2;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c2 = new Uint8Array(m2.length);
        for (var i2 = 0; i2 < msg.length; i2++)
          m2[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c2, m2, m2.length, nonce, key);
        return c2.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m2 = new Uint8Array(c2.length);
        for (var i2 = 0; i2 < box.length; i2++)
          c2[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c2.length < 32)
          return null;
        if (crypto_secretbox_open(m2, c2, c2.length, nonce, key) !== 0)
          return null;
        return m2.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n2, p2) {
        checkArrayTypes(n2, p2);
        if (n2.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p2.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q2, n2, p2);
        return q2;
      };
      nacl.scalarMult.base = function(n2) {
        checkArrayTypes(n2);
        if (n2.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q2, n2);
        return q2;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k2);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k2, publicKey, secretKey);
        return k2;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k2);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk2 = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk2, sk2);
        return { publicKey: pk2, secretKey: sk2 };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk2, secretKey);
        return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m2 = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m2.length; i2++)
          m2[i2] = tmp[i2];
        return m2;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++)
          sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++)
          sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++)
          sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk2, sk2);
        return { publicKey: pk2, secretKey: sk2 };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk2.length; i2++)
          pk2[i2] = secretKey[32 + i2];
        return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++)
          sk2[i2] = seed[i2];
        crypto_sign_keypair(pk2, sk2, true);
        return { publicKey: pk2, secretKey: sk2 };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x2, y2) {
        checkArrayTypes(x2, y2);
        if (x2.length === 0 || y2.length === 0)
          return false;
        if (x2.length !== y2.length)
          return false;
        return vn(x2, 0, y2, 0, x2.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x2, n2) {
            var i2, v2 = new Uint8Array(n2);
            for (i2 = 0; i2 < n2; i2 += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n2 - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n2; i2++)
              x2[i2] = v2[i2];
            cleanup(v2);
          });
        } else if (typeof commonjsRequire !== "undefined") {
          crypto2 = require$$0$1;
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function(x2, n2) {
              var i2, v2 = crypto2.randomBytes(n2);
              for (i2 = 0; i2 < n2; i2++)
                x2[i2] = v2[i2];
              cleanup(v2);
            });
          }
        }
      })();
    })(module2.exports ? module2.exports : self.nacl = self.nacl || {});
  })(naclFast);
  var naclFastExports = naclFast.exports;
  const SALT_SYMMETRIC = "salt-key-symmetric-";
  const SALT_SIGNING = "salt-key-signing-";
  const SALT_ENCRYPTION = "salt-key-encryption-";
  const SALT_SHARED = "salt-shared-";
  const SALT_SIG_SIGNING = "salt-sig-signing-";
  const SALT_SIG_ENCRYPTION = "salt-sig-encryption-";
  const SALT_SIG_HASH = "salt-sig-hash-";
  var naclUtil = { exports: {} };
  (function(module2) {
    (function(root2, f2) {
      if (module2.exports)
        module2.exports = f2();
      else if (root2.nacl)
        root2.nacl.util = f2();
      else {
        root2.nacl = {};
        root2.nacl.util = f2();
      }
    })(commonjsGlobal, function() {
      var util2 = {};
      function validateBase64(s2) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s2)) {
          throw new TypeError("invalid encoding");
        }
      }
      util2.decodeUTF8 = function(s2) {
        if (typeof s2 !== "string")
          throw new TypeError("expected string");
        var i2, d2 = unescape(encodeURIComponent(s2)), b2 = new Uint8Array(d2.length);
        for (i2 = 0; i2 < d2.length; i2++)
          b2[i2] = d2.charCodeAt(i2);
        return b2;
      };
      util2.encodeUTF8 = function(arr) {
        var i2, s2 = [];
        for (i2 = 0; i2 < arr.length; i2++)
          s2.push(String.fromCharCode(arr[i2]));
        return decodeURIComponent(escape(s2.join("")));
      };
      if (typeof atob === "undefined") {
        if (typeof Buffer.from !== "undefined") {
          util2.encodeBase64 = function(arr) {
            return Buffer.from(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(Buffer.from(s2, "base64"), 0));
          };
        } else {
          util2.encodeBase64 = function(arr) {
            return new Buffer(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(new Buffer(s2, "base64"), 0));
          };
        }
      } else {
        util2.encodeBase64 = function(arr) {
          var i2, s2 = [], len = arr.length;
          for (i2 = 0; i2 < len; i2++)
            s2.push(String.fromCharCode(arr[i2]));
          return btoa(s2.join(""));
        };
        util2.decodeBase64 = function(s2) {
          validateBase64(s2);
          var i2, d2 = atob(s2), b2 = new Uint8Array(d2.length);
          for (i2 = 0; i2 < d2.length; i2++)
            b2[i2] = d2.charCodeAt(i2);
          return b2;
        };
      }
      return util2;
    });
  })(naclUtil);
  var naclUtilExports = naclUtil.exports;
  var LvcErrorCode;
  (function(LvcErrorCode2) {
    LvcErrorCode2[LvcErrorCode2["Undefined"] = 0] = "Undefined";
    LvcErrorCode2[LvcErrorCode2["CouldNotDecrypt"] = 3000500] = "CouldNotDecrypt";
    LvcErrorCode2[LvcErrorCode2["InvalidLength"] = 3000400] = "InvalidLength";
    LvcErrorCode2[LvcErrorCode2["LoadingFromUnknownType"] = 3000401] = "LoadingFromUnknownType";
    LvcErrorCode2[LvcErrorCode2["InvalidSeedLength"] = 3000410] = "InvalidSeedLength";
    LvcErrorCode2[LvcErrorCode2["InvalidSecondarySeedLength"] = 3000411] = "InvalidSecondarySeedLength";
    LvcErrorCode2[LvcErrorCode2["InvalidSaltLength"] = 3000412] = "InvalidSaltLength";
    LvcErrorCode2[LvcErrorCode2["InvalidSecretLength"] = 3000413] = "InvalidSecretLength";
    LvcErrorCode2[LvcErrorCode2["InvalidTotpSecret"] = 3000414] = "InvalidTotpSecret";
    LvcErrorCode2[LvcErrorCode2["UnknownTotpAlgorithmError"] = 3000415] = "UnknownTotpAlgorithmError";
  })(LvcErrorCode || (LvcErrorCode = {}));
  const pleaseUpdate$2 = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
  class LvcDomainError extends DomainError$1 {
    constructor(code, short, userTitle, userDetail) {
      super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate$2);
    }
  }
  class CouldNotDecryptError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.CouldNotDecrypt, "could not decrypt message", "Could not decrypt", "The client tried to decrypt data using the wrong key.");
    }
  }
  class InvalidLengthError extends LvcDomainError {
    constructor(got, want) {
      super(LvcErrorCode.InvalidLength, `Found data of length ${got}, expected ${want}.`);
    }
  }
  class LoadingFromUnknownTypeError extends LvcDomainError {
    constructor(type) {
      super(LvcErrorCode.LoadingFromUnknownType, `Loading failed from unknown type ${type}}`);
    }
  }
  class InvalidSeedLengthError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidSeedLength, "Seed for derived key must be 32 bytes in length!");
    }
  }
  class InvalidSecondarySeedLengthError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidSecondarySeedLength, "Secondary seed for derived key must be 32 bytes in length!");
    }
  }
  class InvalidSaltLengthError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidSaltLength, "Salt for a derived key must be at least 8 bytes in length!");
    }
  }
  class InvalidSecretLengthError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidSecretLength, "Length of derived secret must be 32 or 64 bytes!");
    }
  }
  class InvalidTotpSecretError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidTotpSecret, "TOTP secret could not be decoded.");
    }
  }
  class UnknownTotpAlgorithmError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.UnknownTotpAlgorithmError, "TOTP algorithm unknown.", "Unknown TOTP algorithm", "Your client does not support the requested algorithm. Make sure you are using the latest version of our software then try again");
    }
  }
  function loadArrayOrBase64(data, expectedLength) {
    if (expectedLength !== void 0) {
      const array = loadArrayOrBase64(data);
      if (array.length !== expectedLength) {
        throw new InvalidLengthError(array.length, expectedLength);
      }
      return array;
    }
    if (data instanceof Uint8Array) {
      return data;
    }
    if (typeof data === "string") {
      return naclUtilExports.decodeBase64(data);
    }
    if (data.constructor.name === "ArrayBuffer" || data instanceof ArrayBuffer) {
      return new Uint8Array(data);
    }
    throw new LoadingFromUnknownTypeError(typeof data);
  }
  function concatArrays(...inputs) {
    const totalLength = inputs.map((a) => a.length).reduce((a, b2) => a + b2, 0);
    const result2 = new Uint8Array(totalLength);
    let offset = 0;
    for (const input of inputs) {
      result2.set(input, offset);
      offset += input.length;
    }
    return result2;
  }
  function deriveSecretFromSeed(seed, secondarySeed, salt, length = 32) {
    if (seed.length !== 32) {
      throw new InvalidSeedLengthError();
    }
    if (secondarySeed !== null && secondarySeed.length !== 32) {
      throw new InvalidSecondarySeedLengthError();
    }
    if (salt.length < 8) {
      throw new InvalidSaltLengthError();
    }
    if (length !== 32 && length !== 64) {
      throw new InvalidSecretLengthError();
    }
    let hashedSeed;
    if (secondarySeed === null) {
      hashedSeed = naclFastExports.hash(seed);
    } else {
      hashedSeed = naclFastExports.hash(concatArrays(seed, secondarySeed));
    }
    const hashedData = naclFastExports.hash(concatArrays(naclUtilExports.decodeUTF8(salt), hashedSeed));
    return hashedData.slice(0, length);
  }
  function randomSeed() {
    return naclFastExports.randomBytes(32);
  }
  function loadSymEncryptedBlob(data) {
    return loadArrayOrBase64(data);
  }
  function loadSymEncryptionKey(data) {
    return loadArrayOrBase64(data, naclFastExports.secretbox.keyLength);
  }
  function deriveSymEncryptionKey(seed, secondarySeed, salt) {
    return loadSymEncryptionKey(deriveSecretFromSeed(seed, secondarySeed, SALT_SYMMETRIC + salt, naclFastExports.secretbox.keyLength));
  }
  function newSymmetricSecret() {
    return naclFastExports.randomBytes(naclFastExports.secretbox.keyLength);
  }
  function symEncrypt(symKey, data) {
    const nonce = naclFastExports.randomBytes(naclFastExports.secretbox.nonceLength);
    const box = naclFastExports.secretbox(data, nonce, symKey);
    const fullMessage = new Uint8Array(nonce.length + box.length);
    fullMessage.set(nonce);
    fullMessage.set(box, nonce.length);
    return loadSymEncryptedBlob(fullMessage);
  }
  function symDecrypt(symKey, data) {
    const messageWithNonceAsUint8Array = data;
    const nonce = messageWithNonceAsUint8Array.slice(0, naclFastExports.secretbox.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(naclFastExports.secretbox.nonceLength, messageWithNonceAsUint8Array.length);
    const decrypted = naclFastExports.secretbox.open(message, nonce, symKey);
    if (!decrypted) {
      throw new CouldNotDecryptError();
    }
    return decrypted;
  }
  function symKeyToSas(symEncryptionKey) {
    const keyHash = naclFastExports.hash(symEncryptionKey);
    return keyHash.slice(0, 4).reduce((sas, value) => sas.concat((value % 10).toString()), "");
  }
  function loadSharedSecretPrivKey(data) {
    return loadArrayOrBase64(data, naclFastExports.scalarMult.scalarLength);
  }
  function loadSharedSecretPubKey(data) {
    return loadArrayOrBase64(data, naclFastExports.scalarMult.groupElementLength);
  }
  function newSharedSecretKeyPair() {
    const scalar = naclFastExports.randomBytes(naclFastExports.scalarMult.scalarLength);
    const sharedPrivKey = loadSharedSecretPrivKey(scalar);
    const sharedPubKey = loadSharedSecretPubKey(naclFastExports.scalarMult.base(sharedPrivKey));
    return { sharedPubKey, sharedPrivKey };
  }
  function combineSharedSecret(sharedPrivKey, sharedPubKey, salt) {
    const keyData = naclFastExports.scalarMult(sharedPrivKey, sharedPubKey);
    return deriveSymEncryptionKey(keyData, null, SALT_SHARED + salt);
  }
  function loadEncryptionPublicKey(data) {
    return loadArrayOrBase64(data, naclFastExports.box.publicKeyLength);
  }
  function loadEncryptionPrivateKey(data) {
    return loadArrayOrBase64(data, naclFastExports.box.secretKeyLength);
  }
  function loadAsymEncryptedBlob(data) {
    return loadArrayOrBase64(data);
  }
  function loadAsymEncryptedEncryptionPrivateKey(data) {
    return loadArrayOrBase64(data);
  }
  function deriveEncryptionKeyPair(seed, secondarySeed, salt) {
    const keyPair = naclFastExports.box.keyPair.fromSecretKey(deriveSecretFromSeed(seed, secondarySeed, SALT_ENCRYPTION + salt, naclFastExports.box.secretKeyLength));
    const encPrivKey = loadEncryptionPrivateKey(keyPair.secretKey);
    const encPubKey = loadEncryptionPublicKey(keyPair.publicKey);
    return { encPrivKey, encPubKey };
  }
  function newEncryptionKeyPair() {
    const keyPair = naclFastExports.box.keyPair();
    const encPrivKey = loadEncryptionPrivateKey(keyPair.secretKey);
    const encPubKey = loadEncryptionPublicKey(keyPair.publicKey);
    return { encPrivKey, encPubKey };
  }
  function asymEncrypt(encPubKey, data) {
    const ephemeralKeyPair = naclFastExports.box.keyPair();
    const nonce = naclFastExports.randomBytes(naclFastExports.box.nonceLength);
    const encryptedMessage = naclFastExports.box(data, nonce, encPubKey, ephemeralKeyPair.secretKey);
    const fullMessage = new Uint8Array(nonce.length + ephemeralKeyPair.publicKey.length + encryptedMessage.length);
    fullMessage.set(nonce);
    fullMessage.set(ephemeralKeyPair.publicKey, nonce.length);
    fullMessage.set(encryptedMessage, nonce.length + ephemeralKeyPair.publicKey.length);
    return loadAsymEncryptedBlob(fullMessage);
  }
  function asymDecrypt(encPrivKey, encryptedBlob) {
    const nonce = encryptedBlob.slice(0, naclFastExports.box.nonceLength);
    const publicKey = encryptedBlob.slice(naclFastExports.box.nonceLength, naclFastExports.box.nonceLength + naclFastExports.box.publicKeyLength);
    const message = encryptedBlob.slice(naclFastExports.box.nonceLength + naclFastExports.box.publicKeyLength, encryptedBlob.length);
    const decryptedMessage = naclFastExports.box.open(message, nonce, publicKey, encPrivKey);
    if (!decryptedMessage) {
      throw new CouldNotDecryptError();
    }
    return decryptedMessage;
  }
  function loadSigningPublicKey(data) {
    return loadArrayOrBase64(data, naclFastExports.sign.publicKeyLength);
  }
  function loadSigningPrivateKey(data) {
    return loadArrayOrBase64(data, naclFastExports.sign.secretKeyLength);
  }
  function loadSignature(data) {
    return loadArrayOrBase64(data, naclFastExports.sign.signatureLength);
  }
  function deriveSigningKeyPair(seed, secondarySeed, salt) {
    const keyPair = naclFastExports.sign.keyPair.fromSeed(deriveSecretFromSeed(seed, secondarySeed, SALT_SIGNING + salt, naclFastExports.sign.seedLength));
    const sigPrivKey = loadSigningPrivateKey(keyPair.secretKey);
    const sigPubKey = loadSigningPublicKey(keyPair.publicKey);
    return { sigPrivKey, sigPubKey };
  }
  function sign(sigPrivKey, data, salt) {
    const signedData = salt ? concatArrays(naclUtilExports.decodeUTF8(salt), data) : data;
    const signature = naclFastExports.sign.detached(signedData, sigPrivKey);
    return loadSignature(signature);
  }
  function verifySignature(sigPubKey, signature, data, salt) {
    const signedData = salt ? concatArrays(naclUtilExports.decodeUTF8(salt), data) : data;
    return naclFastExports.sign.detached.verify(signedData, signature, sigPubKey);
  }
  function signString(key, data, salt) {
    return sign(key, naclUtilExports.decodeUTF8(data), salt);
  }
  function signingPublicKeyEqual(sigPubKey1, sigPubKey2) {
    return naclFastExports.verify(sigPubKey1, sigPubKey2);
  }
  const HASH_LENGTH = 32;
  function loadHash(data) {
    return loadArrayOrBase64(data, HASH_LENGTH);
  }
  function hashData(blob) {
    return loadHash(naclFastExports.hash(blob).slice(0, HASH_LENGTH));
  }
  function hashEqual(hash1, hash2) {
    return naclFastExports.verify(hash1, hash2);
  }
  function verifyHash(hash2, blob) {
    return hashEqual(hash2, hashData(blob));
  }
  function loadEncryptionPublicKeySignature(data) {
    return loadSignature(data);
  }
  function loadSigningPublicKeySignature(data) {
    return loadSignature(data);
  }
  function loadAsymEncryptedSymmetricKey(data) {
    return loadAsymEncryptedBlob(data);
  }
  function symEncryptSymmetricEncryptionKey(symKey, symKeyToEncrypt) {
    const symKeyEncrypted = symEncrypt(symKey, symKeyToEncrypt);
    return symKeyEncrypted;
  }
  function asymCreateKek(asymKey, symKey) {
    const asymEncryptedBlob = asymEncrypt(asymKey, symKey);
    return loadAsymEncryptedSymmetricKey(asymEncryptedBlob);
  }
  function asymDecryptKek(asymKey, kek) {
    const symKey = asymDecrypt(asymKey, kek);
    return loadSymEncryptionKey(symKey);
  }
  function asymEncryptEncryptionPrivateKey(encryptionKey, payloadKey) {
    const asymEncryptedBlob = asymEncrypt(encryptionKey, payloadKey);
    return loadAsymEncryptedEncryptionPrivateKey(asymEncryptedBlob);
  }
  function asymDecryptEncryptionPrivateKey(decryptionKey, encryptedKey) {
    const decryptedKey = asymDecrypt(decryptionKey, encryptedKey);
    return loadEncryptionPrivateKey(decryptedKey);
  }
  function signEncryptionPublicKey(sigPrivKey, encPubKey, salt) {
    const encPubKeySignature = sign(sigPrivKey, encPubKey, SALT_SIG_ENCRYPTION + salt);
    return encPubKeySignature;
  }
  function verifySignedEncryptionPublicKey(verifyingKey, encPubKey, encPubKeySignature, salt) {
    return verifySignature(verifyingKey, encPubKeySignature, encPubKey, SALT_SIG_ENCRYPTION + salt);
  }
  function signSigningPublicKey(sigPrivKey, sigPubKey, salt) {
    const sigPubKeySignature = sign(sigPrivKey, sigPubKey, SALT_SIG_SIGNING + salt);
    return sigPubKeySignature;
  }
  function verifySignedSigningPublicKey(verifyingSigPubKey, sigPubKey, sigPubKeySignature, salt) {
    return verifySignature(verifyingSigPubKey, sigPubKeySignature, sigPubKey, SALT_SIG_SIGNING + salt);
  }
  function signHash(signKey, hash2) {
    const hashSig = sign(signKey, hash2, SALT_SIG_HASH);
    return hashSig;
  }
  function hashAndSign(signKey, data) {
    const hash2 = hashData(data);
    return signHash(signKey, hash2);
  }
  function verifyHashSignature(verifyingKey, signature, hash2) {
    return verifySignature(verifyingKey, signature, hash2, SALT_SIG_HASH);
  }
  var hash$2 = {};
  var utils$9 = {};
  var minimalisticAssert = assert$5;
  function assert$5(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert$5.equal = function assertEqual(l2, r2, msg) {
    if (l2 != r2)
      throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
  };
  var inherits_browser = { exports: {} };
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  var inherits_browserExports = inherits_browser.exports;
  var assert$4 = minimalisticAssert;
  var inherits = inherits_browserExports;
  utils$9.inherits = inherits;
  function isSurrogatePair(msg, i2) {
    if ((msg.charCodeAt(i2) & 64512) !== 55296) {
      return false;
    }
    if (i2 < 0 || i2 + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
  }
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p2 = 0;
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c2 = msg.charCodeAt(i2);
          if (c2 < 128) {
            res[p2++] = c2;
          } else if (c2 < 2048) {
            res[p2++] = c2 >> 6 | 192;
            res[p2++] = c2 & 63 | 128;
          } else if (isSurrogatePair(msg, i2)) {
            c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
            res[p2++] = c2 >> 18 | 240;
            res[p2++] = c2 >> 12 & 63 | 128;
            res[p2++] = c2 >> 6 & 63 | 128;
            res[p2++] = c2 & 63 | 128;
          } else {
            res[p2++] = c2 >> 12 | 224;
            res[p2++] = c2 >> 6 & 63 | 128;
            res[p2++] = c2 & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      }
    } else {
      for (i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
    }
    return res;
  }
  utils$9.toArray = toArray;
  function toHex(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils$9.toHex = toHex;
  function htonl(w2) {
    var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
    return res >>> 0;
  }
  utils$9.htonl = htonl;
  function toHex32(msg, endian) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++) {
      var w2 = msg[i2];
      if (endian === "little")
        w2 = htonl(w2);
      res += zero8(w2.toString(16));
    }
    return res;
  }
  utils$9.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils$9.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  }
  utils$9.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len = end - start;
    assert$4(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i2 = 0, k2 = start; i2 < res.length; i2++, k2 += 4) {
      var w2;
      if (endian === "big")
        w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
      else
        w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
      res[i2] = w2 >>> 0;
    }
    return res;
  }
  utils$9.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i2 = 0, k2 = 0; i2 < msg.length; i2++, k2 += 4) {
      var m2 = msg[i2];
      if (endian === "big") {
        res[k2] = m2 >>> 24;
        res[k2 + 1] = m2 >>> 16 & 255;
        res[k2 + 2] = m2 >>> 8 & 255;
        res[k2 + 3] = m2 & 255;
      } else {
        res[k2 + 3] = m2 >>> 24;
        res[k2 + 2] = m2 >>> 16 & 255;
        res[k2 + 1] = m2 >>> 8 & 255;
        res[k2] = m2 & 255;
      }
    }
    return res;
  }
  utils$9.split32 = split32;
  function rotr32$1(w2, b2) {
    return w2 >>> b2 | w2 << 32 - b2;
  }
  utils$9.rotr32 = rotr32$1;
  function rotl32$2(w2, b2) {
    return w2 << b2 | w2 >>> 32 - b2;
  }
  utils$9.rotl32 = rotl32$2;
  function sum32$3(a, b2) {
    return a + b2 >>> 0;
  }
  utils$9.sum32 = sum32$3;
  function sum32_3$1(a, b2, c2) {
    return a + b2 + c2 >>> 0;
  }
  utils$9.sum32_3 = sum32_3$1;
  function sum32_4$2(a, b2, c2, d2) {
    return a + b2 + c2 + d2 >>> 0;
  }
  utils$9.sum32_4 = sum32_4$2;
  function sum32_5$2(a, b2, c2, d2, e2) {
    return a + b2 + c2 + d2 + e2 >>> 0;
  }
  utils$9.sum32_5 = sum32_5$2;
  function sum64$1(buf, pos, ah2, al2) {
    var bh2 = buf[pos];
    var bl2 = buf[pos + 1];
    var lo2 = al2 + bl2 >>> 0;
    var hi2 = (lo2 < al2 ? 1 : 0) + ah2 + bh2;
    buf[pos] = hi2 >>> 0;
    buf[pos + 1] = lo2;
  }
  utils$9.sum64 = sum64$1;
  function sum64_hi$1(ah2, al2, bh2, bl2) {
    var lo2 = al2 + bl2 >>> 0;
    var hi2 = (lo2 < al2 ? 1 : 0) + ah2 + bh2;
    return hi2 >>> 0;
  }
  utils$9.sum64_hi = sum64_hi$1;
  function sum64_lo$1(ah2, al2, bh2, bl2) {
    var lo2 = al2 + bl2;
    return lo2 >>> 0;
  }
  utils$9.sum64_lo = sum64_lo$1;
  function sum64_4_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
    var carry = 0;
    var lo2 = al2;
    lo2 = lo2 + bl2 >>> 0;
    carry += lo2 < al2 ? 1 : 0;
    lo2 = lo2 + cl2 >>> 0;
    carry += lo2 < cl2 ? 1 : 0;
    lo2 = lo2 + dl2 >>> 0;
    carry += lo2 < dl2 ? 1 : 0;
    var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
    return hi2 >>> 0;
  }
  utils$9.sum64_4_hi = sum64_4_hi$1;
  function sum64_4_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
    var lo2 = al2 + bl2 + cl2 + dl2;
    return lo2 >>> 0;
  }
  utils$9.sum64_4_lo = sum64_4_lo$1;
  function sum64_5_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
    var carry = 0;
    var lo2 = al2;
    lo2 = lo2 + bl2 >>> 0;
    carry += lo2 < al2 ? 1 : 0;
    lo2 = lo2 + cl2 >>> 0;
    carry += lo2 < cl2 ? 1 : 0;
    lo2 = lo2 + dl2 >>> 0;
    carry += lo2 < dl2 ? 1 : 0;
    lo2 = lo2 + el2 >>> 0;
    carry += lo2 < el2 ? 1 : 0;
    var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
    return hi2 >>> 0;
  }
  utils$9.sum64_5_hi = sum64_5_hi$1;
  function sum64_5_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
    var lo2 = al2 + bl2 + cl2 + dl2 + el2;
    return lo2 >>> 0;
  }
  utils$9.sum64_5_lo = sum64_5_lo$1;
  function rotr64_hi$1(ah2, al2, num) {
    var r2 = al2 << 32 - num | ah2 >>> num;
    return r2 >>> 0;
  }
  utils$9.rotr64_hi = rotr64_hi$1;
  function rotr64_lo$1(ah2, al2, num) {
    var r2 = ah2 << 32 - num | al2 >>> num;
    return r2 >>> 0;
  }
  utils$9.rotr64_lo = rotr64_lo$1;
  function shr64_hi$1(ah2, al2, num) {
    return ah2 >>> num;
  }
  utils$9.shr64_hi = shr64_hi$1;
  function shr64_lo$1(ah2, al2, num) {
    var r2 = ah2 << 32 - num | al2 >>> num;
    return r2 >>> 0;
  }
  utils$9.shr64_lo = shr64_lo$1;
  var common$5 = {};
  var utils$8 = utils$9;
  var assert$3 = minimalisticAssert;
  function BlockHash$4() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  common$5.BlockHash = BlockHash$4;
  BlockHash$4.prototype.update = function update(msg, enc) {
    msg = utils$8.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r2 = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r2, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils$8.join32(msg, 0, msg.length - r2, this.endian);
      for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
        this._update(msg, i2, i2 + this._delta32);
    }
    return this;
  };
  BlockHash$4.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert$3(this.pending === null);
    return this._digest(enc);
  };
  BlockHash$4.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k2 = bytes - (len + this.padLength) % bytes;
    var res = new Array(k2 + this.padLength);
    res[0] = 128;
    for (var i2 = 1; i2 < k2; i2++)
      res[i2] = 0;
    len <<= 3;
    if (this.endian === "big") {
      for (var t2 = 8; t2 < this.padLength; t2++)
        res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = len >>> 24 & 255;
      res[i2++] = len >>> 16 & 255;
      res[i2++] = len >>> 8 & 255;
      res[i2++] = len & 255;
    } else {
      res[i2++] = len & 255;
      res[i2++] = len >>> 8 & 255;
      res[i2++] = len >>> 16 & 255;
      res[i2++] = len >>> 24 & 255;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      for (t2 = 8; t2 < this.padLength; t2++)
        res[i2++] = 0;
    }
    return res;
  };
  var sha = {};
  var common$4 = {};
  var utils$7 = utils$9;
  var rotr32 = utils$7.rotr32;
  function ft_1$1(s2, x2, y2, z2) {
    if (s2 === 0)
      return ch32$1(x2, y2, z2);
    if (s2 === 1 || s2 === 3)
      return p32(x2, y2, z2);
    if (s2 === 2)
      return maj32$1(x2, y2, z2);
  }
  common$4.ft_1 = ft_1$1;
  function ch32$1(x2, y2, z2) {
    return x2 & y2 ^ ~x2 & z2;
  }
  common$4.ch32 = ch32$1;
  function maj32$1(x2, y2, z2) {
    return x2 & y2 ^ x2 & z2 ^ y2 & z2;
  }
  common$4.maj32 = maj32$1;
  function p32(x2, y2, z2) {
    return x2 ^ y2 ^ z2;
  }
  common$4.p32 = p32;
  function s0_256$1(x2) {
    return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
  }
  common$4.s0_256 = s0_256$1;
  function s1_256$1(x2) {
    return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
  }
  common$4.s1_256 = s1_256$1;
  function g0_256$1(x2) {
    return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
  }
  common$4.g0_256 = g0_256$1;
  function g1_256$1(x2) {
    return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
  }
  common$4.g1_256 = g1_256$1;
  var utils$6 = utils$9;
  var common$3 = common$5;
  var shaCommon$1 = common$4;
  var rotl32$1 = utils$6.rotl32;
  var sum32$2 = utils$6.sum32;
  var sum32_5$1 = utils$6.sum32_5;
  var ft_1 = shaCommon$1.ft_1;
  var BlockHash$3 = common$3.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash$3.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  }
  utils$6.inherits(SHA1, BlockHash$3);
  var _1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W2 = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W2[i2] = msg[start + i2];
    for (; i2 < W2.length; i2++)
      W2[i2] = rotl32$1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
    var a = this.h[0];
    var b2 = this.h[1];
    var c2 = this.h[2];
    var d2 = this.h[3];
    var e2 = this.h[4];
    for (i2 = 0; i2 < W2.length; i2++) {
      var s2 = ~~(i2 / 20);
      var t2 = sum32_5$1(rotl32$1(a, 5), ft_1(s2, b2, c2, d2), e2, W2[i2], sha1_K[s2]);
      e2 = d2;
      d2 = c2;
      c2 = rotl32$1(b2, 30);
      b2 = a;
      a = t2;
    }
    this.h[0] = sum32$2(this.h[0], a);
    this.h[1] = sum32$2(this.h[1], b2);
    this.h[2] = sum32$2(this.h[2], c2);
    this.h[3] = sum32$2(this.h[3], d2);
    this.h[4] = sum32$2(this.h[4], e2);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$6.toHex32(this.h, "big");
    else
      return utils$6.split32(this.h, "big");
  };
  var utils$5 = utils$9;
  var common$2 = common$5;
  var shaCommon = common$4;
  var assert$2 = minimalisticAssert;
  var sum32$1 = utils$5.sum32;
  var sum32_4$1 = utils$5.sum32_4;
  var sum32_5 = utils$5.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash$2 = common$2.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function SHA256$1() {
    if (!(this instanceof SHA256$1))
      return new SHA256$1();
    BlockHash$2.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils$5.inherits(SHA256$1, BlockHash$2);
  var _256 = SHA256$1;
  SHA256$1.blockSize = 512;
  SHA256$1.outSize = 256;
  SHA256$1.hmacStrength = 192;
  SHA256$1.padLength = 64;
  SHA256$1.prototype._update = function _update(msg, start) {
    var W2 = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W2[i2] = msg[start + i2];
    for (; i2 < W2.length; i2++)
      W2[i2] = sum32_4$1(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
    var a = this.h[0];
    var b2 = this.h[1];
    var c2 = this.h[2];
    var d2 = this.h[3];
    var e2 = this.h[4];
    var f2 = this.h[5];
    var g2 = this.h[6];
    var h2 = this.h[7];
    assert$2(this.k.length === W2.length);
    for (i2 = 0; i2 < W2.length; i2++) {
      var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i2], W2[i2]);
      var T2 = sum32$1(s0_256(a), maj32(a, b2, c2));
      h2 = g2;
      g2 = f2;
      f2 = e2;
      e2 = sum32$1(d2, T1);
      d2 = c2;
      c2 = b2;
      b2 = a;
      a = sum32$1(T1, T2);
    }
    this.h[0] = sum32$1(this.h[0], a);
    this.h[1] = sum32$1(this.h[1], b2);
    this.h[2] = sum32$1(this.h[2], c2);
    this.h[3] = sum32$1(this.h[3], d2);
    this.h[4] = sum32$1(this.h[4], e2);
    this.h[5] = sum32$1(this.h[5], f2);
    this.h[6] = sum32$1(this.h[6], g2);
    this.h[7] = sum32$1(this.h[7], h2);
  };
  SHA256$1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$5.toHex32(this.h, "big");
    else
      return utils$5.split32(this.h, "big");
  };
  var utils$4 = utils$9;
  var SHA256 = _256;
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  utils$4.inherits(SHA224, SHA256);
  var _224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$4.toHex32(this.h.slice(0, 7), "big");
    else
      return utils$4.split32(this.h.slice(0, 7), "big");
  };
  var utils$3 = utils$9;
  var common$1 = common$5;
  var assert$1 = minimalisticAssert;
  var rotr64_hi = utils$3.rotr64_hi;
  var rotr64_lo = utils$3.rotr64_lo;
  var shr64_hi = utils$3.shr64_hi;
  var shr64_lo = utils$3.shr64_lo;
  var sum64 = utils$3.sum64;
  var sum64_hi = utils$3.sum64_hi;
  var sum64_lo = utils$3.sum64_lo;
  var sum64_4_hi = utils$3.sum64_4_hi;
  var sum64_4_lo = utils$3.sum64_4_lo;
  var sum64_5_hi = utils$3.sum64_5_hi;
  var sum64_5_lo = utils$3.sum64_5_lo;
  var BlockHash$1 = common$1.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function SHA512$1() {
    if (!(this instanceof SHA512$1))
      return new SHA512$1();
    BlockHash$1.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils$3.inherits(SHA512$1, BlockHash$1);
  var _512 = SHA512$1;
  SHA512$1.blockSize = 1024;
  SHA512$1.outSize = 512;
  SHA512$1.hmacStrength = 192;
  SHA512$1.padLength = 128;
  SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W2 = this.W;
    for (var i2 = 0; i2 < 32; i2++)
      W2[i2] = msg[start + i2];
    for (; i2 < W2.length; i2 += 2) {
      var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
      var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
      var c1_hi = W2[i2 - 14];
      var c1_lo = W2[i2 - 13];
      var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
      var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
      var c3_hi = W2[i2 - 32];
      var c3_lo = W2[i2 - 31];
      W2[i2] = sum64_4_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
      W2[i2 + 1] = sum64_4_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
    }
  };
  SHA512$1.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W2 = this.W;
    var ah2 = this.h[0];
    var al2 = this.h[1];
    var bh2 = this.h[2];
    var bl2 = this.h[3];
    var ch2 = this.h[4];
    var cl2 = this.h[5];
    var dh2 = this.h[6];
    var dl2 = this.h[7];
    var eh2 = this.h[8];
    var el2 = this.h[9];
    var fh2 = this.h[10];
    var fl2 = this.h[11];
    var gh2 = this.h[12];
    var gl2 = this.h[13];
    var hh2 = this.h[14];
    var hl2 = this.h[15];
    assert$1(this.k.length === W2.length);
    for (var i2 = 0; i2 < W2.length; i2 += 2) {
      var c0_hi = hh2;
      var c0_lo = hl2;
      var c1_hi = s1_512_hi(eh2, el2);
      var c1_lo = s1_512_lo(eh2, el2);
      var c2_hi = ch64_hi(eh2, el2, fh2, fl2, gh2);
      var c2_lo = ch64_lo(eh2, el2, fh2, fl2, gh2, gl2);
      var c3_hi = this.k[i2];
      var c3_lo = this.k[i2 + 1];
      var c4_hi = W2[i2];
      var c4_lo = W2[i2 + 1];
      var T1_hi = sum64_5_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      var T1_lo = sum64_5_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      c0_hi = s0_512_hi(ah2, al2);
      c0_lo = s0_512_lo(ah2, al2);
      c1_hi = maj64_hi(ah2, al2, bh2, bl2, ch2);
      c1_lo = maj64_lo(ah2, al2, bh2, bl2, ch2, cl2);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh2 = gh2;
      hl2 = gl2;
      gh2 = fh2;
      gl2 = fl2;
      fh2 = eh2;
      fl2 = el2;
      eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
      el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
      dh2 = ch2;
      dl2 = cl2;
      ch2 = bh2;
      cl2 = bl2;
      bh2 = ah2;
      bl2 = al2;
      ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah2, al2);
    sum64(this.h, 2, bh2, bl2);
    sum64(this.h, 4, ch2, cl2);
    sum64(this.h, 6, dh2, dl2);
    sum64(this.h, 8, eh2, el2);
    sum64(this.h, 10, fh2, fl2);
    sum64(this.h, 12, gh2, gl2);
    sum64(this.h, 14, hh2, hl2);
  };
  SHA512$1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$3.toHex32(this.h, "big");
    else
      return utils$3.split32(this.h, "big");
  };
  function ch64_hi(xh2, xl2, yh2, yl2, zh2) {
    var r2 = xh2 & yh2 ^ ~xh2 & zh2;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function ch64_lo(xh2, xl2, yh2, yl2, zh2, zl2) {
    var r2 = xl2 & yl2 ^ ~xl2 & zl2;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_hi(xh2, xl2, yh2, yl2, zh2) {
    var r2 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_lo(xh2, xl2, yh2, yl2, zh2, zl2) {
    var r2 = xl2 & yl2 ^ xl2 & zl2 ^ yl2 & zl2;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_hi(xh2, xl2) {
    var c0_hi = rotr64_hi(xh2, xl2, 28);
    var c1_hi = rotr64_hi(xl2, xh2, 2);
    var c2_hi = rotr64_hi(xl2, xh2, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_lo(xh2, xl2) {
    var c0_lo = rotr64_lo(xh2, xl2, 28);
    var c1_lo = rotr64_lo(xl2, xh2, 2);
    var c2_lo = rotr64_lo(xl2, xh2, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_hi(xh2, xl2) {
    var c0_hi = rotr64_hi(xh2, xl2, 14);
    var c1_hi = rotr64_hi(xh2, xl2, 18);
    var c2_hi = rotr64_hi(xl2, xh2, 9);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_lo(xh2, xl2) {
    var c0_lo = rotr64_lo(xh2, xl2, 14);
    var c1_lo = rotr64_lo(xh2, xl2, 18);
    var c2_lo = rotr64_lo(xl2, xh2, 9);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_hi(xh2, xl2) {
    var c0_hi = rotr64_hi(xh2, xl2, 1);
    var c1_hi = rotr64_hi(xh2, xl2, 8);
    var c2_hi = shr64_hi(xh2, xl2, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_lo(xh2, xl2) {
    var c0_lo = rotr64_lo(xh2, xl2, 1);
    var c1_lo = rotr64_lo(xh2, xl2, 8);
    var c2_lo = shr64_lo(xh2, xl2, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_hi(xh2, xl2) {
    var c0_hi = rotr64_hi(xh2, xl2, 19);
    var c1_hi = rotr64_hi(xl2, xh2, 29);
    var c2_hi = shr64_hi(xh2, xl2, 6);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_lo(xh2, xl2) {
    var c0_lo = rotr64_lo(xh2, xl2, 19);
    var c1_lo = rotr64_lo(xl2, xh2, 29);
    var c2_lo = shr64_lo(xh2, xl2, 6);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  var utils$2 = utils$9;
  var SHA512 = _512;
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  utils$2.inherits(SHA384, SHA512);
  var _384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$2.toHex32(this.h.slice(0, 12), "big");
    else
      return utils$2.split32(this.h.slice(0, 12), "big");
  };
  sha.sha1 = _1;
  sha.sha224 = _224;
  sha.sha256 = _256;
  sha.sha384 = _384;
  sha.sha512 = _512;
  var ripemd = {};
  var utils$1 = utils$9;
  var common = common$5;
  var rotl32 = utils$1.rotl32;
  var sum32 = utils$1.sum32;
  var sum32_3 = utils$1.sum32_3;
  var sum32_4 = utils$1.sum32_4;
  var BlockHash = common.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  }
  utils$1.inherits(RIPEMD160, BlockHash);
  ripemd.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A2 = this.h[0];
    var B2 = this.h[1];
    var C2 = this.h[2];
    var D2 = this.h[3];
    var E2 = this.h[4];
    var Ah2 = A2;
    var Bh2 = B2;
    var Ch2 = C2;
    var Dh2 = D2;
    var Eh2 = E2;
    for (var j = 0; j < 80; j++) {
      var T2 = sum32(
        rotl32(
          sum32_4(A2, f$4(j, B2, C2, D2), msg[r$3[j] + start], K(j)),
          s[j]
        ),
        E2
      );
      A2 = E2;
      E2 = D2;
      D2 = rotl32(C2, 10);
      C2 = B2;
      B2 = T2;
      T2 = sum32(
        rotl32(
          sum32_4(Ah2, f$4(79 - j, Bh2, Ch2, Dh2), msg[rh$1[j] + start], Kh$1(j)),
          sh$1[j]
        ),
        Eh2
      );
      Ah2 = Eh2;
      Eh2 = Dh2;
      Dh2 = rotl32(Ch2, 10);
      Ch2 = Bh2;
      Bh2 = T2;
    }
    T2 = sum32_3(this.h[1], C2, Dh2);
    this.h[1] = sum32_3(this.h[2], D2, Eh2);
    this.h[2] = sum32_3(this.h[3], E2, Ah2);
    this.h[3] = sum32_3(this.h[4], A2, Bh2);
    this.h[4] = sum32_3(this.h[0], B2, Ch2);
    this.h[0] = T2;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$1.toHex32(this.h, "little");
    else
      return utils$1.split32(this.h, "little");
  };
  function f$4(j, x2, y2, z2) {
    if (j <= 15)
      return x2 ^ y2 ^ z2;
    else if (j <= 31)
      return x2 & y2 | ~x2 & z2;
    else if (j <= 47)
      return (x2 | ~y2) ^ z2;
    else if (j <= 63)
      return x2 & z2 | y2 & ~z2;
    else
      return x2 ^ (y2 | ~z2);
  }
  function K(j) {
    if (j <= 15)
      return 0;
    else if (j <= 31)
      return 1518500249;
    else if (j <= 47)
      return 1859775393;
    else if (j <= 63)
      return 2400959708;
    else
      return 2840853838;
  }
  function Kh$1(j) {
    if (j <= 15)
      return 1352829926;
    else if (j <= 31)
      return 1548603684;
    else if (j <= 47)
      return 1836072691;
    else if (j <= 63)
      return 2053994217;
    else
      return 0;
  }
  var r$3 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh$1 = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh$1 = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  var utils = utils$9;
  var assert = minimalisticAssert;
  function Hmac(hash2, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash2, key, enc);
    this.Hash = hash2;
    this.blockSize = hash2.blockSize / 8;
    this.outSize = hash2.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
  }
  var hmac = Hmac;
  Hmac.prototype._init = function init2(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    for (var i2 = key.length; i2 < this.blockSize; i2++)
      key.push(0);
    for (i2 = 0; i2 < key.length; i2++)
      key[i2] ^= 54;
    this.inner = new this.Hash().update(key);
    for (i2 = 0; i2 < key.length; i2++)
      key[i2] ^= 106;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  (function(exports2) {
    var hash2 = exports2;
    hash2.utils = utils$9;
    hash2.common = common$5;
    hash2.sha = sha;
    hash2.ripemd = ripemd;
    hash2.hmac = hmac;
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  })(hash$2);
  const hash$1 = /* @__PURE__ */ getDefaultExportFromCjs(hash$2);
  var TotpAlgorithm;
  (function(TotpAlgorithm2) {
    TotpAlgorithm2["unknown"] = "unknown";
    TotpAlgorithm2["sha1"] = "sha1";
    TotpAlgorithm2["sha256"] = "sha256";
    TotpAlgorithm2["sha512"] = "sha512";
  })(TotpAlgorithm || (TotpAlgorithm = {}));
  const DEFAULT_TOTP_ALGORITHM = TotpAlgorithm.sha1;
  const DEFAULT_TOTP_DIGITS = 6;
  const DEFAULT_TOTP_PERIOD = 30;
  const B32_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  function calculateTotp(secretBase32, algorithm, digits, period, now = Date.now()) {
    const epoch = Math.round(now / 1e3);
    const counter = Math.floor(epoch / period);
    const epochStart = counter * period * 1e3;
    const epochEnd = (counter + 1) * period * 1e3;
    const epochLeftMs = epochEnd - now;
    const totp = calculateHotp(secretBase32, algorithm, digits, counter);
    return { totp, epochStart, epochEnd, epochLeftMs };
  }
  function calculateHotp(secretBase32, algorithm, digits, counter) {
    const secret = base32tohex(secretBase32);
    const hexCounter = zeropad(counter.toString(16), 16);
    let hashAlgorithm;
    switch (algorithm) {
      case TotpAlgorithm.sha1:
        hashAlgorithm = hash$1.sha1;
        break;
      case TotpAlgorithm.sha256:
        hashAlgorithm = hash$1.sha256;
        break;
      case TotpAlgorithm.sha512:
        hashAlgorithm = hash$1.sha512;
        break;
      default:
        throw new UnknownTotpAlgorithmError();
    }
    const hmac2 = hash$1.hmac(hashAlgorithm, secret, "hex").update(hexCounter, "hex").digest("hex");
    const offset = parseInt(hmac2.substring(hmac2.length - 1), 16);
    const otpFull = (parseInt(hmac2.substring(offset * 2, offset * 2 + 8), 16) & 2147483647).toString();
    const otp = otpFull.substring(otpFull.length - digits, otpFull.length);
    return otp;
  }
  function base32tohex(base32) {
    base32 = base32.toUpperCase();
    const missingPaddingCharacters = 8 - base32.length % 8;
    if (missingPaddingCharacters !== 8) {
      base32 += "=".repeat(missingPaddingCharacters);
    }
    let bits = "";
    for (let i2 = 0; i2 < base32.length; i2 += 1) {
      const c2 = base32.charAt(i2);
      const val = B32_CHARS.indexOf(c2);
      if (val === -1) {
        if (c2 === "=") {
          const pad = base32.slice(i2, base32.length);
          if (pad === "=") {
            bits = bits.slice(0, -3);
          } else if (pad === "===") {
            bits = bits.slice(0, -1);
          } else if (pad === "====") {
            bits = bits.slice(0, -4);
          } else if (pad === "======") {
            bits = bits.slice(0, -2);
          } else {
            throw new InvalidTotpSecretError();
          }
          break;
        }
        throw new InvalidTotpSecretError();
      }
      bits += zeropad(val.toString(2), 5);
    }
    let hex = "";
    for (let i2 = 0; i2 + 4 <= bits.length; i2 += 4) {
      const chunk = bits.substr(i2, 4);
      hex += parseInt(chunk, 2).toString(16);
    }
    return hex;
  }
  function zeropad(str, len) {
    if (len <= str.length) {
      return str;
    }
    return Array(len + 1 - str.length).join("0") + str;
  }
  function canonicalize(obj) {
    var buffer = "";
    serialize(obj);
    return buffer;
    function serialize(object) {
      if (object === null || typeof object !== "object" || object.toJSON != null) {
        buffer += JSON.stringify(object);
      } else if (Array.isArray(object)) {
        buffer += "[";
        var next_1 = false;
        object.forEach(function(element) {
          if (next_1) {
            buffer += ",";
          }
          next_1 = true;
          serialize(element);
        });
        buffer += "]";
      } else {
        buffer += "{";
        var vKeys = Object.keys(object).sort();
        vKeys.forEach(function(property, index2) {
          return addProp(object, property, index2);
        });
        buffer += "}";
      }
    }
    function addProp(object, property, index2) {
      if (index2 > 0) {
        buffer += ",";
      }
      buffer += JSON.stringify(property);
      buffer += ":";
      serialize(object[property]);
    }
  }
  function brandedUint8Array(loader) {
    return z$1.instanceof(Uint8Array).transform((arr) => loader(arr));
  }
  function makeProtobufEnumSchema(protobufEnum) {
    const enumValues = Object.values(protobufEnum);
    return z$1.number().transform((value, ctx) => {
      if (enumValues.includes(value)) {
        return value;
      }
      ctx.addIssue({
        code: z$1.ZodIssueCode.custom,
        message: `Invalid protobuf enum value: ${value}`
      });
      return z$1.NEVER;
    });
  }
  function makeTypescriptEnumSchema(typescriptEnum) {
    const enumValues = Object.values(typescriptEnum);
    return z$1.number().or(z$1.string()).transform((value, ctx) => {
      if (enumValues.includes(value)) {
        return value;
      }
      ctx.addIssue({
        code: z$1.ZodIssueCode.custom,
        message: `Invalid typescript enum value: ${value}`
      });
      return z$1.NEVER;
    });
  }
  function makeExcludeValuesTransform(...excludeValues) {
    return (v2, ctx) => {
      if (excludeValues.includes(v2)) {
        ctx.addIssue({
          code: z$1.ZodIssueCode.custom,
          message: `Unexpected value ${v2}`
        });
        return z$1.NEVER;
      }
      return v2;
    };
  }
  var __rest$M = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  const AuthenticatorWebauthn = z$1.object({
    webauthnId: z$1.string(),
    prfSalt: z$1.instanceof(Uint8Array)
  });
  function deviceTypeToAuthenticatorType(deviceType) {
    switch (deviceType) {
      case "push":
        return AuthenticatorType.PUSH;
      case "recovery":
        return AuthenticatorType.BACKUP_CODE;
      case "backup":
        return AuthenticatorType.BACKUP_OS;
      case "dummy":
        return AuthenticatorType.DUMMY;
      case "organization":
        return AuthenticatorType.ORGANIZATION_ADMIN;
      default:
        return AuthenticatorType.UNKNOWN;
    }
  }
  const schemaAuthenticatorType = makeProtobufEnumSchema(AuthenticatorType);
  const AuthenticatorKeyNamesV3 = z$1.object({
    id: z$1.string().uuid(),
    authenticatorType: schemaAuthenticatorType,
    highSecurityLoginSigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityIdentitySigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    storableSigPubKey: brandedUint8Array(loadSigningPublicKey),
    storableSigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
    storableVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    storableVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    secretInfo: z$1.string(),
    secretSalt: z$1.instanceof(Uint8Array),
    webauthn: AuthenticatorWebauthn.optional()
  });
  const AuthenticatorKeyNamesV2 = z$1.object({
    id: z$1.string().uuid(),
    deviceType: z$1.string(),
    highSecurityLoginSigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityIdentitySigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    storableSigPubKey: brandedUint8Array(loadSigningPublicKey),
    storableSigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
    storableVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    storableVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    secretInfo: z$1.string(),
    secretSalt: z$1.instanceof(Uint8Array)
  }).transform((_a3) => {
    var { deviceType } = _a3, rest = __rest$M(_a3, ["deviceType"]);
    return Object.assign({ authenticatorType: deviceTypeToAuthenticatorType(deviceType) }, rest);
  });
  const AuthenticatorKeyNamesV1 = z$1.object({
    id: z$1.string().uuid(),
    deviceType: z$1.string(),
    loginSigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecuritySigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    sigPubKey: brandedUint8Array(loadSigningPublicKey),
    sigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
    encPubKey: brandedUint8Array(loadEncryptionPublicKey),
    encPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    secretInfo: z$1.string(),
    secretSalt: z$1.instanceof(Uint8Array)
  }).transform((_a3) => {
    var { deviceType, loginSigPubKey, highSecuritySigPubKey, highSecurityEncPubKey, highSecurityEncPubKeySignature, sigPubKey, sigPubKeySignature, encPubKey, encPubKeySignature } = _a3, rest = __rest$M(_a3, ["deviceType", "loginSigPubKey", "highSecuritySigPubKey", "highSecurityEncPubKey", "highSecurityEncPubKeySignature", "sigPubKey", "sigPubKeySignature", "encPubKey", "encPubKeySignature"]);
    return Object.assign({ authenticatorType: deviceTypeToAuthenticatorType(deviceType), highSecurityLoginSigPubKey: loginSigPubKey, highSecurityIdentitySigPubKey: highSecuritySigPubKey, highSecurityVaultKeyEncPubKey: highSecurityEncPubKey, highSecurityVaultKeyEncPubKeySignature: highSecurityEncPubKeySignature, storableSigPubKey: sigPubKey, storableSigPubKeySignature: sigPubKeySignature, storableVaultKeyEncPubKey: encPubKey, storableVaultKeyEncPubKeySignature: encPubKeySignature }, rest);
  });
  const Authenticator = z$1.union([
    AuthenticatorKeyNamesV1,
    AuthenticatorKeyNamesV2,
    AuthenticatorKeyNamesV3
  ]);
  var __rest$L = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  const UnlockedAuthenticatorNewKeyNames = z$1.object({
    authenticator: Authenticator,
    storableSigPrivKey: brandedUint8Array(loadSigningPrivateKey),
    storableVaultKeyEncPrivKey: brandedUint8Array(loadEncryptionPrivateKey)
  });
  const UnlockedAuthenticatorOldKeyNames = z$1.object({
    authenticator: Authenticator,
    sigPrivKey: brandedUint8Array(loadSigningPrivateKey),
    encPrivKey: brandedUint8Array(loadEncryptionPrivateKey)
  }).transform((_a3) => {
    var { sigPrivKey, encPrivKey } = _a3, rest = __rest$L(_a3, ["sigPrivKey", "encPrivKey"]);
    return Object.assign({ storableSigPrivKey: sigPrivKey, storableVaultKeyEncPrivKey: encPrivKey }, rest);
  });
  const UnlockedAuthenticator$1 = z$1.union([
    UnlockedAuthenticatorOldKeyNames,
    UnlockedAuthenticatorNewKeyNames
  ]);
  const schemaLoginData = z$1.object({
    userId: z$1.string().uuid(),
    sessionId: z$1.string().uuid(),
    token: z$1.string()
  });
  const SessionKeys$1 = z$1.object({
    encPrivKey: brandedUint8Array(loadEncryptionPrivateKey),
    encPubKey: brandedUint8Array(loadEncryptionPublicKey),
    encPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    signingAuthId: z$1.string().uuid()
  });
  const ClientCoreParameters = z$1.object({
    loginData: schemaLoginData,
    unlockedAuthenticator: UnlockedAuthenticator$1,
    sessionKeys: SessionKeys$1
  });
  var isISO8601$1 = { exports: {} };
  var assertString = { exports: {} };
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = assertString2;
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    function assertString2(input) {
      var isString2 = typeof input === "string" || input instanceof String;
      if (!isString2) {
        var invalidType = _typeof2(input);
        if (input === null)
          invalidType = "null";
        else if (invalidType === "object")
          invalidType = input.constructor.name;
        throw new TypeError("Expected a string but received a ".concat(invalidType));
      }
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  })(assertString, assertString.exports);
  var assertStringExports = assertString.exports;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isISO86012;
    var _assertString = _interopRequireDefault(assertStringExports);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var isValidDate = function isValidDate2(str) {
      var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
      if (ordinalMatch) {
        var oYear = Number(ordinalMatch[1]);
        var oDay = Number(ordinalMatch[2]);
        if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0)
          return oDay <= 366;
        return oDay <= 365;
      }
      var match2 = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
      var year = match2[1];
      var month = match2[2];
      var day = match2[3];
      var monthString = month ? "0".concat(month).slice(-2) : month;
      var dayString = day ? "0".concat(day).slice(-2) : day;
      var d2 = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
      if (month && day) {
        return d2.getUTCFullYear() === year && d2.getUTCMonth() + 1 === month && d2.getUTCDate() === day;
      }
      return true;
    };
    function isISO86012(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
      if (check && options.strict)
        return isValidDate(str);
      return check;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  })(isISO8601$1, isISO8601$1.exports);
  var isISO8601Exports = isISO8601$1.exports;
  const isISO8601 = /* @__PURE__ */ getDefaultExportFromCjs(isISO8601Exports);
  function objectPassthrough(x2) {
    const result2 = z$1.object(x2);
    return result2.passthrough();
  }
  const unknownValuePlaceholderMarker = "fa9fc083-53f0-4616-a4da-2ca792b8f4f8";
  const fallbackValueKey = Symbol("fallbackValueKey");
  const schemaSerializedUnknownValuePlaceholder = z$1.object({
    marker: z$1.literal(unknownValuePlaceholderMarker),
    unknownValueJson: z$1.string()
  });
  function isUnknownValuePlaceholder(value) {
    if (typeof value !== "object") {
      return false;
    }
    return schemaSerializedUnknownValuePlaceholder.safeParse(value).success;
  }
  function getValueWithPlaceholder(value) {
    if (isUnknownValuePlaceholder(value)) {
      return value[fallbackValueKey];
    }
    return value;
  }
  function makeUnknownValuePlaceholderSchema(schema, fallbackValue) {
    return z$1.union([
      schema,
      schemaSerializedUnknownValuePlaceholder.transform((placeholder) => {
        try {
          const result2 = schema.safeParse(JSON.parse(placeholder.unknownValueJson));
          if (result2.success) {
            return result2.data;
          }
        } catch (e2) {
        }
        return Object.assign(Object.assign({}, placeholder), { [fallbackValueKey]: fallbackValue });
      })
    ]).catch((ctx) => ({
      marker: unknownValuePlaceholderMarker,
      // We store the original value as JSON serialized so we can deal with a consistent string type when parsing
      unknownValueJson: JSON.stringify(ctx.input),
      [fallbackValueKey]: fallbackValue
    }));
  }
  var isBase64$1 = { exports: {} };
  var merge = { exports: {} };
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = merge2;
    function merge2() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults = arguments.length > 1 ? arguments[1] : void 0;
      for (var key in defaults) {
        if (typeof obj[key] === "undefined") {
          obj[key] = defaults[key];
        }
      }
      return obj;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  })(merge, merge.exports);
  var mergeExports = merge.exports;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBase642;
    var _assertString = _interopRequireDefault(assertStringExports);
    var _merge = _interopRequireDefault(mergeExports);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var notBase64 = /[^A-Z0-9+\/=]/i;
    var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
    var defaultBase64Options = {
      urlSafe: false
    };
    function isBase642(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultBase64Options);
      var len = str.length;
      if (options.urlSafe) {
        return urlSafeBase64.test(str);
      }
      if (len % 4 !== 0 || notBase64.test(str)) {
        return false;
      }
      var firstPaddingChar = str.indexOf("=");
      return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  })(isBase64$1, isBase64$1.exports);
  var isBase64Exports = isBase64$1.exports;
  const isBase64 = /* @__PURE__ */ getDefaultExportFromCjs(isBase64Exports);
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (var i$2 = 0; i$2 < 256; ++i$2) {
    byteToHex.push((i$2 + 256).toString(16).substr(1));
  }
  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return stringify(rnds);
  }
  const nullUuid = "00000000-0000-0000-0000-000000000000";
  function newUuid$1() {
    return v4();
  }
  function uuidEqual(id1, id2) {
    return id1.toLowerCase() === id2.toLowerCase();
  }
  const ProtectedValue = objectPassthrough({
    // Content identity only changes on user edits. The field should be set most of the time, since
    // it was set for all ProtectedValues during the automerge migration. However contentId-less
    // fields may have been re-introduced after the heymerge migration. In this case we generate an
    // id during parsing.
    contentId: z$1.string().uuid().default(newUuid$1),
    encrypted: z$1.string().refine(isBase64),
    isEmpty: z$1.boolean().optional()
  });
  const UnprotectedValue = objectPassthrough({
    // See ProtectedValue.contentId. Note that this field was previously `UUID | null` and therefore
    // uses a different transformation here.
    contentId: z$1.union([z$1.string().uuid(), z$1.null()]).transform((arg) => arg === null ? newUuid$1() : arg),
    unencrypted: z$1.string()
  });
  const ProtectedCustomField = objectPassthrough({
    // Id should be set most of the time, since it was set for all CustomFields during the automerge
    // migration. However at that time not all importers set the id correctly, so performed in
    // heymerge accounts may have re-introduced id-less CustomFields. In this case we generate an id
    // during parsing.
    id: z$1.string().uuid().default(newUuid$1),
    name: z$1.string(),
    protected: z$1.literal(true),
    value: ProtectedValue
  });
  const UnprotectedProtectedCustomField = objectPassthrough({
    // see ProtectedCustomField.id
    id: z$1.string().uuid().default(newUuid$1),
    name: z$1.string(),
    protected: z$1.literal(true),
    value: UnprotectedValue
  });
  const PlainCustomField = objectPassthrough({
    // see ProtectedCustomField.id
    id: z$1.string().uuid().default(newUuid$1),
    name: z$1.string(),
    protected: z$1.literal(false),
    value: z$1.string()
  });
  const CustomField = z$1.union([ProtectedCustomField, PlainCustomField]);
  const UnprotectedCustomField = z$1.union([UnprotectedProtectedCustomField, PlainCustomField]);
  const LoginAndroidApp = objectPassthrough({
    // TODO make id non optional after migration to heymerge
    id: z$1.string().uuid().optional(),
    appId: z$1.string(),
    signature: z$1.string().refine(isBase64),
    displayName: z$1.string(),
    iconDataUri: z$1.string().optional()
  });
  const LoginCreditCard = objectPassthrough({
    number: z$1.string(),
    cardHolder: z$1.string(),
    expiration: z$1.string(),
    securityCode: ProtectedValue,
    pin: ProtectedValue,
    displayType: z$1.string(),
    displayMaskedNumber: z$1.string()
  });
  const LOGIN_CREDIT_CARD_KEYS = [
    "number",
    "cardHolder",
    "expiration",
    "securityCode",
    "pin",
    "displayType",
    "displayMaskedNumber"
  ];
  var __rest$K = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  var LoginWebsiteProtocol;
  (function(LoginWebsiteProtocol2) {
    LoginWebsiteProtocol2["http"] = "http";
    LoginWebsiteProtocol2["https"] = "https";
  })(LoginWebsiteProtocol || (LoginWebsiteProtocol = {}));
  const schemaLoginWebsiteProtocol = makeTypescriptEnumSchema(LoginWebsiteProtocol);
  const LoginWebsiteAttributesEntry = objectPassthrough({
    protocol: makeUnknownValuePlaceholderSchema(schemaLoginWebsiteProtocol, void 0).optional()
  });
  const LoginWebsiteAttributes = z$1.record(LoginWebsiteAttributesEntry);
  var LoginUiType;
  (function(LoginUiType2) {
    LoginUiType2["login"] = "login";
    LoginUiType2["creditCard"] = "creditCard";
    LoginUiType2["note"] = "note";
    LoginUiType2["wifi"] = "wifi";
  })(LoginUiType || (LoginUiType = {}));
  const schemaLoginUiType = makeTypescriptEnumSchema(LoginUiType);
  const LoginSender = objectPassthrough({
    name: z$1.string(),
    company: z$1.string().optional()
  });
  var LoginSource;
  (function(LoginSource2) {
    LoginSource2["manual"] = "manual";
    LoginSource2["autosave"] = "autosave";
    LoginSource2["registrationPasswordGeneration"] = "registrationPasswordGeneration";
    LoginSource2["addTotpFromOverlay"] = "addTotpFromOverlay";
    LoginSource2["updateLoginFromOverlay"] = "updateLoginFromOverlay";
    LoginSource2["menuDragDrop"] = "menuDragDrop";
    LoginSource2["import"] = "import";
    LoginSource2["shareLink"] = "shareLink";
    LoginSource2["undo"] = "undo";
  })(LoginSource || (LoginSource = {}));
  const schemaLoginSource = makeTypescriptEnumSchema(LoginSource);
  const ShareLink = objectPassthrough({
    id: z$1.string(),
    createdAt: z$1.string().refine((str) => isISO8601(str)),
    openedAt: z$1.string().refine((str) => isISO8601(str)).optional(),
    secret: ProtectedValue
  });
  const schemaTotpAlgorithm = makeTypescriptEnumSchema(TotpAlgorithm);
  const LeakedPasswordCheckInfo = objectPassthrough({
    leakCount: z$1.number(),
    checkedAt: z$1.string().refine((str) => isISO8601(str)),
    checkedPasswordContentId: z$1.string().uuid()
  });
  const LoginWithoutHistory = objectPassthrough({
    uiType: z$1.undefined().transform((_2) => LoginUiType.login).or(makeUnknownValuePlaceholderSchema(schemaLoginUiType, LoginUiType.login)),
    title: z$1.string(),
    websites: z$1.array(z$1.string()),
    websiteAttributes: LoginWebsiteAttributes.optional(),
    androidApps: z$1.array(LoginAndroidApp).optional(),
    username: z$1.string(),
    password: ProtectedValue,
    note: z$1.string(),
    creationTime: z$1.string().refine((str) => isISO8601(str)),
    changeTime: z$1.string().refine((str) => isISO8601(str)).optional(),
    editTime: z$1.string().refine((str) => isISO8601(str)),
    creationSource: makeUnknownValuePlaceholderSchema(schemaLoginSource, void 0).optional(),
    editSource: makeUnknownValuePlaceholderSchema(schemaLoginSource, void 0).optional(),
    creationProfileId: z$1.string().uuid().optional(),
    editProfileId: z$1.string().uuid().optional(),
    customFields: z$1.array(CustomField),
    totp: ProtectedValue.optional(),
    totpAlgorithm: makeUnknownValuePlaceholderSchema(schemaTotpAlgorithm, TotpAlgorithm.unknown).optional(),
    totpDigits: z$1.number().int().gte(1).optional(),
    totpPeriod: z$1.number().int().gte(1).optional(),
    tags: z$1.array(z$1.string()).optional(),
    creditCard: LoginCreditCard.optional(),
    wifiSsid: z$1.string().optional(),
    sender: LoginSender.optional(),
    pendingInboxConfirmation: z$1.boolean().optional(),
    linkedViewSecrets: z$1.boolean().optional(),
    linkedFrom: z$1.object({
      linkedByProfileId: z$1.string().uuid(),
      originPersonalProfileId: z$1.string().uuid().nullable(),
      originVaultId: z$1.string().uuid()
    }).optional(),
    linkedTo: z$1.array(z$1.object({
      linkedByProfileId: z$1.string().uuid(),
      targetPersonalProfileId: z$1.string().uuid().nullable(),
      targetVaultId: z$1.string().uuid(),
      addTime: z$1.string().refine((str) => isISO8601(str)),
      removeTime: z$1.string().refine((str) => isISO8601(str)).nullable()
    })).optional(),
    shareLinks: z$1.array(ShareLink).optional(),
    // This field is dropped as a transform. See LoginRevision below, and LoginListElement in
    // LoginVaultContentV2.ts
    internal: z$1.unknown(),
    archiveInfo: z$1.object({
      archivedByProfileId: z$1.string().uuid().optional(),
      archiveTime: z$1.string().refine((str) => isISO8601(str))
    }).optional(),
    leakedPasswordCheck: LeakedPasswordCheckInfo.optional()
    // deprecated fields
    // icon: z.string().optional(),
  });
  const LoginRevision = LoginWithoutHistory.merge(objectPassthrough({
    baseRevisionId: z$1.string().uuid().optional()
  })).transform((_a3) => {
    var l2 = __rest$K(_a3, ["internal"]);
    return l2;
  });
  const LoginRevisionHistory = z$1.object({
    currentRevisionId: z$1.string().uuid(),
    revisions: z$1.record(LoginRevision)
  });
  const Login = LoginWithoutHistory.merge(objectPassthrough({
    history: LoginRevisionHistory.optional()
  }));
  const LOGIN_WITHOUT_HISTORY_KEYS = [
    "uiType",
    "title",
    "websites",
    "websiteAttributes",
    "androidApps",
    "username",
    "password",
    "note",
    "creationTime",
    "changeTime",
    "editTime",
    "creationProfileId",
    "editProfileId",
    "creationSource",
    "editSource",
    "customFields",
    "totp",
    "totpAlgorithm",
    "totpDigits",
    "totpPeriod",
    "tags",
    "creditCard",
    "wifiSsid",
    "sender",
    "pendingInboxConfirmation",
    "linkedViewSecrets",
    "linkedFrom",
    "linkedTo",
    "shareLinks",
    "archiveInfo",
    "leakedPasswordCheck"
  ];
  const LOGIN_KEYS = [...LOGIN_WITHOUT_HISTORY_KEYS, "history"];
  const LOGIN_REVISION_KEYS = [...LOGIN_WITHOUT_HISTORY_KEYS, "baseRevisionId"];
  const emptyUnprotectedLogin = {
    uiType: LoginUiType.login,
    creationTime: "",
    editTime: "",
    title: "",
    username: "",
    password: "",
    note: "",
    customFields: [],
    websites: [],
    totp: ""
  };
  const ActiveElement = objectPassthrough({
    updateTime: z$1.string().refine((str) => isISO8601(str)),
    isDeleted: z$1.literal(false)
  });
  const Tombstone = objectPassthrough({
    updateTime: z$1.string().refine((str) => isISO8601(str)),
    isDeleted: z$1.literal(true),
    isArchived: z$1.literal(false).optional()
  });
  const ArchivedElement = objectPassthrough({
    updateTime: z$1.string().refine((str) => isISO8601(str)),
    isDeleted: z$1.literal(true),
    isArchived: z$1.literal(true)
  });
  z$1.union([ActiveElement, ArchivedElement]);
  const UnprotectedShareLink = ShareLink.merge(objectPassthrough({ secret: UnprotectedValue }));
  const UnprotectedLoginWithoutHistory = Login.merge(objectPassthrough({
    password: UnprotectedValue,
    totp: UnprotectedValue.optional(),
    customFields: z$1.array(UnprotectedCustomField),
    creditCard: LoginCreditCard.merge(z$1.object({
      pin: UnprotectedValue,
      securityCode: UnprotectedValue
    })).optional(),
    shareLinks: z$1.array(UnprotectedShareLink).optional()
  }));
  const UnprotectedLoginRevision = UnprotectedLoginWithoutHistory.merge(objectPassthrough({
    baseRevisionId: z$1.string().uuid().optional()
  }));
  const UnprotectedLogin = UnprotectedLoginWithoutHistory.merge(objectPassthrough({
    history: z$1.object({
      currentRevisionId: z$1.string().uuid(),
      revisions: z$1.record(UnprotectedLoginRevision)
    }).optional()
  }));
  const UnprotectedLoginListElement = z$1.union([
    UnprotectedLogin.merge(ActiveElement),
    UnprotectedLogin.merge(ArchivedElement),
    Tombstone
  ]);
  var __rest$J = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  const LoginListElement = z$1.union([
    // This is a hack. We would rather apply the transformation to Login directly, but can't because
    // the resulting ZodEffects type would no longer allow us to `.merge` here. So we apply this
    // transformation here, instead of in Login.ts
    // see https://github.com/colinhacks/zod/issues/2474
    Login.merge(ActiveElement).transform((_a3) => {
      var l2 = __rest$J(_a3, ["internal"]);
      return l2;
    }),
    // As archived elements are only written by newer client versions, they will never have the internal field
    Login.merge(ArchivedElement),
    Tombstone
  ]);
  const LoginVaultContentV2 = objectPassthrough({ logins: z$1.record(LoginListElement) });
  objectPassthrough({ logins: z$1.record(Login) });
  const SessionMetadata = objectPassthrough({
    description: z$1.string().optional(),
    iconType: z$1.string().optional(),
    isSelfUnlocking: z$1.boolean().optional(),
    encPubKey: z$1.string().refine((str) => isBase64(str)),
    encPubKeySignature: z$1.string().refine((str) => isBase64(str)),
    signingAuthId: z$1.string().uuid(),
    creationTime: z$1.string().refine((str) => isISO8601(str)),
    editTime: z$1.string().refine((str) => isISO8601(str)),
    autosnatchTarget: z$1.string().uuid().optional(),
    autosnatchDisabled: z$1.boolean().optional()
  });
  const SiteSettings = objectPassthrough({
    extensionDisabled: z$1.boolean().optional()
    // extensionLoginAutosnatchDisabled: z.boolean().optional(), // deprecated
  });
  const PasswordGeneratorSettings = z$1.object({
    length: z$1.number().default(16),
    letters: z$1.boolean().default(true),
    numbers: z$1.boolean().default(true),
    special: z$1.boolean().default(true)
  });
  const HideHints = z$1.object({
    personalLoginsInfoBox: z$1.boolean().optional(),
    newFeatureOrganizationMonitoring: z$1.boolean().optional()
  });
  z$1.object({
    passwordGenerator: PasswordGeneratorSettings.optional(),
    backupCode: ProtectedValue.optional(),
    hideHints: HideHints.optional()
  });
  const SessionMetadataListElement = z$1.union([
    SessionMetadata.merge(ActiveElement),
    SessionMetadata.merge(ArchivedElement),
    Tombstone
  ]);
  const SiteSettingsListElement = z$1.union([
    SiteSettings.merge(ActiveElement),
    SiteSettings.merge(ArchivedElement),
    Tombstone
  ]);
  const MetaVaultContentV2 = objectPassthrough({
    sessions: z$1.record(SessionMetadataListElement),
    siteSettings: z$1.record(SiteSettingsListElement).optional()
  });
  objectPassthrough({
    sessions: z$1.record(SessionMetadata),
    siteSettings: z$1.record(SiteSettings).optional()
  });
  var __rest$I = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  var PermissionLevel$1;
  (function(PermissionLevel2) {
    PermissionLevel2["admin"] = "admin";
    PermissionLevel2["member"] = "member";
    PermissionLevel2["restricted"] = "restricted";
  })(PermissionLevel$1 || (PermissionLevel$1 = {}));
  const schemaPermissionLevel = makeTypescriptEnumSchema(PermissionLevel$1);
  const TeamVaultPendingUserRegistration = objectPassthrough({
    email: z$1.string(),
    // fall back to most restrictive permission level
    permissionLevel: makeUnknownValuePlaceholderSchema(schemaPermissionLevel, PermissionLevel$1.restricted).optional()
  });
  const TeamVaultInfo = objectPassthrough({
    name: z$1.string(),
    icon: z$1.string().optional(),
    description: z$1.string().optional(),
    hideSecretsForRestrictedUsers: z$1.boolean().optional(),
    hideOnMobile: z$1.boolean().optional(),
    isSyncOrganizationMembers: z$1.boolean().optional(),
    /**
     * @deprecated Replaced by backend maintained email invites. Only present for migration purposes.
     */
    pendingUserRegistrations: z$1.array(TeamVaultPendingUserRegistration).optional()
  });
  const TeamVaultUser = objectPassthrough({
    joinedAt: z$1.string().refine((str) => isISO8601(str)),
    email: z$1.string().nullish().transform((_2) => null),
    newlyJoined: objectPassthrough({
      addedByUserId: z$1.string().uuid().optional(),
      addedByEmail: z$1.string()
    }).optional(),
    pendingInvite: objectPassthrough({
      invitedByUserId: z$1.string().uuid(),
      invitedByEmail: z$1.string()
    }).optional().transform((pendingInvite) => pendingInvite ? {
      addedByUserId: pendingInvite.invitedByUserId,
      addedByEmail: pendingInvite.invitedByEmail
    } : void 0).optional(),
    // fall back to most restrictive permission level
    permissionLevel: makeUnknownValuePlaceholderSchema(schemaPermissionLevel, PermissionLevel$1.restricted).optional()
  }).transform((_a3) => {
    var { pendingInvite } = _a3, rest = __rest$I(_a3, ["pendingInvite"]);
    return pendingInvite ? Object.assign(Object.assign({}, rest), { newlyJoined: pendingInvite }) : Object.assign({}, rest);
  });
  const MetadataListElement = z$1.union([
    TeamVaultInfo.merge(ActiveElement),
    TeamVaultInfo.merge(ArchivedElement),
    Tombstone
  ]);
  const UserListElement = z$1.union([
    z$1.intersection(TeamVaultUser, ArchivedElement.strip()),
    z$1.intersection(TeamVaultUser, ActiveElement.strip()),
    Tombstone
  ]);
  const TeamMetaVaultContentV2 = objectPassthrough({
    info: z$1.record(MetadataListElement),
    users: z$1.record(UserListElement)
  });
  const TeamMetaVaultContentExternalV2 = objectPassthrough({
    info: z$1.record(TeamVaultInfo),
    users: z$1.record(TeamVaultUser)
  });
  const GV2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get PermissionLevel() {
      return PermissionLevel$1;
    },
    TeamMetaVaultContentExternalV2,
    TeamMetaVaultContentV2,
    TeamVaultInfo,
    TeamVaultPendingUserRegistration,
    TeamVaultUser
  }, Symbol.toStringTag, { value: "Module" }));
  const OrganizationPendingUserRegistration = objectPassthrough({
    email: z$1.string()
  });
  const LegacyOrganizationAdminVaultInfo = objectPassthrough({
    authenticatorSecret: objectPassthrough({
      // authenticatorId: z.string().uuid(),
      seed: ProtectedValue
    }).optional(),
    profileSecret: objectPassthrough({
      seed: ProtectedValue
    }).optional(),
    /**
     * @deprecated Replaced by backend maintained email invites. Only present for migration purposes.
     */
    pendingUserRegistrations: OrganizationPendingUserRegistration.array().optional(),
    unsafeStoredVaultContents: z$1.record(objectPassthrough({
      logins: z$1.record(UnprotectedLogin),
      archivedLogins: z$1.record(UnprotectedLogin)
    })).optional()
  });
  const InfoListElement$1 = z$1.union([
    LegacyOrganizationAdminVaultInfo.merge(ActiveElement),
    LegacyOrganizationAdminVaultInfo.merge(ArchivedElement),
    Tombstone
  ]);
  const LegacyOrganizationAdminVaultContent$1 = objectPassthrough({
    info: z$1.record(InfoListElement$1)
  });
  const LegacyOrganizationAdminVaultContentExternal = objectPassthrough({
    info: z$1.record(LegacyOrganizationAdminVaultInfo)
  });
  const LOAV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    LegacyOrganizationAdminVaultContent: LegacyOrganizationAdminVaultContent$1,
    LegacyOrganizationAdminVaultContentExternal,
    LegacyOrganizationAdminVaultInfo,
    OrganizationPendingUserRegistration
  }, Symbol.toStringTag, { value: "Module" }));
  const OrganizationAdminVaultInfo = objectPassthrough({
    unsafeStoredVaultContents: z$1.record(objectPassthrough({
      logins: z$1.record(UnprotectedLogin),
      archivedLogins: z$1.record(UnprotectedLogin)
    })).optional()
  });
  const InfoListElement = z$1.union([
    OrganizationAdminVaultInfo.merge(ActiveElement),
    OrganizationAdminVaultInfo.merge(ArchivedElement),
    Tombstone
  ]);
  const OrganizationAdminVaultContent$1 = objectPassthrough({
    info: z$1.record(InfoListElement)
  });
  const OrganizationAdminVaultContentExternal = objectPassthrough({
    info: z$1.record(OrganizationAdminVaultInfo)
  });
  const OAV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    OrganizationAdminVaultContent: OrganizationAdminVaultContent$1,
    OrganizationAdminVaultContentExternal,
    OrganizationAdminVaultInfo
  }, Symbol.toStringTag, { value: "Module" }));
  const RelatedProfile = z$1.object({
    id: z$1.string().uuid(),
    email: z$1.string().nullable()
  });
  const schemaGroups = objectPassthrough({
    enable: z$1.boolean()
  });
  const schemaEventNotifications = objectPassthrough({
    enable: z$1.boolean()
  });
  const schemaSubscriptionErrorKnownValue$1 = makeProtobufEnumSchema(SubscriptionError).transform(makeExcludeValuesTransform(SubscriptionError.OK));
  const ServerSideSettings = objectPassthrough({
    groups: schemaGroups.optional(),
    eventNotifications: schemaEventNotifications.optional(),
    persistLastKnownSyncVersion: z$1.boolean().optional(),
    migrateToProfiles: z$1.boolean().optional(),
    migrateRedundantPrivateProfile: z$1.boolean().optional(),
    injectSubscriptionError: z$1.record(schemaSubscriptionErrorKnownValue$1).optional(),
    preferLongPollForProtoClientTypes: z$1.array(z$1.number()).optional(),
    allowLoginInbox: z$1.boolean().optional(),
    lfdAdmin: z$1.boolean().optional(),
    showInternalBetas: z$1.boolean().optional()
  });
  const SessionClientProfileSettings = z$1.object({
    enabled: z$1.boolean()
  });
  const SessionClientSettings = z$1.object({
    enableAllProfiles: z$1.boolean().default(true),
    profileSettings: z$1.record(SessionClientProfileSettings).default({})
  });
  const unlockTimeLimitSchema = z$1.object({
    enabled: z$1.boolean(),
    minutes: z$1.number()
  });
  const schemaSessionType = makeProtobufEnumSchema(SessionType);
  const Session = z$1.object({
    id: z$1.string().uuid(),
    createdAt: z$1.instanceof(Date),
    lastUsedAt: z$1.instanceof(Date),
    unlockedAt: z$1.instanceof(Date).optional(),
    unlockedUntil: z$1.instanceof(Date).optional(),
    unlockRequestedAt: z$1.instanceof(Date).optional(),
    unlockExtendAt: z$1.instanceof(Date).optional(),
    clientSettings: SessionClientSettings.default({ enableAllProfiles: true, profileSettings: {} }),
    sessionType: schemaSessionType.default(SessionType.UNKNOWN),
    enabledProfileIds: z$1.string().uuid().array().default([]),
    unlockTimeLimit: unlockTimeLimitSchema.default({ enabled: false, minutes: 60 })
  });
  const UserClientSettings = objectPassthrough({
    enableBetaOrganizationUserManagement: z$1.boolean().optional(),
    enableBetaHeyloginMe: z$1.boolean().optional(),
    enableBetaLeakedPasswordCheck: z$1.boolean().optional(),
    enableBetaPasswordPolicy: z$1.boolean().optional(),
    enableBetaShowPersonalLoginsOnMobile: z$1.boolean().optional()
  });
  var decode$1;
  var encode$1;
  (function() {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = new Uint8Array(256);
    for (var i2 = 0; i2 < chars.length; i2++) {
      lookup[chars.charCodeAt(i2)] = i2;
    }
    encode$1 = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer), i3, len = bytes.length, base64 = "";
      for (i3 = 0; i3 < len; i3 += 3) {
        base64 += chars[bytes[i3] >> 2];
        base64 += chars[(bytes[i3] & 3) << 4 | bytes[i3 + 1] >> 4];
        base64 += chars[(bytes[i3 + 1] & 15) << 2 | bytes[i3 + 2] >> 6];
        base64 += chars[bytes[i3 + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    decode$1 = function(base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i3, p2 = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i3 = 0; i3 < len; i3 += 4) {
        encoded1 = lookup[base64.charCodeAt(i3)];
        encoded2 = lookup[base64.charCodeAt(i3 + 1)];
        encoded3 = lookup[base64.charCodeAt(i3 + 2)];
        encoded4 = lookup[base64.charCodeAt(i3 + 3)];
        bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  })();
  const FLAG_UINT8_ARRAY = "FLAG_UINT8_ARRAY";
  const FLAG_DATE = "FLAG_DATE";
  const FLAG_UNDEFINED = "FLAG_UNDEFINED";
  function jsonThaw(_key, value) {
    if (value instanceof Object && "flag" in value) {
      switch (value.flag) {
        case FLAG_UINT8_ARRAY:
          return new Uint8Array(decode$1(value.data));
        case FLAG_DATE:
          return new Date(value.data);
        case FLAG_UNDEFINED:
          return void 0;
        default:
          return value;
      }
    }
    return value;
  }
  function jsonFreeze(key) {
    const value = this[key];
    if (value instanceof Uint8Array) {
      return {
        flag: FLAG_UINT8_ARRAY,
        data: encode$1(value)
      };
    }
    if (value instanceof Date) {
      return {
        flag: FLAG_DATE,
        data: value.toISOString()
      };
    }
    if (value === void 0) {
      return {
        flag: FLAG_UNDEFINED
      };
    }
    return value;
  }
  function jsonStringifyFreeze(value, space) {
    return JSON.stringify(value, jsonFreeze, space);
  }
  function jsonParseThaw(text) {
    return JSON.parse(text, jsonThaw);
  }
  const OrganizationClientSettings = objectPassthrough({
    hidePersonalLoginsOnMobile: z$1.boolean().optional()
  });
  const ContactInfo = z$1.object({
    name: z$1.string().optional(),
    icon: z$1.string().optional(),
    addressLine1: z$1.string().optional(),
    addressLine2: z$1.string().optional()
  });
  const ParentOrganizationMetadata = z$1.object({
    contact: ContactInfo.optional()
  });
  const PasswordRules = z$1.object({
    length: z$1.number(),
    upper: z$1.boolean(),
    numbers: z$1.boolean(),
    special: z$1.boolean()
  });
  const PasswordPolicy = makeUnknownValuePlaceholderSchema(z$1.discriminatedUnion("type", [
    z$1.object({ type: z$1.literal("default") }),
    z$1.object({ type: z$1.literal("custom"), rules: PasswordRules })
  ]), { type: "default" });
  const schemaProfileAuthenticatorLock = z$1.object({
    authenticatorId: z$1.string().uuid(),
    encryptedHighSecurityProfileSeed: z$1.instanceof(Uint8Array),
    encryptedStorableProfileSeed: z$1.instanceof(Uint8Array)
  });
  const schemaProfileProfileLock = z$1.object({
    lockingProfileId: z$1.string().uuid(),
    lockingProfileKeyGenerationId: z$1.string().uuid(),
    encryptedHighSecurityProfileSeed: z$1.instanceof(Uint8Array),
    encryptedStorableProfileSeed: z$1.instanceof(Uint8Array)
  });
  const schemaProfileType = makeProtobufEnumSchema(ProfileType);
  const PersistableProfile = z$1.object({
    id: z$1.string().uuid(),
    profileType: schemaProfileType,
    keyGenerationId: z$1.string().uuid(),
    email: z$1.string().nullable(),
    unverifiedEmail: z$1.string().nullable().default(null),
    organizationId: z$1.string().uuid().nullable(),
    highSecurityIdentitySigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    highSecurityProfileSeedEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityProfileSeedEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    storableSigPubKey: brandedUint8Array(loadSigningPublicKey),
    storableSigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
    storableVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    storableVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    storableProfileSeedEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    storableProfileSeedEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    authenticatorLocks: z$1.array(schemaProfileAuthenticatorLock),
    profileLock: schemaProfileProfileLock.nullable().default(null),
    localEncryptedStorableSeed: brandedUint8Array(loadAsymEncryptedBlob).optional()
  });
  var __rest$H = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  const PersistableOrganizationAdminInfo = z$1.object({
    vaultId: z$1.string().uuid().nullable().default(null),
    legacyAdminVaultId: z$1.string().uuid().nullable().default(null),
    authenticator: Authenticator.optional(),
    adminProfile: PersistableProfile.optional(),
    entraTenantId: z$1.string().optional(),
    csvIntegrationActive: z$1.boolean().default(false),
    googleWorkspaceIntegrationActive: z$1.boolean().default(false),
    trialEndDate: z$1.date().optional(),
    licenseType: makeProtobufEnumSchema(LicenseType).default(LicenseType.NONE)
  }).transform((_a3) => {
    var { vaultId, legacyAdminVaultId } = _a3, remainingAdminInfo = __rest$H(_a3, ["vaultId", "legacyAdminVaultId"]);
    return Object.assign(Object.assign({}, remainingAdminInfo), { legacyAdminVaultId: legacyAdminVaultId !== null && legacyAdminVaultId !== void 0 ? legacyAdminVaultId : vaultId });
  });
  const PersistableOrganizationProfile = z$1.object({
    profileId: z$1.string().uuid(),
    isAdmin: z$1.boolean().default(false),
    isManager: z$1.boolean().default(false),
    isService: z$1.boolean().default(false),
    isNotConnected: z$1.boolean().default(false),
    personalVaultId: z$1.string().uuid().optional(),
    invitedAt: z$1.date().optional(),
    preliminaryUserId: z$1.string().uuid().optional(),
    startCode: z$1.string().optional(),
    startCodeGeneratedAt: z$1.date().optional(),
    startCodeEmailSentAt: z$1.date().optional(),
    lastActiveAt: z$1.date().optional(),
    primaryLoginDevice: makeProtobufEnumSchema(PrimaryLoginDevice).optional()
  });
  const ParentOrganizationInfo = z$1.object({
    id: z$1.string().uuid(),
    name: z$1.string(),
    icon: z$1.string().optional(),
    metadata: ParentOrganizationMetadata.optional()
  });
  const schemaSubscriptionErrorKnownValue = makeProtobufEnumSchema(SubscriptionError).transform(makeExcludeValuesTransform(SubscriptionError.OK));
  const passwordPolicyFallback = z$1.string().nullable().transform((oldValue) => {
    if (oldValue === null) {
      return void 0;
    }
    try {
      return PasswordPolicy.parse(jsonParseThaw(oldValue));
    } catch (e2) {
      return void 0;
    }
  });
  const passwordPolicyWithFallback = z$1.union([
    passwordPolicyFallback,
    PasswordPolicy.optional()
  ]);
  const PersistableOrganization = z$1.object({
    id: z$1.string().uuid(),
    name: z$1.string(),
    icon: z$1.string().nullable(),
    organizationType: makeProtobufEnumSchema(OrganizationType).default(OrganizationType.UNKNOWN),
    restrictCreateTeam: z$1.boolean().default(false),
    restrictPersonalLogins: z$1.boolean().default(false),
    auditlogEnable: z$1.boolean().default(false),
    childOrganizationManagementEnable: z$1.boolean().default(false),
    superUserId: z$1.string().uuid(),
    adminProfileId: z$1.string().uuid().nullable().default(null),
    isAdmin: z$1.boolean().default(false),
    isManager: z$1.boolean().default(false),
    isPreliminary: z$1.boolean().default(false),
    profiles: z$1.array(PersistableOrganizationProfile).default([]),
    adminInfo: PersistableOrganizationAdminInfo.optional(),
    subscriptionError: schemaSubscriptionErrorKnownValue.nullable(),
    verifiedDomain: z$1.string().nullable().default(null),
    passwordPolicy: passwordPolicyWithFallback,
    unlockTimeLimit: unlockTimeLimitSchema.default({ enabled: false, minutes: 60 }),
    clientSettings: OrganizationClientSettings.nullable(),
    parentOrganizationInfo: ParentOrganizationInfo.optional()
  });
  const WebauthnCredential = z$1.object({
    // this field was added late, so we default to a random id if it was missing. this will fix itself
    // on the next sync update, and operations that work on this value will fail reasonably gracefully
    // until then.
    // TODO remove this fallback when minimum version hits 2023-09-28
    webauthnId: z$1.string().default(() => (
      // b64 urlsafe encoding
      naclUtilExports.encodeBase64(randomSeed()).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "")
    )),
    credentialType: makeProtobufEnumSchema(CredentialType).default(CredentialType.UNKNOWN),
    aaguid: z$1.string().nullable(),
    sessionId: z$1.string().nullable().default(null),
    createdAt: z$1.date(),
    lastUsedAt: z$1.date(),
    prfSupportStatus: makeProtobufEnumSchema(WebauthnPrfSupportStatus).default(WebauthnPrfSupportStatus.UNKNOWN)
  });
  const PersistableAccountState = z$1.object({
    userId: z$1.string().uuid(),
    emails: z$1.array(z$1.object({
      email: z$1.string(),
      primary: z$1.boolean(),
      verificationPending: z$1.boolean()
    })).optional(),
    preferredLocale: z$1.string().nullable().optional(),
    serverSideSettings: ServerSideSettings.optional(),
    userClientSettings: UserClientSettings.optional(),
    authenticators: z$1.array(Authenticator),
    sessions: z$1.array(Session),
    achievements: z$1.number().array().optional(),
    localAchievements: z$1.number().array().optional(),
    authenticatorBlockHash: brandedUint8Array(loadHash).optional(),
    organizations: z$1.array(PersistableOrganization).optional(),
    relatedProfiles: z$1.record(RelatedProfile).optional(),
    webauthnCredentials: z$1.array(WebauthnCredential).default([]),
    // deprecated
    email: z$1.string().nullable().optional(),
    unverifiedEmail: z$1.string().nullable().optional(),
    fullName: z$1.string().nullable().optional()
  });
  const LOGIN_DIFFERENCE_CREDIT_CARD_IGNORED_KEYS = ["displayMaskedNumber", "displayType"];
  const LOGIN_DIFFERENCE_IGNORED_KEYS = [
    "creationProfileId",
    "editProfileId",
    "editTime",
    "creationTime",
    "creationSource",
    "editSource",
    "linkedFrom",
    "linkedTo",
    "linkedViewSecrets",
    "sender",
    "pendingInboxConfirmation",
    "shareLinks",
    "history",
    "archiveInfo",
    "changeTime",
    "websiteAttributes",
    "baseRevisionId",
    "uiType",
    "leakedPasswordCheck"
  ];
  function makeLoginDifferenceIncludedKeysSchema(keys2) {
    const includedKeys = keys2.filter((k2) => !LOGIN_DIFFERENCE_IGNORED_KEYS.includes(k2));
    return z$1.string().refine((s2) => includedKeys.includes(s2));
  }
  function makeLoginDifferenceCreditCardIncludedKeysSchema() {
    const includedKeys = LOGIN_CREDIT_CARD_KEYS.filter((k2) => !LOGIN_DIFFERENCE_CREDIT_CARD_IGNORED_KEYS.includes(k2));
    return z$1.string().refine((s2) => includedKeys.includes(s2));
  }
  function makeGenericLoginDifferenceSchema(keys2) {
    return makeUnknownValuePlaceholderSchema(z$1.discriminatedUnion("type", [
      z$1.object({
        type: z$1.literal("login"),
        key: makeLoginDifferenceIncludedKeysSchema(keys2)
      }),
      z$1.object({
        type: z$1.literal("creditCard"),
        key: makeLoginDifferenceCreditCardIncludedKeysSchema()
      }),
      z$1.object({
        type: z$1.literal("customField"),
        id: z$1.string().uuid(),
        name: z$1.string()
      })
    ]), { type: "unknown" });
  }
  const LoginDifference = makeGenericLoginDifferenceSchema(LOGIN_KEYS);
  makeGenericLoginDifferenceSchema(LOGIN_REVISION_KEYS);
  const schemaEventType = makeProtobufEnumSchema(AuditlogEventType);
  const AuditlogEventTargetProfile = z$1.object({
    id: z$1.string().uuid(),
    email: z$1.string()
  });
  const AuditlogEvent = z$1.object({
    type: schemaEventType,
    vaultId: z$1.string().uuid().optional(),
    loginId: z$1.string().uuid().optional(),
    customFieldId: z$1.string().uuid().optional(),
    loginRevisionId: z$1.string().uuid().optional(),
    loginEditTime: z$1.string().refine((str) => isISO8601(str)).optional(),
    loginDifferences: z$1.array(LoginDifference).optional(),
    targetProfile: AuditlogEventTargetProfile.optional()
  });
  const AuditlogEventEnvelope = z$1.object({
    id: z$1.string().uuid(),
    profileId: z$1.string().uuid(),
    time: z$1.string().refine((str) => isISO8601(str)),
    clientIp: z$1.string().optional(),
    event: AuditlogEvent
  });
  const QueuedAuditlogEvent = z$1.object({
    organizationId: z$1.string().uuid(),
    clientTime: z$1.date(),
    lastKnownServerTime: z$1.date(),
    event: AuditlogEvent
  });
  const PersistableForeignVaultSyncPredicate = z$1.object({
    organizationTeamVaults: z$1.boolean().optional(),
    organizationAllVaults: z$1.array(z$1.string().uuid()).optional(),
    organizationPersonalVaultsForUsers: z$1.record(z$1.array(z$1.string().uuid())).optional(),
    organizationPersonalVaultsForProfiles: z$1.record(z$1.array(z$1.string().uuid())).optional(),
    profileAllVaults: z$1.array(z$1.string().uuid()).optional()
  });
  const PersistableProfileRepo = z$1.object({
    profiles: z$1.array(PersistableProfile),
    orgAdminProfiles: z$1.array(PersistableProfile).default([]),
    disabledProfiles: z$1.array(PersistableProfile).default([])
  });
  const LinkedLoginUpdateMessageV1 = z$1.array(z$1.union([
    z$1.object({
      type: z$1.literal("originUpdated"),
      loginId: z$1.string().uuid(),
      content: UnprotectedLoginListElement
    }),
    z$1.object({
      type: z$1.literal("targetDeleted"),
      loginId: z$1.string().uuid(),
      removeTime: z$1.string().refine((str) => isISO8601(str))
    })
  ]));
  var __rest$G = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  const schemaLockDtoNewKeyNames = z$1.object({
    authenticatorId: z$1.string().uuid(),
    encryptedStorableVaultKey: z$1.instanceof(Uint8Array),
    encryptedHighSecurityVaultKey: z$1.instanceof(Uint8Array),
    encryptedVaultMessagePrivateKey: z$1.instanceof(Uint8Array).nullable().default(null)
  });
  const schemaLockDtoOldKeyNames = z$1.object({
    authenticatorId: z$1.string().uuid(),
    vaultKek: z$1.instanceof(Uint8Array),
    protectedKek: z$1.instanceof(Uint8Array)
  }).transform((_a3) => {
    var { vaultKek, protectedKek } = _a3, rest = __rest$G(_a3, ["vaultKek", "protectedKek"]);
    return Object.assign({ encryptedStorableVaultKey: vaultKek, encryptedHighSecurityVaultKey: protectedKek, encryptedVaultMessagePrivateKey: null }, rest);
  });
  const schemaVaultAuthenticatorLockDto = z$1.union([
    schemaLockDtoOldKeyNames,
    schemaLockDtoNewKeyNames
  ]);
  const schemaVaultProfileLockDtoOldKeyNames = z$1.object({
    profileId: z$1.string().uuid(),
    profileKeyGenerationId: z$1.string().uuid(),
    encryptedStorableVaultKey: z$1.instanceof(Uint8Array),
    encryptedHighSecurityVaultKey: z$1.instanceof(Uint8Array),
    encryptedVaultMessagePrivateKey: z$1.instanceof(Uint8Array).nullable().default(null)
  }).transform((_a3) => {
    var { profileId, profileKeyGenerationId } = _a3, rest = __rest$G(_a3, ["profileId", "profileKeyGenerationId"]);
    return Object.assign({ lockingProfileId: profileId, lockingProfileKeyGenerationId: profileKeyGenerationId }, rest);
  });
  const schemaVaultProfileLockDtoNewKeyNames = z$1.object({
    lockingProfileId: z$1.string().uuid(),
    lockingProfileKeyGenerationId: z$1.string().uuid(),
    encryptedStorableVaultKey: z$1.instanceof(Uint8Array),
    encryptedHighSecurityVaultKey: z$1.instanceof(Uint8Array),
    encryptedVaultMessagePrivateKey: z$1.instanceof(Uint8Array).nullable().default(null)
  });
  const schemaVaultProfileLockDto = z$1.union([
    schemaVaultProfileLockDtoOldKeyNames,
    schemaVaultProfileLockDtoNewKeyNames
  ]);
  const schemaLinkedUpdateMessage = z$1.object({
    vaultId: z$1.string().uuid(),
    type: z$1.literal(VaultMessageType.LINKED_LOGIN_UPDATE_V1),
    message: LinkedLoginUpdateMessageV1
  });
  const PersistableVault = z$1.object({
    id: z$1.string().uuid(),
    type: makeProtobufEnumSchema(VaultType),
    associatedVaultId: z$1.string().uuid().optional().nullable(),
    generationId: z$1.string().uuid(),
    firstCommitId: z$1.string().uuid().optional(),
    commitId: z$1.string().uuid(),
    userIds: z$1.array(z$1.string().uuid()),
    profileIds: z$1.array(z$1.string().uuid()).optional(),
    organizationId: z$1.string().uuid().optional().nullable(),
    locks: z$1.array(schemaVaultAuthenticatorLockDto),
    profileLock: schemaVaultProfileLockDto.optional(),
    adminProfileLock: schemaVaultProfileLockDto.optional(),
    dirty: z$1.boolean().optional(),
    vaultState: z$1.instanceof(Uint8Array),
    stagedDiff: z$1.union([z$1.instanceof(Uint8Array), z$1.null()]).optional(),
    messagePublicKey: z$1.instanceof(Uint8Array).nullable().default(null),
    inboxSlug: z$1.string().nullable().default(null),
    linkedUpdateMessages: z$1.array(schemaLinkedUpdateMessage).default([])
  });
  const PersistableVaultRepo = z$1.object({
    vaults: z$1.array(PersistableVault)
  });
  z$1.object({
    accountState: PersistableAccountState,
    profileRepo: PersistableProfileRepo.default({ profiles: [] }),
    vaultRepo: PersistableVaultRepo,
    lastKnownSyncVersion: z$1.number().optional(),
    superUserUnlockedAuthenticators: z$1.record(UnlockedAuthenticator$1).optional(),
    foreignVaultSyncPredicate: PersistableForeignVaultSyncPredicate.optional(),
    ignoredUnlock: z$1.date().optional(),
    auditlogEventQueue: z$1.array(QueuedAuditlogEvent).default([])
  });
  z$1.object({
    streetAndNumber: z$1.string().optional(),
    streetAdditional: z$1.string().optional(),
    postalCode: z$1.string().optional(),
    city: z$1.string().optional(),
    region: z$1.string().optional(),
    country: z$1.string().optional()
  });
  const PersistableAuthenticatorBlockContent = objectType({
    parent: stringType().refine(isBase64, "could not parse base64 parent hash"),
    keys: arrayType(stringType().refine(isBase64, "could not parse base64 key"))
  });
  const VaultStateInternalStructure = objectPassthrough({
    type: z$1.string(),
    version: z$1.number(),
    content: z$1.unknown()
  });
  const AutosnatchUndoCreate = z$1.object({
    id: z$1.string().uuid(),
    type: z$1.literal("create"),
    editTime: z$1.string().refine((str) => isISO8601(str)),
    loginId: z$1.string().uuid(),
    vaultId: z$1.string().uuid().optional(),
    applied: z$1.boolean().optional(),
    seen: z$1.boolean().optional()
  });
  const AutosnatchUndoUpdate = z$1.object({
    id: z$1.string().uuid(),
    type: z$1.literal("update"),
    editTime: z$1.string().refine((str) => isISO8601(str)),
    loginId: z$1.string().uuid(),
    vaultId: z$1.string().uuid().optional(),
    applied: z$1.boolean().optional(),
    seen: z$1.boolean().optional(),
    oldEditTime: z$1.string().refine((str) => isISO8601(str)),
    oldPassword: UnprotectedValue.optional(),
    oldUsername: z$1.string().optional(),
    oldEditProfile: z$1.string().uuid().optional(),
    newRevisionId: z$1.string().uuid().optional(),
    oldEditSource: makeUnknownValuePlaceholderSchema(schemaLoginSource, void 0).optional()
  });
  const AutosnatchUndo = z$1.union([AutosnatchUndoCreate, AutosnatchUndoUpdate]);
  const ContentScriptAddress = z$1.object({
    tabId: z$1.number(),
    frameId: z$1.number().optional()
  });
  const AutosnatchSource = z$1.union([
    z$1.literal(LoginSource.addTotpFromOverlay),
    z$1.literal(LoginSource.updateLoginFromOverlay),
    z$1.literal(LoginSource.autosave),
    z$1.literal(LoginSource.registrationPasswordGeneration)
  ]);
  const EnqueuedAutosnatch = z$1.object({
    id: z$1.string().uuid(),
    date: z$1.string().refine((str) => isISO8601(str)),
    url: z$1.string(),
    username: z$1.string(),
    password: z$1.string(),
    seen: z$1.boolean().optional(),
    forceCreate: z$1.boolean().optional(),
    targetLoginId: z$1.string().uuid().optional(),
    targetVaultId: z$1.string().uuid().optional(),
    waitForContentScript: ContentScriptAddress.optional(),
    hideUntilCompletion: z$1.boolean().optional(),
    addTldPlus1: z$1.boolean().optional(),
    source: AutosnatchSource.optional().catch(void 0)
  });
  z$1.object({
    userId: z$1.string().uuid(),
    undos: z$1.array(AutosnatchUndo),
    queue: z$1.array(EnqueuedAutosnatch)
  });
  z$1.object({
    contact: ContactInfo.optional()
  });
  const LoginInboxMessageV1 = z$1.object({
    sender: z$1.object({
      name: z$1.string(),
      company: z$1.string().optional()
    }),
    website: z$1.string(),
    username: z$1.string(),
    password: z$1.string(),
    creationTime: z$1.string().refine((str) => isISO8601(str))
  });
  const CsvIntegrationDataUser = z$1.object({
    email: z$1.string(),
    filterColumnData: z$1.record(z$1.array(z$1.string()).optional())
  });
  const CsvFilterColumn = z$1.object({
    name: z$1.string(),
    multiValue: z$1.boolean(),
    values: z$1.array(z$1.string())
  });
  const CsvIntegrationData = z$1.object({
    users: z$1.array(CsvIntegrationDataUser),
    filterColumns: z$1.array(CsvFilterColumn),
    originalCsv: z$1.string()
  });
  const ShareLinkOpenedBackendMessageV1 = z$1.object({
    shareLinkId: z$1.string(),
    openedAt: z$1.string().refine((str) => isISO8601(str))
  });
  const LoginFormElementSelectors = z$1.object({
    passwordElement: z$1.string().nullable(),
    usernameElement: z$1.string().nullable(),
    totpElements: z$1.string().or(z$1.array(z$1.string())).nullable(),
    submitElement: z$1.string().nullable(),
    stayLoggedInElement: z$1.string().nullable(),
    formElement: z$1.string().nullable()
  }).nullable();
  const AndPredicate = z$1.object({
    type: z$1.literal("all"),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    predicates: z$1.array(z$1.lazy(() => OverridePredicate))
  });
  const OrPredicate = z$1.object({
    type: z$1.literal("atLeastOne"),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    predicates: z$1.array(z$1.lazy(() => OverridePredicate))
  });
  const ElementExistsPredicate = z$1.object({
    type: z$1.literal("elementExists"),
    selector: z$1.string(),
    requireVisible: z$1.boolean().optional()
  });
  const OverridePredicate = z$1.intersection(z$1.discriminatedUnion("type", [AndPredicate, OrPredicate, ElementExistsPredicate]), z$1.object({ negated: z$1.boolean().optional() }));
  const RegistrationFormElementSelectors = z$1.object({
    formElement: z$1.string().nullable(),
    passwordElement: z$1.string().nullable(),
    repeatPasswordElement: z$1.string().nullable(),
    usernameElement: z$1.string().nullable(),
    submitElement: z$1.string().nullable()
  }).nullable();
  const LoginOverrideRule = z$1.object({
    type: z$1.literal("loginForm"),
    selectors: LoginFormElementSelectors
  });
  const RegistrationOverrideRule = z$1.object({
    type: z$1.literal("registrationForm"),
    selectors: RegistrationFormElementSelectors
  });
  const NoFormOverrideRule = z$1.object({
    type: z$1.literal("noForm")
  });
  const FormKindHintOverrideRule = z$1.object({
    type: z$1.literal("formKindHint"),
    kind: z$1.union([z$1.literal("login"), z$1.literal("registration")])
  });
  const OverrideRule = z$1.intersection(z$1.discriminatedUnion("type", [
    LoginOverrideRule,
    RegistrationOverrideRule,
    NoFormOverrideRule,
    FormKindHintOverrideRule
  ]), z$1.object({ predicate: OverridePredicate.optional() }));
  var WebpageOverrideStatus;
  (function(WebpageOverrideStatus2) {
    WebpageOverrideStatus2["hotfix"] = "hotfix";
  })(WebpageOverrideStatus || (WebpageOverrideStatus = {}));
  const WebpageOverride = z$1.intersection(z$1.object({
    id: z$1.string().uuid(),
    status: makeTypescriptEnumSchema(WebpageOverrideStatus).optional(),
    comment: z$1.string().optional(),
    rules: z$1.array(OverrideRule)
  }), z$1.union([
    z$1.object({ hostnameContains: z$1.string(), predicate: OverridePredicate.optional() }),
    z$1.object({ predicate: OverridePredicate })
  ]));
  z$1.array(WebpageOverride);
  const ExtensionAvailableInfoMessage = objectPassthrough({
    type: z$1.literal("extensionAvailableInfo"),
    globalSearch: z$1.object({ shortcut: z$1.string().optional() }).optional(),
    isSimulated: z$1.boolean().optional()
  });
  const GetClientCoreParametersRequestMessage = objectPassthrough({
    type: z$1.literal("getClientCoreParametersRequest")
  });
  const SetClientCoreParametersMessage = objectPassthrough({
    type: z$1.literal("setClientCoreParameters"),
    clientCoreParametersJSON: z$1.string()
  });
  z$1.union([
    ExtensionAvailableInfoMessage,
    GetClientCoreParametersRequestMessage,
    SetClientCoreParametersMessage
  ]);
  const IsExtensionAvailableMessage = objectPassthrough({
    type: z$1.literal("isExtensionAvailable")
  });
  const ClientCoreParametersChangeMessage = objectPassthrough({
    type: z$1.literal("clientCoreParametersChange")
  });
  const OpenShortcutSettingsMessage = objectPassthrough({
    type: z$1.literal("openShortcutSettings")
  });
  const GetClientCoreParametersResponseMessage = objectPassthrough({
    type: z$1.literal("getClientCoreParametersResponse"),
    clientCoreParametersJSON: z$1.string().optional()
  });
  const SetClearValueFromClipboardAfterTimeoutMessage = objectPassthrough({
    type: z$1.literal("setClearValueFromClipboardAfterTimeout"),
    clearAfterTimeout: z$1.boolean(),
    value: z$1.string()
  });
  const ToExtensionMessage = z$1.union([
    IsExtensionAvailableMessage,
    ClientCoreParametersChangeMessage,
    OpenShortcutSettingsMessage,
    GetClientCoreParametersResponseMessage,
    SetClearValueFromClipboardAfterTimeoutMessage
  ]);
  function isActiveWebauthnAuthenticator(a) {
    return a.authenticatorType === AuthenticatorType.WEBAUTHN && a.webauthn !== void 0;
  }
  const SALT_AUTHENTICATOR_HIGH_SECURITY_LOGIN_SIGNING_KEY = "salt-authenticator-login-signing-key-";
  const SALT_AUTHENTICATOR_HIGH_SECURITY_IDENTITY_SIGNING_KEY = "salt-authenticator-signing-key-";
  const SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY = "salt-authenticator-encryption-key-";
  const SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY = "salt-authenticator-signing-key-";
  const SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY = "salt-authenticator-encryption-key-";
  const SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-authenticator-encryption-key-signature-";
  const SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY_SIGNATURE = "salt-authenticator-signing-key-signature-";
  const SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-authenticator-encryption-key-signature-";
  const SALT_AUTHENTICATOR_WEBAUTHN_SEED = "salt-authenticator-webauthn-seed-";
  function verifyAuthenticator(a) {
    if (!verifySignedEncryptionPublicKey(a.highSecurityIdentitySigPubKey, a.highSecurityVaultKeyEncPubKey, a.highSecurityVaultKeyEncPubKeySignature, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE)) {
      return false;
    }
    if (!verifySignedEncryptionPublicKey(a.highSecurityIdentitySigPubKey, a.storableVaultKeyEncPubKey, a.storableVaultKeyEncPubKeySignature, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE)) {
      return false;
    }
    if (!verifySignedSigningPublicKey(a.highSecurityIdentitySigPubKey, a.storableSigPubKey, a.storableSigPubKeySignature, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY_SIGNATURE)) {
      return false;
    }
    return true;
  }
  var ClientCoreErrorGroup;
  (function(ClientCoreErrorGroup2) {
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Generic"] = 1e4] = "Generic";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Vault"] = 2e4] = "Vault";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Authenticator"] = 3e4] = "Authenticator";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Syncing"] = 4e4] = "Syncing";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Core"] = 5e4] = "Core";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Login"] = 6e4] = "Login";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Protected"] = 7e4] = "Protected";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Organization"] = 8e4] = "Organization";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Profile"] = 9e4] = "Profile";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Webauthn"] = 1e5] = "Webauthn";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["ShareLink"] = 11e4] = "ShareLink";
  })(ClientCoreErrorGroup || (ClientCoreErrorGroup = {}));
  var ClientCoreErrorCode;
  (function(ClientCoreErrorCode2) {
    ClientCoreErrorCode2[ClientCoreErrorCode2["NotImplemented"] = 2010500] = "NotImplemented";
    ClientCoreErrorCode2[ClientCoreErrorCode2["Internal"] = 2010501] = "Internal";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ParentIdDoesntMatch"] = 2020401] = "ParentIdDoesntMatch";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CannotOverrideCommitId"] = 2020402] = "CannotOverrideCommitId";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidSessionModification"] = 2020410] = "InvalidSessionModification";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidVaultContentDescriptorName"] = 2020411] = "InvalidVaultContentDescriptorName";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginNotFound"] = 2020412] = "LoginNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CannotRegenerateLockedVault"] = 2020420] = "CannotRegenerateLockedVault";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UserAuthenticatorsMissingForRegenerate"] = 2020421] = "UserAuthenticatorsMissingForRegenerate";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ProfileMissingForRegenerate"] = 2020422] = "ProfileMissingForRegenerate";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoCommits"] = 2020430] = "NoCommits";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NeedLocks"] = 2020431] = "NeedLocks";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NeedFullHistory"] = 2020432] = "NeedFullHistory";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultIsLocked"] = 2020440] = "VaultIsLocked";
    ClientCoreErrorCode2[ClientCoreErrorCode2["MetaVaultIdDoesntMatch"] = 2020450] = "MetaVaultIdDoesntMatch";
    ClientCoreErrorCode2[ClientCoreErrorCode2["MetaVaultNotFound"] = 2020451] = "MetaVaultNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultNotFound"] = 2020452] = "VaultNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PrivateLoginVaultNotFound"] = 2020456] = "PrivateLoginVaultNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["IncorrectVaultTypeError"] = 2020459] = "IncorrectVaultTypeError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidCommitStructure"] = 2020460] = "InvalidCommitStructure";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultContentTooNew"] = 2020461] = "VaultContentTooNew";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidCommitContent"] = 2020462] = "InvalidCommitContent";
    ClientCoreErrorCode2[ClientCoreErrorCode2["MergeConflict"] = 2020463] = "MergeConflict";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnsupportedCompression"] = 2020464] = "UnsupportedCompression";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnsupportedVaultVersion"] = 2020465] = "UnsupportedVaultVersion";
    ClientCoreErrorCode2[ClientCoreErrorCode2["TeamVaultMissingAssociatedMetaVault"] = 2020470] = "TeamVaultMissingAssociatedMetaVault";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultPermissionDenied"] = 2020471] = "VaultPermissionDenied";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnsupportedLoginVaultType"] = 2020472] = "UnsupportedLoginVaultType";
    ClientCoreErrorCode2[ClientCoreErrorCode2["OrganizationPersonalVaultNotFound"] = 2020473] = "OrganizationPersonalVaultNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultLinkingNotSupported"] = 2020480] = "VaultLinkingNotSupported";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultMessageEncryptedDataNotFound"] = 2020490] = "VaultMessageEncryptedDataNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LockAuthenticatorNotFound"] = 2030400] = "LockAuthenticatorNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnlockedAuthenticatorNotFound"] = 2030420] = "UnlockedAuthenticatorNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginWithRecovery"] = 2030430] = "LoginWithRecovery";
    ClientCoreErrorCode2[ClientCoreErrorCode2["RemoveLocalAuthenticator"] = 2030440] = "RemoveLocalAuthenticator";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LazyWithoutGetter"] = 2030450] = "LazyWithoutGetter";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LazyWithSetter"] = 2030451] = "LazyWithSetter";
    ClientCoreErrorCode2[ClientCoreErrorCode2["WrongAuthenticatorSecret"] = 2030452] = "WrongAuthenticatorSecret";
    ClientCoreErrorCode2[ClientCoreErrorCode2["SecretReuse"] = 2030460] = "SecretReuse";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidRecoveryCode"] = 2030461] = "InvalidRecoveryCode";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidAuthenticatorSeedLength"] = 2030462] = "InvalidAuthenticatorSeedLength";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorSecreMissingId"] = 2030470] = "AuthenticatorSecreMissingId";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorNotFound"] = 2030471] = "AuthenticatorNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorBlockNotInitial"] = 2030480] = "AuthenticatorBlockNotInitial";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorBlockNotChild"] = 2030481] = "AuthenticatorBlockNotChild";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorBlockInvalidSigningKey"] = 2030482] = "AuthenticatorBlockInvalidSigningKey";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoMatchingSigningKeyFound"] = 2030490] = "NoMatchingSigningKeyFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoAuthenticatorIdReceived"] = 2030500] = "NoAuthenticatorIdReceived";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnlockRejected"] = 2040401] = "UnlockRejected";
    ClientCoreErrorCode2[ClientCoreErrorCode2["FailedPushingCommit"] = 2040410] = "FailedPushingCommit";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginDataMissing"] = 2050400] = "LoginDataMissing";
    ClientCoreErrorCode2[ClientCoreErrorCode2["OwnSessionMissing"] = 2050401] = "OwnSessionMissing";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ClientCoreIsLocked"] = 2050440] = "ClientCoreIsLocked";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PersistableMismatchError"] = 2050500] = "PersistableMismatchError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginNotInitiated"] = 2060400] = "LoginNotInitiated";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PushFlowRunning"] = 2060410] = "PushFlowRunning";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ChannelIdMissing"] = 2060411] = "ChannelIdMissing";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidHashCommitment"] = 2060420] = "InvalidHashCommitment";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginCancelled"] = 2060421] = "LoginCancelled";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnknownAuthenticatorReply"] = 2060430] = "UnknownAuthenticatorReply";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ProtectInternalError"] = 2070500] = "ProtectInternalError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CantProtect"] = 2070401] = "CantProtect";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CantUnprotect"] = 2070402] = "CantUnprotect";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CantCreateLock"] = 2070403] = "CantCreateLock";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CantDecryptVaultMessage"] = 2070404] = "CantDecryptVaultMessage";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultProtectedSecretNotFound"] = 2070405] = "VaultProtectedSecretNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["OrganizationNotFoundError"] = 2080400] = "OrganizationNotFoundError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoOrganizationMemberError"] = 2080401] = "NoOrganizationMemberError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoOrganizationAdminError"] = 2080402] = "NoOrganizationAdminError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AdminVaultNotFoundError"] = 2080403] = "AdminVaultNotFoundError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LockProfileNotFound"] = 2090400] = "LockProfileNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ProfileKeyGenerationMismatch"] = 2090401] = "ProfileKeyGenerationMismatch";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoMatchingProfileFound"] = 2090402] = "NoMatchingProfileFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ProfileNotFoundError"] = 2090404] = "ProfileNotFoundError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PrfNotSupportedError"] = 2100501] = "PrfNotSupportedError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PrfInitError"] = 2100502] = "PrfInitError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ShareLinkNotFound"] = 2110400] = "ShareLinkNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidShareLink"] = 2110401] = "InvalidShareLink";
  })(ClientCoreErrorCode || (ClientCoreErrorCode = {}));
  const pleaseUpdate$1 = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
  class ClientCoreDomainError extends DomainError$1 {
    constructor(code, short, userTitle, userDetail) {
      super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate$1);
    }
  }
  class NotImplementedError extends ClientCoreDomainError {
    constructor(featureName) {
      super(ClientCoreErrorCode.NotImplemented, `The feature "${featureName}" is not implemented yet`);
    }
  }
  class ClientCoreInternalError extends ClientCoreDomainError {
    constructor(message) {
      super(ClientCoreErrorCode.Internal, `Internal error: ${message}`);
    }
  }
  class PersistableMismatchError extends ClientCoreDomainError {
    constructor(persistableUserId, ccpUserId) {
      super(ClientCoreErrorCode.PersistableMismatchError, `Persisted user did not match login parameters! (persistable: ${persistableUserId}, ccp: ${ccpUserId})`);
    }
  }
  class ParentIdDoesntMatchError extends ClientCoreDomainError {
    constructor(want, got) {
      super(ClientCoreErrorCode.ParentIdDoesntMatch, `Commit parentId doesn't match: expected ${want}, got ${got}`, `Commit parentId doesn't match: expected ${want}, got ${got}`, `The vault data loaded seems to be inconsistent. Try to re-login. ${pleaseUpdate$1}`);
    }
  }
  class CannotOverrideCommitIdError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.CannotOverrideCommitId, "Cannot override commitId if not in staging state!", "", "");
    }
  }
  class CannotProtectError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.CantProtect, "Can't protect while locked!", "Can't protect while locked!", `Tried to access a protected value while not logged in. Log in using the app, then try again. ${pleaseUpdate$1}`);
    }
  }
  class CannotUnprotectError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.CantUnprotect, "Can't unprotect while locked!", "Can't unprotect while locked!", `Tried to access a protected value while not logged in. Log in using the app, then try again. ${pleaseUpdate$1}`);
    }
  }
  class CannotCreateLockError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.CantCreateLock, "Can't create lock while locked!");
    }
  }
  class ProtectInternalError extends ClientCoreDomainError {
    constructor(detail) {
      super(ClientCoreErrorCode.ProtectInternalError, detail, detail, `The client produced an internal error while trying to access a protected value. ${pleaseUpdate$1}`);
    }
  }
  class CannotDecryptVaultMessageError extends ClientCoreDomainError {
    constructor(detail = "Cannot decrypt vault message") {
      super(ClientCoreErrorCode.CantDecryptVaultMessage, detail);
    }
  }
  class VaultProtectedSecretNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultProtectedSecretNotFound, "Vault secret not found", "Vault secret not found", `The client is trying to access protected values of a vault with no present protected secret. ${pleaseUpdate$1}`);
    }
  }
  class InvalidSessionModificationError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidSessionModification, "Session modification led to invalid vault content!");
    }
  }
  class InvalidVaultContentDescriptorNameError extends ClientCoreDomainError {
    constructor(typeName) {
      super(ClientCoreErrorCode.InvalidVaultContentDescriptorName, `Unknown type descriptor ${typeName}`);
    }
  }
  class LoginNotFoundError extends ClientCoreDomainError {
    constructor(id2) {
      super(ClientCoreErrorCode.LoginNotFound, `No login with id "${id2}"!`);
    }
  }
  class UserAuthenticatorsMissingForRegenerateError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UserAuthenticatorsMissingForRegenerate, "Can't regenerate, authenticators are not presents for all users of the vault!");
    }
  }
  class ProfileMissingForRegenerateError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.ProfileMissingForRegenerate, "Can't regenerate, not all profiles present for the vault!");
    }
  }
  class LockAuthenticatorNotFoundError extends ClientCoreDomainError {
    constructor(authId, locks) {
      super(ClientCoreErrorCode.LockAuthenticatorNotFound, `Found no matching lock for available authenticator! Locally available authenticator id ${authId}, lock authenticator ids: ${locks.map((l2) => l2.authenticatorId)}`);
    }
  }
  class LockProfileNotFoundError extends ClientCoreDomainError {
    constructor(profileId) {
      super(ClientCoreErrorCode.LockProfileNotFound, `Got no matching lock for available profiles! Lock profile id: ${profileId}`);
    }
  }
  class ProfileKeyGenerationMismatchError extends ClientCoreDomainError {
    constructor(profileId, profileGenId, lockGenId) {
      super(ClientCoreErrorCode.ProfileKeyGenerationMismatch, `Mismatched keyGenerationId, profileId: ${profileId}, profile keyGenId: ${profileGenId}, lock keyGenId: ${lockGenId}
        (p) => p.profile.id,
      )}`);
    }
  }
  class ProfileNotFoundError extends ClientCoreDomainError {
    constructor(profileId) {
      super(ClientCoreErrorCode.ProfileNotFoundError, `Profile ${profileId} unexpectedly not loaded`);
    }
  }
  class NeedLocksError extends ClientCoreDomainError {
    constructor(vaultId, oldGenId, newGenId) {
      super(ClientCoreErrorCode.NeedLocks, `Unexpectedly didn't receive locks (vault ${vaultId}, local gen ${oldGenId}, new gen ${newGenId})`);
    }
  }
  class NeedFullHistoryError extends ClientCoreDomainError {
    constructor(vaultId, oldGenId, newGenId) {
      super(ClientCoreErrorCode.NeedFullHistory, `Unexpectedly didn't receive full history (vault ${vaultId}, local gen ${oldGenId}, new gen ${newGenId})`);
    }
  }
  class UnlockedAuthenticatorNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnlockedAuthenticatorNotFound, "Provided unlock does not match any known authenticator");
    }
  }
  class UnlockRejectedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnlockRejected, "Unlock request rejected");
    }
  }
  class LoginWithRecoveryError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LoginWithRecovery, "Can't perform a regular login with recovery authenticator!");
    }
  }
  class LoginDataMissingError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LoginDataMissing, "Login Data is missing!");
    }
  }
  class OwnSessionMissingError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.OwnSessionMissing, "Missing our own session. This should never happen, expected DomainError!");
    }
  }
  class ClientCoreIsLockedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.ClientCoreIsLocked, "Tried to modify a locked ClientCore");
    }
  }
  class VaultIsLockedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultIsLocked, "StagedDiff can't be re-encrypted while vault is locked");
    }
  }
  class RemoveLocalAuthenticatorError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.RemoveLocalAuthenticator, "Cannot remove local unlocked authenticator!");
    }
  }
  class LazyWithoutGetterError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LazyWithoutGetter, "Lazy is only applicable for getters!");
    }
  }
  class LazyWithSetterError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LazyWithSetter, "Lazy is only applicable if no setter is specified!");
    }
  }
  class WrongAuthenticatorSecretError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.WrongAuthenticatorSecret, "Tried to unlock authenticator with wrong authenticator secret!");
    }
  }
  class SecretReuseError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.SecretReuse, "Can't reuse secret that is already associated with an authenticator");
    }
  }
  class InvalidAuthenticatorSeedLengthError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidAuthenticatorSeedLength, "Authenticator seed length must be 32 bytes!");
    }
  }
  class MetaVaultNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.MetaVaultNotFound, "No initialized meta vault!");
    }
  }
  class VaultNotFoundError extends ClientCoreDomainError {
    constructor(vaultId) {
      super(ClientCoreErrorCode.VaultNotFound, `No Vault with id ${vaultId} in VaultRepo`);
    }
  }
  class VaultLinkingNotSupportedError extends ClientCoreDomainError {
    constructor(vaultId) {
      super(ClientCoreErrorCode.VaultLinkingNotSupported, `Linking logins not supported for vault ${vaultId}`);
    }
  }
  class VaultMessageEncryptedDataNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultMessageEncryptedDataNotFound, "Encrypted vault message not found");
    }
  }
  class IncorrectVaultTypeError extends ClientCoreDomainError {
    constructor(vaultId, expected, actual) {
      super(ClientCoreErrorCode.IncorrectVaultTypeError, `Expected vault of type ${expected} for id ${vaultId}, got ${actual} instead.`);
    }
  }
  class TeamVaultMissingAssociatedMetaVaultError extends ClientCoreDomainError {
    constructor(vaultId) {
      super(ClientCoreErrorCode.TeamVaultMissingAssociatedMetaVault, `Team vault with id ${vaultId} is missing its associated meta vault.`);
    }
  }
  class VaultPermissionDeniedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultPermissionDenied, `Account is missing permissions to perform vault operation.`);
    }
  }
  class UnsupportedLoginVaultTypeError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnsupportedLoginVaultType, `Client encountered a login vault with an unsupported type.`);
    }
  }
  class InvalidCommitStructureError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidCommitStructure, "Structure of commit to apply is not valid");
    }
  }
  class VaultContentTooNewError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultContentTooNew, "VaultContent too new, update client!");
    }
  }
  class InvalidCommitContentError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidCommitContent, "Content of commit to apply is not valid");
    }
  }
  class UnsupportedCompressionError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnsupportedCompression, "Commit uses unsupported compression algorithm!");
    }
  }
  class UnsupportedVaultVersionError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnsupportedVaultVersion, "Vault version is not supported!");
    }
  }
  class AuthenticatorNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.AuthenticatorNotFound, "Authenticator not found");
    }
  }
  class AuthenticatorBlockNotInitialError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.AuthenticatorBlockNotInitial, "cannot verify a child AuthenticatorBlock as initial");
    }
  }
  class AuthenticatorBlockNotChildError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.AuthenticatorBlockNotChild, "cannot verify initial AuthenticatorBlock against a parent");
    }
  }
  class NoMatchingSigningKeyFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.NoMatchingSigningKeyFound, "No key matching the signature");
    }
  }
  class NoAuthenticatorIdReceivedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.NoAuthenticatorIdReceived, "no authenticator id received");
    }
  }
  class InvalidHashCommitmentError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidHashCommitment, "Client public key does not match the hash commitment");
    }
  }
  class LoginCancelledError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LoginCancelled, "Operation was cancelled!");
    }
  }
  class OrganizationNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.OrganizationNotFoundError, "organization not found", "Organization not found!", `Tried to perform an operation on an unknown organization. ${pleaseUpdate$1}`);
    }
  }
  class NoOrganizationAdminError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.NoOrganizationAdminError, "no organization admin", "No organization admin!", `Tried to manipulate an organization without admin rights. ${pleaseUpdate$1}`);
    }
  }
  class PrfNotSupportedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.PrfNotSupportedError, "prf not supported", "Webauthn PRF extension not supported", `Your browser does not support the required PRF extension to perform this operation.`);
    }
  }
  class PrfInitError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.PrfInitError, "prf init error", "PRF initialization failed", `Enabling session pairing for this login device failed.`);
    }
  }
  class ShareLinkNotFoundError extends ClientCoreDomainError {
    constructor(shareLinkId) {
      super(ClientCoreErrorCode.ShareLinkNotFound, `No ShareLink with id ${shareLinkId} found`);
    }
  }
  const initialParentHash = hashData(naclUtilExports.decodeUTF8("INITIAL_AUTHENTICATOR_BLOCK"));
  const initialParentHashB64 = naclUtilExports.encodeBase64(initialParentHash);
  class AuthenticatorBlock {
    constructor(parentHash, keys2, signature) {
      this.parentHash = parentHash;
      this.keys = keys2;
      this.signature = signature;
      this.blob = AuthenticatorBlock.serialize(parentHash, keys2);
      this.hash = hashData(this.blob);
    }
    static serialize(parentHash, keys2) {
      const obj = {
        parent: naclUtilExports.encodeBase64(parentHash !== null && parentHash !== void 0 ? parentHash : initialParentHash),
        keys: keys2.map(naclUtilExports.encodeBase64).sort()
      };
      const serializedObj = canonicalize(obj);
      return naclUtilExports.decodeUTF8(serializedObj);
    }
    static parse(serialized, signature) {
      const jsonString = naclUtilExports.encodeUTF8(serialized);
      const { parent: parentB64, keys: b64keys } = PersistableAuthenticatorBlockContent.parse(JSON.parse(jsonString));
      const parent = parentB64 === initialParentHashB64 ? null : naclUtilExports.decodeBase64(parentB64);
      const keys2 = b64keys.map(loadSigningPublicKey);
      return new AuthenticatorBlock(parent, keys2, signature);
    }
    static signBlock(signingKey, previousHash, keys2) {
      const serialized = AuthenticatorBlock.serialize(previousHash, keys2);
      return hashAndSign(signingKey, serialized);
    }
    verifyInitial(fingerPrint) {
      if (this.parentHash) {
        throw new AuthenticatorBlockNotInitialError();
      }
      const hashValid = hashEqual(this.hash, fingerPrint);
      const signatureValid = this.keys.some((key) => verifyHashSignature(key, this.signature, this.hash));
      return hashValid && signatureValid;
    }
    verify(parentBlock) {
      if (!this.parentHash) {
        throw new AuthenticatorBlockNotChildError();
      }
      const signatureValid = parentBlock.keys.some((key) => verifyHashSignature(key, this.signature, this.hash));
      const parentHashValid = hashEqual(parentBlock.hash, this.parentHash);
      return signatureValid && parentHashValid;
    }
    static verifyChain(fingerPrint, [initialBlock, ...childBlocks]) {
      if (!initialBlock.verifyInitial(fingerPrint)) {
        return false;
      }
      return AuthenticatorBlock.verifyChainPart(initialBlock, childBlocks);
    }
    static verifyChainPart(validBlocks, childBlocks) {
      let parentBlock = validBlocks;
      for (const childBlock of childBlocks) {
        if (!childBlock.verify(parentBlock)) {
          return false;
        }
        parentBlock = childBlock;
      }
      return true;
    }
    containsKey(key) {
      return this.keys.some((tmpKey) => signingPublicKeyEqual(tmpKey, key));
    }
    static create(privateKey, publicKeys, parent) {
      const signature = AuthenticatorBlock.signBlock(privateKey, parent !== null && parent !== void 0 ? parent : null, publicKeys);
      return new AuthenticatorBlock(parent !== null && parent !== void 0 ? parent : null, publicKeys, signature);
    }
    static fromUnsyncedAuthenticators(mainUa, extraUas) {
      const allAuthenticators = [mainUa, ...extraUas];
      const keys2 = allAuthenticators.map((ua2) => ua2.highSecurityIdentitySigPubKey);
      const signature = AuthenticatorBlock.signBlock(mainUa.highSecurityIdentitySigPrivKey, null, keys2);
      return new AuthenticatorBlock(null, keys2, signature);
    }
    static load(parentHash, keys2, signature) {
      return new AuthenticatorBlock(parentHash, keys2, signature);
    }
  }
  function loadAuthenticator(dto) {
    const { id: id2, authenticatorType, secretInfo, secretSalt, webauthn } = dto;
    const highSecurityLoginSigPubKey = loadSigningPublicKey(dto.highSecurityLoginSigPubKey);
    const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
    const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
    const highSecurityVaultKeyEncPubKeySignature = loadSigningPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
    const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
    const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
    const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
    const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
    return {
      id: id2,
      authenticatorType,
      highSecurityLoginSigPubKey,
      highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature,
      storableSigPubKey,
      storableSigPubKeySignature,
      storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature,
      secretInfo,
      secretSalt,
      webauthn
    };
  }
  function loadForeignAuthenticator(dto) {
    const { id: id2 } = dto;
    const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
    const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
    const highSecurityVaultKeyEncPubKeySignature = loadSigningPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
    const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
    const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
    const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
    const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
    return {
      id: id2,
      highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature,
      storableSigPubKey,
      storableSigPubKeySignature,
      storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature
    };
  }
  function Lazy(_target, _propertyKey, descriptor) {
    if (!descriptor.get) {
      throw new LazyWithoutGetterError();
    }
    if (descriptor.set) {
      throw new LazyWithSetterError();
    }
    const originalGetter = descriptor.get;
    const { enumerable, configurable } = descriptor;
    const cache2 = /* @__PURE__ */ new WeakMap();
    return {
      enumerable,
      configurable,
      get: function get() {
        const cached = cache2.get(this);
        if (cached !== void 0) {
          return cached;
        }
        const originalResult = originalGetter.call(this);
        cache2.set(this, originalResult);
        return originalResult;
      }
    };
  }
  const SALT_PROFILE_STORABLE_SEED = "salt-profile-storable-seed-";
  const SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY = "salt-profile-high-security-identity-signing-key-";
  const SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY = "salt-profile-high-security-vault-key-encryption-key-";
  const SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY = "salt-profile-high-security-profile-key-encryption-key-";
  const SALT_PROFILE_STORABLE_SIGNING_KEY = "salt-profile-storable-signing-key-";
  const SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY = "salt-profile-storable-vault-key-encryption-key-";
  const SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY = "salt-profile-storable-profile-key-encryption-key-";
  const SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-high-security-vault-key-encryption-key-signature-";
  const SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-high-security-profile-key-encryption-key-signature-";
  const SALT_PROFILE_STORABLE_SIGNING_KEY_SIGNATURE = "salt-profile-storable-signing-key-signature-";
  const SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-storable-vault-key-encryption-key-signature-";
  const SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-storable-profile-key-encryption-key-signature-";
  var __decorate$5 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  class UnlockedProfile {
    constructor(profile, storableSeed) {
      this.profile = profile;
      this.storableSeed = storableSeed;
    }
    static fromSeed(profile, storableSeed) {
      return new UnlockedProfile(profile, storableSeed);
    }
    static load(dto, unlockedAuthenticator, unlockedUpstreamProfile) {
      const profile = loadProfile(dto);
      if ("localEncryptedStorableSeed" in dto && dto.localEncryptedStorableSeed) {
        const storableSeed2 = asymDecrypt(unlockedAuthenticator.storableVaultKeyEncPrivKey, dto.localEncryptedStorableSeed);
        return new UnlockedProfile(profile, storableSeed2);
      }
      if (unlockedUpstreamProfile && profile.profileLock) {
        const storableSeed2 = asymDecrypt(unlockedUpstreamProfile.storableProfileSeedEncPrivKey, profile.profileLock.encryptedStorableProfileSeed);
        return new UnlockedProfile(profile, storableSeed2);
      }
      const candidateLock = profile.authenticatorLocks.find((lock) => lock.authenticatorId === unlockedAuthenticator.authenticator.id);
      if (!candidateLock) {
        throw new LockAuthenticatorNotFoundError(unlockedAuthenticator.authenticator.id, profile.authenticatorLocks);
      }
      const storableSeed = asymDecrypt(unlockedAuthenticator.storableVaultKeyEncPrivKey, candidateLock.encryptedStorableProfileSeed);
      return new UnlockedProfile(profile, storableSeed);
    }
    getPersistable(ua2) {
      if (ua2) {
        const localEncryptedStorableSeed = asymEncrypt(ua2.authenticator.storableVaultKeyEncPubKey, this.storableSeed);
        return Object.assign(Object.assign({}, this.profile), { localEncryptedStorableSeed });
      }
      return this.profile;
    }
    get storableSigPrivKey() {
      return deriveSigningKeyPair(this.storableSeed, null, SALT_PROFILE_STORABLE_SIGNING_KEY).sigPrivKey;
    }
    get storableVaultKeyEncPrivKey() {
      return deriveEncryptionKeyPair(this.storableSeed, null, SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
    }
    get storableProfileSeedEncPrivKey() {
      return deriveEncryptionKeyPair(this.storableSeed, null, SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY).encPrivKey;
    }
  }
  __decorate$5([
    Lazy
  ], UnlockedProfile.prototype, "storableSigPrivKey", null);
  __decorate$5([
    Lazy
  ], UnlockedProfile.prototype, "storableVaultKeyEncPrivKey", null);
  __decorate$5([
    Lazy
  ], UnlockedProfile.prototype, "storableProfileSeedEncPrivKey", null);
  function requireOrgAdminProfile(up) {
    if (up.profile.profileType !== ProfileType.ORGANIZATION_ADMIN) {
      throw new Error(`required org admin profile (${ProfileType.ORGANIZATION_ADMIN}), got ${up.profile.profileType}`);
    }
    if (!up.profile.organizationId) {
      throw new Error("required organizationId in org admin profile, got null");
    }
    return up;
  }
  class UnlockedAuthenticator {
    constructor(authenticator, storableSigPrivKey, storableVaultKeyEncPrivKey) {
      this.authenticator = authenticator;
      this.storableSigPrivKey = storableSigPrivKey;
      this.storableVaultKeyEncPrivKey = storableVaultKeyEncPrivKey;
    }
  }
  var __decorate$4 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  class HighSecurityUnlockedAuthenticator {
    constructor(authenticator, secret) {
      this.authenticator = authenticator;
      this.secret = secret;
    }
    static fromAuthenticatorSecret(a, secret) {
      if (a.id !== secret.authenticatorId) {
        throw new WrongAuthenticatorSecretError();
      }
      return new HighSecurityUnlockedAuthenticator(a, secret);
    }
    createEncryptedSecret(encPubKey) {
      return asymEncrypt(encPubKey, this.secret.seed);
    }
    get highSecurityLoginSigPrivKey() {
      const { sigPrivKey: loginSigPrivKey } = deriveSigningKeyPair(this.secret.seed, null, SALT_AUTHENTICATOR_HIGH_SECURITY_LOGIN_SIGNING_KEY);
      return loginSigPrivKey;
    }
    get highSecurityIdentitySigPrivKey() {
      return deriveSigningKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_IDENTITY_SIGNING_KEY).sigPrivKey;
    }
    get highSecurityVaultKeyEncPrivKey() {
      return deriveEncryptionKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
    }
    get storableSigPrivKey() {
      return deriveSigningKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY).sigPrivKey;
    }
    get storableVaultKeyEncPrivKey() {
      return deriveEncryptionKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
    }
    getUnlockedAuthenticator() {
      return new UnlockedAuthenticator(this.authenticator, this.storableSigPrivKey, this.storableVaultKeyEncPrivKey);
    }
  }
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "highSecurityLoginSigPrivKey", null);
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "highSecurityIdentitySigPrivKey", null);
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "highSecurityVaultKeyEncPrivKey", null);
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "storableSigPrivKey", null);
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "storableVaultKeyEncPrivKey", null);
  class UnsyncedAuthenticator {
    constructor(authenticatorType, highSecurityLoginSigPubKey, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, secretInfo, secretSalt, webauthnCreationData, secret) {
      this.authenticatorType = authenticatorType;
      this.highSecurityLoginSigPubKey = highSecurityLoginSigPubKey;
      this.highSecurityIdentitySigPubKey = highSecurityIdentitySigPubKey;
      this.highSecurityIdentitySigPrivKey = highSecurityIdentitySigPrivKey;
      this.highSecurityVaultKeyEncPubKey = highSecurityVaultKeyEncPubKey;
      this.highSecurityVaultKeyEncPubKeySignature = highSecurityVaultKeyEncPubKeySignature;
      this.storableSigPubKey = storableSigPubKey;
      this.storableSigPubKeySignature = storableSigPubKeySignature;
      this.storableVaultKeyEncPubKey = storableVaultKeyEncPubKey;
      this.storableVaultKeyEncPubKeySignature = storableVaultKeyEncPubKeySignature;
      this.secretInfo = secretInfo;
      this.secretSalt = secretSalt;
      this.webauthnCreationData = webauthnCreationData;
      this.secret = secret;
    }
    static create(authenticatorType, secretInfo, secret) {
      const secretSalt = randomSeed();
      return this.createWithSalt(authenticatorType, secretInfo, secret, secretSalt);
    }
    static createWebauthn(secret, webauthnData) {
      const secretSalt = randomSeed();
      return this.createWithSalt(AuthenticatorType.WEBAUTHN, "", secret, secretSalt, webauthnData);
    }
    static createWithSalt(authenticatorType, secretInfo, secret, secretSalt, webauthnData) {
      if (secret.authenticatorId != null) {
        throw new SecretReuseError();
      }
      const { sigPubKey: highSecurityLoginSigPubKey } = deriveSigningKeyPair(secret.seed, null, SALT_AUTHENTICATOR_HIGH_SECURITY_LOGIN_SIGNING_KEY);
      const { sigPubKey: storableSigPubKey } = deriveSigningKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY);
      const { encPubKey: storableVaultKeyEncPubKey } = deriveEncryptionKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY);
      const { sigPubKey: highSecurityIdentitySigPubKey, sigPrivKey: highSecurityIdentitySigPrivKey } = deriveSigningKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_IDENTITY_SIGNING_KEY);
      const { encPubKey: highSecurityVaultKeyEncPubKey } = deriveEncryptionKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY);
      const highSecurityVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, storableVaultKeyEncPubKey, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableSigPubKeySignature = signSigningPublicKey(highSecurityIdentitySigPrivKey, storableSigPubKey, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY_SIGNATURE);
      return new UnsyncedAuthenticator(authenticatorType, highSecurityLoginSigPubKey, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, secretInfo, secretSalt, webauthnData, secret);
    }
    serializeForCreation(profileRepo, hsc) {
      const data = Object.assign(Object.assign({}, this), { id: nullUuid });
      const profileLocks = profileRepo.profiles.map((p2) => {
        const hsup = hsc.getHighSecurityUnlockedProfile(p2, profileRepo);
        if (!hsup) {
          throw new ClientCoreInternalError("Failed to unlock one of our profiles, can't regenerate!");
        }
        return hsup.createAuthenticatorLock(data);
      });
      if (profileRepo.disabledProfiles.length) {
        const hsua = hsc.getHighSecurityUnlockedAuthenticator();
        const ua2 = hsua.getUnlockedAuthenticator();
        profileRepo.disabledProfiles.forEach((p2) => {
          const up = UnlockedProfile.load(p2, ua2);
          const hsup = hsc.getHighSecurityUnlockedProfile(up, profileRepo);
          const profileLock = hsup.createAuthenticatorLock(this);
          profileLocks.push(profileLock);
        });
      }
      return { data, profileLocks, webauthn: this.webauthnCreationData };
    }
    serializeForRegistration() {
      return this.serializeWithLocks([]);
    }
    serializeWithLocks(profileLocks) {
      const data = Object.assign(Object.assign({}, this), { id: nullUuid });
      return { data, profileLocks, webauthn: this.webauthnCreationData };
    }
    withId(id2) {
      const auth = {
        id: id2,
        authenticatorType: this.authenticatorType,
        highSecurityLoginSigPubKey: this.highSecurityLoginSigPubKey,
        highSecurityIdentitySigPubKey: this.highSecurityIdentitySigPubKey,
        highSecurityVaultKeyEncPubKey: this.highSecurityVaultKeyEncPubKey,
        highSecurityVaultKeyEncPubKeySignature: this.highSecurityVaultKeyEncPubKeySignature,
        storableSigPubKey: this.storableSigPubKey,
        storableSigPubKeySignature: this.storableSigPubKeySignature,
        storableVaultKeyEncPubKey: this.storableVaultKeyEncPubKey,
        storableVaultKeyEncPubKeySignature: this.storableVaultKeyEncPubKeySignature,
        secretInfo: this.secretInfo,
        secretSalt: this.secretSalt,
        webauthn: this.webauthnCreationData
      };
      const secret = Object.assign(Object.assign({}, this.secret), { authenticatorId: id2 });
      return HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(auth, secret);
    }
  }
  class ProfileAuthenticatorLock {
    constructor(authenticatorId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed) {
      this.authenticatorId = authenticatorId;
      this.encryptedHighSecurityProfileSeed = encryptedHighSecurityProfileSeed;
      this.encryptedStorableProfileSeed = encryptedStorableProfileSeed;
    }
    static create(authenticator, highSecuritySeed, storableSeed) {
      const authenticatorId = authenticator instanceof UnsyncedAuthenticator ? nullUuid : authenticator.id;
      const encryptedHighSecurityProfileSeed = asymEncrypt(authenticator.highSecurityVaultKeyEncPubKey, highSecuritySeed);
      const encryptedStorableProfileSeed = asymEncrypt(authenticator.storableVaultKeyEncPubKey, storableSeed);
      return new ProfileAuthenticatorLock(authenticatorId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed);
    }
    static load({ authenticatorId, encryptedHighSecurityProfileSeed: encryptedHighSecurityProfileKeyData, encryptedStorableProfileSeed: encryptedStorableProfileKeyData }) {
      const encryptedHighSecurityProfileKey = loadAsymEncryptedSymmetricKey(encryptedHighSecurityProfileKeyData);
      const encryptedStorableProfileKey = loadAsymEncryptedSymmetricKey(encryptedStorableProfileKeyData);
      return new ProfileAuthenticatorLock(authenticatorId, encryptedHighSecurityProfileKey, encryptedStorableProfileKey);
    }
  }
  class UnsyncedProfile {
    constructor(profileType, organizationId, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, highSecurityProfileSeedEncPubKey, highSecurityProfileSeedEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, storableProfileSeedEncPubKey, storableProfileSeedEncPubKeySignature, authenticatorLocks, upstreamProfileLocks, highSecuritySeed, storableSeed) {
      this.profileType = profileType;
      this.organizationId = organizationId;
      this.highSecurityIdentitySigPubKey = highSecurityIdentitySigPubKey;
      this.highSecurityIdentitySigPrivKey = highSecurityIdentitySigPrivKey;
      this.highSecurityVaultKeyEncPubKey = highSecurityVaultKeyEncPubKey;
      this.highSecurityVaultKeyEncPubKeySignature = highSecurityVaultKeyEncPubKeySignature;
      this.highSecurityProfileSeedEncPubKey = highSecurityProfileSeedEncPubKey;
      this.highSecurityProfileSeedEncPubKeySignature = highSecurityProfileSeedEncPubKeySignature;
      this.storableSigPubKey = storableSigPubKey;
      this.storableSigPubKeySignature = storableSigPubKeySignature;
      this.storableVaultKeyEncPubKey = storableVaultKeyEncPubKey;
      this.storableVaultKeyEncPubKeySignature = storableVaultKeyEncPubKeySignature;
      this.storableProfileSeedEncPubKey = storableProfileSeedEncPubKey;
      this.storableProfileSeedEncPubKeySignature = storableProfileSeedEncPubKeySignature;
      this.authenticatorLocks = authenticatorLocks;
      this.upstreamProfileLocks = upstreamProfileLocks;
      this.highSecuritySeed = highSecuritySeed;
      this.storableSeed = storableSeed;
    }
    static getStorableSeedFromHighSecuritySeed(highSecuritySeed) {
      return deriveSecretFromSeed(highSecuritySeed, null, SALT_PROFILE_STORABLE_SEED);
    }
    static getHighSecurityIdentitySigPrivKey(highSecuritySeed) {
      return deriveSigningKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY).sigPrivKey;
    }
    static create(profileType, organizationId, authenticators) {
      return UnsyncedProfile.createWithSeed(profileType, organizationId, authenticators, []).unsyncedProfile;
    }
    static createWithSeed(profileType, organizationId, lockingAuthenticators, lockingProfiles) {
      if (profileType === ProfileType.ORGANIZATION_ADMIN && lockingProfiles.length === 0) {
        throw new Error("org admin profile must have lockingProfiles");
      }
      if (profileType === ProfileType.ORGANIZATION_ADMIN && lockingAuthenticators.length !== 0) {
        throw new Error("org admin profile must not have lockingAuthenticators");
      }
      const highSecuritySeed = randomSeed();
      const storableSeed = UnsyncedProfile.getStorableSeedFromHighSecuritySeed(highSecuritySeed);
      const { sigPubKey: storableSigPubKey } = deriveSigningKeyPair(storableSeed, null, SALT_PROFILE_STORABLE_SIGNING_KEY);
      const { encPubKey: storableVaultKeyEncPubKey } = deriveEncryptionKeyPair(storableSeed, null, SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY);
      const { encPubKey: storableProfileSeedEncPubKey } = deriveEncryptionKeyPair(storableSeed, null, SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY);
      const { sigPubKey: highSecurityIdentitySigPubKey, sigPrivKey: highSecurityIdentitySigPrivKey } = deriveSigningKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY);
      const { encPubKey: highSecurityVaultKeyEncPubKey } = deriveEncryptionKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY);
      const { encPubKey: highSecurityProfileSeedEncPubKey } = deriveEncryptionKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY);
      const highSecurityVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
      const highSecurityProfileSeedEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, highSecurityProfileSeedEncPubKey, SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, storableVaultKeyEncPubKey, SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableProfileSeedEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, storableProfileSeedEncPubKey, SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableSigPubKeySignature = signSigningPublicKey(highSecurityIdentitySigPrivKey, storableSigPubKey, SALT_PROFILE_STORABLE_SIGNING_KEY_SIGNATURE);
      const authenticatorLocks = lockingAuthenticators.map((a) => ProfileAuthenticatorLock.create(a, highSecuritySeed, storableSeed));
      const profileLocks = lockingProfiles.map((p2) => ProfileProfileLock.create(p2, highSecuritySeed, storableSeed));
      const unsyncedProfile = new UnsyncedProfile(profileType, organizationId, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, highSecurityProfileSeedEncPubKey, highSecurityProfileSeedEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, storableProfileSeedEncPubKey, storableProfileSeedEncPubKeySignature, authenticatorLocks, profileLocks, highSecuritySeed, storableSeed);
      return { unsyncedProfile, highSecuritySeed, storableSeed };
    }
    intoUnlockedProfile(id2, keyGenerationId, email) {
      const profile = {
        id: id2,
        keyGenerationId,
        email,
        unverifiedEmail: null,
        profileType: this.profileType,
        organizationId: this.organizationId,
        highSecurityIdentitySigPubKey: this.highSecurityIdentitySigPubKey,
        highSecurityVaultKeyEncPubKey: this.highSecurityVaultKeyEncPubKey,
        highSecurityVaultKeyEncPubKeySignature: this.highSecurityVaultKeyEncPubKeySignature,
        highSecurityProfileSeedEncPubKey: this.highSecurityProfileSeedEncPubKey,
        highSecurityProfileSeedEncPubKeySignature: this.highSecurityProfileSeedEncPubKeySignature,
        storableSigPubKey: this.storableSigPubKey,
        storableSigPubKeySignature: this.storableSigPubKeySignature,
        storableVaultKeyEncPubKey: this.storableVaultKeyEncPubKey,
        storableVaultKeyEncPubKeySignature: this.storableVaultKeyEncPubKeySignature,
        storableProfileSeedEncPubKey: this.storableProfileSeedEncPubKey,
        storableProfileSeedEncPubKeySignature: this.storableProfileSeedEncPubKeySignature,
        authenticatorLocks: this.authenticatorLocks,
        profileLock: null
      };
      return new UnlockedProfile(profile, this.storableSeed);
    }
    createExtraLock(unsyncedAuthenticator) {
      return ProfileAuthenticatorLock.create(unsyncedAuthenticator, this.highSecuritySeed, this.storableSeed);
    }
    serialize(id2 = nullUuid, keyGenerationId = nullUuid) {
      return Object.assign(Object.assign({}, this), { id: id2, keyGenerationId });
    }
  }
  class ProfileProfileLock {
    constructor(lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed) {
      this.lockingProfileId = lockingProfileId;
      this.lockingProfileKeyGenerationId = lockingProfileKeyGenerationId;
      this.encryptedHighSecurityProfileSeed = encryptedHighSecurityProfileSeed;
      this.encryptedStorableProfileSeed = encryptedStorableProfileSeed;
    }
    static create(lockingProfile, highSecuritySeed, storableSeed) {
      const lockingProfileId = lockingProfile instanceof UnsyncedProfile ? nullUuid : lockingProfile.id;
      const lockingProfileKeyGenerationId = lockingProfile instanceof UnsyncedProfile ? nullUuid : lockingProfile.keyGenerationId;
      const encryptedHighSecurityProfileSeed = asymEncrypt(lockingProfile.highSecurityProfileSeedEncPubKey, highSecuritySeed);
      const encryptedStorableProfileSeed = asymEncrypt(lockingProfile.storableProfileSeedEncPubKey, storableSeed);
      return new ProfileProfileLock(lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed);
    }
    static load({ lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileSeed: encryptedHighSecurityProfileKeyData, encryptedStorableProfileSeed: encryptedStorableProfileKeyData }) {
      const encryptedHighSecurityProfileKey = loadAsymEncryptedSymmetricKey(encryptedHighSecurityProfileKeyData);
      const encryptedStorableProfileKey = loadAsymEncryptedSymmetricKey(encryptedStorableProfileKeyData);
      return new ProfileProfileLock(lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileKey, encryptedStorableProfileKey);
    }
  }
  function loadProfile(dto) {
    const { id: id2, profileType, keyGenerationId, organizationId, email, unverifiedEmail } = dto;
    const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
    const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
    const highSecurityVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
    const highSecurityProfileSeedEncPubKey = loadEncryptionPublicKey(dto.highSecurityProfileSeedEncPubKey);
    const highSecurityProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityProfileSeedEncPubKeySignature);
    const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
    const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
    const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
    const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
    const storableProfileSeedEncPubKey = loadEncryptionPublicKey(dto.storableProfileSeedEncPubKey);
    const storableProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableProfileSeedEncPubKeySignature);
    const authenticatorLocks = dto.authenticatorLocks.map(ProfileAuthenticatorLock.load);
    const profileLock = dto.profileLock ? ProfileProfileLock.load(dto.profileLock) : null;
    return {
      id: id2,
      profileType,
      keyGenerationId,
      email,
      unverifiedEmail,
      organizationId,
      highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature,
      highSecurityProfileSeedEncPubKey,
      highSecurityProfileSeedEncPubKeySignature,
      storableSigPubKey,
      storableSigPubKeySignature,
      storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature,
      storableProfileSeedEncPubKey,
      storableProfileSeedEncPubKeySignature,
      authenticatorLocks,
      profileLock
    };
  }
  class AccountState {
    constructor(state) {
      this.userId = state.userId;
      this.preferredLocale = state.preferredLocale;
      this.emails = state.emails;
      this.preliminaryEmail = state.preliminaryEmail;
      this.serverSideSettings = state.serverSideSettings;
      this.userClientSettings = state.userClientSettings;
      this.authenticators = state.authenticators;
      this.sessions = state.sessions;
      this.channels = state.channels;
      this.achievements = state.achievements;
      this.localAchievements = state.localAchievements;
      this.authenticatorBlockHash = state.authenticatorBlockHash;
      this.organizations = state.organizations;
      this.relatedProfiles = state.relatedProfiles;
      this.preliminaryProfiles = state.preliminaryProfiles;
      this.webauthnCredentials = state.webauthnCredentials;
      this.openUserConfirmationIds = state.openUserConfirmationIds;
    }
    static fromSyncUpdate(userId, update) {
      return new AccountState({
        userId,
        preferredLocale: null,
        emails: [],
        preliminaryEmail: null,
        serverSideSettings: {},
        userClientSettings: {},
        authenticators: [],
        sessions: [],
        channels: [],
        achievements: /* @__PURE__ */ new Set(),
        localAchievements: /* @__PURE__ */ new Set(),
        authenticatorBlockHash: null,
        organizations: [],
        relatedProfiles: {},
        preliminaryProfiles: [],
        webauthnCredentials: [],
        openUserConfirmationIds: []
      }).withSyncUpdate(update);
    }
    static fromPersistable(persistable) {
      var _a3, _b, _c2, _d, _e, _f;
      const authenticators = persistable.authenticators.map((a) => loadAuthenticator(a));
      const achievements = persistable.achievements ? new Set(persistable.achievements) : /* @__PURE__ */ new Set();
      const localAchievements = persistable.localAchievements ? new Set(persistable.localAchievements) : /* @__PURE__ */ new Set();
      const serverSideSettings = (_a3 = persistable.serverSideSettings) !== null && _a3 !== void 0 ? _a3 : {};
      const userClientSettings = (_b = persistable.userClientSettings) !== null && _b !== void 0 ? _b : {};
      const organizations = (_c2 = persistable.organizations) !== null && _c2 !== void 0 ? _c2 : [];
      const relatedProfiles = (_d = persistable.relatedProfiles) !== null && _d !== void 0 ? _d : {};
      const preliminaryEmail = null;
      const preliminaryProfiles = [];
      let emails;
      if (persistable.emails) {
        emails = persistable.emails;
      } else {
        emails = [];
        if (persistable.email) {
          emails.push({
            email: persistable.email,
            verificationPending: false,
            primary: true
          });
        }
        if (persistable.unverifiedEmail) {
          emails.push({
            email: persistable.unverifiedEmail,
            verificationPending: true,
            primary: false
          });
        }
      }
      for (const s2 of persistable.sessions) {
        if (s2.enabledProfileIds.length === 0 && !s2.clientSettings.enableAllProfiles) {
          s2.enabledProfileIds = Object.entries(s2.clientSettings.profileSettings).flatMap(([k2, v2]) => {
            return v2.enabled ? k2 : [];
          });
        }
      }
      return new AccountState({
        userId: persistable.userId,
        preferredLocale: (_e = persistable.preferredLocale) !== null && _e !== void 0 ? _e : null,
        emails,
        preliminaryEmail,
        serverSideSettings,
        userClientSettings,
        authenticators,
        sessions: persistable.sessions,
        channels: [],
        achievements,
        localAchievements,
        authenticatorBlockHash: (_f = persistable.authenticatorBlockHash) !== null && _f !== void 0 ? _f : null,
        organizations,
        relatedProfiles,
        preliminaryProfiles,
        webauthnCredentials: persistable.webauthnCredentials,
        openUserConfirmationIds: []
      });
    }
    getPersistable() {
      var _a3;
      const sessions = this.sessions.map((s2) => Object.assign(Object.assign({}, s2), { unlockRequestedAt: void 0 }));
      return {
        userId: this.userId,
        preferredLocale: this.preferredLocale,
        serverSideSettings: this.serverSideSettings,
        userClientSettings: this.userClientSettings,
        authenticators: this.authenticators,
        sessions,
        achievements: [...this.achievements],
        localAchievements: [...this.localAchievements],
        authenticatorBlockHash: (_a3 = this.authenticatorBlockHash) !== null && _a3 !== void 0 ? _a3 : void 0,
        organizations: this.organizations,
        relatedProfiles: this.relatedProfiles,
        webauthnCredentials: this.webauthnCredentials,
        emails: [...this.emails]
      };
    }
    hasLocalAchievements() {
      return this.localAchievements.size > 0;
    }
    getLocalAchievements() {
      return [...this.localAchievements];
    }
    hasAchievement(a) {
      return this.achievements.has(a) || this.localAchievements.has(a);
    }
    withLocalAchievements(achievements) {
      const localAchievements = new Set(this.localAchievements);
      for (const a of achievements) {
        if (!this.achievements.has(a)) {
          localAchievements.add(a);
        }
      }
      return new AccountState(Object.assign(Object.assign({}, this), { localAchievements }));
    }
    getProfileEmail(profileId) {
      var _a3, _b;
      return (_b = (_a3 = this.relatedProfiles[profileId]) === null || _a3 === void 0 ? void 0 : _a3.email) !== null && _b !== void 0 ? _b : null;
    }
    getPrimaryEmail() {
      var _a3, _b, _c2, _d;
      return (_d = (_b = (_a3 = this.emails.find((e2) => e2.primary)) === null || _a3 === void 0 ? void 0 : _a3.email) !== null && _b !== void 0 ? _b : (_c2 = this.emails[0]) === null || _c2 === void 0 ? void 0 : _c2.email) !== null && _d !== void 0 ? _d : null;
    }
    getUnverifiedEmail() {
      var _a3, _b;
      return (_b = (_a3 = this.emails.find((e2) => e2.verificationPending)) === null || _a3 === void 0 ? void 0 : _a3.email) !== null && _b !== void 0 ? _b : null;
    }
    getOrganization(orgId) {
      return this.organizations.find((o2) => o2.id === orgId);
    }
    isWebauthnPossibleForSession(sessionId) {
      return this.webauthnCredentials.some((c2) => !c2.sessionId || c2.sessionId === sessionId) || this.authenticators.some((auth) => isActiveWebauthnAuthenticator(auth) && this.webauthnCredentials.some((wc2) => wc2.webauthnId === auth.webauthn.webauthnId));
    }
    hasPushAuthenticator() {
      return this.authenticators.some((a) => a.authenticatorType === AuthenticatorType.PUSH);
    }
    getPrimaryLoginDevice() {
      if (this.authenticators.some((a) => a.authenticatorType === AuthenticatorType.PUSH || a.authenticatorType === AuthenticatorType.DUMMY)) {
        return PrimaryLoginDevice.PHONE;
      }
      if (this.authenticators.some((a) => a.authenticatorType === AuthenticatorType.SESSION_UNLOCK)) {
        return PrimaryLoginDevice.SECURITY_KEY;
      }
      if (this.authenticators.some((a) => a.authenticatorType === AuthenticatorType.ORGANIZATION_SERVICE)) {
        return PrimaryLoginDevice.SERVICE;
      }
      return PrimaryLoginDevice.NONE;
    }
    withSyncUpdate(update) {
      let { sessions, channels, achievements, localAchievements, emails, preliminaryEmail, preferredLocale, serverSideSettings, userClientSettings, organizations, relatedProfiles, preliminaryProfiles, webauthnCredentials, openUserConfirmationIds } = this;
      if (update.user !== void 0) {
        emails = update.user.emails;
        preliminaryEmail = update.user.preliminaryEmail;
        preferredLocale = update.user.preferredLocale;
        serverSideSettings = parseFromJsonIgnoringError(ServerSideSettings, update.user.serverSideSettings, {});
        userClientSettings = parseFromJsonIgnoringError(UserClientSettings, update.user.userClientSettings, {});
        webauthnCredentials = update.user.webauthnCredentials;
        openUserConfirmationIds = update.user.openUserConfirmationIds;
      }
      if (update.sessions !== void 0) {
        sessions = update.sessions.map((sus) => {
          const clientSettings = parseFromJsonIgnoringError(SessionClientSettings, sus.clientSettings, {
            enableAllProfiles: true,
            profileSettings: {}
          });
          return Object.assign(Object.assign({}, sus), { clientSettings });
        });
      }
      if (update.channels !== void 0) {
        channels = update.channels;
      }
      if (update.achievementIds !== void 0) {
        achievements = new Set(update.achievementIds);
        localAchievements = new Set(localAchievements);
        for (const a of localAchievements) {
          if (achievements.has(a)) {
            localAchievements.delete(a);
          }
        }
      }
      if (update.organizations !== void 0) {
        organizations = update.organizations.flatMap((o2) => {
          var _a3;
          try {
            const persistableOrganization = Object.assign(Object.assign({}, o2), { adminInfo: o2.adminInfo ? Object.assign(Object.assign({}, o2.adminInfo), { authenticator: o2.adminInfo.authenticator ? loadAuthenticator(o2.adminInfo.authenticator) : o2.adminInfo.authenticator, adminProfile: o2.adminInfo.adminProfile ? loadProfile(o2.adminInfo.adminProfile) : o2.adminInfo.adminProfile, legacyAdminVaultId: (_a3 = o2.adminInfo.legacyAdminVaultId) !== null && _a3 !== void 0 ? _a3 : null }) : o2.adminInfo, clientSettings: parseFromJsonIgnoringError(OrganizationClientSettings, o2.clientSettings, null), parentOrganizationInfo: o2.parentOrganizationInfo ? Object.assign(Object.assign({}, o2.parentOrganizationInfo), { metadata: parseFromJsonIgnoringError(ParentOrganizationMetadata, o2.parentOrganizationInfo.metadata, void 0) }) : void 0, passwordPolicy: parseFromJsonIgnoringError(PasswordPolicy, o2.passwordPolicy, void 0) });
            return PersistableOrganization.parse(persistableOrganization);
          } catch (e2) {
            trackError(e2);
            return [];
          }
        });
      }
      if (update.relatedProfiles !== void 0) {
        relatedProfiles = {};
        for (const p2 of update.relatedProfiles) {
          relatedProfiles[p2.id] = p2;
        }
      }
      if (update.preliminaryProfiles !== void 0) {
        preliminaryProfiles = update.preliminaryProfiles;
      }
      return new AccountState(Object.assign(Object.assign({}, this), {
        preferredLocale,
        emails,
        preliminaryEmail,
        serverSideSettings,
        userClientSettings,
        sessions,
        channels,
        achievements,
        localAchievements,
        organizations,
        relatedProfiles,
        preliminaryProfiles,
        webauthnCredentials,
        openUserConfirmationIds
      }));
    }
    withAuthenticatorList(list) {
      const authenticators = list.authenticators.map(loadAuthenticator);
      if (!authenticators.every((a) => verifyAuthenticator(a))) {
        trackError(new Error(`an authenticator key had no proper signature`));
      }
      const blocks = list.blocks.map((ab2) => AuthenticatorBlock.parse(ab2.blob, ab2.signature));
      if (!blocks.length) {
        if (this.authenticatorBlockHash) {
          trackError(new Error("missing authenticator block"));
        }
        return new AccountState(Object.assign(Object.assign({}, this), { authenticators, authenticatorBlockHash: null }));
      }
      const latestBlock = blocks[blocks.length - 1];
      try {
        if (this.authenticatorBlockHash) {
          const [knownBlock, ...newBlocks] = blocks;
          if (!hashEqual(knownBlock.hash, this.authenticatorBlockHash)) {
            throw new Error("first authenticator block hash does not match");
          }
          if (!AuthenticatorBlock.verifyChainPart(knownBlock, newBlocks)) {
            throw new Error("invalid authenticator block detected");
          }
        } else if (!AuthenticatorBlock.verifyChain(blocks[0].hash, blocks)) {
          throw new Error("invalid init authenticator block detected");
        }
        if (authenticators.some((a) => latestBlock.keys.every((k2) => !signingPublicKeyEqual(k2, a.highSecurityIdentitySigPubKey)))) {
          throw new Error("authenticator is not in the authenticator block");
        }
      } catch (e2) {
        trackError(e2);
      }
      return new AccountState(Object.assign(Object.assign({}, this), { authenticators, authenticatorBlockHash: latestBlock.hash }));
    }
  }
  function parseFromJsonIgnoringError(type, inputJson, fallback2) {
    if (inputJson === void 0 || inputJson === null) {
      return fallback2;
    }
    try {
      const input = jsonParseThaw(inputJson);
      const parsed = type.safeParse(input);
      if (parsed.success) {
        return parsed.data;
      }
    } catch (e2) {
      trackError(e2);
      return fallback2;
    }
  }
  var __awaiter$U = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class Semaphore {
    constructor(_value) {
      this._value = _value;
      this._queue = [];
      if (_value <= 0) {
        throw new Error("semaphore must be initialized to a positive value");
      }
    }
    acquire() {
      const locked = this.isLocked();
      const ticket = new Promise((r2) => this._queue.push(r2));
      if (!locked)
        this._dispatch();
      return ticket;
    }
    runExclusive(callback) {
      return __awaiter$U(this, void 0, void 0, function* () {
        const [value, release] = yield this.acquire();
        try {
          return yield callback(value);
        } finally {
          release();
        }
      });
    }
    isLocked() {
      return this._value <= 0;
    }
    release() {
      if (this._currentReleaser) {
        this._currentReleaser();
        this._currentReleaser = void 0;
      }
    }
    _dispatch() {
      const nextConsumer = this._queue.shift();
      if (!nextConsumer)
        return;
      let released = false;
      this._currentReleaser = () => {
        if (released)
          return;
        released = true;
        this._value++;
        this._dispatch();
      };
      nextConsumer([this._value--, this._currentReleaser]);
    }
  }
  var __awaiter$1$1 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class Mutex {
    constructor() {
      this._semaphore = new Semaphore(1);
    }
    acquire() {
      return __awaiter$1$1(this, void 0, void 0, function* () {
        const [, releaser] = yield this._semaphore.acquire();
        return releaser;
      });
    }
    runExclusive(callback) {
      return this._semaphore.runExclusive(() => callback());
    }
    isLocked() {
      return this._semaphore.isLocked();
    }
    release() {
      this._semaphore.release();
    }
  }
  var toStr$b = Object.prototype.toString;
  var isArguments$5 = function isArguments2(value) {
    var str = toStr$b.call(value);
    var isArgs2 = str === "[object Arguments]";
    if (!isArgs2) {
      isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$b.call(value.callee) === "[object Function]";
    }
    return isArgs2;
  };
  var implementation$e;
  var hasRequiredImplementation;
  function requireImplementation() {
    if (hasRequiredImplementation)
      return implementation$e;
    hasRequiredImplementation = 1;
    var keysShim2;
    if (!Object.keys) {
      var has2 = Object.prototype.hasOwnProperty;
      var toStr2 = Object.prototype.toString;
      var isArgs2 = isArguments$5;
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      var hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      var dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      var equalsConstructorPrototype = function(o2) {
        var ctor = o2.constructor;
        return ctor && ctor.prototype === o2;
      };
      var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      var hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k2 in window) {
          try {
            if (!excludedKeys["$" + k2] && has2.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
              try {
                equalsConstructorPrototype(window[k2]);
              } catch (e2) {
                return true;
              }
            }
          } catch (e2) {
            return true;
          }
        }
        return false;
      }();
      var equalsConstructorPrototypeIfNotBuggy = function(o2) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o2);
        }
        try {
          return equalsConstructorPrototype(o2);
        } catch (e2) {
          return false;
        }
      };
      keysShim2 = function keys2(object) {
        var isObject2 = object !== null && typeof object === "object";
        var isFunction2 = toStr2.call(object) === "[object Function]";
        var isArguments2 = isArgs2(object);
        var isString2 = isObject2 && toStr2.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject2 && !isFunction2 && !isArguments2) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction2;
        if (isString2 && object.length > 0 && !has2.call(object, 0)) {
          for (var i2 = 0; i2 < object.length; ++i2) {
            theKeys.push(String(i2));
          }
        }
        if (isArguments2 && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has2.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k2 = 0; k2 < dontEnums.length; ++k2) {
            if (!(skipConstructor && dontEnums[k2] === "constructor") && has2.call(object, dontEnums[k2])) {
              theKeys.push(dontEnums[k2]);
            }
          }
        }
        return theKeys;
      };
    }
    implementation$e = keysShim2;
    return implementation$e;
  }
  var slice$1 = Array.prototype.slice;
  var isArgs = isArguments$5;
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys2(o2) {
    return origKeys(o2);
  } : requireImplementation();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys2(object) {
          if (isArgs(object)) {
            return originalKeys(slice$1.call(object));
          }
          return originalKeys(object);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  var objectKeys$1 = keysShim;
  var hasToStringTag$6 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var toStr$a = Object.prototype.toString;
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag$6 && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return toStr$a.call(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$a.call(value) !== "[object Array]" && toStr$a.call(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  var isArguments$4 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  var keys$2 = objectKeys$1;
  var hasSymbols$8 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr$9 = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var origDefineProperty = Object.defineProperty;
  var isFunction$2 = function(fn) {
    return typeof fn === "function" && toStr$9.call(fn) === "[object Function]";
  };
  var arePropertyDescriptorsSupported = function() {
    var obj = {};
    try {
      origDefineProperty(obj, "x", { enumerable: false, value: obj });
      for (var _2 in obj) {
        return false;
      }
      return obj.x === obj;
    } catch (e2) {
      return false;
    }
  };
  var supportsDescriptors$2 = origDefineProperty && arePropertyDescriptorsSupported();
  var defineProperty$3 = function(object, name, value, predicate) {
    if (name in object && (!isFunction$2(predicate) || !predicate())) {
      return;
    }
    if (supportsDescriptors$2) {
      origDefineProperty(object, name, {
        configurable: true,
        enumerable: false,
        value,
        writable: true
      });
    } else {
      object[name] = value;
    }
  };
  var defineProperties$1 = function(object, map2) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys$2(map2);
    if (hasSymbols$8) {
      props = concat.call(props, Object.getOwnPropertySymbols(map2));
    }
    for (var i2 = 0; i2 < props.length; i2 += 1) {
      defineProperty$3(object, props[i2], map2[props[i2]], predicates[props[i2]]);
    }
  };
  defineProperties$1.supportsDescriptors = !!supportsDescriptors$2;
  var defineProperties_1 = defineProperties$1;
  var callBind$8 = { exports: {} };
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr$8 = Object.prototype.toString;
  var funcType = "[object Function]";
  var implementation$d = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr$8.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);
    var bound2;
    var binder = function() {
      if (this instanceof bound2) {
        var result2 = target.apply(
          this,
          args.concat(slice.call(arguments))
        );
        if (Object(result2) === result2) {
          return result2;
        }
        return this;
      } else {
        return target.apply(
          that,
          args.concat(slice.call(arguments))
        );
      }
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs.push("$" + i2);
    }
    bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound2.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound2;
  };
  var implementation$c = implementation$d;
  var functionBind = Function.prototype.bind || implementation$c;
  var shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  var origSymbol = commonjsGlobal.Symbol;
  var hasSymbolSham = shams;
  var hasSymbols$7 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  var undefined$2;
  var $TypeError$8 = TypeError;
  var $gOPD$2 = Object.getOwnPropertyDescriptor;
  if ($gOPD$2) {
    try {
      $gOPD$2({}, "");
    } catch (e2) {
      $gOPD$2 = null;
    }
  }
  var throwTypeError$1 = function() {
    throw new $TypeError$8();
  };
  var ThrowTypeError$1 = $gOPD$2 ? function() {
    try {
      arguments.callee;
      return throwTypeError$1;
    } catch (calleeThrows) {
      try {
        return $gOPD$2(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError$1;
      }
    }
  }() : throwTypeError$1;
  var hasSymbols$6 = hasSymbols$7();
  var getProto$2 = Object.getPrototypeOf || function(x2) {
    return x2.__proto__;
  };
  var generatorFunction = undefined$2;
  var asyncFunction = undefined$2;
  var asyncGenFunction$1 = undefined$2;
  var TypedArray$1 = typeof Uint8Array === "undefined" ? undefined$2 : getProto$2(Uint8Array);
  var INTRINSICS$1 = {
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$2 : ArrayBuffer,
    "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$2 : ArrayBuffer.prototype,
    "%ArrayIteratorPrototype%": hasSymbols$6 ? getProto$2([][Symbol.iterator]()) : undefined$2,
    "%ArrayPrototype%": Array.prototype,
    "%ArrayProto_entries%": Array.prototype.entries,
    "%ArrayProto_forEach%": Array.prototype.forEach,
    "%ArrayProto_keys%": Array.prototype.keys,
    "%ArrayProto_values%": Array.prototype.values,
    "%AsyncFromSyncIteratorPrototype%": undefined$2,
    "%AsyncFunction%": asyncFunction,
    "%AsyncFunctionPrototype%": undefined$2,
    "%AsyncGenerator%": undefined$2,
    "%AsyncGeneratorFunction%": asyncGenFunction$1,
    "%AsyncGeneratorPrototype%": undefined$2,
    "%AsyncIteratorPrototype%": undefined$2,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$2 : Atomics,
    "%Boolean%": Boolean,
    "%BooleanPrototype%": Boolean.prototype,
    "%DataView%": typeof DataView === "undefined" ? undefined$2 : DataView,
    "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$2 : DataView.prototype,
    "%Date%": Date,
    "%DatePrototype%": Date.prototype,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%ErrorPrototype%": Error.prototype,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%EvalErrorPrototype%": EvalError.prototype,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$2 : Float32Array,
    "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$2 : Float32Array.prototype,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$2 : Float64Array,
    "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$2 : Float64Array.prototype,
    "%Function%": Function,
    "%FunctionPrototype%": Function.prototype,
    "%Generator%": undefined$2,
    "%GeneratorFunction%": generatorFunction,
    "%GeneratorPrototype%": undefined$2,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$2 : Int8Array,
    "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$2 : Int8Array.prototype,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$2 : Int16Array,
    "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$2 : Int8Array.prototype,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$2 : Int32Array,
    "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$2 : Int32Array.prototype,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols$6 ? getProto$2(getProto$2([][Symbol.iterator]())) : undefined$2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$2,
    "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$2,
    "%Map%": typeof Map === "undefined" ? undefined$2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$6 ? undefined$2 : getProto$2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%MapPrototype%": typeof Map === "undefined" ? undefined$2 : Map.prototype,
    "%Math%": Math,
    "%Number%": Number,
    "%NumberPrototype%": Number.prototype,
    "%Object%": Object,
    "%ObjectPrototype%": Object.prototype,
    "%ObjProto_toString%": Object.prototype.toString,
    "%ObjProto_valueOf%": Object.prototype.valueOf,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$2 : Promise,
    "%PromisePrototype%": typeof Promise === "undefined" ? undefined$2 : Promise.prototype,
    "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$2 : Promise.prototype.then,
    "%Promise_all%": typeof Promise === "undefined" ? undefined$2 : Promise.all,
    "%Promise_reject%": typeof Promise === "undefined" ? undefined$2 : Promise.reject,
    "%Promise_resolve%": typeof Promise === "undefined" ? undefined$2 : Promise.resolve,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$2 : Proxy,
    "%RangeError%": RangeError,
    "%RangeErrorPrototype%": RangeError.prototype,
    "%ReferenceError%": ReferenceError,
    "%ReferenceErrorPrototype%": ReferenceError.prototype,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$2 : Reflect,
    "%RegExp%": RegExp,
    "%RegExpPrototype%": RegExp.prototype,
    "%Set%": typeof Set === "undefined" ? undefined$2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$6 ? undefined$2 : getProto$2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SetPrototype%": typeof Set === "undefined" ? undefined$2 : Set.prototype,
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$2 : SharedArrayBuffer,
    "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$2 : SharedArrayBuffer.prototype,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols$6 ? getProto$2(""[Symbol.iterator]()) : undefined$2,
    "%StringPrototype%": String.prototype,
    "%Symbol%": hasSymbols$6 ? Symbol : undefined$2,
    "%SymbolPrototype%": hasSymbols$6 ? Symbol.prototype : undefined$2,
    "%SyntaxError%": SyntaxError,
    "%SyntaxErrorPrototype%": SyntaxError.prototype,
    "%ThrowTypeError%": ThrowTypeError$1,
    "%TypedArray%": TypedArray$1,
    "%TypedArrayPrototype%": TypedArray$1 ? TypedArray$1.prototype : undefined$2,
    "%TypeError%": $TypeError$8,
    "%TypeErrorPrototype%": $TypeError$8.prototype,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$2 : Uint8Array,
    "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$2 : Uint8Array.prototype,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$2 : Uint8ClampedArray,
    "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$2 : Uint8ClampedArray.prototype,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$2 : Uint16Array,
    "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$2 : Uint16Array.prototype,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$2 : Uint32Array,
    "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$2 : Uint32Array.prototype,
    "%URIError%": URIError,
    "%URIErrorPrototype%": URIError.prototype,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$2 : WeakMap,
    "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$2 : WeakMap.prototype,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$2 : WeakSet,
    "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$2 : WeakSet.prototype
  };
  var bind$3 = functionBind;
  var $replace$1 = bind$3.call(Function.call, String.prototype.replace);
  var rePropName$2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar$2 = /\\(\\)?/g;
  var stringToPath$3 = function stringToPath2(string) {
    var result2 = [];
    $replace$1(string, rePropName$2, function(match2, number2, quote2, subString) {
      result2[result2.length] = quote2 ? $replace$1(subString, reEscapeChar$2, "$1") : number2 || match2;
    });
    return result2;
  };
  var getBaseIntrinsic$1 = function getBaseIntrinsic2(name, allowMissing) {
    if (!(name in INTRINSICS$1)) {
      throw new SyntaxError("intrinsic " + name + " does not exist!");
    }
    if (typeof INTRINSICS$1[name] === "undefined" && !allowMissing) {
      throw new $TypeError$8("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return INTRINSICS$1[name];
  };
  var GetIntrinsic$d = function GetIntrinsic2(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new TypeError('"allowMissing" argument must be a boolean');
    }
    var parts = stringToPath$3(name);
    var value = getBaseIntrinsic$1("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
    for (var i2 = 1; i2 < parts.length; i2 += 1) {
      if (value != null) {
        if ($gOPD$2 && i2 + 1 >= parts.length) {
          var desc = $gOPD$2(value, parts[i2]);
          if (!allowMissing && !(parts[i2] in value)) {
            throw new $TypeError$8("base intrinsic for " + name + " exists, but the property is not available.");
          }
          value = desc && "get" in desc && !("originalValue" in desc.get) ? desc.get : value[parts[i2]];
        } else {
          value = value[parts[i2]];
        }
      }
    }
    return value;
  };
  (function(module2) {
    var bind2 = functionBind;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $apply = GetIntrinsic2("%Function.prototype.apply%");
    var $call = GetIntrinsic2("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind2() {
      return $reflectApply(bind2, $call, arguments);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  })(callBind$8);
  var callBindExports$1 = callBind$8.exports;
  var numberIsNaN = function(value) {
    return value !== value;
  };
  var implementation$b = function is2(a, b2) {
    if (a === 0 && b2 === 0) {
      return 1 / a === 1 / b2;
    }
    if (a === b2) {
      return true;
    }
    if (numberIsNaN(a) && numberIsNaN(b2)) {
      return true;
    }
    return false;
  };
  var implementation$a = implementation$b;
  var polyfill$6 = function getPolyfill2() {
    return typeof Object.is === "function" ? Object.is : implementation$a;
  };
  var getPolyfill$7 = polyfill$6;
  var define$5 = defineProperties_1;
  var shim$7 = function shimObjectIs() {
    var polyfill2 = getPolyfill$7();
    define$5(Object, { is: polyfill2 }, {
      is: function testObjectIs() {
        return Object.is !== polyfill2;
      }
    });
    return polyfill2;
  };
  var define$4 = defineProperties_1;
  var callBind$7 = callBindExports$1;
  var implementation$9 = implementation$b;
  var getPolyfill$6 = polyfill$6;
  var shim$6 = shim$7;
  var polyfill$5 = callBind$7(getPolyfill$6(), Object);
  define$4(polyfill$5, {
    getPolyfill: getPolyfill$6,
    implementation: implementation$9,
    shim: shim$6
  });
  var objectIs = polyfill$5;
  var hasSymbols$5 = hasSymbols$7();
  var hasToStringTag$5 = hasSymbols$5 && typeof Symbol.toStringTag === "symbol";
  var hasOwnProperty$b;
  var regexExec;
  var isRegexMarker;
  var badStringifier;
  if (hasToStringTag$5) {
    hasOwnProperty$b = Function.call.bind(Object.prototype.hasOwnProperty);
    regexExec = Function.call.bind(RegExp.prototype.exec);
    isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
  }
  var toStr$7 = Object.prototype.toString;
  var gOPD$2 = Object.getOwnPropertyDescriptor;
  var regexClass = "[object RegExp]";
  var isRegex$1 = hasToStringTag$5 ? function isRegex2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    var descriptor = gOPD$2(value, "lastIndex");
    var hasLastIndexDataProperty = descriptor && hasOwnProperty$b(descriptor, "value");
    if (!hasLastIndexDataProperty) {
      return false;
    }
    try {
      regexExec(value, badStringifier);
    } catch (e2) {
      return e2 === isRegexMarker;
    }
  } : function isRegex2(value) {
    if (!value || typeof value !== "object" && typeof value !== "function") {
      return false;
    }
    return toStr$7.call(value) === regexClass;
  };
  var $Object = Object;
  var $TypeError$7 = TypeError;
  var implementation$8 = function flags2() {
    if (this != null && this !== $Object(this)) {
      throw new $TypeError$7("RegExp.prototype.flags getter called on non-object");
    }
    var result2 = "";
    if (this.global) {
      result2 += "g";
    }
    if (this.ignoreCase) {
      result2 += "i";
    }
    if (this.multiline) {
      result2 += "m";
    }
    if (this.dotAll) {
      result2 += "s";
    }
    if (this.unicode) {
      result2 += "u";
    }
    if (this.sticky) {
      result2 += "y";
    }
    return result2;
  };
  var implementation$7 = implementation$8;
  var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
  var $gOPD$1 = Object.getOwnPropertyDescriptor;
  var $TypeError$6 = TypeError;
  var polyfill$4 = function getPolyfill2() {
    if (!supportsDescriptors$1) {
      throw new $TypeError$6("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    }
    if (/a/mig.flags === "gim") {
      var descriptor = $gOPD$1(RegExp.prototype, "flags");
      if (descriptor && typeof descriptor.get === "function" && typeof /a/.dotAll === "boolean") {
        return descriptor.get;
      }
    }
    return implementation$7;
  };
  var supportsDescriptors = defineProperties_1.supportsDescriptors;
  var getPolyfill$5 = polyfill$4;
  var gOPD$1 = Object.getOwnPropertyDescriptor;
  var defineProperty$2 = Object.defineProperty;
  var TypeErr = TypeError;
  var getProto$1 = Object.getPrototypeOf;
  var regex = /a/;
  var shim$5 = function shimFlags() {
    if (!supportsDescriptors || !getProto$1) {
      throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    }
    var polyfill2 = getPolyfill$5();
    var proto2 = getProto$1(regex);
    var descriptor = gOPD$1(proto2, "flags");
    if (!descriptor || descriptor.get !== polyfill2) {
      defineProperty$2(proto2, "flags", {
        configurable: true,
        enumerable: false,
        get: polyfill2
      });
    }
    return polyfill2;
  };
  var define$3 = defineProperties_1;
  var callBind$6 = callBindExports$1;
  var implementation$6 = implementation$8;
  var getPolyfill$4 = polyfill$4;
  var shim$4 = shim$5;
  var flagsBound = callBind$6(implementation$6);
  define$3(flagsBound, {
    getPolyfill: getPolyfill$4,
    implementation: implementation$6,
    shim: shim$4
  });
  var regexp_prototype_flags = flagsBound;
  var toString$2 = {}.toString;
  var isarray = Array.isArray || function(arr) {
    return toString$2.call(arr) == "[object Array]";
  };
  var getDay = Date.prototype.getDay;
  var tryDateObject = function tryDateGetDayCall(value) {
    try {
      getDay.call(value);
      return true;
    } catch (e2) {
      return false;
    }
  };
  var toStr$6 = Object.prototype.toString;
  var dateClass = "[object Date]";
  var hasToStringTag$4 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var isDateObject = function isDateObject2(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    return hasToStringTag$4 ? tryDateObject(value) : toStr$6.call(value) === dateClass;
  };
  var strValue = String.prototype.valueOf;
  var tryStringObject = function tryStringObject2(value) {
    try {
      strValue.call(value);
      return true;
    } catch (e2) {
      return false;
    }
  };
  var toStr$5 = Object.prototype.toString;
  var strClass = "[object String]";
  var hasToStringTag$3 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var isString$4 = function isString2(value) {
    if (typeof value === "string") {
      return true;
    }
    if (typeof value !== "object") {
      return false;
    }
    return hasToStringTag$3 ? tryStringObject(value) : toStr$5.call(value) === strClass;
  };
  var numToStr = Number.prototype.toString;
  var tryNumberObject = function tryNumberObject2(value) {
    try {
      numToStr.call(value);
      return true;
    } catch (e2) {
      return false;
    }
  };
  var toStr$4 = Object.prototype.toString;
  var numClass = "[object Number]";
  var hasToStringTag$2 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var isNumberObject = function isNumberObject2(value) {
    if (typeof value === "number") {
      return true;
    }
    if (typeof value !== "object") {
      return false;
    }
    return hasToStringTag$2 ? tryNumberObject(value) : toStr$4.call(value) === numClass;
  };
  var boolToStr = Boolean.prototype.toString;
  var tryBooleanObject = function booleanBrandCheck(value) {
    try {
      boolToStr.call(value);
      return true;
    } catch (e2) {
      return false;
    }
  };
  var toStr$3 = Object.prototype.toString;
  var boolClass = "[object Boolean]";
  var hasToStringTag$1 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var isBooleanObject = function isBoolean2(value) {
    if (typeof value === "boolean") {
      return true;
    }
    if (value === null || typeof value !== "object") {
      return false;
    }
    return hasToStringTag$1 && Symbol.toStringTag in value ? tryBooleanObject(value) : toStr$3.call(value) === boolClass;
  };
  var isSymbol$3 = { exports: {} };
  var toStr$2 = Object.prototype.toString;
  var hasSymbols$4 = hasSymbols$7();
  if (hasSymbols$4) {
    var symToStr = Symbol.prototype.toString;
    var symStringRegex = /^Symbol\(.*\)$/;
    var isSymbolObject = function isRealSymbolObject(value) {
      if (typeof value.valueOf() !== "symbol") {
        return false;
      }
      return symStringRegex.test(symToStr.call(value));
    };
    isSymbol$3.exports = function isSymbol2(value) {
      if (typeof value === "symbol") {
        return true;
      }
      if (toStr$2.call(value) !== "[object Symbol]") {
        return false;
      }
      try {
        return isSymbolObject(value);
      } catch (e2) {
        return false;
      }
    };
  } else {
    isSymbol$3.exports = function isSymbol2(value) {
      return false;
    };
  }
  var isSymbolExports = isSymbol$3.exports;
  var isBigint = { exports: {} };
  if (typeof BigInt === "function") {
    var bigIntValueOf$1 = BigInt.prototype.valueOf;
    var tryBigInt = function tryBigIntObject(value) {
      try {
        bigIntValueOf$1.call(value);
        return true;
      } catch (e2) {
      }
      return false;
    };
    isBigint.exports = function isBigInt2(value) {
      if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
        return false;
      }
      if (typeof value === "bigint") {
        return true;
      }
      return tryBigInt(value);
    };
  } else {
    isBigint.exports = function isBigInt2(value) {
      return false;
    };
  }
  var isBigintExports = isBigint.exports;
  var isString$3 = isString$4;
  var isNumber$1 = isNumberObject;
  var isBoolean$1 = isBooleanObject;
  var isSymbol$2 = isSymbolExports;
  var isBigInt$1 = isBigintExports;
  var whichBoxedPrimitive$1 = function whichBoxedPrimitive2(value) {
    if (value == null || typeof value !== "object" && typeof value !== "function") {
      return null;
    }
    if (isString$3(value)) {
      return "String";
    }
    if (isNumber$1(value)) {
      return "Number";
    }
    if (isBoolean$1(value)) {
      return "Boolean";
    }
    if (isSymbol$2(value)) {
      return "Symbol";
    }
    if (isBigInt$1(value)) {
      return "BigInt";
    }
  };
  var GetIntrinsic$c = GetIntrinsic$d;
  var callBind$5 = callBindExports$1;
  var $indexOf$1 = callBind$5(GetIntrinsic$c("String.prototype.indexOf"));
  var callBound$8 = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic$c(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf$1(name, ".prototype.")) {
      return callBind$5(intrinsic);
    }
    return intrinsic;
  };
  var $Map$3 = typeof Map === "function" && Map.prototype ? Map : null;
  var $Set$3 = typeof Set === "function" && Set.prototype ? Set : null;
  var exported$3;
  if (!$Map$3) {
    exported$3 = function isMap2(x2) {
      return false;
    };
  }
  var $mapHas$5 = $Map$3 ? Map.prototype.has : null;
  var $setHas$4 = $Set$3 ? Set.prototype.has : null;
  if (!exported$3 && !$mapHas$5) {
    exported$3 = function isMap2(x2) {
      return false;
    };
  }
  var isMap$5 = exported$3 || function isMap2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $mapHas$5.call(x2);
      if ($setHas$4) {
        try {
          $setHas$4.call(x2);
        } catch (e2) {
          return true;
        }
      }
      return x2 instanceof $Map$3;
    } catch (e2) {
    }
    return false;
  };
  var $Map$2 = typeof Map === "function" && Map.prototype ? Map : null;
  var $Set$2 = typeof Set === "function" && Set.prototype ? Set : null;
  var exported$2;
  if (!$Set$2) {
    exported$2 = function isSet2(x2) {
      return false;
    };
  }
  var $mapHas$4 = $Map$2 ? Map.prototype.has : null;
  var $setHas$3 = $Set$2 ? Set.prototype.has : null;
  if (!exported$2 && !$setHas$3) {
    exported$2 = function isSet2(x2) {
      return false;
    };
  }
  var isSet$5 = exported$2 || function isSet2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $setHas$3.call(x2);
      if ($mapHas$4) {
        try {
          $mapHas$4.call(x2);
        } catch (e2) {
          return true;
        }
      }
      return x2 instanceof $Set$2;
    } catch (e2) {
    }
    return false;
  };
  var $WeakMap$2 = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
  var $WeakSet$1 = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
  var exported$1;
  if (!$WeakMap$2) {
    exported$1 = function isWeakMap2(x2) {
      return false;
    };
  }
  var $mapHas$3 = $WeakMap$2 ? $WeakMap$2.prototype.has : null;
  var $setHas$2 = $WeakSet$1 ? $WeakSet$1.prototype.has : null;
  if (!exported$1 && !$mapHas$3) {
    exported$1 = function isWeakMap2(x2) {
      return false;
    };
  }
  var isWeakmap = exported$1 || function isWeakMap2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $mapHas$3.call(x2, $mapHas$3);
      if ($setHas$2) {
        try {
          $setHas$2.call(x2, $setHas$2);
        } catch (e2) {
          return true;
        }
      }
      return x2 instanceof $WeakMap$2;
    } catch (e2) {
    }
    return false;
  };
  var $WeakMap$1 = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
  var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
  var exported;
  if (!$WeakMap$1) {
    exported = function isWeakSet2(x2) {
      return false;
    };
  }
  var $mapHas$2 = $WeakMap$1 ? $WeakMap$1.prototype.has : null;
  var $setHas$1 = $WeakSet ? $WeakSet.prototype.has : null;
  if (!exported && !$setHas$1) {
    isWeakset = function isWeakSet2(x2) {
      return false;
    };
  }
  var isWeakset = exported || function isWeakSet2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $setHas$1.call(x2, $setHas$1);
      if ($mapHas$2) {
        try {
          $mapHas$2.call(x2, $mapHas$2);
        } catch (e2) {
          return true;
        }
      }
      return x2 instanceof $WeakSet;
    } catch (e2) {
    }
    return false;
  };
  var isMap$4 = isMap$5;
  var isSet$4 = isSet$5;
  var isWeakMap$1 = isWeakmap;
  var isWeakSet$1 = isWeakset;
  var whichCollection$1 = function whichCollection2(value) {
    if (value && typeof value === "object") {
      if (isMap$4(value)) {
        return "Map";
      }
      if (isSet$4(value)) {
        return "Set";
      }
      if (isWeakMap$1(value)) {
        return "WeakMap";
      }
      if (isWeakSet$1(value)) {
        return "WeakSet";
      }
    }
    return false;
  };
  var esGetIterator = { exports: {} };
  var GetIntrinsic$b;
  var hasRequiredGetIntrinsic$1;
  function requireGetIntrinsic$1() {
    if (hasRequiredGetIntrinsic$1)
      return GetIntrinsic$b;
    hasRequiredGetIntrinsic$1 = 1;
    var undefined$12;
    var $TypeError2 = TypeError;
    var $gOPD2 = Object.getOwnPropertyDescriptor;
    if ($gOPD2) {
      try {
        $gOPD2({}, "");
      } catch (e2) {
        $gOPD2 = null;
      }
    }
    var throwTypeError2 = function() {
      throw new $TypeError2();
    };
    var ThrowTypeError2 = $gOPD2 ? function() {
      try {
        arguments.callee;
        return throwTypeError2;
      } catch (calleeThrows) {
        try {
          return $gOPD2(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError2;
        }
      }
    }() : throwTypeError2;
    var hasSymbols2 = hasSymbols$7();
    var getProto2 = Object.getPrototypeOf || function(x2) {
      return x2.__proto__;
    };
    var generatorFunction2 = undefined$12;
    var asyncFunction2 = undefined$12;
    var asyncGenFunction2 = undefined$12;
    var TypedArray2 = typeof Uint8Array === "undefined" ? undefined$12 : getProto2(Uint8Array);
    var INTRINSICS2 = {
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer,
      "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer.prototype,
      "%ArrayIteratorPrototype%": hasSymbols2 ? getProto2([][Symbol.iterator]()) : undefined$12,
      "%ArrayPrototype%": Array.prototype,
      "%ArrayProto_entries%": Array.prototype.entries,
      "%ArrayProto_forEach%": Array.prototype.forEach,
      "%ArrayProto_keys%": Array.prototype.keys,
      "%ArrayProto_values%": Array.prototype.values,
      "%AsyncFromSyncIteratorPrototype%": undefined$12,
      "%AsyncFunction%": asyncFunction2,
      "%AsyncFunctionPrototype%": undefined$12,
      "%AsyncGenerator%": undefined$12,
      "%AsyncGeneratorFunction%": asyncGenFunction2,
      "%AsyncGeneratorPrototype%": undefined$12,
      "%AsyncIteratorPrototype%": undefined$12,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$12 : Atomics,
      "%Boolean%": Boolean,
      "%BooleanPrototype%": Boolean.prototype,
      "%DataView%": typeof DataView === "undefined" ? undefined$12 : DataView,
      "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$12 : DataView.prototype,
      "%Date%": Date,
      "%DatePrototype%": Date.prototype,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%ErrorPrototype%": Error.prototype,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%EvalErrorPrototype%": EvalError.prototype,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array,
      "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array.prototype,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array,
      "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array.prototype,
      "%Function%": Function,
      "%FunctionPrototype%": Function.prototype,
      "%Generator%": undefined$12,
      "%GeneratorFunction%": generatorFunction2,
      "%GeneratorPrototype%": undefined$12,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array,
      "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array.prototype,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$12 : Int16Array,
      "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$12 : Int8Array.prototype,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array,
      "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array.prototype,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$12,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$12,
      "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$12,
      "%Map%": typeof Map === "undefined" ? undefined$12 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$12 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%MapPrototype%": typeof Map === "undefined" ? undefined$12 : Map.prototype,
      "%Math%": Math,
      "%Number%": Number,
      "%NumberPrototype%": Number.prototype,
      "%Object%": Object,
      "%ObjectPrototype%": Object.prototype,
      "%ObjProto_toString%": Object.prototype.toString,
      "%ObjProto_valueOf%": Object.prototype.valueOf,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$12 : Promise,
      "%PromisePrototype%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype,
      "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype.then,
      "%Promise_all%": typeof Promise === "undefined" ? undefined$12 : Promise.all,
      "%Promise_reject%": typeof Promise === "undefined" ? undefined$12 : Promise.reject,
      "%Promise_resolve%": typeof Promise === "undefined" ? undefined$12 : Promise.resolve,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$12 : Proxy,
      "%RangeError%": RangeError,
      "%RangeErrorPrototype%": RangeError.prototype,
      "%ReferenceError%": ReferenceError,
      "%ReferenceErrorPrototype%": ReferenceError.prototype,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$12 : Reflect,
      "%RegExp%": RegExp,
      "%RegExpPrototype%": RegExp.prototype,
      "%Set%": typeof Set === "undefined" ? undefined$12 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$12 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SetPrototype%": typeof Set === "undefined" ? undefined$12 : Set.prototype,
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer,
      "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer.prototype,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols2 ? getProto2(""[Symbol.iterator]()) : undefined$12,
      "%StringPrototype%": String.prototype,
      "%Symbol%": hasSymbols2 ? Symbol : undefined$12,
      "%SymbolPrototype%": hasSymbols2 ? Symbol.prototype : undefined$12,
      "%SyntaxError%": SyntaxError,
      "%SyntaxErrorPrototype%": SyntaxError.prototype,
      "%ThrowTypeError%": ThrowTypeError2,
      "%TypedArray%": TypedArray2,
      "%TypedArrayPrototype%": TypedArray2 ? TypedArray2.prototype : undefined$12,
      "%TypeError%": $TypeError2,
      "%TypeErrorPrototype%": $TypeError2.prototype,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array,
      "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array.prototype,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray,
      "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray.prototype,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array,
      "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array.prototype,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array,
      "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array.prototype,
      "%URIError%": URIError,
      "%URIErrorPrototype%": URIError.prototype,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap,
      "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap.prototype,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet,
      "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet.prototype
    };
    var bind2 = functionBind;
    var $replace2 = bind2.call(Function.call, String.prototype.replace);
    var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = function stringToPath3(string) {
      var result2 = [];
      $replace2(string, rePropName2, function(match2, number2, quote2, subString) {
        result2[result2.length] = quote2 ? $replace2(subString, reEscapeChar2, "$1") : number2 || match2;
      });
      return result2;
    };
    var getBaseIntrinsic2 = function getBaseIntrinsic3(name, allowMissing) {
      if (!(name in INTRINSICS2)) {
        throw new SyntaxError("intrinsic " + name + " does not exist!");
      }
      if (typeof INTRINSICS2[name] === "undefined" && !allowMissing) {
        throw new $TypeError2("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return INTRINSICS2[name];
    };
    GetIntrinsic$b = function GetIntrinsic2(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath2(name);
      var value = getBaseIntrinsic2("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
      for (var i2 = 1; i2 < parts.length; i2 += 1) {
        if (value != null) {
          if ($gOPD2 && i2 + 1 >= parts.length) {
            var desc = $gOPD2(value, parts[i2]);
            if (!allowMissing && !(parts[i2] in value)) {
              throw new $TypeError2("base intrinsic for " + name + " exists, but the property is not available.");
            }
            value = desc ? desc.get || desc.value : value[parts[i2]];
          } else {
            value = value[parts[i2]];
          }
        }
      }
      return value;
    };
    return GetIntrinsic$b;
  }
  var callBind$4 = { exports: {} };
  var hasRequiredCallBind$1;
  function requireCallBind$1() {
    if (hasRequiredCallBind$1)
      return callBind$4.exports;
    hasRequiredCallBind$1 = 1;
    var bind2 = functionBind;
    var GetIntrinsic2 = requireGetIntrinsic$1();
    var $Function2 = GetIntrinsic2("%Function%");
    var $apply = $Function2.apply;
    var $call = $Function2.call;
    callBind$4.exports = function callBind2() {
      return bind2.apply($call, arguments);
    };
    callBind$4.exports.apply = function applyBind() {
      return bind2.apply($apply, arguments);
    };
    return callBind$4.exports;
  }
  var callBound$7;
  var hasRequiredCallBound$1;
  function requireCallBound$1() {
    if (hasRequiredCallBound$1)
      return callBound$7;
    hasRequiredCallBound$1 = 1;
    var GetIntrinsic2 = requireGetIntrinsic$1();
    var callBind2 = requireCallBind$1();
    var $indexOf2 = callBind2(GetIntrinsic2("String.prototype.indexOf"));
    callBound$7 = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic2(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf2(name, ".prototype.")) {
        return callBind2(intrinsic);
      }
      return intrinsic;
    };
    return callBound$7;
  }
  var isArguments$3 = isArguments$4;
  if (hasSymbols$7() || shams()) {
    var $iterator = Symbol.iterator;
    esGetIterator.exports = function getIterator2(iterable) {
      if (iterable != null && typeof iterable[$iterator] !== "undefined") {
        return iterable[$iterator]();
      }
      if (isArguments$3(iterable)) {
        return Array.prototype[$iterator].call(iterable);
      }
    };
  } else {
    var isArray$6 = isarray;
    var isString$2 = isString$4;
    var GetIntrinsic$a = requireGetIntrinsic$1();
    var $Map$1 = GetIntrinsic$a("%Map%", true);
    var $Set$1 = GetIntrinsic$a("%Set%", true);
    var callBound$6 = requireCallBound$1();
    var $arrayPush = callBound$6("Array.prototype.push");
    var $charCodeAt = callBound$6("String.prototype.charCodeAt");
    var $stringSlice = callBound$6("String.prototype.slice");
    var advanceStringIndex = function advanceStringIndex2(S2, index2) {
      var length = S2.length;
      if (index2 + 1 >= length) {
        return index2 + 1;
      }
      var first = $charCodeAt(S2, index2);
      if (first < 55296 || first > 56319) {
        return index2 + 1;
      }
      var second = $charCodeAt(S2, index2 + 1);
      if (second < 56320 || second > 57343) {
        return index2 + 1;
      }
      return index2 + 2;
    };
    var getArrayIterator = function getArrayIterator2(arraylike) {
      var i2 = 0;
      return {
        next: function next() {
          var done = i2 >= arraylike.length;
          var value;
          if (!done) {
            value = arraylike[i2];
            i2 += 1;
          }
          return {
            done,
            value
          };
        }
      };
    };
    var getNonCollectionIterator = function getNonCollectionIterator2(iterable) {
      if (isArray$6(iterable) || isArguments$3(iterable)) {
        return getArrayIterator(iterable);
      }
      if (isString$2(iterable)) {
        var i2 = 0;
        return {
          next: function next() {
            var nextIndex = advanceStringIndex(iterable, i2);
            var value = $stringSlice(iterable, i2, nextIndex);
            i2 = nextIndex;
            return {
              done: nextIndex > iterable.length,
              value
            };
          }
        };
      }
    };
    if (!$Map$1 && !$Set$1) {
      esGetIterator.exports = getNonCollectionIterator;
    } else {
      var isMap$3 = isMap$5;
      var isSet$3 = isSet$5;
      var $mapForEach = callBound$6("Map.prototype.forEach", true);
      var $setForEach = callBound$6("Set.prototype.forEach", true);
      if (typeof process === "undefined" || !process.versions || !process.versions.node) {
        var $mapIterator = callBound$6("Map.prototype.iterator", true);
        var $setIterator = callBound$6("Set.prototype.iterator", true);
        var getStopIterationIterator = function(iterator2) {
          var done = false;
          return {
            next: function next() {
              try {
                return {
                  done,
                  value: done ? void 0 : iterator2.next()
                };
              } catch (e2) {
                done = true;
                return {
                  done: true,
                  value: void 0
                };
              }
            }
          };
        };
      }
      var $mapAtAtIterator = callBound$6("Map.prototype.@@iterator", true) || callBound$6("Map.prototype._es6-shim iterator_", true);
      var $setAtAtIterator = callBound$6("Set.prototype.@@iterator", true) || callBound$6("Set.prototype._es6-shim iterator_", true);
      var getCollectionIterator = function getCollectionIterator2(iterable) {
        if (isMap$3(iterable)) {
          if ($mapIterator) {
            return getStopIterationIterator($mapIterator(iterable));
          }
          if ($mapAtAtIterator) {
            return $mapAtAtIterator(iterable);
          }
          if ($mapForEach) {
            var entries = [];
            $mapForEach(iterable, function(v2, k2) {
              $arrayPush(entries, [k2, v2]);
            });
            return getArrayIterator(entries);
          }
        }
        if (isSet$3(iterable)) {
          if ($setIterator) {
            return getStopIterationIterator($setIterator(iterable));
          }
          if ($setAtAtIterator) {
            return $setAtAtIterator(iterable);
          }
          if ($setForEach) {
            var values2 = [];
            $setForEach(iterable, function(v2) {
              $arrayPush(values2, v2);
            });
            return getArrayIterator(values2);
          }
        }
      };
      esGetIterator.exports = function getIterator2(iterable) {
        return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
      };
    }
  }
  var esGetIteratorExports = esGetIterator.exports;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString$1 = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var match = String.prototype.match;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var inspectCustom = require$$0$1.custom;
  var inspectSymbol = inspectCustom && isSymbol$1(inspectCustom) ? inspectCustom : null;
  var objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean") {
      throw new TypeError('option "customInspect", if provided, must be `true` or `false`');
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      return String(obj);
    }
    if (typeof obj === "bigint") {
      return String(obj) + "n";
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray$5(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect2(value, from, noIndent) {
      if (from) {
        seen = seen.slice();
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function") {
      var name = nameOf(obj);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]";
    }
    if (isSymbol$1(obj)) {
      var symString = Symbol.prototype.toString.call(obj);
      return typeof obj === "object" ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s2 = "<" + String(obj.nodeName).toLowerCase();
      var attrs = obj.attributes || [];
      for (var i2 = 0; i2 < attrs.length; i2++) {
        s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
      }
      s2 += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s2 += "...";
      }
      s2 += "</" + String(obj.nodeName).toLowerCase() + ">";
      return s2;
    }
    if (isArray$5(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs2 = arrObjKeys(obj, inspect2);
      if (indent && !singleLineValues(xs2)) {
        return "[" + indentedJoin(xs2, indent) + "]";
      }
      return "[ " + xs2.join(", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect2);
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + parts.join(", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
        return obj[inspectSymbol]();
      } else if (typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap$2(obj)) {
      var mapParts = [];
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet$2(obj)) {
      var setParts = [];
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect2(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect2(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString$1(obj)) {
      return markBoxed(inspect2(String(obj)));
    }
    if (!isDate$1(obj) && !isRegExp(obj)) {
      var ys2 = arrObjKeys(obj, inspect2);
      if (ys2.length === 0) {
        return "{}";
      }
      if (indent) {
        return "{" + indentedJoin(ys2, indent) + "}";
      }
      return "{ " + ys2.join(", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s2, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
    return quoteChar + s2 + quoteChar;
  }
  function quote(s2) {
    return String(s2).replace(/"/g, "&quot;");
  }
  function isArray$5(obj) {
    return toStr$1(obj) === "[object Array]";
  }
  function isDate$1(obj) {
    return toStr$1(obj) === "[object Date]";
  }
  function isRegExp(obj) {
    return toStr$1(obj) === "[object RegExp]";
  }
  function isError(obj) {
    return toStr$1(obj) === "[object Error]";
  }
  function isSymbol$1(obj) {
    return toStr$1(obj) === "[object Symbol]";
  }
  function isString$1(obj) {
    return toStr$1(obj) === "[object String]";
  }
  function isNumber(obj) {
    return toStr$1(obj) === "[object Number]";
  }
  function isBigInt(obj) {
    return toStr$1(obj) === "[object BigInt]";
  }
  function isBoolean(obj) {
    return toStr$1(obj) === "[object Boolean]";
  }
  var hasOwn$3 = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn$3.call(obj, key);
  }
  function toStr$1(obj) {
    return objectToString$1.call(obj);
  }
  function nameOf(f2) {
    if (f2.name) {
      return f2.name;
    }
    var m2 = match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
    if (m2) {
      return m2[1];
    }
    return null;
  }
  function indexOf(xs2, x2) {
    if (xs2.indexOf) {
      return xs2.indexOf(x2);
    }
    for (var i2 = 0, l2 = xs2.length; i2 < l2; i2++) {
      if (xs2[i2] === x2) {
        return i2;
      }
    }
    return -1;
  }
  function isMap$2(x2) {
    if (!mapSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      mapSize.call(x2);
      try {
        setSize.call(x2);
      } catch (s2) {
        return true;
      }
      return x2 instanceof Map;
    } catch (e2) {
    }
    return false;
  }
  function isWeakMap(x2) {
    if (!weakMapHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x2, weakMapHas);
      try {
        weakSetHas.call(x2, weakSetHas);
      } catch (s2) {
        return true;
      }
      return x2 instanceof WeakMap;
    } catch (e2) {
    }
    return false;
  }
  function isSet$2(x2) {
    if (!setSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      setSize.call(x2);
      try {
        mapSize.call(x2);
      } catch (m2) {
        return true;
      }
      return x2 instanceof Set;
    } catch (e2) {
    }
    return false;
  }
  function isWeakSet(x2) {
    if (!weakSetHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x2, weakSetHas);
      try {
        weakMapHas.call(x2, weakMapHas);
      } catch (s2) {
        return true;
      }
      return x2 instanceof WeakSet;
    } catch (e2) {
    }
    return false;
  }
  function isElement(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
      return true;
    }
    return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
    }
    var s2 = str.replace(/(['\\])/g, "\\$1").replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s2, "single", opts);
  }
  function lowbyte(c2) {
    var n2 = c2.charCodeAt(0);
    var x2 = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n2];
    if (x2) {
      return "\\" + x2;
    }
    return "\\x" + (n2 < 16 ? "0" : "") + n2.toString(16);
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type) {
    return type + " { ? }";
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(", ");
    return type + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs2) {
    for (var i2 = 0; i2 < xs2.length; i2++) {
      if (indexOf(xs2[i2], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = Array(opts.indent + 1).join(" ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: Array(depth + 1).join(baseIndent)
    };
  }
  function indentedJoin(xs2, indent) {
    if (xs2.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + xs2.join("," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect2) {
    var isArr = isArray$5(obj);
    var xs2 = [];
    if (isArr) {
      xs2.length = obj.length;
      for (var i2 = 0; i2 < obj.length; i2++) {
        xs2[i2] = has(obj, i2) ? inspect2(obj[i2], obj) : "";
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (/[^\w$]/.test(key)) {
        xs2.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
      } else {
        xs2.push(key + ": " + inspect2(obj[key], obj));
      }
    }
    return xs2;
  }
  var GetIntrinsic$9 = GetIntrinsic$d;
  var callBound$5 = callBound$8;
  var inspect$2 = objectInspect;
  var $TypeError$5 = GetIntrinsic$9("%TypeError%");
  var $WeakMap = GetIntrinsic$9("%WeakMap%", true);
  var $Map = GetIntrinsic$9("%Map%", true);
  var $push$1 = callBound$5("Array.prototype.push");
  var $weakMapGet = callBound$5("WeakMap.prototype.get", true);
  var $weakMapSet = callBound$5("WeakMap.prototype.set", true);
  var $weakMapHas = callBound$5("WeakMap.prototype.has", true);
  var $mapGet$1 = callBound$5("Map.prototype.get", true);
  var $mapSet = callBound$5("Map.prototype.set", true);
  var $mapHas$1 = callBound$5("Map.prototype.has", true);
  var objectGet = function(objects, key) {
    for (var i2 = 0; i2 < objects.length; i2 += 1) {
      if (objects[i2].key === key) {
        return objects[i2].value;
      }
    }
  };
  var objectSet = function(objects, key, value) {
    for (var i2 = 0; i2 < objects.length; i2 += 1) {
      if (objects[i2].key === key) {
        objects[i2].value = value;
        return;
      }
    }
    $push$1(objects, {
      key,
      value
    });
  };
  var objectHas = function(objects, key) {
    for (var i2 = 0; i2 < objects.length; i2 += 1) {
      if (objects[i2].key === key) {
        return true;
      }
    }
    return false;
  };
  var sideChannel = function getSideChannel2() {
    var $wm;
    var $m;
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError$5("Side channel does not contain " + inspect$2(key));
        }
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapGet$1($m, key);
          }
        } else {
          if ($o) {
            return objectGet($o, key);
          }
        }
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapHas$1($m, key);
          }
        } else {
          if ($o) {
            return objectHas($o, key);
          }
        }
        return false;
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value);
        } else if ($Map) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        } else {
          if (!$o) {
            $o = [];
          }
          objectSet($o, key, value);
        }
      }
    };
    return channel;
  };
  var hasOwn$2 = Object.prototype.hasOwnProperty;
  var toString$1 = Object.prototype.toString;
  var foreach = function forEach2(obj, fn, ctx) {
    if (toString$1.call(fn) !== "[object Function]") {
      throw new TypeError("iterator must be a function");
    }
    var l2 = obj.length;
    if (l2 === +l2) {
      for (var i2 = 0; i2 < l2; i2++) {
        fn.call(ctx, obj[i2], i2, obj);
      }
    } else {
      for (var k2 in obj) {
        if (hasOwn$2.call(obj, k2)) {
          fn.call(ctx, obj[k2], k2, obj);
        }
      }
    }
  };
  var arrayFilter$1 = function(arr, fn, self2) {
    if (arr.filter)
      return arr.filter(fn, self2);
    if (void 0 === arr || null === arr)
      throw new TypeError();
    if ("function" != typeof fn)
      throw new TypeError();
    var ret = [];
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (!hasOwn$1.call(arr, i2))
        continue;
      var val = arr[i2];
      if (fn.call(self2, val, i2, arr))
        ret.push(val);
    }
    return ret;
  };
  var hasOwn$1 = Object.prototype.hasOwnProperty;
  var filter = arrayFilter$1;
  var availableTypedArrays$1 = function availableTypedArrays2() {
    return filter([
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ], function(typedArray) {
      return typeof commonjsGlobal[typedArray] === "function";
    });
  };
  var getOwnPropertyDescriptor$1;
  var hasRequiredGetOwnPropertyDescriptor$1;
  function requireGetOwnPropertyDescriptor$1() {
    if (hasRequiredGetOwnPropertyDescriptor$1)
      return getOwnPropertyDescriptor$1;
    hasRequiredGetOwnPropertyDescriptor$1 = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $gOPD2 = GetIntrinsic2("%Object.getOwnPropertyDescriptor%");
    if ($gOPD2) {
      try {
        $gOPD2([], "length");
      } catch (e2) {
        $gOPD2 = null;
      }
    }
    getOwnPropertyDescriptor$1 = $gOPD2;
    return getOwnPropertyDescriptor$1;
  }
  var GetIntrinsic$8;
  var hasRequiredGetIntrinsic;
  function requireGetIntrinsic() {
    if (hasRequiredGetIntrinsic)
      return GetIntrinsic$8;
    hasRequiredGetIntrinsic = 1;
    var undefined$12;
    var $TypeError2 = TypeError;
    var $gOPD2 = Object.getOwnPropertyDescriptor;
    if ($gOPD2) {
      try {
        $gOPD2({}, "");
      } catch (e2) {
        $gOPD2 = null;
      }
    }
    var throwTypeError2 = function() {
      throw new $TypeError2();
    };
    var ThrowTypeError2 = $gOPD2 ? function() {
      try {
        arguments.callee;
        return throwTypeError2;
      } catch (calleeThrows) {
        try {
          return $gOPD2(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError2;
        }
      }
    }() : throwTypeError2;
    var hasSymbols2 = hasSymbols$7();
    var getProto2 = Object.getPrototypeOf || function(x2) {
      return x2.__proto__;
    };
    var generatorFunction2 = undefined$12;
    var asyncFunction2 = undefined$12;
    var asyncGenFunction2 = undefined$12;
    var TypedArray2 = typeof Uint8Array === "undefined" ? undefined$12 : getProto2(Uint8Array);
    var INTRINSICS2 = {
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer,
      "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer.prototype,
      "%ArrayIteratorPrototype%": hasSymbols2 ? getProto2([][Symbol.iterator]()) : undefined$12,
      "%ArrayPrototype%": Array.prototype,
      "%ArrayProto_entries%": Array.prototype.entries,
      "%ArrayProto_forEach%": Array.prototype.forEach,
      "%ArrayProto_keys%": Array.prototype.keys,
      "%ArrayProto_values%": Array.prototype.values,
      "%AsyncFromSyncIteratorPrototype%": undefined$12,
      "%AsyncFunction%": asyncFunction2,
      "%AsyncFunctionPrototype%": undefined$12,
      "%AsyncGenerator%": undefined$12,
      "%AsyncGeneratorFunction%": asyncGenFunction2,
      "%AsyncGeneratorPrototype%": undefined$12,
      "%AsyncIteratorPrototype%": undefined$12,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$12 : Atomics,
      "%Boolean%": Boolean,
      "%BooleanPrototype%": Boolean.prototype,
      "%DataView%": typeof DataView === "undefined" ? undefined$12 : DataView,
      "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$12 : DataView.prototype,
      "%Date%": Date,
      "%DatePrototype%": Date.prototype,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%ErrorPrototype%": Error.prototype,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%EvalErrorPrototype%": EvalError.prototype,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array,
      "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array.prototype,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array,
      "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array.prototype,
      "%Function%": Function,
      "%FunctionPrototype%": Function.prototype,
      "%Generator%": undefined$12,
      "%GeneratorFunction%": generatorFunction2,
      "%GeneratorPrototype%": undefined$12,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array,
      "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array.prototype,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$12 : Int16Array,
      "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$12 : Int8Array.prototype,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array,
      "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array.prototype,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$12,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$12,
      "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$12,
      "%Map%": typeof Map === "undefined" ? undefined$12 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$12 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%MapPrototype%": typeof Map === "undefined" ? undefined$12 : Map.prototype,
      "%Math%": Math,
      "%Number%": Number,
      "%NumberPrototype%": Number.prototype,
      "%Object%": Object,
      "%ObjectPrototype%": Object.prototype,
      "%ObjProto_toString%": Object.prototype.toString,
      "%ObjProto_valueOf%": Object.prototype.valueOf,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$12 : Promise,
      "%PromisePrototype%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype,
      "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype.then,
      "%Promise_all%": typeof Promise === "undefined" ? undefined$12 : Promise.all,
      "%Promise_reject%": typeof Promise === "undefined" ? undefined$12 : Promise.reject,
      "%Promise_resolve%": typeof Promise === "undefined" ? undefined$12 : Promise.resolve,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$12 : Proxy,
      "%RangeError%": RangeError,
      "%RangeErrorPrototype%": RangeError.prototype,
      "%ReferenceError%": ReferenceError,
      "%ReferenceErrorPrototype%": ReferenceError.prototype,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$12 : Reflect,
      "%RegExp%": RegExp,
      "%RegExpPrototype%": RegExp.prototype,
      "%Set%": typeof Set === "undefined" ? undefined$12 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$12 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SetPrototype%": typeof Set === "undefined" ? undefined$12 : Set.prototype,
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer,
      "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer.prototype,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols2 ? getProto2(""[Symbol.iterator]()) : undefined$12,
      "%StringPrototype%": String.prototype,
      "%Symbol%": hasSymbols2 ? Symbol : undefined$12,
      "%SymbolPrototype%": hasSymbols2 ? Symbol.prototype : undefined$12,
      "%SyntaxError%": SyntaxError,
      "%SyntaxErrorPrototype%": SyntaxError.prototype,
      "%ThrowTypeError%": ThrowTypeError2,
      "%TypedArray%": TypedArray2,
      "%TypedArrayPrototype%": TypedArray2 ? TypedArray2.prototype : undefined$12,
      "%TypeError%": $TypeError2,
      "%TypeErrorPrototype%": $TypeError2.prototype,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array,
      "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array.prototype,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray,
      "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray.prototype,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array,
      "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array.prototype,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array,
      "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array.prototype,
      "%URIError%": URIError,
      "%URIErrorPrototype%": URIError.prototype,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap,
      "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap.prototype,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet,
      "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet.prototype
    };
    var bind2 = functionBind;
    var $replace2 = bind2.call(Function.call, String.prototype.replace);
    var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = function stringToPath3(string) {
      var result2 = [];
      $replace2(string, rePropName2, function(match2, number2, quote2, subString) {
        result2[result2.length] = quote2 ? $replace2(subString, reEscapeChar2, "$1") : number2 || match2;
      });
      return result2;
    };
    var getBaseIntrinsic2 = function getBaseIntrinsic3(name, allowMissing) {
      if (!(name in INTRINSICS2)) {
        throw new SyntaxError("intrinsic " + name + " does not exist!");
      }
      if (typeof INTRINSICS2[name] === "undefined" && !allowMissing) {
        throw new $TypeError2("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return INTRINSICS2[name];
    };
    GetIntrinsic$8 = function GetIntrinsic2(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath2(name);
      var value = getBaseIntrinsic2("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
      for (var i2 = 1; i2 < parts.length; i2 += 1) {
        if (value != null) {
          if ($gOPD2 && i2 + 1 >= parts.length) {
            var desc = $gOPD2(value, parts[i2]);
            if (!allowMissing && !(parts[i2] in value)) {
              throw new $TypeError2("base intrinsic for " + name + " exists, but the property is not available.");
            }
            value = desc ? desc.get || desc.value : value[parts[i2]];
          } else {
            value = value[parts[i2]];
          }
        }
      }
      return value;
    };
    return GetIntrinsic$8;
  }
  var callBind$3 = { exports: {} };
  var hasRequiredCallBind;
  function requireCallBind() {
    if (hasRequiredCallBind)
      return callBind$3.exports;
    hasRequiredCallBind = 1;
    var bind2 = functionBind;
    var GetIntrinsic2 = requireGetIntrinsic();
    var $Function2 = GetIntrinsic2("%Function%");
    var $apply = $Function2.apply;
    var $call = $Function2.call;
    callBind$3.exports = function callBind2() {
      return bind2.apply($call, arguments);
    };
    callBind$3.exports.apply = function applyBind() {
      return bind2.apply($apply, arguments);
    };
    return callBind$3.exports;
  }
  var callBound$4;
  var hasRequiredCallBound;
  function requireCallBound() {
    if (hasRequiredCallBound)
      return callBound$4;
    hasRequiredCallBound = 1;
    var GetIntrinsic2 = requireGetIntrinsic();
    var callBind2 = requireCallBind();
    var $indexOf2 = callBind2(GetIntrinsic2("String.prototype.indexOf"));
    callBound$4 = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic2(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf2(name, ".prototype.")) {
        return callBind2(intrinsic);
      }
      return intrinsic;
    };
    return callBound$4;
  }
  var getOwnPropertyDescriptor;
  var hasRequiredGetOwnPropertyDescriptor;
  function requireGetOwnPropertyDescriptor() {
    if (hasRequiredGetOwnPropertyDescriptor)
      return getOwnPropertyDescriptor;
    hasRequiredGetOwnPropertyDescriptor = 1;
    var GetIntrinsic2 = requireGetIntrinsic();
    var $gOPD2 = GetIntrinsic2("%Object.getOwnPropertyDescriptor%");
    if ($gOPD2) {
      try {
        $gOPD2([], "length");
      } catch (e2) {
        $gOPD2 = null;
      }
    }
    getOwnPropertyDescriptor = $gOPD2;
    return getOwnPropertyDescriptor;
  }
  var isTypedArray$3;
  var hasRequiredIsTypedArray;
  function requireIsTypedArray() {
    if (hasRequiredIsTypedArray)
      return isTypedArray$3;
    hasRequiredIsTypedArray = 1;
    var forEach2 = foreach;
    var availableTypedArrays2 = availableTypedArrays$1;
    var callBound2 = requireCallBound();
    var $toString2 = callBound2("Object.prototype.toString");
    var hasSymbols2 = hasSymbols$7();
    var hasToStringTag2 = hasSymbols2 && typeof Symbol.toStringTag === "symbol";
    var typedArrays2 = availableTypedArrays2();
    var $indexOf2 = callBound2("Array.prototype.indexOf", true) || function indexOf2(array, value) {
      for (var i2 = 0; i2 < array.length; i2 += 1) {
        if (array[i2] === value) {
          return i2;
        }
      }
      return -1;
    };
    var $slice2 = callBound2("String.prototype.slice");
    var toStrTags2 = {};
    var gOPD2 = requireGetOwnPropertyDescriptor();
    var getPrototypeOf2 = Object.getPrototypeOf;
    if (hasToStringTag2 && gOPD2 && getPrototypeOf2) {
      forEach2(typedArrays2, function(typedArray) {
        var arr = new commonjsGlobal[typedArray]();
        if (!(Symbol.toStringTag in arr)) {
          throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
        }
        var proto2 = getPrototypeOf2(arr);
        var descriptor = gOPD2(proto2, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf2(proto2);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        toStrTags2[typedArray] = descriptor.get;
      });
    }
    var tryTypedArrays2 = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach2(toStrTags2, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e2) {
          }
        }
      });
      return anyTrue;
    };
    isTypedArray$3 = function isTypedArray2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag2) {
        var tag = $slice2($toString2(value), 8, -1);
        return $indexOf2(typedArrays2, tag) > -1;
      }
      if (!gOPD2) {
        return false;
      }
      return tryTypedArrays2(value);
    };
    return isTypedArray$3;
  }
  var forEach = foreach;
  var availableTypedArrays = availableTypedArrays$1;
  var callBound$3 = callBound$8;
  var $toString = callBound$3("Object.prototype.toString");
  var hasSymbols$3 = hasSymbols$7();
  var hasToStringTag = hasSymbols$3 && typeof Symbol.toStringTag === "symbol";
  var typedArrays = availableTypedArrays();
  var $slice = callBound$3("String.prototype.slice");
  var toStrTags = {};
  var gOPD = requireGetOwnPropertyDescriptor$1();
  var getPrototypeOf = Object.getPrototypeOf;
  if (hasToStringTag && gOPD && getPrototypeOf) {
    forEach(typedArrays, function(typedArray) {
      if (typeof commonjsGlobal[typedArray] === "function") {
        var arr = new commonjsGlobal[typedArray]();
        if (!(Symbol.toStringTag in arr)) {
          throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
        }
        var proto2 = getPrototypeOf(arr);
        var descriptor = gOPD(proto2, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto2);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var foundName = false;
    forEach(toStrTags, function(getter, typedArray) {
      if (!foundName) {
        try {
          var name = getter.call(value);
          if (name === typedArray) {
            foundName = name;
          }
        } catch (e2) {
        }
      }
    });
    return foundName;
  };
  var isTypedArray$2 = requireIsTypedArray();
  var whichTypedArray$1 = function whichTypedArray2(value) {
    if (!isTypedArray$2(value)) {
      return false;
    }
    if (!hasToStringTag) {
      return $slice($toString(value), 8, -1);
    }
    return tryTypedArrays(value);
  };
  var callBind$2 = { exports: {} };
  var bind$2 = functionBind;
  var src = bind$2.call(Function.call, Object.prototype.hasOwnProperty);
  var undefined$1;
  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError$4 = TypeError;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return window["notthere"];
    } catch (e2) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e2) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError$4();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols$2 = hasSymbols$7();
  var getProto = Object.getPrototypeOf || function(x2) {
    return x2.__proto__;
  };
  var asyncGenFunction = getEvalledConstructor();
  var asyncGenFunctionPrototype = asyncGenFunction ? asyncGenFunction.prototype : undefined$1;
  var asyncGenPrototype = asyncGenFunctionPrototype ? asyncGenFunctionPrototype.prototype : undefined$1;
  var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols$2 ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": getEvalledConstructor(),
    "%AsyncGenerator%": asyncGenFunctionPrototype,
    "%AsyncGeneratorFunction%": asyncGenFunction,
    "%AsyncIteratorPrototype%": asyncGenPrototype ? getProto(asyncGenPrototype) : undefined$1,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": getEvalledConstructor(),
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols$2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$2 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$2 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols$2 ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols$2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError$4,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind$1 = functionBind;
  var hasOwn = src;
  var $concat = bind$1.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind$1.call(Function.apply, Array.prototype.splice);
  var $replace = bind$1.call(Function.call, String.prototype.replace);
  var rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar$1 = /\\(\\)?/g;
  var stringToPath$2 = function stringToPath2(string) {
    var result2 = [];
    $replace(string, rePropName$1, function(match2, number2, quote2, subString) {
      result2[result2.length] = quote2 ? $replace(subString, reEscapeChar$1, "$1") : number2 || match2;
    });
    return result2;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError$4("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError$4("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError$4('"allowMissing" argument must be a boolean');
    }
    var parts = stringToPath$2(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
      var part = parts[i2];
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if ($gOPD && i2 + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (!allowMissing && !(part in value)) {
            throw new $TypeError$4("base intrinsic for " + name + " exists, but the property is not available.");
          }
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  (function(module2) {
    var bind2 = functionBind;
    var GetIntrinsic2 = getIntrinsic;
    var $apply = GetIntrinsic2("%Function.prototype.apply%");
    var $call = GetIntrinsic2("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind2() {
      return $reflectApply(bind2, $call, arguments);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  })(callBind$2);
  var callBindExports = callBind$2.exports;
  var GetIntrinsic$7 = getIntrinsic;
  var callBind$1 = callBindExports;
  var $indexOf = callBind$1(GetIntrinsic$7("String.prototype.indexOf"));
  var callBound$2 = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic$7(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind$1(intrinsic);
    }
    return intrinsic;
  };
  var keys$1 = objectKeys$1;
  var canBeObject = function(obj) {
    return typeof obj !== "undefined" && obj !== null;
  };
  var hasSymbols$1 = shams();
  var callBound$1 = callBound$2;
  var toObject = Object;
  var $push = callBound$1("Array.prototype.push");
  var $propIsEnumerable = callBound$1("Object.prototype.propertyIsEnumerable");
  var originalGetSymbols = hasSymbols$1 ? Object.getOwnPropertySymbols : null;
  var implementation$5 = function assign2(target, source1) {
    if (!canBeObject(target)) {
      throw new TypeError("target must be an object");
    }
    var objTarget = toObject(target);
    var s2, source, i2, props, syms, value, key;
    for (s2 = 1; s2 < arguments.length; ++s2) {
      source = toObject(arguments[s2]);
      props = keys$1(source);
      var getSymbols2 = hasSymbols$1 && (Object.getOwnPropertySymbols || originalGetSymbols);
      if (getSymbols2) {
        syms = getSymbols2(source);
        for (i2 = 0; i2 < syms.length; ++i2) {
          key = syms[i2];
          if ($propIsEnumerable(source, key)) {
            $push(props, key);
          }
        }
      }
      for (i2 = 0; i2 < props.length; ++i2) {
        key = props[i2];
        value = source[key];
        if ($propIsEnumerable(source, key)) {
          objTarget[key] = value;
        }
      }
    }
    return objTarget;
  };
  var implementation$4 = implementation$5;
  var lacksProperEnumerationOrder = function() {
    if (!Object.assign) {
      return false;
    }
    var str = "abcdefghijklmnopqrst";
    var letters = str.split("");
    var map2 = {};
    for (var i2 = 0; i2 < letters.length; ++i2) {
      map2[letters[i2]] = letters[i2];
    }
    var obj = Object.assign({}, map2);
    var actual = "";
    for (var k2 in obj) {
      actual += k2;
    }
    return str !== actual;
  };
  var assignHasPendingExceptions = function() {
    if (!Object.assign || !Object.preventExtensions) {
      return false;
    }
    var thrower = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(thrower, "xy");
    } catch (e2) {
      return thrower[1] === "y";
    }
    return false;
  };
  var polyfill$3 = function getPolyfill2() {
    if (!Object.assign) {
      return implementation$4;
    }
    if (lacksProperEnumerationOrder()) {
      return implementation$4;
    }
    if (assignHasPendingExceptions()) {
      return implementation$4;
    }
    return Object.assign;
  };
  var define$2 = defineProperties_1;
  var getPolyfill$3 = polyfill$3;
  var shim$3 = function shimAssign() {
    var polyfill2 = getPolyfill$3();
    define$2(
      Object,
      { assign: polyfill2 },
      { assign: function() {
        return Object.assign !== polyfill2;
      } }
    );
    return polyfill2;
  };
  var defineProperties = defineProperties_1;
  var callBind = callBindExports;
  var implementation$3 = implementation$5;
  var getPolyfill$2 = polyfill$3;
  var shim$2 = shim$3;
  var polyfill$2 = callBind.apply(getPolyfill$2());
  var bound = function assign2(target, source1) {
    return polyfill$2(Object, arguments);
  };
  defineProperties(bound, {
    getPolyfill: getPolyfill$2,
    implementation: implementation$3,
    shim: shim$2
  });
  var object_assign = bound;
  var objectKeys = objectKeys$1;
  var isArguments$2 = isArguments$4;
  var is = objectIs;
  var isRegex = isRegex$1;
  var flags = regexp_prototype_flags;
  var isArray$4 = isarray;
  var isDate = isDateObject;
  var whichBoxedPrimitive = whichBoxedPrimitive$1;
  var GetIntrinsic$6 = GetIntrinsic$d;
  var callBound = callBound$8;
  var whichCollection = whichCollection$1;
  var getIterator = esGetIteratorExports;
  var getSideChannel = sideChannel;
  var whichTypedArray = whichTypedArray$1;
  var assign = object_assign;
  var $getTime = callBound("Date.prototype.getTime");
  var gPO = Object.getPrototypeOf;
  var $objToString = callBound("Object.prototype.toString");
  var $Set = GetIntrinsic$6("%Set%", true);
  var $mapHas = callBound("Map.prototype.has", true);
  var $mapGet = callBound("Map.prototype.get", true);
  var $mapSize = callBound("Map.prototype.size", true);
  var $setAdd = callBound("Set.prototype.add", true);
  var $setDelete = callBound("Set.prototype.delete", true);
  var $setHas = callBound("Set.prototype.has", true);
  var $setSize = callBound("Set.prototype.size", true);
  function setHasEqualElement(set, val1, opts, channel) {
    var i2 = getIterator(set);
    var result2;
    while ((result2 = i2.next()) && !result2.done) {
      if (internalDeepEqual(val1, result2.value, opts, channel)) {
        $setDelete(set, result2.value);
        return true;
      }
    }
    return false;
  }
  function findLooseMatchingPrimitives(prim) {
    if (typeof prim === "undefined") {
      return null;
    }
    if (typeof prim === "object") {
      return void 0;
    }
    if (typeof prim === "symbol") {
      return false;
    }
    if (typeof prim === "string" || typeof prim === "number") {
      return +prim === +prim;
    }
    return true;
  }
  function mapMightHaveLoosePrim(a, b2, prim, item, opts, channel) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) {
      return altValue;
    }
    var curB = $mapGet(b2, altValue);
    var looseOpts = assign({}, opts, { strict: false });
    if (typeof curB === "undefined" && !$mapHas(b2, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
      return false;
    }
    return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
  }
  function setMightHaveLoosePrim(a, b2, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) {
      return altValue;
    }
    return $setHas(b2, altValue) && !$setHas(a, altValue);
  }
  function mapHasEqualEntry(set, map2, key1, item1, opts, channel) {
    var i2 = getIterator(set);
    var result2;
    var key2;
    while ((result2 = i2.next()) && !result2.done) {
      key2 = result2.value;
      if (
        // eslint-disable-next-line no-use-before-define
        internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet(map2, key2), opts, channel)
      ) {
        $setDelete(set, key2);
        return true;
      }
    }
    return false;
  }
  function internalDeepEqual(actual, expected, options, channel) {
    var opts = options || {};
    if (opts.strict ? is(actual, expected) : actual === expected) {
      return true;
    }
    var actualBoxed = whichBoxedPrimitive(actual);
    var expectedBoxed = whichBoxedPrimitive(expected);
    if (actualBoxed !== expectedBoxed) {
      return false;
    }
    if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
      return opts.strict ? is(actual, expected) : actual == expected;
    }
    var hasActual = channel.has(actual);
    var hasExpected = channel.has(expected);
    var sentinel;
    if (hasActual && hasExpected) {
      if (channel.get(actual) === channel.get(expected)) {
        return true;
      }
    } else {
      sentinel = {};
    }
    if (!hasActual) {
      channel.set(actual, sentinel);
    }
    if (!hasExpected) {
      channel.set(expected, sentinel);
    }
    return objEquiv(actual, expected, opts, channel);
  }
  function isBuffer$3(x2) {
    if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
      return false;
    }
    if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
      return false;
    }
    if (x2.length > 0 && typeof x2[0] !== "number") {
      return false;
    }
    return !!(x2.constructor && x2.constructor.isBuffer && x2.constructor.isBuffer(x2));
  }
  function setEquiv(a, b2, opts, channel) {
    if ($setSize(a) !== $setSize(b2)) {
      return false;
    }
    var iA = getIterator(a);
    var iB = getIterator(b2);
    var resultA;
    var resultB;
    var set;
    while ((resultA = iA.next()) && !resultA.done) {
      if (resultA.value && typeof resultA.value === "object") {
        if (!set) {
          set = new $Set();
        }
        $setAdd(set, resultA.value);
      } else if (!$setHas(b2, resultA.value)) {
        if (opts.strict) {
          return false;
        }
        if (!setMightHaveLoosePrim(a, b2, resultA.value)) {
          return false;
        }
        if (!set) {
          set = new $Set();
        }
        $setAdd(set, resultA.value);
      }
    }
    if (set) {
      while ((resultB = iB.next()) && !resultB.done) {
        if (resultB.value && typeof resultB.value === "object") {
          if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
            return false;
          }
        } else if (!opts.strict && !$setHas(a, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
          return false;
        }
      }
      return $setSize(set) === 0;
    }
    return true;
  }
  function mapEquiv(a, b2, opts, channel) {
    if ($mapSize(a) !== $mapSize(b2)) {
      return false;
    }
    var iA = getIterator(a);
    var iB = getIterator(b2);
    var resultA;
    var resultB;
    var set;
    var key;
    var item1;
    var item2;
    while ((resultA = iA.next()) && !resultA.done) {
      key = resultA.value[0];
      item1 = resultA.value[1];
      if (key && typeof key === "object") {
        if (!set) {
          set = new $Set();
        }
        $setAdd(set, key);
      } else {
        item2 = $mapGet(b2, key);
        if (typeof item2 === "undefined" && !$mapHas(b2, key) || !internalDeepEqual(item1, item2, opts, channel)) {
          if (opts.strict) {
            return false;
          }
          if (!mapMightHaveLoosePrim(a, b2, key, item1, opts, channel)) {
            return false;
          }
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, key);
        }
      }
    }
    if (set) {
      while ((resultB = iB.next()) && !resultB.done) {
        key = resultB.value[0];
        item2 = resultB.value[1];
        if (key && typeof key === "object") {
          if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {
            return false;
          }
        } else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel)) && !mapHasEqualEntry(set, a, key, item2, assign({}, opts, { strict: false }), channel)) {
          return false;
        }
      }
      return $setSize(set) === 0;
    }
    return true;
  }
  function objEquiv(a, b2, opts, channel) {
    var i2, key;
    if (typeof a !== typeof b2) {
      return false;
    }
    if (a == null || b2 == null) {
      return false;
    }
    if ($objToString(a) !== $objToString(b2)) {
      return false;
    }
    if (isArguments$2(a) !== isArguments$2(b2)) {
      return false;
    }
    var aIsArray = isArray$4(a);
    var bIsArray = isArray$4(b2);
    if (aIsArray !== bIsArray) {
      return false;
    }
    var aIsError = a instanceof Error;
    var bIsError = b2 instanceof Error;
    if (aIsError !== bIsError) {
      return false;
    }
    if (aIsError || bIsError) {
      if (a.name !== b2.name || a.message !== b2.message) {
        return false;
      }
    }
    var aIsRegex = isRegex(a);
    var bIsRegex = isRegex(b2);
    if (aIsRegex !== bIsRegex) {
      return false;
    }
    if ((aIsRegex || bIsRegex) && (a.source !== b2.source || flags(a) !== flags(b2))) {
      return false;
    }
    var aIsDate = isDate(a);
    var bIsDate = isDate(b2);
    if (aIsDate !== bIsDate) {
      return false;
    }
    if (aIsDate || bIsDate) {
      if ($getTime(a) !== $getTime(b2)) {
        return false;
      }
    }
    if (opts.strict && gPO && gPO(a) !== gPO(b2)) {
      return false;
    }
    if (whichTypedArray(a) !== whichTypedArray(b2)) {
      return false;
    }
    var aIsBuffer = isBuffer$3(a);
    var bIsBuffer = isBuffer$3(b2);
    if (aIsBuffer !== bIsBuffer) {
      return false;
    }
    if (aIsBuffer || bIsBuffer) {
      if (a.length !== b2.length) {
        return false;
      }
      for (i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b2[i2]) {
          return false;
        }
      }
      return true;
    }
    if (typeof a !== typeof b2) {
      return false;
    }
    var ka2 = objectKeys(a);
    var kb2 = objectKeys(b2);
    if (ka2.length !== kb2.length) {
      return false;
    }
    ka2.sort();
    kb2.sort();
    for (i2 = ka2.length - 1; i2 >= 0; i2--) {
      if (ka2[i2] != kb2[i2]) {
        return false;
      }
    }
    for (i2 = ka2.length - 1; i2 >= 0; i2--) {
      key = ka2[i2];
      if (!internalDeepEqual(a[key], b2[key], opts, channel)) {
        return false;
      }
    }
    var aCollection = whichCollection(a);
    var bCollection = whichCollection(b2);
    if (aCollection !== bCollection) {
      return false;
    }
    if (aCollection === "Set" || bCollection === "Set") {
      return setEquiv(a, b2, opts, channel);
    }
    if (aCollection === "Map") {
      return mapEquiv(a, b2, opts, channel);
    }
    return true;
  }
  var deepEqual = function deepEqual2(a, b2, opts) {
    return internalDeepEqual(a, b2, opts, getSideChannel());
  };
  const Ee$1 = /* @__PURE__ */ getDefaultExportFromCjs(deepEqual);
  const anyMap = /* @__PURE__ */ new WeakMap();
  const eventsMap = /* @__PURE__ */ new WeakMap();
  const producersMap = /* @__PURE__ */ new WeakMap();
  const anyProducer = Symbol("anyProducer");
  const resolvedPromise = Promise.resolve();
  const listenerAdded = Symbol("listenerAdded");
  const listenerRemoved = Symbol("listenerRemoved");
  function assertEventName(eventName) {
    if (typeof eventName !== "string" && typeof eventName !== "symbol") {
      throw new TypeError("eventName must be a string or a symbol");
    }
  }
  function assertListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError("listener must be a function");
    }
  }
  function getListeners(instance, eventName) {
    const events = eventsMap.get(instance);
    if (!events.has(eventName)) {
      events.set(eventName, /* @__PURE__ */ new Set());
    }
    return events.get(eventName);
  }
  function getEventProducers(instance, eventName) {
    const key = typeof eventName === "string" ? eventName : anyProducer;
    const producers = producersMap.get(instance);
    if (!producers.has(key)) {
      producers.set(key, /* @__PURE__ */ new Set());
    }
    return producers.get(key);
  }
  function enqueueProducers(instance, eventName, eventData) {
    const producers = producersMap.get(instance);
    if (producers.has(eventName)) {
      for (const producer of producers.get(eventName)) {
        producer.enqueue(eventData);
      }
    }
    if (producers.has(anyProducer)) {
      const item = Promise.all([eventName, eventData]);
      for (const producer of producers.get(anyProducer)) {
        producer.enqueue(item);
      }
    }
  }
  function iterator(instance, eventName) {
    let isFinished = false;
    let flush = () => {
    };
    let queue = [];
    const producer = {
      enqueue(item) {
        queue.push(item);
        flush();
      },
      finish() {
        isFinished = true;
        flush();
      }
    };
    getEventProducers(instance, eventName).add(producer);
    return {
      async next() {
        if (!queue) {
          return { done: true };
        }
        if (queue.length === 0) {
          if (isFinished) {
            queue = void 0;
            return this.next();
          }
          await new Promise((resolve) => {
            flush = resolve;
          });
          return this.next();
        }
        return {
          done: false,
          value: await queue.shift()
        };
      },
      async return(value) {
        queue = void 0;
        getEventProducers(instance, eventName).delete(producer);
        flush();
        return arguments.length > 0 ? { done: true, value: await value } : { done: true };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function defaultMethodNamesOrAssert(methodNames) {
    if (methodNames === void 0) {
      return allEmitteryMethods;
    }
    if (!Array.isArray(methodNames)) {
      throw new TypeError("`methodNames` must be an array of strings");
    }
    for (const methodName of methodNames) {
      if (!allEmitteryMethods.includes(methodName)) {
        if (typeof methodName !== "string") {
          throw new TypeError("`methodNames` element must be a string");
        }
        throw new Error(`${methodName} is not Emittery method`);
      }
    }
    return methodNames;
  }
  const isListenerSymbol = (symbol) => symbol === listenerAdded || symbol === listenerRemoved;
  class Emittery {
    static mixin(emitteryPropertyName, methodNames) {
      methodNames = defaultMethodNamesOrAssert(methodNames);
      return (target) => {
        if (typeof target !== "function") {
          throw new TypeError("`target` must be function");
        }
        for (const methodName of methodNames) {
          if (target.prototype[methodName] !== void 0) {
            throw new Error(`The property \`${methodName}\` already exists on \`target\``);
          }
        }
        function getEmitteryProperty() {
          Object.defineProperty(this, emitteryPropertyName, {
            enumerable: false,
            value: new Emittery()
          });
          return this[emitteryPropertyName];
        }
        Object.defineProperty(target.prototype, emitteryPropertyName, {
          enumerable: false,
          get: getEmitteryProperty
        });
        const emitteryMethodCaller = (methodName) => function(...args) {
          return this[emitteryPropertyName][methodName](...args);
        };
        for (const methodName of methodNames) {
          Object.defineProperty(target.prototype, methodName, {
            enumerable: false,
            value: emitteryMethodCaller(methodName)
          });
        }
        return target;
      };
    }
    constructor() {
      anyMap.set(this, /* @__PURE__ */ new Set());
      eventsMap.set(this, /* @__PURE__ */ new Map());
      producersMap.set(this, /* @__PURE__ */ new Map());
    }
    on(eventName, listener) {
      assertEventName(eventName);
      assertListener(listener);
      getListeners(this, eventName).add(listener);
      if (!isListenerSymbol(eventName)) {
        this.emit(listenerAdded, { eventName, listener });
      }
      return this.off.bind(this, eventName, listener);
    }
    off(eventName, listener) {
      assertEventName(eventName);
      assertListener(listener);
      if (!isListenerSymbol(eventName)) {
        this.emit(listenerRemoved, { eventName, listener });
      }
      getListeners(this, eventName).delete(listener);
    }
    once(eventName) {
      return new Promise((resolve) => {
        assertEventName(eventName);
        const off = this.on(eventName, (data) => {
          off();
          resolve(data);
        });
      });
    }
    events(eventName) {
      assertEventName(eventName);
      return iterator(this, eventName);
    }
    async emit(eventName, eventData) {
      assertEventName(eventName);
      enqueueProducers(this, eventName, eventData);
      const listeners = getListeners(this, eventName);
      const anyListeners = anyMap.get(this);
      const staticListeners = [...listeners];
      const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];
      await resolvedPromise;
      return Promise.all([
        ...staticListeners.map(async (listener) => {
          if (listeners.has(listener)) {
            return listener(eventData);
          }
        }),
        ...staticAnyListeners.map(async (listener) => {
          if (anyListeners.has(listener)) {
            return listener(eventName, eventData);
          }
        })
      ]);
    }
    async emitSerial(eventName, eventData) {
      assertEventName(eventName);
      const listeners = getListeners(this, eventName);
      const anyListeners = anyMap.get(this);
      const staticListeners = [...listeners];
      const staticAnyListeners = [...anyListeners];
      await resolvedPromise;
      for (const listener of staticListeners) {
        if (listeners.has(listener)) {
          await listener(eventData);
        }
      }
      for (const listener of staticAnyListeners) {
        if (anyListeners.has(listener)) {
          await listener(eventName, eventData);
        }
      }
    }
    onAny(listener) {
      assertListener(listener);
      anyMap.get(this).add(listener);
      this.emit(listenerAdded, { listener });
      return this.offAny.bind(this, listener);
    }
    anyEvent() {
      return iterator(this);
    }
    offAny(listener) {
      assertListener(listener);
      this.emit(listenerRemoved, { listener });
      anyMap.get(this).delete(listener);
    }
    clearListeners(eventName) {
      if (typeof eventName === "string") {
        getListeners(this, eventName).clear();
        const producers = getEventProducers(this, eventName);
        for (const producer of producers) {
          producer.finish();
        }
        producers.clear();
      } else {
        anyMap.get(this).clear();
        for (const listeners of eventsMap.get(this).values()) {
          listeners.clear();
        }
        for (const producers of producersMap.get(this).values()) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
        }
      }
    }
    listenerCount(eventName) {
      if (typeof eventName === "string") {
        return anyMap.get(this).size + getListeners(this, eventName).size + getEventProducers(this, eventName).size + getEventProducers(this).size;
      }
      if (typeof eventName !== "undefined") {
        assertEventName(eventName);
      }
      let count = anyMap.get(this).size;
      for (const value of eventsMap.get(this).values()) {
        count += value.size;
      }
      for (const value of producersMap.get(this).values()) {
        count += value.size;
      }
      return count;
    }
    bindMethods(target, methodNames) {
      if (typeof target !== "object" || target === null) {
        throw new TypeError("`target` must be an object");
      }
      methodNames = defaultMethodNamesOrAssert(methodNames);
      for (const methodName of methodNames) {
        if (target[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
        Object.defineProperty(target, methodName, {
          enumerable: false,
          value: this[methodName].bind(this)
        });
      }
    }
  }
  const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v2) => v2 !== "constructor");
  Emittery.Typed = class extends Emittery {
  };
  Object.defineProperty(Emittery.Typed, "Typed", {
    enumerable: false,
    value: void 0
  });
  Object.defineProperty(Emittery, "listenerAdded", {
    value: listenerAdded,
    writable: false,
    enumerable: true,
    configurable: false
  });
  Object.defineProperty(Emittery, "listenerRemoved", {
    value: listenerRemoved,
    writable: false,
    enumerable: true,
    configurable: false
  });
  var emittery = Emittery;
  const Emittery$1 = /* @__PURE__ */ getDefaultExportFromCjs(emittery);
  function getRecentRevisionIds(history, cutoffDate) {
    const recentRevisionIds = /* @__PURE__ */ new Set();
    for (const [id2, revision] of Object.entries(history.revisions)) {
      if (new Date(revision.editTime).getTime() < cutoffDate.getTime()) {
        continue;
      }
      recentRevisionIds.add(id2);
    }
    while (true) {
      let changed = false;
      for (const [id2, revision] of Object.entries(history.revisions)) {
        if (!recentRevisionIds.has(id2) && revision.baseRevisionId && recentRevisionIds.has(revision.baseRevisionId)) {
          recentRevisionIds.add(id2);
          changed = true;
        }
      }
      if (!changed) {
        break;
      }
    }
    const baseRevisionIds = [];
    for (const id2 of recentRevisionIds) {
      const baseRevisionId = history.revisions[id2].baseRevisionId;
      if (baseRevisionId && !recentRevisionIds.has(baseRevisionId)) {
        baseRevisionIds.push(baseRevisionId);
      }
    }
    for (const id2 of baseRevisionIds) {
      recentRevisionIds.add(id2);
    }
    recentRevisionIds.add(history.currentRevisionId);
    return recentRevisionIds;
  }
  function modifyProtectedValues(content2, timestamp, transform) {
    let modifiedContent = content2;
    for (const [listKey, list] of Object.entries(content2)) {
      for (const [elementKey, current] of Object.entries(list)) {
        const modifiedElement = Object.assign(Object.assign({}, recursivelyTransformProtectedValues(current, transform)), { updateTime: timestamp });
        modifiedContent = Object.assign(Object.assign({}, modifiedContent), { [listKey]: Object.assign(Object.assign({}, modifiedContent[listKey]), { [elementKey]: modifiedElement }) });
      }
    }
    return modifiedContent;
  }
  function recursivelyTransformProtectedValues(element, transform) {
    return recursivelyTransformValues(element, isProtectedValue$1, transform);
  }
  function recursivelyTransformUnprotectedValues(element, transform) {
    return recursivelyTransformValues(element, isUnprotectedValue, transform);
  }
  function recursivelyTransformValues(element, predicate, transform) {
    if (Array.isArray(element)) {
      return element.map((el2) => recursivelyTransformValues(el2, predicate, transform));
    }
    if (typeof element === "object" && element !== null) {
      if (predicate(element)) {
        return transform(element);
      }
      const transformedElement = {};
      for (const [key, value] of Object.entries(element)) {
        transformedElement[key] = recursivelyTransformValues(value, predicate, transform);
      }
      return transformedElement;
    }
    return element;
  }
  function isProtectedValue$1(obj) {
    return ProtectedValue.safeParse(obj).success;
  }
  function isUnprotectedValue(obj) {
    return UnprotectedValue.safeParse(obj).success;
  }
  var __rest$F = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function extractLinkedUpdateMessages(vaultId, originPersonalProfileId, preChangeContent, protectedSecretFunctions, vaultContentDiff) {
    var _a3;
    const result2 = [];
    for (const [loginId, modifiedLogin] of Object.entries(vaultContentDiff.logins)) {
      const preChangeLogin = preChangeContent.logins[loginId];
      if (!modifiedLogin.isDeleted && ((_a3 = modifiedLogin.linkedTo) === null || _a3 === void 0 ? void 0 : _a3.length)) {
        const redactedLogin = __rest$F(modifiedLogin, ["history", "shareLinks"]);
        const newValues = recursivelyTransformProtectedValues(redactedLogin, (pv) => protectedSecretFunctions.unprotectWithContentId(pv));
        for (const { targetVaultId, removeTime, linkedByProfileId } of modifiedLogin.linkedTo) {
          if (targetVaultId === vaultId) {
            continue;
          }
          const removedInThisChange = removeTime === modifiedLogin.updateTime;
          let update = null;
          if (removedInThisChange) {
            update = {
              type: "originUpdated",
              loginId,
              content: { isDeleted: true, isArchived: false, updateTime: modifiedLogin.updateTime }
            };
          } else if (!removeTime) {
            update = {
              type: "originUpdated",
              loginId,
              content: Object.assign(Object.assign({}, newValues), { linkedTo: void 0, linkedFrom: { originVaultId: vaultId, originPersonalProfileId, linkedByProfileId }, isDeleted: false, updateTime: modifiedLogin.updateTime })
            };
          }
          if (update) {
            result2.push({
              vaultId: targetVaultId,
              type: VaultMessageType.LINKED_LOGIN_UPDATE_V1,
              message: [update]
            });
          }
        }
      } else if (modifiedLogin.isDeleted && !!preChangeLogin) {
        if (preChangeLogin.linkedTo) {
          const update = {
            type: "originUpdated",
            loginId,
            content: { isDeleted: true, isArchived: false, updateTime: modifiedLogin.updateTime }
          };
          for (const { targetVaultId } of preChangeLogin.linkedTo) {
            if (targetVaultId === vaultId) {
              continue;
            }
            result2.push({
              vaultId: targetVaultId,
              type: VaultMessageType.LINKED_LOGIN_UPDATE_V1,
              message: [update]
            });
          }
        } else if (preChangeLogin.linkedFrom) {
          if (preChangeLogin.linkedFrom.originVaultId !== vaultId) {
            const update = {
              type: "targetDeleted",
              loginId,
              removeTime: modifiedLogin.updateTime
            };
            result2.push({
              vaultId: preChangeLogin.linkedFrom.originVaultId,
              type: VaultMessageType.LINKED_LOGIN_UPDATE_V1,
              message: [update]
            });
          }
        }
      }
    }
    return result2;
  }
  var HeymergeErrorCode;
  (function(HeymergeErrorCode2) {
    HeymergeErrorCode2[HeymergeErrorCode2["NotImplemented"] = 6000500] = "NotImplemented";
    HeymergeErrorCode2[HeymergeErrorCode2["ElementNotFound"] = 6000401] = "ElementNotFound";
    HeymergeErrorCode2[HeymergeErrorCode2["InvalidHeymergeList"] = 6000402] = "InvalidHeymergeList";
    HeymergeErrorCode2[HeymergeErrorCode2["InvalidHeymergeVaultContent"] = 6000403] = "InvalidHeymergeVaultContent";
    HeymergeErrorCode2[HeymergeErrorCode2["ElementDeleted"] = 6000404] = "ElementDeleted";
    HeymergeErrorCode2[HeymergeErrorCode2["ElementArchived"] = 6000405] = "ElementArchived";
  })(HeymergeErrorCode || (HeymergeErrorCode = {}));
  const pleaseUpdate = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
  class HeymergeDomainError extends DomainError$1 {
    constructor(code, short, userTitle, userDetail) {
      super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate);
    }
  }
  class ElementNotFoundError extends HeymergeDomainError {
    constructor(id2) {
      super(HeymergeErrorCode.ElementNotFound, `No element with id "${id2}"!`);
    }
  }
  class InvalidHeymergeListError extends HeymergeDomainError {
    constructor(description) {
      super(HeymergeErrorCode.InvalidHeymergeList, `Invalid HeymergeList: "${description}"!`);
    }
  }
  class InvalidHeymergeVaultContentError extends HeymergeDomainError {
    constructor(description) {
      super(HeymergeErrorCode.InvalidHeymergeVaultContent, `Invalid HeymergeVaultContent: "${description}"!`);
    }
  }
  class ElementDeletedError extends HeymergeDomainError {
    constructor(id2) {
      super(HeymergeErrorCode.ElementDeleted, `Element with id "${id2}" has been deleted and cannot be archived or restored!`);
    }
  }
  class ElementArchivedError extends HeymergeDomainError {
    constructor(id2) {
      super(HeymergeErrorCode.ElementArchived, `Element with id "${id2}" has been archived and cannot be modified!`);
    }
  }
  var object_hash = { exports: {} };
  (function(module2, exports2) {
    !function(e2) {
      module2.exports = e2();
    }(function() {
      return function o2(i2, u2, a) {
        function s2(n2, e3) {
          if (!u2[n2]) {
            if (!i2[n2]) {
              var t2 = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e3 && t2)
                return t2(n2, true);
              if (f2)
                return f2(n2, true);
              throw new Error("Cannot find module '" + n2 + "'");
            }
            var r2 = u2[n2] = { exports: {} };
            i2[n2][0].call(r2.exports, function(e4) {
              var t3 = i2[n2][1][e4];
              return s2(t3 || e4);
            }, r2, r2.exports, o2, i2, u2, a);
          }
          return u2[n2].exports;
        }
        for (var f2 = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < a.length; e2++)
          s2(a[e2]);
        return s2;
      }({ 1: [function(w2, b2, m2) {
        (function(e2, t2, f2, n2, r2, o2, i2, u2, a) {
          var s2 = w2("crypto");
          function l2(e3, t3) {
            return function(e4, t4) {
              var n3;
              n3 = "passthrough" !== t4.algorithm ? s2.createHash(t4.algorithm) : new y2();
              void 0 === n3.write && (n3.write = n3.update, n3.end = n3.update);
              g2(t4, n3).dispatch(e4), n3.update || n3.end("");
              if (n3.digest)
                return n3.digest("buffer" === t4.encoding ? void 0 : t4.encoding);
              var r3 = n3.read();
              return "buffer" !== t4.encoding ? r3.toString(t4.encoding) : r3;
            }(e3, t3 = h2(e3, t3));
          }
          (m2 = b2.exports = l2).sha1 = function(e3) {
            return l2(e3);
          }, m2.keys = function(e3) {
            return l2(e3, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m2.MD5 = function(e3) {
            return l2(e3, { algorithm: "md5", encoding: "hex" });
          }, m2.keysMD5 = function(e3) {
            return l2(e3, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var c2 = s2.getHashes ? s2.getHashes().slice() : ["sha1", "md5"];
          c2.push("passthrough");
          var d2 = ["buffer", "hex", "binary", "base64"];
          function h2(e3, t3) {
            t3 = t3 || {};
            var n3 = {};
            if (n3.algorithm = t3.algorithm || "sha1", n3.encoding = t3.encoding || "hex", n3.excludeValues = !!t3.excludeValues, n3.algorithm = n3.algorithm.toLowerCase(), n3.encoding = n3.encoding.toLowerCase(), n3.ignoreUnknown = true === t3.ignoreUnknown, n3.respectType = false !== t3.respectType, n3.respectFunctionNames = false !== t3.respectFunctionNames, n3.respectFunctionProperties = false !== t3.respectFunctionProperties, n3.unorderedArrays = true === t3.unorderedArrays, n3.unorderedSets = false !== t3.unorderedSets, n3.unorderedObjects = false !== t3.unorderedObjects, n3.replacer = t3.replacer || void 0, n3.excludeKeys = t3.excludeKeys || void 0, void 0 === e3)
              throw new Error("Object argument required.");
            for (var r3 = 0; r3 < c2.length; ++r3)
              c2[r3].toLowerCase() === n3.algorithm.toLowerCase() && (n3.algorithm = c2[r3]);
            if (-1 === c2.indexOf(n3.algorithm))
              throw new Error('Algorithm "' + n3.algorithm + '"  not supported. supported values: ' + c2.join(", "));
            if (-1 === d2.indexOf(n3.encoding) && "passthrough" !== n3.algorithm)
              throw new Error('Encoding "' + n3.encoding + '"  not supported. supported values: ' + d2.join(", "));
            return n3;
          }
          function p2(e3) {
            if ("function" == typeof e3) {
              return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e3));
            }
          }
          function g2(u3, t3, a2) {
            a2 = a2 || [];
            function s3(e3) {
              return t3.update ? t3.update(e3, "utf8") : t3.write(e3, "utf8");
            }
            return { dispatch: function(e3) {
              return u3.replacer && (e3 = u3.replacer(e3)), this["_" + (null === e3 ? "null" : typeof e3)](e3);
            }, _object: function(t4) {
              var e3 = Object.prototype.toString.call(t4), n3 = /\[object (.*)\]/i.exec(e3);
              n3 = (n3 = n3 ? n3[1] : "unknown:[" + e3 + "]").toLowerCase();
              var r3;
              if (0 <= (r3 = a2.indexOf(t4)))
                return this.dispatch("[CIRCULAR:" + r3 + "]");
              if (a2.push(t4), void 0 !== f2 && f2.isBuffer && f2.isBuffer(t4))
                return s3("buffer:"), s3(t4);
              if ("object" === n3 || "function" === n3 || "asyncfunction" === n3) {
                var o3 = Object.keys(t4);
                u3.unorderedObjects && (o3 = o3.sort()), false === u3.respectType || p2(t4) || o3.splice(0, 0, "prototype", "__proto__", "constructor"), u3.excludeKeys && (o3 = o3.filter(function(e4) {
                  return !u3.excludeKeys(e4);
                })), s3("object:" + o3.length + ":");
                var i3 = this;
                return o3.forEach(function(e4) {
                  i3.dispatch(e4), s3(":"), u3.excludeValues || i3.dispatch(t4[e4]), s3(",");
                });
              }
              if (!this["_" + n3]) {
                if (u3.ignoreUnknown)
                  return s3("[" + n3 + "]");
                throw new Error('Unknown object type "' + n3 + '"');
              }
              this["_" + n3](t4);
            }, _array: function(e3, t4) {
              t4 = void 0 !== t4 ? t4 : false !== u3.unorderedArrays;
              var n3 = this;
              if (s3("array:" + e3.length + ":"), !t4 || e3.length <= 1)
                return e3.forEach(function(e4) {
                  return n3.dispatch(e4);
                });
              var r3 = [], o3 = e3.map(function(e4) {
                var t5 = new y2(), n4 = a2.slice();
                return g2(u3, t5, n4).dispatch(e4), r3 = r3.concat(n4.slice(a2.length)), t5.read().toString();
              });
              return a2 = a2.concat(r3), o3.sort(), this._array(o3, false);
            }, _date: function(e3) {
              return s3("date:" + e3.toJSON());
            }, _symbol: function(e3) {
              return s3("symbol:" + e3.toString());
            }, _error: function(e3) {
              return s3("error:" + e3.toString());
            }, _boolean: function(e3) {
              return s3("bool:" + e3.toString());
            }, _string: function(e3) {
              s3("string:" + e3.length + ":"), s3(e3.toString());
            }, _function: function(e3) {
              s3("fn:"), p2(e3) ? this.dispatch("[native]") : this.dispatch(e3.toString()), false !== u3.respectFunctionNames && this.dispatch("function-name:" + String(e3.name)), u3.respectFunctionProperties && this._object(e3);
            }, _number: function(e3) {
              return s3("number:" + e3.toString());
            }, _xml: function(e3) {
              return s3("xml:" + e3.toString());
            }, _null: function() {
              return s3("Null");
            }, _undefined: function() {
              return s3("Undefined");
            }, _regexp: function(e3) {
              return s3("regex:" + e3.toString());
            }, _uint8array: function(e3) {
              return s3("uint8array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _uint8clampedarray: function(e3) {
              return s3("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _int8array: function(e3) {
              return s3("uint8array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _uint16array: function(e3) {
              return s3("uint16array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _int16array: function(e3) {
              return s3("uint16array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _uint32array: function(e3) {
              return s3("uint32array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _int32array: function(e3) {
              return s3("uint32array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _float32array: function(e3) {
              return s3("float32array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _float64array: function(e3) {
              return s3("float64array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _arraybuffer: function(e3) {
              return s3("arraybuffer:"), this.dispatch(new Uint8Array(e3));
            }, _url: function(e3) {
              return s3("url:" + e3.toString());
            }, _map: function(e3) {
              s3("map:");
              var t4 = Array.from(e3);
              return this._array(t4, false !== u3.unorderedSets);
            }, _set: function(e3) {
              s3("set:");
              var t4 = Array.from(e3);
              return this._array(t4, false !== u3.unorderedSets);
            }, _file: function(e3) {
              return s3("file:"), this.dispatch([e3.name, e3.size, e3.type, e3.lastModfied]);
            }, _blob: function() {
              if (u3.ignoreUnknown)
                return s3("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return s3("domwindow");
            }, _process: function() {
              return s3("process");
            }, _timer: function() {
              return s3("timer");
            }, _pipe: function() {
              return s3("pipe");
            }, _tcp: function() {
              return s3("tcp");
            }, _udp: function() {
              return s3("udp");
            }, _tty: function() {
              return s3("tty");
            }, _statwatcher: function() {
              return s3("statwatcher");
            }, _securecontext: function() {
              return s3("securecontext");
            }, _connection: function() {
              return s3("connection");
            }, _zlib: function() {
              return s3("zlib");
            }, _context: function() {
              return s3("context");
            }, _nodescript: function() {
              return s3("nodescript");
            }, _httpparser: function() {
              return s3("httpparser");
            }, _dataview: function() {
              return s3("dataview");
            }, _signal: function() {
              return s3("signal");
            }, _fsevent: function() {
              return s3("fsevent");
            }, _tlswrap: function() {
              return s3("tlswrap");
            } };
          }
          function y2() {
            return { buf: "", write: function(e3) {
              this.buf += e3;
            }, end: function(e3) {
              this.buf += e3;
            }, read: function() {
              return this.buf;
            } };
          }
          m2.writeToStream = function(e3, t3, n3) {
            return void 0 === n3 && (n3 = t3, t3 = {}), g2(t3 = h2(e3, t3), n3).dispatch(e3);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_5812b7fb.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 10 }], 2: [function(e2, t2, f2) {
        (function(e3, t3, n2, r2, o2, i2, u2, a, s2) {
          !function(e4) {
            var f3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, n3 = "+".charCodeAt(0), r3 = "/".charCodeAt(0), o3 = "0".charCodeAt(0), i3 = "a".charCodeAt(0), u3 = "A".charCodeAt(0), a2 = "-".charCodeAt(0), s3 = "_".charCodeAt(0);
            function l2(e5) {
              var t4 = e5.charCodeAt(0);
              return t4 === n3 || t4 === a2 ? 62 : t4 === r3 || t4 === s3 ? 63 : t4 < o3 ? -1 : t4 < o3 + 10 ? t4 - o3 + 26 + 26 : t4 < u3 + 26 ? t4 - u3 : t4 < i3 + 26 ? t4 - i3 + 26 : void 0;
            }
            e4.toByteArray = function(e5) {
              var t4, n4;
              if (0 < e5.length % 4)
                throw new Error("Invalid string. Length must be a multiple of 4");
              var r4 = e5.length, o4 = "=" === e5.charAt(r4 - 2) ? 2 : "=" === e5.charAt(r4 - 1) ? 1 : 0, i4 = new f3(3 * e5.length / 4 - o4), u4 = 0 < o4 ? e5.length - 4 : e5.length, a3 = 0;
              function s4(e6) {
                i4[a3++] = e6;
              }
              for (t4 = 0; t4 < u4; t4 += 4, 0)
                s4((16711680 & (n4 = l2(e5.charAt(t4)) << 18 | l2(e5.charAt(t4 + 1)) << 12 | l2(e5.charAt(t4 + 2)) << 6 | l2(e5.charAt(t4 + 3)))) >> 16), s4((65280 & n4) >> 8), s4(255 & n4);
              return 2 == o4 ? s4(255 & (n4 = l2(e5.charAt(t4)) << 2 | l2(e5.charAt(t4 + 1)) >> 4)) : 1 == o4 && (s4((n4 = l2(e5.charAt(t4)) << 10 | l2(e5.charAt(t4 + 1)) << 4 | l2(e5.charAt(t4 + 2)) >> 2) >> 8 & 255), s4(255 & n4)), i4;
            }, e4.fromByteArray = function(e5) {
              var t4, n4, r4, o4, i4 = e5.length % 3, u4 = "";
              function a3(e6) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e6);
              }
              for (t4 = 0, r4 = e5.length - i4; t4 < r4; t4 += 3)
                n4 = (e5[t4] << 16) + (e5[t4 + 1] << 8) + e5[t4 + 2], u4 += a3((o4 = n4) >> 18 & 63) + a3(o4 >> 12 & 63) + a3(o4 >> 6 & 63) + a3(63 & o4);
              switch (i4) {
                case 1:
                  u4 += a3((n4 = e5[e5.length - 1]) >> 2), u4 += a3(n4 << 4 & 63), u4 += "==";
                  break;
                case 2:
                  u4 += a3((n4 = (e5[e5.length - 2] << 8) + e5[e5.length - 1]) >> 10), u4 += a3(n4 >> 4 & 63), u4 += a3(n4 << 2 & 63), u4 += "=";
              }
              return u4;
            };
          }(void 0 === f2 ? this.base64js = {} : f2);
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 10 }], 3: [function(O2, e2, H2) {
        (function(e3, t2, g2, n2, r2, o2, i2, u2, a) {
          var s2 = O2("base64-js"), f2 = O2("ieee754");
          function g2(e4, t3, n3) {
            if (!(this instanceof g2))
              return new g2(e4, t3, n3);
            var r3, o3, i3, u3, a2, s3 = typeof e4;
            if ("base64" === t3 && "string" == s3)
              for (e4 = (r3 = e4).trim ? r3.trim() : r3.replace(/^\s+|\s+$/g, ""); e4.length % 4 != 0; )
                e4 += "=";
            if ("number" == s3)
              o3 = x2(e4);
            else if ("string" == s3)
              o3 = g2.byteLength(e4, t3);
            else {
              if ("object" != s3)
                throw new Error("First argument needs to be a number, array or string.");
              o3 = x2(e4.length);
            }
            if (g2._useTypedArrays ? i3 = g2._augment(new Uint8Array(o3)) : ((i3 = this).length = o3, i3._isBuffer = true), g2._useTypedArrays && "number" == typeof e4.byteLength)
              i3._set(e4);
            else if (S2(a2 = e4) || g2.isBuffer(a2) || a2 && "object" == typeof a2 && "number" == typeof a2.length)
              for (u3 = 0; u3 < o3; u3++)
                g2.isBuffer(e4) ? i3[u3] = e4.readUInt8(u3) : i3[u3] = e4[u3];
            else if ("string" == s3)
              i3.write(e4, 0, t3);
            else if ("number" == s3 && !g2._useTypedArrays && !n3)
              for (u3 = 0; u3 < o3; u3++)
                i3[u3] = 0;
            return i3;
          }
          function y2(e4, t3, n3, r3) {
            return g2._charsWritten = T2(function(e5) {
              for (var t4 = [], n4 = 0; n4 < e5.length; n4++)
                t4.push(255 & e5.charCodeAt(n4));
              return t4;
            }(t3), e4, n3, r3);
          }
          function w2(e4, t3, n3, r3) {
            return g2._charsWritten = T2(function(e5) {
              for (var t4, n4, r4, o3 = [], i3 = 0; i3 < e5.length; i3++)
                t4 = e5.charCodeAt(i3), n4 = t4 >> 8, r4 = t4 % 256, o3.push(r4), o3.push(n4);
              return o3;
            }(t3), e4, n3, r3);
          }
          function l2(e4, t3, n3) {
            var r3 = "";
            n3 = Math.min(e4.length, n3);
            for (var o3 = t3; o3 < n3; o3++)
              r3 += String.fromCharCode(e4[o3]);
            return r3;
          }
          function c2(e4, t3, n3, r3) {
            r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(null != t3, "missing offset"), D2(t3 + 1 < e4.length, "Trying to read beyond buffer length"));
            var o3, i3 = e4.length;
            if (!(i3 <= t3))
              return n3 ? (o3 = e4[t3], t3 + 1 < i3 && (o3 |= e4[t3 + 1] << 8)) : (o3 = e4[t3] << 8, t3 + 1 < i3 && (o3 |= e4[t3 + 1])), o3;
          }
          function d2(e4, t3, n3, r3) {
            r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(null != t3, "missing offset"), D2(t3 + 3 < e4.length, "Trying to read beyond buffer length"));
            var o3, i3 = e4.length;
            if (!(i3 <= t3))
              return n3 ? (t3 + 2 < i3 && (o3 = e4[t3 + 2] << 16), t3 + 1 < i3 && (o3 |= e4[t3 + 1] << 8), o3 |= e4[t3], t3 + 3 < i3 && (o3 += e4[t3 + 3] << 24 >>> 0)) : (t3 + 1 < i3 && (o3 = e4[t3 + 1] << 16), t3 + 2 < i3 && (o3 |= e4[t3 + 2] << 8), t3 + 3 < i3 && (o3 |= e4[t3 + 3]), o3 += e4[t3] << 24 >>> 0), o3;
          }
          function h2(e4, t3, n3, r3) {
            if (r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(null != t3, "missing offset"), D2(t3 + 1 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) {
              var o3 = c2(e4, t3, n3, true);
              return 32768 & o3 ? -1 * (65535 - o3 + 1) : o3;
            }
          }
          function p2(e4, t3, n3, r3) {
            if (r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(null != t3, "missing offset"), D2(t3 + 3 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) {
              var o3 = d2(e4, t3, n3, true);
              return 2147483648 & o3 ? -1 * (4294967295 - o3 + 1) : o3;
            }
          }
          function b2(e4, t3, n3, r3) {
            return r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(t3 + 3 < e4.length, "Trying to read beyond buffer length")), f2.read(e4, t3, n3, 23, 4);
          }
          function m2(e4, t3, n3, r3) {
            return r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(t3 + 7 < e4.length, "Trying to read beyond buffer length")), f2.read(e4, t3, n3, 52, 8);
          }
          function v2(e4, t3, n3, r3, o3) {
            o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 1 < e4.length, "trying to write beyond buffer length"), N2(t3, 65535));
            var i3 = e4.length;
            if (!(i3 <= n3))
              for (var u3 = 0, a2 = Math.min(i3 - n3, 2); u3 < a2; u3++)
                e4[n3 + u3] = (t3 & 255 << 8 * (r3 ? u3 : 1 - u3)) >>> 8 * (r3 ? u3 : 1 - u3);
          }
          function _2(e4, t3, n3, r3, o3) {
            o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 3 < e4.length, "trying to write beyond buffer length"), N2(t3, 4294967295));
            var i3 = e4.length;
            if (!(i3 <= n3))
              for (var u3 = 0, a2 = Math.min(i3 - n3, 4); u3 < a2; u3++)
                e4[n3 + u3] = t3 >>> 8 * (r3 ? u3 : 3 - u3) & 255;
          }
          function E2(e4, t3, n3, r3, o3) {
            o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 1 < e4.length, "Trying to write beyond buffer length"), Y2(t3, 32767, -32768)), e4.length <= n3 || v2(e4, 0 <= t3 ? t3 : 65535 + t3 + 1, n3, r3, o3);
          }
          function I2(e4, t3, n3, r3, o3) {
            o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 3 < e4.length, "Trying to write beyond buffer length"), Y2(t3, 2147483647, -2147483648)), e4.length <= n3 || _2(e4, 0 <= t3 ? t3 : 4294967295 + t3 + 1, n3, r3, o3);
          }
          function A2(e4, t3, n3, r3, o3) {
            o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 3 < e4.length, "Trying to write beyond buffer length"), F2(t3, 34028234663852886e22, -34028234663852886e22)), e4.length <= n3 || f2.write(e4, t3, n3, r3, 23, 4);
          }
          function B2(e4, t3, n3, r3, o3) {
            o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 7 < e4.length, "Trying to write beyond buffer length"), F2(t3, 17976931348623157e292, -17976931348623157e292)), e4.length <= n3 || f2.write(e4, t3, n3, r3, 52, 8);
          }
          H2.Buffer = g2, H2.SlowBuffer = g2, H2.INSPECT_MAX_BYTES = 50, g2.poolSize = 8192, g2._useTypedArrays = function() {
            try {
              var e4 = new ArrayBuffer(0), t3 = new Uint8Array(e4);
              return t3.foo = function() {
                return 42;
              }, 42 === t3.foo() && "function" == typeof t3.subarray;
            } catch (e5) {
              return false;
            }
          }(), g2.isEncoding = function(e4) {
            switch (String(e4).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, g2.isBuffer = function(e4) {
            return !(null == e4 || !e4._isBuffer);
          }, g2.byteLength = function(e4, t3) {
            var n3;
            switch (e4 += "", t3 || "utf8") {
              case "hex":
                n3 = e4.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n3 = C2(e4).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n3 = e4.length;
                break;
              case "base64":
                n3 = k2(e4).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n3 = 2 * e4.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n3;
          }, g2.concat = function(e4, t3) {
            if (D2(S2(e4), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e4.length)
              return new g2(0);
            if (1 === e4.length)
              return e4[0];
            if ("number" != typeof t3)
              for (o3 = t3 = 0; o3 < e4.length; o3++)
                t3 += e4[o3].length;
            for (var n3 = new g2(t3), r3 = 0, o3 = 0; o3 < e4.length; o3++) {
              var i3 = e4[o3];
              i3.copy(n3, r3), r3 += i3.length;
            }
            return n3;
          }, g2.prototype.write = function(e4, t3, n3, r3) {
            var o3;
            isFinite(t3) ? isFinite(n3) || (r3 = n3, n3 = void 0) : (o3 = r3, r3 = t3, t3 = n3, n3 = o3), t3 = Number(t3) || 0;
            var i3, u3, a2, s3, f3, l3, c3, d3, h3, p3 = this.length - t3;
            switch ((!n3 || p3 < (n3 = Number(n3))) && (n3 = p3), r3 = String(r3 || "utf8").toLowerCase()) {
              case "hex":
                i3 = function(e5, t4, n4, r4) {
                  n4 = Number(n4) || 0;
                  var o4 = e5.length - n4;
                  (!r4 || o4 < (r4 = Number(r4))) && (r4 = o4);
                  var i4 = t4.length;
                  D2(i4 % 2 == 0, "Invalid hex string"), i4 / 2 < r4 && (r4 = i4 / 2);
                  for (var u4 = 0; u4 < r4; u4++) {
                    var a3 = parseInt(t4.substr(2 * u4, 2), 16);
                    D2(!isNaN(a3), "Invalid hex string"), e5[n4 + u4] = a3;
                  }
                  return g2._charsWritten = 2 * u4, u4;
                }(this, e4, t3, n3);
                break;
              case "utf8":
              case "utf-8":
                l3 = this, c3 = e4, d3 = t3, h3 = n3, i3 = g2._charsWritten = T2(C2(c3), l3, d3, h3);
                break;
              case "ascii":
              case "binary":
                i3 = y2(this, e4, t3, n3);
                break;
              case "base64":
                u3 = this, a2 = e4, s3 = t3, f3 = n3, i3 = g2._charsWritten = T2(k2(a2), u3, s3, f3);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                i3 = w2(this, e4, t3, n3);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return i3;
          }, g2.prototype.toString = function(e4, t3, n3) {
            var r3, o3, i3, u3, a2 = this;
            if (e4 = String(e4 || "utf8").toLowerCase(), t3 = Number(t3) || 0, (n3 = void 0 !== n3 ? Number(n3) : n3 = a2.length) === t3)
              return "";
            switch (e4) {
              case "hex":
                r3 = function(e5, t4, n4) {
                  var r4 = e5.length;
                  (!t4 || t4 < 0) && (t4 = 0);
                  (!n4 || n4 < 0 || r4 < n4) && (n4 = r4);
                  for (var o4 = "", i4 = t4; i4 < n4; i4++)
                    o4 += j(e5[i4]);
                  return o4;
                }(a2, t3, n3);
                break;
              case "utf8":
              case "utf-8":
                r3 = function(e5, t4, n4) {
                  var r4 = "", o4 = "";
                  n4 = Math.min(e5.length, n4);
                  for (var i4 = t4; i4 < n4; i4++)
                    e5[i4] <= 127 ? (r4 += M2(o4) + String.fromCharCode(e5[i4]), o4 = "") : o4 += "%" + e5[i4].toString(16);
                  return r4 + M2(o4);
                }(a2, t3, n3);
                break;
              case "ascii":
              case "binary":
                r3 = l2(a2, t3, n3);
                break;
              case "base64":
                o3 = a2, u3 = n3, r3 = 0 === (i3 = t3) && u3 === o3.length ? s2.fromByteArray(o3) : s2.fromByteArray(o3.slice(i3, u3));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r3 = function(e5, t4, n4) {
                  for (var r4 = e5.slice(t4, n4), o4 = "", i4 = 0; i4 < r4.length; i4 += 2)
                    o4 += String.fromCharCode(r4[i4] + 256 * r4[i4 + 1]);
                  return o4;
                }(a2, t3, n3);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r3;
          }, g2.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, g2.prototype.copy = function(e4, t3, n3, r3) {
            if (n3 = n3 || 0, r3 || 0 === r3 || (r3 = this.length), t3 = t3 || 0, r3 !== n3 && 0 !== e4.length && 0 !== this.length) {
              D2(n3 <= r3, "sourceEnd < sourceStart"), D2(0 <= t3 && t3 < e4.length, "targetStart out of bounds"), D2(0 <= n3 && n3 < this.length, "sourceStart out of bounds"), D2(0 <= r3 && r3 <= this.length, "sourceEnd out of bounds"), r3 > this.length && (r3 = this.length), e4.length - t3 < r3 - n3 && (r3 = e4.length - t3 + n3);
              var o3 = r3 - n3;
              if (o3 < 100 || !g2._useTypedArrays)
                for (var i3 = 0; i3 < o3; i3++)
                  e4[i3 + t3] = this[i3 + n3];
              else
                e4._set(this.subarray(n3, n3 + o3), t3);
            }
          }, g2.prototype.slice = function(e4, t3) {
            var n3 = this.length;
            if (e4 = U2(e4, n3, 0), t3 = U2(t3, n3, n3), g2._useTypedArrays)
              return g2._augment(this.subarray(e4, t3));
            for (var r3 = t3 - e4, o3 = new g2(r3, void 0, true), i3 = 0; i3 < r3; i3++)
              o3[i3] = this[i3 + e4];
            return o3;
          }, g2.prototype.get = function(e4) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e4);
          }, g2.prototype.set = function(e4, t3) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e4, t3);
          }, g2.prototype.readUInt8 = function(e4, t3) {
            if (t3 || (D2(null != e4, "missing offset"), D2(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length))
              return this[e4];
          }, g2.prototype.readUInt16LE = function(e4, t3) {
            return c2(this, e4, true, t3);
          }, g2.prototype.readUInt16BE = function(e4, t3) {
            return c2(this, e4, false, t3);
          }, g2.prototype.readUInt32LE = function(e4, t3) {
            return d2(this, e4, true, t3);
          }, g2.prototype.readUInt32BE = function(e4, t3) {
            return d2(this, e4, false, t3);
          }, g2.prototype.readInt8 = function(e4, t3) {
            if (t3 || (D2(null != e4, "missing offset"), D2(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length))
              return 128 & this[e4] ? -1 * (255 - this[e4] + 1) : this[e4];
          }, g2.prototype.readInt16LE = function(e4, t3) {
            return h2(this, e4, true, t3);
          }, g2.prototype.readInt16BE = function(e4, t3) {
            return h2(this, e4, false, t3);
          }, g2.prototype.readInt32LE = function(e4, t3) {
            return p2(this, e4, true, t3);
          }, g2.prototype.readInt32BE = function(e4, t3) {
            return p2(this, e4, false, t3);
          }, g2.prototype.readFloatLE = function(e4, t3) {
            return b2(this, e4, true, t3);
          }, g2.prototype.readFloatBE = function(e4, t3) {
            return b2(this, e4, false, t3);
          }, g2.prototype.readDoubleLE = function(e4, t3) {
            return m2(this, e4, true, t3);
          }, g2.prototype.readDoubleBE = function(e4, t3) {
            return m2(this, e4, false, t3);
          }, g2.prototype.writeUInt8 = function(e4, t3, n3) {
            n3 || (D2(null != e4, "missing value"), D2(null != t3, "missing offset"), D2(t3 < this.length, "trying to write beyond buffer length"), N2(e4, 255)), t3 >= this.length || (this[t3] = e4);
          }, g2.prototype.writeUInt16LE = function(e4, t3, n3) {
            v2(this, e4, t3, true, n3);
          }, g2.prototype.writeUInt16BE = function(e4, t3, n3) {
            v2(this, e4, t3, false, n3);
          }, g2.prototype.writeUInt32LE = function(e4, t3, n3) {
            _2(this, e4, t3, true, n3);
          }, g2.prototype.writeUInt32BE = function(e4, t3, n3) {
            _2(this, e4, t3, false, n3);
          }, g2.prototype.writeInt8 = function(e4, t3, n3) {
            n3 || (D2(null != e4, "missing value"), D2(null != t3, "missing offset"), D2(t3 < this.length, "Trying to write beyond buffer length"), Y2(e4, 127, -128)), t3 >= this.length || (0 <= e4 ? this.writeUInt8(e4, t3, n3) : this.writeUInt8(255 + e4 + 1, t3, n3));
          }, g2.prototype.writeInt16LE = function(e4, t3, n3) {
            E2(this, e4, t3, true, n3);
          }, g2.prototype.writeInt16BE = function(e4, t3, n3) {
            E2(this, e4, t3, false, n3);
          }, g2.prototype.writeInt32LE = function(e4, t3, n3) {
            I2(this, e4, t3, true, n3);
          }, g2.prototype.writeInt32BE = function(e4, t3, n3) {
            I2(this, e4, t3, false, n3);
          }, g2.prototype.writeFloatLE = function(e4, t3, n3) {
            A2(this, e4, t3, true, n3);
          }, g2.prototype.writeFloatBE = function(e4, t3, n3) {
            A2(this, e4, t3, false, n3);
          }, g2.prototype.writeDoubleLE = function(e4, t3, n3) {
            B2(this, e4, t3, true, n3);
          }, g2.prototype.writeDoubleBE = function(e4, t3, n3) {
            B2(this, e4, t3, false, n3);
          }, g2.prototype.fill = function(e4, t3, n3) {
            if (e4 = e4 || 0, t3 = t3 || 0, n3 = n3 || this.length, "string" == typeof e4 && (e4 = e4.charCodeAt(0)), D2("number" == typeof e4 && !isNaN(e4), "value is not a number"), D2(t3 <= n3, "end < start"), n3 !== t3 && 0 !== this.length) {
              D2(0 <= t3 && t3 < this.length, "start out of bounds"), D2(0 <= n3 && n3 <= this.length, "end out of bounds");
              for (var r3 = t3; r3 < n3; r3++)
                this[r3] = e4;
            }
          }, g2.prototype.inspect = function() {
            for (var e4 = [], t3 = this.length, n3 = 0; n3 < t3; n3++)
              if (e4[n3] = j(this[n3]), n3 === H2.INSPECT_MAX_BYTES) {
                e4[n3 + 1] = "...";
                break;
              }
            return "<Buffer " + e4.join(" ") + ">";
          }, g2.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array)
              throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (g2._useTypedArrays)
              return new g2(this).buffer;
            for (var e4 = new Uint8Array(this.length), t3 = 0, n3 = e4.length; t3 < n3; t3 += 1)
              e4[t3] = this[t3];
            return e4.buffer;
          };
          var L2 = g2.prototype;
          function U2(e4, t3, n3) {
            return "number" != typeof e4 ? n3 : t3 <= (e4 = ~~e4) ? t3 : 0 <= e4 || 0 <= (e4 += t3) ? e4 : 0;
          }
          function x2(e4) {
            return (e4 = ~~Math.ceil(+e4)) < 0 ? 0 : e4;
          }
          function S2(e4) {
            return (Array.isArray || function(e5) {
              return "[object Array]" === Object.prototype.toString.call(e5);
            })(e4);
          }
          function j(e4) {
            return e4 < 16 ? "0" + e4.toString(16) : e4.toString(16);
          }
          function C2(e4) {
            for (var t3 = [], n3 = 0; n3 < e4.length; n3++) {
              var r3 = e4.charCodeAt(n3);
              if (r3 <= 127)
                t3.push(e4.charCodeAt(n3));
              else {
                var o3 = n3;
                55296 <= r3 && r3 <= 57343 && n3++;
                for (var i3 = encodeURIComponent(e4.slice(o3, n3 + 1)).substr(1).split("%"), u3 = 0; u3 < i3.length; u3++)
                  t3.push(parseInt(i3[u3], 16));
              }
            }
            return t3;
          }
          function k2(e4) {
            return s2.toByteArray(e4);
          }
          function T2(e4, t3, n3, r3) {
            for (var o3 = 0; o3 < r3 && !(o3 + n3 >= t3.length || o3 >= e4.length); o3++)
              t3[o3 + n3] = e4[o3];
            return o3;
          }
          function M2(e4) {
            try {
              return decodeURIComponent(e4);
            } catch (e5) {
              return String.fromCharCode(65533);
            }
          }
          function N2(e4, t3) {
            D2("number" == typeof e4, "cannot write a non-number as a number"), D2(0 <= e4, "specified a negative value for writing an unsigned value"), D2(e4 <= t3, "value is larger than maximum value for type"), D2(Math.floor(e4) === e4, "value has a fractional component");
          }
          function Y2(e4, t3, n3) {
            D2("number" == typeof e4, "cannot write a non-number as a number"), D2(e4 <= t3, "value larger than maximum allowed value"), D2(n3 <= e4, "value smaller than minimum allowed value"), D2(Math.floor(e4) === e4, "value has a fractional component");
          }
          function F2(e4, t3, n3) {
            D2("number" == typeof e4, "cannot write a non-number as a number"), D2(e4 <= t3, "value larger than maximum allowed value"), D2(n3 <= e4, "value smaller than minimum allowed value");
          }
          function D2(e4, t3) {
            if (!e4)
              throw new Error(t3 || "Failed assertion");
          }
          g2._augment = function(e4) {
            return e4._isBuffer = true, e4._get = e4.get, e4._set = e4.set, e4.get = L2.get, e4.set = L2.set, e4.write = L2.write, e4.toString = L2.toString, e4.toLocaleString = L2.toString, e4.toJSON = L2.toJSON, e4.copy = L2.copy, e4.slice = L2.slice, e4.readUInt8 = L2.readUInt8, e4.readUInt16LE = L2.readUInt16LE, e4.readUInt16BE = L2.readUInt16BE, e4.readUInt32LE = L2.readUInt32LE, e4.readUInt32BE = L2.readUInt32BE, e4.readInt8 = L2.readInt8, e4.readInt16LE = L2.readInt16LE, e4.readInt16BE = L2.readInt16BE, e4.readInt32LE = L2.readInt32LE, e4.readInt32BE = L2.readInt32BE, e4.readFloatLE = L2.readFloatLE, e4.readFloatBE = L2.readFloatBE, e4.readDoubleLE = L2.readDoubleLE, e4.readDoubleBE = L2.readDoubleBE, e4.writeUInt8 = L2.writeUInt8, e4.writeUInt16LE = L2.writeUInt16LE, e4.writeUInt16BE = L2.writeUInt16BE, e4.writeUInt32LE = L2.writeUInt32LE, e4.writeUInt32BE = L2.writeUInt32BE, e4.writeInt8 = L2.writeInt8, e4.writeInt16LE = L2.writeInt16LE, e4.writeInt16BE = L2.writeInt16BE, e4.writeInt32LE = L2.writeInt32LE, e4.writeInt32BE = L2.writeInt32BE, e4.writeFloatLE = L2.writeFloatLE, e4.writeFloatBE = L2.writeFloatBE, e4.writeDoubleLE = L2.writeDoubleLE, e4.writeDoubleBE = L2.writeDoubleBE, e4.fill = L2.fill, e4.inspect = L2.inspect, e4.toArrayBuffer = L2.toArrayBuffer, e4;
          };
        }).call(this, O2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 11, lYpoI2: 10 }], 4: [function(c2, d2, e2) {
        (function(e3, t2, u2, n2, r2, o2, i2, a, s2) {
          var u2 = c2("buffer").Buffer, f2 = 4, l2 = new u2(f2);
          l2.fill(0);
          d2.exports = { hash: function(e4, t3, n3, r3) {
            return u2.isBuffer(e4) || (e4 = new u2(e4)), function(e5, t4, n4) {
              for (var r4 = new u2(t4), o3 = n4 ? r4.writeInt32BE : r4.writeInt32LE, i3 = 0; i3 < e5.length; i3++)
                o3.call(r4, e5[i3], 4 * i3, true);
              return r4;
            }(t3(function(e5, t4) {
              var n4;
              e5.length % f2 != 0 && (n4 = e5.length + (f2 - e5.length % f2), e5 = u2.concat([e5, l2], n4));
              for (var r4 = [], o3 = t4 ? e5.readInt32BE : e5.readInt32LE, i3 = 0; i3 < e5.length; i3 += f2)
                r4.push(o3.call(e5, i3));
              return r4;
            }(e4, r3), 8 * e4.length), n3, r3);
          } };
        }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 10 }], 5: [function(w2, e2, b2) {
        (function(e3, t2, a, n2, r2, o2, i2, u2, s2) {
          var a = w2("buffer").Buffer, f2 = w2("./sha"), l2 = w2("./sha256"), c2 = w2("./rng"), d2 = { sha1: f2, sha256: l2, md5: w2("./md5") }, h2 = 64, p2 = new a(h2);
          function g2(e4, r3) {
            var o3 = d2[e4 = e4 || "sha1"], i3 = [];
            return o3 || y2("algorithm:", e4, "is not yet supported"), { update: function(e5) {
              return a.isBuffer(e5) || (e5 = new a(e5)), i3.push(e5), e5.length, this;
            }, digest: function(e5) {
              var t3 = a.concat(i3), n3 = r3 ? function(e6, t4, n4) {
                a.isBuffer(t4) || (t4 = new a(t4)), a.isBuffer(n4) || (n4 = new a(n4)), t4.length > h2 ? t4 = e6(t4) : t4.length < h2 && (t4 = a.concat([t4, p2], h2));
                for (var r4 = new a(h2), o4 = new a(h2), i4 = 0; i4 < h2; i4++)
                  r4[i4] = 54 ^ t4[i4], o4[i4] = 92 ^ t4[i4];
                var u3 = e6(a.concat([r4, n4]));
                return e6(a.concat([o4, u3]));
              }(o3, r3, t3) : o3(t3);
              return i3 = null, e5 ? n3.toString(e5) : n3;
            } };
          }
          function y2() {
            var e4 = [].slice.call(arguments).join(" ");
            throw new Error([e4, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          p2.fill(0), b2.createHash = function(e4) {
            return g2(e4);
          }, b2.createHmac = g2, b2.randomBytes = function(e4, t3) {
            if (!t3 || !t3.call)
              return new a(c2(e4));
            try {
              t3.call(this, void 0, new a(c2(e4)));
            } catch (e5) {
              t3(e5);
            }
          }, function(e4, t3) {
            for (var n3 in e4)
              t3(e4[n3], n3);
          }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function(e4) {
            b2[e4] = function() {
              y2("sorry,", e4, "is not implemented yet");
            };
          });
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 10 }], 6: [function(w2, b2, e2) {
        (function(e3, t2, n2, r2, o2, i2, u2, a, s2) {
          var f2 = w2("./helpers");
          function l2(e4, t3) {
            e4[t3 >> 5] |= 128 << t3 % 32, e4[14 + (t3 + 64 >>> 9 << 4)] = t3;
            for (var n3 = 1732584193, r3 = -271733879, o3 = -1732584194, i3 = 271733878, u3 = 0; u3 < e4.length; u3 += 16) {
              var a2 = n3, s3 = r3, f3 = o3, l3 = i3, n3 = d2(n3, r3, o3, i3, e4[u3 + 0], 7, -680876936), i3 = d2(i3, n3, r3, o3, e4[u3 + 1], 12, -389564586), o3 = d2(o3, i3, n3, r3, e4[u3 + 2], 17, 606105819), r3 = d2(r3, o3, i3, n3, e4[u3 + 3], 22, -1044525330);
              n3 = d2(n3, r3, o3, i3, e4[u3 + 4], 7, -176418897), i3 = d2(i3, n3, r3, o3, e4[u3 + 5], 12, 1200080426), o3 = d2(o3, i3, n3, r3, e4[u3 + 6], 17, -1473231341), r3 = d2(r3, o3, i3, n3, e4[u3 + 7], 22, -45705983), n3 = d2(n3, r3, o3, i3, e4[u3 + 8], 7, 1770035416), i3 = d2(i3, n3, r3, o3, e4[u3 + 9], 12, -1958414417), o3 = d2(o3, i3, n3, r3, e4[u3 + 10], 17, -42063), r3 = d2(r3, o3, i3, n3, e4[u3 + 11], 22, -1990404162), n3 = d2(n3, r3, o3, i3, e4[u3 + 12], 7, 1804603682), i3 = d2(i3, n3, r3, o3, e4[u3 + 13], 12, -40341101), o3 = d2(o3, i3, n3, r3, e4[u3 + 14], 17, -1502002290), n3 = h2(n3, r3 = d2(r3, o3, i3, n3, e4[u3 + 15], 22, 1236535329), o3, i3, e4[u3 + 1], 5, -165796510), i3 = h2(i3, n3, r3, o3, e4[u3 + 6], 9, -1069501632), o3 = h2(o3, i3, n3, r3, e4[u3 + 11], 14, 643717713), r3 = h2(r3, o3, i3, n3, e4[u3 + 0], 20, -373897302), n3 = h2(n3, r3, o3, i3, e4[u3 + 5], 5, -701558691), i3 = h2(i3, n3, r3, o3, e4[u3 + 10], 9, 38016083), o3 = h2(o3, i3, n3, r3, e4[u3 + 15], 14, -660478335), r3 = h2(r3, o3, i3, n3, e4[u3 + 4], 20, -405537848), n3 = h2(n3, r3, o3, i3, e4[u3 + 9], 5, 568446438), i3 = h2(i3, n3, r3, o3, e4[u3 + 14], 9, -1019803690), o3 = h2(o3, i3, n3, r3, e4[u3 + 3], 14, -187363961), r3 = h2(r3, o3, i3, n3, e4[u3 + 8], 20, 1163531501), n3 = h2(n3, r3, o3, i3, e4[u3 + 13], 5, -1444681467), i3 = h2(i3, n3, r3, o3, e4[u3 + 2], 9, -51403784), o3 = h2(o3, i3, n3, r3, e4[u3 + 7], 14, 1735328473), n3 = p2(n3, r3 = h2(r3, o3, i3, n3, e4[u3 + 12], 20, -1926607734), o3, i3, e4[u3 + 5], 4, -378558), i3 = p2(i3, n3, r3, o3, e4[u3 + 8], 11, -2022574463), o3 = p2(o3, i3, n3, r3, e4[u3 + 11], 16, 1839030562), r3 = p2(r3, o3, i3, n3, e4[u3 + 14], 23, -35309556), n3 = p2(n3, r3, o3, i3, e4[u3 + 1], 4, -1530992060), i3 = p2(i3, n3, r3, o3, e4[u3 + 4], 11, 1272893353), o3 = p2(o3, i3, n3, r3, e4[u3 + 7], 16, -155497632), r3 = p2(r3, o3, i3, n3, e4[u3 + 10], 23, -1094730640), n3 = p2(n3, r3, o3, i3, e4[u3 + 13], 4, 681279174), i3 = p2(i3, n3, r3, o3, e4[u3 + 0], 11, -358537222), o3 = p2(o3, i3, n3, r3, e4[u3 + 3], 16, -722521979), r3 = p2(r3, o3, i3, n3, e4[u3 + 6], 23, 76029189), n3 = p2(n3, r3, o3, i3, e4[u3 + 9], 4, -640364487), i3 = p2(i3, n3, r3, o3, e4[u3 + 12], 11, -421815835), o3 = p2(o3, i3, n3, r3, e4[u3 + 15], 16, 530742520), n3 = g2(n3, r3 = p2(r3, o3, i3, n3, e4[u3 + 2], 23, -995338651), o3, i3, e4[u3 + 0], 6, -198630844), i3 = g2(i3, n3, r3, o3, e4[u3 + 7], 10, 1126891415), o3 = g2(o3, i3, n3, r3, e4[u3 + 14], 15, -1416354905), r3 = g2(r3, o3, i3, n3, e4[u3 + 5], 21, -57434055), n3 = g2(n3, r3, o3, i3, e4[u3 + 12], 6, 1700485571), i3 = g2(i3, n3, r3, o3, e4[u3 + 3], 10, -1894986606), o3 = g2(o3, i3, n3, r3, e4[u3 + 10], 15, -1051523), r3 = g2(r3, o3, i3, n3, e4[u3 + 1], 21, -2054922799), n3 = g2(n3, r3, o3, i3, e4[u3 + 8], 6, 1873313359), i3 = g2(i3, n3, r3, o3, e4[u3 + 15], 10, -30611744), o3 = g2(o3, i3, n3, r3, e4[u3 + 6], 15, -1560198380), r3 = g2(r3, o3, i3, n3, e4[u3 + 13], 21, 1309151649), n3 = g2(n3, r3, o3, i3, e4[u3 + 4], 6, -145523070), i3 = g2(i3, n3, r3, o3, e4[u3 + 11], 10, -1120210379), o3 = g2(o3, i3, n3, r3, e4[u3 + 2], 15, 718787259), r3 = g2(r3, o3, i3, n3, e4[u3 + 9], 21, -343485551), n3 = y2(n3, a2), r3 = y2(r3, s3), o3 = y2(o3, f3), i3 = y2(i3, l3);
            }
            return Array(n3, r3, o3, i3);
          }
          function c2(e4, t3, n3, r3, o3, i3) {
            return y2((u3 = y2(y2(t3, e4), y2(r3, i3))) << (a2 = o3) | u3 >>> 32 - a2, n3);
            var u3, a2;
          }
          function d2(e4, t3, n3, r3, o3, i3, u3) {
            return c2(t3 & n3 | ~t3 & r3, e4, t3, o3, i3, u3);
          }
          function h2(e4, t3, n3, r3, o3, i3, u3) {
            return c2(t3 & r3 | n3 & ~r3, e4, t3, o3, i3, u3);
          }
          function p2(e4, t3, n3, r3, o3, i3, u3) {
            return c2(t3 ^ n3 ^ r3, e4, t3, o3, i3, u3);
          }
          function g2(e4, t3, n3, r3, o3, i3, u3) {
            return c2(n3 ^ (t3 | ~r3), e4, t3, o3, i3, u3);
          }
          function y2(e4, t3) {
            var n3 = (65535 & e4) + (65535 & t3);
            return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          b2.exports = function(e4) {
            return f2.hash(e4, l2, 16);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 7: [function(e2, c2, t2) {
        (function(e3, t3, n2, r2, o2, i2, u2, a, s2) {
          var l2;
          l2 = function(e4) {
            for (var t4, n3 = new Array(e4), r3 = 0; r3 < e4; r3++)
              0 == (3 & r3) && (t4 = 4294967296 * Math.random()), n3[r3] = t4 >>> ((3 & r3) << 3) & 255;
            return n3;
          }, c2.exports = l2;
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 10 }], 8: [function(c2, d2, e2) {
        (function(e3, t2, n2, r2, o2, i2, u2, a, s2) {
          var f2 = c2("./helpers");
          function l2(e4, t3) {
            e4[t3 >> 5] |= 128 << 24 - t3 % 32, e4[15 + (t3 + 64 >> 9 << 4)] = t3;
            for (var n3, r3, o3, i3, u3, a2 = Array(80), s3 = 1732584193, f3 = -271733879, l3 = -1732584194, c3 = 271733878, d3 = -1009589776, h2 = 0; h2 < e4.length; h2 += 16) {
              for (var p2 = s3, g2 = f3, y2 = l3, w2 = c3, b2 = d3, m2 = 0; m2 < 80; m2++) {
                a2[m2] = m2 < 16 ? e4[h2 + m2] : E2(a2[m2 - 3] ^ a2[m2 - 8] ^ a2[m2 - 14] ^ a2[m2 - 16], 1);
                var v2 = _2(_2(E2(s3, 5), (o3 = f3, i3 = l3, u3 = c3, (r3 = m2) < 20 ? o3 & i3 | ~o3 & u3 : !(r3 < 40) && r3 < 60 ? o3 & i3 | o3 & u3 | i3 & u3 : o3 ^ i3 ^ u3)), _2(_2(d3, a2[m2]), (n3 = m2) < 20 ? 1518500249 : n3 < 40 ? 1859775393 : n3 < 60 ? -1894007588 : -899497514)), d3 = c3, c3 = l3, l3 = E2(f3, 30), f3 = s3, s3 = v2;
              }
              s3 = _2(s3, p2), f3 = _2(f3, g2), l3 = _2(l3, y2), c3 = _2(c3, w2), d3 = _2(d3, b2);
            }
            return Array(s3, f3, l3, c3, d3);
          }
          function _2(e4, t3) {
            var n3 = (65535 & e4) + (65535 & t3);
            return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          function E2(e4, t3) {
            return e4 << t3 | e4 >>> 32 - t3;
          }
          d2.exports = function(e4) {
            return f2.hash(e4, l2, 20, true);
          };
        }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 9: [function(c2, d2, e2) {
        (function(e3, t2, n2, r2, o2, i2, u2, a, s2) {
          function B2(e4, t3) {
            var n3 = (65535 & e4) + (65535 & t3);
            return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          function L2(e4, t3) {
            return e4 >>> t3 | e4 << 32 - t3;
          }
          function f2(e4, t3) {
            var n3, r3, o3, i3, u3, a2, s3, f3, l3, c3, d3 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), h2 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), p2 = new Array(64);
            e4[t3 >> 5] |= 128 << 24 - t3 % 32, e4[15 + (t3 + 64 >> 9 << 4)] = t3;
            for (var g2, y2, w2, b2, m2, v2, _2, E2, I2 = 0; I2 < e4.length; I2 += 16) {
              n3 = h2[0], r3 = h2[1], o3 = h2[2], i3 = h2[3], u3 = h2[4], a2 = h2[5], s3 = h2[6], f3 = h2[7];
              for (var A2 = 0; A2 < 64; A2++)
                p2[A2] = A2 < 16 ? e4[A2 + I2] : B2(B2(B2((E2 = p2[A2 - 2], L2(E2, 17) ^ L2(E2, 19) ^ E2 >>> 10), p2[A2 - 7]), (_2 = p2[A2 - 15], L2(_2, 7) ^ L2(_2, 18) ^ _2 >>> 3)), p2[A2 - 16]), l3 = B2(B2(B2(B2(f3, L2(v2 = u3, 6) ^ L2(v2, 11) ^ L2(v2, 25)), (m2 = u3) & a2 ^ ~m2 & s3), d3[A2]), p2[A2]), c3 = B2(L2(b2 = n3, 2) ^ L2(b2, 13) ^ L2(b2, 22), (g2 = n3) & (y2 = r3) ^ g2 & (w2 = o3) ^ y2 & w2), f3 = s3, s3 = a2, a2 = u3, u3 = B2(i3, l3), i3 = o3, o3 = r3, r3 = n3, n3 = B2(l3, c3);
              h2[0] = B2(n3, h2[0]), h2[1] = B2(r3, h2[1]), h2[2] = B2(o3, h2[2]), h2[3] = B2(i3, h2[3]), h2[4] = B2(u3, h2[4]), h2[5] = B2(a2, h2[5]), h2[6] = B2(s3, h2[6]), h2[7] = B2(f3, h2[7]);
            }
            return h2;
          }
          var l2 = c2("./helpers");
          d2.exports = function(e4) {
            return l2.hash(e4, f2, 32, true);
          };
        }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 10: [function(e2, l2, t2) {
        (function(e3, t3, n2, r2, o2, i2, u2, a, s2) {
          function f2() {
          }
          (e3 = l2.exports = {}).nextTick = function() {
            var e4 = "undefined" != typeof window && window.setImmediate, t4 = "undefined" != typeof window && window.postMessage && window.addEventListener;
            if (e4)
              return function(e5) {
                return window.setImmediate(e5);
              };
            if (t4) {
              var n3 = [];
              return window.addEventListener("message", function(e5) {
                var t5 = e5.source;
                t5 !== window && null !== t5 || "process-tick" !== e5.data || (e5.stopPropagation(), 0 < n3.length && n3.shift()());
              }, true), function(e5) {
                n3.push(e5), window.postMessage("process-tick", "*");
              };
            }
            return function(e5) {
              setTimeout(e5, 0);
            };
          }(), e3.title = "browser", e3.browser = true, e3.env = {}, e3.argv = [], e3.on = f2, e3.addListener = f2, e3.once = f2, e3.off = f2, e3.removeListener = f2, e3.removeAllListeners = f2, e3.emit = f2, e3.binding = function(e4) {
            throw new Error("process.binding is not supported");
          }, e3.cwd = function() {
            return "/";
          }, e3.chdir = function(e4) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 10 }], 11: [function(e2, t2, f2) {
        (function(e3, t3, n2, r2, o2, i2, u2, a, s2) {
          f2.read = function(e4, t4, n3, r3, o3) {
            var i3, u3, a2 = 8 * o3 - r3 - 1, s3 = (1 << a2) - 1, f3 = s3 >> 1, l2 = -7, c2 = n3 ? o3 - 1 : 0, d2 = n3 ? -1 : 1, h2 = e4[t4 + c2];
            for (c2 += d2, i3 = h2 & (1 << -l2) - 1, h2 >>= -l2, l2 += a2; 0 < l2; i3 = 256 * i3 + e4[t4 + c2], c2 += d2, l2 -= 8)
              ;
            for (u3 = i3 & (1 << -l2) - 1, i3 >>= -l2, l2 += r3; 0 < l2; u3 = 256 * u3 + e4[t4 + c2], c2 += d2, l2 -= 8)
              ;
            if (0 === i3)
              i3 = 1 - f3;
            else {
              if (i3 === s3)
                return u3 ? NaN : 1 / 0 * (h2 ? -1 : 1);
              u3 += Math.pow(2, r3), i3 -= f3;
            }
            return (h2 ? -1 : 1) * u3 * Math.pow(2, i3 - r3);
          }, f2.write = function(e4, t4, n3, r3, o3, i3) {
            var u3, a2, s3, f3 = 8 * i3 - o3 - 1, l2 = (1 << f3) - 1, c2 = l2 >> 1, d2 = 23 === o3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h2 = r3 ? 0 : i3 - 1, p2 = r3 ? 1 : -1, g2 = t4 < 0 || 0 === t4 && 1 / t4 < 0 ? 1 : 0;
            for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (a2 = isNaN(t4) ? 1 : 0, u3 = l2) : (u3 = Math.floor(Math.log(t4) / Math.LN2), t4 * (s3 = Math.pow(2, -u3)) < 1 && (u3--, s3 *= 2), 2 <= (t4 += 1 <= u3 + c2 ? d2 / s3 : d2 * Math.pow(2, 1 - c2)) * s3 && (u3++, s3 /= 2), l2 <= u3 + c2 ? (a2 = 0, u3 = l2) : 1 <= u3 + c2 ? (a2 = (t4 * s3 - 1) * Math.pow(2, o3), u3 += c2) : (a2 = t4 * Math.pow(2, c2 - 1) * Math.pow(2, o3), u3 = 0)); 8 <= o3; e4[n3 + h2] = 255 & a2, h2 += p2, a2 /= 256, o3 -= 8)
              ;
            for (u3 = u3 << o3 | a2, f3 += o3; 0 < f3; e4[n3 + h2] = 255 & u3, h2 += p2, u3 /= 256, f3 -= 8)
              ;
            e4[n3 + h2 - p2] |= 128 * g2;
          };
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 10 }] }, {}, [1])(1);
    });
  })(object_hash);
  var object_hashExports = object_hash.exports;
  const hash = /* @__PURE__ */ getDefaultExportFromCjs(object_hashExports);
  function chooseByUpdateTime(left, right, leftUpdateTime, rightUpdateTime) {
    if (leftUpdateTime === rightUpdateTime) {
      return hash(left) < hash(right) ? left : right;
    }
    return leftUpdateTime > rightUpdateTime ? left : right;
  }
  function newUuid() {
    return v4();
  }
  var __rest$E = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function isTombstone(element) {
    return element.isDeleted && !element.isArchived;
  }
  function isHeymergeArchivedListValue(element) {
    return element.isDeleted && !!element.isArchived;
  }
  function isHeymergeListValue(element) {
    return !element.isDeleted;
  }
  function unpackHeymergeList(list) {
    const output = {};
    for (const index2 of Object.keys(list)) {
      const item = Object.assign({}, list[index2]);
      const unpacked = unpackHeymergeListElement(item);
      if (unpacked !== void 0) {
        output[index2] = unpacked;
      }
    }
    return output;
  }
  function unpackHeymergeListElement(el2) {
    if (!isHeymergeListValue(el2)) {
      return void 0;
    }
    return unpackHeymergeListValue(el2);
  }
  function unpackHeymergeListValue(val) {
    const stripped = __rest$E(val, ["isDeleted", "updateTime"]);
    return stripped;
  }
  function unpackHeymergeListArchive(list) {
    const output = {};
    for (const index2 of Object.keys(list)) {
      const item = Object.assign({}, list[index2]);
      const unpacked = unpackHeymergeArchivedListElement(item);
      if (unpacked !== void 0) {
        output[index2] = unpacked;
      }
    }
    return output;
  }
  function unpackHeymergeArchivedListElement(el2) {
    if (!isHeymergeArchivedListValue(el2)) {
      return void 0;
    }
    return unpackHeymergeArchivedListValue(el2);
  }
  function unpackHeymergeArchivedListValue(val) {
    const stripped = __rest$E(val, ["isDeleted", "isArchived", "updateTime"]);
    return stripped;
  }
  function unpackHeymergeListElementContent(el2) {
    return isHeymergeArchivedListValue(el2) ? unpackHeymergeArchivedListValue(el2) : unpackHeymergeListValue(el2);
  }
  function addElement(list, timestamp, element) {
    const uuid = newUuid();
    const newElement = Object.assign(Object.assign({}, element), { isDeleted: false, updateTime: timestamp });
    return {
      newList: Object.assign(Object.assign({}, list), { [uuid]: newElement }),
      result: uuid
    };
  }
  function removeElement(list, timestamp, id2) {
    if (!list[id2]) {
      throw new ElementNotFoundError(id2);
    }
    const tombstone = {
      isDeleted: true,
      isArchived: false,
      updateTime: guardMinUpdateTime(list[id2].updateTime, timestamp)
    };
    return {
      newList: Object.assign(Object.assign({}, list), { [id2]: tombstone }),
      result: void 0
    };
  }
  function archiveElement(list, timestamp, id2) {
    const el2 = list[id2];
    if (!el2) {
      throw new ElementNotFoundError(id2);
    }
    if (isTombstone(el2)) {
      throw new ElementDeletedError(id2);
    }
    const archivedElement = Object.assign(Object.assign({}, unpackHeymergeListElementContent(el2)), { isDeleted: true, isArchived: true, updateTime: guardMinUpdateTime(el2.updateTime, timestamp) });
    return {
      newList: Object.assign(Object.assign({}, list), { [id2]: archivedElement }),
      result: void 0
    };
  }
  function restoreArchivedElement(list, timestamp, id2) {
    const el2 = list[id2];
    if (!el2) {
      throw new ElementNotFoundError(id2);
    }
    if (isTombstone(el2)) {
      throw new ElementDeletedError(id2);
    }
    const restoredElement = Object.assign(Object.assign({}, unpackHeymergeListElementContent(el2)), { isDeleted: false, updateTime: guardMinUpdateTime(el2.updateTime, timestamp) });
    return {
      newList: Object.assign(Object.assign({}, list), { [id2]: restoredElement }),
      result: void 0
    };
  }
  function modifyElement(list, timestamp, id2, listElement) {
    const oldElement = list[id2];
    if (!oldElement || isTombstone(oldElement)) {
      throw new ElementNotFoundError(id2);
    }
    if (isHeymergeArchivedListValue(oldElement)) {
      throw new ElementArchivedError(id2);
    }
    const modifiedElement = Object.assign(Object.assign(Object.assign({}, oldElement), listElement), { updateTime: guardMinUpdateTime(list[id2].updateTime, timestamp), isDeleted: false });
    return {
      newList: Object.assign(Object.assign({}, list), { [id2]: modifiedElement }),
      result: void 0
    };
  }
  function addOrModifyElement(list, timestamp, id2, listElement) {
    var _a3;
    const oldElement = list[id2];
    if (oldElement !== void 0 && isHeymergeArchivedListValue(oldElement)) {
      throw new ElementArchivedError(id2);
    }
    const oldContent = oldElement === void 0 || isTombstone(oldElement) ? {} : unpackHeymergeListValue(oldElement);
    return {
      newList: Object.assign(Object.assign({}, list), { [id2]: Object.assign(Object.assign(Object.assign({}, oldContent), listElement), { updateTime: guardMinUpdateTime((_a3 = oldElement === null || oldElement === void 0 ? void 0 : oldElement.updateTime) !== null && _a3 !== void 0 ? _a3 : "", timestamp), isDeleted: false }) }),
      result: void 0
    };
  }
  function mergeListsByTimestamp(left, right, postMergeHook) {
    const indices = /* @__PURE__ */ new Set([...Object.keys(left), ...Object.keys(right)]);
    const outputList = {};
    for (const index2 of indices) {
      if (index2 in left && index2 in right) {
        outputList[index2] = chooseByUpdateTimeWithHook(left[index2], right[index2], postMergeHook);
      } else if (index2 in left) {
        outputList[index2] = left[index2];
      } else {
        outputList[index2] = right[index2];
      }
    }
    return {
      newList: outputList,
      result: void 0
    };
  }
  function diffListsByTimestamp(base2, changed, postMergeHook) {
    const outputList = {};
    const indices = /* @__PURE__ */ new Set([...Object.keys(base2), ...Object.keys(changed)]);
    for (const index2 of indices) {
      if (index2 in base2 && index2 in changed) {
        const chosen = chooseByUpdateTimeWithHook(base2[index2], changed[index2], postMergeHook);
        if (chosen !== base2[index2]) {
          outputList[index2] = chosen;
        }
      } else if (index2 in changed) {
        outputList[index2] = changed[index2];
      } else {
        throw new InvalidHeymergeListError("Base contains Element not existing in changed List");
      }
    }
    return {
      newList: outputList,
      result: void 0
    };
  }
  function setMaxUpdateTime(list, timestamp) {
    const outputList = {};
    for (const index2 of Object.keys(list)) {
      const time = timestamp < list[index2].updateTime ? timestamp : list[index2].updateTime;
      outputList[index2] = Object.assign(Object.assign({}, list[index2]), { updateTime: time });
    }
    return { newList: outputList, result: true };
  }
  function getMaxUpdateTime(list) {
    let timestamp = (/* @__PURE__ */ new Date(0)).toISOString();
    for (const index2 of Object.keys(list)) {
      if (list[index2].updateTime > timestamp) {
        timestamp = list[index2].updateTime;
      }
    }
    return timestamp;
  }
  function guardMinUpdateTime(oldTime, newTime) {
    if (newTime > oldTime) {
      return newTime;
    }
    const shiftedTime = new Date(oldTime).getTime() + 1e3;
    return new Date(shiftedTime).toISOString();
  }
  function chooseByUpdateTimeWithHook(leftElement, rightElement, postMergeHook) {
    const chosenElement = chooseByUpdateTime(leftElement, rightElement, leftElement.updateTime, rightElement.updateTime);
    if (postMergeHook) {
      return postMergeHook(leftElement, rightElement, chosenElement);
    }
    return chosenElement;
  }
  function unpackHeymergeVaultContent(vaultContent) {
    let external = {};
    for (const [k2, v2] of Object.entries(vaultContent)) {
      external = Object.assign(Object.assign({}, external), { [k2]: unpackHeymergeList(v2) });
    }
    return external;
  }
  function unpackHeymergeVaultContentArchive(vaultContent) {
    let external = {};
    for (const [k2, v2] of Object.entries(vaultContent)) {
      external = Object.assign(Object.assign({}, external), { [k2]: unpackHeymergeListArchive(v2) });
    }
    return external;
  }
  function modifyVault$1(vaultContent, listKey, modification) {
    var _a3;
    const list = (_a3 = vaultContent[listKey]) !== null && _a3 !== void 0 ? _a3 : {};
    const { newList, result: result2 } = modification(list);
    return { newVaultContent: Object.assign(Object.assign({}, vaultContent), { [listKey]: newList }), result: result2 };
  }
  function diffVaults(base2, changed, postMergeHooks) {
    const keys2 = /* @__PURE__ */ new Set([...getObjectKeys$1(base2), ...getObjectKeys$1(changed)]);
    const outputContent = Object.assign({}, changed);
    for (const key of keys2) {
      if (key in base2 && key in changed) {
        const postMergeHook = postMergeHooks === null || postMergeHooks === void 0 ? void 0 : postMergeHooks[key];
        const { newList: diffList } = diffListsByTimestamp(base2[key], changed[key], postMergeHook);
        outputContent[key] = diffList;
      } else if (!(key in changed)) {
        throw new InvalidHeymergeVaultContentError("Key not present in changed Object");
      }
    }
    const newVaultContent = outputContent;
    return { newVaultContent, result: void 0 };
  }
  function mergeVaults(left, right, postMergeHooks) {
    const keys2 = /* @__PURE__ */ new Set([...getObjectKeys$1(left), ...getObjectKeys$1(right)]);
    const outputContent = Object.assign(Object.assign({}, left), right);
    for (const key of keys2) {
      if (key in left && key in right) {
        const postMergeHook = postMergeHooks === null || postMergeHooks === void 0 ? void 0 : postMergeHooks[key];
        const { newList: mergedList } = mergeListsByTimestamp(left[key], right[key], postMergeHook);
        outputContent[key] = mergedList;
      }
    }
    const newVaultContent = outputContent;
    return { newVaultContent, result: void 0 };
  }
  function getObjectKeys$1(obj) {
    return Object.keys(obj);
  }
  function getMaxVaultUpdateTime(vault) {
    let timestamp = (/* @__PURE__ */ new Date(0)).toISOString();
    for (const index2 of getObjectKeys$1(vault)) {
      const listMaxUpdateTime = getMaxUpdateTime(vault[index2]);
      if (listMaxUpdateTime > timestamp) {
        timestamp = listMaxUpdateTime;
      }
    }
    return timestamp;
  }
  const DESCRIPTOR_VERSION_HEYMERGE = 2;
  const TEAM_META_VAULT_INFO_ID = nullUuid;
  const ORGANIZATION_ADMIN_VAULT_INFO_ID = nullUuid;
  const META_VAULT_ACCOUNT_SETTINGS_ID = nullUuid;
  const TeamMetaVaultContent = TeamMetaVaultContentV2;
  const { PermissionLevel } = GV2;
  const TEAM_USER_DEFAULT_PERMISSION_LEVEL = PermissionLevel.restricted;
  function getTeamMetaVaultInfo(content2) {
    var _a3;
    return (_a3 = content2.info) === null || _a3 === void 0 ? void 0 : _a3[TEAM_META_VAULT_INFO_ID];
  }
  const NEWLY_JOINED_RECENT_AGE_MS = 7 * 24 * 60 * 60 * 1e3;
  function getNewlyJoinedInfo(content2, profileId) {
    const user = content2.users[profileId];
    if (!(user === null || user === void 0 ? void 0 : user.newlyJoined)) {
      return void 0;
    }
    const recent = Date.now() - new Date(user.joinedAt).getTime() < NEWLY_JOINED_RECENT_AGE_MS;
    return Object.assign(Object.assign({}, user.newlyJoined), { recent });
  }
  function getPermissionLevel(content2, profileId) {
    var _a3;
    const user = content2.users[profileId];
    return (_a3 = getValueWithPlaceholder(user === null || user === void 0 ? void 0 : user.permissionLevel)) !== null && _a3 !== void 0 ? _a3 : PermissionLevel.admin;
  }
  function createInitialVaultContent$3() {
    return { users: {}, info: {} };
  }
  const teamMetaVaultContentDescriptor = {
    version: 2,
    // "groupMeta" for compatibility, renamed to team later
    contentTypeName: "groupMeta",
    vaultTypes: [VaultType.TEAM_META, VaultType.INBOX_META],
    parseVaultContent: TeamMetaVaultContent.parse.bind(TeamMetaVaultContent),
    createInitialVaultContent: createInitialVaultContent$3
  };
  function modifyTeamVaultInfo(content2, timestamp, info) {
    return modifyVault$1(content2, "info", (list) => {
      if (!list[TEAM_META_VAULT_INFO_ID]) {
        return addOrModifyElement(list, timestamp, TEAM_META_VAULT_INFO_ID, Object.assign({
          // Default values
          name: ""
        }, info));
      }
      return modifyElement(list, timestamp, TEAM_META_VAULT_INFO_ID, info);
    });
  }
  function addOrModifyTeamVaultUser(content2, timestamp, profileId, user) {
    return modifyVault$1(content2, "users", (list) => {
      return addOrModifyElement(list, timestamp, profileId, Object.assign(Object.assign({ email: null, joinedAt: timestamp }, list[profileId]), user));
    });
  }
  function deleteTeamVaultUser(content2, timestamp, profileId) {
    return modifyVault$1(content2, "users", (list) => {
      try {
        return removeElement(list, timestamp, profileId);
      } catch (e2) {
        if (e2 instanceof ElementNotFoundError) {
          return { newList: list, result: void 0 };
        }
        throw e2;
      }
    });
  }
  function getLoggedInUserTeamPermissionLevel(accountState, meta) {
    var _a3;
    const isTeamOrgAdmin = meta.organizationId && ((_a3 = accountState.getOrganization(meta.organizationId)) === null || _a3 === void 0 ? void 0 : _a3.isAdmin);
    if (isTeamOrgAdmin) {
      return PermissionLevel.admin;
    }
    const profileId = meta.getProfileId();
    if (!profileId) {
      throw new Error("called getLoggedInUserTeamPermissionLevel on a foreign vault");
    }
    return getPermissionLevel(meta.getContent(), profileId);
  }
  class VaultAuthenticatorLock {
    constructor(authenticatorId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey) {
      this.authenticatorId = authenticatorId;
      this.encryptedStorableVaultKey = encryptedStorableVaultKey;
      this.encryptedHighSecurityVaultKey = encryptedHighSecurityVaultKey;
      this.encryptedVaultMessagePrivateKey = encryptedVaultMessagePrivateKey;
    }
    static create(authenticator, vaultSecret, protectedSecret, messagePrivateKey) {
      const encryptedStorableVaultKey = asymCreateKek(authenticator.storableVaultKeyEncPubKey, vaultSecret);
      const encryptedHighSecurityVaultKey = asymCreateKek(authenticator.highSecurityVaultKeyEncPubKey, protectedSecret);
      const encryptedVaultMessagePrivateKey = messagePrivateKey === null ? null : asymEncryptEncryptionPrivateKey(authenticator.highSecurityVaultKeyEncPubKey, messagePrivateKey);
      return new VaultAuthenticatorLock(authenticator.id, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey);
    }
    static load({ authenticatorId, encryptedStorableVaultKey: encryptedStorableVaultKeyData, encryptedHighSecurityVaultKey: encryptedHighSecurityVaultKeyData, encryptedVaultMessagePrivateKey: encryptedVaultMessagePrivateKeyData }) {
      const encryptedStorableVaultKey = loadAsymEncryptedSymmetricKey(encryptedStorableVaultKeyData);
      const encryptedHighSecurityVaultKey = loadAsymEncryptedSymmetricKey(encryptedHighSecurityVaultKeyData);
      const encryptedVaultMessagePrivateKey = encryptedVaultMessagePrivateKeyData === null ? null : loadAsymEncryptedEncryptionPrivateKey(encryptedVaultMessagePrivateKeyData);
      return new VaultAuthenticatorLock(authenticatorId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey);
    }
  }
  class VaultProfileLock {
    constructor(lockingProfileId, lockingProfileKeyGenerationId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey) {
      this.lockingProfileId = lockingProfileId;
      this.lockingProfileKeyGenerationId = lockingProfileKeyGenerationId;
      this.encryptedStorableVaultKey = encryptedStorableVaultKey;
      this.encryptedHighSecurityVaultKey = encryptedHighSecurityVaultKey;
      this.encryptedVaultMessagePrivateKey = encryptedVaultMessagePrivateKey;
    }
    static create(profile, vaultSecret, protectedSecret, messagePrivateKey) {
      const encryptedStorableVaultKey = asymCreateKek(profile.storableVaultKeyEncPubKey, vaultSecret);
      const encryptedHighSecurityVaultKey = asymCreateKek(profile.highSecurityVaultKeyEncPubKey, protectedSecret);
      const encryptedVaultMessagePrivateKey = messagePrivateKey === null ? null : asymEncryptEncryptionPrivateKey(profile.highSecurityVaultKeyEncPubKey, messagePrivateKey);
      const profileId = profile instanceof UnsyncedProfile ? nullUuid : profile.id;
      const profileKeyGenerationId = profile instanceof UnsyncedProfile ? nullUuid : profile.keyGenerationId;
      return new VaultProfileLock(profileId, profileKeyGenerationId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey);
    }
    static load({ lockingProfileId, lockingProfileKeyGenerationId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey }) {
      return new VaultProfileLock(lockingProfileId, lockingProfileKeyGenerationId, loadAsymEncryptedSymmetricKey(encryptedStorableVaultKey), loadAsymEncryptedSymmetricKey(encryptedHighSecurityVaultKey), encryptedVaultMessagePrivateKey !== null ? loadAsymEncryptedEncryptionPrivateKey(encryptedVaultMessagePrivateKey) : null);
    }
  }
  function protect(protectedSecret, value) {
    const encoder2 = new TextEncoder();
    const encrypted = encode$1(symEncrypt(protectedSecret, encoder2.encode(value.unencrypted)));
    return {
      contentId: value.contentId,
      encrypted,
      isEmpty: value.unencrypted === ""
    };
  }
  function unlockLockProtectedSecret(vaultAccess, locks, profileLock, adminProfileLock, profileRepo, hsc) {
    if (vaultAccess.type === "profile") {
      const { unlockedProfile: up, hsup: vaultHsup } = vaultAccess;
      if (!profileLock) {
        throw new LockProfileNotFoundError(up.profile.id);
      }
      if (up.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
      }
      const hsup = vaultHsup !== null && vaultHsup !== void 0 ? vaultHsup : hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedProfile(up, profileRepo);
      if (!hsup) {
        throw new LockProfileNotFoundError(profileLock.lockingProfileId);
      }
      const messagePrivateKey = profileLock.encryptedVaultMessagePrivateKey !== null ? asymDecryptEncryptionPrivateKey(hsup.highSecurityVaultKeyEncPrivKey, profileLock.encryptedVaultMessagePrivateKey) : null;
      return {
        protectedSecret: asymDecryptKek(hsup.highSecurityVaultKeyEncPrivKey, profileLock.encryptedHighSecurityVaultKey),
        messagePrivateKey
      };
    } else if (vaultAccess.type === "admin-profile") {
      const { unlockedProfile: up, hsup: vaultHsup } = vaultAccess;
      if (!adminProfileLock) {
        throw new LockProfileNotFoundError(up.profile.id);
      }
      if (up.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
      }
      const hsup = vaultHsup !== null && vaultHsup !== void 0 ? vaultHsup : hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedProfile(up, profileRepo);
      if (!hsup) {
        throw new LockProfileNotFoundError(adminProfileLock.lockingProfileId);
      }
      const messagePrivateKey = adminProfileLock.encryptedVaultMessagePrivateKey !== null ? asymDecryptEncryptionPrivateKey(hsup.highSecurityVaultKeyEncPrivKey, adminProfileLock.encryptedVaultMessagePrivateKey) : null;
      return {
        protectedSecret: asymDecryptKek(hsup.highSecurityVaultKeyEncPrivKey, adminProfileLock.encryptedHighSecurityVaultKey),
        messagePrivateKey
      };
    } else {
      const { unlockedAuthenticator, hsua: vaultHsua } = vaultAccess;
      const hsua = vaultHsua !== null && vaultHsua !== void 0 ? vaultHsua : hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedAuthenticator();
      if (!hsua) {
        throw new LockAuthenticatorNotFoundError(unlockedAuthenticator.authenticator.id, locks);
      }
      const candidateLock = locks.find((lock) => lock.authenticatorId === hsua.authenticator.id);
      if (!candidateLock) {
        throw new LockAuthenticatorNotFoundError(hsua.authenticator.id, locks);
      }
      const messagePrivateKey = candidateLock.encryptedVaultMessagePrivateKey !== null ? asymDecryptEncryptionPrivateKey(hsua.highSecurityVaultKeyEncPrivKey, candidateLock.encryptedVaultMessagePrivateKey) : null;
      return {
        protectedSecret: asymDecryptKek(hsua.highSecurityVaultKeyEncPrivKey, candidateLock.encryptedHighSecurityVaultKey),
        messagePrivateKey
      };
    }
  }
  function unprotect(protectedSecret, value) {
    const decoder2 = new TextDecoder();
    return decoder2.decode(symDecrypt(protectedSecret, loadSymEncryptedBlob(value.encrypted)));
  }
  function unprotectWithContentId(protectedSecret, value) {
    var _a3;
    return {
      contentId: (_a3 = value.contentId) !== null && _a3 !== void 0 ? _a3 : null,
      unencrypted: unprotect(protectedSecret, value)
    };
  }
  var __awaiter$T = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function getProfileInVault(profileRepo, v2) {
    var _a3, _b, _c2, _d;
    if ("profiles" in v2) {
      return (_b = (_a3 = v2.profiles.find(({ id: id2 }) => profileRepo.hasProfile(id2))) === null || _a3 === void 0 ? void 0 : _a3.id) !== null && _b !== void 0 ? _b : null;
    } else {
      return (_d = (_c2 = v2.profileIds) === null || _c2 === void 0 ? void 0 : _c2.find((id2) => profileRepo.hasProfile(id2))) !== null && _d !== void 0 ? _d : null;
    }
  }
  function findPersonalVaultId(accountState, vaultRepo, orgId, profileId) {
    const org = accountState.getOrganization(orgId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    const personalVault = vaultRepo.getOrganizationPersonalLoginVault(orgId);
    if ((personalVault === null || personalVault === void 0 ? void 0 : personalVault.getPersonalProfileId()) === profileId) {
      return personalVault.id;
    }
    const toOrgProfile = org.profiles.find((op) => op.profileId === profileId);
    if (!toOrgProfile) {
      throw new Error("tried to link to non-existing org profile");
    }
    if (!toOrgProfile.personalVaultId) {
      throw new Error("tried to link to profile with no known personal vault");
    }
    return toOrgProfile.personalVaultId;
  }
  function onlineCheckCanLinkToVault(backendClient, orgId, vaultId) {
    return __awaiter$T(this, void 0, void 0, function* () {
      const { messagePublicKeys } = yield backendClient.vault.listMessagePublicKeys(orgId, [vaultId]);
      if (messagePublicKeys[0].key.length === 0) {
        throw new VaultLinkingNotSupportedError(vaultId);
      }
    });
  }
  const { LegacyOrganizationAdminVaultContent } = LOAV;
  function getLegacyOrganizationAdminVaultInfo(content2) {
    var _a3;
    return (_a3 = content2.info) === null || _a3 === void 0 ? void 0 : _a3[ORGANIZATION_ADMIN_VAULT_INFO_ID];
  }
  function createInitialVaultContent$2() {
    return { info: {} };
  }
  const legacyOrganizationAdminVaultContentDescriptor = {
    version: 2,
    // 'organizationAdmin' for compatibility, this vault type will be removed later
    contentTypeName: "organizationAdmin",
    vaultTypes: [VaultType.LEGACY_ORGANIZATION_ADMIN],
    parseVaultContent: LegacyOrganizationAdminVaultContent.parse.bind(LegacyOrganizationAdminVaultContent),
    createInitialVaultContent: createInitialVaultContent$2
  };
  function replaceLegacyOrganizationAdminVaultInfo(content2, timestamp, info) {
    return modifyVault$1(content2, "info", (list) => {
      return addOrModifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
    });
  }
  function modifyLegacyOrganizationAdminVaultInfo(content2, timestamp, info) {
    return modifyVault$1(content2, "info", (list) => {
      return modifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
    });
  }
  function getBackendClientForVault(ccs, v2) {
    if (getProfileInVault(ccs.profileRepo, v2)) {
      return ccs.backendClient;
    }
    const org = v2.organizationId ? ccs.accountState.getOrganization(v2.organizationId) : void 0;
    if (org === null || org === void 0 ? void 0 : org.adminInfo) {
      if (org.adminProfileId) {
        return ccs.backendClient;
      }
      return ccs.backendClient.withPermissionUserId(org.superUserId);
    }
    throw new NoOrganizationAdminError();
  }
  function getSuperUserHighSecurityUnlockedAuthenticator(protectedSecretRepo, adminVault, authenticator) {
    const info = getLegacyOrganizationAdminVaultInfo(adminVault.getContent());
    if (!info.authenticatorSecret) {
      return null;
    }
    const seed = protectedSecretRepo.unprotect(adminVault, info.authenticatorSecret.seed);
    const pinnedSecret = {
      authenticatorId: authenticator.id,
      seed: naclUtilExports.decodeBase64(seed)
    };
    const auth = loadAuthenticator(authenticator);
    const hsua = HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(auth, pinnedSecret);
    return hsua;
  }
  var __decorate$3 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  class HighSecurityUnlockedProfile {
    constructor(up, highSecuritySeed) {
      this.up = up;
      this.highSecuritySeed = highSecuritySeed;
    }
    static fromSeed(up, highSecuritySeed) {
      return new HighSecurityUnlockedProfile(up, highSecuritySeed);
    }
    static fromAuthenticatorLocks(up, hsua) {
      const locks = up.profile.authenticatorLocks;
      const candidateLock = locks.find((lock) => lock.authenticatorId === hsua.authenticator.id);
      if (!candidateLock) {
        throw new LockAuthenticatorNotFoundError(hsua.authenticator.id, locks);
      }
      const highSecuritySeed = asymDecrypt(hsua.highSecurityVaultKeyEncPrivKey, candidateLock.encryptedHighSecurityProfileSeed);
      return new HighSecurityUnlockedProfile(up, highSecuritySeed);
    }
    static fromProfileLock(up, parentHsup) {
      var _a3;
      if (((_a3 = up.profile.profileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId) !== parentHsup.up.profile.id) {
        throw new LockProfileNotFoundError(up.profile.profileLock.lockingProfileId);
      }
      const highSecuritySeed = asymDecrypt(parentHsup.highSecurityProfileSeedEncPrivKey, up.profile.profileLock.encryptedHighSecurityProfileSeed);
      return new HighSecurityUnlockedProfile(up, highSecuritySeed);
    }
    createAuthenticatorLock(authenticator) {
      return Object.assign(Object.assign({}, ProfileAuthenticatorLock.create(authenticator, this.highSecuritySeed, this.up.storableSeed)), { profileId: this.up.profile.id, profileKeyGenerationId: this.up.profile.keyGenerationId });
    }
    createProfileLock(profile) {
      return Object.assign(Object.assign({}, ProfileProfileLock.create(profile, this.highSecuritySeed, this.up.storableSeed)), { profileId: this.up.profile.id, profileKeyGenerationId: this.up.profile.keyGenerationId });
    }
    get highSecurityIdentitySigPrivKey() {
      return deriveSigningKeyPair(this.highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY).sigPrivKey;
    }
    get highSecurityVaultKeyEncPrivKey() {
      return deriveEncryptionKeyPair(this.highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
    }
    get highSecurityProfileSeedEncPrivKey() {
      return deriveEncryptionKeyPair(this.highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY).encPrivKey;
    }
  }
  __decorate$3([
    Lazy
  ], HighSecurityUnlockedProfile.prototype, "highSecurityIdentitySigPrivKey", null);
  __decorate$3([
    Lazy
  ], HighSecurityUnlockedProfile.prototype, "highSecurityVaultKeyEncPrivKey", null);
  __decorate$3([
    Lazy
  ], HighSecurityUnlockedProfile.prototype, "highSecurityProfileSeedEncPrivKey", null);
  function isHighSecurityOrgAdminProfile(hsup) {
    const { up } = hsup;
    return up.profile.profileType === ProfileType.ORGANIZATION_ADMIN && !!up.profile.organizationId;
  }
  function getDirectVaultAccess(profileRepo, hsc, v2) {
    var _a3;
    const vaultProfileId = getProfileInVault(profileRepo, v2);
    if (vaultProfileId) {
      const unlockedProfile = profileRepo.getUnlocked(vaultProfileId);
      if (!unlockedProfile) {
        throw new ProfileNotFoundError(vaultProfileId);
      }
      return {
        type: "profile",
        unlockedProfile,
        hsup: (_a3 = hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedProfile(unlockedProfile, profileRepo)) !== null && _a3 !== void 0 ? _a3 : null
      };
    }
    return null;
  }
  function getVaultAccess(ccs, hsc, v2) {
    const directVaultAccess = getDirectVaultAccess(ccs.profileRepo, hsc, v2);
    if (directVaultAccess) {
      return directVaultAccess;
    }
    const org = v2.organizationId ? ccs.accountState.getOrganization(v2.organizationId) : void 0;
    if (!(org === null || org === void 0 ? void 0 : org.adminInfo)) {
      throw new NoOrganizationAdminError();
    }
    if (!ccs.protectedSecretRepo) {
      const unlockedProfile = ccs.profileRepo.getOrgAdminProfile(org.id);
      if (unlockedProfile) {
        return {
          type: "admin-profile",
          unlockedProfile,
          hsup: null,
          orgId: org.id
        };
      }
      const unlockedAuthenticator = ccs.superUserUnlockedAuthenticators[org.id];
      if (unlockedAuthenticator) {
        return {
          type: "admin-authenticator",
          unlockedAuthenticator,
          hsua: null,
          orgId: org.id
        };
      }
      throw new NoOrganizationAdminError();
    }
    const orgVaultAccess = getOrgAdminVaultAccess(ccs.protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, hsc, org);
    if (orgVaultAccess) {
      return orgVaultAccess;
    }
    throw new NoOrganizationAdminError();
  }
  function getOrgAdminVaultAccess(protectedSecretRepo, vaultRepo, profileRepo, hsc, org) {
    var _a3, _b;
    if (!org.adminInfo) {
      return null;
    }
    if ((_a3 = org.adminInfo) === null || _a3 === void 0 ? void 0 : _a3.authenticator) {
      if (!org.adminInfo.legacyAdminVaultId) {
        throw new Error("no admin vault for legacy org, this should never happen!");
      }
      const adminVault = vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
      if (!adminVault) {
        return null;
      }
      const orgHsua = getSuperUserHighSecurityUnlockedAuthenticator(protectedSecretRepo, adminVault, org.adminInfo.authenticator);
      if (!orgHsua) {
        return null;
      }
      return {
        type: "admin-authenticator",
        unlockedAuthenticator: orgHsua.getUnlockedAuthenticator(),
        hsua: orgHsua,
        orgId: org.id
      };
    } else if ((_b = org.adminInfo) === null || _b === void 0 ? void 0 : _b.adminProfile) {
      if (!hsc) {
        return null;
      }
      const up = profileRepo.getOrgAdminProfile(org.id);
      if (!up) {
        return null;
      }
      const orgHsup = hsc.getHighSecurityUnlockedProfile(up, profileRepo);
      if (!isHighSecurityOrgAdminProfile(orgHsup)) {
        throw new Error(`expected org admin profile (${ProfileType.ORGANIZATION_ADMIN}), got ${up.profile.profileType}`);
      }
      return {
        type: "admin-profile",
        unlockedProfile: up,
        hsup: orgHsup,
        orgId: org.id
      };
    }
    return null;
  }
  class ProtectedSecretRepo {
    constructor(protectedSecrets, unlockedUntil, cachedOrganizations) {
      this.protectedSecrets = protectedSecrets;
      this.unlockedUntil = unlockedUntil;
      this.cachedOrganizations = cachedOrganizations;
    }
    static create(ccs, hsc, unlockedUntil) {
      const protectedSecrets = {};
      ccs.vaultRepo.getAllVaults().forEach((vault) => {
        if (vault.isUserJoined) {
          try {
            const vaultAccess = getVaultAccess(ccs, hsc, vault);
            const { protectedSecret, messagePrivateKey } = unlockLockProtectedSecret(vaultAccess, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, ccs.profileRepo);
            protectedSecrets[vault.id] = {
              generationId: vault.generationId,
              protectedSecret,
              messagePrivateKey
            };
          } catch (e2) {
            if (e2 instanceof DomainError$1 && e2.code === ClientCoreErrorCode.ProfileKeyGenerationMismatch) {
              return;
            }
            throw e2;
          }
        }
      });
      return new ProtectedSecretRepo(protectedSecrets, unlockedUntil, /* @__PURE__ */ new Set());
    }
    withOrganization(orgId, orgProtectedSecrets) {
      const protectedSecrets = Object.assign(Object.assign({}, this.protectedSecrets), orgProtectedSecrets);
      const cachedOrganizations = /* @__PURE__ */ new Set([...this.cachedOrganizations, orgId]);
      return new ProtectedSecretRepo(protectedSecrets, this.unlockedUntil, cachedOrganizations);
    }
    withUnlockedUntil(unlockedUntil) {
      return new ProtectedSecretRepo(this.protectedSecrets, unlockedUntil, this.cachedOrganizations);
    }
    withProtectedSecret({ id: vaultId, generationId }, protectedSecret, messagePrivateKey) {
      const protectedSecrets = Object.assign({}, this.protectedSecrets);
      protectedSecrets[vaultId] = { generationId, protectedSecret, messagePrivateKey };
      return new ProtectedSecretRepo(protectedSecrets, this.unlockedUntil, this.cachedOrganizations);
    }
    withDeleteProtectedSecret(vaultId) {
      const protectedSecrets = Object.assign({}, this.protectedSecrets);
      delete protectedSecrets[vaultId];
      return new ProtectedSecretRepo(protectedSecrets, this.unlockedUntil, this.cachedOrganizations);
    }
    isUnlocked() {
      if (this.unlockedUntil === null) {
        return true;
      }
      const now = /* @__PURE__ */ new Date();
      return this.unlockedUntil.getTime() >= now.getTime();
    }
    protect(vault, value) {
      const secret = this.getSecret(vault, CannotProtectError);
      return protect(secret, value);
    }
    unprotect(vault, value) {
      const secret = this.getSecret(vault, CannotUnprotectError);
      return unprotect(secret, value);
    }
    unprotectWithContentId(vault, value) {
      const secret = this.getSecret(vault, CannotUnprotectError);
      return unprotectWithContentId(secret, value);
    }
    decryptVaultMessage(vault, message) {
      var _a3;
      if (!((_a3 = message.encryptedData) === null || _a3 === void 0 ? void 0 : _a3.length)) {
        return void 0;
      }
      const privateKey = this.getVaultMessagePrivateKey(vault, CannotDecryptVaultMessageError);
      if (!privateKey) {
        throw new CannotDecryptVaultMessageError("no vault message private key");
      }
      return asymDecrypt(privateKey, loadAsymEncryptedBlob(message.encryptedData));
    }
    createLock(vault, authenticator) {
      const protectedSecret = this.getSecret(vault, CannotCreateLockError);
      const messagePrivateKey = this.getVaultMessagePrivateKey(vault, CannotCreateLockError);
      return VaultAuthenticatorLock.create(authenticator, vault.vaultSecret, protectedSecret, messagePrivateKey);
    }
    createProfileLock(vault, profile) {
      const protectedSecret = this.getSecret(vault, CannotCreateLockError);
      const messagePrivateKey = this.getVaultMessagePrivateKey(vault, CannotCreateLockError);
      return VaultProfileLock.create(profile, vault.vaultSecret, protectedSecret, messagePrivateKey);
    }
    getProtectedSecretFunctions(vault) {
      this.getSecret(vault, VaultProtectedSecretNotFoundError);
      const decryptVaultMessage = vault.messagePublicKey ? (msg) => this.decryptVaultMessage(vault, msg) : null;
      return {
        protect: (v2) => this.protect(vault, v2),
        unprotect: (v2) => this.unprotect(vault, v2),
        unprotectWithContentId: (v2) => this.unprotectWithContentId(vault, v2),
        decryptVaultMessage
      };
    }
    hasVault(vaultId) {
      return !!this.protectedSecrets[vaultId];
    }
    getSecret(vault, ErrorConstructor) {
      this.checkProtectedSecretPrecondition(ErrorConstructor);
      const entry = this.protectedSecrets[vault.id];
      if (!entry) {
        throw new ProtectInternalError(`No protected secret for vault: ${vault.id}}!`);
      }
      if (entry.generationId !== vault.generationId) {
        throw new ProtectInternalError(`Incorrect vault generation: got ${vault.generationId}, expected ${entry.generationId}`);
      }
      return entry.protectedSecret;
    }
    getVaultMessagePrivateKey(vault, ErrorConstructor) {
      this.checkProtectedSecretPrecondition(ErrorConstructor);
      const entry = this.protectedSecrets[vault.id];
      if (!entry) {
        throw new ProtectInternalError(`No protected secret for vault: ${vault.id}}!`);
      }
      if (entry.generationId !== vault.generationId) {
        throw new ProtectInternalError(`Incorrect vault generation: got ${vault.generationId}, expected ${entry.generationId}`);
      }
      return entry.messagePrivateKey;
    }
    checkProtectedSecretPrecondition(ErrorConstructor) {
      if (!this.isUnlocked()) {
        const msg = `Vault protectedSecret expired at ${this.unlockedUntil} but was still present at ${/* @__PURE__ */ new Date()}.`;
        trackError(new Error(msg));
        throw new ErrorConstructor();
      }
    }
  }
  var __rest$D = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function internalCheckLoginAchievements(_a3) {
    var ccs = __rest$D(_a3, []);
    const achievements = [];
    const privateLoginVault = ccs.vaultRepo.getPrivateLoginVault();
    if (privateLoginVault) {
      const numLogins = Object.keys(privateLoginVault.getContent().logins).length;
      if (numLogins >= 1024)
        achievements.push(Achievement.COR_LOGINS_TOTAL_1024);
      if (numLogins >= 512)
        achievements.push(Achievement.COR_LOGINS_TOTAL_512);
      if (numLogins >= 256)
        achievements.push(Achievement.COR_LOGINS_TOTAL_256);
      if (numLogins >= 128)
        achievements.push(Achievement.COR_LOGINS_TOTAL_128);
      if (numLogins >= 64)
        achievements.push(Achievement.COR_LOGINS_TOTAL_64);
      if (numLogins >= 32)
        achievements.push(Achievement.COR_LOGINS_TOTAL_32);
      if (numLogins >= 16)
        achievements.push(Achievement.COR_LOGINS_TOTAL_16);
      if (numLogins >= 8)
        achievements.push(Achievement.COR_LOGINS_TOTAL_8);
      if (numLogins >= 4)
        achievements.push(Achievement.COR_LOGINS_TOTAL_4);
      if (numLogins >= 2)
        achievements.push(Achievement.COR_LOGINS_TOTAL_2);
      if (numLogins >= 1)
        achievements.push(Achievement.COR_LOGINS_TOTAL_1);
      ccs.accountState = ccs.accountState.withLocalAchievements(achievements);
    }
    return ccs;
  }
  function internalWriteAuditlogEvent(ccs, organizationId, ...events) {
    if (!organizationId) {
      return ccs;
    }
    const queuedEvents = events.map((event) => {
      var _a3;
      return {
        clientTime: /* @__PURE__ */ new Date(),
        organizationId,
        lastKnownServerTime: (_a3 = ccs.lastKnownServerTime) !== null && _a3 !== void 0 ? _a3 : /* @__PURE__ */ new Date(0),
        event
      };
    });
    return Object.assign(Object.assign({}, ccs), { auditlogEventQueue: [...ccs.auditlogEventQueue, ...queuedEvents] });
  }
  var __rest$C = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function modifyVault(_a3, vault, mod, requireUnlock, hsc) {
    var ccs = __rest$C(_a3, []);
    let modifiedVault;
    let returnResult;
    if (requireUnlock) {
      const protectedSecretFunctions = getProtectedSecretFunctions(ccs, vault, hsc);
      ({ vault: modifiedVault, result: returnResult } = vault.withModification((c2, t2, operation) => mod(c2, t2, Object.assign(Object.assign({}, operation), protectedSecretFunctions))));
    } else {
      ({ vault: modifiedVault, result: returnResult } = vault.withModification((c2, t2, operation) => mod(c2, t2, operation)));
    }
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(modifiedVault);
    return Object.assign(Object.assign({}, ccs), { returnResult, modifiedVault });
  }
  function modifyLoginVault(_a3, vault, mod, hsc) {
    var ccs = __rest$C(_a3, []);
    if (vault.type === VaultType.TEAM) {
      const pair = ccs.vaultRepo.getTeamVaultPairById(vault.id);
      if (!pair) {
        throw new VaultNotFoundError(vault.id);
      }
      const permissionLevel = getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta);
      if (permissionLevel !== PermissionLevel.admin && permissionLevel !== PermissionLevel.member) {
        throw new VaultPermissionDeniedError();
      }
    }
    const protectedSecretFunctions = getProtectedSecretFunctions(ccs, vault, hsc);
    let auditlogEvents;
    const { vault: postChangeVault, result: returnResult, vaultContentDiff } = vault.withModification((c2, t2, operation) => {
      const result2 = mod(c2, t2, Object.assign(Object.assign({}, operation), protectedSecretFunctions));
      auditlogEvents = result2.auditlogEvents;
      return result2;
    });
    let modifiedVault = postChangeVault;
    const messages = extractLinkedUpdateMessages(vault.id, vault.getPersonalProfileId(), vault.getContent(), protectedSecretFunctions, vaultContentDiff);
    if (messages.length) {
      modifiedVault = modifiedVault.withAddLinkedUpdateMessage(...messages);
    }
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(modifiedVault);
    if (vault.type === VaultType.PRIVATE) {
      ccs = internalCheckLoginAchievements(ccs);
    }
    if (auditlogEvents) {
      ccs = internalWriteAuditlogEvent(ccs, vault.organizationId, ...auditlogEvents);
    }
    return Object.assign(Object.assign({}, ccs), { returnResult, modifiedVault });
  }
  function getProtectedSecretFunctions(ccs, vault, hsc) {
    var _a3;
    if ((_a3 = ccs.protectedSecretRepo) === null || _a3 === void 0 ? void 0 : _a3.isUnlocked()) {
      return ccs.protectedSecretRepo.getProtectedSecretFunctions(vault);
    }
    if (hsc) {
      return ProtectedSecretRepo.create(ccs, hsc, null).getProtectedSecretFunctions(vault);
    }
    throw new ClientCoreIsLockedError();
  }
  var __awaiter$S = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$B = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  const MAX_REVISION_AGE_MS = 90 * 24 * 60 * 60 * 1e3;
  function internalDeleteOutdatedLoginHistory(_a3, vaultId, loginId) {
    var ccs = __rest$B(_a3, []);
    return __awaiter$S(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const lastKnownServerTime = ccs.lastKnownServerTime;
      if (!lastKnownServerTime) {
        return ccs;
      }
      const cutoffDate = new Date(lastKnownServerTime.getTime() - MAX_REVISION_AGE_MS);
      const previousLogin = vault.getContent().logins[loginId];
      if (!previousLogin) {
        throw new LoginNotFoundError(loginId);
      }
      if (!hasHistory(previousLogin)) {
        return ccs;
      }
      const recentRevisionIds = getRecentRevisionIds(previousLogin.history, cutoffDate);
      const baseRevisionIds = /* @__PURE__ */ new Set();
      for (const id2 of recentRevisionIds) {
        const baseRevisionId = previousLogin.history.revisions[id2].baseRevisionId;
        if (baseRevisionId && !recentRevisionIds.has(baseRevisionId)) {
          baseRevisionIds.add(baseRevisionId);
        }
      }
      const keptRevisionCount = recentRevisionIds.size + baseRevisionIds.size;
      if (keptRevisionCount === Object.keys(previousLogin.history.revisions).length) {
        return ccs;
      }
      const revisions = {};
      for (const [id2, revision] of Object.entries(previousLogin.history.revisions)) {
        if (recentRevisionIds.has(id2) || baseRevisionIds.has(id2)) {
          revisions[id2] = revision;
        }
      }
      return modifyLoginVault(ccs, vault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
        const result2 = modifyLoginInternal2(c2, t2, loginId, {
          history: Object.assign(Object.assign({}, previousLogin.history), { revisions })
        });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
      });
    });
  }
  function hasHistory(login) {
    return !!login.history;
  }
  var __awaiter$R = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$A = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  const MAX_OPENED_SHARE_LINK_AGE_MS = 7 * 24 * 60 * 60 * 1e3;
  function internalDeleteOutdatedShareLinks(_a3, vaultId, loginId) {
    var ccs = __rest$A(_a3, []);
    return __awaiter$R(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const lastKnownServerTime = ccs.lastKnownServerTime;
      if (!lastKnownServerTime) {
        return ccs;
      }
      const previousLogin = vault.getContent().logins[loginId];
      if (!previousLogin) {
        throw new LoginNotFoundError(loginId);
      }
      if (!previousLogin.shareLinks) {
        return ccs;
      }
      const cutoffDate = new Date(lastKnownServerTime.getTime() - MAX_OPENED_SHARE_LINK_AGE_MS);
      const newShareLinks = previousLogin.shareLinks.filter((sl2) => {
        if (!sl2.openedAt) {
          return true;
        }
        const openedAtDate = new Date(sl2.openedAt);
        return openedAtDate.getTime() > cutoffDate.getTime();
      });
      if (newShareLinks.length === previousLogin.shareLinks.length) {
        return ccs;
      }
      return modifyLoginVault(ccs, vault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
        const result2 = modifyLoginInternal2(c2, t2, loginId, {
          shareLinks: newShareLinks
        });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
      });
    });
  }
  var __rest$z = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function internalLoginSetConfirmed(_a3, vaultId, loginId) {
    var ccs = __rest$z(_a3, []);
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    const { vault: updatedVault } = vault.withModification((c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => modifyLoginInternal2(c2, t2, loginId, { pendingInboxConfirmation: false }));
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(updatedVault);
    return ccs;
  }
  var __rest$y = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function internalTeamClearNewlyJoined(_a3, teamId) {
    var ccs = __rest$y(_a3, []);
    const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
    if (!pair) {
      throw new VaultNotFoundError(teamId);
    }
    const profileId = pair.meta.getProfileId();
    if (!profileId) {
      throw new Error("tried to call internalTeamClearNewlyJoined on a foreign vault");
    }
    const { vault } = pair.meta.withModification((c2, t2, { addOrModifyTeamVaultUser: addOrModifyTeamVaultUser2 }) => addOrModifyTeamVaultUser2(c2, t2, profileId, { newlyJoined: void 0 }));
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(vault);
    return ccs;
  }
  var __rest$x = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function internalTeamSetUserPermissionLevels(_a3, teamId, ...profiles) {
    var ccs = __rest$x(_a3, []);
    const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
    if (!pair) {
      throw new VaultNotFoundError(teamId);
    }
    if (getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta) !== "admin") {
      throw new VaultPermissionDeniedError();
    }
    const updatesMetaVault = pair.meta.withModification((c2, t2, { addOrModifyTeamVaultUser: addOrModifyTeamVaultUser2 }) => {
      let newVaultContent = c2;
      for (const { profileId, permissionLevel } of profiles) {
        newVaultContent = addOrModifyTeamVaultUser2(newVaultContent, t2, profileId, {
          permissionLevel
        }).newVaultContent;
      }
      return { newVaultContent, result: void 0 };
    }).vault;
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(updatesMetaVault);
    return ccs;
  }
  var __rest$w = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function internalUpdateMetaSession(_a3, sessionId, session) {
    var ccs = __rest$w(_a3, []);
    const vault = ccs.vaultRepo.getMetaVault();
    if (!vault) {
      throw new MetaVaultNotFoundError();
    }
    const { vault: modifiedVault } = vault.withModification((contents, t2, { replaceSession: replaceSession2 }) => {
      return replaceSession2(contents, t2, sessionId, session);
    });
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(modifiedVault);
    return ccs;
  }
  function groupBy(list, key) {
    if (list.length === 0) {
      return {};
    }
    list.sort((a, b2) => {
      const k1 = key(a);
      const k2 = key(b2);
      if (k1 === k2) {
        return 0;
      }
      return k1 < k2 ? -1 : 1;
    });
    const result2 = {};
    let currentStart = 0;
    let currentKey = key(list[0]);
    for (let i2 = 0; i2 < list.length; i2++) {
      const k2 = key(list[i2]);
      result2[currentKey] = list.slice(currentStart, i2);
      if (k2 !== currentKey) {
        result2[currentKey] = list.slice(currentStart, i2);
        currentKey = k2;
        currentStart = i2;
      }
    }
    result2[currentKey] = list.slice(currentStart, list.length);
    return result2;
  }
  function getLoginDifferences(left, right) {
    return genericGetLoginDifferences(left, right, LOGIN_KEYS);
  }
  function genericGetLoginDifferences(left, right, keys2) {
    const result2 = [];
    for (const key of keys2) {
      if (!isLoginDifferenceIncludedKey(key)) {
        continue;
      }
      if (key === "creditCard") {
        result2.push(...getCreditCardDifference(left.creditCard, right.creditCard));
      } else if (key === "customFields") {
        result2.push(...getCustomFieldDifference(left.customFields, right.customFields));
      } else if (!isEqual$1(left[key], right[key])) {
        result2.push({ type: "login", key });
      }
    }
    return result2;
  }
  function getCreditCardDifference(left, right) {
    const result2 = [];
    for (const key of LOGIN_CREDIT_CARD_KEYS) {
      if (!isLoginDifferenceCreditCardIncludedKey(key)) {
        continue;
      }
      if (!isEqual$1(left === null || left === void 0 ? void 0 : left[key], right === null || right === void 0 ? void 0 : right[key]) || // Always report all fields as changed if CreditCard switches from set to unset or vice versa.
      left === void 0 && right !== void 0 || left !== void 0 && right === void 0) {
        result2.push({ type: "creditCard", key });
      }
    }
    return result2;
  }
  function getCustomFieldDifference(left, right) {
    var _a3;
    const leftFieldsById = groupBy(left, (cf2) => cf2.id);
    const rightFieldsById = groupBy(right, (cf2) => cf2.id);
    const ids = /* @__PURE__ */ new Set([...Object.keys(leftFieldsById), ...Object.keys(rightFieldsById)]);
    const result2 = [];
    for (const id2 of ids) {
      const leftValues = leftFieldsById[id2];
      const rightValues = rightFieldsById[id2];
      const leftValue = leftValues === null || leftValues === void 0 ? void 0 : leftValues[0];
      const rightValue = rightValues === null || rightValues === void 0 ? void 0 : rightValues[0];
      if (!isEqual$1(leftValue === null || leftValue === void 0 ? void 0 : leftValue.value, rightValue === null || rightValue === void 0 ? void 0 : rightValue.value)) {
        const name = (_a3 = leftValue === null || leftValue === void 0 ? void 0 : leftValue.name) !== null && _a3 !== void 0 ? _a3 : rightValue === null || rightValue === void 0 ? void 0 : rightValue.name;
        if (name !== void 0) {
          result2.push({ type: "customField", id: id2, name });
        }
      }
    }
    return result2;
  }
  function isLoginDifferenceIncludedKey(k2) {
    return typeof k2 === "string" && !LOGIN_DIFFERENCE_IGNORED_KEYS.includes(k2);
  }
  function isLoginDifferenceCreditCardIncludedKey(k2) {
    return typeof k2 === "string" && !LOGIN_DIFFERENCE_CREDIT_CARD_IGNORED_KEYS.includes(k2);
  }
  function isEqual$1(leftValue, rightValue) {
    if (isProtectedValue(leftValue) && isProtectedValue(rightValue)) {
      return leftValue.contentId === rightValue.contentId;
    }
    if (leftValue === void 0 && isEmptyValue(rightValue) || isEmptyValue(leftValue) && rightValue === void 0) {
      return true;
    }
    return Ee$1(leftValue, rightValue, { strict: true });
  }
  function isProtectedValue(obj) {
    return typeof obj === "object" && obj !== null && Object.keys(obj).length === 2 && "contentId" in obj && typeof obj.contentId === "string" && "encrypted" in obj && typeof obj.encrypted === "string";
  }
  function isEmptyValue(value) {
    return (Array.isArray(value) || typeof value === "string") && value.length === 0;
  }
  function getWebsiteAttributesEntry(unnormalizedWebsite) {
    const websiteAttributesEntry = {};
    const protocol = getProtocol(unnormalizedWebsite);
    if (protocol) {
      websiteAttributesEntry.protocol = protocol;
    }
    return websiteAttributesEntry;
  }
  function getProtocol(website) {
    let url;
    try {
      url = new URL(website);
    } catch (_a3) {
      return null;
    }
    switch (url.protocol) {
      case "http:":
        return LoginWebsiteProtocol.http;
      case "https:":
        return LoginWebsiteProtocol.https;
      default:
        return null;
    }
  }
  var cardTypes$1 = {
    visa: {
      niceType: "Visa",
      type: "visa",
      patterns: [4],
      gaps: [4, 8, 12],
      lengths: [16, 18, 19],
      code: {
        name: "CVV",
        size: 3
      }
    },
    mastercard: {
      niceType: "Mastercard",
      type: "mastercard",
      patterns: [[51, 55], [2221, 2229], [223, 229], [23, 26], [270, 271], 2720],
      gaps: [4, 8, 12],
      lengths: [16],
      code: {
        name: "CVC",
        size: 3
      }
    },
    "american-express": {
      niceType: "American Express",
      type: "american-express",
      patterns: [34, 37],
      gaps: [4, 10],
      lengths: [15],
      code: {
        name: "CID",
        size: 4
      }
    },
    "diners-club": {
      niceType: "Diners Club",
      type: "diners-club",
      patterns: [[300, 305], 36, 38, 39],
      gaps: [4, 10],
      lengths: [14, 16, 19],
      code: {
        name: "CVV",
        size: 3
      }
    },
    discover: {
      niceType: "Discover",
      type: "discover",
      patterns: [6011, [644, 649], 65],
      gaps: [4, 8, 12],
      lengths: [16, 19],
      code: {
        name: "CID",
        size: 3
      }
    },
    jcb: {
      niceType: "JCB",
      type: "jcb",
      patterns: [2131, 1800, [3528, 3589]],
      gaps: [4, 8, 12],
      lengths: [16, 17, 18, 19],
      code: {
        name: "CVV",
        size: 3
      }
    },
    unionpay: {
      niceType: "UnionPay",
      type: "unionpay",
      patterns: [
        620,
        [624, 626],
        [62100, 62182],
        [62184, 62187],
        [62185, 62197],
        [62200, 62205],
        [622010, 622999],
        622018,
        [622019, 622999],
        [62207, 62209],
        [622126, 622925],
        [623, 626],
        6270,
        6272,
        6276,
        [627700, 627779],
        [627781, 627799],
        [6282, 6289],
        6291,
        6292,
        810,
        [8110, 8131],
        [8132, 8151],
        [8152, 8163],
        [8164, 8171]
      ],
      gaps: [4, 8, 12],
      lengths: [14, 15, 16, 17, 18, 19],
      code: {
        name: "CVN",
        size: 3
      }
    },
    maestro: {
      niceType: "Maestro",
      type: "maestro",
      patterns: [
        493698,
        [5e5, 504174],
        [504176, 506698],
        [506779, 508999],
        [56, 59],
        63,
        67,
        6
      ],
      gaps: [4, 8, 12],
      lengths: [12, 13, 14, 15, 16, 17, 18, 19],
      code: {
        name: "CVC",
        size: 3
      }
    },
    elo: {
      niceType: "Elo",
      type: "elo",
      patterns: [
        401178,
        401179,
        438935,
        457631,
        457632,
        431274,
        451416,
        457393,
        504175,
        [506699, 506778],
        [509e3, 509999],
        627780,
        636297,
        636368,
        [650031, 650033],
        [650035, 650051],
        [650405, 650439],
        [650485, 650538],
        [650541, 650598],
        [650700, 650718],
        [650720, 650727],
        [650901, 650978],
        [651652, 651679],
        [655e3, 655019],
        [655021, 655058]
      ],
      gaps: [4, 8, 12],
      lengths: [16],
      code: {
        name: "CVE",
        size: 3
      }
    },
    mir: {
      niceType: "Mir",
      type: "mir",
      patterns: [[2200, 2204]],
      gaps: [4, 8, 12],
      lengths: [16, 17, 18, 19],
      code: {
        name: "CVP2",
        size: 3
      }
    },
    hiper: {
      niceType: "Hiper",
      type: "hiper",
      patterns: [637095, 63737423, 63743358, 637568, 637599, 637609, 637612],
      gaps: [4, 8, 12],
      lengths: [16],
      code: {
        name: "CVC",
        size: 3
      }
    },
    hipercard: {
      niceType: "Hipercard",
      type: "hipercard",
      patterns: [606282],
      gaps: [4, 8, 12],
      lengths: [16],
      code: {
        name: "CVC",
        size: 3
      }
    }
  };
  var cardTypes_1 = cardTypes$1;
  var addMatchingCardsToResults$1 = {};
  var clone$2 = {};
  Object.defineProperty(clone$2, "__esModule", { value: true });
  clone$2.clone = void 0;
  function clone$1(originalObject) {
    if (!originalObject) {
      return null;
    }
    return JSON.parse(JSON.stringify(originalObject));
  }
  clone$2.clone = clone$1;
  var matches$1 = {};
  Object.defineProperty(matches$1, "__esModule", { value: true });
  matches$1.matches = void 0;
  function matchesRange(cardNumber2, min, max2) {
    var maxLengthToCheck = String(min).length;
    var substr = cardNumber2.substr(0, maxLengthToCheck);
    var integerRepresentationOfCardNumber = parseInt(substr, 10);
    min = parseInt(String(min).substr(0, substr.length), 10);
    max2 = parseInt(String(max2).substr(0, substr.length), 10);
    return integerRepresentationOfCardNumber >= min && integerRepresentationOfCardNumber <= max2;
  }
  function matchesPattern(cardNumber2, pattern) {
    pattern = String(pattern);
    return pattern.substring(0, cardNumber2.length) === cardNumber2.substring(0, pattern.length);
  }
  function matches(cardNumber2, pattern) {
    if (Array.isArray(pattern)) {
      return matchesRange(cardNumber2, pattern[0], pattern[1]);
    }
    return matchesPattern(cardNumber2, pattern);
  }
  matches$1.matches = matches;
  Object.defineProperty(addMatchingCardsToResults$1, "__esModule", { value: true });
  addMatchingCardsToResults$1.addMatchingCardsToResults = void 0;
  var clone_1$1 = clone$2;
  var matches_1 = matches$1;
  function addMatchingCardsToResults(cardNumber2, cardConfiguration, results) {
    var i2, patternLength;
    for (i2 = 0; i2 < cardConfiguration.patterns.length; i2++) {
      var pattern = cardConfiguration.patterns[i2];
      if (!matches_1.matches(cardNumber2, pattern)) {
        continue;
      }
      var clonedCardConfiguration = clone_1$1.clone(cardConfiguration);
      if (Array.isArray(pattern)) {
        patternLength = String(pattern[0]).length;
      } else {
        patternLength = String(pattern).length;
      }
      if (cardNumber2.length >= patternLength) {
        clonedCardConfiguration.matchStrength = patternLength;
      }
      results.push(clonedCardConfiguration);
      break;
    }
  }
  addMatchingCardsToResults$1.addMatchingCardsToResults = addMatchingCardsToResults;
  var isValidInputType$1 = {};
  Object.defineProperty(isValidInputType$1, "__esModule", { value: true });
  isValidInputType$1.isValidInputType = void 0;
  function isValidInputType(cardNumber2) {
    return typeof cardNumber2 === "string" || cardNumber2 instanceof String;
  }
  isValidInputType$1.isValidInputType = isValidInputType;
  var findBestMatch$1 = {};
  Object.defineProperty(findBestMatch$1, "__esModule", { value: true });
  findBestMatch$1.findBestMatch = void 0;
  function hasEnoughResultsToDetermineBestMatch(results) {
    var numberOfResultsWithMaxStrengthProperty = results.filter(function(result2) {
      return result2.matchStrength;
    }).length;
    return numberOfResultsWithMaxStrengthProperty > 0 && numberOfResultsWithMaxStrengthProperty === results.length;
  }
  function findBestMatch(results) {
    if (!hasEnoughResultsToDetermineBestMatch(results)) {
      return null;
    }
    return results.reduce(function(bestMatch, result2) {
      if (!bestMatch) {
        return result2;
      }
      if (Number(bestMatch.matchStrength) < Number(result2.matchStrength)) {
        return result2;
      }
      return bestMatch;
    });
  }
  findBestMatch$1.findBestMatch = findBestMatch;
  var __assign$3 = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign$3 = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign$3.apply(this, arguments);
  };
  var cardTypes = cardTypes_1;
  var add_matching_cards_to_results_1 = addMatchingCardsToResults$1;
  var is_valid_input_type_1 = isValidInputType$1;
  var find_best_match_1 = findBestMatch$1;
  var clone_1 = clone$2;
  var customCards = {};
  var cardNames = {
    VISA: "visa",
    MASTERCARD: "mastercard",
    AMERICAN_EXPRESS: "american-express",
    DINERS_CLUB: "diners-club",
    DISCOVER: "discover",
    JCB: "jcb",
    UNIONPAY: "unionpay",
    MAESTRO: "maestro",
    ELO: "elo",
    MIR: "mir",
    HIPER: "hiper",
    HIPERCARD: "hipercard"
  };
  var ORIGINAL_TEST_ORDER = [
    cardNames.VISA,
    cardNames.MASTERCARD,
    cardNames.AMERICAN_EXPRESS,
    cardNames.DINERS_CLUB,
    cardNames.DISCOVER,
    cardNames.JCB,
    cardNames.UNIONPAY,
    cardNames.MAESTRO,
    cardNames.ELO,
    cardNames.MIR,
    cardNames.HIPER,
    cardNames.HIPERCARD
  ];
  var testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
  function findType(cardType) {
    return customCards[cardType] || cardTypes[cardType];
  }
  function getAllCardTypes() {
    return testOrder.map(function(cardType) {
      return clone_1.clone(findType(cardType));
    });
  }
  function getCardPosition(name, ignoreErrorForNotExisting) {
    if (ignoreErrorForNotExisting === void 0) {
      ignoreErrorForNotExisting = false;
    }
    var position = testOrder.indexOf(name);
    if (!ignoreErrorForNotExisting && position === -1) {
      throw new Error('"' + name + '" is not a supported card type.');
    }
    return position;
  }
  function creditCardType$1(cardNumber2) {
    var results = [];
    if (!is_valid_input_type_1.isValidInputType(cardNumber2)) {
      return results;
    }
    if (cardNumber2.length === 0) {
      return getAllCardTypes();
    }
    testOrder.forEach(function(cardType) {
      var cardConfiguration = findType(cardType);
      add_matching_cards_to_results_1.addMatchingCardsToResults(cardNumber2, cardConfiguration, results);
    });
    var bestMatch = find_best_match_1.findBestMatch(results);
    if (bestMatch) {
      return [bestMatch];
    }
    return results;
  }
  creditCardType$1.getTypeInfo = function(cardType) {
    return clone_1.clone(findType(cardType));
  };
  creditCardType$1.removeCard = function(name) {
    var position = getCardPosition(name);
    testOrder.splice(position, 1);
  };
  creditCardType$1.addCard = function(config2) {
    var existingCardPosition = getCardPosition(config2.type, true);
    customCards[config2.type] = config2;
    if (existingCardPosition === -1) {
      testOrder.push(config2.type);
    }
  };
  creditCardType$1.updateCard = function(cardType, updates) {
    var originalObject = customCards[cardType] || cardTypes[cardType];
    if (!originalObject) {
      throw new Error('"' + cardType + "\" is not a recognized type. Use `addCard` instead.'");
    }
    if (updates.type && originalObject.type !== updates.type) {
      throw new Error("Cannot overwrite type parameter.");
    }
    var clonedCard = clone_1.clone(originalObject);
    clonedCard = __assign$3(__assign$3({}, clonedCard), updates);
    customCards[clonedCard.type] = clonedCard;
  };
  creditCardType$1.changeOrder = function(name, position) {
    var currentPosition = getCardPosition(name);
    testOrder.splice(currentPosition, 1);
    testOrder.splice(position, 0, name);
  };
  creditCardType$1.resetModifications = function() {
    testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
    customCards = {};
  };
  creditCardType$1.types = cardNames;
  var dist$1 = creditCardType$1;
  var cardholderName$1 = {};
  Object.defineProperty(cardholderName$1, "__esModule", { value: true });
  cardholderName$1.cardholderName = void 0;
  var CARD_NUMBER_REGEX = /^[\d\s-]*$/;
  var MAX_LENGTH = 255;
  function verification$6(isValid2, isPotentiallyValid) {
    return { isValid: isValid2, isPotentiallyValid };
  }
  function cardholderName(value) {
    if (typeof value !== "string") {
      return verification$6(false, false);
    }
    if (value.length === 0) {
      return verification$6(false, true);
    }
    if (value.length > MAX_LENGTH) {
      return verification$6(false, false);
    }
    if (CARD_NUMBER_REGEX.test(value)) {
      return verification$6(false, true);
    }
    return verification$6(true, true);
  }
  cardholderName$1.cardholderName = cardholderName;
  var cardNumber$1 = {};
  function luhn10$1(identifier) {
    var sum = 0;
    var alt = false;
    var i2 = identifier.length - 1;
    var num;
    while (i2 >= 0) {
      num = parseInt(identifier.charAt(i2), 10);
      if (alt) {
        num *= 2;
        if (num > 9) {
          num = num % 10 + 1;
        }
      }
      alt = !alt;
      sum += num;
      i2--;
    }
    return sum % 10 === 0;
  }
  var luhn10_1 = luhn10$1;
  Object.defineProperty(cardNumber$1, "__esModule", { value: true });
  cardNumber$1.cardNumber = void 0;
  var luhn10 = luhn10_1;
  var getCardTypes = dist$1;
  function verification$5(card, isPotentiallyValid, isValid2) {
    return {
      card,
      isPotentiallyValid,
      isValid: isValid2
    };
  }
  function cardNumber(value, options) {
    if (options === void 0) {
      options = {};
    }
    var isPotentiallyValid, isValid2, maxLength;
    if (typeof value !== "string" && typeof value !== "number") {
      return verification$5(null, false, false);
    }
    var testCardValue = String(value).replace(/-|\s/g, "");
    if (!/^\d*$/.test(testCardValue)) {
      return verification$5(null, false, false);
    }
    var potentialTypes = getCardTypes(testCardValue);
    if (potentialTypes.length === 0) {
      return verification$5(null, false, false);
    } else if (potentialTypes.length !== 1) {
      return verification$5(null, true, false);
    }
    var cardType = potentialTypes[0];
    if (options.maxLength && testCardValue.length > options.maxLength) {
      return verification$5(cardType, false, false);
    }
    if (cardType.type === getCardTypes.types.UNIONPAY && options.luhnValidateUnionPay !== true) {
      isValid2 = true;
    } else {
      isValid2 = luhn10(testCardValue);
    }
    maxLength = Math.max.apply(null, cardType.lengths);
    if (options.maxLength) {
      maxLength = Math.min(options.maxLength, maxLength);
    }
    for (var i2 = 0; i2 < cardType.lengths.length; i2++) {
      if (cardType.lengths[i2] === testCardValue.length) {
        isPotentiallyValid = testCardValue.length < maxLength || isValid2;
        return verification$5(cardType, isPotentiallyValid, isValid2);
      }
    }
    return verification$5(cardType, testCardValue.length < maxLength, false);
  }
  cardNumber$1.cardNumber = cardNumber;
  var expirationDate$1 = {};
  var parseDate$2 = {};
  var expirationYear$1 = {};
  Object.defineProperty(expirationYear$1, "__esModule", { value: true });
  expirationYear$1.expirationYear = void 0;
  var DEFAULT_VALID_NUMBER_OF_YEARS_IN_THE_FUTURE = 19;
  function verification$4(isValid2, isPotentiallyValid, isCurrentYear) {
    return {
      isValid: isValid2,
      isPotentiallyValid,
      isCurrentYear: isCurrentYear || false
    };
  }
  function expirationYear(value, maxElapsedYear) {
    if (maxElapsedYear === void 0) {
      maxElapsedYear = DEFAULT_VALID_NUMBER_OF_YEARS_IN_THE_FUTURE;
    }
    var isCurrentYear;
    if (typeof value !== "string") {
      return verification$4(false, false);
    }
    if (value.replace(/\s/g, "") === "") {
      return verification$4(false, true);
    }
    if (!/^\d*$/.test(value)) {
      return verification$4(false, false);
    }
    var len = value.length;
    if (len < 2) {
      return verification$4(false, true);
    }
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    if (len === 3) {
      var firstTwo = value.slice(0, 2);
      var currentFirstTwo = String(currentYear).slice(0, 2);
      return verification$4(false, firstTwo === currentFirstTwo);
    }
    if (len > 4) {
      return verification$4(false, false);
    }
    var numericValue = parseInt(value, 10);
    var twoDigitYear = Number(String(currentYear).substr(2, 2));
    var valid = false;
    if (len === 2) {
      if (String(currentYear).substr(0, 2) === value) {
        return verification$4(false, true);
      }
      isCurrentYear = twoDigitYear === numericValue;
      valid = numericValue >= twoDigitYear && numericValue <= twoDigitYear + maxElapsedYear;
    } else if (len === 4) {
      isCurrentYear = currentYear === numericValue;
      valid = numericValue >= currentYear && numericValue <= currentYear + maxElapsedYear;
    }
    return verification$4(valid, valid, isCurrentYear);
  }
  expirationYear$1.expirationYear = expirationYear;
  var isArray$3 = {};
  Object.defineProperty(isArray$3, "__esModule", { value: true });
  isArray$3.isArray = void 0;
  isArray$3.isArray = Array.isArray || function(arg) {
    return Object.prototype.toString.call(arg) === "[object Array]";
  };
  Object.defineProperty(parseDate$2, "__esModule", { value: true });
  parseDate$2.parseDate = void 0;
  var expiration_year_1$2 = expirationYear$1;
  var is_array_1 = isArray$3;
  function getNumberOfMonthDigitsInDateString(dateString) {
    var firstCharacter = Number(dateString[0]);
    var assumedYear;
    if (firstCharacter === 0) {
      return 2;
    }
    if (firstCharacter > 1) {
      return 1;
    }
    if (firstCharacter === 1 && Number(dateString[1]) > 2) {
      return 1;
    }
    if (firstCharacter === 1) {
      assumedYear = dateString.substr(1);
      return expiration_year_1$2.expirationYear(assumedYear).isPotentiallyValid ? 1 : 2;
    }
    if (dateString.length === 5) {
      return 1;
    }
    if (dateString.length > 5) {
      return 2;
    }
    return 1;
  }
  function parseDate$1(datestring) {
    var date2;
    if (/^\d{4}-\d{1,2}$/.test(datestring)) {
      date2 = datestring.split("-").reverse();
    } else if (/\//.test(datestring)) {
      date2 = datestring.split(/\s*\/\s*/g);
    } else if (/\s/.test(datestring)) {
      date2 = datestring.split(/ +/g);
    }
    if (is_array_1.isArray(date2)) {
      return {
        month: date2[0] || "",
        year: date2.slice(1).join()
      };
    }
    var numberOfDigitsInMonth = getNumberOfMonthDigitsInDateString(datestring);
    var month = datestring.substr(0, numberOfDigitsInMonth);
    return {
      month,
      year: datestring.substr(month.length)
    };
  }
  parseDate$2.parseDate = parseDate$1;
  var expirationMonth$1 = {};
  Object.defineProperty(expirationMonth$1, "__esModule", { value: true });
  expirationMonth$1.expirationMonth = void 0;
  function verification$3(isValid2, isPotentiallyValid, isValidForThisYear) {
    return {
      isValid: isValid2,
      isPotentiallyValid,
      isValidForThisYear: isValidForThisYear || false
    };
  }
  function expirationMonth(value) {
    var currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
    if (typeof value !== "string") {
      return verification$3(false, false);
    }
    if (value.replace(/\s/g, "") === "" || value === "0") {
      return verification$3(false, true);
    }
    if (!/^\d*$/.test(value)) {
      return verification$3(false, false);
    }
    var month = parseInt(value, 10);
    if (isNaN(Number(value))) {
      return verification$3(false, false);
    }
    var result2 = month > 0 && month < 13;
    return verification$3(result2, result2, result2 && month >= currentMonth);
  }
  expirationMonth$1.expirationMonth = expirationMonth;
  var __assign$2 = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign$2 = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign$2.apply(this, arguments);
  };
  Object.defineProperty(expirationDate$1, "__esModule", { value: true });
  expirationDate$1.expirationDate = void 0;
  var parse_date_1 = parseDate$2;
  var expiration_month_1$1 = expirationMonth$1;
  var expiration_year_1$1 = expirationYear$1;
  function verification$2(isValid2, isPotentiallyValid, month, year) {
    return {
      isValid: isValid2,
      isPotentiallyValid,
      month,
      year
    };
  }
  function expirationDate(value, maxElapsedYear) {
    var date2;
    if (typeof value === "string") {
      value = value.replace(/^(\d\d) (\d\d(\d\d)?)$/, "$1/$2");
      date2 = parse_date_1.parseDate(String(value));
    } else if (value !== null && typeof value === "object") {
      var fullDate = __assign$2({}, value);
      date2 = {
        month: String(fullDate.month),
        year: String(fullDate.year)
      };
    } else {
      return verification$2(false, false, null, null);
    }
    var monthValid = expiration_month_1$1.expirationMonth(date2.month);
    var yearValid = expiration_year_1$1.expirationYear(date2.year, maxElapsedYear);
    if (monthValid.isValid) {
      if (yearValid.isCurrentYear) {
        var isValidForThisYear = monthValid.isValidForThisYear;
        return verification$2(isValidForThisYear, isValidForThisYear, date2.month, date2.year);
      }
      if (yearValid.isValid) {
        return verification$2(true, true, date2.month, date2.year);
      }
    }
    if (monthValid.isPotentiallyValid && yearValid.isPotentiallyValid) {
      return verification$2(false, true, null, null);
    }
    return verification$2(false, false, null, null);
  }
  expirationDate$1.expirationDate = expirationDate;
  var cvv$1 = {};
  Object.defineProperty(cvv$1, "__esModule", { value: true });
  cvv$1.cvv = void 0;
  var DEFAULT_LENGTH = 3;
  function includes(array, thing) {
    for (var i2 = 0; i2 < array.length; i2++) {
      if (thing === array[i2]) {
        return true;
      }
    }
    return false;
  }
  function max(array) {
    var maximum = DEFAULT_LENGTH;
    var i2 = 0;
    for (; i2 < array.length; i2++) {
      maximum = array[i2] > maximum ? array[i2] : maximum;
    }
    return maximum;
  }
  function verification$1(isValid2, isPotentiallyValid) {
    return { isValid: isValid2, isPotentiallyValid };
  }
  function cvv(value, maxLength) {
    if (maxLength === void 0) {
      maxLength = DEFAULT_LENGTH;
    }
    maxLength = maxLength instanceof Array ? maxLength : [maxLength];
    if (typeof value !== "string") {
      return verification$1(false, false);
    }
    if (!/^\d*$/.test(value)) {
      return verification$1(false, false);
    }
    if (includes(maxLength, value.length)) {
      return verification$1(true, true);
    }
    if (value.length < Math.min.apply(null, maxLength)) {
      return verification$1(false, true);
    }
    if (value.length > max(maxLength)) {
      return verification$1(false, false);
    }
    return verification$1(true, true);
  }
  cvv$1.cvv = cvv;
  var postalCode$1 = {};
  Object.defineProperty(postalCode$1, "__esModule", { value: true });
  postalCode$1.postalCode = void 0;
  var DEFAULT_MIN_POSTAL_CODE_LENGTH = 3;
  function verification(isValid2, isPotentiallyValid) {
    return { isValid: isValid2, isPotentiallyValid };
  }
  function postalCode(value, options) {
    if (options === void 0) {
      options = {};
    }
    var minLength = options.minLength || DEFAULT_MIN_POSTAL_CODE_LENGTH;
    if (typeof value !== "string") {
      return verification(false, false);
    } else if (value.length < minLength) {
      return verification(false, true);
    }
    return verification(true, true);
  }
  postalCode$1.postalCode = postalCode;
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result2 = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result2, mod, k2);
    }
    __setModuleDefault(result2, mod);
    return result2;
  };
  var creditCardType = __importStar(dist$1);
  var cardholder_name_1 = cardholderName$1;
  var card_number_1 = cardNumber$1;
  var expiration_date_1 = expirationDate$1;
  var expiration_month_1 = expirationMonth$1;
  var expiration_year_1 = expirationYear$1;
  var cvv_1 = cvv$1;
  var postal_code_1 = postalCode$1;
  var cardValidator = {
    creditCardType,
    cardholderName: cardholder_name_1.cardholderName,
    number: card_number_1.cardNumber,
    expirationDate: expiration_date_1.expirationDate,
    expirationMonth: expiration_month_1.expirationMonth,
    expirationYear: expiration_year_1.expirationYear,
    cvv: cvv_1.cvv,
    postalCode: postal_code_1.postalCode
  };
  var dist = cardValidator;
  const At = /* @__PURE__ */ getDefaultExportFromCjs(dist);
  function normalizeCreditCard(creditCard) {
    var _a3, _b, _c2, _d;
    const normalizedNumber = creditCard.number ? normalizeCreditCardNumber(creditCard.number) : { number: "", displayMaskedNumber: "", displayType: "" };
    const normalizedCreditCard = Object.assign(Object.assign({ pin: (_a3 = creditCard.pin) !== null && _a3 !== void 0 ? _a3 : "", securityCode: (_b = creditCard.securityCode) !== null && _b !== void 0 ? _b : "" }, normalizedNumber), { cardHolder: (_d = (_c2 = creditCard.cardHolder) === null || _c2 === void 0 ? void 0 : _c2.trim()) !== null && _d !== void 0 ? _d : "", expiration: creditCard.expiration ? normalizeCreditCardExpiration(creditCard.expiration) : "" });
    if (Object.values(normalizedCreditCard).every((v2) => v2 === "")) {
      return void 0;
    }
    return normalizedCreditCard;
  }
  function normalizeCreditCardNumber(inputNumber) {
    var _a3, _b;
    const cardNumberValidation = At.number(inputNumber);
    if (!cardNumberValidation.card || !cardNumberValidation.isValid) {
      const number3 = inputNumber.trim();
      const displayMaskedNumber2 = number3.replace(/\d/g, "*");
      return { number: number3, displayMaskedNumber: displayMaskedNumber2, displayType: (_b = (_a3 = cardNumberValidation.card) === null || _a3 === void 0 ? void 0 : _a3.niceType) !== null && _b !== void 0 ? _b : "" };
    }
    const { card } = cardNumberValidation;
    const cardNumberDigits = inputNumber.replace(/\D/g, "");
    const offsets = [0, ...card.gaps, cardNumberDigits.length];
    const components = [];
    for (let i2 = 0; offsets[i2] < cardNumberDigits.length; i2++) {
      const start = offsets[i2];
      const end = Math.min(offsets[i2 + 1], cardNumberDigits.length);
      components.push(cardNumberDigits.substring(start, end));
    }
    const number2 = components.join(" ");
    const displayMaskedNumber = components.map((c2, i2) => i2 === components.length - 1 ? c2 : c2.replace(/\d/g, "*")).join(" ");
    return { number: number2, displayMaskedNumber, displayType: cardNumberValidation.card.niceType };
  }
  function normalizeCreditCardExpiration(expiration) {
    var _a3, _b;
    const expirationValidation = At.expirationDate(expiration, Infinity);
    if (!expirationValidation.isValid || !expirationValidation.month || !expirationValidation.year) {
      const match2 = /^\s*(?<month>\d?\d)\s*\/\s*(?<year>(\d\d\d|\d)?\d)\s*$/.exec(expiration);
      if (match2) {
        return `${(_a3 = match2.groups) === null || _a3 === void 0 ? void 0 : _a3.month.padStart(2, "0")} / ${(_b = match2.groups) === null || _b === void 0 ? void 0 : _b.year.substring(match2.groups.year.length - 2).padStart(2, "0")}`;
      }
      return expiration.trim();
    }
    const twoDigitYear = expirationValidation.year.substring(expirationValidation.year.length - 2);
    return `${expirationValidation.month} / ${twoDigitYear}`;
  }
  function normalizeTag(tag) {
    return tag.replace(/^[\s/]*/, "").replace(/[\s/]*$/, "").replace(/\/+/g, "/");
  }
  function normalizeTotpSecret(value) {
    let result2 = value;
    const parameters = getTotpParametersFromOtpauthUrl(value);
    if (parameters) {
      result2 = parameters.secret;
    }
    const normalizedSecret = getNormalizedPlainTotpSecret(result2);
    if (normalizedSecret) {
      result2 = normalizedSecret;
    }
    return result2;
  }
  function getTotpParametersFromOtpauthUrl(value) {
    const parts = /otpauth:\/\/([A-Za-z]+)\/([^?]*)\??(.*)?/i.exec(value);
    if (parts === null || parts.length < 3) {
      return null;
    }
    const type = parts[1];
    if (type.toLowerCase() !== "totp") {
      return null;
    }
    const urlParams = new URLSearchParams(parts[3]);
    const secret = urlParams.get("secret");
    if (secret === null) {
      return null;
    }
    const params = {
      secret,
      algorithm: normalizeTotpAlgorithm(urlParams.get("algorithm")),
      digits: normalizeTotpDigits(urlParams.get("digits")),
      period: normalizeTotpPeriod(urlParams.get("period"))
    };
    return params;
  }
  function normalizeTotpAlgorithm(algorithm) {
    if (algorithm === null) {
      return void 0;
    }
    const algo = algorithm.toLowerCase().trim();
    switch (algo) {
      case "sha1":
        return TotpAlgorithm.sha1;
      case "sha256":
        return TotpAlgorithm.sha256;
      case "sha512":
        return TotpAlgorithm.sha512;
      default:
        return TotpAlgorithm.sha1;
    }
  }
  function normalizeTotpDigits(digitsString) {
    if (digitsString === null) {
      return void 0;
    }
    const digits = Number.parseInt(digitsString);
    if (Number.isNaN(digits) || !Number.isInteger(digits)) {
      return void 0;
    }
    if (digits <= 0) {
      return DEFAULT_TOTP_DIGITS;
    }
    return Math.min(8, digits);
  }
  function normalizeTotpPeriod(periodString) {
    if (periodString === null) {
      return void 0;
    }
    const period = Number.parseInt(periodString);
    if (Number.isNaN(period) || !Number.isInteger(period)) {
      return void 0;
    }
    if (period <= 0) {
      return DEFAULT_TOTP_PERIOD;
    }
    return period;
  }
  function getNormalizedPlainTotpSecret(value) {
    if (value === null) {
      return void 0;
    }
    const secret = value.toUpperCase().replace(/\s/g, "");
    try {
      base32tohex(secret);
      return secret;
    } catch (e2) {
      if (e2 instanceof InvalidTotpSecretError) {
        return void 0;
      }
    }
    return void 0;
  }
  const maxInt = 2147483647;
  const base = 36;
  const tMin = 1;
  const tMax = 26;
  const skew = 38;
  const damp = 700;
  const initialBias = 72;
  const initialN = 128;
  const delimiter = "-";
  const regexPunycode = /^xn--/;
  const regexNonASCII = /[^\0-\x7E]/;
  const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  const baseMinusTMin = base - tMin;
  const floor = Math.floor;
  const stringFromCharCode = String.fromCharCode;
  function error(type) {
    throw new RangeError(errors[type]);
  }
  function map(array, fn) {
    const result2 = [];
    let length = array.length;
    while (length--) {
      result2[length] = fn(array[length]);
    }
    return result2;
  }
  function mapDomain(string, fn) {
    const parts = string.split("@");
    let result2 = "";
    if (parts.length > 1) {
      result2 = parts[0] + "@";
      string = parts[1];
    }
    string = string.replace(regexSeparators, ".");
    const labels = string.split(".");
    const encoded = map(labels, fn).join(".");
    return result2 + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  const ucs2encode = (array) => String.fromCodePoint(...array);
  const basicToDigit = function(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }
    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }
    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }
    return base;
  };
  const digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  const adapt = function(delta, numPoints, firstTime) {
    let k2 = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  const decode = function(input) {
    const output = [];
    const inputLength = input.length;
    let i2 = 0;
    let n2 = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0; j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
      let oldi = i2;
      for (let w2 = 1, k2 = base; ; k2 += base) {
        if (index2 >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index2++));
        if (digit >= base || digit > floor((maxInt - i2) / w2)) {
          error("overflow");
        }
        i2 += digit * w2;
        const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
        if (digit < t2) {
          break;
        }
        const baseMinusT = base - t2;
        if (w2 > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w2 *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i2 - oldi, out, oldi == 0);
      if (floor(i2 / out) > maxInt - n2) {
        error("overflow");
      }
      n2 += floor(i2 / out);
      i2 %= out;
      output.splice(i2++, 0, n2);
    }
    return String.fromCodePoint(...output);
  };
  const encode = function(input) {
    const output = [];
    input = ucs2decode(input);
    let inputLength = input.length;
    let n2 = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    let basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m2 = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n2 && currentValue < m2) {
          m2 = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m2 - n2) * handledCPCountPlusOne;
      n2 = m2;
      for (const currentValue of input) {
        if (currentValue < n2 && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue == n2) {
          let q2 = delta;
          for (let k2 = base; ; k2 += base) {
            const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
            if (q2 < t2) {
              break;
            }
            const qMinusT = q2 - t2;
            const baseMinusT = base - t2;
            output.push(
              stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
            );
            q2 = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q2, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n2;
    }
    return output.join("");
  };
  const toUnicode = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  const toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  };
  const punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    "version": "2.1.0",
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    "ucs2": {
      "decode": ucs2decode,
      "encode": ucs2encode
    },
    "decode": decode,
    "encode": encode,
    "toASCII": toASCII,
    "toUnicode": toUnicode
  };
  const punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    decode,
    default: punycode,
    encode,
    toASCII,
    toUnicode,
    ucs2decode,
    ucs2encode
  }, Symbol.toStringTag, { value: "Module" }));
  function normalizeWebsitePattern(websitePatternString, options = {}) {
    const { hostname: host, port, pathname: path } = getNormalizedPatternParts(websitePatternString.trim(), options);
    return `${host}${port ? ":" : ""}${port}${path}`;
  }
  function getNormalizedPatternParts(inputWebsitePatternString, { usePunycode = false } = {}) {
    if (/^\d+$/.test(inputWebsitePatternString)) {
      return {
        hostname: inputWebsitePatternString.trim(),
        pathname: "",
        port: ""
      };
    }
    try {
      let websitePatternString = inputWebsitePatternString;
      const hasProtocol = /^([a-z]+:)?\/\//.exec(websitePatternString);
      if (!hasProtocol) {
        websitePatternString = `https://${websitePatternString}`;
      }
      const url = new URL(websitePatternString);
      const hostname = normalizePatternHostname(url.hostname, usePunycode);
      const pathname = normalizePatternPathname(url);
      const { port } = url;
      return {
        hostname,
        pathname,
        port
      };
    } catch (e2) {
      return {
        hostname: inputWebsitePatternString.trim(),
        pathname: "",
        port: ""
      };
    }
  }
  function normalizePatternHostname(hostname, usePunycode) {
    const hostnamePunycodedIfNeeded = usePunycode ? hostname : punycode.toUnicode(hostname);
    return hostnamePunycodedIfNeeded.toLowerCase();
  }
  function normalizePatternPathname(url) {
    const pathname = url.pathname.trim();
    if (pathname.match(/^\/+$/)) {
      return "";
    }
    return pathname;
  }
  var __rest$v = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function sanitizeLoginFromImport(login, profileId, now, emptyNameCustomFieldDefaultName) {
    var _a3, _b;
    const { creationTime, editTime, changeTime, websites, websiteAttributes, tags, creditCard, totp, customFields } = login, restLogin = __rest$v(login, ["creationTime", "editTime", "changeTime", "websites", "websiteAttributes", "tags", "creditCard", "totp", "customFields"]);
    const { normalizedWebsites, normalizedWebsiteAttributes } = getNormalizedWebsites(websites !== null && websites !== void 0 ? websites : [], websiteAttributes !== null && websiteAttributes !== void 0 ? websiteAttributes : {});
    const sanitizedLogin = Object.assign({
      // static defaults
      title: "",
      username: "",
      password: "",
      icon: "",
      note: "",
      creationSource: LoginSource.import,
      editSource: LoginSource.import,
      creationProfileId: profileId,
      editProfileId: profileId,
      // Default times to each other if not all are set
      creationTime: (_a3 = creationTime !== null && creationTime !== void 0 ? creationTime : editTime) !== null && _a3 !== void 0 ? _a3 : now,
      changeTime: (_b = changeTime !== null && changeTime !== void 0 ? changeTime : editTime) !== null && _b !== void 0 ? _b : now,
      editTime: editTime !== null && editTime !== void 0 ? editTime : now,
      // Normalize fields where possible
      websites: normalizedWebsites,
      websiteAttributes: normalizedWebsiteAttributes,
      tags: tags ? removeDuplicates(tags.map(normalizeTag)) : void 0,
      creditCard: creditCard ? normalizeCreditCard(creditCard) : void 0,
      totp: totp ? normalizeTotpSecret(totp) : void 0,
      customFields: customFields ? getNormalizedCustomFields(customFields, emptyNameCustomFieldDefaultName) : []
    }, deleteUndefinedKeys(restLogin));
    return deleteUndefinedKeys(Object.assign({
      // Guess uiType if not set
      uiType: guessUiType(sanitizedLogin)
    }, sanitizedLogin));
  }
  function deleteUndefinedKeys(obj) {
    const keys2 = Object.keys(obj);
    for (const k2 of keys2) {
      if (k2 in obj && obj[k2] === void 0) {
        delete obj[k2];
      }
    }
    return obj;
  }
  function guessUiType(login) {
    var _a3;
    if (login.creditCard) {
      return LoginUiType.creditCard;
    }
    if (((_a3 = login.websites) === null || _a3 === void 0 ? void 0 : _a3.length) || login.username || login.password || login.totp) {
      return LoginUiType.login;
    }
    if (login.note) {
      return LoginUiType.note;
    }
    return LoginUiType.login;
  }
  function removeDuplicates(arr) {
    return [...new Set(arr)];
  }
  function getNormalizedWebsites(websites, websiteAttributes) {
    const normalizedWebsitesSet = /* @__PURE__ */ new Set();
    const normalizedWebsiteAttributes = Object.assign({}, websiteAttributes);
    for (const unnormalizedWebsite of websites) {
      if (!unnormalizedWebsite) {
        continue;
      }
      const normalizedWebsite = normalizeWebsitePattern(unnormalizedWebsite);
      if (!normalizedWebsite || normalizedWebsitesSet.has(normalizedWebsite)) {
        continue;
      }
      normalizedWebsitesSet.add(normalizedWebsite);
      normalizedWebsiteAttributes[normalizedWebsite] = Object.assign(Object.assign({}, websiteAttributes[normalizedWebsite]), getWebsiteAttributesEntry(unnormalizedWebsite));
    }
    for (const key of Object.keys(normalizedWebsiteAttributes)) {
      if (!normalizedWebsitesSet.has(key)) {
        delete normalizedWebsiteAttributes[key];
      }
    }
    return { normalizedWebsites: [...normalizedWebsitesSet], normalizedWebsiteAttributes };
  }
  function getNormalizedCustomFields(customFields, emptyNameCustomFieldDefaultName) {
    const result2 = [];
    let index2 = 1;
    for (const cf2 of customFields) {
      if (cf2.name) {
        result2.push(cf2);
      } else {
        while (
          // eslint-disable-next-line @typescript-eslint/no-loop-func
          customFields.find(({ name }) => name === `${emptyNameCustomFieldDefaultName} ${index2}`) || // eslint-disable-next-line @typescript-eslint/no-loop-func
          result2.find(({ name }) => name === `${emptyNameCustomFieldDefaultName} ${index2}`)
        ) {
          index2++;
        }
        result2.push(Object.assign(Object.assign({}, cf2), { name: `${emptyNameCustomFieldDefaultName} ${index2}` }));
      }
    }
    return result2;
  }
  var __rest$u = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  const LoginVaultContent = LoginVaultContentV2;
  function transformLoginProtectedValues(l2, transform) {
    const { password, customFields, shareLinks, history, totp, creditCard } = l2, rest = __rest$u(l2, ["password", "customFields", "shareLinks", "history", "totp", "creditCard"]);
    let copy = Object.assign({}, rest);
    if ("password" in l2 && password !== void 0) {
      copy = Object.assign(Object.assign({}, copy), { password: transform(password) });
    }
    if ("totp" in l2) {
      copy = Object.assign(Object.assign({}, copy), { totp: totp ? transform(totp) : void 0 });
    }
    if ("customFields" in l2 && customFields !== void 0) {
      copy = Object.assign(Object.assign({}, copy), { customFields: customFields.map((cf2) => !cf2.protected ? cf2 : Object.assign(Object.assign({}, cf2), { value: transform(cf2.value) })) });
    }
    if ("creditCard" in l2) {
      copy = Object.assign(Object.assign({}, copy), { creditCard: creditCard ? Object.assign(Object.assign({}, creditCard), { securityCode: transform(creditCard.securityCode), pin: transform(creditCard.pin) }) : void 0 });
    }
    if ("history" in l2) {
      if (history == void 0) {
        copy = Object.assign(Object.assign({}, copy), { history: void 0 });
      } else {
        const revisions = {};
        for (const [id2, revision] of Object.entries(history.revisions)) {
          revisions[id2] = transformLoginProtectedValues(revision, transform);
        }
        copy = Object.assign(Object.assign({}, copy), { history: Object.assign(Object.assign({}, history), { revisions }) });
      }
    }
    if ("shareLinks" in l2) {
      copy = Object.assign(Object.assign({}, copy), { shareLinks: shareLinks ? shareLinks.map((sl2) => Object.assign(Object.assign({}, sl2), { secret: transform(sl2.secret) })) : void 0 });
    }
    return copy;
  }
  function createInitialVaultContent$1() {
    return { logins: {} };
  }
  function getActiveShareLinkIds(c2) {
    return Object.values(c2.logins).flatMap((l2) => {
      var _a3, _b;
      if (l2.isDeleted) {
        return [];
      }
      return (_b = (_a3 = l2.shareLinks) === null || _a3 === void 0 ? void 0 : _a3.flatMap((sl2) => sl2.openedAt ? [] : [sl2.id])) !== null && _b !== void 0 ? _b : [];
    });
  }
  const loginVaultContentDescriptor = {
    version: 2,
    contentTypeName: "login",
    vaultTypes: [VaultType.PRIVATE, VaultType.TEAM, VaultType.INBOX],
    parseVaultContent: LoginVaultContent.parse.bind(LoginVaultContent),
    createInitialVaultContent: createInitialVaultContent$1,
    postMergeHooks: {
      logins(left, right, chosen) {
        return loginMergeHistory(left, right, chosen);
      }
    },
    getActiveShareLinkIds
  };
  const organizationPersonalVaultContentDescriptor = {
    version: 2,
    contentTypeName: "organizationPersonal",
    vaultTypes: [VaultType.ORGANIZATION_PERSONAL],
    parseVaultContent: LoginVaultContent.parse.bind(LoginVaultContent),
    createInitialVaultContent: createInitialVaultContent$1,
    postMergeHooks: {
      logins(left, right, chosen) {
        return loginMergeHistory(left, right, chosen);
      }
    },
    getActiveShareLinkIds
  };
  function addLoginInternal(content2, timestamp, login) {
    return modifyVault$1(content2, "logins", (list) => {
      return addElement(list, timestamp, login);
    });
  }
  function addLoginInternalWithHistory(content2, timestamp, login) {
    return modifyVault$1(content2, "logins", (list) => {
      return addElement(list, timestamp, updateHistory(list, void 0, login));
    });
  }
  function modifyLoginInternal(content2, timestamp, id2, login) {
    return modifyVault$1(content2, "logins", (list) => {
      return modifyElement(list, timestamp, id2, login);
    });
  }
  function modifyLoginInternalWithHistory(content2, timestamp, id2, login) {
    return modifyVault$1(content2, "logins", (list) => {
      const fullLogin = unpackHeymergeListElement(modifyElement(list, timestamp, id2, login).newList[id2]);
      return modifyElement(list, timestamp, id2, updateHistory(list, id2, fullLogin));
    });
  }
  function addOrModifyLoginInternal(content2, timestamp, id2, login) {
    return modifyVault$1(content2, "logins", (list) => {
      return addOrModifyElement(list, timestamp, id2, login);
    });
  }
  function addOrModifyLoginInternalWithHistory(content2, timestamp, id2, login) {
    return modifyVault$1(content2, "logins", (list) => {
      return addOrModifyElement(list, timestamp, id2, updateHistory(list, id2, login));
    });
  }
  function deleteLoginInternal(content2, timestamp, id2) {
    return modifyVault$1(content2, "logins", (list) => {
      return removeElement(list, timestamp, id2);
    });
  }
  function archiveLoginInternal(content2, timestamp, id2) {
    return modifyVault$1(content2, "logins", (list) => {
      return archiveElement(list, timestamp, id2);
    });
  }
  function restoreArchivedLoginInternal(content2, timestamp, id2) {
    return modifyVault$1(content2, "logins", (list) => {
      return restoreArchivedElement(list, timestamp, id2);
    });
  }
  function updateHistory(previousList, id2, login) {
    let baseRevisionId;
    let previousRevisions;
    const previousElement = id2 ? previousList[id2] : void 0;
    const previousLogin = previousElement ? unpackHeymergeListElement(previousElement) : void 0;
    if (previousLogin) {
      if (previousLogin.history) {
        baseRevisionId = previousLogin.history.currentRevisionId;
        previousRevisions = previousLogin.history.revisions;
      } else {
        const backfillRevisionId = newUuid$1();
        previousRevisions = {
          [backfillRevisionId]: getLoginWithoutHistory(previousLogin)
        };
        baseRevisionId = backfillRevisionId;
      }
    } else {
      previousRevisions = void 0;
      baseRevisionId = void 0;
    }
    const currentRevisionId = newUuid$1();
    const loginWithoutHistory = getLoginWithoutHistory(login);
    const newRevision = Object.assign(Object.assign({}, loginWithoutHistory), { baseRevisionId });
    const loginWithHistory = Object.assign(Object.assign({}, login), {
      // History is merged from both sides with a post merge hook when a login is chosen on the
      // heymerge layer.
      history: {
        revisions: Object.assign(Object.assign({}, previousRevisions), { [currentRevisionId]: newRevision }),
        currentRevisionId
      }
    });
    return loginWithHistory;
  }
  function getLoginWithoutHistory(login) {
    const loginWithoutHistory = __rest$u(login, ["history"]);
    return loginWithoutHistory;
  }
  function loginMergeHistory(leftValue, rightValue, chosenValue) {
    var _a3, _b;
    const leftHistoryRevisions = leftValue.isDeleted ? void 0 : (_a3 = leftValue.history) === null || _a3 === void 0 ? void 0 : _a3.revisions;
    const rightHistoryRevisions = rightValue.isDeleted ? void 0 : (_b = rightValue.history) === null || _b === void 0 ? void 0 : _b.revisions;
    if (!chosenValue.isDeleted && chosenValue.history && (leftHistoryRevisions || rightHistoryRevisions) && !Ee$1(leftHistoryRevisions, rightHistoryRevisions)) {
      return Object.assign(Object.assign({}, chosenValue), { history: Object.assign(Object.assign({}, chosenValue.history), { revisions: Object.assign(Object.assign({}, leftHistoryRevisions), rightHistoryRevisions) }) });
    } else {
      return chosenValue;
    }
  }
  var __awaiter$Q = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$t = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function addLogin(_a3, _b) {
    var ccs = __rest$t(_a3, []);
    var vaultId = _b.vaultId, login = _b.login, highSecurityCache = _b.highSecurityCache, source = _b.source, timesOverride = _b.timesOverride;
    return __awaiter$Q(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      return modifyLoginVault(ccs, vault, (vaultContent, t2, { addLoginInternalWithHistory: addLoginInternalWithHistory2, protect: protect2 }) => {
        var _a4;
        const completedLogin = completeFullEditLogin(vault, ccs.profileRepo, t2, source, login, timesOverride);
        const { newVaultContent, result: loginId } = addLoginInternalWithHistory2(vaultContent, t2, recursivelyTransformUnprotectedValues(completedLogin, protect2));
        const modifiedLogin = newVaultContent.logins[loginId];
        return {
          newVaultContent,
          auditlogEvents: [
            {
              type: AuditlogEventType.LOGIN_W_CREATE,
              loginId,
              vaultId,
              loginEditTime: modifiedLogin.editTime,
              loginRevisionId: (_a4 = modifiedLogin.history) === null || _a4 === void 0 ? void 0 : _a4.currentRevisionId,
              loginDifferences: getLoginDifferencesForChange(modifiedLogin, void 0, completedLogin)
            }
          ],
          result: loginId
        };
      }, highSecurityCache);
    });
  }
  function modifyLogin(_a3, _b) {
    var ccs = __rest$t(_a3, []);
    var vaultId = _b.vaultId, loginId = _b.loginId, login = _b.login, highSecurityCache = _b.highSecurityCache, timesOverride = _b.timesOverride, source = _b.source;
    return __awaiter$Q(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      return modifyLoginVault(ccs, vault, (vaultContent, t2, { modifyLoginInternalWithHistory: modifyLoginInternalWithHistory2, protect: protect2 }) => {
        var _a4;
        const previousLogin = vaultContent.logins[loginId];
        const { newVaultContent } = modifyLoginInternalWithHistory2(vaultContent, t2, loginId, recursivelyTransformUnprotectedValues(completePartialEditLogin(vault, ccs.profileRepo, t2, source, login, timesOverride), protect2));
        const modifiedLogin = newVaultContent.logins[loginId];
        return {
          newVaultContent,
          auditlogEvents: [
            {
              type: AuditlogEventType.LOGIN_W_CHANGE,
              loginId,
              vaultId,
              loginEditTime: modifiedLogin.editTime,
              loginRevisionId: (_a4 = modifiedLogin.history) === null || _a4 === void 0 ? void 0 : _a4.currentRevisionId,
              loginDifferences: getLoginDifferencesForChange(modifiedLogin, previousLogin)
            }
          ],
          result: void 0
        };
      }, highSecurityCache);
    });
  }
  function addOrModifyLogin(_a3, _b) {
    var ccs = __rest$t(_a3, []);
    var vaultId = _b.vaultId, loginId = _b.loginId, login = _b.login, highSecurityCache = _b.highSecurityCache, source = _b.source, timesOverride = _b.timesOverride;
    return __awaiter$Q(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const newCcs = modifyLoginVault(ccs, vault, (vaultContent, t2, { addOrModifyLoginInternalWithHistory: addOrModifyLoginInternalWithHistory2, protect: protect2 }) => {
        var _a4;
        const previousLogin = vaultContent.logins[loginId];
        const completedLogin = completeFullEditLogin(vault, ccs.profileRepo, t2, source, login, timesOverride, previousLogin);
        const { newVaultContent } = addOrModifyLoginInternalWithHistory2(vaultContent, t2, loginId, recursivelyTransformUnprotectedValues(completedLogin, protect2));
        const modifiedLogin = newVaultContent.logins[loginId];
        return {
          newVaultContent,
          auditlogEvents: [
            {
              type: previousLogin ? AuditlogEventType.LOGIN_W_CHANGE : AuditlogEventType.LOGIN_W_CREATE,
              loginId,
              vaultId,
              loginEditTime: modifiedLogin.editTime,
              loginRevisionId: (_a4 = modifiedLogin.history) === null || _a4 === void 0 ? void 0 : _a4.currentRevisionId,
              loginDifferences: getLoginDifferencesForChange(modifiedLogin, previousLogin, completedLogin)
            }
          ],
          result: void 0
        };
      }, highSecurityCache);
      return Object.assign(Object.assign({}, newCcs), { returnResult: void 0 });
    });
  }
  function createInitialLoginHistoryEntryIfNecessary(_a3, _b) {
    var ccs = __rest$t(_a3, []);
    var vaultId = _b.vaultId, loginId = _b.loginId;
    return __awaiter$Q(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const previousLogin = vault.getContent().logins[loginId];
      if (!previousLogin) {
        throw new LoginNotFoundError(loginId);
      }
      if (previousLogin.history) {
        return Object.assign(Object.assign({}, ccs), { returnResult: previousLogin.history.currentRevisionId });
      }
      const newCcs = modifyLoginVault(ccs, vault, (vaultContent, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
        const initialRevisionId = newUuid$1();
        const loginWithoutHistory = __rest$t(previousLogin, ["history"]);
        const { newVaultContent } = modifyLoginInternal2(vaultContent, t2, loginId, {
          history: {
            currentRevisionId: initialRevisionId,
            revisions: {
              [initialRevisionId]: loginWithoutHistory
            }
          }
        });
        return { newVaultContent, auditlogEvents: [], result: initialRevisionId };
      });
      return newCcs;
    });
  }
  function copyLogins(_a3, toId, from) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      const logins = [];
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        const fromContent = fromVault.getContent();
        for (const loginId of loginIds) {
          const l2 = fromContent.logins[loginId];
          if (!l2) {
            throw new LoginNotFoundError(loginId);
          }
          if (l2.linkedFrom) {
            continue;
          }
          const redactedLogin = __rest$t(l2, ["shareLinks"]);
          const login = recursivelyTransformProtectedValues(redactedLogin, (pv) => protectedSecretRepo.unprotectWithContentId(fromVault, pv));
          logins.push(login);
        }
      }
      if (logins.length === 0) {
        return Object.assign(Object.assign({}, ccs), { returnResult: [] });
      }
      const toVault = ccs.vaultRepo.getLoginVaultById(toId);
      if (!toVault) {
        throw new VaultNotFoundError(toId);
      }
      return modifyLoginVault(ccs, toVault, (vaultContent, t2, { addLoginInternal: addLoginInternal2, protect: protect2 }) => {
        var _a4;
        const copiedLoginIds = [];
        const auditlogEvents = [];
        for (let _b of logins) {
          const login = __rest$t(_b, ["linkedTo"]);
          const { newVaultContent, result: result2 } = addLoginInternal2(vaultContent, t2, Object.assign(Object.assign({}, recursivelyTransformUnprotectedValues(login, protect2)), { editTime: t2, changeTime: t2 }));
          copiedLoginIds.push(result2);
          auditlogEvents.push({
            type: AuditlogEventType.LOGIN_W_CREATE,
            vaultId: toId,
            loginId: result2,
            loginEditTime: login.editTime,
            loginRevisionId: (_a4 = login.history) === null || _a4 === void 0 ? void 0 : _a4.currentRevisionId,
            loginDifferences: getLoginDifferences(emptyUnprotectedLogin, recursivelyTransformUnprotectedValues(login, (upv) => upv.unencrypted))
          });
          vaultContent = newVaultContent;
        }
        return { newVaultContent: vaultContent, auditlogEvents, result: copiedLoginIds };
      });
    });
  }
  function deleteLogins(_a3, from) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t2, { deleteLoginInternal: deleteLoginInternal2 }) => {
          var _a4;
          const auditlogEvents = [];
          let newVaultContent = vaultContent;
          for (const loginId of loginIds) {
            const login = newVaultContent.logins[loginId];
            if (login === void 0) {
              throw new LoginNotFoundError(loginId);
            }
            if (login.isDeleted) {
              continue;
            }
            ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t2, loginId));
            auditlogEvents.push({
              type: AuditlogEventType.LOGIN_W_DELETE,
              loginId,
              vaultId: fromId,
              loginEditTime: login.editTime,
              loginRevisionId: (_a4 = login.history) === null || _a4 === void 0 ? void 0 : _a4.currentRevisionId
            });
          }
          return { newVaultContent, auditlogEvents, result: void 0 };
        });
      }
      return ccs;
    });
  }
  function isLoginTrashable(login) {
    return !login.linkedFrom;
  }
  function deleteOrArchiveLogins(_a3, from) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        const { profileRepo } = ccs;
        ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t2, { deleteLoginInternal: deleteLoginInternal2, archiveLoginInternal: archiveLoginInternal2, modifyLoginInternal: modifyLoginInternal2 }) => {
          var _a4, _b;
          const auditlogEvents = [];
          const archivedByProfileId = getVaultEditProfileId(fromVault, profileRepo);
          let newVaultContent = vaultContent;
          for (const loginId of loginIds) {
            const login = newVaultContent.logins[loginId];
            if (!login) {
              throw new LoginNotFoundError(loginId);
            }
            if (login.isDeleted) {
              return { newVaultContent, auditlogEvents: [], result: void 0 };
            }
            if (!isLoginTrashable(login)) {
              ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t2, loginId));
              auditlogEvents.push({
                type: AuditlogEventType.LOGIN_W_DELETE,
                loginId,
                vaultId: fromId,
                loginEditTime: login.editTime,
                loginRevisionId: (_a4 = login.history) === null || _a4 === void 0 ? void 0 : _a4.currentRevisionId
              });
            } else {
              ({ newVaultContent } = modifyLoginInternal2(newVaultContent, t2, loginId, {
                shareLinks: void 0,
                linkedTo: void 0,
                archiveInfo: {
                  archiveTime: t2,
                  archivedByProfileId
                }
              }));
              ({ newVaultContent } = archiveLoginInternal2(newVaultContent, t2, loginId));
              auditlogEvents.push({
                type: AuditlogEventType.LOGIN_W_ARCHIVE,
                loginId,
                vaultId: fromId,
                loginEditTime: login.editTime,
                loginRevisionId: (_b = login.history) === null || _b === void 0 ? void 0 : _b.currentRevisionId
              });
            }
          }
          return { newVaultContent, auditlogEvents, result: void 0 };
        });
      }
      return ccs;
    });
  }
  function restoreArchivedLogins(_a3, from) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t2, { restoreArchivedLoginInternal: restoreArchivedLoginInternal2, modifyLoginInternal: modifyLoginInternal2 }) => {
          var _a4;
          const auditlogEvents = [];
          let newVaultContent = vaultContent;
          for (const loginId of loginIds) {
            const login = newVaultContent.logins[loginId];
            if (!login) {
              throw new LoginNotFoundError(loginId);
            }
            if (!login.isDeleted) {
              return { newVaultContent, auditlogEvents: [], result: void 0 };
            }
            if (!login.isArchived) {
              throw new LoginNotFoundError(loginId);
            }
            ({ newVaultContent } = restoreArchivedLoginInternal2(newVaultContent, t2, loginId));
            ({ newVaultContent } = modifyLoginInternal2(newVaultContent, t2, loginId, {
              archiveInfo: void 0,
              changeTime: t2
            }));
            auditlogEvents.push({
              type: AuditlogEventType.LOGIN_W_RESTORE_FROM_ARCHIVE,
              loginId,
              vaultId: fromId,
              loginEditTime: login.editTime,
              loginRevisionId: (_a4 = login.history) === null || _a4 === void 0 ? void 0 : _a4.currentRevisionId
            });
          }
          return { newVaultContent, auditlogEvents, result: void 0 };
        });
      }
      return ccs;
    });
  }
  function deleteArchivedLogins(_a3, from) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t2, { deleteLoginInternal: deleteLoginInternal2 }) => {
          var _a4;
          const auditlogEvents = [];
          let newVaultContent = vaultContent;
          for (const loginId of loginIds) {
            const login = newVaultContent.logins[loginId];
            if (!login || !login.isDeleted || !login.isArchived) {
              throw new LoginNotFoundError(loginId);
            }
            auditlogEvents.push({
              type: AuditlogEventType.LOGIN_W_DELETE,
              loginId,
              vaultId: fromId,
              loginEditTime: login.editTime,
              loginRevisionId: (_a4 = login.history) === null || _a4 === void 0 ? void 0 : _a4.currentRevisionId
            });
            ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t2, loginId));
          }
          return { newVaultContent, auditlogEvents, result: void 0 };
        });
      }
      return ccs;
    });
  }
  function moveLogins(_a3, toId, from) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      const copyResult = yield copyLogins(ccs, toId, from);
      ccs = yield deleteLogins(copyResult, from);
      return Object.assign(Object.assign({}, ccs), { returnResult: copyResult.returnResult });
    });
  }
  function modifyTagsForLogin(_a3, _b) {
    var ccs = __rest$t(_a3, []);
    var vaultId = _b.vaultId, loginIds = _b.loginIds, addTags = _b.addTags, removeTags = _b.removeTags, source = _b.source, highSecurityCache = _b.highSecurityCache;
    return __awaiter$Q(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      return modifyLoginVault(ccs, vault, (content2, t2, { modifyLoginInternalWithHistory: modifyLoginInternalWithHistory2 }) => {
        return loginIds.reduce((accumulator, loginId) => {
          var _a4;
          const login = accumulator.newVaultContent.logins[loginId];
          if (!login || !isHeymergeListValue(login)) {
            return accumulator;
          }
          const newTagsSet = new Set(login.tags);
          if (removeTags === null || removeTags === void 0 ? void 0 : removeTags.length) {
            removeTags.forEach((tag) => newTagsSet.delete(tag));
          }
          if (addTags === null || addTags === void 0 ? void 0 : addTags.length) {
            addTags.forEach((tag) => newTagsSet.add(tag));
          }
          const oldTags = (_a4 = login.tags) !== null && _a4 !== void 0 ? _a4 : [];
          if (newTagsSet.size == oldTags.length && oldTags.every((tag) => newTagsSet.has(tag))) {
            return accumulator;
          }
          return {
            newVaultContent: modifyLoginInternalWithHistory2(accumulator.newVaultContent, t2, loginId, completePartialEditLogin(vault, ccs.profileRepo, t2, source, {
              tags: [...newTagsSet]
            })).newVaultContent,
            auditlogEvents: [],
            result: accumulator.result + 1
          };
        }, { newVaultContent: content2, auditlogEvents: [], result: 0 });
      }, highSecurityCache);
    });
  }
  function modifyLinkedViewSecretsForLogin(_a3, targetVaultId, loginId, linkedViewSecrets) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(targetVaultId);
      if (!vault) {
        throw new VaultNotFoundError(targetVaultId);
      }
      return modifyLoginVault(ccs, vault, (content2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
        const result2 = modifyLoginInternal2(content2, t2, loginId, { linkedViewSecrets });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
      });
    });
  }
  function importLogins(_a3, targetVaultId, logins, emptyNameCustomFieldDefaultName) {
    var _b, _c2;
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      const targetVault = ccs.vaultRepo.getLoginVaultById(targetVaultId);
      if (!targetVault) {
        throw new VaultNotFoundError(targetVaultId);
      }
      const targetVaultOrgProfile = targetVault.organizationId ? ccs.profileRepo.getOrganizationProfile(targetVault.organizationId) : void 0;
      const profileId = (_c2 = (_b = targetVaultOrgProfile === null || targetVaultOrgProfile === void 0 ? void 0 : targetVaultOrgProfile.profile.id) !== null && _b !== void 0 ? _b : targetVault.getProfileId()) !== null && _c2 !== void 0 ? _c2 : void 0;
      return modifyLoginVault(ccs, targetVault, (c2, t2, { addLoginInternalWithHistory: addLoginInternalWithHistory2, protect: protect2 }) => {
        var _a4;
        const auditlogEvents = [];
        const existingLoginHashes = new Set(Object.values(c2.logins).filter((l2) => !l2.isDeleted).flatMap(getLoginHashes));
        let added = 0;
        let skippedDuplicate = 0;
        let skippedUnnamed = 0;
        let newVaultContent = c2;
        for (const unprotectedLogin of logins) {
          const fullUnprotectedLogin = sanitizeLoginFromImport(unprotectedLogin, profileId, t2, emptyNameCustomFieldDefaultName);
          const isLoginAndUnnamed = fullUnprotectedLogin.uiType === LoginUiType.login && fullUnprotectedLogin.username === "" && fullUnprotectedLogin.title === "" && fullUnprotectedLogin.websites.every((ws) => ws === "");
          if (isLoginAndUnnamed) {
            skippedUnnamed++;
            continue;
          }
          const hashes = getLoginHashes(fullUnprotectedLogin);
          const loginIsNew = hashes.some((h2) => !existingLoginHashes.has(h2));
          if (!loginIsNew) {
            skippedDuplicate++;
            continue;
          }
          let loginId;
          ({ newVaultContent, result: loginId } = addLoginInternalWithHistory2(newVaultContent, t2, transformLoginProtectedValues(fullUnprotectedLogin, (unencrypted) => protect2({ contentId: newUuid$1(), unencrypted }))));
          const newLogin = newVaultContent.logins[loginId];
          auditlogEvents.push({
            type: AuditlogEventType.LOGIN_W_CREATE,
            vaultId: targetVaultId,
            loginId,
            loginEditTime: newLogin.editTime,
            loginRevisionId: (_a4 = newLogin.history) === null || _a4 === void 0 ? void 0 : _a4.currentRevisionId,
            loginDifferences: getLoginDifferences(emptyUnprotectedLogin, fullUnprotectedLogin)
          });
          added++;
        }
        return {
          newVaultContent,
          auditlogEvents,
          result: { added, skippedDuplicate, skippedUnnamed }
        };
      });
    });
  }
  function linkLoginsToTeam(_a3, orgId, toVaultId, from) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      const toVault = ccs.vaultRepo.getLoginVaultById(toVaultId);
      if (!toVault) {
        throw new VaultNotFoundError(toVaultId);
      }
      if ((toVault === null || toVault === void 0 ? void 0 : toVault.type) !== VaultType.TEAM) {
        throw new Error("tried to link to non-team vault in linkLoginsToTeam");
      }
      if (toVault.organizationId !== orgId) {
        throw new Error("orgId mismatch for linking");
      }
      const org = ccs.accountState.getOrganization(toVault.organizationId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      ccs.accountState = ccs.accountState.withLocalAchievements([
        Achievement.COR_LINKED_LOGIN_CREATE_TEAM
      ]);
      return linkLoginsInternal(ccs, org.id, toVaultId, null, from);
    });
  }
  function linkLoginsToPersonalVault(_a3, orgId, toProfileId, from) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      ccs.accountState = ccs.accountState.withLocalAchievements([
        Achievement.COR_LINKED_LOGIN_CREATE_PERSONAL
      ]);
      const personalVaultId = findPersonalVaultId(ccs.accountState, ccs.vaultRepo, orgId, toProfileId);
      return linkLoginsInternal(ccs, orgId, personalVaultId, toProfileId, from);
    });
  }
  function linkLoginsInternal(ccs, orgId, targetVaultId, targetPersonalProfileId, from) {
    return __awaiter$Q(this, void 0, void 0, function* () {
      const orgProfile = ccs.profileRepo.getOrganizationProfile(orgId);
      if (!orgProfile) {
        throw new OrganizationNotFoundError();
      }
      const linkedByProfileId = orgProfile.profile.id;
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        if (fromId === targetVaultId) {
          throw new Error("internal: can't link login to identical vault");
        }
        return modifyLoginVault(ccs, fromVault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
          let newVaultContent = c2;
          for (const loginId of loginIds) {
            const existingElement = newVaultContent.logins[loginId];
            if (!existingElement || existingElement.isDeleted) {
              throw new LoginNotFoundError(loginId);
            }
            const originalLinkedTo = existingElement === null || existingElement === void 0 ? void 0 : existingElement.linkedTo;
            const linkedTo = originalLinkedTo ? [...originalLinkedTo] : [];
            const existing = linkedTo.find((lt) => lt.targetVaultId === targetVaultId);
            if (existing) {
              existing.addTime = t2;
              existing.removeTime = null;
            } else {
              linkedTo.push({
                targetVaultId,
                // NOTE: this value is not checked here, it is up to the caller to make sure it is
                // correct!
                targetPersonalProfileId,
                addTime: t2,
                linkedByProfileId,
                removeTime: null
              });
            }
            newVaultContent = modifyLoginInternal2(newVaultContent, t2, loginId, {
              linkedTo
            }).newVaultContent;
          }
          return { newVaultContent, auditlogEvents: [], result: void 0 };
        });
      }
      return ccs;
    });
  }
  function unlinkLogins(_a3, fromId, toIds, loginIds) {
    var ccs = __rest$t(_a3, []);
    return __awaiter$Q(this, void 0, void 0, function* () {
      const originalVault = ccs.vaultRepo.getLoginVaultById(fromId);
      if (!originalVault) {
        throw new VaultNotFoundError(fromId);
      }
      const fromContent = originalVault.getContent();
      return modifyLoginVault(ccs, originalVault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
        var _a4;
        let newVaultContent = c2;
        for (const loginId of loginIds) {
          const originalLinkedTo = (_a4 = fromContent.logins[loginId]) === null || _a4 === void 0 ? void 0 : _a4.linkedTo;
          if (!originalLinkedTo) {
            continue;
          }
          const linkedTo = originalLinkedTo.map((lt) => {
            const shouldBeDeleted = toIds.some((id2) => lt.targetVaultId === id2);
            return shouldBeDeleted ? Object.assign(Object.assign({}, lt), { removeTime: t2 }) : lt;
          });
          newVaultContent = modifyLoginInternal2(newVaultContent, t2, loginId, {
            linkedTo
          }).newVaultContent;
        }
        return { newVaultContent, auditlogEvents: [], result: void 0 };
      });
    });
  }
  function groupByVaultId(from) {
    const loginIdsByVault = /* @__PURE__ */ new Map();
    for (const { vaultId, loginId } of from) {
      if (!loginIdsByVault.has(vaultId)) {
        loginIdsByVault.set(vaultId, []);
      }
      loginIdsByVault.get(vaultId).push(loginId);
    }
    return loginIdsByVault;
  }
  function getLoginHashes(l2) {
    var _a3;
    if (l2.uiType === LoginUiType.creditCard) {
      return [canonicalize({ creditCardNumber: (_a3 = l2.creditCard) === null || _a3 === void 0 ? void 0 : _a3.number, title: l2.title })];
    }
    if (l2.uiType === LoginUiType.note) {
      return [canonicalize({ secureNote: l2.note, title: l2.title })];
    }
    if (l2.uiType === LoginUiType.wifi) {
      if (l2.username) {
        return [canonicalize({ wifiSsid: l2.wifiSsid, username: l2.username })];
      }
      return [canonicalize({ wifiSsid: l2.wifiSsid, title: l2.title })];
    }
    if (l2.websites.length) {
      return l2.websites.map((ws) => canonicalize(l2.username ? { username: l2.username, ws } : { title: l2.title, ws }));
    }
    return [canonicalize(l2.username ? { username: l2.username } : { title: l2.title })];
  }
  function completePartialEditLogin(vault, profileRepo, t2, source, editLogin, timesOverride) {
    const profileId = getVaultEditProfileId(vault, profileRepo);
    return Object.assign(Object.assign(Object.assign({}, editLogin), { editTime: t2, editProfileId: profileId, editSource: source, changeTime: t2 }), timesOverride);
  }
  function completeFullEditLogin(vault, profileRepo, t2, source, editLogin, timesOverride, previousLogin) {
    const profileId = getVaultEditProfileId(vault, profileRepo);
    return Object.assign(Object.assign(Object.assign({ creationTime: previousLogin ? previousLogin.creationTime : t2, creationProfileId: previousLogin ? previousLogin.creationProfileId : profileId, creationSource: previousLogin ? previousLogin.creationSource : source }, editLogin), { editTime: t2, editProfileId: profileId, editSource: source, changeTime: t2 }), timesOverride);
  }
  function getVaultEditProfileId(vault, profileRepo) {
    var _a3, _b;
    const organizationProfileId = vault.organizationId ? (_a3 = profileRepo.getOrganizationProfile(vault.organizationId)) === null || _a3 === void 0 ? void 0 : _a3.profile.id : void 0;
    const profileId = (_b = organizationProfileId !== null && organizationProfileId !== void 0 ? organizationProfileId : vault.getProfileId()) !== null && _b !== void 0 ? _b : void 0;
    return profileId;
  }
  function getLoginDifferencesForChange(modifiedLogin, previousLogin, completedLogin) {
    return previousLogin ? getLoginDifferences(previousLogin, modifiedLogin) : getLoginDifferences(emptyUnprotectedLogin, recursivelyTransformUnprotectedValues(completedLogin, (upv) => upv.unencrypted));
  }
  var __awaiter$P = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var AuditlogWriteResult;
  (function(AuditlogWriteResult2) {
    AuditlogWriteResult2["Ok"] = "ok";
    AuditlogWriteResult2["Failure"] = "failure";
    AuditlogWriteResult2["Retry"] = "retry";
  })(AuditlogWriteResult || (AuditlogWriteResult = {}));
  function onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, events) {
    return __awaiter$P(this, void 0, void 0, function* () {
      try {
        let auditlogWriteClient;
        ({ ccs, auditlogWriteClient } = yield onlineGetAuditlogWriteClient(ccs, orgId));
        yield auditlogWriteClient.writeEvents(events);
        return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Ok });
      } catch (e2) {
        if (e2 instanceof DomainError$1) {
          if (e2.code === BackendClientErrorCode.NoResponse) {
            return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Retry });
          }
          if (e2.code === BackendErrorCode.ORGANIZATION_NOT_FOUND) {
            return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Failure });
          }
          if (e2.code === BackendErrorCode.INTERNAL || e2.code === BackendClientErrorCode.InvalidGrpcResponse) {
            trackError(e2);
            return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Retry });
          }
        }
        trackError(e2);
        return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Failure });
      }
    });
  }
  function onlineGetAuditlogWriteClient(ccs, orgId) {
    return __awaiter$P(this, void 0, void 0, function* () {
      const cachedToken = ccs.auditlogWriteTokenCache.getToken(orgId);
      if (cachedToken) {
        const auditlogWriteClient2 = ccs.backendClient.getAuditlogWriteClient(cachedToken);
        return { ccs, auditlogWriteClient: auditlogWriteClient2 };
      }
      const token = yield ccs.backendClient.credential.createAuditlogWriteToken(orgId);
      ccs.auditlogWriteTokenCache = ccs.auditlogWriteTokenCache.withToken(orgId, token, token.expiresAt);
      const auditlogWriteClient = ccs.backendClient.getAuditlogWriteClient(token);
      return { ccs, auditlogWriteClient };
    });
  }
  function loadForeignProfile(dto) {
    const { id: id2, keyGenerationId } = dto;
    const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
    const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
    const highSecurityVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
    const highSecurityProfileSeedEncPubKey = loadEncryptionPublicKey(dto.highSecurityProfileSeedEncPubKey);
    const highSecurityProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityProfileSeedEncPubKeySignature);
    const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
    const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
    const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
    const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
    const storableProfileSeedEncPubKey = loadEncryptionPublicKey(dto.storableProfileSeedEncPubKey);
    const storableProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableProfileSeedEncPubKeySignature);
    return {
      id: id2,
      keyGenerationId,
      highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature,
      highSecurityProfileSeedEncPubKey,
      highSecurityProfileSeedEncPubKeySignature,
      storableSigPubKey,
      storableSigPubKeySignature,
      storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature,
      storableProfileSeedEncPubKey,
      storableProfileSeedEncPubKeySignature
    };
  }
  function serializeVaultProfileLock(lock) {
    return {
      lockingProfileId: lock.lockingProfileId,
      lockingProfileKeyGenerationId: lock.lockingProfileKeyGenerationId,
      encryptedStorableVaultKey: lock.encryptedStorableVaultKey,
      encryptedHighSecurityVaultKey: lock.encryptedHighSecurityVaultKey,
      encryptedVaultMessagePrivateKey: lock.encryptedVaultMessagePrivateKey
    };
  }
  class Commit {
    constructor(id2, parentId, blob) {
      this.id = id2;
      this.parentId = parentId;
      this.blob = blob;
    }
    static create(parentId, secret, state) {
      const blob = symEncrypt(secret, state);
      return new Commit(nullUuid, parentId, blob);
    }
    static load({ id: id2, parentId, blob }) {
      return new Commit(id2, parentId, loadSymEncryptedBlob(blob));
    }
    getContent(secret) {
      return symDecrypt(secret, this.blob);
    }
  }
  function serializeVaultAuthenticatorLock(lock) {
    return {
      authenticatorId: lock.authenticatorId,
      encryptedStorableVaultKey: lock.encryptedStorableVaultKey,
      encryptedHighSecurityVaultKey: lock.encryptedHighSecurityVaultKey,
      encryptedVaultMessagePrivateKey: lock.encryptedVaultMessagePrivateKey
    };
  }
  function unlockLockVaultSecret(vaultAccess, locks, profileLock, adminProfileLock) {
    if (vaultAccess.type === "admin-profile") {
      const { unlockedProfile: up } = vaultAccess;
      if (!adminProfileLock) {
        throw new LockProfileNotFoundError(up.profile.id);
      }
      if (up.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
      }
      return asymDecryptKek(up.storableVaultKeyEncPrivKey, adminProfileLock.encryptedStorableVaultKey);
    } else if (vaultAccess.type === "profile") {
      const { unlockedProfile: up } = vaultAccess;
      if (!profileLock) {
        throw new LockProfileNotFoundError(up.profile.id);
      }
      if (up.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
      }
      return asymDecryptKek(up.storableVaultKeyEncPrivKey, profileLock.encryptedStorableVaultKey);
    } else {
      const { unlockedAuthenticator: ua2 } = vaultAccess;
      const candidateLock = locks.find((lock) => lock.authenticatorId === ua2.authenticator.id);
      if (!candidateLock) {
        throw new LockAuthenticatorNotFoundError(ua2.authenticator.id, locks);
      }
      return asymDecryptKek(ua2.storableVaultKeyEncPrivKey, candidateLock.encryptedStorableVaultKey);
    }
  }
  var snappyjs = {};
  var snappy_decompressor = {};
  var WORD_MASK = [0, 255, 65535, 16777215, 4294967295];
  function copyBytes$1(fromArray, fromPos, toArray2, toPos, length) {
    var i2;
    for (i2 = 0; i2 < length; i2++) {
      toArray2[toPos + i2] = fromArray[fromPos + i2];
    }
  }
  function selfCopyBytes(array, pos, offset, length) {
    var i2;
    for (i2 = 0; i2 < length; i2++) {
      array[pos + i2] = array[pos - offset + i2];
    }
  }
  function SnappyDecompressor$1(compressed) {
    this.array = compressed;
    this.pos = 0;
  }
  SnappyDecompressor$1.prototype.readUncompressedLength = function() {
    var result2 = 0;
    var shift = 0;
    var c2, val;
    while (shift < 32 && this.pos < this.array.length) {
      c2 = this.array[this.pos];
      this.pos += 1;
      val = c2 & 127;
      if (val << shift >>> shift !== val) {
        return -1;
      }
      result2 |= val << shift;
      if (c2 < 128) {
        return result2;
      }
      shift += 7;
    }
    return -1;
  };
  SnappyDecompressor$1.prototype.uncompressToBuffer = function(outBuffer) {
    var array = this.array;
    var arrayLength = array.length;
    var pos = this.pos;
    var outPos = 0;
    var c2, len, smallLen;
    var offset;
    while (pos < array.length) {
      c2 = array[pos];
      pos += 1;
      if ((c2 & 3) === 0) {
        len = (c2 >>> 2) + 1;
        if (len > 60) {
          if (pos + 3 >= arrayLength) {
            return false;
          }
          smallLen = len - 60;
          len = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
          len = (len & WORD_MASK[smallLen]) + 1;
          pos += smallLen;
        }
        if (pos + len > arrayLength) {
          return false;
        }
        copyBytes$1(array, pos, outBuffer, outPos, len);
        pos += len;
        outPos += len;
      } else {
        switch (c2 & 3) {
          case 1:
            len = (c2 >>> 2 & 7) + 4;
            offset = array[pos] + (c2 >>> 5 << 8);
            pos += 1;
            break;
          case 2:
            if (pos + 1 >= arrayLength) {
              return false;
            }
            len = (c2 >>> 2) + 1;
            offset = array[pos] + (array[pos + 1] << 8);
            pos += 2;
            break;
          case 3:
            if (pos + 3 >= arrayLength) {
              return false;
            }
            len = (c2 >>> 2) + 1;
            offset = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
            pos += 4;
            break;
        }
        if (offset === 0 || offset > outPos) {
          return false;
        }
        selfCopyBytes(outBuffer, outPos, offset, len);
        outPos += len;
      }
    }
    return true;
  };
  snappy_decompressor.SnappyDecompressor = SnappyDecompressor$1;
  var snappy_compressor = {};
  var BLOCK_LOG = 16;
  var BLOCK_SIZE = 1 << BLOCK_LOG;
  var MAX_HASH_TABLE_BITS = 14;
  var globalHashTables = new Array(MAX_HASH_TABLE_BITS + 1);
  function hashFunc(key, hashFuncShift) {
    return key * 506832829 >>> hashFuncShift;
  }
  function load32(array, pos) {
    return array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
  }
  function equals32(array, pos1, pos2) {
    return array[pos1] === array[pos2] && array[pos1 + 1] === array[pos2 + 1] && array[pos1 + 2] === array[pos2 + 2] && array[pos1 + 3] === array[pos2 + 3];
  }
  function copyBytes(fromArray, fromPos, toArray2, toPos, length) {
    var i2;
    for (i2 = 0; i2 < length; i2++) {
      toArray2[toPos + i2] = fromArray[fromPos + i2];
    }
  }
  function emitLiteral(input, ip, len, output, op) {
    if (len <= 60) {
      output[op] = len - 1 << 2;
      op += 1;
    } else if (len < 256) {
      output[op] = 60 << 2;
      output[op + 1] = len - 1;
      op += 2;
    } else {
      output[op] = 61 << 2;
      output[op + 1] = len - 1 & 255;
      output[op + 2] = len - 1 >>> 8;
      op += 3;
    }
    copyBytes(input, ip, output, op, len);
    return op + len;
  }
  function emitCopyLessThan64(output, op, offset, len) {
    if (len < 12 && offset < 2048) {
      output[op] = 1 + (len - 4 << 2) + (offset >>> 8 << 5);
      output[op + 1] = offset & 255;
      return op + 2;
    } else {
      output[op] = 2 + (len - 1 << 2);
      output[op + 1] = offset & 255;
      output[op + 2] = offset >>> 8;
      return op + 3;
    }
  }
  function emitCopy(output, op, offset, len) {
    while (len >= 68) {
      op = emitCopyLessThan64(output, op, offset, 64);
      len -= 64;
    }
    if (len > 64) {
      op = emitCopyLessThan64(output, op, offset, 60);
      len -= 60;
    }
    return emitCopyLessThan64(output, op, offset, len);
  }
  function compressFragment(input, ip, inputSize, output, op) {
    var hashTableBits = 1;
    while (1 << hashTableBits <= inputSize && hashTableBits <= MAX_HASH_TABLE_BITS) {
      hashTableBits += 1;
    }
    hashTableBits -= 1;
    var hashFuncShift = 32 - hashTableBits;
    if (typeof globalHashTables[hashTableBits] === "undefined") {
      globalHashTables[hashTableBits] = new Uint16Array(1 << hashTableBits);
    }
    var hashTable = globalHashTables[hashTableBits];
    var i2;
    for (i2 = 0; i2 < hashTable.length; i2++) {
      hashTable[i2] = 0;
    }
    var ipEnd = ip + inputSize;
    var ipLimit;
    var baseIp = ip;
    var nextEmit = ip;
    var hash2, nextHash;
    var nextIp, candidate, skip;
    var bytesBetweenHashLookups;
    var base2, matched, offset;
    var prevHash, curHash;
    var flag = true;
    var INPUT_MARGIN = 15;
    if (inputSize >= INPUT_MARGIN) {
      ipLimit = ipEnd - INPUT_MARGIN;
      ip += 1;
      nextHash = hashFunc(load32(input, ip), hashFuncShift);
      while (flag) {
        skip = 32;
        nextIp = ip;
        do {
          ip = nextIp;
          hash2 = nextHash;
          bytesBetweenHashLookups = skip >>> 5;
          skip += 1;
          nextIp = ip + bytesBetweenHashLookups;
          if (ip > ipLimit) {
            flag = false;
            break;
          }
          nextHash = hashFunc(load32(input, nextIp), hashFuncShift);
          candidate = baseIp + hashTable[hash2];
          hashTable[hash2] = ip - baseIp;
        } while (!equals32(input, ip, candidate));
        if (!flag) {
          break;
        }
        op = emitLiteral(input, nextEmit, ip - nextEmit, output, op);
        do {
          base2 = ip;
          matched = 4;
          while (ip + matched < ipEnd && input[ip + matched] === input[candidate + matched]) {
            matched += 1;
          }
          ip += matched;
          offset = base2 - candidate;
          op = emitCopy(output, op, offset, matched);
          nextEmit = ip;
          if (ip >= ipLimit) {
            flag = false;
            break;
          }
          prevHash = hashFunc(load32(input, ip - 1), hashFuncShift);
          hashTable[prevHash] = ip - 1 - baseIp;
          curHash = hashFunc(load32(input, ip), hashFuncShift);
          candidate = baseIp + hashTable[curHash];
          hashTable[curHash] = ip - baseIp;
        } while (equals32(input, ip, candidate));
        if (!flag) {
          break;
        }
        ip += 1;
        nextHash = hashFunc(load32(input, ip), hashFuncShift);
      }
    }
    if (nextEmit < ipEnd) {
      op = emitLiteral(input, nextEmit, ipEnd - nextEmit, output, op);
    }
    return op;
  }
  function putVarint(value, output, op) {
    do {
      output[op] = value & 127;
      value = value >>> 7;
      if (value > 0) {
        output[op] += 128;
      }
      op += 1;
    } while (value > 0);
    return op;
  }
  function SnappyCompressor$1(uncompressed) {
    this.array = uncompressed;
  }
  SnappyCompressor$1.prototype.maxCompressedLength = function() {
    var sourceLen = this.array.length;
    return 32 + sourceLen + Math.floor(sourceLen / 6);
  };
  SnappyCompressor$1.prototype.compressToBuffer = function(outBuffer) {
    var array = this.array;
    var length = array.length;
    var pos = 0;
    var outPos = 0;
    var fragmentSize;
    outPos = putVarint(length, outBuffer, outPos);
    while (pos < length) {
      fragmentSize = Math.min(length - pos, BLOCK_SIZE);
      outPos = compressFragment(array, pos, fragmentSize, outBuffer, outPos);
      pos += fragmentSize;
    }
    return outPos;
  };
  snappy_compressor.SnappyCompressor = SnappyCompressor$1;
  function isNode() {
    if (typeof process === "object") {
      if (typeof process.versions === "object") {
        if (typeof process.versions.node !== "undefined") {
          return true;
        }
      }
    }
    return false;
  }
  function isUint8Array(object) {
    return object instanceof Uint8Array && (!isNode() || !Buffer.isBuffer(object));
  }
  function isArrayBuffer(object) {
    return object instanceof ArrayBuffer;
  }
  function isBuffer$2(object) {
    if (!isNode()) {
      return false;
    }
    return Buffer.isBuffer(object);
  }
  var SnappyDecompressor = snappy_decompressor.SnappyDecompressor;
  var SnappyCompressor = snappy_compressor.SnappyCompressor;
  var TYPE_ERROR_MSG = "Argument compressed must be type of ArrayBuffer, Buffer, or Uint8Array";
  function uncompress(compressed) {
    if (!isUint8Array(compressed) && !isArrayBuffer(compressed) && !isBuffer$2(compressed)) {
      throw new TypeError(TYPE_ERROR_MSG);
    }
    var uint8Mode = false;
    var arrayBufferMode = false;
    if (isUint8Array(compressed)) {
      uint8Mode = true;
    } else if (isArrayBuffer(compressed)) {
      arrayBufferMode = true;
      compressed = new Uint8Array(compressed);
    }
    var decompressor = new SnappyDecompressor(compressed);
    var length = decompressor.readUncompressedLength();
    if (length === -1) {
      throw new Error("Invalid Snappy bitstream");
    }
    var uncompressed, uncompressedView;
    if (uint8Mode) {
      uncompressed = new Uint8Array(length);
      if (!decompressor.uncompressToBuffer(uncompressed)) {
        throw new Error("Invalid Snappy bitstream");
      }
    } else if (arrayBufferMode) {
      uncompressed = new ArrayBuffer(length);
      uncompressedView = new Uint8Array(uncompressed);
      if (!decompressor.uncompressToBuffer(uncompressedView)) {
        throw new Error("Invalid Snappy bitstream");
      }
    } else {
      uncompressed = Buffer.alloc(length);
      if (!decompressor.uncompressToBuffer(uncompressed)) {
        throw new Error("Invalid Snappy bitstream");
      }
    }
    return uncompressed;
  }
  function compress(uncompressed) {
    if (!isUint8Array(uncompressed) && !isArrayBuffer(uncompressed) && !isBuffer$2(uncompressed)) {
      throw new TypeError(TYPE_ERROR_MSG);
    }
    var uint8Mode = false;
    var arrayBufferMode = false;
    if (isUint8Array(uncompressed)) {
      uint8Mode = true;
    } else if (isArrayBuffer(uncompressed)) {
      arrayBufferMode = true;
      uncompressed = new Uint8Array(uncompressed);
    }
    var compressor = new SnappyCompressor(uncompressed);
    var maxLength = compressor.maxCompressedLength();
    var compressed, compressedView;
    var length;
    if (uint8Mode) {
      compressed = new Uint8Array(maxLength);
      length = compressor.compressToBuffer(compressed);
    } else if (arrayBufferMode) {
      compressed = new ArrayBuffer(maxLength);
      compressedView = new Uint8Array(compressed);
      length = compressor.compressToBuffer(compressedView);
    } else {
      compressed = Buffer.alloc(maxLength);
      length = compressor.compressToBuffer(compressed);
    }
    return compressed.slice(0, length);
  }
  snappyjs.uncompress = uncompress;
  snappyjs.compress = compress;
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  const FORMAT_UNCOMPRESSED_AUTOMERGE = 91;
  const FORMAT_UNCOMPRESSED_HEYMERGE = 123;
  const FORMAT_SNAPPY = 1;
  function prependByte(data, byte) {
    const result2 = new Uint8Array(data.byteLength + 1);
    result2[0] = byte;
    result2.set(data, 1);
    return result2;
  }
  function serializeData(obj) {
    const str = JSON.stringify(obj);
    const bin = encoder.encode(str);
    const compressed = snappyjs.compress(bin);
    return prependByte(compressed, FORMAT_SNAPPY);
  }
  function deserializeData(data) {
    let decompressed;
    if (data[0] === FORMAT_UNCOMPRESSED_AUTOMERGE || data[0] === FORMAT_UNCOMPRESSED_HEYMERGE) {
      decompressed = data;
    } else if (data[0] === FORMAT_SNAPPY) {
      decompressed = snappyjs.uncompress(data.slice(1));
    } else {
      throw new UnsupportedCompressionError();
    }
    const str = decoder.decode(decompressed);
    const obj = JSON.parse(str);
    return obj;
  }
  const MetaVaultContent = MetaVaultContentV2;
  function createInitialMetaVaultContent() {
    return { sessions: {} };
  }
  const metaVaultContentDescriptor = {
    version: 2,
    contentTypeName: "meta",
    vaultTypes: [VaultType.META],
    parseVaultContent: MetaVaultContent.parse.bind(MetaVaultContent),
    createInitialVaultContent: createInitialMetaVaultContent
  };
  function replaceSession(content2, timestamp, id2, session) {
    const newVault = modifyVault$1(content2, "sessions", (list) => {
      var _a3;
      const oldSessionMeta = list[id2];
      const newElement = Object.assign(Object.assign(Object.assign({ creationTime: timestamp }, oldSessionMeta), session), { editTime: (_a3 = session === null || session === void 0 ? void 0 : session.editTime) !== null && _a3 !== void 0 ? _a3 : timestamp, isDeleted: false, updateTime: timestamp });
      return {
        newList: Object.assign(Object.assign({}, list), { [id2]: newElement }),
        result: void 0
      };
    });
    if (!MetaVaultContent.safeParse(newVault.newVaultContent).success) {
      throw new InvalidSessionModificationError();
    }
    return newVault;
  }
  function deleteSession(content2, timestamp, id2) {
    return modifyVault$1(content2, "sessions", (list) => {
      return removeElement(list, timestamp, id2);
    });
  }
  function addOrModifySiteSettings(content2, timestamp, host, siteSettings) {
    return modifyVault$1(content2, "siteSettings", (list) => {
      return addOrModifyElement(list, timestamp, host, siteSettings);
    });
  }
  function getAccountSettings(content2) {
    var _a3;
    return (_a3 = content2.accountSettings) === null || _a3 === void 0 ? void 0 : _a3[META_VAULT_ACCOUNT_SETTINGS_ID];
  }
  function modifyAccountSettings(content2, timestamp, settings) {
    return modifyVault$1(content2, "accountSettings", (list) => {
      if (!list[META_VAULT_ACCOUNT_SETTINGS_ID]) {
        return addOrModifyElement(list, timestamp, META_VAULT_ACCOUNT_SETTINGS_ID, Object.assign({}, settings));
      }
      return modifyElement(list, timestamp, META_VAULT_ACCOUNT_SETTINGS_ID, settings);
    });
  }
  const { OrganizationAdminVaultContent } = OAV;
  function getOrganizationAdminVaultInfo(content2) {
    var _a3;
    return (_a3 = content2.info) === null || _a3 === void 0 ? void 0 : _a3[ORGANIZATION_ADMIN_VAULT_INFO_ID];
  }
  function createInitialVaultContent() {
    return { info: {} };
  }
  const organizationAdminVaultContentDescriptor = {
    version: 2,
    contentTypeName: "organizationAdminV2",
    vaultTypes: [VaultType.ORGANIZATION_ADMIN],
    parseVaultContent: OrganizationAdminVaultContent.parse.bind(OrganizationAdminVaultContent),
    createInitialVaultContent
  };
  function replaceOrganizationAdminVaultInfo(content2, timestamp, info) {
    return modifyVault$1(content2, "info", (list) => {
      return addOrModifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
    });
  }
  function modifyOrganizationAdminVaultInfo(content2, timestamp, info) {
    return modifyVault$1(content2, "info", (list) => {
      return modifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
    });
  }
  function getVaultContentDescriptorByName(vaultType, contentTypeName, version) {
    const descriptor = getVaultContentDescriptor(contentTypeName, version);
    if (!descriptor.vaultTypes.includes(vaultType)) {
      throw new InvalidVaultContentDescriptorNameError(contentTypeName);
    }
    return descriptor;
  }
  function getVaultContentDescriptor(contentTypeName, version) {
    if (version !== DESCRIPTOR_VERSION_HEYMERGE) {
      throw new UnsupportedVaultVersionError();
    }
    switch (contentTypeName) {
      case loginVaultContentDescriptor.contentTypeName:
        return loginVaultContentDescriptor;
      case organizationPersonalVaultContentDescriptor.contentTypeName:
        return organizationPersonalVaultContentDescriptor;
      case metaVaultContentDescriptor.contentTypeName:
        return metaVaultContentDescriptor;
      case teamMetaVaultContentDescriptor.contentTypeName:
        return teamMetaVaultContentDescriptor;
      case legacyOrganizationAdminVaultContentDescriptor.contentTypeName:
        return legacyOrganizationAdminVaultContentDescriptor;
      case organizationAdminVaultContentDescriptor.contentTypeName:
        return organizationAdminVaultContentDescriptor;
      default:
        throw new InvalidVaultContentDescriptorNameError(contentTypeName);
    }
  }
  const validModificationFunctions = {
    addLoginInternal,
    modifyLoginInternal,
    addOrModifyLoginInternal,
    addLoginInternalWithHistory,
    modifyLoginInternalWithHistory,
    addOrModifyLoginInternalWithHistory,
    deleteLoginInternal,
    archiveLoginInternal,
    restoreArchivedLoginInternal,
    replaceSession,
    deleteSession,
    addOrModifySiteSettings,
    modifyTeamVaultInfo,
    addOrModifyTeamVaultUser,
    deleteTeamVaultUser,
    replaceLegacyOrganizationAdminVaultInfo,
    modifyLegacyOrganizationAdminVaultInfo,
    replaceOrganizationAdminVaultInfo,
    modifyOrganizationAdminVaultInfo,
    modifyAccountSettings
  };
  class VaultState {
    constructor(descriptor, state, stagedState) {
      this.descriptor = descriptor;
      this.state = state;
      this.stagedState = stagedState;
    }
    static createEmpty(descriptor) {
      return new VaultState(descriptor, descriptor.createInitialVaultContent(), {
        diff: descriptor.createInitialVaultContent(),
        updateTime: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    static initializeFromCommits(vaultType, commits) {
      const lastCommit = commits[commits.length - 1];
      const lastCommitState = deserializeData(lastCommit);
      if (Array.isArray(lastCommitState)) {
        throw new UnsupportedVaultVersionError();
      }
      const lastCommitStateParsed = VaultStateInternalStructure.safeParse(lastCommitState);
      if (!lastCommitStateParsed.success) {
        throw new InvalidCommitStructureError();
      }
      const descriptor = getVaultContentDescriptorByName(vaultType, lastCommitStateParsed.data.type, lastCommitStateParsed.data.version);
      let content2 = {};
      for (const commit of commits) {
        const commitState = deserializeData(commit);
        if (Array.isArray(commitState)) {
          throw new UnsupportedVaultVersionError();
        }
        const commitContent = VaultState.parseStateFromCommit(descriptor, commitState);
        content2 = mergeVaults(content2, commitContent, descriptor.postMergeHooks).newVaultContent;
      }
      return new VaultState(descriptor, content2, null);
    }
    static parseCommit(descriptor, inputCommit) {
      const parsed = VaultStateInternalStructure.safeParse(inputCommit);
      if (!parsed.success) {
        throw new InvalidCommitStructureError();
      }
      const state = parsed.data;
      if (state.version > descriptor.version) {
        throw new VaultContentTooNewError();
      }
      if (state.version < descriptor.version) {
        throw new NotImplementedError("vault content migration");
      }
      let content2;
      try {
        content2 = descriptor.parseVaultContent(state.content);
      } catch (e2) {
        trackError(e2);
        throw new InvalidCommitContentError();
      }
      return Object.assign(Object.assign({}, parsed.data), { content: content2 });
    }
    static parseStateFromCommit(descriptor, inputCommit) {
      return VaultState.parseCommit(descriptor, inputCommit).content;
    }
    withModification(modification) {
      var _a3, _b;
      const updateTime = (/* @__PURE__ */ new Date()).toISOString();
      const { newVaultContent: modifiedContent, result: modificationReturnValue } = modification(this.state, updateTime, validModificationFunctions);
      this.descriptor.parseVaultContent(modifiedContent);
      const { newVaultContent: newDiff } = diffVaults(this.state, modifiedContent, this.descriptor.postMergeHooks);
      const { newVaultContent } = mergeVaults((_b = (_a3 = this.stagedState) === null || _a3 === void 0 ? void 0 : _a3.diff) !== null && _b !== void 0 ? _b : this.descriptor.createInitialVaultContent(), newDiff, this.descriptor.postMergeHooks);
      const stagedState = {
        diff: newVaultContent,
        updateTime
      };
      return {
        state: new VaultState(this.descriptor, modifiedContent, stagedState),
        vaultContentDiff: newDiff,
        result: modificationReturnValue
      };
    }
    getContent() {
      return unpackHeymergeVaultContent(this.state);
    }
    getArchivedContent() {
      return unpackHeymergeVaultContentArchive(this.state);
    }
    getContentInternal() {
      return this.state;
    }
    applyCommit(commitData) {
      const deserialized = deserializeData(commitData);
      const commit = VaultState.parseCommit(this.descriptor, deserialized);
      const newState = this.loadAndValidateState(commit);
      return new VaultState(this.descriptor, newState, this.stagedState);
    }
    applyStagedDiff(diff) {
      var _a3, _b;
      const commit = deserializeData(diff);
      const newState = this.loadAndValidateState(commit);
      const { newVaultContent } = mergeVaults((_b = (_a3 = this.stagedState) === null || _a3 === void 0 ? void 0 : _a3.diff) !== null && _b !== void 0 ? _b : this.descriptor.createInitialVaultContent(), commit.content, this.descriptor.postMergeHooks);
      const stagedState = {
        diff: newVaultContent,
        updateTime: getMaxVaultUpdateTime(newVaultContent)
      };
      return new VaultState(this.descriptor, newState, stagedState);
    }
    loadAndValidateState(diff) {
      const { newVaultContent: content2 } = mergeVaults(
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        this.state,
        diff.content,
        this.descriptor.postMergeHooks
      );
      const state = {
        type: diff.type,
        version: diff.version,
        content: content2
      };
      VaultState.parseCommit(this.descriptor, state);
      return state.content;
    }
    getSquashedState() {
      const diff = diffVaults(this.descriptor.createInitialVaultContent(), this.state, this.descriptor.postMergeHooks);
      const commitWrap = {
        type: this.descriptor.contentTypeName,
        version: this.descriptor.version,
        content: diff.newVaultContent
      };
      return serializeData(commitWrap);
    }
    getStagedDiff(cappedUpdateTime) {
      if (this.stagedState === null) {
        return null;
      }
      let { state } = this;
      let { diff } = this.stagedState;
      if (cappedUpdateTime && cappedUpdateTime < this.stagedState.updateTime) {
        for (const k2 of getObjectKeys(diff)) {
          const { newVaultContent } = modifyVault$1(diff, k2, (list) => {
            return setMaxUpdateTime(list, cappedUpdateTime);
          });
          diff = newVaultContent;
        }
        for (const k2 of getObjectKeys(state)) {
          const { newVaultContent } = modifyVault$1(state, k2, (list) => {
            return setMaxUpdateTime(list, cappedUpdateTime);
          });
          state = newVaultContent;
        }
      }
      const commitWrap = {
        type: this.descriptor.contentTypeName,
        version: this.descriptor.version,
        content: diff
      };
      return {
        diff: serializeData(commitWrap),
        vaultState: new VaultState(this.descriptor, state, null),
        latestUpdateTime: cappedUpdateTime ? cappedUpdateTime : this.stagedState.updateTime
      };
    }
    hasStagedDiff() {
      return this.stagedState !== null;
    }
    getLatestUpdateTime() {
      var _a3, _b;
      return (_b = (_a3 = this.stagedState) === null || _a3 === void 0 ? void 0 : _a3.updateTime) !== null && _b !== void 0 ? _b : null;
    }
  }
  function getObjectKeys(obj) {
    return Object.keys(obj);
  }
  class Vault {
    constructor(id2, type, associatedVaultId, generationId, firstCommitId, commitId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, messageQueue, inboxSlug, linkedUpdateMessages, shareLinkUpdates) {
      this.id = id2;
      this.type = type;
      this.associatedVaultId = associatedVaultId;
      this.generationId = generationId;
      this.firstCommitId = firstCommitId;
      this.commitId = commitId;
      this.userIds = userIds;
      this.profileIds = profileIds;
      this.organizationId = organizationId;
      this.authenticatorLocks = authenticatorLocks;
      this.profileLock = profileLock;
      this.adminProfileLock = adminProfileLock;
      this.dirty = dirty;
      this.isUserJoined = isUserJoined;
      this.vaultState = vaultState;
      this.vaultSecret = vaultSecret;
      this.messagePublicKey = messagePublicKey;
      this.messageQueue = messageQueue;
      this.inboxSlug = inboxSlug;
      this.linkedUpdateMessages = linkedUpdateMessages;
      this.shareLinkUpdates = shareLinkUpdates;
    }
    static createFromCommits(id2, type, associatedVaultId, generationId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, vaultSecret, commits, stagedDiff, profileRepo, messagePublicKey, messageQueue, inboxSlug) {
      const firstCommitId = commits[0].id;
      const commitId = commits.slice(-1)[0].id;
      const rawCommits = commits.map((c2) => c2.getContent(vaultSecret));
      let vaultState = VaultState.initializeFromCommits(type, rawCommits);
      if (stagedDiff) {
        vaultState = vaultState.applyStagedDiff(stagedDiff);
      }
      const isUserJoined = profileRepo.profiles.some((p2) => profileIds.includes(p2.profile.id));
      if (profileLock) {
        const profile = profileRepo.getUnlocked(profileLock.lockingProfileId);
        if (!profile) {
          throw new LockProfileNotFoundError(profileLock.lockingProfileId);
        }
        if (profile.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
          throw new ProfileKeyGenerationMismatchError(profile.profile.id, profile.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
        }
      } else if (adminProfileLock && organizationId) {
        const profile = profileRepo.getOrgAdminProfile(organizationId);
        if (!profile) {
          throw new LockProfileNotFoundError(adminProfileLock.lockingProfileId);
        }
        if (profile.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
          throw new ProfileKeyGenerationMismatchError(profile.profile.id, profile.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
        }
      }
      return new Vault(id2, type, associatedVaultId, generationId, firstCommitId, commitId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, messageQueue, inboxSlug, [], []);
    }
    static createFromPersistable(pv, vaultAccess) {
      var _a3, _b, _c2, _d;
      const authenticatorLocks = pv.locks.map((al2) => VaultAuthenticatorLock.load(al2));
      const profileLock = pv.profileLock ? VaultProfileLock.load(pv.profileLock) : null;
      const adminProfileLock = pv.adminProfileLock ? VaultProfileLock.load(pv.adminProfileLock) : null;
      const vaultSecret = unlockLockVaultSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock);
      const vaultType = pv.type;
      let vaultState = VaultState.initializeFromCommits(vaultType, [pv.vaultState]);
      if (pv.stagedDiff) {
        vaultState = vaultState.applyStagedDiff(pv.stagedDiff);
      }
      const isUserJoined = vaultAccess.type === "profile";
      const messagePublicKey = pv.messagePublicKey ? loadEncryptionPublicKey(pv.messagePublicKey) : null;
      return new Vault(pv.id, vaultType, (_a3 = pv.associatedVaultId) !== null && _a3 !== void 0 ? _a3 : null, pv.generationId, (_b = pv.firstCommitId) !== null && _b !== void 0 ? _b : null, pv.commitId, pv.userIds, (_c2 = pv.profileIds) !== null && _c2 !== void 0 ? _c2 : [], (_d = pv.organizationId) !== null && _d !== void 0 ? _d : null, authenticatorLocks, profileLock, adminProfileLock, !!pv.dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, [], pv.inboxSlug, pv.linkedUpdateMessages, []);
    }
    getPersistable() {
      var _a3, _b, _c2;
      const vaultState = this.vaultState.getSquashedState();
      const stagedDiff = (_b = (_a3 = this.vaultState.getStagedDiff()) === null || _a3 === void 0 ? void 0 : _a3.diff) !== null && _b !== void 0 ? _b : null;
      return {
        id: this.id,
        type: this.type,
        associatedVaultId: this.associatedVaultId,
        generationId: this.generationId,
        firstCommitId: (_c2 = this.firstCommitId) !== null && _c2 !== void 0 ? _c2 : void 0,
        commitId: this.commitId,
        userIds: this.userIds,
        profileIds: this.profileIds,
        organizationId: this.organizationId,
        locks: this.authenticatorLocks.map((l2) => serializeVaultAuthenticatorLock(l2)),
        profileLock: this.profileLock ? serializeVaultProfileLock(this.profileLock) : void 0,
        adminProfileLock: this.adminProfileLock ? serializeVaultProfileLock(this.adminProfileLock) : void 0,
        dirty: this.dirty,
        vaultState,
        stagedDiff,
        messagePublicKey: this.messagePublicKey,
        inboxSlug: this.inboxSlug,
        linkedUpdateMessages: this.linkedUpdateMessages
      };
    }
    getProfileId() {
      var _a3, _b;
      return (_b = (_a3 = this.profileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId) !== null && _b !== void 0 ? _b : null;
    }
    getPersonalProfileId() {
      var _a3, _b;
      if (this.type !== VaultType.ORGANIZATION_PERSONAL) {
        return null;
      }
      if (this.profileLock) {
        return (_a3 = this.profileIds.find((id2) => {
          var _a4;
          return id2 === ((_a4 = this.profileLock) === null || _a4 === void 0 ? void 0 : _a4.lockingProfileId);
        })) !== null && _a3 !== void 0 ? _a3 : null;
      } else if (this.adminProfileLock) {
        return (_b = this.profileIds.find((id2) => {
          var _a4;
          return id2 !== ((_a4 = this.adminProfileLock) === null || _a4 === void 0 ? void 0 : _a4.lockingProfileId);
        })) !== null && _b !== void 0 ? _b : null;
      }
      return null;
    }
    with({ type = this.type, id: id2 = this.id, associatedVaultId = this.associatedVaultId, generationId = this.generationId, firstCommitId = this.firstCommitId, commitId = this.commitId, userIds = this.userIds, profileIds = this.profileIds, organizationId = this.organizationId, authenticatorLocks = this.authenticatorLocks, profileLock = this.profileLock, adminProfileLock = this.adminProfileLock, dirty = this.dirty, isUserJoined = this.isUserJoined, vaultState = this.vaultState, vaultSecret = this.vaultSecret, messageQueue = this.messageQueue, messagePublicKey = this.messagePublicKey, inboxSlug = this.inboxSlug, linkedUpdateMessages = this.linkedUpdateMessages, shareLinkUpdates = this.shareLinkUpdates }) {
      return new Vault(id2, type, associatedVaultId, generationId, firstCommitId, commitId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, messageQueue, inboxSlug, linkedUpdateMessages, shareLinkUpdates);
    }
    withSyncUpdate(su2, profileRepo) {
      let { userIds, profileIds, dirty, organizationId, profileLock, adminProfileLock, isUserJoined, messagePublicKey, inboxSlug } = this;
      let changed = false;
      const newUserIds = su2.users.map((u2) => u2.id);
      if (!Ee$1(userIds, newUserIds)) {
        changed = true;
        userIds = newUserIds;
      }
      const newProfileIds = su2.profiles.map((p2) => p2.id);
      if (!Ee$1(profileIds, newProfileIds)) {
        changed = true;
        profileIds = newProfileIds;
      }
      const newIsUserJoined = profileRepo.profiles.some((p2) => profileIds.includes(p2.profile.id));
      if (isUserJoined !== newIsUserJoined) {
        changed = true;
        isUserJoined = newIsUserJoined;
      }
      if (this.profileLock && (su2.profileKeyGenerationId !== this.profileLock.lockingProfileKeyGenerationId || !isUserJoined)) {
        changed = true;
        profileLock = null;
      }
      if (this.adminProfileLock && (su2.adminProfileKeyGenerationId !== this.adminProfileLock.lockingProfileKeyGenerationId || isUserJoined)) {
        changed = true;
        adminProfileLock = null;
      }
      if (su2.dirty !== dirty) {
        changed = true;
        dirty = su2.dirty;
      }
      if (su2.organizationId !== organizationId) {
        changed = true;
        organizationId = su2.organizationId;
      }
      if (su2.inboxSlug !== inboxSlug) {
        changed = true;
        inboxSlug = su2.inboxSlug;
      }
      const newMessagePublicKey = su2.messagePublicKey ? loadEncryptionPublicKey(su2.messagePublicKey) : null;
      if (!Ee$1(newMessagePublicKey, messagePublicKey)) {
        changed = true;
        messagePublicKey = newMessagePublicKey;
      }
      if (!changed) {
        return this;
      }
      return this.with({
        userIds,
        profileIds,
        dirty,
        organizationId,
        profileLock,
        adminProfileLock,
        isUserJoined,
        inboxSlug,
        messagePublicKey
      });
    }
    withDirty(dirty = true) {
      return this.dirty === dirty ? this : this.with({ dirty });
    }
    withLoadCommits(...commits) {
      let { commitId, vaultState } = this;
      for (const commit of commits) {
        if (commitId !== commit.parentId) {
          throw new ParentIdDoesntMatchError(this.commitId, commit.parentId);
        }
        try {
          const commitData = commit.getContent(this.vaultSecret);
          commitId = commit.id;
          vaultState = vaultState.applyCommit(commitData);
        } catch (e2) {
          commitId = commit.id;
          trackError(e2);
        }
      }
      return this.with({ commitId, vaultState });
    }
    withMessageQueue(messageQueue) {
      return this.with({ messageQueue });
    }
    withAddMessageQueue(...messageQueue) {
      const knownMessageIds = this.messageQueue.map((m2) => m2.id);
      const newMessages = messageQueue.filter((m2) => !knownMessageIds.includes(m2.id));
      return this.with({ messageQueue: [...this.messageQueue, ...newMessages] });
    }
    withLocks(vaultAccess, authenticatorLocks, profileLock, adminProfileLock) {
      if (vaultAccess.type === "admin-profile") {
        const { unlockedProfile: up } = vaultAccess;
        if (!adminProfileLock) {
          throw new LockProfileNotFoundError(up.profile.id);
        }
        if (up.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
          throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
        }
        return this.with({ authenticatorLocks: [], profileLock, adminProfileLock });
      } else if (vaultAccess.type === "profile") {
        const { unlockedProfile: up } = vaultAccess;
        if (!profileLock) {
          throw new LockProfileNotFoundError(up.profile.id);
        }
        if (up.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
          throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
        }
        return this.with({ authenticatorLocks: [], profileLock });
      } else {
        const { unlockedAuthenticator: ua2 } = vaultAccess;
        const isAuthenticatorLockAvailable = authenticatorLocks.some((l2) => l2.authenticatorId === ua2.authenticator.id);
        if (!isAuthenticatorLockAvailable) {
          throw new LockAuthenticatorNotFoundError(ua2.authenticator.id, authenticatorLocks);
        }
        return this.with({ authenticatorLocks, profileLock, adminProfileLock });
      }
    }
    withFirstCommitId(firstCommitId) {
      if (this.firstCommitId !== null) {
        throw new Error("Cannot change firstCommitId once set!");
      }
      return this.with({ firstCommitId });
    }
    getContentType() {
      return this.vaultState.descriptor.contentTypeName;
    }
    getVersion() {
      return this.vaultState.descriptor.version;
    }
    getStagedDiff(cappedUpdateTime) {
      const stagedData = this.vaultState.getStagedDiff(cappedUpdateTime === null || cappedUpdateTime === void 0 ? void 0 : cappedUpdateTime.toISOString());
      if (stagedData === null) {
        return null;
      }
      const { diff, vaultState, latestUpdateTime } = stagedData;
      const stagingVault = this.with({
        commitId: nullUuid,
        vaultState,
        linkedUpdateMessages: [],
        shareLinkUpdates: []
      });
      const { linkedUpdateMessages, shareLinkUpdates } = this;
      return { stagingVault, diff, latestUpdateTime, linkedUpdateMessages, shareLinkUpdates };
    }
    hasStagedDiff() {
      return this.vaultState.hasStagedDiff();
    }
    withCommitId(commitId) {
      if (this.id === nullUuid || this.commitId !== nullUuid) {
        throw new CannotOverrideCommitIdError();
      }
      return this.with({ commitId });
    }
    withModification(mod) {
      const { state: vaultState, vaultContentDiff, result: result2 } = this.vaultState.withModification(
        // @ts-ignore -- ts doesn't understand that HeymergeVaultContent<VaultContentSpec<T>> = T
        mod
      );
      return {
        vault: this.with({ vaultState }),
        // @ts-ignore -- ts doesn't understand that HeymergeVaultContent<VaultContentSpec<T>> = T
        vaultContentDiff,
        result: result2
      };
    }
    withAddLinkedUpdateMessage(...linkedUpdateMessages) {
      return this.with({
        linkedUpdateMessages: [...this.linkedUpdateMessages, ...linkedUpdateMessages]
      });
    }
    withAddShareLinkUpdate(...shareLinkUpdates) {
      return this.with({
        shareLinkUpdates: [...this.shareLinkUpdates, ...shareLinkUpdates]
      });
    }
    getContent() {
      return this.vaultState.getContent();
    }
    getArchivedContent() {
      return this.vaultState.getArchivedContent();
    }
    getContentInternal() {
      return this.vaultState.getContentInternal();
    }
  }
  class UnsyncedVault {
    constructor(type, userIds, profileIds, authenticatorLocks, profileLock, adminProfileLock, vaultState, commitBlob, organizationId, vaultSecret, protectedSecret, messageKeyPair, inbox) {
      this.type = type;
      this.userIds = userIds;
      this.profileIds = profileIds;
      this.authenticatorLocks = authenticatorLocks;
      this.profileLock = profileLock;
      this.adminProfileLock = adminProfileLock;
      this.vaultState = vaultState;
      this.commitBlob = commitBlob;
      this.organizationId = organizationId;
      this.vaultSecret = vaultSecret;
      this.protectedSecret = protectedSecret;
      this.messageKeyPair = messageKeyPair;
      this.inbox = inbox;
    }
    getCreationDto() {
      var _a3, _b;
      return {
        blob: this.getCommitBlob(),
        locks: this.getAuthenticatorLockDtos(),
        profileLock: this.getProfileLockDto(),
        adminProfileLock: this.getAdminProfileLockDto(),
        messagePublicKey: (_a3 = this.messageKeyPair) === null || _a3 === void 0 ? void 0 : _a3.encPubKey,
        organizationId: (_b = this.organizationId) !== null && _b !== void 0 ? _b : void 0
      };
    }
    getAuthenticatorLockDtos() {
      return this.authenticatorLocks.map(serializeVaultAuthenticatorLock);
    }
    getProfileLockDto() {
      var _a3;
      return (_a3 = this.profileLock) !== null && _a3 !== void 0 ? _a3 : void 0;
    }
    getAdminProfileLockDto() {
      var _a3;
      return (_a3 = this.adminProfileLock) !== null && _a3 !== void 0 ? _a3 : void 0;
    }
    getExtraProfileLockDto(up) {
      var _a3, _b;
      return VaultProfileLock.create(up, this.vaultSecret, this.protectedSecret, (_b = (_a3 = this.messageKeyPair) === null || _a3 === void 0 ? void 0 : _a3.encPrivKey) !== null && _b !== void 0 ? _b : null);
    }
    getExtraLockDto(ua2) {
      const encryptedStorableVaultKey = asymCreateKek(ua2.storableVaultKeyEncPubKey, this.vaultSecret);
      const encryptedHighSecurityVaultKey = asymCreateKek(ua2.highSecurityVaultKeyEncPubKey, this.protectedSecret);
      const encryptedVaultMessagePrivateKey = this.messageKeyPair ? asymEncryptEncryptionPrivateKey(ua2.highSecurityVaultKeyEncPubKey, this.messageKeyPair.encPrivKey) : null;
      return {
        encryptedStorableVaultKey,
        encryptedHighSecurityVaultKey,
        encryptedVaultMessagePrivateKey
      };
    }
    getCommitBlob() {
      return this.commitBlob;
    }
    static create(type, userIds, profileIds, authenticators, profile, adminProfile, organizationId, descriptor, inbox, mod) {
      const vaultSecret = newSymmetricSecret();
      const protectedSecret = newSymmetricSecret();
      const messageKeyPair = newEncryptionKeyPair();
      const authenticatorLocks = authenticators.map((a) => VaultAuthenticatorLock.create(a, vaultSecret, protectedSecret, messageKeyPair.encPrivKey));
      const profileLock = profile ? VaultProfileLock.create(profile, vaultSecret, protectedSecret, messageKeyPair.encPrivKey) : null;
      const adminProfileLock = adminProfile ? VaultProfileLock.create(adminProfile, vaultSecret, protectedSecret, messageKeyPair.encPrivKey) : null;
      const initialVaultState = UnsyncedVault.createInitialVaultState(descriptor, protectedSecret, mod);
      const { diff, vaultState } = initialVaultState.getStagedDiff();
      const { blob } = Commit.create(null, vaultSecret, diff);
      return new UnsyncedVault(type, userIds, profileIds, authenticatorLocks, profileLock, adminProfileLock, vaultState, blob, organizationId, vaultSecret, protectedSecret, messageKeyPair, inbox);
    }
    static createInitialVaultState(descriptor, protectedSecret, mod) {
      if (descriptor.version !== DESCRIPTOR_VERSION_HEYMERGE) {
        throw new UnsupportedVaultVersionError();
      }
      let initialVaultState = VaultState.createEmpty(descriptor);
      if (mod) {
        ({ state: initialVaultState } = initialVaultState.withModification(UnsyncedVault.wrapMod(mod, protectedSecret)));
      }
      return initialVaultState;
    }
    static wrapMod(mod, protectedSecret) {
      return (c2, t2, fns) => {
        return mod(c2, t2, Object.assign(Object.assign({}, fns), {
          protect: protect.bind(null, protectedSecret),
          unprotect: unprotect.bind(null, protectedSecret),
          unprotectWithContentId: unprotectWithContentId.bind(null, protectedSecret),
          // NOTE: there are no vault messages in unsynced vaults, so decryptVaultMessage is not needed
          decryptVaultMessage: null
        }));
      };
    }
    withIds(vaultId, generationId, commitId, associatedVaultId, organizationId) {
      var _a3, _b, _c2, _d;
      const firstCommitId = commitId;
      return new Vault(vaultId, this.type, associatedVaultId !== null && associatedVaultId !== void 0 ? associatedVaultId : null, generationId, firstCommitId, commitId, this.userIds, this.profileIds, organizationId, this.authenticatorLocks, this.profileLock, this.adminProfileLock, false, true, this.vaultState, this.vaultSecret, (_b = (_a3 = this.messageKeyPair) === null || _a3 === void 0 ? void 0 : _a3.encPubKey) !== null && _b !== void 0 ? _b : null, [], (_d = (_c2 = this.inbox) === null || _c2 === void 0 ? void 0 : _c2.slug) !== null && _d !== void 0 ? _d : null, [], []);
    }
  }
  class HighSecurityCache {
    constructor(userHsua) {
      this.userHsua = userHsua;
      this.cachedHighSecurityUnlockedProfiles = {};
    }
    static fromExisting(userHsua) {
      return new HighSecurityCache(userHsua);
    }
    static fromSecret(secret, authenticator) {
      const hsua = HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(authenticator, secret);
      return new HighSecurityCache(hsua);
    }
    static fromSessionUnlock(unlockData, sessionEncPrivKey, authenticators) {
      const authenticator = authenticators.find((a) => unlockData.authenticatorId === a.id);
      if (authenticator === void 0) {
        throw new UnlockedAuthenticatorNotFoundError();
      }
      const { encryptedSecret } = unlockData;
      const hsua = HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(authenticator, {
        authenticatorId: authenticator.id,
        seed: asymDecrypt(sessionEncPrivKey, loadAsymEncryptedBlob(encryptedSecret))
      });
      return new HighSecurityCache(hsua);
    }
    getAuthenticator() {
      return this.userHsua.authenticator;
    }
    getHighSecurityUnlockedAuthenticator() {
      return this.userHsua;
    }
    getHighSecurityUnlockedProfile(unlockedProfile, profileRepo) {
      if (this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId]) {
        return this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId];
      }
      if (unlockedProfile.profile.profileLock) {
        const parentUp = profileRepo.getUnlocked(unlockedProfile.profile.profileLock.lockingProfileId);
        if (!parentUp) {
          throw new LockProfileNotFoundError(unlockedProfile.profile.profileLock.lockingProfileId);
        }
        const parentHsup = this.getHighSecurityUnlockedProfile(parentUp, profileRepo);
        if (!parentHsup) {
          throw new LockProfileNotFoundError(unlockedProfile.profile.profileLock.lockingProfileId);
        }
        const hsup = HighSecurityUnlockedProfile.fromProfileLock(unlockedProfile, parentHsup);
        this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId] = hsup;
        return hsup;
      } else {
        const hsup = HighSecurityUnlockedProfile.fromAuthenticatorLocks(unlockedProfile, this.userHsua);
        this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId] = hsup;
        return hsup;
      }
    }
  }
  const KNOWN_USER_PROFILE_TYPES = [
    ProfileType.PREFERENCES,
    ProfileType.INBOX,
    ProfileType.PRIVATE,
    ProfileType.ORGANIZATION,
    ProfileType.ORGANIZATION_SERVICE
  ];
  const LOGIN_PROFILE_TYPES = [
    ProfileType.PRIVATE,
    ProfileType.ORGANIZATION,
    ProfileType.ORGANIZATION_SERVICE
  ];
  const ORGANIZATION_PROFILE_TYPES = [
    ProfileType.ORGANIZATION,
    ProfileType.ORGANIZATION_SERVICE
  ];
  class ProfileRepo {
    constructor(profiles, disabledProfiles, orgAdminProfiles) {
      this.profiles = profiles;
      this.disabledProfiles = disabledProfiles;
      this.orgAdminProfiles = orgAdminProfiles;
    }
    static create(profiles, disabledProfiles) {
      profiles.sort((a, b2) => {
        if (a.profile.profileType !== b2.profile.profileType) {
          return a.profile.profileType - b2.profile.profileType;
        }
        return a.profile.id.localeCompare(b2.profile.id);
      });
      return new ProfileRepo(profiles, disabledProfiles, []);
    }
    static createFromPersistable(persistable, ua2) {
      const profiles = persistable.profiles.map((p2) => UnlockedProfile.load(p2, ua2));
      const orgAdminProfiles = persistable.orgAdminProfiles.map((p2) => UnlockedProfile.load(p2, ua2));
      return new ProfileRepo(profiles, persistable.disabledProfiles, orgAdminProfiles);
    }
    getPersistable(ua2) {
      const orgAdminProfiles = this.orgAdminProfiles.map((p2) => p2.getPersistable(ua2));
      return {
        profiles: this.profiles.map((p2) => p2.getPersistable()),
        disabledProfiles: this.disabledProfiles,
        orgAdminProfiles
      };
    }
    withSyncUpdate(suProfiles, unlockedAuthenticator, profileEnabledPredicate) {
      const profiles = [];
      const disabledProfiles = [];
      const orgAdminProfiles = [];
      for (const p2 of suProfiles) {
        if (!KNOWN_USER_PROFILE_TYPES.includes(p2.profileType)) {
          continue;
        }
        if (p2.profileLock) {
          continue;
        }
        if (profileEnabledPredicate(p2)) {
          profiles.push(UnlockedProfile.load(p2, unlockedAuthenticator));
        } else {
          disabledProfiles.push(loadProfile(p2));
        }
      }
      for (const p2 of suProfiles) {
        if (p2.profileType !== ProfileType.ORGANIZATION_ADMIN || !p2.profileLock) {
          continue;
        }
        const lockingProfile = profiles.find((lp) => {
          var _a3;
          return ((_a3 = p2.profileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId) === lp.profile.id;
        });
        if (!lockingProfile) {
          continue;
        }
        const up = UnlockedProfile.load(p2, unlockedAuthenticator, lockingProfile);
        orgAdminProfiles.push(requireOrgAdminProfile(up));
      }
      return new ProfileRepo(profiles, disabledProfiles, orgAdminProfiles);
    }
    getUnlocked(profileId) {
      var _a3;
      return (_a3 = this.profiles.find((p2) => p2.profile.id === profileId)) !== null && _a3 !== void 0 ? _a3 : null;
    }
    hasProfile(profileId) {
      return this.profiles.some((p2) => p2.profile.id === profileId);
    }
    hasAtLeastOneLoginsProfile() {
      return this.profiles.some((p2) => LOGIN_PROFILE_TYPES.includes(p2.profile.profileType));
    }
    getPrivateProfile() {
      var _a3;
      return (_a3 = this.profiles.find((p2) => p2.profile.profileType === ProfileType.PRIVATE)) !== null && _a3 !== void 0 ? _a3 : null;
    }
    getInboxProfile() {
      var _a3;
      return (_a3 = this.profiles.find((p2) => p2.profile.profileType === ProfileType.INBOX)) !== null && _a3 !== void 0 ? _a3 : null;
    }
    getPreferencesProfile() {
      var _a3;
      return (_a3 = this.profiles.find((p2) => p2.profile.profileType === ProfileType.PREFERENCES)) !== null && _a3 !== void 0 ? _a3 : null;
    }
    getAllOrganizationProfiles() {
      return this.profiles.filter((p2) => ORGANIZATION_PROFILE_TYPES.includes(p2.profile.profileType));
    }
    getAllProfilesByLockingProfileId(lockingProfileId) {
      return this.orgAdminProfiles.filter((p2) => {
        var _a3;
        return ((_a3 = p2.profile.profileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId) === lockingProfileId;
      });
    }
    getOrganizationProfile(organizationId) {
      var _a3;
      return (_a3 = this.profiles.find((p2) => ORGANIZATION_PROFILE_TYPES.includes(p2.profile.profileType) && p2.profile.organizationId === organizationId)) !== null && _a3 !== void 0 ? _a3 : null;
    }
    getOrgAdminProfile(organizationId) {
      var _a3;
      return (_a3 = this.orgAdminProfiles.find((p2) => p2.profile.profileType === ProfileType.ORGANIZATION_ADMIN && p2.profile.organizationId === organizationId)) !== null && _a3 !== void 0 ? _a3 : null;
    }
    withOrgAdminProfile(unlockedProfile) {
      const existingProfile = this.getOrgAdminProfile(unlockedProfile.profile.organizationId);
      if ((existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.profile.keyGenerationId) === unlockedProfile.profile.keyGenerationId) {
        return this;
      }
      const otherOrgProfiles = this.orgAdminProfiles.filter((oap) => oap.profile.organizationId !== unlockedProfile.profile.organizationId);
      const adminProfiles = [...otherOrgProfiles, unlockedProfile];
      return new ProfileRepo(this.profiles, this.disabledProfiles, adminProfiles);
    }
    withRetainOrgAdminProfiles(keyGenerationIds) {
      const adminProfiles = this.orgAdminProfiles.filter((op) => keyGenerationIds.includes(op.profile.keyGenerationId));
      if (adminProfiles.length === this.orgAdminProfiles.length) {
        return this;
      }
      return new ProfileRepo(this.profiles, this.disabledProfiles, adminProfiles);
    }
    getAllLoginProfileIds() {
      return [
        ...this.profiles.flatMap((p2) => LOGIN_PROFILE_TYPES.includes(p2.profile.profileType) ? p2.profile.id : []),
        ...this.disabledProfiles.flatMap((p2) => LOGIN_PROFILE_TYPES.includes(p2.profileType) ? p2.id : [])
      ];
    }
  }
  function checkForeignVaultSyncPredicate(info, foreignVaultSyncPredicate) {
    var _a3, _b, _c2;
    const profileIds = info.type === "syncUpdate" ? info.vault.profiles.map((p2) => p2.id) : info.vault.profileIds;
    if (foreignVaultSyncPredicate.profileAllVaults && profileIds.some((pId) => {
      var _a4;
      return (_a4 = foreignVaultSyncPredicate.profileAllVaults) === null || _a4 === void 0 ? void 0 : _a4.includes(pId);
    })) {
      return true;
    }
    if (info.vault.organizationId && ((_a3 = foreignVaultSyncPredicate.organizationAllVaults) === null || _a3 === void 0 ? void 0 : _a3.includes(info.vault.organizationId))) {
      return true;
    }
    const type = info.type === "syncUpdate" ? info.vault.vaultType : info.vault.type;
    if (foreignVaultSyncPredicate.organizationTeamVaults && (type === VaultType.TEAM || type === VaultType.TEAM_META)) {
      return true;
    }
    if (info.vault.organizationId && type === VaultType.ORGANIZATION_PERSONAL) {
      const userIdsToSync = (_b = foreignVaultSyncPredicate.organizationPersonalVaultsForUsers) === null || _b === void 0 ? void 0 : _b[info.vault.organizationId];
      const userIds = info.type === "syncUpdate" ? info.vault.users.map((u2) => u2.id) : info.vault.userIds;
      const shouldSyncViaUser = !!userIdsToSync && userIds.some((uId) => userIdsToSync.includes(uId));
      if (shouldSyncViaUser) {
        return true;
      }
      const profileIdsToSync = (_c2 = foreignVaultSyncPredicate.organizationPersonalVaultsForProfiles) === null || _c2 === void 0 ? void 0 : _c2[info.vault.organizationId];
      const shouldSyncViaProfile = !!profileIdsToSync && profileIds.some((pId) => profileIdsToSync.includes(pId));
      if (shouldSyncViaProfile) {
        return true;
      }
    }
    return false;
  }
  function exponentialSlottedBackoff(attempt) {
    if (attempt === 0) {
      return Promise.resolve();
    }
    const maxDelaySlot = Math.pow(2, attempt);
    const delaySlot = Math.floor(Math.random() * maxDelaySlot);
    const delayMs = delaySlot * 100;
    return sleep(delayMs);
  }
  function getSessionUnlockedUntil(sessions, ccp) {
    var _a3, _b;
    return (_b = (_a3 = sessions.find((s2) => s2.id === ccp.loginData.sessionId)) === null || _a3 === void 0 ? void 0 : _a3.unlockedUntil) !== null && _b !== void 0 ? _b : null;
  }
  const KNOWN_VAULT_MESSAGE_TYPES = [
    VaultMessageType.LOGIN_INBOX_V1,
    VaultMessageType.LINKED_LOGIN_UPDATE_V1,
    VaultMessageType.LINKED_VAULT_DELETED_V1,
    VaultMessageType.SHARE_LINK_OPENED_V1
  ];
  function processVaultMessages(vault, decryptVaultMessage, protect2) {
    if (vault.dirty) {
      return { vault, processedMessageIds: [] };
    }
    const messages = vault.messageQueue;
    const remainingMessages = [];
    const processedMessageIds = [];
    let updatedVault = vault;
    for (const m2 of messages) {
      if (!KNOWN_VAULT_MESSAGE_TYPES.includes(m2.type)) {
        remainingMessages.push(m2);
        continue;
      }
      let decrypted;
      try {
        decrypted = decryptVaultMessage(m2);
      } catch (e2) {
        trackError(new Error(`could not decrypt vault message: ${e2}`));
        processedMessageIds.push(m2.id);
        continue;
      }
      try {
        if (m2.type === VaultMessageType.LOGIN_INBOX_V1) {
          updatedVault = processLoginInboxMessage(updatedVault, protect2, decrypted);
          processedMessageIds.push(m2.id);
        } else if (m2.type === VaultMessageType.LINKED_LOGIN_UPDATE_V1) {
          if (!m2.senderVaultId) {
            trackError(new Error(`dropping message with missing senderVaultId (vault ${vault.id})`));
            processedMessageIds.push(m2.id);
            continue;
          }
          updatedVault = processLinkedLoginUpdateMessage(m2.senderVaultId, updatedVault, protect2, decrypted);
          processedMessageIds.push(m2.id);
        } else if (m2.type === VaultMessageType.LINKED_VAULT_DELETED_V1) {
          if (!m2.senderVaultId) {
            trackError(new Error(`dropping message with missing senderVaultId (vault ${vault.id})`));
            processedMessageIds.push(m2.id);
            continue;
          }
          updatedVault = processLinkedVaultDeletedMessage(m2.senderVaultId, updatedVault);
          processedMessageIds.push(m2.id);
        } else if (m2.type === VaultMessageType.SHARE_LINK_OPENED_V1) {
          updatedVault = processShareLinkOpenedMessage(updatedVault, m2);
          processedMessageIds.push(m2.id);
        } else {
          remainingMessages.push(m2);
        }
      } catch (e2) {
        trackError(new Error(`error processing message for vault ${vault.id}, dropping: ${e2}`));
        processedMessageIds.push(m2.id);
      }
    }
    if (!processedMessageIds.length) {
      return { vault, processedMessageIds };
    }
    if (vault === updatedVault) {
      updatedVault = updatedVault.withModification((c2) => {
        return { newVaultContent: c2, result: void 0 };
      }).vault;
    }
    return {
      vault: updatedVault.withMessageQueue(remainingMessages),
      processedMessageIds
    };
  }
  function processLoginInboxMessage(vault, protect2, decrypted) {
    if (!decrypted) {
      throw new VaultMessageEncryptedDataNotFoundError();
    }
    if (vault.type !== VaultType.INBOX) {
      trackError(new Error(`found login inbox message V1 in non-inbox vault`));
      return vault;
    }
    const parsedMessage = LoginInboxMessageV1.parse(deserializeData(decrypted));
    const login = {
      uiType: LoginUiType.login,
      username: parsedMessage.username,
      websites: parsedMessage.website ? [parsedMessage.website] : [],
      password: protect2({ contentId: newUuid$1(), unencrypted: parsedMessage.password }),
      sender: parsedMessage.sender,
      creationTime: parsedMessage.creationTime,
      editTime: parsedMessage.creationTime,
      customFields: [],
      title: "",
      note: "",
      pendingInboxConfirmation: true,
      changeTime: parsedMessage.creationTime
    };
    return vault.withModification((c2, t2, { addLoginInternal: addLoginInternal2 }) => {
      return addLoginInternal2(c2, t2, login);
    }).vault;
  }
  function processLinkedLoginUpdateMessage(senderVaultId, vault, protect2, decrypted) {
    if (!decrypted) {
      throw new VaultMessageEncryptedDataNotFoundError();
    }
    if (vault.type !== VaultType.TEAM && vault.type !== VaultType.ORGANIZATION_PERSONAL) {
      trackError(new Error(`found linked login update message V1 in non-team non-personal vault`));
      return vault;
    }
    const parsedMessage = LinkedLoginUpdateMessageV1.parse(deserializeData(decrypted));
    return vault.withModification((c2, t2, { addOrModifyLoginInternal: addOrModifyLoginInternal2, modifyLoginInternal: modifyLoginInternal2, deleteLoginInternal: deleteLoginInternal2 }) => {
      var _a3;
      for (const update of parsedMessage) {
        const existingLogin = c2.logins[update.loginId];
        if (update.type === "originUpdated") {
          if (existingLogin && !existingLogin.isDeleted && !existingLogin.linkedFrom) {
            throw new Error("tried to manipulate non-linked login via linked login!");
          }
          const { loginId, content: content2 } = update;
          if (existingLogin && existingLogin.updateTime >= content2.updateTime) {
            continue;
          }
          if (content2.isDeleted) {
            if (!existingLogin.isDeleted) {
              c2 = deleteLoginInternal2(c2, content2.updateTime, loginId).newVaultContent;
            }
          } else {
            const protectedLogin = recursivelyTransformUnprotectedValues(content2, protect2);
            c2 = addOrModifyLoginInternal2(c2, content2.updateTime, loginId, protectedLogin).newVaultContent;
          }
        } else if (update.type === "targetDeleted") {
          if (!existingLogin.isDeleted) {
            const linkedTo = (_a3 = existingLogin.linkedTo) === null || _a3 === void 0 ? void 0 : _a3.flatMap((lt) => {
              if (lt.targetVaultId !== senderVaultId) {
                return lt;
              }
              return Object.assign(Object.assign({}, lt), { removeTime: update.removeTime });
            });
            c2 = modifyLoginInternal2(c2, t2, update.loginId, { linkedTo }).newVaultContent;
          }
        }
      }
      return { newVaultContent: c2, result: void 0 };
    }).vault;
  }
  function processLinkedVaultDeletedMessage(senderVaultId, vault) {
    if (vault.type !== VaultType.TEAM && vault.type !== VaultType.ORGANIZATION_PERSONAL) {
      trackError(new Error(`found linked vault deleted message V1 in non-team non-personal vault`));
      return vault;
    }
    return vault.withModification((c2, t2, { modifyLoginInternal: modifyLoginInternal2, deleteLoginInternal: deleteLoginInternal2 }) => {
      var _a3, _b, _c2;
      const linkedLogins = Object.entries(c2.logins).filter((e2) => !e2[1].isDeleted && !!(e2[1].linkedTo || e2[1].linkedFrom));
      for (const [loginId, login] of linkedLogins) {
        if (((_a3 = login.linkedFrom) === null || _a3 === void 0 ? void 0 : _a3.originVaultId) === senderVaultId) {
          c2 = deleteLoginInternal2(c2, t2, loginId).newVaultContent;
        } else if ((_b = login.linkedTo) === null || _b === void 0 ? void 0 : _b.some((lt) => lt.targetVaultId === senderVaultId)) {
          const linkedTo = (_c2 = login.linkedTo) === null || _c2 === void 0 ? void 0 : _c2.flatMap((lt) => {
            if (lt.targetVaultId !== senderVaultId) {
              return lt;
            }
            return Object.assign(Object.assign({}, lt), { removeTime: t2 });
          });
          c2 = modifyLoginInternal2(c2, t2, loginId, { linkedTo }).newVaultContent;
        }
      }
      return { newVaultContent: c2, result: void 0 };
    }).vault;
  }
  function processShareLinkOpenedMessage(vault, msg) {
    let parsedBackendMessage;
    try {
      if (!msg.backendMessage) {
        throw new Error("got share link opened message without backend message");
      }
      parsedBackendMessage = ShareLinkOpenedBackendMessageV1.parse(JSON.parse(naclUtilExports.encodeUTF8(msg.backendMessage)));
    } catch (e2) {
      trackError(e2);
      return vault;
    }
    const [shareLinkModificationInfo] = Object.entries(vault.getContent().logins).flatMap(([lId, login]) => {
      var _a3;
      if (!((_a3 = login.shareLinks) === null || _a3 === void 0 ? void 0 : _a3.some((sl2) => sl2.id === parsedBackendMessage.shareLinkId))) {
        return [];
      }
      const newShareLinks = login.shareLinks.map((sl2) => {
        if (sl2.id !== parsedBackendMessage.shareLinkId) {
          return sl2;
        }
        if (sl2.openedAt) {
          trackError("got share link opened message for previously opened share link");
        }
        return Object.assign(Object.assign({}, sl2), { openedAt: parsedBackendMessage.openedAt });
      });
      return [{ loginId: lId, login, newShareLinks }];
    });
    if (!shareLinkModificationInfo) {
      return vault;
    }
    return vault.withModification((c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => modifyLoginInternal2(c2, t2, shareLinkModificationInfo.loginId, {
      shareLinks: shareLinkModificationInfo.newShareLinks
    })).vault;
  }
  var __rest$s = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function regenerateVault(vault, authenticatorsByUser, profilesById, newAuths, newProfiles, oldProtectedSecret, oldVaultMessagePrivateKey) {
    return regenerateVaultForUsers(vault, authenticatorsByUser, profilesById, vault.userIds, vault.profileIds, newAuths, newProfiles, oldProtectedSecret, oldVaultMessagePrivateKey).regeneratedVaultDto;
  }
  function regenerateVaultForUsers(vault, authenticatorsByUser, profilesById, userIds, profileIds, newAuths, newProfiles, oldProtectedSecret, oldMessagePrivateKey) {
    const newVaultSecret = newSymmetricSecret();
    const newProtectedSecret = newSymmetricSecret();
    const newVaultMessageKeyPair = newEncryptionKeyPair();
    let { vault: updatedVault } = vault.withModification((c2, t2) => {
      return {
        newVaultContent: modifyProtectedValues(c2, t2, (pv) => {
          const unprotected = unprotectWithContentId(oldProtectedSecret, pv);
          const reprotected = protect(newProtectedSecret, unprotected);
          return reprotected;
        }),
        result: void 0
      };
    });
    let processedMessageIds = [];
    let regeneratedMessages = [];
    if (oldMessagePrivateKey) {
      const decryptVaultMessage = (msg) => {
        return msg.encryptedData ? asymDecrypt(oldMessagePrivateKey, loadAsymEncryptedBlob(msg.encryptedData)) : void 0;
      };
      const protectInVault = (uv) => protect(newProtectedSecret, uv);
      const result2 = processVaultMessages(updatedVault, decryptVaultMessage, protectInVault);
      updatedVault = result2.vault;
      processedMessageIds = result2.processedMessageIds;
      regeneratedMessages = updatedVault.messageQueue.map((_a3) => {
        var { encryptedData } = _a3, rest = __rest$s(_a3, ["encryptedData"]);
        let newEncryptedData;
        if (encryptedData) {
          const decryptedData = asymDecrypt(oldMessagePrivateKey, loadAsymEncryptedBlob(encryptedData));
          newEncryptedData = asymEncrypt(newVaultMessageKeyPair.encPubKey, decryptedData);
        }
        return Object.assign(Object.assign({}, rest), { encryptedData: newEncryptedData });
      });
      updatedVault = updatedVault.withMessageQueue(regeneratedMessages);
    }
    const squashedVaultState = updatedVault.vaultState.getSquashedState();
    const authenticatorLocks = [];
    for (const userId of userIds) {
      const authenticators = authenticatorsByUser[userId];
      if (!authenticators) {
        throw new UserAuthenticatorsMissingForRegenerateError();
      }
      for (const a of authenticators) {
        const lock = VaultAuthenticatorLock.create(a, newVaultSecret, newProtectedSecret, newVaultMessageKeyPair.encPrivKey);
        authenticatorLocks.push(serializeVaultAuthenticatorLock(lock));
      }
    }
    const profileLocks = [];
    for (const profileId of profileIds) {
      const profile = profilesById[profileId];
      if (!profile) {
        throw new ProfileMissingForRegenerateError();
      }
      const lock = VaultProfileLock.create(profile, newVaultSecret, newProtectedSecret, newVaultMessageKeyPair.encPrivKey);
      profileLocks.push(serializeVaultProfileLock(lock));
    }
    const newAuthenticatorEncryptedStorableVaultKeys = newAuths.map((a) => asymCreateKek(a.storableVaultKeyEncPubKey, newVaultSecret));
    const newAuthenticatorEncryptedHighSecurityVaultKeys = newAuths.map((a) => asymCreateKek(a.highSecurityVaultKeyEncPubKey, newProtectedSecret));
    const newAuthenticatorEncryptedVaultMessagePrivateKeys = newAuths.map((a) => asymEncryptEncryptionPrivateKey(a.highSecurityVaultKeyEncPubKey, newVaultMessageKeyPair.encPrivKey));
    const newProfileLockDtos = newProfiles.map((p2) => ({
      lockingProfileId: nullUuid,
      lockingProfileKeyGenerationId: nullUuid,
      encryptedStorableVaultKey: asymCreateKek(p2.storableVaultKeyEncPubKey, newVaultSecret),
      encryptedHighSecurityVaultKey: asymCreateKek(p2.highSecurityVaultKeyEncPubKey, newProtectedSecret),
      encryptedVaultMessagePrivateKey: newVaultMessageKeyPair !== null ? asymEncryptEncryptionPrivateKey(p2.highSecurityVaultKeyEncPubKey, newVaultMessageKeyPair.encPrivKey) : null
    }));
    const { blob } = Commit.create(null, newVaultSecret, squashedVaultState);
    return {
      regeneratedVaultDto: {
        id: updatedVault.id,
        latestCommitId: updatedVault.commitId,
        locks: authenticatorLocks,
        profileLocks,
        blob,
        newAuthenticatorEncryptedStorableVaultKeys,
        newAuthenticatorEncryptedHighSecurityVaultKeys,
        newAuthenticatorEncryptedVaultMessagePrivateKeys,
        messagePublicKey: newVaultMessageKeyPair === null || newVaultMessageKeyPair === void 0 ? void 0 : newVaultMessageKeyPair.encPubKey,
        deleteMessageIds: processedMessageIds,
        regeneratedMessages
      },
      newProfileLockDtos
    };
  }
  var __awaiter$O = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalGetUsers(backendClient, [...userIds], [...profileIds], userEmails, organizationId) {
    return __awaiter$O(this, void 0, void 0, function* () {
      const emailsByUserId = {};
      if (userEmails.length) {
        const resolvedEmails = yield backendClient.account.resolveEmails(userEmails, true);
        for (const re2 of resolvedEmails) {
          if (re2.emailInvalid) {
            debugConsole.error("unexpected invalid email", re2.email);
            continue;
          }
          if (!userEmails.includes(re2.email)) {
            debugConsole.error("unexpected extra email", re2.email);
            continue;
          }
          const orgProfile = re2.profiles.find((p2) => p2.profileType === ProfileType.ORGANIZATION && p2.organizationId === organizationId);
          if (orgProfile) {
            profileIds.push(orgProfile.profileId);
            continue;
          }
          const privateProfile = re2.profiles.find((p2) => p2.profileType === ProfileType.PRIVATE);
          if (privateProfile) {
            profileIds.push(privateProfile.profileId);
            continue;
          }
          if (re2.userId) {
            userIds.push(re2.userId);
            emailsByUserId[re2.userId] = re2.email;
            continue;
          }
        }
      }
      const index2 = [];
      const authenticatorsByUser = {};
      if (userIds.length) {
        const knownUserIds = [...userIds].map((id2) => ({ id: id2 }));
        const { users } = yield backendClient.account.list(knownUserIds, [], []);
        for (const { id: id2, authenticators, isProfilesEnabled } of users) {
          authenticatorsByUser[id2] = authenticators.map((a) => loadForeignAuthenticator(a));
          index2.push({ email: emailsByUserId[id2], userId: id2, isProfilesEnabled });
        }
      }
      const profilesById = {};
      if (profileIds.length) {
        const profiles = yield backendClient.profile.list(profileIds);
        for (const profile of profiles) {
          profilesById[profile.id] = loadForeignProfile(profile);
          index2.push({ email: profile.email, profileId: profile.id, isProfilesEnabled: true });
        }
      }
      return { authenticatorsByUser, profilesById, index: index2 };
    });
  }
  var __awaiter$N = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalGetUsersForVaults({ backendClient, accountState, profileRepo }, vaults) {
    return __awaiter$N(this, void 0, void 0, function* () {
      const allUserIds = /* @__PURE__ */ new Set([
        ...vaults.map((v2) => v2.userIds).reduce((acc, val) => acc.concat(val), [])
      ]);
      const allProfileIds = new Set(vaults.map((v2) => v2.profileIds).reduce((acc, val) => acc.concat(val), []));
      allUserIds.delete(accountState.userId);
      profileRepo.profiles.forEach((p2) => allProfileIds.delete(p2.profile.id));
      const { authenticatorsByUser, profilesById, index: index2 } = yield onlineInternalGetUsers(backendClient, [...allUserIds], [...allProfileIds], []);
      profileRepo.profiles.forEach((p2) => profilesById[p2.profile.id] = p2.profile);
      return { authenticatorsByUser, profilesById, index: index2 };
    });
  }
  var __awaiter$M = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalCreateRegeneratedVault(ccs, vault, vaultAccess, hsc) {
    return __awaiter$M(this, void 0, void 0, function* () {
      const { protectedSecret, messagePrivateKey } = unlockLockProtectedSecret(vaultAccess, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, ccs.profileRepo, hsc);
      const { authenticatorsByUser, profilesById } = yield onlineInternalGetUsersForVaults(ccs, [
        vault
      ]);
      return regenerateVault(vault, authenticatorsByUser, profilesById, [], [], protectedSecret, messagePrivateKey);
    });
  }
  var __awaiter$L = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$r = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  var __asyncValues$1 = globalThis && globalThis.__asyncValues || function(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d2, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d2 });
      }, reject);
    }
  };
  function onlineInternalSync(_a3, syncUpdateArg, fcmMessageId, hsc) {
    var ccs = __rest$r(_a3, []);
    if (syncUpdateArg === void 0) {
      syncUpdateArg = null;
    }
    if (hsc === void 0) {
      hsc = null;
    }
    return __awaiter$L(this, void 0, void 0, function* () {
      const result2 = yield onlineInternalSyncReturningHighSecurityCache(ccs, syncUpdateArg, fcmMessageId, hsc);
      return result2.ccs;
    });
  }
  function onlineInternalSyncReturningHighSecurityCache(_a3, syncUpdateArg, fcmMessageId, hsc) {
    var ccs = __rest$r(_a3, []);
    if (syncUpdateArg === void 0) {
      syncUpdateArg = null;
    }
    if (hsc === void 0) {
      hsc = null;
    }
    return __awaiter$L(this, void 0, void 0, function* () {
      let su2 = syncUpdateArg;
      if (!su2 || su2.syncVersion && ccs.syncVersion && su2.syncVersion < ccs.syncVersion) {
        su2 = yield ccs.backendClient.sync.poll(fcmMessageId);
      }
      let shouldUpdateSyncVersion = true;
      ccs.lastKnownServerTime = su2.serverTime;
      ccs.clientOutdated = su2.clientOutdated;
      ccs.clientServerTimeOffsetMs = Date.now() - su2.serverTime.getTime();
      ccs.tokenRefreshNeeded = su2.tokenRefreshNeeded;
      ccs.accountState = ccs.accountState.withSyncUpdate(su2);
      ccs = yield onlineInternalSyncAuthenticatorChain(ccs, su2);
      ccs = onlineInternalSyncProfileRepo(ccs, su2);
      if (!hsc) {
        ({ ccs, hsc } = yield onlineInternalSyncSessionUnlock(ccs, su2));
      }
      try {
        ({ ccs, shouldUpdateSyncVersion } = yield onlineInternalSyncVaultRepo(ccs, su2, hsc));
      } catch (e2) {
        shouldUpdateSyncVersion = false;
        trackError(e2);
      }
      try {
        ccs = yield onlineInternalSyncAchievements(ccs, su2);
      } catch (e2) {
        trackError(e2);
      }
      try {
        ccs = yield onlineInternalSyncAuditlogEventQueue(ccs);
      } catch (e2) {
        trackError(e2);
      }
      if (su2.maintenanceSettings) {
        ccs.maintenanceSettings = su2.maintenanceSettings;
      }
      if (shouldUpdateSyncVersion) {
        ccs.syncVersion = su2.syncVersion;
        ccs.backendClient = ccs.backendClient.withSyncVersion(su2.syncVersion);
      }
      return { ccs, hsc: hsc !== null && hsc !== void 0 ? hsc : void 0 };
    });
  }
  function onlineInternalSyncProfileRepo(_a3, su2) {
    var ccs = __rest$r(_a3, []);
    if (su2.profiles) {
      const sessionId = ccs.backendClient.getSessionId();
      const session = ccs.accountState.sessions.find((s2) => s2.id === sessionId);
      const profileEnabledPredicate = (p2) => {
        var _a4;
        return isProfileEnabled(session, p2, (_a4 = ccs.ephemeralOperationState) === null || _a4 === void 0 ? void 0 : _a4.additionalEnabledProfileIds);
      };
      ccs.profileRepo = ccs.profileRepo.withSyncUpdate(su2.profiles, ccs.params.unlockedAuthenticator, profileEnabledPredicate);
      const availableProfileIds = ccs.profileRepo.profiles.map((p2) => p2.profile.id);
      ccs.vaultRepo = ccs.vaultRepo.withDeleteWithoutMatchingProfileLocks(availableProfileIds);
    }
    return ccs;
  }
  function isProfileEnabled(session, profile, ephemeralEnabledProfileIds) {
    if (!LOGIN_PROFILE_TYPES.includes(profile.profileType)) {
      return true;
    }
    if (!session) {
      return true;
    }
    if (session.enabledProfileIds.length === 0) {
      return true;
    }
    return session.enabledProfileIds.includes(profile.id) || !!(ephemeralEnabledProfileIds === null || ephemeralEnabledProfileIds === void 0 ? void 0 : ephemeralEnabledProfileIds.includes(profile.id));
  }
  function onlineInternalSyncAuthenticatorChain(_a3, su2) {
    var _b;
    var ccs = __rest$r(_a3, []);
    return __awaiter$L(this, void 0, void 0, function* () {
      if (su2.user) {
        if (su2.user.authenticatorBlockHash) {
          if (!ccs.accountState.authenticatorBlockHash || !hashEqual(loadHash(su2.user.authenticatorBlockHash), ccs.accountState.authenticatorBlockHash)) {
            const authListDto = yield ccs.backendClient.authenticator.list((_b = ccs.accountState.authenticatorBlockHash) !== null && _b !== void 0 ? _b : void 0);
            ccs.accountState = ccs.accountState.withAuthenticatorList(authListDto);
          }
        } else if (ccs.accountState.authenticatorBlockHash) {
          trackError(new Error("missing authenticator block hash"));
        } else {
          const authListDto = yield ccs.backendClient.authenticator.list();
          ccs.accountState = ccs.accountState.withAuthenticatorList(authListDto);
        }
      }
      return ccs;
    });
  }
  function onlineInternalSyncSessionUnlock(_a3, su2) {
    var _b, _c2;
    var ccs = __rest$r(_a3, []);
    return __awaiter$L(this, void 0, void 0, function* () {
      const { sessionUnlock } = su2;
      const ownSession = ccs.accountState.sessions.find((s2) => uuidEqual(s2.id, ccs.params.loginData.sessionId));
      if (ccs.ignoredUnlock && ownSession && ((_b = ownSession.unlockedAt) === null || _b === void 0 ? void 0 : _b.getTime()) === ((_c2 = ccs.ignoredUnlock) === null || _c2 === void 0 ? void 0 : _c2.getTime())) {
        ccs.protectedSecretRepo = null;
        return { ccs, hsc: null };
      }
      let hsc;
      const unlockedUntil = getSessionUnlockedUntil(ccs.accountState.sessions, ccs.params);
      if (ccs.pinnedAuthenticatorSecret) {
        const pinnedSecret = ccs.pinnedAuthenticatorSecret;
        const authenticator = ccs.accountState.authenticators.find((a) => pinnedSecret.authenticatorId === a.id);
        if (authenticator === void 0) {
          throw new UnlockedAuthenticatorNotFoundError();
        }
        hsc = HighSecurityCache.fromSecret(pinnedSecret, authenticator);
        if (!ccs.protectedSecretRepo) {
          ccs.protectedSecretRepo = ProtectedSecretRepo.create(ccs, hsc, null);
        }
      } else if (sessionUnlock) {
        hsc = HighSecurityCache.fromSessionUnlock(sessionUnlock, ccs.params.sessionKeys.encPrivKey, ccs.accountState.authenticators);
        if (!ccs.protectedSecretRepo) {
          ccs.protectedSecretRepo = ProtectedSecretRepo.create(ccs, hsc, unlockedUntil);
        } else if (unlockedUntil) {
          ccs.protectedSecretRepo = ccs.protectedSecretRepo.withUnlockedUntil(unlockedUntil);
        }
      } else {
        hsc = null;
        ccs.protectedSecretRepo = null;
      }
      ccs = refreshOrgAdminCaches(ccs, hsc);
      return { ccs, hsc };
    });
  }
  function refreshOrgAdminCaches(_a3, hsc) {
    var ccs = __rest$r(_a3, []);
    if (!ccs.backendClient.config.syncSuperUsers || !hsc || !ccs.protectedSecretRepo) {
      return ccs;
    }
    for (const org of ccs.accountState.organizations) {
      if (!org.adminInfo) {
        continue;
      }
      const orgVaultAccess = getOrgAdminVaultAccess(ccs.protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, hsc, org);
      if (!orgVaultAccess) {
        continue;
      }
      const secrets = {};
      for (const vault of ccs.vaultRepo.getForeignVaultsByOrganizationId(orgVaultAccess.orgId)) {
        if (ccs.protectedSecretRepo.hasVault(vault.id)) {
          continue;
        }
        try {
          const { protectedSecret, messagePrivateKey } = unlockLockProtectedSecret(orgVaultAccess, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, ccs.profileRepo, hsc);
          secrets[vault.id] = {
            generationId: vault.generationId,
            protectedSecret,
            messagePrivateKey
          };
        } catch (e2) {
          trackError(new Error(`Dropping vault ${vault.id} due to failed unlockLockProtectedSecret: ${e2}`));
          ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
        }
        ccs.protectedSecretRepo = ccs.protectedSecretRepo.withOrganization(org.id, secrets);
      }
    }
    return ccs;
  }
  function onlineInternalSyncVaultRepo(ccs, su2, hsc) {
    var _a3, e_1, _b, _c2;
    var _d, _e, _f, _g;
    return __awaiter$L(this, void 0, void 0, function* () {
      let { vaults: suVaultList } = su2;
      let shouldUpdateSyncVersion = true;
      const syncPromises = [];
      if (suVaultList === void 0) {
        for (const vault of ccs.vaultRepo.getAllVaults()) {
          if (shouldSyncVault(vault.type)) {
            syncPromises.push(onlineInternalSyncVault(ccs, vault, null, hsc, su2.serverTime));
          }
        }
      } else {
        suVaultList = suVaultList.filter((suv) => shouldUseSyncUpdateVault(ccs, suv));
        for (const vault of ccs.vaultRepo.getLegacyOrganizationAdminVaults()) {
          if (suVaultList.some((suv) => suv.id === vault.id)) {
            continue;
          }
          ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
          ccs.protectedSecretRepo = (_e = (_d = ccs.protectedSecretRepo) === null || _d === void 0 ? void 0 : _d.withDeleteProtectedSecret(vault.id)) !== null && _e !== void 0 ? _e : null;
        }
        const adminVaultSyncs = suVaultList.filter((v2) => v2.vaultType === VaultType.LEGACY_ORGANIZATION_ADMIN).map((v2) => {
          const localVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(v2.id);
          if (localVault) {
            return onlineInternalSyncVault(ccs, localVault, v2, hsc, su2.serverTime);
          } else {
            return onlineInternalInitializeVault(ccs, v2, hsc);
          }
        });
        try {
          for (var _h = true, adminVaultSyncs_1 = __asyncValues$1(adminVaultSyncs), adminVaultSyncs_1_1; adminVaultSyncs_1_1 = yield adminVaultSyncs_1.next(), _a3 = adminVaultSyncs_1_1.done, !_a3; _h = true) {
            _c2 = adminVaultSyncs_1_1.value;
            _h = false;
            const vaultSyncResult = _c2;
            if (vaultSyncResult.vault) {
              ccs = applyVaultSyncResult(ccs, vaultSyncResult);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_h && !_a3 && (_b = adminVaultSyncs_1.return))
              yield _b.call(adminVaultSyncs_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        ccs = refreshOrgAdminCaches(ccs, hsc);
        const localVaultIds = new Set(ccs.vaultRepo.getAllVaults().map((v2) => v2.id));
        for (const vault of ccs.vaultRepo.getAllVaults()) {
          if (vault.type === VaultType.LEGACY_ORGANIZATION_ADMIN) {
            continue;
          }
          const syncUpdateVault = suVaultList.find((suv) => suv.id === vault.id);
          if (!syncUpdateVault) {
            ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
            ccs.protectedSecretRepo = (_g = (_f = ccs.protectedSecretRepo) === null || _f === void 0 ? void 0 : _f.withDeleteProtectedSecret(vault.id)) !== null && _g !== void 0 ? _g : null;
          } else {
            syncPromises.push(onlineInternalSyncVault(ccs, vault, syncUpdateVault, hsc, su2.serverTime));
          }
        }
        const newVaults = suVaultList.filter((v2) => !localVaultIds.has(v2.id));
        for (const syncUpdateVault of newVaults) {
          syncPromises.push(onlineInternalInitializeVault(ccs, syncUpdateVault, hsc));
        }
      }
      const syncPromiseResults = yield Promise.allSettled(syncPromises);
      for (const syncPromiseResult of syncPromiseResults) {
        if (syncPromiseResult.status === "fulfilled") {
          ccs = applyVaultSyncResult(ccs, syncPromiseResult.value);
        } else {
          shouldUpdateSyncVersion = false;
          if (syncPromiseResult.reason instanceof DomainError$1 && syncPromiseResult.reason.code === ClientCoreErrorCode.VaultIsLocked)
            ;
          else {
            trackError(syncPromiseResult.reason);
          }
        }
      }
      for (const syncPromiseResult of syncPromiseResults) {
        if (syncPromiseResult.status === "fulfilled") {
          ccs = applyVaultSyncResultVaultMessages(ccs, syncPromiseResult.value);
        }
      }
      ccs = ensureVaultRepoConsistency(ccs);
      const adminOrgIds = ccs.accountState.organizations.filter((o2) => !!o2.adminInfo).map((o2) => o2.id);
      for (const orgId of Object.keys(ccs.superUserUnlockedAuthenticators)) {
        const isAdmin = adminOrgIds.some((id2) => id2 === orgId);
        if (!isAdmin) {
          const newSuperUserUnlockedAuthenticators = Object.assign({}, ccs.superUserUnlockedAuthenticators);
          delete newSuperUserUnlockedAuthenticators[orgId];
          ccs.superUserUnlockedAuthenticators = newSuperUserUnlockedAuthenticators;
        }
      }
      return { ccs, shouldUpdateSyncVersion };
    });
  }
  function shouldUseSyncUpdateVault({ profileRepo, foreignVaultSyncPredicate, ephemeralForeignVaultSyncPredicate }, suv) {
    if (!shouldSyncVault(suv.vaultType)) {
      return false;
    }
    const isOwnVault = suv.profiles.some(({ id: id2 }) => profileRepo.hasProfile(id2));
    const isAdminVault = suv.vaultType === VaultType.ORGANIZATION_ADMIN;
    const isForeignOrgVault = suv.organizationId && profileRepo.getOrganizationProfile(suv.organizationId);
    return isOwnVault || isAdminVault || isForeignOrgVault && (checkForeignVaultSyncPredicate({ type: "syncUpdate", vault: suv }, foreignVaultSyncPredicate) || checkForeignVaultSyncPredicate({ type: "syncUpdate", vault: suv }, ephemeralForeignVaultSyncPredicate));
  }
  function shouldSyncVault(vaultType) {
    if (vaultType === VaultType.UNKNOWN) {
      return false;
    }
    return true;
  }
  function applyVaultSyncResult(_a3, _b) {
    var _c2, _d;
    var ccs = __rest$r(_a3, []);
    var vault = _b.vault, newSecrets = _b.newSecrets, vaultAccess = _b.vaultAccess;
    if (vault) {
      ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(vault);
      if (newSecrets) {
        ccs.protectedSecretRepo = (_d = (_c2 = ccs.protectedSecretRepo) === null || _c2 === void 0 ? void 0 : _c2.withProtectedSecret(vault, newSecrets.protectedSecret, newSecrets.messagePrivateKey)) !== null && _d !== void 0 ? _d : null;
      }
      if ((vaultAccess === null || vaultAccess === void 0 ? void 0 : vaultAccess.type) === "admin-authenticator") {
        ccs.superUserUnlockedAuthenticators = Object.assign(Object.assign({}, ccs.superUserUnlockedAuthenticators), { [vaultAccess.orgId]: vaultAccess.unlockedAuthenticator });
      }
    }
    return ccs;
  }
  function applyVaultSyncResultVaultMessages(_a3, _b) {
    var ccs = __rest$r(_a3, []);
    var synthesizedVaultMessages = _b.synthesizedVaultMessages;
    if (synthesizedVaultMessages) {
      for (const { vaultId, message } of synthesizedVaultMessages) {
        if (ccs.vaultRepo.vaultExits(vaultId)) {
          let v2 = ccs.vaultRepo.getVaultById(vaultId);
          v2 = v2.withAddMessageQueue(message);
          ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(v2);
        }
      }
    }
    return ccs;
  }
  function onlineInternalSyncVault(ccs, initialVault, syncUpdate, hsc, syncUpdateServerTime) {
    var _a3, _b;
    return __awaiter$L(this, void 0, void 0, function* () {
      let vault = initialVault;
      let shouldPerformUpdate = false;
      let forceRegenerate = false;
      if (syncUpdate) {
        vault = vault.withSyncUpdate(syncUpdate, ccs.profileRepo);
        shouldPerformUpdate = vault.commitId !== syncUpdate.commitId || syncUpdate.hasMessagesQueued;
        if (!shouldPerformUpdate && vault.isUserJoined) {
          const hasProfileWithoutLock = !vault.profileLock && vault.profileIds.some((id2) => ccs.profileRepo.hasProfile(id2));
          if (hasProfileWithoutLock) {
            shouldPerformUpdate = true;
          }
        }
        if (!shouldPerformUpdate && !vault.isUserJoined && vault.organizationId) {
          const orgAdminProfile = ccs.profileRepo.getOrgAdminProfile(vault.organizationId);
          const hasAdminProfileWithoutLock = orgAdminProfile && !vault.adminProfileLock && vault.profileIds.includes(orgAdminProfile.profile.id);
          if (hasAdminProfileWithoutLock) {
            shouldPerformUpdate = true;
          }
        }
        if ((vault.type === VaultType.ORGANIZATION_PERSONAL || vault.type === VaultType.PRIVATE) && vault.isUserJoined && vault.messagePublicKey === null) {
          forceRegenerate = true;
        }
        if (vault.isUserJoined && vault.messagePublicKey === null && vault.linkedUpdateMessages.length > 0) {
          forceRegenerate = true;
        }
        if (vault.messagePublicKey === null && vault.hasStagedDiff()) {
          forceRegenerate = true;
        }
      }
      const vaultBackendClient = getBackendClientForVault(ccs, vault);
      const vaultAccess = getVaultAccess(ccs, hsc, vault);
      if (!vaultAccess) {
        return {};
      }
      let newSecrets;
      let synthesizedVaultMessages;
      try {
        let forceFullReload = false;
        for (let attempt = 0; ; attempt += 1) {
          yield exponentialSlottedBackoff(attempt);
          let cappedUpdateTime = syncUpdateServerTime;
          try {
            if (shouldPerformUpdate) {
              const hasAuthenticatorLock = vaultAccess.type === "admin-authenticator" && vault.authenticatorLocks.some((l2) => l2.authenticatorId === vaultAccess.unlockedAuthenticator.authenticator.id);
              const hasProfile = vault.profileIds.some((id2) => ccs.profileRepo.hasProfile(id2));
              const isLockRequired = !vault.profileLock && !vault.adminProfileLock && (!hasAuthenticatorLock || hasProfile);
              const vaultUpdate = forceFullReload ? yield vaultBackendClient.vault.listCommits(vault.id, null, null, false) : yield vaultBackendClient.vault.listCommits(vault.id, vault.commitId, vault.firstCommitId, isLockRequired);
              cappedUpdateTime = vaultUpdate.serverTime;
              const updatedVault2 = internalUpdateVaultFromDto(ccs, hsc, vault, vaultUpdate, vaultAccess);
              vault = updatedVault2.vault;
              newSecrets = (_a3 = updatedVault2.newSecrets) !== null && _a3 !== void 0 ? _a3 : newSecrets;
            }
            const updatedVault = yield onlineInternalPushOrRegenerateVaultIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate);
            vault = updatedVault.vault;
            newSecrets = (_b = updatedVault.newSecrets) !== null && _b !== void 0 ? _b : newSecrets;
            synthesizedVaultMessages = updatedVault.synthesizedVaultMessages;
            forceRegenerate = false;
            break;
          } catch (e2) {
            if (e2 instanceof DomainError$1 && e2.code === BackendErrorCode.VAULT_OUT_OF_SYNC) {
              shouldPerformUpdate = true;
            } else if (e2 instanceof DomainError$1 && e2.code === BackendErrorCode.INVALID_UPDATE_TIME) {
              shouldPerformUpdate = true;
              trackError(new Error(`Invalid update time, retrying sync #${attempt} for vault ${vault.id}`));
            } else if (e2 instanceof DomainError$1 && e2.code === BackendErrorCode.VAULT_DIRTY) {
              vault = vault.withDirty();
            } else if (e2 instanceof DomainError$1 && (e2.code === ClientCoreErrorCode.NeedLocks || e2.code === ClientCoreErrorCode.NeedFullHistory)) {
              if (!forceFullReload) {
                shouldPerformUpdate = true;
                forceFullReload = true;
                trackError(e2);
              } else {
                throw e2;
              }
            } else {
              throw e2;
            }
          }
          if (attempt === 4) {
            trackError(new Error(`Bailing out of syncVault for vault ${vault.id} due to excessive retries`));
            break;
          }
        }
        const vaultChanged = vault !== initialVault;
        if (!vaultChanged) {
          return {};
        }
        return { vault, newSecrets, synthesizedVaultMessages, vaultAccess };
      } catch (e2) {
        throw e2;
      }
    });
  }
  function onlineInternalPushOrRegenerateVaultIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate) {
    return __awaiter$L(this, void 0, void 0, function* () {
      if (vault.dirty || forceRegenerate) {
        return onlineInternalCreateRegeneratedVaultDuringSyncIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate);
      }
      return onlineInternalSyncPushCommitIfNecessary(vaultBackendClient, vault, cappedUpdateTime);
    });
  }
  function onlineInternalSyncPushCommitIfNecessary(vaultBackendClient, vault, serverTime) {
    var _a3, _b;
    return __awaiter$L(this, void 0, void 0, function* () {
      const stagedData = vault.getStagedDiff(serverTime);
      if (!stagedData) {
        return { vault };
      }
      const { stagingVault, diff, latestUpdateTime, linkedUpdateMessages, shareLinkUpdates } = stagedData;
      const protoCommit = Commit.create(null, vault.vaultSecret, diff);
      const messages = linkedUpdateMessages.length ? yield prepareVaultMessages(vaultBackendClient, vault, linkedUpdateMessages) : [];
      const activeShareLinkIds = (_b = (_a3 = vault.vaultState.descriptor).getActiveShareLinkIds) === null || _b === void 0 ? void 0 : _b.call(_a3, vault.getContentInternal());
      const { commitId, updateMessageIds } = yield vaultBackendClient.vault.createCommit(vault.id, vault.commitId, protoCommit.blob, new Date(latestUpdateTime), [], messages, shareLinkUpdates, { keepShareLinkIds: activeShareLinkIds !== null && activeShareLinkIds !== void 0 ? activeShareLinkIds : [] });
      const synthesizedVaultMessages = messages.map((m2) => ({
        vaultId: m2.vaultId,
        message: {
          id: updateMessageIds.shift(),
          type: m2.type,
          encryptedData: m2.encryptedData,
          senderVaultId: vault.id
        }
      }));
      return {
        vault: stagingVault.withCommitId(commitId),
        synthesizedVaultMessages
      };
    });
  }
  function onlineInternalCreateRegeneratedVaultDuringSyncIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate) {
    var _a3, _b;
    return __awaiter$L(this, void 0, void 0, function* () {
      const stagedData = vault.getStagedDiff(cappedUpdateTime);
      if (!stagedData && !forceRegenerate) {
        return { vault };
      }
      if (!hsc) {
        throw new VaultIsLockedError();
      }
      const regeneratedVaultDto = yield onlineInternalCreateRegeneratedVault(ccs, vault, vaultAccess, hsc);
      const activeShareLinkIds = (_b = (_a3 = vault.vaultState.descriptor).getActiveShareLinkIds) === null || _b === void 0 ? void 0 : _b.call(_a3, vault.getContentInternal());
      if (!stagedData) {
        yield vaultBackendClient.vault.createGeneration(regeneratedVaultDto, [], {
          keepShareLinkIds: activeShareLinkIds !== null && activeShareLinkIds !== void 0 ? activeShareLinkIds : []
        });
        const vaultUpdate2 = yield vaultBackendClient.vault.listCommits(vault.id, null, null, false);
        return internalUpdateVaultFromDto(ccs, hsc, vault, vaultUpdate2, vaultAccess);
      }
      const { stagingVault, linkedUpdateMessages, shareLinkUpdates } = stagedData;
      const messages = linkedUpdateMessages.length ? yield prepareVaultMessages(vaultBackendClient, vault, linkedUpdateMessages) : [];
      const { updateMessageIds } = yield vaultBackendClient.vault.createGeneration(regeneratedVaultDto, messages, { keepShareLinkIds: activeShareLinkIds !== null && activeShareLinkIds !== void 0 ? activeShareLinkIds : [] }, shareLinkUpdates);
      const synthesizedVaultMessages = messages.map((m2) => ({
        vaultId: m2.vaultId,
        message: {
          id: updateMessageIds.shift(),
          type: m2.type,
          encryptedData: m2.encryptedData,
          senderVaultId: vault.id
        }
      }));
      const vaultUpdate = yield vaultBackendClient.vault.listCommits(vault.id, null, null, false);
      let updatedVault = internalUpdateVaultFromDto(ccs, hsc, stagingVault, vaultUpdate, vaultAccess);
      updatedVault = Object.assign(Object.assign({}, updatedVault), { vault: updatedVault.vault.withDirty(false) });
      return Object.assign(Object.assign({}, updatedVault), { synthesizedVaultMessages });
    });
  }
  function prepareVaultMessages(vaultBackendClient, vault, linkedUpdateMessages) {
    return __awaiter$L(this, void 0, void 0, function* () {
      if (linkedUpdateMessages.length === 0) {
        return [];
      }
      if (!vault.organizationId) {
        throw new Error("vault with linked logins must be in organization");
      }
      const vaultIds = new Set(linkedUpdateMessages.map(({ vaultId }) => vaultId));
      const { messagePublicKeys } = yield vaultBackendClient.vault.listMessagePublicKeys(vault.organizationId, [...vaultIds]);
      const mpksByVault = {};
      for (const { vaultId, generationId, key } of messagePublicKeys) {
        if (key.length > 0) {
          mpksByVault[vaultId] = {
            generationId,
            messagePublicKey: loadEncryptionPublicKey(key)
          };
        }
      }
      return linkedUpdateMessages.flatMap(({ vaultId, message, type }) => {
        if (!mpksByVault[vaultId]) {
          trackError(new Error("linked vault is missing public key, no longer exists? (skipping)"));
          return [];
        }
        const { generationId, messagePublicKey } = mpksByVault[vaultId];
        return {
          vaultId,
          generationId,
          encryptedData: asymEncrypt(messagePublicKey, serializeData(message)),
          type
        };
      });
    });
  }
  function internalUpdateVaultFromDto(ccs, hsc, vault, vaultUpdate, vaultAccess) {
    var _a3, _b;
    const { generationId, commitDtos, lockDtos, profileLockDto, adminProfileLockDto, firstCommitId, messages } = vaultUpdate;
    const commits = commitDtos.map((c2) => Commit.load(c2));
    const isSameGeneration = generationId === vault.generationId;
    const isReceivedFullHistory = commits.length && commits[0].id === firstCommitId;
    const isLocalCommitsMissing = isSameGeneration && isReceivedFullHistory && !commits.some(({ id: id2 }) => id2 === vault.commitId);
    if (isLocalCommitsMissing) {
      trackError(new Error(`One or more commits (latest local: ${vault.commitId}) were lost serverside in vault ${vault.id}`));
      const stagedDiff2 = vault.vaultState.getSquashedState();
      const updatedVault2 = Vault.createFromCommits(vault.id, vault.type, vault.associatedVaultId, generationId, vault.userIds, vault.profileIds, vault.organizationId, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, vault.dirty, vault.vaultSecret, commits, stagedDiff2, ccs.profileRepo, vault.messagePublicKey, messages, vault.inboxSlug);
      return { vault: updatedVault2 };
    }
    if (isSameGeneration) {
      let newCommits;
      if (isReceivedFullHistory) {
        const lastKnownCommitIndex = commits.findIndex(({ id: id2 }) => id2 === vault.commitId);
        newCommits = commits.slice(lastKnownCommitIndex + 1);
        trackError(new Error(`Unexpectedly received full history for vault ${vault.id} (${lastKnownCommitIndex + 1} old commits)`));
      } else {
        newCommits = commits;
      }
      let updatedVault2 = vault.withLoadCommits(...newCommits).withMessageQueue(messages);
      if (vault.firstCommitId === null) {
        updatedVault2 = updatedVault2.withFirstCommitId(firstCommitId);
      }
      let newSecrets2;
      if (lockDtos.length || profileLockDto || adminProfileLockDto) {
        const authenticatorLocks2 = (_a3 = lockDtos === null || lockDtos === void 0 ? void 0 : lockDtos.map((dto) => VaultAuthenticatorLock.load(dto))) !== null && _a3 !== void 0 ? _a3 : [];
        const profileLock2 = profileLockDto ? VaultProfileLock.load(profileLockDto) : null;
        const adminProfileLock2 = adminProfileLockDto ? VaultProfileLock.load(adminProfileLockDto) : null;
        updatedVault2 = updatedVault2.withLocks(vaultAccess, authenticatorLocks2, profileLock2, adminProfileLock2);
      }
      if (hsc && (lockDtos.length || profileLockDto || adminProfileLockDto)) {
        newSecrets2 = unlockLockProtectedSecret(vaultAccess, updatedVault2.authenticatorLocks, updatedVault2.profileLock, updatedVault2.adminProfileLock, ccs.profileRepo, hsc);
      }
      return { vault: updatedVault2, newSecrets: newSecrets2 };
    }
    if (!isReceivedFullHistory) {
      throw new NeedFullHistoryError(vault.id, vault.generationId, generationId);
    }
    if (!(lockDtos === null || lockDtos === void 0 ? void 0 : lockDtos.length) && !profileLockDto && !adminProfileLockDto) {
      throw new NeedLocksError(vault.id, vault.generationId, generationId);
    }
    const authenticatorLocks = lockDtos.map((dto) => VaultAuthenticatorLock.load(dto));
    const profileLock = profileLockDto ? VaultProfileLock.load(profileLockDto) : null;
    const adminProfileLock = adminProfileLockDto ? VaultProfileLock.load(adminProfileLockDto) : null;
    const vaultSecret = unlockLockVaultSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock);
    const newSecrets = hsc ? unlockLockProtectedSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock, ccs.profileRepo, hsc) : void 0;
    const stagedDiff = getStagedDiff(vault, vaultAccess, hsc, ccs.profileRepo, (_b = newSecrets === null || newSecrets === void 0 ? void 0 : newSecrets.protectedSecret) !== null && _b !== void 0 ? _b : null);
    const updatedVault = Vault.createFromCommits(vault.id, vault.type, vault.associatedVaultId, generationId, vault.userIds, vault.profileIds, vault.organizationId, authenticatorLocks, profileLock, adminProfileLock, vault.dirty, vaultSecret, commits, stagedDiff, ccs.profileRepo, vault.messagePublicKey, messages, vault.inboxSlug);
    return { vault: updatedVault, newSecrets };
  }
  function getStagedDiff(currentVault, vaultAccess, hsc, profileRepo, newProtectedSecret) {
    var _a3, _b, _c2;
    const stagedDiff = (_a3 = currentVault.getStagedDiff(null)) === null || _a3 === void 0 ? void 0 : _a3.diff;
    if (!stagedDiff) {
      return null;
    }
    if (!hsc || !newProtectedSecret) {
      throw new VaultIsLockedError();
    }
    const { protectedSecret: currentProtectedSecret } = unlockLockProtectedSecret(vaultAccess, currentVault.authenticatorLocks, currentVault.profileLock, currentVault.adminProfileLock, profileRepo, hsc);
    const { vault: reprotectedVault } = currentVault.withModification((c2, t2) => {
      return {
        newVaultContent: modifyProtectedValues(c2, t2, (pv) => {
          const unprotected = unprotectWithContentId(currentProtectedSecret, pv);
          const reprotected = protect(newProtectedSecret, unprotected);
          return reprotected;
        }),
        result: void 0
      };
    });
    return (_c2 = (_b = reprotectedVault.getStagedDiff(null)) === null || _b === void 0 ? void 0 : _b.diff) !== null && _c2 !== void 0 ? _c2 : null;
  }
  function onlineInternalInitializeVault(ccs, syncUpdateVault, hsc) {
    var _a3;
    return __awaiter$L(this, void 0, void 0, function* () {
      const backendClient = getBackendClientForVault(ccs, syncUpdateVault);
      const vaultAccess = getVaultAccess(ccs, hsc, syncUpdateVault);
      if (!vaultAccess) {
        return {};
      }
      const { id: vaultId, vaultType, associatedVaultId, users, profiles, organizationId, dirty, messagePublicKey, inboxSlug } = syncUpdateVault;
      const { generationId, commitDtos, lockDtos, profileLockDto, adminProfileLockDto, messages } = yield backendClient.vault.listCommits(vaultId, null, null, false);
      const commits = commitDtos.map((c2) => Commit.load(c2));
      const authenticatorLocks = (_a3 = lockDtos === null || lockDtos === void 0 ? void 0 : lockDtos.map((dto) => VaultAuthenticatorLock.load(dto))) !== null && _a3 !== void 0 ? _a3 : [];
      const profileLock = profileLockDto ? VaultProfileLock.load(profileLockDto) : null;
      const adminProfileLock = adminProfileLockDto ? VaultProfileLock.load(adminProfileLockDto) : null;
      const vaultSecret = unlockLockVaultSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock);
      const newSecrets = hsc && vaultAccess ? unlockLockProtectedSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock, ccs.profileRepo, hsc) : void 0;
      const userIds = users.map((u2) => u2.id);
      const profileIds = profiles.map((p2) => p2.id);
      const vault = Vault.createFromCommits(vaultId, vaultType, associatedVaultId, generationId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, vaultSecret, commits, null, ccs.profileRepo, messagePublicKey ? loadEncryptionPublicKey(messagePublicKey) : null, messages, inboxSlug);
      return { vault, newSecrets, vaultAccess };
    });
  }
  function ensureVaultRepoConsistency(_a3) {
    var ccs = __rest$r(_a3, []);
    if (ccs.protectedSecretRepo && ccs.protectedSecretRepo.isUnlocked()) {
      for (const vault of ccs.vaultRepo.getAllVaults()) {
        if (!ccs.protectedSecretRepo.hasVault(vault.id)) {
          trackError({ message: "Vault was missing from protectedSecretRepo", vaultId: vault.id });
          ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
        }
      }
    }
    for (const vault of ccs.vaultRepo.getAllVaults()) {
      if (vault.type === VaultType.TEAM && (!vault.associatedVaultId || ccs.vaultRepo.getTeamMetaVaultById(vault.associatedVaultId) === null)) {
        trackError({ messsage: "Team vault is missing assosciated vault", vaultId: vault.id });
        ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
      }
    }
    return ccs;
  }
  function onlineInternalSyncAchievements(_a3, su2) {
    var ccs = __rest$r(_a3, []);
    return __awaiter$L(this, void 0, void 0, function* () {
      const localAchievements = ccs.accountState.getLocalAchievements();
      if (localAchievements.length) {
        su2 = yield ccs.backendClient.account.addAchievements(localAchievements);
        ccs.accountState = ccs.accountState.withSyncUpdate(su2);
      }
      return ccs;
    });
  }
  function onlineInternalSyncAuditlogEventQueue(_a3) {
    var _b;
    var ccs = __rest$r(_a3, []);
    return __awaiter$L(this, void 0, void 0, function* () {
      const groupedEvents = groupBy(ccs.auditlogEventQueue, (e2) => e2.organizationId);
      ccs.auditlogEventQueue = [];
      let returnResult;
      for (const events of Object.values(groupedEvents)) {
        if (!events) {
          continue;
        }
        const orgId = events[0].organizationId;
        _b = yield onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, events), { returnResult } = _b, ccs = __rest$r(_b, ["returnResult"]);
        if (returnResult === AuditlogWriteResult.Retry) {
          ccs.auditlogEventQueue.push(...events);
        }
      }
      return ccs;
    });
  }
  var __awaiter$K = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$q = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalChildOrganizationAddManager(_a3, orgId, parentOrgProfileId) {
    var ccs = __rest$q(_a3, []);
    return __awaiter$K(this, void 0, void 0, function* () {
      const disabledOrgProfile = ccs.profileRepo.disabledProfiles.find((p2) => p2.organizationId === orgId);
      const fullSyncRequired = !!disabledOrgProfile;
      if (disabledOrgProfile) {
        ccs.ephemeralOperationState = {
          additionalEnabledProfileIds: [disabledOrgProfile.id]
        };
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
      }
      let hsc;
      ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
      if (!hsc || !ccs.protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.organizations.find((o2) => o2.id === orgId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      const { adminInfo } = org;
      if (!adminInfo || !adminInfo.authenticator && !adminInfo.adminProfile) {
        throw new NoOrganizationAdminError();
      }
      const adminAuthenticator = adminInfo.authenticator ? [loadForeignAuthenticator(adminInfo.authenticator)] : [];
      const superUserVaultMemberIds = adminInfo.authenticator ? [org.superUserId] : [];
      const adminProfile = adminInfo.adminProfile ? loadForeignProfile(adminInfo.adminProfile) : null;
      const adminUp = ccs.profileRepo.getOrgAdminProfile(orgId);
      const adminHsup = adminUp ? hsc.getHighSecurityUnlockedProfile(adminUp, ccs.profileRepo) : void 0;
      const { users: [{ authenticators }] } = yield ccs.backendClient.account.list([], [], [parentOrgProfileId]);
      const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, orgId, authenticators.map(loadForeignAuthenticator));
      const personalVaultDto = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, superUserVaultMemberIds, [], adminAuthenticator, unsyncedProfile, adminProfile, orgId, organizationPersonalVaultContentDescriptor, null).getCreationDto();
      const adminProfileLock = adminHsup === null || adminHsup === void 0 ? void 0 : adminHsup.createProfileLock(unsyncedProfile);
      let legacyAdminVaultLock;
      if (adminInfo.legacyAdminVaultId) {
        const legacyAdminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(adminInfo.legacyAdminVaultId);
        if (!legacyAdminVault) {
          throw new VaultNotFoundError(adminInfo.legacyAdminVaultId);
        }
        legacyAdminVaultLock = {
          generationId: legacyAdminVault.generationId,
          vaultId: legacyAdminVault.id,
          lock: serializeVaultProfileLock(ccs.protectedSecretRepo.createProfileLock(legacyAdminVault, unsyncedProfile))
        };
      }
      const { syncUpdate } = yield ccs.backendClient.childOrganization.addManager(orgId, parentOrgProfileId, {
        profile: unsyncedProfile.serialize(),
        personalVaultData: personalVaultDto,
        adminProfileLock,
        legacyAdminVaultLock
      });
      ccs.ephemeralOperationState = void 0;
      if (fullSyncRequired) {
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
      }
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __rest$p = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function addUnsyncedVaultAfterCreate(_a3, syncUpdate, vaultId, associatedVaultId, organizationId, unsyncedVault) {
    var _b, _c2, _d, _e, _f;
    var ccs = __rest$p(_a3, []);
    const { generationId, commitId } = (_b = syncUpdate.vaults) === null || _b === void 0 ? void 0 : _b.find((v2) => v2.id === vaultId);
    const vault = unsyncedVault.withIds(vaultId, generationId, commitId, associatedVaultId, organizationId);
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(vault);
    ccs.protectedSecretRepo = (_f = (_c2 = ccs.protectedSecretRepo) === null || _c2 === void 0 ? void 0 : _c2.withProtectedSecret(vault, unsyncedVault.protectedSecret, (_e = (_d = unsyncedVault.messageKeyPair) === null || _d === void 0 ? void 0 : _d.encPrivKey) !== null && _e !== void 0 ? _e : null)) !== null && _f !== void 0 ? _f : null;
    return ccs;
  }
  var __awaiter$J = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalMakeUnsyncedTeamVaults(ccs, name, organizationId, profile, isSyncOrganizationMembers, inbox, vaultType = VaultType.TEAM, metaVaultType = VaultType.TEAM_META) {
    return __awaiter$J(this, void 0, void 0, function* () {
      const profileIds = !(profile instanceof UnsyncedProfile) ? [profile.id] : [];
      let userIds;
      let adminProfile;
      let authenticators;
      if (organizationId) {
        const org = ccs.accountState.organizations.find((o2) => o2.id === organizationId);
        if (!org) {
          throw new OrganizationNotFoundError();
        }
        if (org.adminProfileId) {
          const { profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], [org.adminProfileId], []);
          adminProfile = profilesById[org.adminProfileId];
          authenticators = [];
          userIds = [];
        } else {
          const { authenticatorsByUser } = yield onlineInternalGetUsers(ccs.backendClient, [org.superUserId], [], []);
          adminProfile = null;
          authenticators = authenticatorsByUser[org.superUserId];
          userIds = [org.superUserId];
        }
      } else {
        adminProfile = null;
        authenticators = [];
        userIds = [];
      }
      const unsyncedTeamVault = UnsyncedVault.create(vaultType, userIds, profileIds, authenticators, profile, adminProfile, organizationId !== null && organizationId !== void 0 ? organizationId : null, loginVaultContentDescriptor, inbox !== null && inbox !== void 0 ? inbox : null);
      const unsyncedTeamMetaVault = UnsyncedVault.create(metaVaultType, userIds, profileIds, authenticators, profile, adminProfile, organizationId !== null && organizationId !== void 0 ? organizationId : null, teamMetaVaultContentDescriptor, null, getInitialMetaContentModification(profileIds, name, isSyncOrganizationMembers));
      return { unsyncedTeamVault, unsyncedTeamMetaVault };
    });
  }
  function getInitialMetaContentModification(adminIds, name, isSyncOrganizationMembers) {
    return (c2, t2, { modifyTeamVaultInfo: modifyTeamVaultInfo2, addOrModifyTeamVaultUser: addOrModifyTeamVaultUser2 }) => {
      let newVaultContent = c2;
      ({ newVaultContent } = modifyTeamVaultInfo2(newVaultContent, t2, {
        name,
        // Note: There's currently no exposed api for changing this setting. We used to force it to
        // true via the web app, but will probably implement a UI for it in the future.
        hideSecretsForRestrictedUsers: true,
        isSyncOrganizationMembers
      }));
      for (const adminId of adminIds) {
        ({ newVaultContent } = addOrModifyTeamVaultUser2(newVaultContent, t2, adminId, {
          permissionLevel: PermissionLevel.admin
        }));
      }
      return { newVaultContent, result: void 0 };
    };
  }
  var __awaiter$I = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$o = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalInboxVaultCreate(_a3, slug, metadata, organizationId) {
    var _b, _c2;
    var ccs = __rest$o(_a3, []);
    return __awaiter$I(this, void 0, void 0, function* () {
      const metadataJson = jsonStringifyFreeze(metadata);
      const profile = (_b = ccs.profileRepo.getOrganizationProfile(organizationId)) === null || _b === void 0 ? void 0 : _b.profile;
      if (!profile) {
        throw new OrganizationNotFoundError();
      }
      const { unsyncedTeamVault: unsyncedInboxVault, unsyncedTeamMetaVault } = yield onlineInternalMakeUnsyncedTeamVaults(ccs, "Inbox", organizationId, profile, false, { slug, metadata }, VaultType.INBOX, VaultType.INBOX_META);
      const { vaultId: inboxVaultId, associatedVaultId: teamMetaVaultId, syncUpdate } = yield ccs.backendClient.vault.createInboxVault({
        blob: unsyncedInboxVault.getCommitBlob(),
        locks: unsyncedInboxVault.getAuthenticatorLockDtos(),
        profileLock: unsyncedInboxVault.getProfileLockDto(),
        adminProfileLock: unsyncedInboxVault.getAdminProfileLockDto(),
        associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
        associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
        associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
        associatedAdminProfileLock: unsyncedTeamMetaVault.getAdminProfileLockDto(),
        organizationId,
        messagePublicKey: (_c2 = unsyncedInboxVault.messageKeyPair) === null || _c2 === void 0 ? void 0 : _c2.encPubKey
      }, slug, metadataJson);
      ccs = addUnsyncedVaultAfterCreate(ccs, syncUpdate, inboxVaultId, teamMetaVaultId, organizationId !== null && organizationId !== void 0 ? organizationId : null, unsyncedInboxVault);
      ccs = addUnsyncedVaultAfterCreate(
        ccs,
        syncUpdate,
        // if we pass in an unsynced associated vault, we're also going to get back an id for it
        teamMetaVaultId,
        null,
        organizationId !== null && organizationId !== void 0 ? organizationId : null,
        unsyncedTeamMetaVault
      );
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      return Object.assign(Object.assign({}, ccs), { returnResult: inboxVaultId });
    });
  }
  var __awaiter$H = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$n = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalInboxVaultDelete(_a3, vaultId) {
    var ccs = __rest$n(_a3, []);
    return __awaiter$H(this, void 0, void 0, function* () {
      const pair = ccs.vaultRepo.getInboxVaultPairById(vaultId);
      if (!pair) {
        throw new VaultNotFoundError(vaultId);
      }
      if (getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta) !== PermissionLevel.admin) {
        throw new VaultPermissionDeniedError();
      }
      const syncUpdate = yield ccs.backendClient.vault.deleteInboxVault(vaultId);
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      return Object.assign({}, ccs);
    });
  }
  const ALL_LOGIN_VAULT_PERMISSIONS = {
    viewSecrets: true,
    createLogins: true,
    deleteLogins: true,
    editLogins: true,
    useLogins: true,
    viewHistory: true
  };
  function getLoginVaultMetadata({ accountState, profileRepo }, vaultPair) {
    switch (vaultPair.type) {
      case VaultType.PRIVATE:
        return getPrivateVaultMetadata(vaultPair.login);
      case VaultType.ORGANIZATION_PERSONAL:
        return getPersonalVaultMetadata({ accountState, profileRepo }, vaultPair.login);
      case VaultType.TEAM:
        return getTeamVaultPairMetadata({ accountState, profileRepo }, vaultPair);
      case VaultType.INBOX:
        return getInboxVaultPairMetadata(vaultPair);
      default:
        throw new UnsupportedLoginVaultTypeError();
    }
  }
  function assertVaultType(vault, type) {
    if (vault.type != type) {
      throw new IncorrectVaultTypeError(vault.id, type, vault.type);
    }
  }
  function getPrivateVaultMetadata(vault) {
    var _a3;
    assertVaultType(vault, VaultType.PRIVATE);
    return {
      id: vault.id,
      profileId: (_a3 = vault.getProfileId()) !== null && _a3 !== void 0 ? _a3 : void 0,
      type: VaultType.PRIVATE,
      permissions: ALL_LOGIN_VAULT_PERMISSIONS,
      path: "/logins"
    };
  }
  function getPersonalVaultMetadata({ accountState, profileRepo }, vault) {
    var _a3, _b, _c2, _d, _e, _f, _g, _h;
    assertVaultType(vault, VaultType.ORGANIZATION_PERSONAL);
    const org = vault.organizationId && accountState.getOrganization(vault.organizationId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    const orgProfile = (_a3 = profileRepo.getOrganizationProfile(vault.organizationId)) === null || _a3 === void 0 ? void 0 : _a3.profile;
    if (orgProfile && vault.profileIds.includes(orgProfile.id)) {
      return {
        id: vault.id,
        profileId: (_b = vault.getProfileId()) !== null && _b !== void 0 ? _b : void 0,
        permissions: ALL_LOGIN_VAULT_PERMISSIONS,
        type: VaultType.ORGANIZATION_PERSONAL,
        owner: {
          profileId: orgProfile.id,
          isLoggedInUser: true,
          email: (_c2 = orgProfile.email) !== null && _c2 !== void 0 ? _c2 : void 0
        },
        organizationId: vault.organizationId,
        path: `/organizations/${vault.organizationId}/logins`
      };
    }
    if (vault.profileIds.length) {
      const ownerProfileId = vault.profileIds.find((pId) => {
        var _a4;
        return pId !== ((_a4 = vault.adminProfileLock) === null || _a4 === void 0 ? void 0 : _a4.lockingProfileId);
      });
      if (!ownerProfileId) {
        throw new Error("organization personal vault without an owner, this should never happen");
      }
      const ownerProfile = (_d = accountState.getOrganization(vault.organizationId)) === null || _d === void 0 ? void 0 : _d.profiles.find((p2) => p2.profileId === ownerProfileId);
      if (!ownerProfile) {
        throw new Error("owner profile not found in organization");
      }
      const ownerEmail = (_f = (_e = accountState.relatedProfiles[ownerProfileId]) === null || _e === void 0 ? void 0 : _e.email) !== null && _f !== void 0 ? _f : void 0;
      return {
        id: vault.id,
        profileId: (_g = vault.getProfileId()) !== null && _g !== void 0 ? _g : void 0,
        name: (_h = accountState.getProfileEmail(ownerProfileId)) !== null && _h !== void 0 ? _h : void 0,
        permissions: {
          viewSecrets: false,
          createLogins: true,
          editLogins: false,
          deleteLogins: false,
          useLogins: false,
          viewHistory: false
        },
        type: VaultType.ORGANIZATION_PERSONAL,
        owner: {
          profileId: ownerProfileId,
          isLoggedInUser: false,
          email: ownerEmail
        },
        organizationId: vault.organizationId,
        path: `/organizations/${vault.organizationId}/members/profiles/${ownerProfileId}/logins`
      };
    }
    throw new Error("organization personal vault without an owner, this should never happen");
  }
  function getTeamVaultPairMetadata({ accountState, profileRepo }, { login, meta }) {
    var _a3;
    const org = login.organizationId && accountState.getOrganization(login.organizationId);
    assertVaultType(login, VaultType.TEAM);
    const loggedInProfile = org ? profileRepo.getOrganizationProfile(org.id) : profileRepo.getPrivateProfile();
    if (!loggedInProfile) {
      throw new Error("getTeamVaultPairMetadata on a vault outside a known org or private profile");
    }
    const metaContent = meta.getContent();
    const metaInfo = getTeamMetaVaultInfo(metaContent);
    const permissionLevel = getPermissionLevel(metaContent, loggedInProfile.profile.id);
    const newlyJoinedInfo = getNewlyJoinedInfo(metaContent, loggedInProfile.profile.id);
    const hideSecretsForRestrictedUsers = !!metaInfo.hideSecretsForRestrictedUsers;
    return {
      id: login.id,
      profileId: (_a3 = login.getProfileId()) !== null && _a3 !== void 0 ? _a3 : void 0,
      type: VaultType.TEAM,
      name: metaInfo.name,
      isSyncOrganizationMembers: !!metaInfo.isSyncOrganizationMembers,
      isUserJoined: login.isUserJoined,
      newlyJoinedInfo,
      permissions: {
        viewSecrets: !(permissionLevel === PermissionLevel.restricted && hideSecretsForRestrictedUsers),
        createLogins: permissionLevel !== PermissionLevel.restricted,
        editLogins: permissionLevel !== PermissionLevel.restricted,
        deleteLogins: permissionLevel !== PermissionLevel.restricted,
        useLogins: login.isUserJoined,
        viewHistory: permissionLevel === PermissionLevel.admin
      },
      organizationId: login.organizationId,
      path: org ? `/organizations/${org.id}/teams/${login.id}` : `/teams/${login.id}`,
      icon: metaInfo.icon,
      hideSecretsForRestrictedUsers
    };
  }
  function getInboxVaultPairMetadata({ login }) {
    var _a3;
    assertVaultType(login, VaultType.INBOX);
    const path = login.organizationId ? `/organizations/${login.organizationId}/inboxes/${login.id}` : `/inboxes/${login.id}`;
    return {
      type: VaultType.INBOX,
      permissions: {
        viewSecrets: true,
        createLogins: false,
        editLogins: true,
        deleteLogins: true,
        useLogins: true,
        viewHistory: true
      },
      id: login.id,
      profileId: (_a3 = login.getProfileId()) !== null && _a3 !== void 0 ? _a3 : void 0,
      path,
      slug: login.inboxSlug,
      organizationId: login.organizationId
    };
  }
  function encodeBase64Urlsafe(data) {
    return naclUtilExports.encodeBase64(data instanceof Uint8Array ? data : new Uint8Array(data)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }
  function decodeBase64Urlsafe(data) {
    const substituted = data.replace(/_/g, "/").replace(/-/g, "+");
    const padLength = (4 - substituted.length % 4) % 4;
    const padded = substituted.padEnd(substituted.length + padLength, "=");
    return naclUtilExports.decodeBase64(padded);
  }
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function encryptShareLinkLogin(login) {
    const strippedLogin = {
      customFields: login.customFields,
      note: login.note,
      password: login.password,
      title: login.title,
      uiType: login.uiType,
      username: login.username,
      websites: login.websites,
      androidApps: login.androidApps,
      creditCard: login.creditCard,
      totp: login.totp,
      websiteAttributes: login.websiteAttributes,
      // NOTE: the following fields are explicitly redacted
      creationTime: "1970-01-01T00:00:00.000Z",
      editTime: "1970-01-01T00:00:00.000Z",
      changeTime: "1970-01-01T00:00:00.000Z"
    };
    const protectedSecret = newSymmetricSecret();
    const protectedLogin = recursivelyTransformUnprotectedValues(strippedLogin, (pv) => protect(protectedSecret, pv));
    const loginJson = jsonStringifyFreeze(protectedLogin);
    const secret = newSymmetricSecret();
    const encryptedPayload = symEncrypt(secret, naclUtilExports.decodeUTF8(loginJson));
    const encryptedProtectedSecret = symEncryptSymmetricEncryptionKey(secret, protectedSecret);
    const secretBase64 = encodeBase64Urlsafe(secret);
    return { encryptedPayload, secretBase64, encryptedProtectedSecret };
  }
  const UNIURI_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  function newUniURI() {
    const seed = [...randomSeed().subarray(0, 16)];
    return seed.map((b2) => UNIURI_ALPHABET.charAt(b2 % UNIURI_ALPHABET.length)).join("");
  }
  var __awaiter$G = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$m = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalLoginShareLinkCreate$1(_a3, vaultId, loginId) {
    var ccs = __rest$m(_a3, []);
    return __awaiter$G(this, void 0, void 0, function* () {
      if (!ccs.protectedSecretRepo) {
        throw new VaultIsLockedError();
      }
      const vaultPair = ccs.vaultRepo.getLoginVaultPairById(vaultId);
      if (!vaultPair) {
        throw new VaultNotFoundError(vaultId);
      }
      const { permissions } = getLoginVaultMetadata(ccs, vaultPair);
      if (!permissions.editLogins || !permissions.viewSecrets) {
        throw new VaultPermissionDeniedError();
      }
      let modifiedVault = vaultPair.login;
      const protectedLogin = modifiedVault.getContent().logins[loginId];
      if (!protectedLogin) {
        throw new LoginNotFoundError(loginId);
      }
      const { unprotectWithContentId: unprotectWithContentId2 } = ccs.protectedSecretRepo.getProtectedSecretFunctions(modifiedVault);
      const login = recursivelyTransformProtectedValues(protectedLogin, unprotectWithContentId2);
      const { encryptedPayload, secretBase64, encryptedProtectedSecret } = encryptShareLinkLogin(login);
      const shareLinkId = newUniURI();
      modifiedVault = modifiedVault.withAddShareLinkUpdate({
        id: shareLinkId,
        encryptedPayload,
        encryptedProtectedSecret
      });
      ccs = modifyLoginVault(ccs, modifiedVault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2, protect: protect2 }) => {
        var _a4;
        const result2 = modifyLoginInternal2(c2, t2, loginId, {
          shareLinks: [
            ...(_a4 = protectedLogin.shareLinks) !== null && _a4 !== void 0 ? _a4 : [],
            {
              id: shareLinkId,
              createdAt: (/* @__PURE__ */ new Date()).toISOString(),
              secret: protect2({ contentId: newUuid$1(), unencrypted: secretBase64 })
            }
          ]
        });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [
          {
            type: AuditlogEventType.LOGIN_SHARE_LINK_CREATE,
            loginId,
            vaultId
          }
        ] });
      });
      ccs = Object.assign(Object.assign({}, ccs), { accountState: ccs.accountState.withLocalAchievements([Achievement.WEB_LOGIN_CREATE_SHARE_LINK]) });
      ccs = yield onlineInternalSync(ccs);
      return Object.assign(Object.assign({}, ccs), { returnResult: { shareLinkId, secretBase64 } });
    });
  }
  var __awaiter$F = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$l = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalLoginShareLinkCreate(_a3, vaultId, loginId, shareLinkId) {
    var _b;
    var ccs = __rest$l(_a3, []);
    return __awaiter$F(this, void 0, void 0, function* () {
      const vaultPair = ccs.vaultRepo.getLoginVaultPairById(vaultId);
      if (!vaultPair) {
        throw new VaultNotFoundError(vaultId);
      }
      const { permissions } = getLoginVaultMetadata(ccs, vaultPair);
      if (!permissions.editLogins || !permissions.viewSecrets) {
        throw new VaultPermissionDeniedError();
      }
      const vault = vaultPair.login;
      const protectedLogin = vault.getContent().logins[loginId];
      if (!protectedLogin) {
        throw new LoginNotFoundError(loginId);
      }
      if (!ccs.protectedSecretRepo) {
        throw new VaultIsLockedError();
      }
      if (!((_b = protectedLogin.shareLinks) === null || _b === void 0 ? void 0 : _b.some((sl2) => sl2.id === shareLinkId))) {
        throw new ShareLinkNotFoundError(shareLinkId);
      }
      ccs = modifyLoginVault(ccs, vault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
        var _a4;
        const result2 = modifyLoginInternal2(c2, t2, loginId, {
          shareLinks: (_a4 = protectedLogin.shareLinks) === null || _a4 === void 0 ? void 0 : _a4.filter((sl2) => sl2.id !== shareLinkId)
        });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
      });
      return onlineInternalSync(ccs);
    });
  }
  var __awaiter$E = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$k = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalOrganizationRegenerateProfiles(inputCcs, orgId, profiles) {
    return __awaiter$E(this, void 0, void 0, function* () {
      const profileIds = profiles.map((p2) => p2.profileId);
      return performWithPersonalVaultsSyncPredicate(inputCcs, profileIds, (_a3, hsc) => __awaiter$E(this, void 0, void 0, function* () {
        var ccs = __rest$k(_a3, []);
        const org = ccs.accountState.getOrganization(orgId);
        if (!org) {
          throw new OrganizationNotFoundError();
        }
        if (!org.isAdmin) {
          throw new NoOrganizationAdminError();
        }
        const { vaultRepo, protectedSecretRepo } = ccs;
        if (!protectedSecretRepo) {
          throw new ClientCoreIsLockedError();
        }
        const userIds = profiles.flatMap((p2) => p2.userId ? p2.userId : []);
        const { authenticatorsByUser } = yield onlineInternalGetUsers(ccs.backendClient, userIds, [], []);
        const orgAdminProfile = ccs.profileRepo.getOrgAdminProfile(orgId);
        const returnResult = {};
        for (const { profileId, userId } of profiles) {
          const orgProfile = org === null || org === void 0 ? void 0 : org.profiles.find((p2) => p2.profileId === profileId);
          if (!org || !orgProfile) {
            throw new Error("Profile organization not found");
          }
          const unsynced = UnsyncedProfile.createWithSeed(ProfileType.ORGANIZATION, org.id, userId ? authenticatorsByUser[userId] : [], []);
          const vaultLocks = vaultRepo.getAllVaultsByProfileId(profileId).map((v2) => ({
            vaultId: v2.id,
            generationId: v2.generationId,
            lock: protectedSecretRepo.createProfileLock(v2, unsynced.unsyncedProfile)
          }));
          const downstreamProfileLocks = orgProfile.isAdmin && orgAdminProfile ? [
            hsc.getHighSecurityUnlockedProfile(orgAdminProfile, ccs.profileRepo).createProfileLock(unsynced.unsyncedProfile)
          ] : [];
          const regProfile = {
            profile: unsynced.unsyncedProfile.serialize(profileId),
            vaultLocks,
            downstreamProfileLocks
          };
          yield ccs.backendClient.organization.regenerateUser(orgId, userId, regProfile);
          returnResult[profileId] = unsynced;
        }
        return Object.assign(Object.assign({}, ccs), { returnResult });
      }));
    });
  }
  function performWithPersonalVaultsSyncPredicate(ccs, profileIds, operation) {
    var _a3;
    return __awaiter$E(this, void 0, void 0, function* () {
      const originalForeignVaultSyncPredicate = ccs.ephemeralForeignVaultSyncPredicate;
      ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { profileAllVaults: [
        ...(_a3 = ccs.ephemeralForeignVaultSyncPredicate.profileAllVaults) !== null && _a3 !== void 0 ? _a3 : [],
        ...profileIds
      ] });
      const originalBackendClient = ccs.backendClient;
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      let hsc;
      ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
      if (!hsc) {
        throw new ClientCoreIsLockedError();
      }
      const _b = yield operation(ccs, hsc), { returnResult } = _b, newCcs = __rest$k(_b, ["returnResult"]);
      ccs = newCcs;
      ccs.syncVersion = null;
      ccs.backendClient = originalBackendClient.withSyncVersion(void 0);
      ccs.ephemeralForeignVaultSyncPredicate = originalForeignVaultSyncPredicate;
      ccs = yield onlineInternalSync(ccs);
      return Object.assign(Object.assign({}, ccs), { returnResult });
    });
  }
  var __awaiter$D = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$j = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineMaintainOrganizationPreliminaryProfiles(_a3) {
    var _b;
    var ccs = __rest$j(_a3, []);
    return __awaiter$D(this, void 0, void 0, function* () {
      const task = MaintenanceTask.ORGANIZATION_PRELIMINARY_PROFILES_V3;
      if (!((_b = ccs.maintenanceSettings) === null || _b === void 0 ? void 0 : _b.allowedTasks.includes(task))) {
        return ccs;
      }
      const registeredFreeProfiles = getOrganizationsProfilesWithPreliminaryUserId(ccs.accountState.organizations, ccs.profileRepo);
      for (const { organization, profiles } of registeredFreeProfiles) {
        ccs = yield onlineInternalOrganizationRegenerateProfiles(ccs, organization.id, profiles.map(({ profileId, preliminaryUserId }) => ({
          profileId,
          userId: preliminaryUserId
        })));
      }
      return ccs;
    });
  }
  function getOrganizationsProfilesWithPreliminaryUserId(organizations, profileRepo) {
    return organizations.filter((org) => org.isAdmin && !!org.adminInfo).filter((org) => !!profileRepo.getOrganizationProfile(org.id)).flatMap((organization) => {
      const profiles = organization.profiles.filter((p2) => !!p2.preliminaryUserId);
      return profiles.length ? { organization, profiles } : [];
    });
  }
  function normalizeEmailAddress(email) {
    return email.trim().toLowerCase();
  }
  var __awaiter$C = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalTeamModifyUsers(ccs, teamId, { profileIdsToRemove, usersToAdd, skipInvite }) {
    return __awaiter$C(this, void 0, void 0, function* () {
      const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
      if (!pair) {
        throw new VaultNotFoundError(teamId);
      }
      let { login: loginVault, meta: metaVault } = pair;
      const backendClient = getBackendClientForVault(ccs, loginVault);
      const normalizedUsersToAdd = usersToAdd === null || usersToAdd === void 0 ? void 0 : usersToAdd.map((u2) => u2.by === "email" ? Object.assign(Object.assign({}, u2), { email: normalizeEmailAddress(u2.email) }) : u2);
      if (
        // only admins can perform user operations
        getLoggedInUserTeamPermissionLevel(ccs.accountState, metaVault) !== PermissionLevel.admin
      ) {
        throw new VaultPermissionDeniedError();
      }
      const { addProfileOps } = normalizedUsersToAdd ? yield onlineCreateAddUserOps(ccs, loginVault, metaVault, normalizedUsersToAdd) : { addProfileOps: [] };
      const commitData = getUpdatedMetaVault$1(ccs, metaVault, addProfileOps, profileIdsToRemove, skipInvite);
      const { syncUpdate } = yield backendClient.vault.modifyTeamUsers(teamId, loginVault.generationId, addProfileOps, profileIdsToRemove !== null && profileIdsToRemove !== void 0 ? profileIdsToRemove : [], metaVault.generationId, commitData === null || commitData === void 0 ? void 0 : commitData.metaVaultCommitId, commitData === null || commitData === void 0 ? void 0 : commitData.blob, commitData === null || commitData === void 0 ? void 0 : commitData.latestUpdateTime);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  function onlineCreateAddUserOps({ backendClient, protectedSecretRepo }, loginVault, metaVault, normalizedUsersToAdd) {
    var _a3, _b;
    return __awaiter$C(this, void 0, void 0, function* () {
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const { index: index2, profilesById } = yield onlineInternalGetUsers(backendClient, [], normalizedUsersToAdd.flatMap((u2) => u2.by === "profile" ? u2.profileId : []), normalizedUsersToAdd.flatMap((u2) => u2.by === "email" ? u2.email : []), (_a3 = loginVault.organizationId) !== null && _a3 !== void 0 ? _a3 : void 0);
      const addProfileOps = [];
      for (const { profileId, email } of index2) {
        const userToAdd = (_b = normalizedUsersToAdd.find((u2) => u2.by === "profile" && u2.profileId === profileId)) !== null && _b !== void 0 ? _b : normalizedUsersToAdd.find((u2) => u2.by === "email" && u2.email === email);
        if (!userToAdd) {
          continue;
        }
        const { permissionLevel } = userToAdd;
        if (profileId) {
          const p2 = profilesById[profileId];
          const lock = serializeVaultProfileLock(protectedSecretRepo.createProfileLock(loginVault, p2));
          const associatedLock = serializeVaultProfileLock(protectedSecretRepo.createProfileLock(metaVault, p2));
          addProfileOps.push({
            id: profileId,
            email: email !== null && email !== void 0 ? email : void 0,
            lock,
            associatedLock,
            permissionLevel
          });
        }
      }
      return { addProfileOps };
    });
  }
  function getUpdatedMetaVault$1(ccs, metaVault, addedProfiles, removeProfileIds, skipMarkNewlyJoined) {
    var _a3;
    const relevantProfileId = metaVault.getProfileId();
    const relevantEmail = relevantProfileId ? (_a3 = ccs.profileRepo.getUnlocked(relevantProfileId)) === null || _a3 === void 0 ? void 0 : _a3.profile.email : ccs.accountState.getPrimaryEmail();
    ({ vault: metaVault } = metaVault.withModification((initialVaultContent, t2, ops) => {
      let newVaultContent = initialVaultContent;
      const org = metaVault.organizationId ? ccs.accountState.getOrganization(metaVault.organizationId) : void 0;
      if (addedProfiles) {
        newVaultContent = addedProfiles.reduce((c2, addedProfile) => {
          var _a4, _b, _c2;
          const isNotConnected = (_b = (_a4 = org === null || org === void 0 ? void 0 : org.profiles.find((p2) => p2.profileId === addedProfile.id)) === null || _a4 === void 0 ? void 0 : _a4.isNotConnected) !== null && _b !== void 0 ? _b : false;
          return ops.addOrModifyTeamVaultUser(c2, t2, addedProfile.id, {
            newlyJoined: skipMarkNewlyJoined || isNotConnected ? void 0 : {
              // Only filled in for compatibility with older clients that require this field to be
              // set
              addedByUserId: nullUuid,
              addedByEmail: relevantEmail !== null && relevantEmail !== void 0 ? relevantEmail : ""
            },
            permissionLevel: (_c2 = addedProfile.permissionLevel) !== null && _c2 !== void 0 ? _c2 : TEAM_USER_DEFAULT_PERMISSION_LEVEL
          }).newVaultContent;
        }, newVaultContent);
      }
      if (removeProfileIds) {
        newVaultContent = removeProfileIds.reduce((c2, userId) => {
          return ops.deleteTeamVaultUser(c2, t2, userId).newVaultContent;
        }, newVaultContent);
      }
      return { newVaultContent, result: void 0 };
    }));
    const stagedData = metaVault.getStagedDiff(null);
    if (!stagedData) {
      return null;
    }
    const { stagingVault, diff, latestUpdateTime } = stagedData;
    const protoCommit = Commit.create(null, stagingVault.vaultSecret, diff);
    return {
      metaVaultCommitId: metaVault.commitId,
      blob: protoCommit.blob,
      latestUpdateTime: new Date(latestUpdateTime)
    };
  }
  var __awaiter$B = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$i = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalMaintainTeamSyncOrganizationMembers(_a3, skipInvite) {
    var _b;
    var ccs = __rest$i(_a3, []);
    return __awaiter$B(this, void 0, void 0, function* () {
      const task = MaintenanceTask.TEAM_SYNC_ORGANIZATION_MEMBERS_V2;
      if (!((_b = ccs.maintenanceSettings) === null || _b === void 0 ? void 0 : _b.allowedTasks.includes(task))) {
        return ccs;
      }
      const teamsToChange = getTeamsWithSyncOrganizationMembersAndMismatchedUsers(ccs.vaultRepo, ccs.accountState);
      if (!teamsToChange.length) {
        return ccs;
      }
      for (const { teamId, details } of teamsToChange) {
        const { profileIdsToAdd, profileIdsToRemove, profilesToUpdate } = details;
        if (profileIdsToAdd.length || profileIdsToRemove.length) {
          ccs = yield onlineInternalTeamModifyUsers(ccs, teamId, {
            usersToAdd: profileIdsToAdd.map((profileId) => {
              return {
                by: "profile",
                profileId,
                permissionLevel: void 0
              };
            }),
            profileIdsToRemove,
            skipInvite
          });
        }
        if (profilesToUpdate.length) {
          ccs = internalTeamSetUserPermissionLevels(ccs, teamId, ...profilesToUpdate.map(({ profileId, isAdmin }) => ({
            profileId,
            permissionLevel: deriveTeamPermissionLevelFromOrgIsAdmin(isAdmin)
          })));
          ccs = yield onlineInternalSync(ccs);
        }
      }
      return ccs;
    });
  }
  function getTeamsWithSyncOrganizationMembersAndMismatchedUsers(vaultRepo, accountState) {
    return vaultRepo.getTeamVaultPairs().map(({ login, meta }) => {
      if (!login.organizationId || getLoggedInUserTeamPermissionLevel(accountState, meta) !== PermissionLevel.admin || !getTeamMetaVaultInfo(meta.getContent()).isSyncOrganizationMembers) {
        return null;
      }
      const organization = accountState.getOrganization(login.organizationId);
      if (!organization) {
        return null;
      }
      const adminProfileIds = organization.adminProfileId ? [organization.adminProfileId] : [];
      const organizationProfileIds = /* @__PURE__ */ new Set([
        ...adminProfileIds,
        ...organization.profiles.flatMap(({ profileId, isService }) => isService ? [] : profileId)
      ]);
      const currentUserProfileId = login.getProfileId();
      if (currentUserProfileId) {
        organizationProfileIds.add(currentUserProfileId);
      }
      const teamProfileIds = new Set(login.profileIds);
      const profileIdsToAdd = setDifference(organizationProfileIds, teamProfileIds);
      const profileIdsToRemove = setDifference(teamProfileIds, organizationProfileIds);
      const profilesToUpdate = organization.profiles.filter(({ profileId, isAdmin }) => teamProfileIds.has(profileId) && !orgIsAdminMatchesTeamPermissionLevel(isAdmin, getPermissionLevel(meta.getContent(), profileId)));
      return {
        teamId: login.id,
        details: {
          profileIdsToAdd,
          profileIdsToRemove,
          profilesToUpdate
        }
      };
    }).filter((teamResult) => !!teamResult && Object.values(teamResult.details).some((val) => val.length));
  }
  function orgIsAdminMatchesTeamPermissionLevel(isAdmin, permissionLevel) {
    if (isAdmin) {
      return permissionLevel === PermissionLevel.admin;
    }
    return permissionLevel !== PermissionLevel.admin;
  }
  function deriveTeamPermissionLevelFromOrgIsAdmin(isAdmin) {
    return isAdmin ? PermissionLevel.admin : TEAM_USER_DEFAULT_PERMISSION_LEVEL;
  }
  function setDifference(a, b2) {
    return [...a].filter((x2) => !b2.has(x2));
  }
  var __awaiter$A = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$h = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalMaintainVaultMessages(_a3) {
    var ccs = __rest$h(_a3, []);
    return __awaiter$A(this, void 0, void 0, function* () {
      if (!ccs.protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const protectedSecretRepo = ccs.protectedSecretRepo;
      const vaultsWithMessages = ccs.vaultRepo.getAllVaults().filter((v2) => !!v2.messageQueue.length);
      const updates = vaultsWithMessages.map((vault) => {
        const { protect: protect2, decryptVaultMessage } = protectedSecretRepo.getProtectedSecretFunctions(vault);
        if (!decryptVaultMessage) {
          throw new Error("cannot decrypt inbox vault");
        }
        return processVaultMessages(vault, decryptVaultMessage, protect2);
      });
      const updatedVaultPromises = updates.map(({ vault, processedMessageIds }) => __awaiter$A(this, void 0, void 0, function* () {
        const stagedDiff = vault.getStagedDiff(null);
        if (!stagedDiff) {
          return;
        }
        const { diff, latestUpdateTime, stagingVault } = stagedDiff;
        const protoCommit = Commit.create(null, vault.vaultSecret, diff);
        const backendClient = getBackendClientForVault(ccs, vault);
        const { commitId } = yield backendClient.vault.createCommit(vault.id, vault.commitId, protoCommit.blob, new Date(latestUpdateTime), processedMessageIds);
        const filteredMessages = stagingVault.messageQueue.filter((m2) => !processedMessageIds.includes(m2.id));
        return stagingVault.withCommitId(commitId).withMessageQueue(filteredMessages);
      }));
      const updateResults = yield Promise.allSettled(updatedVaultPromises);
      const updatedVaults = updateResults.flatMap((result2) => {
        if (result2.status == "rejected") {
          if (result2.reason instanceof DomainError$1) {
            if (result2.reason.code === BackendErrorCode.VAULT_OUT_OF_SYNC) {
              return [];
            }
            if (result2.reason.code === BackendErrorCode.VAULT_DIRTY) {
              return [];
            }
          }
          trackError(result2.reason);
          return [];
        }
        if (result2.value) {
          return [result2.value];
        }
        return [];
      });
      const updatedVaultRepo = updatedVaults.length ? ccs.vaultRepo.withUpdateVaults(...updatedVaults) : ccs.vaultRepo;
      return Object.assign(Object.assign({}, ccs), { vaultRepo: updatedVaultRepo });
    });
  }
  function hasProcessableVaultMessages(vaultRepo) {
    return vaultRepo.getAllVaults().flatMap((v2) => v2.messageQueue).some((m2) => KNOWN_VAULT_MESSAGE_TYPES.includes(m2.type));
  }
  var __awaiter$z = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$g = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalMigrateToAuthenticatorChain(_a3, hsc) {
    var ccs = __rest$g(_a3, []);
    return __awaiter$z(this, void 0, void 0, function* () {
      const authenticatorKeys = ccs.accountState.authenticators.map((a) => a.highSecurityIdentitySigPubKey);
      const authenticatorBlock = AuthenticatorBlock.create(hsc.getHighSecurityUnlockedAuthenticator().highSecurityIdentitySigPrivKey, authenticatorKeys);
      try {
        const syncUpdate = yield ccs.backendClient.authenticator.createInitialAuthenticatorBlock(authenticatorBlock);
        return yield onlineInternalSync(ccs, syncUpdate);
      } catch (e2) {
        if (e2 instanceof BackendDomainError && e2.code === BackendErrorCode.AUTHENTICATOR_BLOCK_EXISTS) {
          return ccs;
        }
        throw e2;
      }
    });
  }
  function regenerateProfiles(hsc, protectedSecretRepo, vaultRepo, profileRepo, authenticators, newAuthenticators) {
    const unsyncedProfiles = profileRepo.profiles.map(({ profile }) => ({
      profile,
      unsynced: UnsyncedProfile.create(profile.profileType, profile.organizationId, authenticators)
    }));
    const regeneratedProfiles = unsyncedProfiles.map(({ profile, unsynced }) => {
      const vaultLocks = vaultRepo.getAllVaults().filter((v2) => v2.profileIds.includes(profile.id)).map((v2) => ({
        vaultId: v2.id,
        generationId: v2.generationId,
        lock: protectedSecretRepo.createProfileLock(v2, unsynced)
      }));
      const downstreamProfileLocks = profileRepo.getAllProfilesByLockingProfileId(profile.id).map((p2) => {
        const hsup = hsc.getHighSecurityUnlockedProfile(p2, profileRepo);
        return hsup.createProfileLock(unsynced);
      });
      return {
        profile: unsynced.serialize(profile.id, profile.keyGenerationId),
        vaultLocks,
        downstreamProfileLocks
      };
    });
    const authenticatorCreationDtos = newAuthenticators.map((ua2) => ua2.serializeWithLocks(unsyncedProfiles.map(({ profile, unsynced }) => Object.assign(Object.assign({}, unsynced.createExtraLock(ua2)), { profileId: profile.id, profileKeyGenerationId: nullUuid }))));
    return { regeneratedProfiles, authenticatorCreationDtos };
  }
  var __awaiter$y = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$f = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalModifyAuthenticators(inputCcs, hsc, deleteAuthenticatorIds, newAuthenticators = []) {
    return __awaiter$y(this, void 0, void 0, function* () {
      return performWithSyncSuperUsers(inputCcs, hsc, (_a3) => __awaiter$y(this, void 0, void 0, function* () {
        var ccs = __rest$f(_a3, []);
        let { protectedSecretRepo } = ccs;
        if (!protectedSecretRepo) {
          protectedSecretRepo = ProtectedSecretRepo.create(ccs, hsc, null);
        }
        const isRemovingLocalAuthenticator = deleteAuthenticatorIds.some((id2) => id2 === ccs.params.unlockedAuthenticator.authenticator.id);
        if (isRemovingLocalAuthenticator) {
          throw new RemoveLocalAuthenticatorError();
        }
        const remainingAuths = ccs.accountState.authenticators.filter((a) => deleteAuthenticatorIds.every((delId) => a.id !== delId));
        const authenticatorKeys = remainingAuths.map((a) => a.highSecurityIdentitySigPubKey);
        const newAuthenticatorKeys = newAuthenticators.map((a) => a.highSecurityIdentitySigPubKey);
        const newAuthenticatorBlock = AuthenticatorBlock.create(hsc.getHighSecurityUnlockedAuthenticator().highSecurityIdentitySigPrivKey, [...authenticatorKeys, ...newAuthenticatorKeys], ccs.accountState.authenticatorBlockHash);
        let regeneratedProfiles;
        let authenticatorCreationDtos;
        if (deleteAuthenticatorIds.length) {
          ({ regeneratedProfiles, authenticatorCreationDtos } = regenerateProfiles(hsc, protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, remainingAuths, newAuthenticators));
        } else {
          regeneratedProfiles = [];
          authenticatorCreationDtos = newAuthenticators.map((a) => a.serializeForCreation(ccs.profileRepo, hsc));
        }
        const { syncUpdate, authenticatorIds } = yield ccs.backendClient.authenticator.modify(authenticatorCreationDtos, deleteAuthenticatorIds, newAuthenticatorBlock, regeneratedProfiles);
        ccs = yield onlineInternalSync(ccs, syncUpdate, void 0, hsc);
        return Object.assign(Object.assign({}, ccs), { returnResult: authenticatorIds });
      }));
    });
  }
  function performWithSyncSuperUsers(ccs, hsc, operation) {
    return __awaiter$y(this, void 0, void 0, function* () {
      const originalBackendClient = ccs.backendClient;
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      ccs = yield onlineInternalSync(ccs, void 0, void 0, hsc);
      const _a3 = yield operation(ccs), { returnResult } = _a3, newCcs = __rest$f(_a3, ["returnResult"]);
      ccs = newCcs;
      ccs.syncVersion = null;
      ccs.backendClient = originalBackendClient.withSyncVersion(void 0);
      ccs = yield onlineInternalSync(ccs, void 0, void 0, hsc);
      return Object.assign(Object.assign({}, ccs), { returnResult });
    });
  }
  var __awaiter$x = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalSessionSetProfileEnabled(ccs, profileId, enabled) {
    return __awaiter$x(this, void 0, void 0, function* () {
      const sessionId = ccs.params.loginData.sessionId;
      const session = ccs.accountState.sessions.find((s2) => s2.id == sessionId);
      if (!session) {
        throw new OwnSessionMissingError();
      }
      const allProfilesEnabled = session.enabledProfileIds.length === 0;
      const allProfileIds = ccs.profileRepo.getAllLoginProfileIds();
      const previouslyEnabled = allProfilesEnabled || session.enabledProfileIds.some((pId) => pId === profileId);
      if (enabled === previouslyEnabled) {
        return ccs;
      }
      const oldEnabledProfileIds = allProfilesEnabled ? allProfileIds : session.enabledProfileIds.filter((pId) => allProfileIds.includes(pId));
      const enabledProfileIds = enabled ? [...oldEnabledProfileIds, profileId] : oldEnabledProfileIds.filter((pId) => pId !== profileId);
      return onlineInternalSessionSetEnabledProfileIds(ccs, enabledProfileIds);
    });
  }
  function onlineInternalSessionSetEnabledProfileIds(ccs, enabledProfileIds) {
    return __awaiter$x(this, void 0, void 0, function* () {
      const sessionId = ccs.params.loginData.sessionId;
      const su2 = yield ccs.backendClient.session.update(sessionId, [], { enabledProfileIds });
      return onlineInternalSync(ccs, su2);
    });
  }
  var __awaiter$w = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$e = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalOrganizationCreate(_a3, email, name, syncOrganizationMembersVaultName, options) {
    var _b, _c2;
    var ccs = __rest$e(_a3, []);
    return __awaiter$w(this, void 0, void 0, function* () {
      const unsyncedUserProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, null, ccs.accountState.authenticators);
      const { unsyncedProfile: unsyncedAdminProfile } = UnsyncedProfile.createWithSeed(ProfileType.ORGANIZATION_ADMIN, null, [], [unsyncedUserProfile]);
      const unsyncedPersonalVault = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, [], [], [], unsyncedUserProfile, unsyncedAdminProfile, null, organizationPersonalVaultContentDescriptor, null);
      const unsyncedTeamVault = UnsyncedVault.create(VaultType.TEAM, [], [], [], unsyncedUserProfile, unsyncedAdminProfile, null, loginVaultContentDescriptor, null);
      const unsyncedTeamMetaVault = UnsyncedVault.create(VaultType.TEAM_META, [], [], [], unsyncedUserProfile, unsyncedAdminProfile, null, teamMetaVaultContentDescriptor, null, getInitialMetaContentModification([], syncOrganizationMembersVaultName, true));
      const teamVaultDto = {
        blob: unsyncedTeamVault.getCommitBlob(),
        locks: unsyncedTeamVault.getAuthenticatorLockDtos(),
        profileLock: unsyncedTeamVault.getProfileLockDto(),
        adminProfileLock: unsyncedTeamVault.getAdminProfileLockDto(),
        messagePublicKey: (_b = unsyncedTeamVault.messageKeyPair) === null || _b === void 0 ? void 0 : _b.encPubKey,
        associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
        associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
        associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
        associatedMessagePublicKey: (_c2 = unsyncedTeamMetaVault.messageKeyPair) === null || _c2 === void 0 ? void 0 : _c2.encPubKey,
        associatedAdminProfileLock: unsyncedTeamMetaVault.getAdminProfileLockDto()
      };
      const unsyncedAdminVault = UnsyncedVault.create(VaultType.ORGANIZATION_ADMIN, [], [], [], null, unsyncedAdminProfile, null, organizationAdminVaultContentDescriptor, null, (c2, t2, { replaceOrganizationAdminVaultInfo: replaceOrganizationAdminVaultInfo2 }) => replaceOrganizationAdminVaultInfo2(c2, t2, {}));
      const result2 = yield ccs.backendClient.organization.create({
        name,
        email,
        userProfile: unsyncedUserProfile.serialize(),
        adminProfile: unsyncedAdminProfile.serialize(),
        personalVaultDto: unsyncedPersonalVault.getCreationDto(),
        teamVaultDto,
        contactJson: options === null || options === void 0 ? void 0 : options.contactJson,
        parentOrganizationInfo: (options === null || options === void 0 ? void 0 : options.parentOrganizationId) ? { id: options.parentOrganizationId } : void 0,
        adminVaultDto: unsyncedAdminVault.getCreationDto()
      });
      ccs = yield onlineInternalSync(ccs, result2.syncUpdate);
      ccs = yield onlineInternalSessionSetProfileEnabled(ccs, result2.profileId, true);
      return Object.assign(Object.assign({}, ccs), { returnResult: result2.organizationId });
    });
  }
  function createOrganizationAuthenticator() {
    const secret = { seed: randomSeed() };
    const unsyncedAuthenticator = UnsyncedAuthenticator.create(AuthenticatorType.ORGANIZATION_ADMIN, "", secret);
    return { secret, unsyncedAuthenticator };
  }
  function serializeAuthenticator(a) {
    const id2 = "id" in a ? a.id : nullUuid;
    return Object.assign(Object.assign({}, a), { id: id2 });
  }
  var __awaiter$v = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$d = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalOrganizationCreateLegacy(_a3, email, name, syncOrganizationMembersVaultName, options) {
    var _b, _c2;
    var ccs = __rest$d(_a3, []);
    return __awaiter$v(this, void 0, void 0, function* () {
      const { secret, unsyncedAuthenticator: orgAuth } = createOrganizationAuthenticator();
      const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, null, ccs.accountState.authenticators);
      const unsyncedAdminVault = UnsyncedVault.create(VaultType.LEGACY_ORGANIZATION_ADMIN, [], [], [], unsyncedProfile, null, null, legacyOrganizationAdminVaultContentDescriptor, null, (c2, t2, { protect: prot, replaceLegacyOrganizationAdminVaultInfo: replaceLegacyOrganizationAdminVaultInfo2 }) => replaceLegacyOrganizationAdminVaultInfo2(c2, t2, {
        authenticatorSecret: {
          seed: prot({ unencrypted: naclUtilExports.encodeBase64(secret.seed), contentId: newUuid$1() })
        }
      }));
      const authBlock = AuthenticatorBlock.fromUnsyncedAuthenticators(orgAuth, []);
      const unsyncedPersonalVault = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, [], [], [], unsyncedProfile, null, null, organizationPersonalVaultContentDescriptor, null);
      const unsyncedTeamVault = UnsyncedVault.create(VaultType.TEAM, [], [], [], unsyncedProfile, null, null, loginVaultContentDescriptor, null);
      const unsyncedTeamMetaVault = UnsyncedVault.create(VaultType.TEAM_META, [], [], [], unsyncedProfile, null, null, teamMetaVaultContentDescriptor, null, getInitialMetaContentModification([], syncOrganizationMembersVaultName, true));
      const teamVaultDto = {
        blob: unsyncedTeamVault.getCommitBlob(),
        locks: unsyncedTeamVault.getAuthenticatorLockDtos(),
        profileLock: unsyncedTeamVault.getProfileLockDto(),
        messagePublicKey: (_b = unsyncedTeamVault.messageKeyPair) === null || _b === void 0 ? void 0 : _b.encPubKey,
        associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
        associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
        associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
        associatedMessagePublicKey: (_c2 = unsyncedTeamMetaVault.messageKeyPair) === null || _c2 === void 0 ? void 0 : _c2.encPubKey
      };
      const result2 = yield ccs.backendClient.organization.create({
        name,
        email,
        userProfile: unsyncedProfile.serialize(),
        orgAuth: serializeAuthenticator(orgAuth),
        legacyAdminVaultDto: unsyncedAdminVault.getCreationDto(),
        authenticatorBlock: { blob: authBlock.blob, signature: authBlock.signature },
        personalVaultDto: unsyncedPersonalVault.getCreationDto(),
        personalVaultSuperuserLock: unsyncedPersonalVault.getExtraLockDto(orgAuth),
        teamVaultDto,
        teamVaultSuperuserLock: unsyncedTeamVault.getExtraLockDto(orgAuth),
        teamAssociatedVaultSuperuserLock: unsyncedTeamMetaVault.getExtraLockDto(orgAuth),
        contactJson: options === null || options === void 0 ? void 0 : options.contactJson,
        parentOrganizationInfo: (options === null || options === void 0 ? void 0 : options.parentOrganizationId) ? { id: options.parentOrganizationId } : void 0
      });
      ccs = yield onlineInternalSync(ccs, result2.syncUpdate);
      ccs = yield onlineInternalSessionSetProfileEnabled(ccs, result2.profileId, true);
      return Object.assign(Object.assign({}, ccs), { returnResult: result2.organizationId });
    });
  }
  var __awaiter$u = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalOrganizationCreateServiceProfile(ccs, orgId) {
    return __awaiter$u(this, void 0, void 0, function* () {
      const org = ccs.accountState.organizations.find((o2) => o2.id === orgId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      let hsc;
      ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
      if (!hsc) {
        throw new ClientCoreIsLockedError();
      }
      const adminUp = ccs.profileRepo.getOrgAdminProfile(orgId);
      if (!adminUp) {
        throw new NoOrganizationAdminError();
      }
      const adminHsup = hsc.getHighSecurityUnlockedProfile(adminUp, ccs.profileRepo);
      const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION_SERVICE, orgId, []);
      const adminProfileLock = adminHsup.createProfileLock(unsyncedProfile);
      const syncUpdate = yield ccs.backendClient.organization.createServiceProfile(orgId, unsyncedProfile.serialize(), adminProfileLock);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$t = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$c = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalOrganizationDelete(_a3, orgId) {
    var ccs = __rest$c(_a3, []);
    return __awaiter$t(this, void 0, void 0, function* () {
      ccs = yield onlineInternalSync(ccs);
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.getOrganization(orgId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      const syncUpdate = yield ccs.backendClient.organization.delete(orgId);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$s = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalOrganizationModifyMembers(ccs, orgId, { createFreeProfiles, updateProfiles, removeProfileIds }) {
    var _a3;
    return __awaiter$s(this, void 0, void 0, function* () {
      const disabledOrgProfile = ccs.profileRepo.disabledProfiles.find((p2) => p2.organizationId === orgId);
      const fullSyncRequired = !!disabledOrgProfile;
      if (disabledOrgProfile) {
        ccs.ephemeralOperationState = {
          additionalEnabledProfileIds: [disabledOrgProfile.id]
        };
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
      }
      let hsc;
      ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
      if (!hsc) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.organizations.find((o2) => o2.id === orgId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      const orgProfile = ccs.profileRepo.getOrganizationProfile(orgId);
      if (!orgProfile) {
        throw new OrganizationNotFoundError();
      }
      const profiles = org.profiles;
      profiles.push({
        profileId: orgProfile.profile.id,
        isAdmin: org.isAdmin,
        isManager: org.isManager,
        isService: false,
        isNotConnected: false
      });
      const { adminInfo } = org;
      if (!adminInfo || !adminInfo.authenticator && !adminInfo.adminProfile) {
        throw new NoOrganizationAdminError();
      }
      const adminAuthenticator = adminInfo.authenticator ? [loadForeignAuthenticator(adminInfo.authenticator)] : [];
      const superUserVaultMemberIds = adminInfo.authenticator ? [org.superUserId] : [];
      const adminProfile = adminInfo.adminProfile ? loadForeignProfile(adminInfo.adminProfile) : null;
      const adminUp = ccs.profileRepo.getOrgAdminProfile(orgId);
      const adminHsup = adminUp ? hsc.getHighSecurityUnlockedProfile(adminUp, ccs.profileRepo) : void 0;
      const addedAdminProfileIds = [];
      const removedAdminProfileIds = [];
      let addedAdminUnsyncedProfiles = [];
      removeProfileIds === null || removeProfileIds === void 0 ? void 0 : removeProfileIds.forEach((pId) => {
        const existingMember = profiles.find((p2) => uuidEqual(pId, p2.profileId));
        if (existingMember === null || existingMember === void 0 ? void 0 : existingMember.isAdmin) {
          removedAdminProfileIds.push(pId);
        }
      });
      let createProfileDtos = [];
      if (createFreeProfiles === null || createFreeProfiles === void 0 ? void 0 : createFreeProfiles.length) {
        createProfileDtos = createFreeProfiles.flatMap((p2) => {
          const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, orgId, []);
          const personalVaultDto = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, superUserVaultMemberIds, [], adminAuthenticator, unsyncedProfile, adminProfile, orgId, organizationPersonalVaultContentDescriptor, null).getCreationDto();
          const legacyAdminVaultLock = void 0;
          const adminProfileLock = p2.isAdmin ? adminHsup === null || adminHsup === void 0 ? void 0 : adminHsup.createProfileLock(unsyncedProfile) : void 0;
          return {
            userId: null,
            email: p2.email,
            isAdmin: p2.isAdmin,
            createStartCodeAndSendMail: p2.createStartCodeAndSendMail,
            profileDto: unsyncedProfile.serialize(),
            unsyncedProfile,
            personalVaultDto,
            legacyAdminVaultLock,
            adminProfileLock
          };
        });
        addedAdminUnsyncedProfiles = createProfileDtos ? createProfileDtos.filter(({ isAdmin }) => isAdmin).map((dto) => dto.unsyncedProfile) : [];
      }
      let selfDemotion = false;
      let updateProfileDtos;
      if (updateProfiles) {
        const { profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], updateProfiles.map(({ id: id2 }) => id2), []);
        updateProfileDtos = updateProfiles.map(({ id: profileId, isAdmin }) => {
          let adminProfileLock;
          const existingProfile = profiles.find((m2) => uuidEqual(profileId, m2.profileId));
          if (isAdmin !== void 0 && isAdmin !== (existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.isAdmin)) {
            if (isAdmin) {
              addedAdminProfileIds.push(profileId);
              adminProfileLock = adminHsup === null || adminHsup === void 0 ? void 0 : adminHsup.createProfileLock(profilesById[profileId]);
            } else if (existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.isAdmin) {
              if (profileId === orgProfile.profile.id) {
                selfDemotion = true;
              }
              removedAdminProfileIds.push(profileId);
            }
          }
          return { profileId, isAdmin, adminProfileLock };
        });
      }
      if (selfDemotion) {
        const tvps = ccs.vaultRepo.getOrganizationTeamVaultPairs(orgId);
        for (const tvp of tvps) {
          if (getTeamMetaVaultInfo(tvp.meta.getContent()).isSyncOrganizationMembers) {
            ccs = internalTeamSetUserPermissionLevels(ccs, tvp.login.id, {
              profileId: orgProfile.profile.id,
              permissionLevel: TEAM_USER_DEFAULT_PERMISSION_LEVEL
            });
          }
        }
      }
      let regeneratedVaultDto;
      if (removedAdminProfileIds.length || addedAdminProfileIds.length || addedAdminUnsyncedProfiles.length) {
        if (!org.adminInfo) {
          throw new NoOrganizationAdminError();
        }
        if (org.adminInfo.legacyAdminVaultId && org.adminInfo.legacyAdminVaultId !== nullUuid) {
          const adminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
          if (!adminVault) {
            throw new VaultNotFoundError(org.adminInfo.legacyAdminVaultId);
          }
          const adminProfileIdSet = /* @__PURE__ */ new Set([...adminVault.profileIds, ...addedAdminProfileIds]);
          for (const pId of removedAdminProfileIds) {
            adminProfileIdSet.delete(pId);
          }
          const adminProfileIds = [...adminProfileIdSet];
          const { authenticatorsByUser, profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], adminProfileIds, []);
          const oldProtectedSecret = (_a3 = ccs.protectedSecretRepo) === null || _a3 === void 0 ? void 0 : _a3.protectedSecrets[adminVault.id];
          if (!oldProtectedSecret) {
            throw new CannotUnprotectError();
          }
          const regenerateData = regenerateVaultForUsers(adminVault, authenticatorsByUser, profilesById, [], adminProfileIds, [], addedAdminUnsyncedProfiles, oldProtectedSecret.protectedSecret, oldProtectedSecret.messagePrivateKey);
          regeneratedVaultDto = regenerateData.regeneratedVaultDto;
          createProfileDtos === null || createProfileDtos === void 0 ? void 0 : createProfileDtos.filter(({ isAdmin }) => isAdmin).forEach((dto, i2) => {
            dto.legacyAdminVaultLock = regenerateData.newProfileLockDtos[i2];
          });
        }
      }
      const syncUpdate = yield ccs.backendClient.organization.modifyMembers(orgId, createProfileDtos !== null && createProfileDtos !== void 0 ? createProfileDtos : [], updateProfileDtos !== null && updateProfileDtos !== void 0 ? updateProfileDtos : [], removeProfileIds !== null && removeProfileIds !== void 0 ? removeProfileIds : [], regeneratedVaultDto);
      ccs.ephemeralOperationState = void 0;
      if (fullSyncRequired) {
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
      }
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      ccs = yield onlineInternalMaintainTeamSyncOrganizationMembers(ccs, true);
      return ccs;
    });
  }
  var __awaiter$r = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$b = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalOrganizationRegenerateAdminProfile(inputCcs, orgId) {
    return __awaiter$r(this, void 0, void 0, function* () {
      return performWithOrgAllVaultsSyncPredicate(inputCcs, orgId, (_a3) => __awaiter$r(this, void 0, void 0, function* () {
        var ccs = __rest$b(_a3, []);
        const org = ccs.accountState.getOrganization(orgId);
        const orgProfile = ccs.profileRepo.getOrganizationProfile(orgId);
        const { vaultRepo, protectedSecretRepo } = ccs;
        if (!org || !org.adminInfo || !orgProfile || !protectedSecretRepo) {
          return ccs;
        }
        const adminProfileIds = org.profiles.flatMap((p2) => p2.isAdmin ? p2.profileId : []);
        const { profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], adminProfileIds, [], org.id);
        const lockingProfiles = adminProfileIds.map((adminProfileId) => profilesById[adminProfileId]);
        lockingProfiles.push(orgProfile.profile);
        const { unsyncedProfile: adminProfile } = UnsyncedProfile.createWithSeed(ProfileType.ORGANIZATION_ADMIN, orgId, [], lockingProfiles);
        const vaultLocks = vaultRepo.getAllVaultsByOrganizationId(orgId).map((v2) => ({
          vaultId: v2.id,
          generationId: v2.generationId,
          lock: protectedSecretRepo.createProfileLock(v2, adminProfile)
        }));
        let adminVaultCreationData;
        if (!ccs.vaultRepo.getOrganizationAdminVaultByOrganizationId(org.id)) {
          const adminVault = UnsyncedVault.create(VaultType.ORGANIZATION_ADMIN, [], [], [], null, adminProfile, org.id, organizationAdminVaultContentDescriptor, null);
          adminVaultCreationData = adminVault.getCreationDto();
        }
        const previousAdminProfile = ccs.profileRepo.getOrgAdminProfile(org.id);
        const syncUpdate = yield ccs.backendClient.organization.regenerateAdmin(orgId, {
          profile: adminProfile.serialize(previousAdminProfile === null || previousAdminProfile === void 0 ? void 0 : previousAdminProfile.profile.id, previousAdminProfile === null || previousAdminProfile === void 0 ? void 0 : previousAdminProfile.profile.keyGenerationId),
          vaultLocks,
          // Organization admin profiles currently never lock any downstream profiles
          downstreamProfileLocks: []
        }, adminVaultCreationData);
        return onlineInternalSync(ccs, syncUpdate);
      }));
    });
  }
  function performWithOrgAllVaultsSyncPredicate(ccs, orgId, operation) {
    var _a3;
    return __awaiter$r(this, void 0, void 0, function* () {
      const originalForeignVaultSyncPredicate = ccs.ephemeralForeignVaultSyncPredicate;
      ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { organizationAllVaults: [
        orgId,
        ...(_a3 = ccs.ephemeralForeignVaultSyncPredicate.organizationAllVaults) !== null && _a3 !== void 0 ? _a3 : []
      ] });
      const originalBackendClient = ccs.backendClient;
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      ccs = yield onlineInternalSync(ccs);
      ccs = yield operation(ccs);
      ccs.syncVersion = null;
      ccs.backendClient = originalBackendClient.withSyncVersion(void 0);
      ccs.ephemeralForeignVaultSyncPredicate = originalForeignVaultSyncPredicate;
      return onlineInternalSync(ccs);
    });
  }
  var __awaiter$q = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$a = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalOrganizationRestoreUnsafeVaultContents(_a3, organizationId) {
    var ccs = __rest$a(_a3, []);
    return __awaiter$q(this, void 0, void 0, function* () {
      const oldEFVSP = ccs.ephemeralForeignVaultSyncPredicate;
      const oldBackendClient = ccs.backendClient;
      ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { organizationAllVaults: [organizationId] });
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      ccs = yield onlineInternalSync(ccs);
      if (!ccs.protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.getOrganization(organizationId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      if (!org.isAdmin || !org.adminInfo) {
        throw new NoOrganizationAdminError();
      }
      if (org.adminInfo.licenseType !== LicenseType.EXAMPLE) {
        throw new Error("Tried to restore organization vault contents for non-example organization. This feature may only be used for demo purposes.");
      }
      let storedVaultContents;
      if (org.adminInfo.legacyAdminVaultId && org.adminInfo.legacyAdminVaultId != nullUuid) {
        const legacyAdminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
        if (!legacyAdminVault) {
          throw new VaultNotFoundError(org.adminInfo.legacyAdminVaultId);
        }
        storedVaultContents = getLegacyOrganizationAdminVaultInfo(legacyAdminVault.getContent()).unsafeStoredVaultContents;
      } else {
        const adminVault = ccs.vaultRepo.getOrganizationAdminVaultByOrganizationId(org.id);
        if (!adminVault) {
          throw new Error("Organization has no admin vault! This should never happen.");
        }
        storedVaultContents = getOrganizationAdminVaultInfo(adminVault.getContent()).unsafeStoredVaultContents;
      }
      for (const [vaultId, storedContent] of Object.entries(storedVaultContents !== null && storedVaultContents !== void 0 ? storedVaultContents : {})) {
        const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
        if (!vault) {
          continue;
        }
        const { protect: protect2 } = ccs.protectedSecretRepo.getProtectedSecretFunctions(vault);
        const storedActiveLoginIds = Object.keys(storedContent.logins);
        const storedArchivedLoginIds = Object.keys(storedContent.archivedLogins);
        const allStoredLoginIds = [...storedActiveLoginIds, ...storedArchivedLoginIds];
        const activeLoginIds = Object.keys(vault.getContent().logins);
        const archivedLoginIds = Object.keys(vault.getArchivedContent().logins);
        const deleteLoginIds = activeLoginIds.filter((lid) => !allStoredLoginIds.includes(lid));
        const deleteArchivedLoginIds = archivedLoginIds.filter((lid) => !allStoredLoginIds.includes(lid));
        const keptArchivedLoginIds = archivedLoginIds.filter((lid) => allStoredLoginIds.includes(lid));
        ccs = modifyLoginVault(ccs, vault, (c2, t2, { deleteLoginInternal: deleteLoginInternal2, restoreArchivedLoginInternal: restoreArchivedLoginInternal2, addOrModifyLoginInternal: addOrModifyLoginInternal2, archiveLoginInternal: archiveLoginInternal2 }) => {
          let newVaultContent = c2;
          for (const lid of [...deleteLoginIds, ...deleteArchivedLoginIds]) {
            ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t2, lid));
          }
          for (const lid of keptArchivedLoginIds) {
            ({ newVaultContent } = restoreArchivedLoginInternal2(newVaultContent, t2, lid));
          }
          for (const [id2, login] of Object.entries(storedContent.logins)) {
            ({ newVaultContent } = addOrModifyLoginInternal2(newVaultContent, t2, id2, recursivelyTransformUnprotectedValues(login, protect2)));
          }
          for (const [id2, login] of Object.entries(storedContent.archivedLogins)) {
            ({ newVaultContent } = addOrModifyLoginInternal2(newVaultContent, t2, id2, recursivelyTransformUnprotectedValues(login, protect2)));
            ({ newVaultContent } = archiveLoginInternal2(newVaultContent, t2, id2));
          }
          return { result: void 0, auditlogEvents: [], newVaultContent };
        });
      }
      ccs = yield onlineInternalSync(ccs);
      ccs.ephemeralForeignVaultSyncPredicate = oldEFVSP;
      ccs.syncVersion = null;
      ccs.backendClient = oldBackendClient.withSyncVersion(void 0);
      return onlineInternalSync(ccs);
    });
  }
  var __awaiter$p = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$9 = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalOrganizationStoreUnsafeVaultContents(_a3, organizationId) {
    var ccs = __rest$9(_a3, []);
    return __awaiter$p(this, void 0, void 0, function* () {
      const oldEFVSP = ccs.ephemeralForeignVaultSyncPredicate;
      const oldBackendClient = ccs.backendClient;
      ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { organizationAllVaults: [organizationId] });
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      ccs = yield onlineInternalSync(ccs);
      if (!ccs.protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.getOrganization(organizationId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      if (!(org === null || org === void 0 ? void 0 : org.isAdmin) || !org.adminInfo) {
        throw new NoOrganizationAdminError();
      }
      if (org.adminInfo.licenseType !== LicenseType.EXAMPLE) {
        throw new Error("Tried to unsafely store organization vault contents for non-example organization. This feature may only be used for demo purposes.");
      }
      const orgLoginVaultPairs = ccs.vaultRepo.getOrganizationLoginVaultPairs(organizationId, {
        includeForeignOrganizationPersonalVaults: true,
        includeForeignTeamVaults: true
      });
      const vaultContents = {};
      for (const { login: loginVault } of orgLoginVaultPairs) {
        const { unprotectWithContentId: unprotectWithContentId2 } = ccs.protectedSecretRepo.getProtectedSecretFunctions(loginVault);
        const logins = {};
        for (const [id2, login] of Object.entries(loginVault.getContent().logins)) {
          logins[id2] = recursivelyTransformProtectedValues(login, unprotectWithContentId2);
        }
        const archivedLogins = {};
        for (const [id2, login] of Object.entries(loginVault.getArchivedContent().logins)) {
          archivedLogins[id2] = recursivelyTransformProtectedValues(login, unprotectWithContentId2);
        }
        vaultContents[loginVault.id] = { logins, archivedLogins };
      }
      if (org.adminInfo.legacyAdminVaultId && org.adminInfo.legacyAdminVaultId != nullUuid) {
        const legacyAdminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
        if (!legacyAdminVault) {
          throw new VaultNotFoundError(org.adminInfo.legacyAdminVaultId);
        }
        ccs = modifyVault(ccs, legacyAdminVault, (c2, t2, { modifyLegacyOrganizationAdminVaultInfo: modifyLegacyOrganizationAdminVaultInfo2 }) => modifyLegacyOrganizationAdminVaultInfo2(c2, t2, {
          unsafeStoredVaultContents: vaultContents
        }));
      } else {
        const adminVault = ccs.vaultRepo.getOrganizationAdminVaultByOrganizationId(org.id);
        if (!adminVault) {
          throw new Error("Organization has no admin vault! This should never happen.");
        }
        ccs = modifyVault(ccs, adminVault, (c2, t2, { modifyOrganizationAdminVaultInfo: modifyOrganizationAdminVaultInfo2 }) => modifyOrganizationAdminVaultInfo2(c2, t2, { unsafeStoredVaultContents: vaultContents }));
      }
      ccs = yield onlineInternalSync(ccs);
      ccs.ephemeralForeignVaultSyncPredicate = oldEFVSP;
      ccs.syncVersion = null;
      ccs.backendClient = oldBackendClient.withSyncVersion(void 0);
      return onlineInternalSync(ccs);
    });
  }
  var __awaiter$o = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$8 = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalProfileCreatePrivate(_a3, email) {
    var ccs = __rest$8(_a3, []);
    return __awaiter$o(this, void 0, void 0, function* () {
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const privateProfile = UnsyncedProfile.create(ProfileType.PRIVATE, null, ccs.accountState.authenticators);
      const privateVault = UnsyncedVault.create(VaultType.PRIVATE, [], [], [], privateProfile, null, null, loginVaultContentDescriptor, null);
      const { privateProfileId, syncUpdate } = yield ccs.backendClient.profile.createPrivate(email, privateProfile.serialize(), privateVault.getCreationDto());
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      ccs = yield onlineInternalSessionSetProfileEnabled(ccs, privateProfileId, true);
      return ccs;
    });
  }
  var __awaiter$n = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$7 = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalProfileDeletePrivate(_a3, privateProfileId) {
    var ccs = __rest$7(_a3, []);
    return __awaiter$n(this, void 0, void 0, function* () {
      const syncUpdate = yield ccs.backendClient.profile.deletePrivate(privateProfileId);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$m = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$6 = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalProfileRegenerate(_a3, hsc) {
    var ccs = __rest$6(_a3, []);
    return __awaiter$m(this, void 0, void 0, function* () {
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const { regeneratedProfiles } = regenerateProfiles(hsc, protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, ccs.accountState.authenticators, []);
      const syncUpdate = yield ccs.backendClient.profile.regenerate(regeneratedProfiles);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  function createUnsyncedRecoveryAuthenticator(seed, recoveryParameters) {
    if (seed.byteLength !== 32) {
      throw new InvalidAuthenticatorSeedLengthError();
    }
    const checksum = naclUtilExports.encodeBase64(hashData(seed));
    const secretInfo = { checksum, recoveryParameters };
    return UnsyncedAuthenticator.create(AuthenticatorType.BACKUP_CODE, JSON.stringify(secretInfo), {
      seed
    });
  }
  function createUnsyncedBackupAuthenticator(seed) {
    if (seed.byteLength !== 32) {
      throw new InvalidAuthenticatorSeedLengthError();
    }
    return UnsyncedAuthenticator.create(AuthenticatorType.BACKUP_OS, "", { seed });
  }
  var __awaiter$l = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$5 = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalRegenerateBackup(_a3, backupAuthSeed, hsc) {
    var ccs = __rest$5(_a3, []);
    return __awaiter$l(this, void 0, void 0, function* () {
      ccs = yield onlineInternalSync(ccs);
      const unsyncedAuthenticator = createUnsyncedBackupAuthenticator(backupAuthSeed);
      const previousAuth = ccs.accountState.authenticators.find((a) => a.authenticatorType === AuthenticatorType.BACKUP_OS);
      const result2 = yield onlineInternalModifyAuthenticators(ccs, hsc, previousAuth ? [previousAuth.id] : [], [unsyncedAuthenticator]);
      if (!result2.returnResult.length) {
        throw new NoAuthenticatorIdReceivedError();
      }
      return Object.assign(Object.assign({}, result2), { returnResult: result2.returnResult[0] });
    });
  }
  var __awaiter$k = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$4 = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  const BACKUP_CODE_PATTERN = /\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d/;
  function onlineInternalRegenerateRecovery(_a3, backupCode, recoverySeed, recoveryParameters, hsc) {
    var ccs = __rest$4(_a3, []);
    return __awaiter$k(this, void 0, void 0, function* () {
      if (!BACKUP_CODE_PATTERN.test(backupCode)) {
        throw new Error("received incorrectly formatted backup code");
      }
      ccs = yield onlineInternalSync(ccs);
      const metaVault = ccs.vaultRepo.getMetaVault();
      if (!metaVault) {
        throw new MetaVaultNotFoundError();
      }
      ccs = modifyVault(ccs, metaVault, (c2, t2, { protect: protect2, modifyAccountSettings: modifyAccountSettings2 }) => modifyAccountSettings2(c2, t2, {
        backupCode: protect2({ contentId: newUuid$1(), unencrypted: backupCode })
      }), true, hsc);
      ccs.accountState = ccs.accountState.withLocalAchievements([
        Achievement.COR_STORE_BACKUP_CODE_META_VAULT
      ]);
      const unsyncedAuthenticator = createUnsyncedRecoveryAuthenticator(recoverySeed, recoveryParameters);
      const previousAuth = ccs.accountState.authenticators.find((a) => a.authenticatorType === AuthenticatorType.BACKUP_CODE);
      const result2 = yield onlineInternalModifyAuthenticators(ccs, hsc, previousAuth ? [previousAuth.id] : [], [unsyncedAuthenticator]);
      if (!result2.returnResult.length) {
        throw new NoAuthenticatorIdReceivedError();
      }
      return Object.assign(Object.assign({}, result2), { returnResult: result2.returnResult[0] });
    });
  }
  var __awaiter$j = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalRegenerateVault(ccs, hsc, vaultId) {
    return __awaiter$j(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getVaultById(vaultId);
      const vaultAccess = getVaultAccess(ccs, hsc, vault);
      if (!vaultAccess) {
        throw new ClientCoreIsLockedError();
      }
      const regeneratedVault = yield onlineInternalCreateRegeneratedVault(ccs, vault, vaultAccess);
      const backendClient = getBackendClientForVault(ccs, vault);
      const { syncUpdate } = yield backendClient.vault.createGeneration(regeneratedVault);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$i = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$3 = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalTeamCreate(_a3, name, organizationId) {
    var _b, _c2, _d, _e;
    var ccs = __rest$3(_a3, []);
    return __awaiter$i(this, void 0, void 0, function* () {
      const profile = organizationId ? (_b = ccs.profileRepo.getOrganizationProfile(organizationId)) === null || _b === void 0 ? void 0 : _b.profile : (_c2 = ccs.profileRepo.getPrivateProfile()) === null || _c2 === void 0 ? void 0 : _c2.profile;
      if (!profile) {
        throw new ClientCoreInternalError("no organization or private profile found to create team");
      }
      const { unsyncedTeamVault, unsyncedTeamMetaVault } = yield onlineInternalMakeUnsyncedTeamVaults(ccs, name, organizationId, profile, false);
      const { vaultId: teamVaultId, associatedVaultId: teamMetaVaultId, syncUpdate } = yield ccs.backendClient.vault.createTeam({
        blob: unsyncedTeamVault.getCommitBlob(),
        locks: unsyncedTeamVault.getAuthenticatorLockDtos(),
        profileLock: unsyncedTeamVault.getProfileLockDto(),
        adminProfileLock: unsyncedTeamVault.getAdminProfileLockDto(),
        messagePublicKey: (_d = unsyncedTeamVault.messageKeyPair) === null || _d === void 0 ? void 0 : _d.encPubKey,
        associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
        associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
        associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
        associatedAdminProfileLock: unsyncedTeamMetaVault.getAdminProfileLockDto(),
        associatedMessagePublicKey: (_e = unsyncedTeamMetaVault.messageKeyPair) === null || _e === void 0 ? void 0 : _e.encPubKey,
        organizationId
      });
      ccs = addUnsyncedVaultAfterCreate(ccs, syncUpdate, teamVaultId, teamMetaVaultId, organizationId !== null && organizationId !== void 0 ? organizationId : null, unsyncedTeamVault);
      ccs = addUnsyncedVaultAfterCreate(
        ccs,
        syncUpdate,
        // if we pass in an unsynced associated vault, we're also going to get back an id for it
        teamMetaVaultId,
        null,
        organizationId !== null && organizationId !== void 0 ? organizationId : null,
        unsyncedTeamMetaVault
      );
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      return Object.assign(Object.assign({}, ccs), { returnResult: teamVaultId });
    });
  }
  var __awaiter$h = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$2 = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function onlineInternalTeamDelete(_a3, vaultId) {
    var ccs = __rest$2(_a3, []);
    return __awaiter$h(this, void 0, void 0, function* () {
      const pair = ccs.vaultRepo.getTeamVaultPairById(vaultId);
      if (!pair) {
        throw new VaultNotFoundError(vaultId);
      }
      if (getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta) !== PermissionLevel.admin) {
        throw new VaultPermissionDeniedError();
      }
      const { syncUpdate } = yield ccs.backendClient.vault.deleteTeam(vaultId);
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      ccs = yield onlineInternalMaintainVaultMessages(ccs);
      return Object.assign({}, ccs);
    });
  }
  var __awaiter$g = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalTeamLeave(ccs, teamId) {
    return __awaiter$g(this, void 0, void 0, function* () {
      const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
      if (!pair) {
        throw new VaultNotFoundError(teamId);
      }
      const { login, meta } = pair;
      const joinedProfileId = login.getProfileId();
      if (!joinedProfileId) {
        throw new VaultNotFoundError(teamId);
      }
      const commitData = getUpdatedMetaVault(meta, joinedProfileId);
      const { syncUpdate } = yield ccs.backendClient.vault.modifyTeamUsers(teamId, login.generationId, [], joinedProfileId ? [joinedProfileId] : [], meta.generationId, commitData === null || commitData === void 0 ? void 0 : commitData.metaVaultCommitId, commitData === null || commitData === void 0 ? void 0 : commitData.blob, commitData === null || commitData === void 0 ? void 0 : commitData.latestUpdateTime);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  function getUpdatedMetaVault(metaVault, removeProfileId) {
    ({ vault: metaVault } = metaVault.withModification((c2, t2, { deleteTeamVaultUser: deleteTeamVaultUser2 }) => deleteTeamVaultUser2(c2, t2, removeProfileId)));
    const stagedData = metaVault.getStagedDiff(null);
    if (!stagedData) {
      return null;
    }
    const { stagingVault, diff, latestUpdateTime } = stagedData;
    const protoCommit = Commit.create(null, stagingVault.vaultSecret, diff);
    return {
      metaVaultCommitId: metaVault.commitId,
      blob: protoCommit.blob,
      latestUpdateTime: new Date(latestUpdateTime)
    };
  }
  var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalWebauthnDeleteCredentials(ccs, ids) {
    return __awaiter$f(this, void 0, void 0, function* () {
      const syncUpdate = yield ccs.backendClient.webauthn.deleteCredentials(ids);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalWebauthnEnablePrf(ccs, { options }, cred) {
    var _a3, _b, _c2, _d;
    return __awaiter$e(this, void 0, void 0, function* () {
      if (!cred.prfExtensionResult) {
        throw new PrfNotSupportedError();
      }
      const syncUpdate = yield ccs.backendClient.sync.poll();
      if (!syncUpdate.sessionUnlock) {
        throw new ClientCoreIsLockedError();
      }
      const seed = deriveSecretFromSeed(new Uint8Array(cred.prfExtensionResult.first), null, SALT_AUTHENTICATOR_WEBAUTHN_SEED);
      const webauthnCred = ccs.accountState.webauthnCredentials.find((wc2) => cred.id === wc2.webauthnId);
      if (!webauthnCred) {
        throw new PrfInitError();
      }
      const prfInputs = (_b = (_a3 = options.publicKey) === null || _a3 === void 0 ? void 0 : _a3.extensions) === null || _b === void 0 ? void 0 : _b.prf;
      const prfSalt = (_d = (_c2 = prfInputs === null || prfInputs === void 0 ? void 0 : prfInputs.evalByCredential) === null || _c2 === void 0 ? void 0 : _c2[cred.id]) === null || _d === void 0 ? void 0 : _d.first;
      if (!prfSalt) {
        throw new PrfInitError();
      }
      const ua2 = UnsyncedAuthenticator.createWebauthn({ seed }, { webauthnId: webauthnCred.webauthnId, prfSalt: new Uint8Array(prfSalt) });
      const hsc = HighSecurityCache.fromSessionUnlock(syncUpdate.sessionUnlock, ccs.params.sessionKeys.encPrivKey, ccs.accountState.authenticators);
      return onlineInternalModifyAuthenticators(ccs, hsc, [], [ua2]);
    });
  }
  function unmarshalCredentialCreationOptions(optionsJson) {
    const options = JSON.parse(optionsJson);
    options.publicKey.challenge = decodeBase64Urlsafe(options.publicKey.challenge);
    options.publicKey.user.id = decodeBase64Urlsafe(options.publicKey.user.id);
    if (options.publicKey.excludeCredentials) {
      options.publicKey.excludeCredentials.forEach((cred) => {
        cred.id = decodeBase64Urlsafe(cred.id);
      });
    }
    return options;
  }
  function unmarshalCredentialRequestOptions(optionsJson) {
    const options = JSON.parse(optionsJson);
    options.publicKey.challenge = decodeBase64Urlsafe(options.publicKey.challenge);
    options.publicKey.allowCredentials.forEach((cred) => {
      cred.id = decodeBase64Urlsafe(cred.id);
    });
    return options;
  }
  function marshalAssertionPublicKeyCredential(cred) {
    return JSON.stringify({
      id: cred.id,
      rawId: encodeBase64Urlsafe(cred.rawId),
      type: "public-key",
      response: {
        authenticatorData: encodeBase64Urlsafe(cred.response.authenticatorData),
        clientDataJSON: encodeBase64Urlsafe(cred.response.clientDataJSON),
        signature: encodeBase64Urlsafe(cred.response.signature),
        userHandle: cred.response.userHandle ? encodeBase64Urlsafe(cred.response.userHandle) : void 0
      }
    });
  }
  var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalWebauthnRegisterCredentialInit(ccs, type) {
    return __awaiter$d(this, void 0, void 0, function* () {
      const { requestId, optionsJson } = yield ccs.backendClient.webauthn.registerCredentialInit(type);
      const options = unmarshalCredentialCreationOptions(optionsJson);
      const prfSalt = { first: randomSeed() };
      options.publicKey.extensions = Object.assign(Object.assign({}, options.publicKey.extensions), { prf: { eval: prfSalt } });
      debugConsole.info("webauthn.create options", options);
      return Object.assign(Object.assign({}, ccs), { returnResult: { requestId, options, prfSalt } });
    });
  }
  function onlineInternalWebauthnRegisterCredentialFinish(ccs, requestId, cred) {
    return __awaiter$d(this, void 0, void 0, function* () {
      const credJson = marshalAttestationPublicKeyCredential(cred);
      const su2 = yield ccs.backendClient.webauthn.registerCredentialFinish(requestId, credJson, cred.prfSupportStatus);
      return onlineInternalSync(ccs, su2);
    });
  }
  function marshalAttestationPublicKeyCredential(cred) {
    return JSON.stringify({
      id: cred.id,
      rawId: encodeBase64Urlsafe(cred.rawId),
      type: "public-key",
      response: {
        attestationObject: encodeBase64Urlsafe(cred.response.attestationObject),
        clientDataJSON: encodeBase64Urlsafe(cred.response.clientDataJSON),
        transports: cred.response.transports
      }
    });
  }
  function getUnlockTime() {
    const date2 = new Date((/* @__PURE__ */ new Date()).getTime() + 864e5);
    date2.setHours(2, 0, 0, 0);
    return date2;
  }
  var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalWebauthnUnlockSessionInit(ccs) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const { requestId, optionsJson } = yield ccs.backendClient.webauthn.unlockSessionInit();
      const options = unmarshalCredentialRequestOptions(optionsJson);
      const evalByCredential = {};
      for (const a of options.publicKey.allowCredentials) {
        evalByCredential[encodeBase64Urlsafe(a.id)] = {
          first: randomSeed()
        };
      }
      options.publicKey.extensions = Object.assign(Object.assign({}, options.publicKey.extensions), { prf: { evalByCredential } });
      debugConsole.info("webauthn.get options", options);
      return Object.assign(Object.assign({}, ccs), { returnResult: { requestId, options } });
    });
  }
  function onlineInternalWebauthnUnlockSessionFinish(ccs, requestId, cred) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const responseJson = marshalAssertionPublicKeyCredential(cred);
      const syncUpdate = yield ccs.backendClient.webauthn.unlockSessionFinish(requestId, responseJson, getUnlockTime());
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  function completeLongPollChannelReply(publicKeyB64, authenticatorSeed, registration) {
    const publicKey = loadEncryptionPublicKey(publicKeyB64);
    const publicKeyHash = naclUtilExports.encodeBase64(hashData(publicKey));
    const authReply = createEncryptedSecretAuthenticatorReply({
      encryptedSecret: asymEncrypt(publicKey, authenticatorSeed),
      registration
    });
    return { publicKeyHash, authReply };
  }
  const SALT_SESSION_ENCRYPTION_KEY = "salt-session-encryption-key-";
  const SALT_SESSION_ENCRYPTION_KEY_SIGNATURE$1 = "salt-session-encryption-key-signature-";
  function createUnsignedSessionKeys() {
    const secret = randomSeed();
    return deriveEncryptionKeyPair(secret, null, SALT_SESSION_ENCRYPTION_KEY);
  }
  class SessionKeys {
    constructor(encPrivKey, encPubKey, encPubKeySignature, signingAuthId) {
      this.encPrivKey = encPrivKey;
      this.encPubKey = encPubKey;
      this.encPubKeySignature = encPubKeySignature;
      this.signingAuthId = signingAuthId;
    }
    static createFromUnsigned(usk, ua2) {
      const { encPrivKey, encPubKey } = usk;
      const encPubKeySignature = signEncryptionPublicKey(ua2.highSecurityIdentitySigPrivKey, encPubKey, SALT_SESSION_ENCRYPTION_KEY_SIGNATURE$1);
      return new SessionKeys(encPrivKey, encPubKey, encPubKeySignature, ua2.authenticator.id);
    }
    static create(ua2) {
      return SessionKeys.createFromUnsigned(createUnsignedSessionKeys(), ua2);
    }
  }
  var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function finishChallengeSelfUnlocking({ client, hsua, challenge, userId, sessionType }) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const unsignedSessionKeys = createUnsignedSessionKeys();
      const response = signString(hsua.highSecurityLoginSigPrivKey, challenge, null);
      const { loginData } = yield client.credential.createTokens(userId, hsua.authenticator.id, challenge, response, null, sessionType);
      const { authenticators } = yield client.withLogin(loginData).authenticator.list();
      const authenticatorDto = authenticators.find((a) => a.id === hsua.authenticator.id);
      if (!authenticatorDto) {
        throw new AuthenticatorNotFoundError();
      }
      const sessionKeys = SessionKeys.createFromUnsigned(unsignedSessionKeys, hsua);
      const clientCoreParameters = {
        loginData,
        unlockedAuthenticator: hsua.getUnlockedAuthenticator(),
        sessionKeys
      };
      return clientCoreParameters;
    });
  }
  var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class LoginFlowPushAuthenticator {
    constructor(channelId, authenticatorId, backend, sharedSecret, isCancelled = false) {
      this.channelId = channelId;
      this.authenticatorId = authenticatorId;
      this.backend = backend;
      this.sharedSecret = sharedSecret;
      this.isCancelled = isCancelled;
    }
    static create(channelId, authenticatorId, backend) {
      return __awaiter$a(this, void 0, void 0, function* () {
        const keyPair = newSharedSecretKeyPair();
        const hashCommitment = yield backend.channel.loginChannelClaimAndReceiveHashCommitment(channelId, authenticatorId, keyPair.sharedPubKey);
        const clientPubKey = yield backend.channel.loginChannelReceiveClientPubKey(channelId);
        if (!verifyHash(hashCommitment, clientPubKey)) {
          throw new InvalidHashCommitmentError();
        }
        const sharedSecret = combineSharedSecret(keyPair.sharedPrivKey, clientPubKey, "push-login");
        const flow = new LoginFlowPushAuthenticator(channelId, authenticatorId, backend, sharedSecret);
        return flow;
      });
    }
    cancel() {
      return __awaiter$a(this, void 0, void 0, function* () {
        yield this.backend.channel.loginChannelClose(this.channelId);
        this.isCancelled = true;
      });
    }
    getSas() {
      if (this.isCancelled) {
        throw new LoginCancelledError();
      }
      return symKeyToSas(this.sharedSecret);
    }
    sendEncryptedSecret(secret) {
      return __awaiter$a(this, void 0, void 0, function* () {
        if (this.isCancelled) {
          throw new LoginCancelledError();
        }
        const encryptedSecret = symEncrypt(this.sharedSecret, secret);
        yield this.backend.channel.loginChannelSendEncryptedSecret(this.channelId, encryptedSecret, this.authenticatorId);
      });
    }
    waitForClose() {
      return __awaiter$a(this, void 0, void 0, function* () {
        yield this.backend.channel.loginChannelWaitUntilClosed(this.channelId);
      });
    }
  }
  function checkEncPubKeySignature(trustedSigPubKeys, encPubKey, encPubKeySignature, salt) {
    if (!trustedSigPubKeys.some((sigPubKey) => verifySignedEncryptionPublicKey(sigPubKey, encPubKey, loadEncryptionPublicKeySignature(encPubKeySignature), salt))) {
      throw new NoMatchingSigningKeyFoundError();
    }
  }
  class OrganizationAuthTokenCache {
    constructor(cache2 = {}) {
      this.cache = cache2;
    }
    isEmpty() {
      return Object.values(this.cache).length === 0;
    }
    getToken(orgId) {
      const entry = this.cache[orgId];
      if (!entry || entry.expiresAt < /* @__PURE__ */ new Date()) {
        return null;
      }
      return entry.token;
    }
    withToken(orgId, token, expiresAt) {
      return new OrganizationAuthTokenCache(Object.assign(Object.assign({}, this.cache), { [orgId]: { expiresAt, token } }));
    }
  }
  var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$1 = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  function mergeLoginWebsites(websites, websiteAttributes, unnormalizedWebsite) {
    const normalizedWebsite = normalizeWebsitePattern(unnormalizedWebsite);
    const websiteHost = new URL(`https://${unnormalizedWebsite}`).host;
    if (websites.find((w2) => new URL(`https://${w2}`).host === websiteHost)) {
      return { websites, websiteAttributes };
    }
    return {
      websites: [...websites, normalizedWebsite],
      websiteAttributes: Object.assign(Object.assign({}, websiteAttributes), { [normalizedWebsite]: Object.assign(Object.assign({}, websiteAttributes === null || websiteAttributes === void 0 ? void 0 : websiteAttributes[normalizedWebsite]), getWebsiteAttributesEntry(unnormalizedWebsite)) })
    };
  }
  function mergeLoginAndroidApps(androidApps, androidApp) {
    const androidAppWithId = Object.assign({ id: newUuid$1() }, androidApp);
    if (!androidApps) {
      return androidApp ? [androidAppWithId] : [];
    }
    const existingAppIndex = androidApps.findIndex((a) => a.appId === androidApp.appId);
    if (existingAppIndex === -1) {
      return [...androidApps, androidAppWithId];
    }
    return [
      ...androidApps.slice(0, existingAppIndex),
      Object.assign(Object.assign({}, androidApps[existingAppIndex]), androidAppWithId),
      ...androidApps.slice(existingAppIndex + 1)
    ];
  }
  function ingestLoginUpdate(_a3, _b) {
    var ccs = __rest$1(_a3, []);
    var loginId = _b.loginId, vaultId = _b.vaultId, username = _b.username, password = _b.password, unnormalizedWebsite = _b.unnormalizedWebsite, androidApp = _b.androidApp;
    return __awaiter$9(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const existing = loginId ? vault.getContent().logins[loginId] : void 0;
      const unprotectedPassword = { contentId: newUuid$1(), unencrypted: password };
      if (loginId && existing) {
        const oldPassword = protectedSecretRepo.unprotectWithContentId(vault, existing.password);
        const newPassword = oldPassword.unencrypted === password ? oldPassword : unprotectedPassword;
        let modifiedLogin = {
          username: username !== null && username !== void 0 ? username : "",
          password: newPassword
        };
        if (unnormalizedWebsite) {
          modifiedLogin = Object.assign(Object.assign({}, modifiedLogin), mergeLoginWebsites(existing.websites, existing.websiteAttributes, unnormalizedWebsite.uri));
        }
        if (androidApp) {
          modifiedLogin = Object.assign(Object.assign({}, modifiedLogin), { androidApps: mergeLoginAndroidApps(existing.androidApps, androidApp) });
        }
        return Object.assign(Object.assign({}, yield modifyLogin(ccs, {
          vaultId,
          loginId,
          login: modifiedLogin,
          source: LoginSource.autosave
        })), { returnResult: loginId });
      }
      let websites = [];
      let websiteAttributes = {};
      if (unnormalizedWebsite === null || unnormalizedWebsite === void 0 ? void 0 : unnormalizedWebsite.uri) {
        const website = normalizeWebsitePattern(unnormalizedWebsite.uri);
        websiteAttributes = { [website]: getWebsiteAttributesEntry(unnormalizedWebsite === null || unnormalizedWebsite === void 0 ? void 0 : unnormalizedWebsite.uri) };
        websites = [website];
      }
      const androidApps = androidApp ? [Object.assign({ id: newUuid$1() }, androidApp)] : [];
      return addLogin(ccs, {
        vaultId,
        login: {
          uiType: LoginUiType.login,
          title: "",
          websites,
          websiteAttributes,
          androidApps,
          username: username !== null && username !== void 0 ? username : "",
          password: unprotectedPassword,
          note: "",
          customFields: []
        },
        source: LoginSource.autosave
      });
    });
  }
  class VaultRepo {
    constructor(vaults = []) {
      this.vaults = vaults;
    }
    static create(vaults = []) {
      return new VaultRepo(vaults);
    }
    static createFromPersistable(p2, profileRepo, superUserUnlockedAuthenticators = {}) {
      const vaults = p2.vaults.flatMap((pv) => {
        let vaultAccess = getDirectVaultAccess(profileRepo, null, pv);
        if (!vaultAccess && pv.organizationId && pv.adminProfileLock) {
          const unlockedProfile = profileRepo.getOrgAdminProfile(pv.organizationId);
          if (unlockedProfile) {
            vaultAccess = {
              type: "admin-profile",
              unlockedProfile,
              hsup: null,
              orgId: pv.organizationId
            };
          }
        }
        if (!vaultAccess && pv.organizationId && superUserUnlockedAuthenticators[pv.organizationId]) {
          vaultAccess = {
            type: "admin-authenticator",
            unlockedAuthenticator: superUserUnlockedAuthenticators[pv.organizationId],
            hsua: null,
            orgId: pv.organizationId
          };
        }
        if (!vaultAccess) {
          trackError(new Error(`Ignoring vault ${pv.id} from persistable. There is no matching unlocked authenticator.`));
          return [];
        }
        return [Vault.createFromPersistable(pv, vaultAccess)];
      });
      return new VaultRepo(vaults);
    }
    isInitialized() {
      const metaVault = this.getVaultByQuery({ descriptor: metaVaultContentDescriptor });
      return !!metaVault;
    }
    getPersistable(foreignVaultSyncPredicate) {
      return {
        vaults: this.vaults.flatMap((vault) => {
          const shouldPersistVault = vault.isUserJoined || checkForeignVaultSyncPredicate({ type: "vault", vault }, foreignVaultSyncPredicate);
          if (!shouldPersistVault) {
            return [];
          }
          return vault.getPersistable();
        })
      };
    }
    getAllVaults() {
      return this.vaults;
    }
    getAllVaultsByOrganizationId(organizationId) {
      return this.filterVaultsByQuery({ organizationId });
    }
    getForeignVaultsByOrganizationId(organizationId) {
      return this.filterVaultsByQuery({ organizationId, isUserJoined: false });
    }
    getAllVaultsByProfileId(profileId) {
      return this.filterVaultsByQuery({ profileId });
    }
    getVaultById(vaultId) {
      const vault = this.vaults.find((v2) => v2.id === vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      return vault;
    }
    vaultExits(vaultId) {
      return this.vaults.some((v2) => v2.id === vaultId);
    }
    getPrivateLoginVault() {
      const privateLoginVault = this.getVaultByQuery({
        descriptor: loginVaultContentDescriptor,
        vaultTypes: [VaultType.PRIVATE],
        isUserJoined: true
      });
      return privateLoginVault !== null && privateLoginVault !== void 0 ? privateLoginVault : null;
    }
    getPrivateLoginVaultPairs(excludeOrganizationIds) {
      return this.filterVaultsByQuery({
        descriptor: loginVaultContentDescriptor,
        isUserJoined: true,
        vaultTypes: [VaultType.PRIVATE, VaultType.TEAM]
      }).flatMap((l2) => {
        if (l2.organizationId && excludeOrganizationIds.includes(l2.organizationId)) {
          return [];
        }
        const pair = this.makeLoginVaultPair(l2);
        if (!pair) {
          return [];
        }
        return pair;
      });
    }
    getMetaVault() {
      return this.getVaultByQuery({
        descriptor: metaVaultContentDescriptor,
        isUserJoined: true
      });
    }
    getTeamVaultPairs() {
      return this.getTeamVaultPairsByQuery({
        isUserJoined: true
      });
    }
    getOrganizationTeamVaultPairs(organizationId) {
      return this.getTeamVaultPairsByQuery({ organizationId });
    }
    getOrganizationLoginVaultPairs(organizationId, { includeForeignOrganizationPersonalVaults = false, includeForeignTeamVaults = false } = {}) {
      return this.filterVaultsByQuery({
        descriptor: loginVaultContentDescriptor,
        isUserJoined: includeForeignTeamVaults ? void 0 : true,
        organizationId
      }, {
        descriptor: organizationPersonalVaultContentDescriptor,
        isUserJoined: includeForeignOrganizationPersonalVaults ? void 0 : true,
        organizationId
      }).flatMap((l2) => {
        const pair = this.makeLoginVaultPair(l2);
        if (!pair) {
          return [];
        }
        return pair;
      });
    }
    getLoginVaultPairs({ includeForeignOrganizationPersonalVaults = false, includeForeignTeamVaults = false } = {}) {
      return this.filterVaultsByQuery({
        descriptor: loginVaultContentDescriptor,
        isUserJoined: includeForeignTeamVaults ? void 0 : true
      }, {
        descriptor: organizationPersonalVaultContentDescriptor,
        isUserJoined: includeForeignOrganizationPersonalVaults ? void 0 : true
      }).flatMap((l2) => {
        const pair = this.makeLoginVaultPair(l2);
        if (!pair) {
          return [];
        }
        return pair;
      });
    }
    getTeamVaultPairById(vaultId) {
      const login = this.getLoginVaultById(vaultId);
      if (!login) {
        return null;
      }
      const meta = this.getTeamMetaVaultForTeamVault(login);
      if (!meta) {
        return null;
      }
      return { login, meta, type: VaultType.TEAM };
    }
    getLoginVaultById(vaultId) {
      return this.getVaultByQuery({ vaultId, descriptor: loginVaultContentDescriptor }, { vaultId, descriptor: organizationPersonalVaultContentDescriptor });
    }
    getLoginVaultPairById(vaultId) {
      const loginVault = this.getVaultByQuery({ vaultId, descriptor: loginVaultContentDescriptor }, { vaultId, descriptor: organizationPersonalVaultContentDescriptor });
      if (!loginVault) {
        return null;
      }
      return this.makeLoginVaultPair(loginVault);
    }
    getTeamMetaVaultById(vaultId) {
      return this.getVaultByQuery({
        vaultId,
        descriptor: teamMetaVaultContentDescriptor
      });
    }
    getLegacyOrganizationAdminVaults() {
      return this.filterVaultsByQuery({
        descriptor: legacyOrganizationAdminVaultContentDescriptor
      });
    }
    getLegacyOrganizationAdminVaultById(vaultId) {
      return this.getVaultByQuery({
        vaultId,
        descriptor: legacyOrganizationAdminVaultContentDescriptor
      });
    }
    getOrganizationAdminVaultByOrganizationId(organizationId) {
      return this.getVaultByQuery({
        organizationId,
        descriptor: organizationAdminVaultContentDescriptor
      });
    }
    getOrganizationPersonalLoginVault(organizationId) {
      return this.getVaultByQuery({
        organizationId,
        descriptor: organizationPersonalVaultContentDescriptor,
        isUserJoined: true
      });
    }
    getOrganizationAllPersonalLoginVaults(organizationId) {
      return this.filterVaultsByQuery({
        organizationId,
        descriptor: organizationPersonalVaultContentDescriptor
      });
    }
    getOrganizationPersonalLoginVaults() {
      return this.filterVaultsByQuery({
        descriptor: organizationPersonalVaultContentDescriptor,
        isUserJoined: true
      });
    }
    getOrganizationPersonalLoginVaultForUser(organizationId, userId) {
      return this.getVaultByQuery({
        organizationId,
        descriptor: organizationPersonalVaultContentDescriptor,
        userId
      });
    }
    getOrganizationPersonalLoginVaultForProfile(organizationId, profileId) {
      return this.getVaultByQuery({
        organizationId,
        descriptor: organizationPersonalVaultContentDescriptor,
        profileId
      });
    }
    getInboxVaults() {
      return this.filterVaultsByQuery({ vaultTypes: [VaultType.INBOX] });
    }
    getInboxVaultPairById(vaultId) {
      const login = this.getLoginVaultById(vaultId);
      if (!login) {
        return null;
      }
      const meta = this.getTeamMetaVaultForTeamVault(login);
      if (!meta) {
        return null;
      }
      return { login, meta, type: VaultType.INBOX };
    }
    withDeleteVault(vaultId) {
      const modifiedVaults = this.vaults.filter((vault) => !uuidEqual(vault.id, vaultId));
      if (modifiedVaults.length === this.vaults.length) {
        throw new VaultNotFoundError(vaultId);
      }
      return new VaultRepo(modifiedVaults);
    }
    withDeleteWithoutMatchingProfileLocks(profileIds) {
      const modifiedVaults = this.vaults.filter((vault) => {
        return !vault.profileLock || profileIds.includes(vault.profileLock.lockingProfileId);
      });
      if (modifiedVaults.length === this.vaults.length) {
        return this;
      }
      return new VaultRepo(modifiedVaults);
    }
    withUpdateVaults(...updatedVaults) {
      const vaults = [...this.vaults];
      for (const updatedVault of updatedVaults) {
        const i2 = vaults.findIndex((vault) => uuidEqual(vault.id, updatedVault.id));
        if (i2 >= 0) {
          vaults[i2] = updatedVault;
        } else {
          vaults.push(updatedVault);
        }
      }
      return new VaultRepo(vaults);
    }
    getVaultByQuery(...queries) {
      const vault = this.vaults.find(makeVaultPredicate(queries));
      return vault !== null && vault !== void 0 ? vault : null;
    }
    filterVaultsByQuery(...queries) {
      const vaults = this.vaults.filter(makeVaultPredicate(queries));
      return vaults !== null && vaults !== void 0 ? vaults : null;
    }
    getTeamVaultPairsByQuery(query) {
      return this.filterVaultsByQuery(Object.assign({ descriptor: loginVaultContentDescriptor, vaultTypes: [VaultType.TEAM] }, query)).flatMap((vault) => {
        const meta = this.getTeamMetaVaultForTeamVault(vault);
        if (!meta) {
          return [];
        }
        return {
          login: vault,
          meta,
          type: VaultType.TEAM
        };
      });
    }
    makeLoginVaultPair(login) {
      if (login.type === VaultType.TEAM) {
        const meta = this.getTeamMetaVaultForTeamVault(login);
        if (!meta) {
          return null;
        }
        return {
          type: VaultType.TEAM,
          login,
          meta
        };
      }
      if (login.type === VaultType.PRIVATE) {
        return {
          type: login.type,
          login
        };
      }
      if (login.type === VaultType.INBOX) {
        const meta = this.getTeamMetaVaultForTeamVault(login);
        if (!meta) {
          return null;
        }
        return {
          meta,
          type: login.type,
          login
        };
      }
      if (login.type === VaultType.ORGANIZATION_PERSONAL) {
        return {
          type: login.type,
          login
        };
      }
      throw new UnsupportedLoginVaultTypeError();
    }
    getTeamMetaVaultForTeamVault(loginVault) {
      if (![VaultType.TEAM, VaultType.INBOX].some((t2) => loginVault.type === t2)) {
        throw new IncorrectVaultTypeError(loginVault.id, VaultType.TEAM, loginVault.type);
      }
      if (!loginVault.associatedVaultId) {
        throw new TeamVaultMissingAssociatedMetaVaultError(loginVault.id);
      }
      return this.getTeamMetaVaultById(loginVault.associatedVaultId);
    }
  }
  function makeVaultPredicate(queries) {
    return (v2) => {
      return queries.some(({ descriptor, vaultId, organizationId, vaultTypes, userId, profileId, isUserJoined }) => (!descriptor || descriptor.vaultTypes.includes(v2.type) && descriptor.contentTypeName === v2.getContentType()) && (!vaultId || uuidEqual(v2.id, vaultId)) && (!organizationId || v2.organizationId === organizationId) && (!vaultTypes || vaultTypes.includes(v2.type)) && (!userId || v2.userIds.includes(userId)) && (!profileId || v2.profileIds.includes(profileId)) && (isUserJoined === void 0 || v2.isUserJoined == isUserJoined));
    };
  }
  var __decorate$2 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest = globalThis && globalThis.__rest || function(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  var ClientCore_1;
  const SALT_SESSION_ENCRYPTION_KEY_SIGNATURE = "salt-session-encryption-key-signature-";
  let ClientCore = ClientCore_1 = class ClientCore {
    constructor(vaultRepo, profileRepo, backendClient, params, accountState, pinnedAuthenticatorSecret, syncVersion = null, tokenRefreshNeeded = false, superUserUnlockedAuthenticators = {}, foreignVaultSyncPredicate = {}, ephemeralForeignVaultSyncPredicate = {}, ignoredUnlock = null, lastKnownServerTime = null, clientServerTimeOffsetMs = null, auditlogEventQueue = [], auditlogWriteTokenCache = new OrganizationAuthTokenCache(), clientOutdated = false) {
      this.vaultRepo = vaultRepo;
      this.profileRepo = profileRepo;
      this.backendClient = backendClient;
      this.params = params;
      this.accountState = accountState;
      this.pinnedAuthenticatorSecret = pinnedAuthenticatorSecret;
      this.syncVersion = syncVersion;
      this.tokenRefreshNeeded = tokenRefreshNeeded;
      this.superUserUnlockedAuthenticators = superUserUnlockedAuthenticators;
      this.foreignVaultSyncPredicate = foreignVaultSyncPredicate;
      this.ephemeralForeignVaultSyncPredicate = ephemeralForeignVaultSyncPredicate;
      this.ignoredUnlock = ignoredUnlock;
      this.lastKnownServerTime = lastKnownServerTime;
      this.clientServerTimeOffsetMs = clientServerTimeOffsetMs;
      this.auditlogEventQueue = auditlogEventQueue;
      this.auditlogWriteTokenCache = auditlogWriteTokenCache;
      this.clientOutdated = clientOutdated;
      this.mutex = new Mutex();
      this.protectedSecretRepo = null;
      this.maintenanceSettings = null;
      if (pinnedAuthenticatorSecret) {
        const hsc = HighSecurityCache.fromSecret(pinnedAuthenticatorSecret, params.unlockedAuthenticator.authenticator);
        this.protectedSecretRepo = ProtectedSecretRepo.create(this.getClientCoreState(), hsc, null);
      }
    }
    static onlineLoad(clientCoreParameters, backendClient, pcc, pinnedAuthenticatorSecret) {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (!pcc) {
          return this.onlineLoadWithClientCoreParameters(clientCoreParameters, backendClient, pinnedAuthenticatorSecret);
        }
        try {
          return this.createFromPersistable(clientCoreParameters, backendClient, pcc, pinnedAuthenticatorSecret);
        } catch (e2) {
          trackError(e2);
          return this.onlineLoadWithClientCoreParameters(clientCoreParameters, backendClient, pinnedAuthenticatorSecret);
        }
      });
    }
    static onlineInitializeFromLogin(clientCoreParameters, backendClient, syncUpdate, authenticatorSecret, customSessionData) {
      return __awaiter$8(this, void 0, void 0, function* () {
        const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
        const { userId } = clientCoreParameters.loginData;
        const authListDto = yield authorizedBackendClient.authenticator.list();
        const accountState = AccountState.fromSyncUpdate(userId, syncUpdate).withAuthenticatorList(authListDto);
        const vaultRepo = VaultRepo.create();
        const profileRepo = ProfileRepo.create([], []);
        const clientCore = new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, authenticatorSecret);
        yield clientCore.onlineEnsureSessionMetaUpToDate((_2, others) => customSessionData ? customSessionData(others) : {}, syncUpdate);
        return clientCore;
      });
    }
    static createFromPersistable(clientCoreParameters, backendClient, pcc, pinnedAuthenticatorSecret) {
      var _a3, _b;
      if (clientCoreParameters.unlockedAuthenticator.authenticator.authenticatorType === AuthenticatorType.BACKUP_CODE) {
        throw new LoginWithRecoveryError();
      }
      const accountState = AccountState.fromPersistable(pcc.accountState);
      if (accountState.userId !== clientCoreParameters.loginData.userId) {
        throw new PersistableMismatchError(accountState.userId, clientCoreParameters.loginData.userId);
      }
      const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
      const profileRepo = ProfileRepo.createFromPersistable(pcc.profileRepo, clientCoreParameters.unlockedAuthenticator);
      const vaultRepo = VaultRepo.createFromPersistable(pcc.vaultRepo, profileRepo, pcc.superUserUnlockedAuthenticators);
      return new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, pinnedAuthenticatorSecret !== null && pinnedAuthenticatorSecret !== void 0 ? pinnedAuthenticatorSecret : null, (_a3 = pcc.lastKnownSyncVersion) !== null && _a3 !== void 0 ? _a3 : null, false, pcc.superUserUnlockedAuthenticators, pcc.foreignVaultSyncPredicate, void 0, (_b = pcc.ignoredUnlock) !== null && _b !== void 0 ? _b : null, null, null, pcc.auditlogEventQueue);
    }
    static onlineLoadWithClientCoreParameters(clientCoreParameters, backendClient, pinnedAuthenticatorSecret) {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (clientCoreParameters.unlockedAuthenticator.authenticator.authenticatorType === AuthenticatorType.BACKUP_CODE) {
          throw new LoginWithRecoveryError();
        }
        const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
        const { userId } = clientCoreParameters.loginData;
        const syncUpdate = yield authorizedBackendClient.sync.poll();
        const authListDto = yield authorizedBackendClient.authenticator.list();
        const accountState = AccountState.fromSyncUpdate(userId, syncUpdate).withAuthenticatorList(authListDto);
        const vaultRepo = VaultRepo.create();
        const profileRepo = ProfileRepo.create([], []);
        return new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, pinnedAuthenticatorSecret !== null && pinnedAuthenticatorSecret !== void 0 ? pinnedAuthenticatorSecret : null);
      });
    }
    static onlineRecoverWithNewAuthenticator(clientCoreParameters, backendClient, unsyncedAuthenticator, hsc, extraAuthenticators = []) {
      return __awaiter$8(this, void 0, void 0, function* () {
        const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
        const { userId } = clientCoreParameters.loginData;
        const syncUpdate = yield authorizedBackendClient.sync.poll();
        const accountState = AccountState.fromSyncUpdate(userId, syncUpdate);
        const vaultRepo = VaultRepo.create();
        const profileRepo = ProfileRepo.create([], []);
        const clientCore = new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, null);
        yield clientCore.onlineSyncWithUpdate(syncUpdate, "init");
        const authIds = yield clientCore.onlineAddAuthenticators([unsyncedAuthenticator, ...extraAuthenticators], hsc);
        yield clientCore.onlineLogoutSession(clientCore.getSessionId());
        const hsua = unsyncedAuthenticator.withId(authIds[0]);
        const loginChallenge = yield backendClient.credential.createChallenge(null, null, userId);
        const newClientCoreParameters = yield finishChallengeSelfUnlocking({
          client: backendClient,
          hsua,
          challenge: loginChallenge.challenge,
          userId,
          sessionType: SessionType.SELF_UNLOCKING_PRIMARY
        });
        return {
          clientCoreParameters: Object.assign(Object.assign({}, newClientCoreParameters), { unlockedAuthenticator: hsua.getUnlockedAuthenticator() }),
          extraAuthenticatorIds: authIds.slice(1)
        };
      });
    }
    getPersistable() {
      var _a3;
      let lastKnownSyncVersion;
      if (this.syncVersion && this.accountState.serverSideSettings.persistLastKnownSyncVersion) {
        lastKnownSyncVersion = this.syncVersion;
      }
      return {
        vaultRepo: this.vaultRepo.getPersistable(this.foreignVaultSyncPredicate),
        profileRepo: this.profileRepo.getPersistable(this.params.unlockedAuthenticator),
        accountState: this.accountState.getPersistable(),
        lastKnownSyncVersion,
        superUserUnlockedAuthenticators: this.superUserUnlockedAuthenticators,
        foreignVaultSyncPredicate: this.foreignVaultSyncPredicate,
        ignoredUnlock: (_a3 = this.ignoredUnlock) !== null && _a3 !== void 0 ? _a3 : void 0,
        auditlogEventQueue: this.auditlogEventQueue
      };
    }
    getClientCoreParameters() {
      if (!this.backendClient.config.loginData) {
        throw new LoginDataMissingError();
      }
      return this.params;
    }
    getSessionId() {
      return this.backendClient.getSessionId();
    }
    getLoginVaultById(vaultId) {
      return this.vaultRepo.getLoginVaultById(vaultId);
    }
    getPrivateLoginVault() {
      return this.vaultRepo.getPrivateLoginVault();
    }
    getAchievements() {
      return [...this.accountState.achievements];
    }
    getLoginVaultProtectedSecret(v2, hsc) {
      const vaultAccess = getVaultAccess(this.getClientCoreState(), hsc, v2);
      return unlockLockProtectedSecret(vaultAccess, v2.authenticatorLocks, v2.profileLock, v2.adminProfileLock, this.profileRepo, hsc);
    }
    addLogin(options) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => addLogin(ccs, options));
      });
    }
    modifyLogin(options) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => modifyLogin(ccs, options));
      });
    }
    addOrModifyLogin(options) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => addOrModifyLogin(ccs, options));
      });
    }
    createInitialLoginHistoryEntryIfNecessary(options) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => createInitialLoginHistoryEntryIfNecessary(ccs, options));
      });
    }
    copyLogins(toId, ...fromLogins) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => copyLogins(ccs, toId, fromLogins));
      });
    }
    moveLogins(toId, ...fromLogins) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => moveLogins(ccs, toId, fromLogins));
      });
    }
    deleteOrArchiveLogins(...fromLogins) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => deleteOrArchiveLogins(ccs, fromLogins));
      });
    }
    restoreArchivedLogins(...fromLogins) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => restoreArchivedLogins(ccs, fromLogins));
      });
    }
    deleteArchivedLogins(...fromLogins) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => deleteArchivedLogins(ccs, fromLogins));
      });
    }
    modifyTagsForLogin(options) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => modifyTagsForLogin(ccs, options));
      });
    }
    modifyLinkedViewSecretsForLogin(targetVaultId, loginId, linkedViewSecrets) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => modifyLinkedViewSecretsForLogin(ccs, targetVaultId, loginId, linkedViewSecrets));
      });
    }
    importLogins({ targetVaultId, emptyNameCustomFieldDefaultName }, ...logins) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => importLogins(ccs, targetVaultId, logins, emptyNameCustomFieldDefaultName));
      });
    }
    ingestLoginUpdate(options) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => ingestLoginUpdate(ccs, options));
      });
    }
    deleteOutdatedLoginData(vaultId, loginId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => __awaiter$8(this, void 0, void 0, function* () {
          let newCcs = Object.assign({}, ccs);
          newCcs = yield internalDeleteOutdatedLoginHistory(newCcs, vaultId, loginId);
          newCcs = yield internalDeleteOutdatedShareLinks(newCcs, vaultId, loginId);
          return newCcs;
        }));
      });
    }
    onlineLinkLoginsToTeam(orgId, teamVaultId, ...fromLogins) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield onlineCheckCanLinkToVault(this.backendClient, orgId, teamVaultId);
        return this.modifyClientCore((ccs) => linkLoginsToTeam(ccs, orgId, teamVaultId, fromLogins));
      });
    }
    onlineLinkLoginsToPersonalProfile(orgId, profileId, ...fromLogins) {
      return __awaiter$8(this, void 0, void 0, function* () {
        const personalVaultId = findPersonalVaultId(this.accountState, this.vaultRepo, orgId, profileId);
        yield onlineCheckCanLinkToVault(this.backendClient, orgId, personalVaultId);
        return this.modifyClientCore((ccs) => linkLoginsToPersonalVault(ccs, orgId, profileId, fromLogins));
      });
    }
    unlinkLogins(fromId, toId, ...loginIds) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => unlinkLogins(ccs, fromId, toId, loginIds));
      });
    }
    onlineLoginShareLinkCreate(vaultId, loginId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("loginShareLinkCreate", (ccs) => onlineInternalLoginShareLinkCreate$1(ccs, vaultId, loginId), "result");
      });
    }
    onlineLoginShareLinkDelete(vaultId, loginId, shareLinkId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("loginShareLinkDelete", (ccs) => onlineInternalLoginShareLinkCreate(ccs, vaultId, loginId, shareLinkId), "result");
      });
    }
    onlineUserConfirmationCreate(data) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("userConfirmationCreate", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const { id: id2, syncUpdate, webauthnOptionsJson } = yield ccs.backendClient.userConfirmations.create(data);
          const webauthnOptions = webauthnOptionsJson ? unmarshalCredentialRequestOptions(webauthnOptionsJson) : void 0;
          ccs = yield onlineInternalSync(ccs, syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: { id: id2, webauthnOptions } });
        }), "result");
      });
    }
    onlineUserConfirmationGet(id2) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.backendClient.userConfirmations.get(id2);
      });
    }
    onlineUserConfirmationSendAuthenticatorResult(id2, type) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("onlineUserConfirmationSendAuthenticatorResult", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const su2 = yield ccs.backendClient.userConfirmations.sendResult(id2, type, void 0);
          return onlineInternalSync(ccs, su2);
        }), "result");
      });
    }
    onlineUserConfirmationSendWebauthnResult(id2, type, webauthnResponse) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("onlineUserConfirmationSendWebauthnResult", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const webauthnResponseJson = webauthnResponse ? marshalAssertionPublicKeyCredential(webauthnResponse) : void 0;
          const su2 = yield ccs.backendClient.userConfirmations.sendResult(id2, type, webauthnResponseJson);
          return onlineInternalSync(ccs, su2);
        }), "result");
      });
    }
    onlineUserConfirmationRetrieveResult(id2) {
      return __awaiter$8(this, void 0, void 0, function* () {
        const { resultType } = yield this.backendClient.userConfirmations.retrieveResult(id2);
        return resultType;
      });
    }
    onlineUserConfirmationCancel(id2) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("userConfirmationCancel", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const su2 = yield ccs.backendClient.userConfirmations.cancel(id2);
          return onlineInternalSync(ccs, su2);
        }), "result");
      });
    }
    modifyLoginVaultForTest(vaultId, mod, hsc) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
          if (!vault) {
            throw new VaultNotFoundError(vaultId);
          }
          const mod2 = (vaultContent, t2, modificationFunctions) => {
            const result2 = mod(vaultContent, t2, modificationFunctions);
            return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
          };
          return modifyLoginVault(ccs, vault, mod2, hsc);
        }));
      });
    }
    modifyTeamMetaVault(vaultId, mod) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const vault = ccs.vaultRepo.getTeamMetaVaultById(vaultId);
          if (!vault) {
            throw new VaultNotFoundError(vaultId);
          }
          return modifyVault(ccs, vault, mod);
        }));
      });
    }
    modifyMetaVault(mod) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const vault = ccs.vaultRepo.getMetaVault();
          if (!vault) {
            throw new MetaVaultNotFoundError();
          }
          return modifyVault(ccs, vault, mod);
        }));
      });
    }
    migrateBackupCode(backupCode, hsc) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var _b;
          var ccs = __rest(_a3, []);
          const vault = ccs.vaultRepo.getMetaVault();
          if (!vault) {
            throw new MetaVaultNotFoundError();
          }
          if ((_b = getAccountSettings(vault.getContent())) === null || _b === void 0 ? void 0 : _b.backupCode) {
            trackError("cor: onlineMigrateBackupCode called with backup code already migrated");
            return ccs;
          }
          ccs = modifyVault(ccs, vault, (c2, t2, { modifyAccountSettings: modifyAccountSettings2, protect: protect2 }) => modifyAccountSettings2(c2, t2, {
            backupCode: protect2({ unencrypted: backupCode, contentId: newUuid$1() })
          }), true, hsc);
          ccs.accountState = ccs.accountState.withLocalAchievements([
            Achievement.COR_STORE_BACKUP_CODE_META_VAULT
          ]);
          return ccs;
        }));
      });
    }
    modifyLegacyOrganizationAdminVault(vaultId, mod, hsc) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const vault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(vaultId);
          if (!vault) {
            throw new VaultNotFoundError(vaultId);
          }
          return modifyVault(ccs, vault, mod, true, hsc);
        }));
      });
    }
    addAchievement(...achievements) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          ccs.accountState = ccs.accountState.withLocalAchievements(achievements);
          return ccs;
        }));
      });
    }
    getMetaContent() {
      var _a3, _b;
      return (_b = (_a3 = this.vaultRepo.getMetaVault()) === null || _a3 === void 0 ? void 0 : _a3.getContent()) !== null && _b !== void 0 ? _b : null;
    }
    isUnlocked() {
      var _a3;
      return !!((_a3 = this.protectedSecretRepo) === null || _a3 === void 0 ? void 0 : _a3.isUnlocked());
    }
    isPinnedUnlocked() {
      return !!this.pinnedAuthenticatorSecret;
    }
    modifyClientCore(modify) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.internalModifyClientCore(modify, null, null);
      });
    }
    onlineModifyClientCore(clientOperationName, modify, eventOrigin) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.internalModifyClientCore(modify, eventOrigin, clientOperationName);
      });
    }
    internalModifyClientCore(modify, eventOrigin, clientOperationName) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.mutex.runExclusive(() => __awaiter$8(this, void 0, void 0, function* () {
          var _a3, _b, _c2, _d;
          if (eventOrigin) {
            yield this.emitter.emit("syncStart", { eventOrigin });
          }
          const backendClient = clientOperationName ? this.backendClient.withClientOperation(newUniURI(), clientOperationName, (_a3 = this.syncVersion) !== null && _a3 !== void 0 ? _a3 : void 0) : void 0;
          if (clientOperationName) {
            addBreadcrumb$1({
              type: "info",
              category: "onlineModifyClientCore",
              data: {
                clientOperationName,
                clientOperationId: backendClient === null || backendClient === void 0 ? void 0 : backendClient.config.clientOperationId
              }
            });
          }
          const oldCcs = Object.assign(Object.assign({}, this.getClientCoreState()), { backendClient });
          let newCcs;
          try {
            newCcs = yield modify(oldCcs);
          } catch (e2) {
            if (eventOrigin) {
              yield this.emitter.emit("syncEnd", { eventOrigin });
            }
            throw e2;
          }
          this.vaultRepo = newCcs.vaultRepo;
          this.profileRepo = newCcs.profileRepo;
          this.accountState = newCcs.accountState;
          this.protectedSecretRepo = newCcs.protectedSecretRepo;
          this.syncVersion = newCcs.syncVersion;
          this.tokenRefreshNeeded = newCcs.tokenRefreshNeeded;
          this.superUserUnlockedAuthenticators = newCcs.superUserUnlockedAuthenticators;
          this.foreignVaultSyncPredicate = newCcs.foreignVaultSyncPredicate;
          this.ephemeralForeignVaultSyncPredicate = newCcs.ephemeralForeignVaultSyncPredicate;
          this.ignoredUnlock = newCcs.ignoredUnlock;
          this.maintenanceSettings = newCcs.maintenanceSettings;
          this.lastKnownServerTime = newCcs.lastKnownServerTime;
          this.clientOutdated = newCcs.clientOutdated;
          this.clientServerTimeOffsetMs = newCcs.clientServerTimeOffsetMs;
          this.auditlogEventQueue = newCcs.auditlogEventQueue;
          this.auditlogWriteTokenCache = newCcs.auditlogWriteTokenCache;
          if (newCcs.ignoredUnlock !== oldCcs.ignoredUnlock) {
            this.emitter.emit("ignoredUnlockChange").catch(trackError);
          }
          if (newCcs.accountState && newCcs.accountState !== oldCcs.accountState) {
            this.emitter.emit("accountStateChange", {
              oldAccountState: oldCcs.accountState,
              newAccountState: newCcs.accountState
            }).catch(trackError);
          }
          if (newCcs.protectedSecretRepo !== oldCcs.protectedSecretRepo && ((_b = newCcs.protectedSecretRepo) === null || _b === void 0 ? void 0 : _b.isUnlocked()) !== ((_c2 = oldCcs.protectedSecretRepo) === null || _c2 === void 0 ? void 0 : _c2.isUnlocked())) {
            const isUnlocked = !!((_d = newCcs.protectedSecretRepo) === null || _d === void 0 ? void 0 : _d.isUnlocked());
            this.emitter.emit("unlockedChange", { isUnlocked }).catch(trackError);
            addBreadcrumb$1({
              type: "info",
              category: "unlockedChange",
              data: { isUnlocked }
            });
          }
          if (newCcs.profileRepo !== oldCcs.profileRepo) {
            this.emitter.emit("profileRepoChange", {
              oldProfileRepo: oldCcs.profileRepo,
              newProfileRepo: newCcs.profileRepo
            }).catch(trackError);
          }
          if (newCcs.vaultRepo !== oldCcs.vaultRepo) {
            this.emitter.emit("vaultRepoChange", {
              oldVaultRepo: oldCcs.vaultRepo,
              newVaultRepo: newCcs.vaultRepo
            }).catch(trackError);
          }
          if (eventOrigin) {
            yield this.emitter.emit("syncEnd", { eventOrigin });
          } else if (newCcs.vaultRepo !== oldCcs.vaultRepo) {
            yield this.emitter.emit("localVaultChange");
          }
          if (newCcs.tokenRefreshNeeded) {
            yield this.emitter.emit("clientCoreParametersRefreshNeeded");
          }
          return newCcs.returnResult;
        }));
      });
    }
    batchModify(performBatchModification, pinnedSecret) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.internalBatchModify(performBatchModification, null, pinnedSecret);
      });
    }
    onlineBatchModify(performBatchModification, pinnedSecret) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.internalBatchModify(performBatchModification, "result", pinnedSecret);
      });
    }
    // This method can be called with a pinnedSecret as a temporary unlock. Please note that this way
    // is a relatively expensive operation, and should only be called in ways that don't affect
    // responsiveness.
    internalBatchModify(performBatchModification, eventOrigin, pinnedSecret) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.internalModifyClientCore((_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const batchCC = new ClientCore_1(ccs.vaultRepo, ccs.profileRepo, ccs.backendClient, ccs.params, ccs.accountState, pinnedSecret !== null && pinnedSecret !== void 0 ? pinnedSecret : ccs.pinnedAuthenticatorSecret, ccs.syncVersion, ccs.tokenRefreshNeeded, ccs.superUserUnlockedAuthenticators, ccs.foreignVaultSyncPredicate, ccs.ephemeralForeignVaultSyncPredicate, ccs.ignoredUnlock, ccs.lastKnownServerTime, ccs.clientServerTimeOffsetMs, ccs.auditlogEventQueue, ccs.auditlogWriteTokenCache);
          batchCC.maintenanceSettings = ccs.maintenanceSettings;
          if (!pinnedSecret) {
            batchCC.protectedSecretRepo = ccs.protectedSecretRepo;
          }
          const returnResult = yield performBatchModification(batchCC);
          if (pinnedSecret && !ccs.protectedSecretRepo) {
            batchCC.protectedSecretRepo = null;
          }
          return Object.assign(Object.assign({}, batchCC.getClientCoreState()), { backendClient: batchCC.backendClient, returnResult });
        }), eventOrigin, "batch");
      });
    }
    onlineEnsureSessionMetaUpToDate(customSessionData, syncUpdate = null) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("ensureSessionMetaUpToDate", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var _b;
          var ccs = __rest(_a3, []);
          ccs = yield onlineInternalSync(ccs, syncUpdate);
          const ownSessionId = ccs.backendClient.getSessionId();
          const otherSessionIds = ccs.accountState.sessions.map((s2) => s2.id).filter((s2) => s2 !== ownSessionId);
          const metaVault = ccs.vaultRepo.getMetaVault();
          if (!metaVault) {
            return ccs;
          }
          const allSessionMeta = metaVault.getContent().sessions;
          const ownSessionMeta = (_b = allSessionMeta[ownSessionId]) !== null && _b !== void 0 ? _b : null;
          const otherSessionMeta = otherSessionIds.map((s2) => allSessionMeta[s2]).filter((m2) => m2);
          let fieldsToUpdate = customSessionData(ownSessionMeta, otherSessionMeta);
          if (ownSessionMeta === null) {
            fieldsToUpdate = Object.assign(Object.assign({}, fieldsToUpdate), { encPubKey: naclUtilExports.encodeBase64(ccs.params.sessionKeys.encPubKey), encPubKeySignature: naclUtilExports.encodeBase64(ccs.params.sessionKeys.encPubKeySignature), signingAuthId: ccs.params.sessionKeys.signingAuthId });
          }
          if (Object.keys(fieldsToUpdate).length) {
            ccs = internalUpdateMetaSession(ccs, ownSessionId, fieldsToUpdate);
            ccs = yield onlineInternalSync(ccs, syncUpdate);
          }
          return ccs;
        }), "result");
      });
    }
    updateMetaSession(sessionId, session) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.modifyClientCore((ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return internalUpdateMetaSession(ccs, sessionId, session);
        }));
      });
    }
    getSessions() {
      return this.accountState.sessions;
    }
    getSession() {
      const sessionId = this.getSessionId();
      const session = this.getSessions().find((s2) => s2.id === sessionId);
      if (!session) {
        throw new OwnSessionMissingError();
      }
      return session;
    }
    getSessionById(sessionId) {
      return this.getSessions().find((s2) => s2.id === sessionId);
    }
    getSessionMetaById(sessionId) {
      var _a3, _b;
      const sessionMeta = (_a3 = this.getMetaContent()) === null || _a3 === void 0 ? void 0 : _a3.sessions;
      return (_b = sessionMeta === null || sessionMeta === void 0 ? void 0 : sessionMeta[sessionId]) !== null && _b !== void 0 ? _b : null;
    }
    ignoreCurrentUnlock() {
      return __awaiter$8(this, void 0, void 0, function* () {
        const session = this.getSession();
        if (this.pinnedAuthenticatorSecret) {
          throw new Error("cannot ignore unlock with pinned authenticator secret");
        }
        const { unlockedAt } = session;
        if (unlockedAt !== void 0) {
          yield this.modifyClientCore((_a3) => {
            var ccs = __rest(_a3, []);
            ccs.ignoredUnlock = unlockedAt;
            ccs.protectedSecretRepo = null;
            return Promise.resolve(ccs);
          });
        }
      });
    }
    getActiveChannels() {
      return this.accountState.channels;
    }
    getLoginRequests() {
      return this.accountState.channels.map((c2) => c2.id);
    }
    onlineSync(fcmMessageId, hsc = null) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("sync", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalSync(Object.assign({}, ccs), null, fcmMessageId, hsc);
        }), "poll");
      });
    }
    onlineSyncWithUpdate(syncUpdate, eventOrigin) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("syncWithUpdate", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalSync(ccs, syncUpdate);
        }), eventOrigin);
      });
    }
    onlineLogoutSession(sessionId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        try {
          const syncUpdate = yield this.backendClient.deleteSession(sessionId);
          if (syncUpdate) {
            yield this.onlineSyncWithUpdate(syncUpdate, "result");
          }
        } catch (e2) {
          if (e2 instanceof DomainError$1 && e2.code === BackendErrorCode.SESSION_NOT_FOUND) {
            yield this.onlineSync();
            return;
          }
          throw e2;
        }
      });
    }
    lockAllVaults() {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (this.pinnedAuthenticatorSecret) {
          return;
        }
        yield this.modifyClientCore((ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return Object.assign(Object.assign({}, ccs), { protectedSecretRepo: null });
        }));
      });
    }
    onlineRegenerateVault(hsc, vaultId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("regenerateVault", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          ccs = yield onlineInternalSync(ccs);
          return onlineInternalRegenerateVault(ccs, hsc, vaultId);
        }), "result");
      });
    }
    onlineRegenerateRecovery(backupCode, recoverySeed, parameters, hsc) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("regenerateRecovery", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalRegenerateRecovery(ccs, backupCode, recoverySeed, parameters, hsc);
        }), "result");
      });
    }
    getBackupCode(hsc) {
      var _a3, _b;
      const metaVault = this.vaultRepo.getMetaVault();
      if (!metaVault) {
        throw new MetaVaultNotFoundError();
      }
      let protectedSecretFunctions;
      if (hsc) {
        protectedSecretFunctions = ProtectedSecretRepo.create(this.getClientCoreState(), hsc, null).getProtectedSecretFunctions(metaVault);
      } else if ((_a3 = this.protectedSecretRepo) === null || _a3 === void 0 ? void 0 : _a3.isUnlocked()) {
        protectedSecretFunctions = this.protectedSecretRepo.getProtectedSecretFunctions(metaVault);
      } else {
        throw new CannotUnprotectError();
      }
      const protectedBackupCode = (_b = getAccountSettings(metaVault.getContent())) === null || _b === void 0 ? void 0 : _b.backupCode;
      if (!protectedBackupCode) {
        return;
      }
      return protectedSecretFunctions.unprotect(protectedBackupCode);
    }
    onlineRegenerateBackup(backupSeed, hsc) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("regenerateBackup", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalRegenerateBackup(ccs, backupSeed, hsc);
        }), "result");
      });
    }
    onlineAddAuthenticators(authsToAdd, hsc) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("addAuthenticators", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const result2 = yield onlineInternalModifyAuthenticators(ccs, hsc, [], authsToAdd);
          if (result2.returnResult.length === 0) {
            throw new NoAuthenticatorIdReceivedError();
          }
          return Object.assign(Object.assign({}, result2), { returnResult: result2.returnResult });
        }), "result");
      });
    }
    onlineRemoveAuthenticator(authenticatorId, hsc) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("removeAuthenticator", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalModifyAuthenticators(ccs, hsc, [authenticatorId]);
        }), "result");
      });
    }
    onlineMigrateToAuthenticatorChain(hsc) {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (this.accountState.authenticatorBlockHash !== null) {
          return;
        }
        return this.onlineModifyClientCore("migrateToAuthenticatorChain", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalMigrateToAuthenticatorChain(ccs, hsc);
        }), "result");
      });
    }
    onlineProfilesRegenerate(hsc) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("profilesRegenerate", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalProfileRegenerate(ccs, hsc);
        }), "result");
      });
    }
    onlineOrganizationRegenerateProfiles(orgId, profiles) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRegenerateProfile", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const newCcs = yield onlineInternalOrganizationRegenerateProfiles(ccs, orgId, profiles);
          return Object.assign(Object.assign({}, newCcs), { returnResult: newCcs.returnResult });
        }), "result");
      });
    }
    onlineTeamCreate(name, organizationId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("teamCreate", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalTeamCreate(ccs, name, organizationId);
        }), "result");
      });
    }
    onlineTeamDelete(vaultId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("teamDelete", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalTeamDelete(ccs, vaultId);
        }), "result");
      });
    }
    onlineTeamAddUsers(teamId, usersToAdd, skipInvite = false) {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (usersToAdd.length === 0) {
          return;
        }
        return this.onlineModifyClientCore("teamAddUsers", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalTeamModifyUsers(ccs, teamId, { usersToAdd, skipInvite });
        }), "result");
      });
    }
    onlineTeamRemoveUsers(teamId, profileIds) {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (profileIds.length === 0) {
          return;
        }
        return this.onlineModifyClientCore("teamRemoveUsers", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalTeamModifyUsers(ccs, teamId, {
            profileIdsToRemove: profileIds
          });
        }), "result");
      });
    }
    onlineTeamLeave(teamId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("teamLeave", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalTeamLeave(ccs, teamId);
        }), "result");
      });
    }
    teamSetUserPermissionLevels(teamId, ...users) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return internalTeamSetUserPermissionLevels(ccs, teamId, ...users);
        }));
      });
    }
    teamClearNewlyJoined(teamId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return internalTeamClearNewlyJoined(ccs, teamId);
        }));
      });
    }
    loginSetConfirmed(vaultId, loginId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return internalLoginSetConfirmed(ccs, vaultId, loginId);
        }));
      });
    }
    onlineMaintainTeamSyncOrganizationMembers() {
      var _a3;
      return __awaiter$8(this, void 0, void 0, function* () {
        const task = MaintenanceTask.TEAM_SYNC_ORGANIZATION_MEMBERS_V2;
        if (!((_a3 = this.maintenanceSettings) === null || _a3 === void 0 ? void 0 : _a3.allowedTasks.includes(task))) {
          return;
        }
        const teamsToChange = getTeamsWithSyncOrganizationMembersAndMismatchedUsers(this.vaultRepo, this.accountState);
        if (!teamsToChange.length) {
          return;
        }
        yield this.onlineModifyClientCore("maintainTeamSyncOrganizationMembers", (ccs) => {
          return onlineInternalMaintainTeamSyncOrganizationMembers(ccs);
        }, "result");
      });
    }
    onlineHandleLoginChallenge(channelId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return LoginFlowPushAuthenticator.create(
          channelId,
          // TODO: this is implicit, make this explicit
          this.params.unlockedAuthenticator.authenticator.id,
          this.backendClient
        );
      });
    }
    onlineRejectLoginChallenge(channelId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("rejectLoginChallenge", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const { syncUpdate } = yield ccs.backendClient.channel.delete(channelId);
          return syncUpdate ? onlineInternalSync(ccs, syncUpdate) : ccs;
        }), "result");
      });
    }
    onlineLongPollChannelSendSecret(publicKeyB64, authenticatorSeed, registration) {
      return __awaiter$8(this, void 0, void 0, function* () {
        const { publicKeyHash, authReply } = completeLongPollChannelReply(publicKeyB64, authenticatorSeed, registration);
        yield this.backendClient.credential.completeLongPollChannel(publicKeyHash, this.params.unlockedAuthenticator.authenticator.id, authReply);
      });
    }
    onlineCreateSessionUnlock(sessionId, encPubKey, encPubKeySignature, trustedSigPubKeys, hsc, expiresAt) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("createSessionUnlock", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          checkEncPubKeySignature(trustedSigPubKeys, encPubKey, encPubKeySignature, SALT_SESSION_ENCRYPTION_KEY_SIGNATURE);
          const encryptedSecret = hsc.getHighSecurityUnlockedAuthenticator().createEncryptedSecret(encPubKey);
          const syncUpdate = yield ccs.backendClient.session.createSessionUnlock(
            sessionId,
            // TODO: this is implicit, make this explicit
            this.params.unlockedAuthenticator.authenticator.id,
            encryptedSecret,
            expiresAt
          );
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineExtendSessionUnlock(lastUserActivity) {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (this.getSession().unlockedAt === void 0) {
          return;
        }
        return this.onlineModifyClientCore("extendSessionUnlock", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.session.extendSessionUnlock(lastUserActivity);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineSendLoginEventNotification(vaultId, loginId, username, domain) {
      var _a3;
      return __awaiter$8(this, void 0, void 0, function* () {
        if (!((_a3 = this.accountState.serverSideSettings.eventNotifications) === null || _a3 === void 0 ? void 0 : _a3.enable)) {
          return;
        }
        const { description, iconType } = this.getSessionMetaById(this.getSessionId());
        const data = new TextEncoder().encode(JSON.stringify({
          type: "login",
          session: { description, iconType },
          vaultId,
          loginId,
          username,
          domain
        }));
        const messages = [];
        for (const s2 of this.getSessions()) {
          const meta = this.getSessionMetaById(s2.id);
          if (meta && (s2.sessionType === SessionType.SELF_UNLOCKING_PRIMARY || s2.sessionType === SessionType.SELF_UNLOCKING_SECONDARY)) {
            const payload = asymEncrypt(loadEncryptionPublicKey(meta.encPubKey), data);
            messages.push({ sessionId: s2.id, payload });
          }
        }
        yield this.backendClient.session.sendSessionMessage(messages);
      });
    }
    onlineDeleteSessionUnlock(sessionId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("deleteSessionUnlock", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.session.deleteSessionUnlock(sessionId);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineCancelRequestSessionUnlock(sessionId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("cancelRequestSessionUnlock", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.session.deleteSessionUnlock(sessionId, true);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineRequestSessionUnlock() {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("requestSessionUnlock", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.session.requestSessionUnlock();
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineSessionSetUnlockTimeLimit(unlockTimeLimit) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("sessionSetUnlockTimeLimit", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const sessionId = ccs.params.loginData.sessionId;
          const su2 = yield ccs.backendClient.session.update(sessionId, [], { unlockTimeLimit });
          return onlineInternalSync(ccs, su2);
        }), "result");
      });
    }
    onlineSessionSetProfileEnabled(profileId, enabled) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("sessionSetProfileEnabled", (ccs) => onlineInternalSessionSetProfileEnabled(ccs, profileId, enabled), "result");
      });
    }
    onlineSessionSetEnabledProfileIds(enabledProfileIds) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("sessionSetEnabledProfileIds", (ccs) => onlineInternalSessionSetEnabledProfileIds(ccs, enabledProfileIds), "result");
      });
    }
    onlineRequestProfileEmailChange(profileId, email) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("requestProfileEmailChange", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const resp = yield ccs.backendClient.profile.requestEmailChange(profileId, email);
          ccs = yield onlineInternalSync(ccs, resp.syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: { verificationEmailSent: resp.verificationEmailSent } });
        }), "result");
      });
    }
    onlineCancelProfileEmailChange(profileId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("cancelProfileEmailChange", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const syncUpdate = yield ccs.backendClient.profile.cancelEmailChange(profileId);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineSetPreferredLocale(preferredLocale) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("setPreferredLocale", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.account.update({
            preferredLocale
          });
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineProfileCreatePrivate(email) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("profileCreatePrivate", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalProfileCreatePrivate(ccs, email);
        }), "result");
      });
    }
    onlineProfileDeletePrivate(profileId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("profileDeletePrivate", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalProfileDeletePrivate(ccs, profileId);
        }), "result");
      });
    }
    onlineProfileClaimWithStartCode(profileId, startCode) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("profileClaimWithStartCode", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const result2 = yield ccs.backendClient.profile.claimWithStartCode(profileId, startCode);
          ccs = yield onlineInternalSync(ccs, result2.syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: result2.organizationId });
        }), "result");
      });
    }
    onlineOrganizationCreate(email, name, syncOrganizationMembersVaultName, options) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationCreate", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          if (!(options === null || options === void 0 ? void 0 : options.legacy)) {
            return onlineInternalOrganizationCreate(ccs, email, name, syncOrganizationMembersVaultName, options);
          } else {
            return onlineInternalOrganizationCreateLegacy(ccs, email, name, syncOrganizationMembersVaultName, options);
          }
        }), "result");
      });
    }
    onlineOrganizationUpdate(orgId, fields) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationUpdate", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const org = this.accountState.organizations.find((o2) => o2.id === orgId);
          if (!org) {
            throw new OrganizationNotFoundError();
          }
          const { passwordPolicy, clientSettings } = fields, restFields = __rest(fields, ["passwordPolicy", "clientSettings"]);
          const syncUpdate = yield ccs.backendClient.organization.update(orgId, Object.assign(Object.assign({}, restFields), { passwordPolicy: passwordPolicy === void 0 || passwordPolicy === null ? passwordPolicy : jsonStringifyFreeze(passwordPolicy), clientSettings: clientSettings ? jsonStringifyFreeze(Object.assign(Object.assign({}, org.clientSettings), clientSettings)) : void 0 }));
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationCreateFreeProfiles(orgId, emails, { isAdmin = false, createStartCodeAndSendMail } = {}) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationAddMember", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const resolvedEmails = yield ccs.backendClient.account.resolveEmails(emails, false);
          const createFreeProfiles = resolvedEmails.map(({ email, emailInvalid }) => {
            if (emailInvalid) {
              throw new DomainError$1(BackendErrorCode.INVALID_EMAIL, "invalid email", "Email address is invalid", `${email} is not a valid email address.`);
            }
            return {
              email,
              isAdmin,
              createStartCodeAndSendMail
            };
          });
          return onlineInternalOrganizationModifyMembers(ccs, orgId, { createFreeProfiles });
        }), "result");
      });
    }
    onlineOrganizationCreateServiceProfile(orgId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationCreateServiceProfile", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalOrganizationCreateServiceProfile(ccs, orgId);
        }), "result");
      });
    }
    onlineOrganizationUpdateMembers(orgId, membersToUpdate) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationUpdateMembers", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalOrganizationModifyMembers(ccs, orgId, {
            updateProfiles: membersToUpdate.flatMap((m2) => ({
              id: m2.profileId,
              isAdmin: m2.isAdmin
            }))
          });
        }), "result");
      });
    }
    onlineOrganizationRemoveMembers(orgId, profileIds) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRemoveMembers", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalOrganizationModifyMembers(ccs, orgId, {
            removeProfileIds: profileIds
          });
        }), "result");
      });
    }
    onlineOrganizationLeave(orgId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationLeave", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const su2 = yield ccs.backendClient.organization.leave(orgId);
          return onlineInternalSync(ccs, su2);
        }), "result");
      });
    }
    onlineOrganizationDelete(orgId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationDelete", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalOrganizationDelete(ccs, orgId);
        }), "result");
      });
    }
    onlineOrganizationRedeemCoupon(orgId, coupon) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRedeemCoupon", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const org = ccs.accountState.getOrganization(orgId);
          if (!org) {
            throw new OrganizationNotFoundError();
          }
          if (!org.isAdmin) {
            throw new NoOrganizationAdminError();
          }
          const su2 = yield ccs.backendClient.withPermissionUserId(org.superUserId).organization.redeemCoupon(orgId, coupon);
          return onlineInternalSync(ccs, su2);
        }), "result");
      });
    }
    onlineOrganizationEntraFinishAuthorization(search) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationEntraInitSync", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const response = yield ccs.backendClient.integrations.entraFinishAuthorization(search);
          const { syncUpdate } = response;
          ccs = yield onlineInternalSync(ccs, syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: response });
        }), "result");
      });
    }
    onlineOrganizationEntraClearAuthorization(organizationId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationEntraClearAuthorization", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.integrations.entraClearAuthorization(organizationId);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationGoogleWorkspaceFinishAuthorization(search) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationGoogleWorkspaceFinishAuthorization", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const response = yield ccs.backendClient.integrations.googleWorkspaceFinishAuthorization(search);
          const { syncUpdate } = response;
          ccs = yield onlineInternalSync(ccs, syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: response });
        }), "result");
      });
    }
    onlineOrganizationGoogleWorkspaceClearAuthorization(orgId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationGoogleWorkspaceFinishAuthorization", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const su2 = yield ccs.backendClient.integrations.googleWorkspaceClearAuthorization(orgId);
          return onlineInternalSync(ccs, su2);
        }), "result");
      });
    }
    onlineOrganizationSetCsvIntegrationData(organizationId, csvIntegrationData, cancelToken) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationSetCsvIntegrationData", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const su2 = yield ccs.backendClient.integrations.csvSetIntegrationData(organizationId, csvIntegrationData ? JSON.stringify(csvIntegrationData) : null, cancelToken);
          return onlineInternalSync(ccs, su2);
        }), "result");
      });
    }
    onlineOrganizationGetCsvIntegrationData(organizationId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return CsvIntegrationData.parse(JSON.parse(yield this.backendClient.integrations.csvGetIntegrationData(organizationId)));
      });
    }
    onlineOrganizationRegenerateAdminProfile(orgId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRegenerateAdminProfile", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalOrganizationRegenerateAdminProfile(ccs, orgId);
        }), "result");
      });
    }
    onlineChildOrganizationAddManager(organizationId, parentOrganizationProfileId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("childOrganizationAddManager", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalChildOrganizationAddManager(ccs, organizationId, parentOrganizationProfileId);
        }), "result");
      });
    }
    onlineChildOrganizationUpdate(childOrgId, fields) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("childOrganizationUpdate", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const { parentOrganizationMetadata } = fields, restFields = __rest(fields, ["parentOrganizationMetadata"]);
          const syncUpdate = yield ccs.backendClient.childOrganization.update(childOrgId, Object.assign(Object.assign({}, restFields), { parentOrganizationMetadata: parentOrganizationMetadata === void 0 || parentOrganizationMetadata === null ? parentOrganizationMetadata : jsonStringifyFreeze(parentOrganizationMetadata) }));
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineInboxVaultCreate(slug, metadata, organizationId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("inboxVaultCreate", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalInboxVaultCreate(ccs, slug, metadata, organizationId);
        }), "result");
      });
    }
    onlineInboxVaultUpdate(vaultId, { slug, metadata }) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("inboxVaultModify", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const metadataJson = metadata !== void 0 ? jsonStringifyFreeze(metadata) : void 0;
          const syncUpdate = yield ccs.backendClient.vault.updateInbox(vaultId, {
            slug,
            metadataJson
          });
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineInboxVaultDelete(vaultId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("inboxVaultDelete", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalInboxVaultDelete(ccs, vaultId);
        }), "result");
      });
    }
    onlineMaintainMigrateToAdminProfile() {
      var _a3, _b;
      return __awaiter$8(this, void 0, void 0, function* () {
        const task = MaintenanceTask.ORGANIZATION_MIGRATE_TO_ADMIN_PROFILE_V2;
        if (!((_a3 = this.maintenanceSettings) === null || _a3 === void 0 ? void 0 : _a3.allowedTasks.includes(task))) {
          return;
        }
        const legacyOrgId = (_b = this.accountState.organizations.find((o2) => o2.adminProfileId === null)) === null || _b === void 0 ? void 0 : _b.id;
        if (!legacyOrgId) {
          return;
        }
        yield this.onlineModifyClientCore("maintainMigrateToAdminProfile", (ccs) => {
          return onlineInternalOrganizationRegenerateAdminProfile(ccs, legacyOrgId);
        }, "result");
      });
    }
    onlineMaintainVaultMessages() {
      var _a3;
      return __awaiter$8(this, void 0, void 0, function* () {
        const task = MaintenanceTask.PROCESS_VAULT_MESSAGES_V2;
        if (!((_a3 = this.maintenanceSettings) === null || _a3 === void 0 ? void 0 : _a3.allowedTasks.includes(task))) {
          return;
        }
        if (!hasProcessableVaultMessages(this.vaultRepo)) {
          return;
        }
        yield this.onlineModifyClientCore("maintainVaultMessages", (ccs) => {
          return onlineInternalMaintainVaultMessages(ccs);
        }, "result");
      });
    }
    onlineMaintainOrganizationPreliminaryProfiles() {
      var _a3;
      return __awaiter$8(this, void 0, void 0, function* () {
        const task = MaintenanceTask.ORGANIZATION_PRELIMINARY_PROFILES_V3;
        if (!((_a3 = this.maintenanceSettings) === null || _a3 === void 0 ? void 0 : _a3.allowedTasks.includes(task))) {
          return;
        }
        const profiles = getOrganizationsProfilesWithPreliminaryUserId(this.accountState.organizations, this.profileRepo);
        if (!profiles.length) {
          return;
        }
        yield this.onlineModifyClientCore("maintainOrganizationPreliminaryProfiles", (ccs) => {
          return onlineMaintainOrganizationPreliminaryProfiles(ccs);
        }, "result");
      });
    }
    onlineSetUserClientSettings(updatedSettings) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("setUserClientSettings", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const userClientSettings = jsonStringifyFreeze(Object.assign(Object.assign({}, ccs.accountState.userClientSettings), updatedSettings));
          const syncUpdate = yield ccs.backendClient.account.update({
            userClientSettings
          });
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlinePerformMaintenance() {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (!this.isUnlocked()) {
          return;
        }
        yield this.onlineMaintainMigrateToAdminProfile().catch(trackError);
        const results = yield Promise.allSettled([
          this.onlineMaintainOrganizationPreliminaryProfiles(),
          this.onlineMaintainTeamSyncOrganizationMembers(),
          this.onlineMaintainVaultMessages()
        ]);
        results.filter((result2) => result2.status === "rejected").forEach(({ reason }) => trackError(reason));
      });
    }
    onlineWebauthnRegisterCredentialInit(type) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("webauthnRegisterCredentialInit", (ccs) => onlineInternalWebauthnRegisterCredentialInit(ccs, type), "result");
      });
    }
    onlineWebauthnRegisterCredentialFinish(requestId, cred) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("webauthnRegisterCredentialFinish", (ccs) => onlineInternalWebauthnRegisterCredentialFinish(ccs, requestId, cred), "result");
      });
    }
    onlineWebauthnDeleteCredentials(...ids) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("webauthnDeleteCredentials", (ccs) => onlineInternalWebauthnDeleteCredentials(ccs, ids), "result");
      });
    }
    onlineWebauthnUnlockSessionInit() {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("webauthnUnlockSessionInit", onlineInternalWebauthnUnlockSessionInit, "result");
      });
    }
    onlineWebauthnUnlockSessionFinish(requestId, cred) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("webauthnUnlockSessionFinish", (ccs) => onlineInternalWebauthnUnlockSessionFinish(ccs, requestId, cred), "result");
      });
    }
    onlineWebauthnEnablePrf(request, cred) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("webauthnEnablePrf", (ccs) => onlineInternalWebauthnEnablePrf(ccs, request, cred), "result");
      });
    }
    onlineWebauthnEnablePrfOpportunistically(request, result2) {
      var _a3;
      return __awaiter$8(this, void 0, void 0, function* () {
        const task = MaintenanceTask.ENABLE_PRF_OPPORTUNISTICALLY_V1;
        if (!((_a3 = this.maintenanceSettings) === null || _a3 === void 0 ? void 0 : _a3.allowedTasks.includes(task))) {
          return;
        }
        const isAlreadyEnabled = this.accountState.authenticators.some((a) => {
          var _a4;
          return ((_a4 = a.webauthn) === null || _a4 === void 0 ? void 0 : _a4.webauthnId) === result2.id;
        });
        if (isAlreadyEnabled) {
          return;
        }
        const isSessionBound = this.accountState.webauthnCredentials.some((wc2) => wc2.webauthnId === result2.id && wc2.sessionId !== null);
        if (isSessionBound) {
          return;
        }
        yield this.onlineWebauthnEnablePrf(request, result2);
      });
    }
    onlineModifyForeignVaultSyncPredicate(predicateModification) {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (!this.backendClient.config.syncSuperUsers) {
          throw new Error("onlineModifyForeignVaultSyncPredicate requires syncSuperUsers!");
        }
        yield this.onlineModifyClientCore("modifyForeignVaultSyncPredicate", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const newPredicate = predicateModification(ccs.foreignVaultSyncPredicate);
          if (Ee$1(ccs.foreignVaultSyncPredicate, newPredicate)) {
            return ccs;
          }
          ccs.foreignVaultSyncPredicate = newPredicate;
          ccs.syncVersion = null;
          ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
          ccs = yield onlineInternalSync(ccs);
          return ccs;
        }), "result");
      });
    }
    onlineModifyEphemeralForeignVaultSyncPredicate(predicateModification) {
      return __awaiter$8(this, void 0, void 0, function* () {
        if (!this.backendClient.config.syncSuperUsers) {
          throw new Error("onlineModifyEphemeralForeignVaultSyncPredicate requires syncSuperUsers!");
        }
        yield this.onlineModifyClientCore("modifyEphemeralForeignVaultSyncPredicate", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const newPredicate = predicateModification(ccs.ephemeralForeignVaultSyncPredicate);
          if (Ee$1(ccs.ephemeralForeignVaultSyncPredicate, newPredicate)) {
            return ccs;
          }
          ccs.ephemeralForeignVaultSyncPredicate = newPredicate;
          ccs.syncVersion = null;
          ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
          ccs = yield onlineInternalSync(ccs);
          return ccs;
        }), "result");
      });
    }
    auditlogWriteEventsWithRetry(orgId, ...events) {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("auditlogWriteEventsWithRetry", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const queuedEvents = events.map((event) => {
            var _a4;
            return {
              organizationId: orgId,
              clientTime: /* @__PURE__ */ new Date(),
              lastKnownServerTime: (_a4 = ccs.lastKnownServerTime) !== null && _a4 !== void 0 ? _a4 : /* @__PURE__ */ new Date(0),
              event
            };
          });
          const newCcs = yield onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, queuedEvents);
          if (newCcs.returnResult === AuditlogWriteResult.Retry) {
            newCcs.auditlogEventQueue = [...newCcs.auditlogEventQueue, ...queuedEvents];
          }
          return newCcs;
        }), "result");
      });
    }
    onlineAuditlogWriteEvents(orgId, ...events) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("auditlogWriteQueuedEvents", (_a3) => __awaiter$8(this, void 0, void 0, function* () {
          var ccs = __rest(_a3, []);
          const queuedEvents = events.map((event) => Object.assign({ organizationId: orgId }, event));
          return onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, queuedEvents);
        }), "result");
      });
    }
    onlineAuditlogGetEvents(orgId, page, filter2, anchor, cancelToken) {
      return __awaiter$8(this, void 0, void 0, function* () {
        const auditlogClient = yield this.onlineGetAuditlogAdminClient(orgId, cancelToken);
        const { events, totalCount, timeAnchor: newTimeAnchor } = yield auditlogClient.listEvents(page, filter2, anchor, cancelToken);
        return {
          events: events.map((e2) => AuditlogEventEnvelope.parse(JSON.parse(e2))),
          totalCount,
          timeAnchor: newTimeAnchor
        };
      });
    }
    onlineGetAuditlogAdminClient(orgId, cancelToken) {
      return __awaiter$8(this, void 0, void 0, function* () {
        const token = yield this.backendClient.credential.createAuditlogAdminToken(orgId, cancelToken);
        return this.backendClient.getAuditlogAdminClient(token);
      });
    }
    onlineCreateRefreshedClientCoreParameters() {
      return __awaiter$8(this, void 0, void 0, function* () {
        const currentCcp = this.getClientCoreParameters();
        const newToken = yield this.backendClient.credential.refreshToken();
        const newCcp = Object.assign(Object.assign({}, currentCcp), { loginData: Object.assign(Object.assign({}, currentCcp.loginData), { token: newToken }) });
        return newCcp;
      });
    }
    onlineOrganizationRenewStartCodes(orgId, ...profileIds) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRenewStartCodes", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.organization.renewProfileStartCode(orgId, ...profileIds);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationSendStartCodeEmails(orgId, ...profileIds) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationSendStartCodeEmails", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.organization.sendStartCodeEmail(orgId, ...profileIds);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationRevokeStartCodes(orgId, ...profileIds) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRevokeStartCodes", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.organization.revokeProfileStartCode(orgId, ...profileIds);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationGetBreachData(organizationId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.backendClient.organization.getBreachData(organizationId);
      });
    }
    onlineOrganizationStoreUnsafeVaultContents(organizationId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("onlineOrganizationStoreUnsafeVaultStates", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalOrganizationStoreUnsafeVaultContents(ccs, organizationId);
        }), "result");
      });
    }
    onlineOrganizationRestoreUnsafeVaultContents(organizationId) {
      return __awaiter$8(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("onlineOrganizationRestoreVaultStates", (ccs) => __awaiter$8(this, void 0, void 0, function* () {
          return onlineInternalOrganizationRestoreUnsafeVaultContents(ccs, organizationId);
        }), "result");
      });
    }
    debugEmitClientCoreParametersRefreshNeeded() {
      return __awaiter$8(this, void 0, void 0, function* () {
        yield this.emitter.emit("clientCoreParametersRefreshNeeded");
      });
    }
    getClientCoreState() {
      return {
        params: this.params,
        pinnedAuthenticatorSecret: this.pinnedAuthenticatorSecret,
        vaultRepo: this.vaultRepo,
        profileRepo: this.profileRepo,
        accountState: this.accountState,
        protectedSecretRepo: this.protectedSecretRepo,
        syncVersion: this.syncVersion,
        tokenRefreshNeeded: this.tokenRefreshNeeded,
        superUserUnlockedAuthenticators: this.superUserUnlockedAuthenticators,
        foreignVaultSyncPredicate: this.foreignVaultSyncPredicate,
        ephemeralForeignVaultSyncPredicate: this.ephemeralForeignVaultSyncPredicate,
        ignoredUnlock: this.ignoredUnlock,
        maintenanceSettings: this.maintenanceSettings,
        lastKnownServerTime: this.lastKnownServerTime,
        clientOutdated: this.clientOutdated,
        clientServerTimeOffsetMs: this.clientServerTimeOffsetMs,
        auditlogEventQueue: this.auditlogEventQueue,
        auditlogWriteTokenCache: this.auditlogWriteTokenCache
      };
    }
  };
  ClientCore = ClientCore_1 = __decorate$2([
    Emittery$1.mixin("emitter")
  ], ClientCore);
  function getDummySecretSeedFromSecretInfo(secretInfo) {
    const { seed } = jsonParseThaw(secretInfo);
    return seed;
  }
  var __decorate$1 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var LongPollUpdateEmitter_1;
  let LongPollUpdateEmitter = LongPollUpdateEmitter_1 = class LongPollUpdateEmitter {
    constructor(backendClient, requestUnlock) {
      this.backendClient = backendClient;
      this.cancelToken = new CancelToken();
      this.longPollLoopUntilCancelled(requestUnlock).catch((error2) => __awaiter$7(this, void 0, void 0, function* () {
        if (this.cancelToken.isCancelled) {
          return;
        }
        if (error2 instanceof Cancel) {
          return this.emitter.emit("cancel");
        } else {
          return this.emitter.emit("error", { error: error2 });
        }
      }));
    }
    longPollLoopUntilCancelled(requestUnlock) {
      return __awaiter$7(this, void 0, void 0, function* () {
        let message = yield this.backendClient.withSyncVersion(0).sync.longPoll(this.cancelToken, requestUnlock);
        let updateSyncVersion = message.syncVersion;
        yield this.emitter.emit("message", { message });
        while (!this.cancelToken.isCancelled) {
          message = yield this.backendClient.withSyncVersion(updateSyncVersion).sync.longPoll(this.cancelToken, false);
          updateSyncVersion = message.syncVersion;
          yield this.emitter.emit("message", { message });
        }
      });
    }
    static fromLoginData(loginData, backendClient) {
      const authorizedBackendClient = backendClient.withLogin(loginData);
      return new LongPollUpdateEmitter_1(authorizedBackendClient, false);
    }
    static fromClientCore(clientCore, requestUnlock) {
      return new LongPollUpdateEmitter_1(clientCore.backendClient, requestUnlock);
    }
    close() {
      this.cancelToken.cancel();
      this.emitter.emit("cancel").catch(trackError);
      this.emitter.clearListeners();
    }
  };
  LongPollUpdateEmitter = LongPollUpdateEmitter_1 = __decorate$1([
    Emittery$1.mixin("emitter")
  ], LongPollUpdateEmitter);
  const LongPollUpdateEmitter$1 = LongPollUpdateEmitter;
  class StreamingUpdateEmitter {
    constructor(backendClient, requestUnlock) {
      this.backendClient = backendClient;
      this.cancelToken = new CancelToken();
      this.emitter = backendClient.sync.streamingSync(this.cancelToken, requestUnlock);
      this.emitter.bindMethods(this);
    }
    static fromLoginData(loginData, backendClient) {
      const authorizedBackendClient = backendClient.withLogin(loginData);
      return new StreamingUpdateEmitter(authorizedBackendClient, false);
    }
    static fromClientCore(clientCore, requestUnlock) {
      var _a3;
      const backendClient = clientCore.backendClient.withSyncVersion((_a3 = clientCore.syncVersion) !== null && _a3 !== void 0 ? _a3 : void 0);
      return new StreamingUpdateEmitter(backendClient, requestUnlock);
    }
    close() {
      this.emitter.clearListeners();
      this.cancelToken.cancel();
    }
  }
  var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function runWithCancel(cb2, onCancel, cancelToken) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (cancelToken) {
        try {
          yield Promise.race([cb2(), waitForCancel(cancelToken)]);
        } catch (e2) {
          if (e2 instanceof Cancel) {
            yield onCancel();
            return;
          }
          throw e2;
        }
      } else {
        yield cb2();
      }
    });
  }
  function waitForCancel(cancelToken) {
    return new Promise((_2, reject) => cancelToken.onCancel(() => {
      reject(new Cancel());
    }));
  }
  var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues = globalThis && globalThis.__asyncValues || function(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d2, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d2 });
      }, reject);
    }
  };
  let ClientCoreSync = class ClientCoreSync {
    constructor(clientCore, { performMaintenanceAfterSync = true, minReconnectDelayMs = 3e3, stateStore = {} } = {}) {
      this.clientCore = clientCore;
      this.autoSyncLocalChanges = true;
      this.autoSyncRemoteChanges = true;
      this.internalUpdateEmitter = null;
      this.isInitialSyncResponse = false;
      this.isSyncEnabled = false;
      this.isDelayExtendUnlock = false;
      this.syncConnectionMode = "streaming";
      this.handleUpdateEmitterMessage = ({ message }) => {
        this.stateStore.lastConnectAttempt = 0;
        if (!this.autoSyncRemoteChanges) {
          return;
        }
        let eventOrigin;
        if (this.isInitialSyncResponse) {
          this.isInitialSyncResponse = false;
          debugConsole.log("Initial sync successful");
          eventOrigin = "init";
        } else {
          eventOrigin = "push";
        }
        this.onlineSyncNonBlocking(message, eventOrigin);
      };
      this.handleClientCoreLocalVaultChange = () => {
        if (this.autoSyncLocalChanges) {
          this.onlineSyncNonBlocking(null);
        }
      };
      this.handleSyncEnd = () => {
        this.scheduleUnlockTimeouts();
      };
      this.performMaintenanceAfterSync = performMaintenanceAfterSync;
      this.minReconnectDelayMs = minReconnectDelayMs;
      this.stateStore = stateStore;
      const { clientType } = clientCore.backendClient.config;
      const { preferLongPollForProtoClientTypes } = clientCore.accountState.serverSideSettings;
      if (clientType && (preferLongPollForProtoClientTypes === null || preferLongPollForProtoClientTypes === void 0 ? void 0 : preferLongPollForProtoClientTypes.includes(clientType))) {
        this.syncConnectionMode = "longPoll";
      }
    }
    open() {
      this.isSyncEnabled = true;
      this.reconnectWithDelay();
      this.clientCore.on("localVaultChange", this.handleClientCoreLocalVaultChange);
      this.clientCore.on("syncEnd", this.handleSyncEnd);
    }
    close() {
      this.isSyncEnabled = false;
      this.disconnect();
      this.clientCore.off("localVaultChange", this.handleClientCoreLocalVaultChange);
      this.clientCore.off("syncEnd", this.handleSyncEnd);
      if (this.unlockExpirationTimeoutId) {
        clearTimeout(this.unlockExpirationTimeoutId);
        this.unlockExpirationTimeoutId = void 0;
      }
      if (this.unlockExtensionTimeoutId) {
        clearTimeout(this.unlockExtensionTimeoutId);
        this.unlockExtensionTimeoutId = void 0;
      }
      if (this.maintenanceTaskTimeoutId) {
        clearTimeout(this.maintenanceTaskTimeoutId);
        this.maintenanceTaskTimeoutId = void 0;
      }
      if (this.reconnectTimeoutId) {
        clearTimeout(this.reconnectTimeoutId);
        this.reconnectTimeoutId = void 0;
      }
    }
    reconnectIfNecessary(requestUnlock = false) {
      if (this.internalUpdateEmitter) {
        return;
      }
      this.reconnect(requestUnlock);
    }
    disconnect() {
      if (this.internalUpdateEmitter) {
        this.internalUpdateEmitter.close();
        this.internalUpdateEmitter = null;
      }
    }
    setSyncConnectionMode(mode2, origin = "explicit") {
      if (this.syncConnectionMode === mode2) {
        return;
      }
      const keepConnection = mode2 === "streaming" && this.syncConnectionMode === "streamingOrFallback";
      this.syncConnectionMode = mode2;
      this.emitter.emit("syncConnectionModeChange", { mode: mode2, origin }).catch(trackError);
      if (!keepConnection) {
        this.reconnect();
      }
    }
    getSyncConnectionMode() {
      return this.syncConnectionMode;
    }
    setDelayExtendUnlock(delayExtendUnlock) {
      this.isDelayExtendUnlock = delayExtendUnlock;
    }
    reconnectWithDelay(requestUnlock = false) {
      var _a3;
      this.disconnect();
      if (!this.isSyncEnabled) {
        return;
      }
      const now = /* @__PURE__ */ new Date();
      if (this.minReconnectDelayMs === null) {
        return;
      }
      if (!this.stateStore.lastConnectAttemptDate) {
        debugConsole.log("Reconnecting immediately, no last connect attempt date known");
        this.reconnectIfNecessary(requestUnlock);
        return;
      }
      if (this.stateStore.lastConnectAttempt === 0) {
        debugConsole.log(`Reconnecting event stream immediately`);
        this.stateStore.lastConnectAttempt += 1;
        this.reconnectIfNecessary(requestUnlock);
        return;
      }
      let reconnectDelay = this.minReconnectDelayMs;
      const lastConnectAttempt = (_a3 = this.stateStore.lastConnectAttempt) !== null && _a3 !== void 0 ? _a3 : 0;
      reconnectDelay *= Math.pow(2, Math.min(lastConnectAttempt - 1, 5));
      this.stateStore.lastConnectAttempt = lastConnectAttempt + 1;
      const timeSinceLastConnect = now.getTime() - this.stateStore.lastConnectAttemptDate.getTime();
      const effectiveDelay = Math.max(500, reconnectDelay - timeSinceLastConnect);
      debugConsole.log(`Reconnecting event stream in ${effectiveDelay / 1e3} seconds... ${requestUnlock ? "(With unlock)" : ""}`);
      this.reconnectTimeoutId = setTimeout(this.reconnectIfNecessary.bind(this, requestUnlock), effectiveDelay);
    }
    reconnectRequestingUnlock() {
      this.reconnect(true);
    }
    reconnect(requestUnlock = false) {
      this.disconnect();
      if (this.reconnectTimeoutId) {
        clearTimeout(this.reconnectTimeoutId);
        this.reconnectTimeoutId = void 0;
      }
      if (!this.isSyncEnabled) {
        return;
      }
      this.stateStore.lastConnectAttemptDate = /* @__PURE__ */ new Date();
      this.isInitialSyncResponse = true;
      this.internalUpdateEmitter = this.syncConnectionMode === "longPoll" ? LongPollUpdateEmitter$1.fromClientCore(this.clientCore, requestUnlock) : StreamingUpdateEmitter.fromClientCore(this.clientCore, requestUnlock);
      this.internalUpdateEmitter.on("message", this.handleUpdateEmitterMessage);
      this.internalUpdateEmitter.on("error", ({ error: error2 }) => {
        debugConsole.log("Event stream disconnected due to error.", error2);
        if (error2 instanceof NoResponseError) {
          this.emitter.emit("recoverableSyncError", { error: error2 }).catch(trackError);
          this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
          return;
        }
        if (error2 instanceof BackendDomainError && error2.code === BackendErrorCode.CANCELED) {
          if (this.isSyncEnabled) {
            this.emitter.emit("recoverableSyncCancel", {}).catch(trackError);
          }
          this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
          return;
        }
        if (error2 instanceof InvalidGrpcResponseError) {
          this.emitter.emit("recoverableSyncError", { error: error2 }).catch(trackError);
          if (this.stateStore.lastConnectAttempt === 0) {
            trackError(error2);
          }
          this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
          return;
        }
        debugConsole.log("Sync stream error not recoverable, giving up.", error2);
        this.disconnect();
        this.emitter.emit("syncError", { error: error2 }).catch(trackError);
      });
      this.internalUpdateEmitter.on("cancel", () => {
        if (this.isSyncEnabled) {
          this.emitter.emit("recoverableSyncCancel", {}).catch(trackError);
        }
        this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
      });
      if (this.syncConnectionMode === "streamingOrFallback") {
        const initialSyncTimeout = setTimeout(() => {
          debugConsole.log("[clientCoreSync]", "switching to long poll after 5s no response");
          this.setSyncConnectionMode("longPoll", "fallback");
        }, 5e3);
        const clearOnAny = this.internalUpdateEmitter.onAny((...args) => {
          debugConsole.log("[clientCoreSync]", "canceling switch to longpoll", args);
          clearTimeout(initialSyncTimeout);
          clearOnAny();
          this.setSyncConnectionMode("streaming", "fallback");
        });
      }
    }
    /**
     * Triggers a sync that cannot be awaited. Sync errors emit syncError events.
     */
    onlineSyncNonBlocking(syncUpdate, eventOrigin = "poll") {
      this.sync(syncUpdate, eventOrigin).catch(trackError);
    }
    requestUnlock(cancelToken) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.startRequestUnlock(cancelToken);
        yield this.finishRequestUnlock(cancelToken);
      });
    }
    startRequestUnlock(cancelToken) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (this.clientCore.isUnlocked()) {
          return;
        }
        const syncEvents = this.clientCore.events("syncEnd");
        this.reconnectRequestingUnlock();
        yield runWithCancel(() => __awaiter$5(this, void 0, void 0, function* () {
          var _a3, e_1, _b, _c2;
          try {
            for (var _d = true, syncEvents_1 = __asyncValues(syncEvents), syncEvents_1_1; syncEvents_1_1 = yield syncEvents_1.next(), _a3 = syncEvents_1_1.done, !_a3; _d = true) {
              _c2 = syncEvents_1_1.value;
              _d = false;
              const _2 = _c2;
              if (this.clientCore.isUnlocked()) {
                return;
              }
              if (this.clientCore.getSession().unlockRequestedAt !== void 0) {
                return;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a3 && (_b = syncEvents_1.return))
                yield _b.call(syncEvents_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }), () => __awaiter$5(this, void 0, void 0, function* () {
          yield this.clientCore.onlineCancelRequestSessionUnlock(this.clientCore.getSessionId());
          throw new Cancel();
        }), cancelToken);
      });
    }
    finishRequestUnlock(cancelToken) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (this.clientCore.isUnlocked()) {
          return;
        }
        if (this.clientCore.getSession().unlockRequestedAt === void 0) {
          throw new UnlockRejectedError();
        }
        const syncEvents = this.clientCore.events("syncEnd");
        yield this.tryUnlockingWithDummyAuth();
        yield runWithCancel(() => __awaiter$5(this, void 0, void 0, function* () {
          var _a3, e_2, _b, _c2;
          try {
            for (var _d = true, syncEvents_2 = __asyncValues(syncEvents), syncEvents_2_1; syncEvents_2_1 = yield syncEvents_2.next(), _a3 = syncEvents_2_1.done, !_a3; _d = true) {
              _c2 = syncEvents_2_1.value;
              _d = false;
              const _2 = _c2;
              if (this.clientCore.isUnlocked()) {
                return;
              }
              if (this.clientCore.getSession().unlockRequestedAt === void 0) {
                throw new UnlockRejectedError();
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (!_d && !_a3 && (_b = syncEvents_2.return))
                yield _b.call(syncEvents_2);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }), () => __awaiter$5(this, void 0, void 0, function* () {
          yield this.clientCore.onlineCancelRequestSessionUnlock(this.clientCore.getSessionId());
          throw new Cancel();
        }), cancelToken);
      });
    }
    tryUnlockingWithDummyAuth() {
      var _a3;
      return __awaiter$5(this, void 0, void 0, function* () {
        const currentAuth = this.clientCore.params.unlockedAuthenticator.authenticator;
        if (currentAuth.authenticatorType !== AuthenticatorType.DUMMY) {
          return;
        }
        if (this.isInitialSyncResponse) {
          yield (_a3 = this.internalUpdateEmitter) === null || _a3 === void 0 ? void 0 : _a3.once("message");
        }
        const hsc = HighSecurityCache.fromSecret({
          authenticatorId: currentAuth.id,
          seed: getDummySecretSeedFromSecretInfo(currentAuth.secretInfo)
        }, currentAuth);
        const meta = this.clientCore.getSessionMetaById(this.clientCore.getSessionId());
        if (!meta || !meta.encPubKey || !meta.encPubKeySignature) {
          return;
        }
        const encPubKey = loadEncryptionPublicKey(meta.encPubKey);
        const encPubKeySignature = loadEncryptionPublicKeySignature(meta.encPubKeySignature);
        const trustedSigPubKeys = [currentAuth.storableSigPubKey];
        const expiresAt = getUnlockTime();
        yield this.clientCore.onlineCreateSessionUnlock(this.clientCore.getSessionId(), encPubKey, encPubKeySignature, trustedSigPubKeys, hsc, expiresAt);
      });
    }
    sync(syncUpdate, eventOrigin) {
      return __awaiter$5(this, void 0, void 0, function* () {
        try {
          if (!syncUpdate) {
            yield this.clientCore.onlineSync();
          } else {
            if (eventOrigin === "push" && syncUpdate.syncVersion === this.clientCore.syncVersion) {
              return;
            }
            this.emitter.emit("syncUpdate", { eventOrigin, syncUpdate }).catch(trackError);
            yield this.clientCore.onlineSyncWithUpdate(syncUpdate, eventOrigin);
          }
          this.checkLongPollSetting();
          this.scheduleMaintenanceTasks();
        } catch (error2) {
          if (error2 instanceof InvalidGrpcResponseError || error2 instanceof NoResponseError) {
            yield this.emitter.emit("recoverableSyncError", { error: error2 });
          } else if (error2 instanceof Error) {
            yield this.emitter.emit("syncError", { error: error2 });
          } else {
            yield this.emitter.emit("syncError", { error: new Error(`${error2}`) });
          }
        }
      });
    }
    checkLongPollSetting() {
      if (this.syncConnectionMode === "longPoll") {
        return;
      }
      const { clientType } = this.clientCore.backendClient.config;
      const { preferLongPollForProtoClientTypes } = this.clientCore.accountState.serverSideSettings;
      if (clientType && (preferLongPollForProtoClientTypes === null || preferLongPollForProtoClientTypes === void 0 ? void 0 : preferLongPollForProtoClientTypes.includes(clientType))) {
        this.setSyncConnectionMode("longPoll", "serverSideSetting");
      }
    }
    scheduleUnlockTimeouts() {
      if (this.unlockExpirationTimeoutId) {
        clearTimeout(this.unlockExpirationTimeoutId);
        this.unlockExpirationTimeoutId = void 0;
      }
      if (this.unlockExtensionTimeoutId) {
        clearTimeout(this.unlockExtensionTimeoutId);
        this.unlockExtensionTimeoutId = void 0;
      }
      if (this.clientCore.vaultRepo.isInitialized() && !this.clientCore.isUnlocked()) {
        return;
      }
      if (this.clientCore.isPinnedUnlocked()) {
        return;
      }
      const { unlockedAt, unlockExtendAt, unlockedUntil } = this.clientCore.getSession();
      if (!unlockedAt) {
        this.clientCore.lockAllVaults().catch(trackError);
        return;
      }
      if (unlockedUntil) {
        const unlockDurationMs = unlockedUntil.getTime() - Date.now();
        this.unlockExpirationTimeoutId = setTimeout(() => {
          this.clientCore.lockAllVaults().catch(trackError);
        }, unlockDurationMs);
        if (unlockExtendAt) {
          const extendSessionTime = unlockExtendAt.getTime() - Date.now() + (this.isDelayExtendUnlock ? 5e3 : 0);
          this.unlockExtensionTimeoutId = setTimeout(() => {
            this.extendSessionIfNecessary();
          }, extendSessionTime);
        }
      }
    }
    pingActivity() {
      const now = /* @__PURE__ */ new Date();
      if (this.lastUserActivityDate && this.lastUserActivityDate.getTime() > now.getTime() - 10 * 1e3) {
        return;
      }
      this.lastUserActivityDate = now;
      this.extendSessionIfNecessary();
    }
    extendSessionIfNecessary() {
      if (!this.lastUserActivityDate) {
        return;
      }
      const session = this.clientCore.getSession();
      const { unlockedAt, unlockExtendAt, unlockedUntil } = session;
      if (!unlockedAt || !unlockExtendAt || unlockExtendAt.getTime() > Date.now() || unlockedUntil && unlockedUntil.getTime() < Date.now()) {
        return;
      }
      const lastUserActivity = this.lastUserActivityDate;
      this.lastUserActivityDate = void 0;
      this.clientCore.onlineExtendSessionUnlock(lastUserActivity).catch((e2) => {
        if (e2 instanceof NoResponseError) {
          return;
        }
        if (e2 instanceof DomainError$1) {
          switch (e2.code) {
            case BackendErrorCode.SESSION_NOT_UNLOCKED:
            case BackendErrorCode.SESSION_NOT_FOUND:
              return;
          }
        }
        throw e2;
      }).catch(trackError);
    }
    scheduleMaintenanceTasks() {
      if (!this.performMaintenanceAfterSync) {
        return;
      }
      if (this.maintenanceTaskTimeoutId) {
        clearTimeout(this.maintenanceTaskTimeoutId);
        this.maintenanceTaskTimeoutId = void 0;
      }
      const delay = 1e3 + Math.random() * 2e3;
      this.maintenanceTaskTimeoutId = setTimeout(() => {
        this.clientCore.onlinePerformMaintenance().catch(trackError);
      }, delay);
    }
  };
  ClientCoreSync = __decorate([
    Emittery$1.mixin("emitter")
  ], ClientCoreSync);
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function filterUnprotectedCustomFields(customFields) {
    const totpField = customFields === null || customFields === void 0 ? void 0 : customFields.find((f2) => f2.protected && f2.name.toLowerCase().includes("totp"));
    const remainingFields = customFields.filter((cf2) => cf2 !== totpField);
    return {
      totpField,
      remainingFields
    };
  }
  function getLoginDisplayLabel(login) {
    var _a3, _b, _c2, _d, _e;
    if ((_a3 = login.title) === null || _a3 === void 0 ? void 0 : _a3.trim()) {
      return login.title.trim();
    }
    if (login.uiType === LoginUiType.creditCard && ((_c2 = (_b = login.creditCard) === null || _b === void 0 ? void 0 : _b.displayType) === null || _c2 === void 0 ? void 0 : _c2.trim())) {
      return login.creditCard.displayType.trim();
    }
    if (login.uiType === LoginUiType.wifi && ((_d = login.wifiSsid) === null || _d === void 0 ? void 0 : _d.trim())) {
      return login.wifiSsid.trim();
    }
    if ((_e = login.username) === null || _e === void 0 ? void 0 : _e.trim()) {
      return login.username.trim();
    }
    return void 0;
  }
  const relatedDomainsDictionary = {
    "3docean.net": [
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "audiojungle.net": [
      "3docean.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "codecanyon.net": [
      "3docean.net",
      "audiojungle.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "envato.com": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "graphicriver.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "photodune.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "placeit.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "themeforest.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "tutsplus.com": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "videohive.net"
    ],
    "videohive.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com"
    ],
    "airbnb.com.ar": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.au": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.at": [
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.be": [
      "airbnb.at",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.bz": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.bo": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.br": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.ca": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.cl": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.co": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.cr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.cz": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.dk": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.ec": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.sv": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.fi": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.fr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.de": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.gr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.gt": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.gy": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.hn": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.hk": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.hu": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.is": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.in": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.id": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.ie": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.it": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.jp": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.my": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.mt": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.mx": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.nl": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.nz": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.ni": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.no": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.pa": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.py": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.pe": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.pl": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.pt": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.ru": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.se"
    ],
    "airbnb.com.sg": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.kr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.es": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.se": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru"
    ],
    "airbnb.ch": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.tw": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.tr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.uk": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.ve": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airnewzealand.co.nz": [
      "airnewzealand.com",
      "airnewzealand.com.au"
    ],
    "airnewzealand.com": [
      "airnewzealand.co.nz",
      "airnewzealand.com.au"
    ],
    "airnewzealand.com.au": [
      "airnewzealand.co.nz",
      "airnewzealand.com"
    ],
    "albertsons.com": [
      "acmemarkets.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "acmemarkets.com": [
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "carrsqc.com": [
      "acmemarkets.com",
      "albertsons.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "jewelosco.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "pavilions.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "randalls.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "safeway.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "shaws.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "starmarket.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "tomthumb.com",
      "vons.com"
    ],
    "tomthumb.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "vons.com"
    ],
    "vons.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com"
    ],
    "alelo.com.br": [
      "meualelo.com.br"
    ],
    "meualelo.com.br": [
      "alelo.com.br"
    ],
    "ana.co.jp": [
      "astyle.jp"
    ],
    "astyle.jp": [
      "ana.co.jp"
    ],
    "angel.co": [
      "wellfound.com"
    ],
    "anthem.com": [
      "sydneyhealth.com"
    ],
    "sydneyhealth.com": [
      "anthem.com"
    ],
    "appannie.com": [
      "data.ai"
    ],
    "bgg.cc": [
      "boardgamegeek.com",
      "rpggeek.com",
      "videogamegeek.com"
    ],
    "boardgamegeek.com": [
      "bgg.cc",
      "rpggeek.com",
      "videogamegeek.com"
    ],
    "rpggeek.com": [
      "bgg.cc",
      "boardgamegeek.com",
      "videogamegeek.com"
    ],
    "videogamegeek.com": [
      "bgg.cc",
      "boardgamegeek.com",
      "rpggeek.com"
    ],
    "centralfcu.org": [
      "centralfcu.com"
    ],
    "centralfcu.com": [
      "centralfcu.org"
    ],
    "coolblue.nl": [
      "coolblue.be",
      "coolblue.de"
    ],
    "coolblue.be": [
      "coolblue.de",
      "coolblue.nl"
    ],
    "coolblue.de": [
      "coolblue.be",
      "coolblue.nl"
    ],
    "dan.org": [
      "diversalertnetwork.org"
    ],
    "diversalertnetwork.org": [
      "dan.org"
    ],
    "discordapp.com": [
      "discord.com"
    ],
    "discordmerch.com": [
      "discord.store"
    ],
    "discord.store": [
      "discordmerch.com"
    ],
    "discovercard.com": [
      "discover.com"
    ],
    "disney.com": [
      "disneyplus.com",
      "disneystore.com",
      "espn.com",
      "go.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "disneyplus.com": [
      "disney.com",
      "disneystore.com",
      "espn.com",
      "go.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "disneystore.com": [
      "disney.com",
      "disneyplus.com",
      "espn.com",
      "go.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "espn.com": [
      "disney.com",
      "disneyplus.com",
      "disneystore.com",
      "go.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "go.com": [
      "disney.com",
      "disneyplus.com",
      "disneystore.com",
      "espn.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "hulu.com": [
      "disney.com",
      "disneyplus.com",
      "disneystore.com",
      "espn.com",
      "go.com",
      "shopdisney.com"
    ],
    "shopdisney.com": [
      "disney.com",
      "disneyplus.com",
      "disneystore.com",
      "espn.com",
      "go.com",
      "hulu.com"
    ],
    "dnt.abine.com": [
      "ironvest.com"
    ],
    "ironvest.com": [
      "dnt.abine.com"
    ],
    "drivethrucards.com": [
      "dmsguild.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "drivethrucomics.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "drivethrufiction.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "drivethrurpg.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "dmsguild.com": [
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "pathfinderinfinite.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "storytellersvault.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "wargamevault.com"
    ],
    "wargamevault.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com"
    ],
    "ebay.at": [
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.be": [
      "ebay.at",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.ca": [
      "ebay.at",
      "ebay.be",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.ch": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.cn": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.co.th": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.co.uk": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.au": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.hk": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.my": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.sg": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.tw": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.de": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.es": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.fr": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.ie": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.it": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.nl": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.ph": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.pl": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.vn"
    ],
    "ebay.vn": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl"
    ],
    "epicgames.com": [
      "unrealengine.com"
    ],
    "unrealengine.com": [
      "epicgames.com"
    ],
    "eventbrite.at": [
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.be": [
      "eventbrite.at",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.ca": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.ch": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.cl": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.co": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.com": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.de": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.dk": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.es": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.fi": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.fr": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.hk": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.ie": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.in": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.it": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.my": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.nl": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.ph": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.pt": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.se": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.sg"
    ],
    "eventbrite.sg": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se"
    ],
    "fancourier.ro": [
      "selfawb.ro"
    ],
    "flyblade.com": [
      "blade.com"
    ],
    "gazduire.com.ro": [
      "admin.ro"
    ],
    "gazduire.net": [
      "admin.ro"
    ],
    "hbo.com": [
      "max.com"
    ],
    "hbomax.com": [
      "max.com"
    ],
    "hbonow.com": [
      "max.com"
    ],
    "heroku.com": [
      "verify.salesforce.com"
    ],
    "ing.de": [
      "ing.com"
    ],
    "instagram.com": [
      "threads.net"
    ],
    "threads.net": [
      "instagram.com"
    ],
    "letsdeel.com": [
      "deel.com"
    ],
    "login.airfrance.com": [
      "login.flyingblue.com",
      "login.klm.com"
    ],
    "login.flyingblue.com": [
      "login.airfrance.com",
      "login.klm.com"
    ],
    "login.klm.com": [
      "login.airfrance.com",
      "login.flyingblue.com"
    ],
    "lrz.de": [
      "mwn.de",
      "mytum.de",
      "tum.de",
      "tum.edu"
    ],
    "mwn.de": [
      "lrz.de",
      "mytum.de",
      "tum.de",
      "tum.edu"
    ],
    "mytum.de": [
      "lrz.de",
      "mwn.de",
      "tum.de",
      "tum.edu"
    ],
    "tum.de": [
      "lrz.de",
      "mwn.de",
      "mytum.de",
      "tum.edu"
    ],
    "tum.edu": [
      "lrz.de",
      "mwn.de",
      "mytum.de",
      "tum.de"
    ],
    "mercadolibre.cl": [
      "mercadolibre.com"
    ],
    "mercadolibre.co.cr": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.ar": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.bo": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.co": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.do": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.ec": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.gt": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.hn": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.mx": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.ni": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.pa": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.pe": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.py": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.sv": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.uy": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.ve": [
      "mercadolibre.com"
    ],
    "mercadopago.cl": [
      "mercadolibre.com"
    ],
    "mercadopago.com.ar": [
      "mercadolibre.com"
    ],
    "mercadopago.com.co": [
      "mercadolibre.com"
    ],
    "mercadopago.com.ec": [
      "mercadolibre.com"
    ],
    "mercadopago.com.mx": [
      "mercadolibre.com"
    ],
    "mercadopago.com.pe": [
      "mercadolibre.com"
    ],
    "mercadopago.com.uy": [
      "mercadolibre.com"
    ],
    "mercadopago.com.ve": [
      "mercadolibre.com"
    ],
    "mercadolivre.com.br": [
      "mercadolivre.com"
    ],
    "mercadopago.com.br": [
      "mercadolivre.com"
    ],
    "moneybird.nl": [
      "moneybird.com"
    ],
    "moneybird.de": [
      "moneybird.com"
    ],
    "nebula.app": [
      "nebula.tv"
    ],
    "watchnebula.com": [
      "nebula.tv"
    ],
    "nextinpact.com": [
      "next.ink"
    ],
    "nordvpn.com": [
      "nordaccount.com"
    ],
    "nordpass.com": [
      "nordaccount.com"
    ],
    "overstock.com": [
      "bedbathandbeyond.com"
    ],
    "parkmobile.us": [
      "parkmobile.io"
    ],
    "pinterest.com": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.ca": [
      "pinterest.at",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.co.uk": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.fr": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.de": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.es": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.com.au": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.se": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru"
    ],
    "pinterest.ph": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.ch": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.com.mx": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.dk": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.pt": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.ru": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.se"
    ],
    "pinterest.it": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.at": [
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.jp": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.cl": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.ie": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.co.kr": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.nz": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "postnl.nl": [
      "postnl.be"
    ],
    "postnl.be": [
      "postnl.nl"
    ],
    "pretendo.network": [
      "pretendo.cc"
    ],
    "pretendo.cc": [
      "pretendo.network"
    ],
    "proton.me": [
      "protonmail.ch",
      "protonmail.com",
      "protonvpn.com"
    ],
    "protonvpn.com": [
      "proton.me",
      "protonmail.ch",
      "protonmail.com"
    ],
    "protonmail.ch": [
      "proton.me",
      "protonmail.com",
      "protonvpn.com"
    ],
    "protonmail.com": [
      "proton.me",
      "protonmail.ch",
      "protonvpn.com"
    ],
    "quicken.com": [
      "simplifimoney.com"
    ],
    "simplifimoney.com": [
      "quicken.com"
    ],
    "raywenderlich.com": [
      "kodeco.com"
    ],
    "redis.com": [
      "redislabs.com"
    ],
    "redislabs.com": [
      "redis.com"
    ],
    "s.activision.com": [
      "profile.callofduty.com"
    ],
    "profile.callofduty.com": [
      "s.activision.com"
    ],
    "scottscheapflights.com": [
      "going.com"
    ],
    "steampowered.com": [
      "steamcommunity.com"
    ],
    "steamcommunity.com": [
      "steampowered.com"
    ],
    "taxhawk.com": [
      "express1040.com",
      "freetaxusa.com"
    ],
    "freetaxusa.com": [
      "express1040.com",
      "taxhawk.com"
    ],
    "express1040.com": [
      "freetaxusa.com",
      "taxhawk.com"
    ],
    "telegram.me": [
      "telegram.org"
    ],
    "ting.com": [
      "tingmobile.com"
    ],
    "tingmobile.com": [
      "ting.com"
    ],
    "transferwise.com": [
      "wise.com"
    ],
    "tvnow.de": [
      "auth.rtl.de",
      "rtlplus.com",
      "rtlplus.de"
    ],
    "tvnow.at": [
      "auth.rtl.de",
      "rtlplus.com",
      "rtlplus.de"
    ],
    "tvnow.ch": [
      "auth.rtl.de",
      "rtlplus.com",
      "rtlplus.de"
    ],
    "twitter.com": [
      "x.com"
    ],
    "uspowerboating.com": [
      "ussailing.org"
    ],
    "ussailing.org": [
      "uspowerboating.com"
    ],
    "wacom.eu": [
      "wacom.com"
    ],
    "wikipedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "mediawiki.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikibooks.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikidata.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikinews.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikiquote.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikisource.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikiversity.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikivoyage.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wiktionary.org"
    ],
    "wiktionary.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org"
    ],
    "commons.wikimedia.org": [
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "meta.wikimedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "incubator.wikimedia.org": [
      "commons.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "outreach.wikimedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "species.wikimedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikimania.wikimedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "www.seek.com.au": [
      "login.seek.com"
    ],
    "www.seek.co.nz": [
      "login.seek.com"
    ],
    "jobsdb.com": [
      "login.seek.com"
    ],
    "hk.jobsdb.com": [
      "login.seek.com"
    ],
    "sg.jobsdb.com": [
      "login.seek.com"
    ],
    "th.jobsdb.com": [
      "login.seek.com"
    ],
    "jobstreet.com": [
      "login.seek.com"
    ],
    "myjobstreet.jobstreet.co.id": [
      "login.seek.com"
    ],
    "myjobstreet.jobstreet.com.my": [
      "login.seek.com"
    ],
    "myjobstreet.jobstreet.com.ph": [
      "login.seek.com"
    ],
    "myjobstreet.jobstreet.com.sg": [
      "login.seek.com"
    ],
    "www.vistaprint.ca": [
      "account.vistaprint.com"
    ],
    "youneedabudget.com": [
      "ynab.com"
    ],
    "aa.com": [
      "americanairlines.com",
      "americanairlines.jp"
    ],
    "americanairlines.com": [
      "aa.com",
      "americanairlines.jp"
    ],
    "americanairlines.jp": [
      "aa.com",
      "americanairlines.com"
    ],
    "aetna.com": [
      "banneraetna.myplanportal.com"
    ],
    "banneraetna.myplanportal.com": [
      "aetna.com"
    ],
    "alibaba.com": [
      "aliexpress.com"
    ],
    "aliexpress.com": [
      "alibaba.com"
    ],
    "alltrails.com": [
      "alltrails.io"
    ],
    "alltrails.io": [
      "alltrails.com"
    ],
    "amazon.com": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.ae": [
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.com.au": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.com.br": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.ca": [
      "amazon.ae",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.fr": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.de": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.in": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.it": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.com.mx": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.nl": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.es": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.com.tr": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.co.uk": [
      "amazon.ae",
      "amazon.ca",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.sa": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.sg": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se"
    ],
    "amazon.se": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.sg"
    ],
    "amazon.pl": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amcrestcloud.com": [
      "amcrestview.com"
    ],
    "amcrestview.com": [
      "amcrestcloud.com"
    ],
    "americastestkitchen.com": [
      "cookscountry.com",
      "cooksillustrated.com",
      "onlinecookingschool.com"
    ],
    "cooksillustrated.com": [
      "americastestkitchen.com",
      "cookscountry.com",
      "onlinecookingschool.com"
    ],
    "cookscountry.com": [
      "americastestkitchen.com",
      "cooksillustrated.com",
      "onlinecookingschool.com"
    ],
    "onlinecookingschool.com": [
      "americastestkitchen.com",
      "cookscountry.com",
      "cooksillustrated.com"
    ],
    "ameritrade.com": [
      "tdameritrade.com"
    ],
    "tdameritrade.com": [
      "ameritrade.com"
    ],
    "anylist.com": [
      "anylistapp.com"
    ],
    "anylistapp.com": [
      "anylist.com"
    ],
    "apple.com": [
      "icloud.com"
    ],
    "icloud.com": [
      "apple.com"
    ],
    "atlassian.com": [
      "trello.com"
    ],
    "trello.com": [
      "atlassian.com"
    ],
    "att.com": [
      "att.net"
    ],
    "att.net": [
      "att.com"
    ],
    "audi.com": [
      "audiusa.com"
    ],
    "audiusa.com": [
      "audi.com"
    ],
    "bahn.de": [
      "bahn.com"
    ],
    "bahn.com": [
      "bahn.de"
    ],
    "battle.net": [
      "blizzard.com"
    ],
    "blizzard.com": [
      "battle.net"
    ],
    "beachbodyondemand.com": [
      "teambeachbody.com"
    ],
    "teambeachbody.com": [
      "beachbodyondemand.com"
    ],
    "beavercreek.com": [
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "breckenridge.com": [
      "beavercreek.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "epicpass.com": [
      "beavercreek.com",
      "breckenridge.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "keystoneresort.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "kirkwood.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "mountsunapee.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "northstarcalifornia.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "okemo.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "parkcitymountain.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "skicb.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "skiheavenly.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "snow.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "stevenspass.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "stowe.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "vail.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "whistlerblackcomb.com"
    ],
    "whistlerblackcomb.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com"
    ],
    "boingo.com": [
      "boingohotspot.com"
    ],
    "boingohotspot.com": [
      "boingo.com"
    ],
    "bol.com": [
      "kobo.com"
    ],
    "kobo.com": [
      "bol.com"
    ],
    "boudinbakery.com": [
      "boudincatering.com"
    ],
    "boudincatering.com": [
      "boudinbakery.com"
    ],
    "braze.com": [
      "braze.eu"
    ],
    "braze.eu": [
      "braze.com"
    ],
    "capitalone.com": [
      "capitalone360.com"
    ],
    "capitalone360.com": [
      "capitalone.com"
    ],
    "cathaypacific.com": [
      "asiamiles.com"
    ],
    "asiamiles.com": [
      "cathaypacific.com"
    ],
    "citi.com": [
      "citibank.com",
      "citibankonline.com"
    ],
    "citibank.com": [
      "citi.com",
      "citibankonline.com"
    ],
    "citibankonline.com": [
      "citi.com",
      "citibank.com"
    ],
    "comcast.net": [
      "xfinity.com"
    ],
    "xfinity.com": [
      "comcast.net"
    ],
    "curbed.com": [
      "grubstreet.com",
      "nymag.com",
      "thecut.com",
      "vulture.com"
    ],
    "grubstreet.com": [
      "curbed.com",
      "nymag.com",
      "thecut.com",
      "vulture.com"
    ],
    "nymag.com": [
      "curbed.com",
      "grubstreet.com",
      "thecut.com",
      "vulture.com"
    ],
    "thecut.com": [
      "curbed.com",
      "grubstreet.com",
      "nymag.com",
      "vulture.com"
    ],
    "vulture.com": [
      "curbed.com",
      "grubstreet.com",
      "nymag.com",
      "thecut.com"
    ],
    "dinersclubnorthamerica.com": [
      "dinersclubus.com"
    ],
    "dinersclubus.com": [
      "dinersclubnorthamerica.com"
    ],
    "dish.com": [
      "dishnetwork.com",
      "mydish.com"
    ],
    "mydish.com": [
      "dish.com",
      "dishnetwork.com"
    ],
    "dishnetwork.com": [
      "dish.com",
      "mydish.com"
    ],
    "docusign.com": [
      "docusign.net"
    ],
    "docusign.net": [
      "docusign.com"
    ],
    "dropbox.com": [
      "getdropbox.com"
    ],
    "getdropbox.com": [
      "dropbox.com"
    ],
    "eater.com": [
      "polygon.com",
      "sbnation.com",
      "theverge.com"
    ],
    "polygon.com": [
      "eater.com",
      "sbnation.com",
      "theverge.com"
    ],
    "sbnation.com": [
      "eater.com",
      "polygon.com",
      "theverge.com"
    ],
    "theverge.com": [
      "eater.com",
      "polygon.com",
      "sbnation.com"
    ],
    "eurosport.no": [
      "eurosportplayer.com"
    ],
    "eurosportplayer.com": [
      "eurosport.no"
    ],
    "facebook.com": [
      "messenger.com"
    ],
    "messenger.com": [
      "facebook.com"
    ],
    "fandangonow.com": [
      "fandango.com"
    ],
    "fandango.com": [
      "fandangonow.com"
    ],
    "fidelity.com": [
      "fidelityinvestments.com"
    ],
    "fidelityinvestments.com": [
      "fidelity.com"
    ],
    "flyingblue.com": [
      "klm.com"
    ],
    "klm.com": [
      "flyingblue.com"
    ],
    "fnac.com": [
      "fnacspectacles.com"
    ],
    "fnacspectacles.com": [
      "fnac.com"
    ],
    "fourleaf.net": [
      "fourleaf.cl"
    ],
    "fourleaf.cl": [
      "fourleaf.net"
    ],
    "foursquare.com": [
      "swarmapp.com"
    ],
    "swarmapp.com": [
      "foursquare.com"
    ],
    "glassdoor.ca": [
      "glassdoor.com",
      "glassdoor.com.ar"
    ],
    "glassdoor.com": [
      "glassdoor.ca",
      "glassdoor.com.ar"
    ],
    "glassdoor.com.ar": [
      "glassdoor.ca",
      "glassdoor.com"
    ],
    "gogoair.com": [
      "gogoinflight.com"
    ],
    "gogoinflight.com": [
      "gogoair.com"
    ],
    "igen.fr": [
      "macg.co",
      "watchgeneration.fr"
    ],
    "watchgeneration.fr": [
      "igen.fr",
      "macg.co"
    ],
    "macg.co": [
      "igen.fr",
      "watchgeneration.fr"
    ],
    "ikonpass.com": [
      "skilynx.com"
    ],
    "skilynx.com": [
      "ikonpass.com"
    ],
    "intuit.com": [
      "mint.com"
    ],
    "mint.com": [
      "intuit.com"
    ],
    "kaiserpermanente.org": [
      "kp.org"
    ],
    "kp.org": [
      "kaiserpermanente.org"
    ],
    "kclibrary.overdrive.com": [
      "kclibrary.bibliocommons.com"
    ],
    "kclibrary.bibliocommons.com": [
      "kclibrary.overdrive.com"
    ],
    "kcls.bibliocommons.com": [
      "kcls.org",
      "kcls.overdrive.com"
    ],
    "kcls.overdrive.com": [
      "kcls.bibliocommons.com",
      "kcls.org"
    ],
    "kcls.org": [
      "kcls.bibliocommons.com",
      "kcls.overdrive.com"
    ],
    "liebherr.com": [
      "myliebherr.com"
    ],
    "myliebherr.com": [
      "liebherr.com"
    ],
    "logitech.com": [
      "astrogaming.com",
      "logi.com",
      "logitechg.com",
      "ultimateears.com"
    ],
    "logitechg.com": [
      "astrogaming.com",
      "logi.com",
      "logitech.com",
      "ultimateears.com"
    ],
    "logi.com": [
      "astrogaming.com",
      "logitech.com",
      "logitechg.com",
      "ultimateears.com"
    ],
    "astrogaming.com": [
      "logi.com",
      "logitech.com",
      "logitechg.com",
      "ultimateears.com"
    ],
    "ultimateears.com": [
      "astrogaming.com",
      "logi.com",
      "logitech.com",
      "logitechg.com"
    ],
    "lookmark.io": [
      "lookmark.link"
    ],
    "lookmark.link": [
      "lookmark.io"
    ],
    "lufthansa.com": [
      "miles-and-more.com"
    ],
    "miles-and-more.com": [
      "lufthansa.com"
    ],
    "marriott.com": [
      "marriottrewards.com",
      "ritzcarlton.com",
      "spg.com",
      "starwoodhotels.com"
    ],
    "marriottrewards.com": [
      "marriott.com",
      "ritzcarlton.com",
      "spg.com",
      "starwoodhotels.com"
    ],
    "ritzcarlton.com": [
      "marriott.com",
      "marriottrewards.com",
      "spg.com",
      "starwoodhotels.com"
    ],
    "spg.com": [
      "marriott.com",
      "marriottrewards.com",
      "ritzcarlton.com",
      "starwoodhotels.com"
    ],
    "starwoodhotels.com": [
      "marriott.com",
      "marriottrewards.com",
      "ritzcarlton.com",
      "spg.com"
    ],
    "microsoft.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "live.com": [
      "azure.com",
      "hotmail.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "microsoftonline.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "office.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "onenote.com",
      "skype.com"
    ],
    "skype.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com"
    ],
    "onenote.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "skype.com"
    ],
    "hotmail.com": [
      "azure.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "azure.com": [
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "minecraft.net": [
      "mojang.com"
    ],
    "mojang.com": [
      "minecraft.net"
    ],
    "mytotalconnectcomfort.com": [
      "tccna.honeywell.com"
    ],
    "tccna.honeywell.com": [
      "mytotalconnectcomfort.com"
    ],
    "myuhc.com": [
      "optum.com",
      "optumrx.com",
      "uhc.com"
    ],
    "uhc.com": [
      "myuhc.com",
      "optum.com",
      "optumrx.com"
    ],
    "optum.com": [
      "myuhc.com",
      "optumrx.com",
      "uhc.com"
    ],
    "optumrx.com": [
      "myuhc.com",
      "optum.com",
      "uhc.com"
    ],
    "neatorama.com": [
      "neatoshop.com"
    ],
    "neatoshop.com": [
      "neatorama.com"
    ],
    "newyorker.com": [
      "vanityfair.com"
    ],
    "vanityfair.com": [
      "newyorker.com"
    ],
    "nintendolife.com": [
      "purexbox.com",
      "pushsquare.com"
    ],
    "purexbox.com": [
      "nintendolife.com",
      "pushsquare.com"
    ],
    "pushsquare.com": [
      "nintendolife.com",
      "purexbox.com"
    ],
    "nokia.com": [
      "alcatel-lucent.com",
      "nsn-rdnet.net",
      "nsn.com"
    ],
    "alcatel-lucent.com": [
      "nokia.com",
      "nsn-rdnet.net",
      "nsn.com"
    ],
    "nsn-rdnet.net": [
      "alcatel-lucent.com",
      "nokia.com",
      "nsn.com"
    ],
    "nsn.com": [
      "alcatel-lucent.com",
      "nokia.com",
      "nsn-rdnet.net"
    ],
    "norwegian.com": [
      "norwegianreward.com"
    ],
    "norwegianreward.com": [
      "norwegian.com"
    ],
    "olo.com": [
      "olo.express"
    ],
    "olo.express": [
      "olo.com"
    ],
    "pocket.com": [
      "getpocket.com"
    ],
    "getpocket.com": [
      "pocket.com"
    ],
    "probikeshop.fr": [
      "bikeshop.es",
      "probikeshop.com",
      "probikeshop.it",
      "probikeshop.pt"
    ],
    "bikeshop.es": [
      "probikeshop.com",
      "probikeshop.fr",
      "probikeshop.it",
      "probikeshop.pt"
    ],
    "probikeshop.it": [
      "bikeshop.es",
      "probikeshop.com",
      "probikeshop.fr",
      "probikeshop.pt"
    ],
    "probikeshop.pt": [
      "bikeshop.es",
      "probikeshop.com",
      "probikeshop.fr",
      "probikeshop.it"
    ],
    "probikeshop.com": [
      "bikeshop.es",
      "probikeshop.fr",
      "probikeshop.it",
      "probikeshop.pt"
    ],
    "qnap.com": [
      "myqnapcloud.com"
    ],
    "myqnapcloud.com": [
      "qnap.com"
    ],
    "questdiagnostics.com": [
      "care360.com"
    ],
    "care360.com": [
      "questdiagnostics.com"
    ],
    "rocketaccount.com": [
      "rocketmortgage.com"
    ],
    "rocketmortgage.com": [
      "rocketaccount.com"
    ],
    "scholarshare529.com": [
      "secureaccountview.com"
    ],
    "secureaccountview.com": [
      "scholarshare529.com"
    ],
    "scoutingevent.com": [
      "campreservation.com"
    ],
    "campreservation.com": [
      "scoutingevent.com"
    ],
    "scribbr.com": [
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.de": [
      "scribbr.com",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.dk": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.es": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.fi": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.fr": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.it": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.nl": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.no": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.se"
    ],
    "scribbr.se": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no"
    ],
    "seattle.bibliocommons.com": [
      "spl.org",
      "spl.overdrive.com"
    ],
    "spl.overdrive.com": [
      "seattle.bibliocommons.com",
      "spl.org"
    ],
    "spl.org": [
      "seattle.bibliocommons.com",
      "spl.overdrive.com"
    ],
    "sfpl.bibliocommons.com": [
      "sfpl.overdrive.com"
    ],
    "sfpl.overdrive.com": [
      "sfpl.bibliocommons.com"
    ],
    "slcl.overdrive.com": [
      "slcl.org"
    ],
    "slcl.org": [
      "slcl.overdrive.com"
    ],
    "slpl.bibliocommons.com": [
      "slpl.overdrive.com"
    ],
    "slpl.overdrive.com": [
      "slpl.bibliocommons.com"
    ],
    "sonyentertainmentnetwork.com": [
      "sony.com"
    ],
    "sony.com": [
      "sonyentertainmentnetwork.com"
    ],
    "spark.net": [
      "jdate.com"
    ],
    "jdate.com": [
      "spark.net"
    ],
    "spirit.com": [
      "spirit-airlines.com"
    ],
    "spirit-airlines.com": [
      "spirit.com"
    ],
    "springfield.overdrive.com": [
      "coolcat.org"
    ],
    "coolcat.org": [
      "springfield.overdrive.com"
    ],
    "square.com": [
      "squareup.com"
    ],
    "squareup.com": [
      "square.com"
    ],
    "stackoverflow.com": [
      "askubuntu.com",
      "serverfault.com",
      "stackexchange.com",
      "superuser.com"
    ],
    "askubuntu.com": [
      "serverfault.com",
      "stackexchange.com",
      "stackoverflow.com",
      "superuser.com"
    ],
    "serverfault.com": [
      "askubuntu.com",
      "stackexchange.com",
      "stackoverflow.com",
      "superuser.com"
    ],
    "stackexchange.com": [
      "askubuntu.com",
      "serverfault.com",
      "stackoverflow.com",
      "superuser.com"
    ],
    "superuser.com": [
      "askubuntu.com",
      "serverfault.com",
      "stackexchange.com",
      "stackoverflow.com"
    ],
    "telekom-dienste.de": [
      "accounts.login.idm.telekom.com"
    ],
    "accounts.login.idm.telekom.com": [
      "telekom-dienste.de"
    ],
    "tesla.com": [
      "teslamotors.com"
    ],
    "teslamotors.com": [
      "tesla.com"
    ],
    "ticketmaster.com": [
      "livenation.com"
    ],
    "livenation.com": [
      "ticketmaster.com"
    ],
    "tp-link.com": [
      "tplinkcloud.com"
    ],
    "tplinkcloud.com": [
      "tp-link.com"
    ],
    "turkishairlines.com": [
      "thy.com"
    ],
    "thy.com": [
      "turkishairlines.com"
    ],
    "ubi.com": [
      "ubisoft.com"
    ],
    "ubisoft.com": [
      "ubi.com"
    ],
    "umsystem.edu": [
      "missouri.edu",
      "mst.edu",
      "umkc.edu",
      "umsl.edu"
    ],
    "mst.edu": [
      "missouri.edu",
      "umkc.edu",
      "umsl.edu",
      "umsystem.edu"
    ],
    "umkc.edu": [
      "missouri.edu",
      "mst.edu",
      "umsl.edu",
      "umsystem.edu"
    ],
    "umsl.edu": [
      "missouri.edu",
      "mst.edu",
      "umkc.edu",
      "umsystem.edu"
    ],
    "missouri.edu": [
      "mst.edu",
      "umkc.edu",
      "umsl.edu",
      "umsystem.edu"
    ],
    "united.com": [
      "unitedwifi.com"
    ],
    "unitedwifi.com": [
      "united.com"
    ],
    "verizon.com": [
      "verizonwireless.com",
      "vzw.com"
    ],
    "verizonwireless.com": [
      "verizon.com",
      "vzw.com"
    ],
    "vzw.com": [
      "verizon.com",
      "verizonwireless.com"
    ],
    "wayfair.com": [
      "allmodern.com",
      "birchlane.com",
      "jossandmain.com",
      "perigold.com",
      "wayfair.ca"
    ],
    "wayfair.ca": [
      "allmodern.com",
      "birchlane.com",
      "jossandmain.com",
      "perigold.com",
      "wayfair.com"
    ],
    "jossandmain.com": [
      "allmodern.com",
      "birchlane.com",
      "perigold.com",
      "wayfair.ca",
      "wayfair.com"
    ],
    "allmodern.com": [
      "birchlane.com",
      "jossandmain.com",
      "perigold.com",
      "wayfair.ca",
      "wayfair.com"
    ],
    "perigold.com": [
      "allmodern.com",
      "birchlane.com",
      "jossandmain.com",
      "wayfair.ca",
      "wayfair.com"
    ],
    "birchlane.com": [
      "allmodern.com",
      "jossandmain.com",
      "perigold.com",
      "wayfair.ca",
      "wayfair.com"
    ],
    "wellsfargo.com": [
      "wellsfargoadvisors.com"
    ],
    "wellsfargoadvisors.com": [
      "wellsfargo.com"
    ],
    "wiimmfi.de": [
      "wii-homebrew.com"
    ],
    "wii-homebrew.com": [
      "wiimmfi.de"
    ],
    "williams-sonoma.com": [
      "markandgraham.com",
      "potterybarn.com",
      "westelm.com"
    ],
    "markandgraham.com": [
      "potterybarn.com",
      "westelm.com",
      "williams-sonoma.com"
    ],
    "potterybarn.com": [
      "markandgraham.com",
      "westelm.com",
      "williams-sonoma.com"
    ],
    "westelm.com": [
      "markandgraham.com",
      "potterybarn.com",
      "williams-sonoma.com"
    ],
    "wilson.com": [
      "atecsports.com",
      "demarini.com",
      "evoshield.com",
      "luxilon.com",
      "slugger.com"
    ],
    "slugger.com": [
      "atecsports.com",
      "demarini.com",
      "evoshield.com",
      "luxilon.com",
      "wilson.com"
    ],
    "atecsports.com": [
      "demarini.com",
      "evoshield.com",
      "luxilon.com",
      "slugger.com",
      "wilson.com"
    ],
    "demarini.com": [
      "atecsports.com",
      "evoshield.com",
      "luxilon.com",
      "slugger.com",
      "wilson.com"
    ],
    "evoshield.com": [
      "atecsports.com",
      "demarini.com",
      "luxilon.com",
      "slugger.com",
      "wilson.com"
    ],
    "luxilon.com": [
      "atecsports.com",
      "demarini.com",
      "evoshield.com",
      "slugger.com",
      "wilson.com"
    ],
    "worldlink.com.np": [
      "nettv.com.np"
    ],
    "nettv.com.np": [
      "worldlink.com.np"
    ],
    "wsj.com": [
      "dowjones.com"
    ],
    "dowjones.com": [
      "wsj.com"
    ],
    "zixmail.net": [
      "zixmessagecenter.com"
    ],
    "zixmessagecenter.com": [
      "zixmail.net"
    ],
    "sackrace.ai": [],
    "poalim.xyz": [
      "poalim.site"
    ],
    "poalim.site": [
      "poalim.xyz"
    ],
    "nacion.com": [
      "elfinancierocr.com",
      "lateja.cr"
    ],
    "lateja.cr": [
      "elfinancierocr.com",
      "nacion.com"
    ],
    "elfinancierocr.com": [
      "lateja.cr",
      "nacion.com"
    ],
    "wp.pl": [
      "abczdrowie.pl",
      "money.pl",
      "o2.pl",
      "pudelek.pl",
      "wpext.pl"
    ],
    "o2.pl": [
      "abczdrowie.pl",
      "money.pl",
      "pudelek.pl",
      "wp.pl",
      "wpext.pl"
    ],
    "pudelek.pl": [
      "abczdrowie.pl",
      "money.pl",
      "o2.pl",
      "wp.pl",
      "wpext.pl"
    ],
    "money.pl": [
      "abczdrowie.pl",
      "o2.pl",
      "pudelek.pl",
      "wp.pl",
      "wpext.pl"
    ],
    "abczdrowie.pl": [
      "money.pl",
      "o2.pl",
      "pudelek.pl",
      "wp.pl",
      "wpext.pl"
    ],
    "wpext.pl": [
      "abczdrowie.pl",
      "money.pl",
      "o2.pl",
      "pudelek.pl",
      "wp.pl"
    ],
    "cafemedia.com": [
      "cardsayings.net",
      "nourishingpursuits.com"
    ],
    "cardsayings.net": [
      "cafemedia.com",
      "nourishingpursuits.com"
    ],
    "nourishingpursuits.com": [
      "cafemedia.com",
      "cardsayings.net"
    ],
    "bild.de": [
      "autobild.de",
      "computerbild.de",
      "welt.de",
      "wieistmeineip.de"
    ],
    "welt.de": [
      "autobild.de",
      "bild.de",
      "computerbild.de",
      "wieistmeineip.de"
    ],
    "autobild.de": [
      "bild.de",
      "computerbild.de",
      "welt.de",
      "wieistmeineip.de"
    ],
    "computerbild.de": [
      "autobild.de",
      "bild.de",
      "welt.de",
      "wieistmeineip.de"
    ],
    "wieistmeineip.de": [
      "autobild.de",
      "bild.de",
      "computerbild.de",
      "welt.de"
    ],
    "gliadomain.com": [
      "salemoveadvisor.com",
      "salemovefinancial.com",
      "salemovetravel.com"
    ],
    "salemoveadvisor.com": [
      "gliadomain.com",
      "salemovefinancial.com",
      "salemovetravel.com"
    ],
    "salemovefinancial.com": [
      "gliadomain.com",
      "salemoveadvisor.com",
      "salemovetravel.com"
    ],
    "salemovetravel.com": [
      "gliadomain.com",
      "salemoveadvisor.com",
      "salemovefinancial.com"
    ],
    "hapara.com": [
      "mystudentdashboard.com",
      "teacherdashboard.com"
    ],
    "teacherdashboard.com": [
      "hapara.com",
      "mystudentdashboard.com"
    ],
    "mystudentdashboard.com": [
      "hapara.com",
      "teacherdashboard.com"
    ],
    "songstats.com": [
      "songshare.com"
    ],
    "songshare.com": [
      "songstats.com"
    ],
    "hindustantimes.com": [
      "desimartini.com",
      "healthshots.com",
      "livehindustan.com",
      "livemint.com",
      "ottplay.com"
    ],
    "livemint.com": [
      "desimartini.com",
      "healthshots.com",
      "hindustantimes.com",
      "livehindustan.com",
      "ottplay.com"
    ],
    "livehindustan.com": [
      "desimartini.com",
      "healthshots.com",
      "hindustantimes.com",
      "livemint.com",
      "ottplay.com"
    ],
    "healthshots.com": [
      "desimartini.com",
      "hindustantimes.com",
      "livehindustan.com",
      "livemint.com",
      "ottplay.com"
    ],
    "ottplay.com": [
      "desimartini.com",
      "healthshots.com",
      "hindustantimes.com",
      "livehindustan.com",
      "livemint.com"
    ],
    "desimartini.com": [
      "healthshots.com",
      "hindustantimes.com",
      "livehindustan.com",
      "livemint.com",
      "ottplay.com"
    ],
    "landyrev.com": [
      "landyrev.ru"
    ],
    "landyrev.ru": [
      "landyrev.com"
    ],
    "jagran.com": [
      "gujaratijagran.com",
      "punjabijagran.com"
    ],
    "gujaratijagran.com": [
      "jagran.com",
      "punjabijagran.com"
    ],
    "punjabijagran.com": [
      "gujaratijagran.com",
      "jagran.com"
    ],
    "mercadolibre.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadolivre.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadopago.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "portalinmobiliario.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "tucarro.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com.ar": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com.br": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com.mx": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.cl": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com.co": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "tucarro.com.co": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.ve"
    ],
    "tucarro.com.ve": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co"
    ],
    "joyreactor.cc": [
      "cookreactor.com",
      "joyreactor.com",
      "reactor.cc"
    ],
    "reactor.cc": [
      "cookreactor.com",
      "joyreactor.cc",
      "joyreactor.com"
    ],
    "cookreactor.com": [
      "joyreactor.cc",
      "joyreactor.com",
      "reactor.cc"
    ],
    "joyreactor.com": [
      "cookreactor.com",
      "joyreactor.cc",
      "reactor.cc"
    ],
    "unotv.com": [
      "clarosports.com"
    ],
    "clarosports.com": [
      "unotv.com"
    ],
    "idbs-cloud.com": [
      "eworkbookcloud.com",
      "eworkbookrequest.com",
      "idbs-dev.com",
      "idbs-eworkbook.com",
      "idbs-staging.com"
    ],
    "idbs-dev.com": [
      "eworkbookcloud.com",
      "eworkbookrequest.com",
      "idbs-cloud.com",
      "idbs-eworkbook.com",
      "idbs-staging.com"
    ],
    "idbs-staging.com": [
      "eworkbookcloud.com",
      "eworkbookrequest.com",
      "idbs-cloud.com",
      "idbs-dev.com",
      "idbs-eworkbook.com"
    ],
    "idbs-eworkbook.com": [
      "eworkbookcloud.com",
      "eworkbookrequest.com",
      "idbs-cloud.com",
      "idbs-dev.com",
      "idbs-staging.com"
    ],
    "eworkbookcloud.com": [
      "eworkbookrequest.com",
      "idbs-cloud.com",
      "idbs-dev.com",
      "idbs-eworkbook.com",
      "idbs-staging.com"
    ],
    "eworkbookrequest.com": [
      "eworkbookcloud.com",
      "idbs-cloud.com",
      "idbs-dev.com",
      "idbs-eworkbook.com",
      "idbs-staging.com"
    ],
    "mightytext.net": [],
    "vwo.com": [
      "wingify.com"
    ],
    "wingify.com": [
      "vwo.com"
    ],
    "wildix.com": [
      "wildixin.com"
    ],
    "wildixin.com": [
      "wildix.com"
    ],
    "timesinternet.in": [
      "cricbuzz.com",
      "economictimes.com",
      "indiatimes.com",
      "samayam.com",
      "timesofindia.com"
    ],
    "indiatimes.com": [
      "cricbuzz.com",
      "economictimes.com",
      "samayam.com",
      "timesinternet.in",
      "timesofindia.com"
    ],
    "timesofindia.com": [
      "cricbuzz.com",
      "economictimes.com",
      "indiatimes.com",
      "samayam.com",
      "timesinternet.in"
    ],
    "economictimes.com": [
      "cricbuzz.com",
      "indiatimes.com",
      "samayam.com",
      "timesinternet.in",
      "timesofindia.com"
    ],
    "samayam.com": [
      "cricbuzz.com",
      "economictimes.com",
      "indiatimes.com",
      "timesinternet.in",
      "timesofindia.com"
    ],
    "cricbuzz.com": [
      "economictimes.com",
      "indiatimes.com",
      "samayam.com",
      "timesinternet.in",
      "timesofindia.com"
    ],
    "hc1.com": [
      "hc1.global"
    ],
    "hc1.global": [
      "hc1.com"
    ],
    "kompas.com": [
      "bolasport.com",
      "grid.id",
      "kompas.tv",
      "kompasiana.com",
      "tribunnews.com"
    ],
    "tribunnews.com": [
      "bolasport.com",
      "grid.id",
      "kompas.com",
      "kompas.tv",
      "kompasiana.com"
    ],
    "grid.id": [
      "bolasport.com",
      "kompas.com",
      "kompas.tv",
      "kompasiana.com",
      "tribunnews.com"
    ],
    "bolasport.com": [
      "grid.id",
      "kompas.com",
      "kompas.tv",
      "kompasiana.com",
      "tribunnews.com"
    ],
    "kompasiana.com": [
      "bolasport.com",
      "grid.id",
      "kompas.com",
      "kompas.tv",
      "tribunnews.com"
    ],
    "kompas.tv": [
      "bolasport.com",
      "grid.id",
      "kompas.com",
      "kompasiana.com",
      "tribunnews.com"
    ],
    "journaldesfemmes.com": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "commentcamarche.net": [
      "commentcamarche.com",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "linternaute.com": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "journaldunet.com": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "phonandroid.com": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr"
    ],
    "commentcamarche.com": [
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "journaldesfemmes.fr": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "linternaute.fr": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "phonandroid.com"
    ],
    "journaldunet.fr": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "johndeere.com": [
      "deere.com"
    ],
    "deere.com": [
      "johndeere.com"
    ],
    "lanacion.com.ar": [
      "bonvivir.com"
    ],
    "bonvivir.com": [
      "lanacion.com.ar"
    ],
    "nien.com": [
      "chennien.com",
      "nien.co",
      "nien.org"
    ],
    "chennien.com": [
      "nien.co",
      "nien.com",
      "nien.org"
    ],
    "nien.org": [
      "chennien.com",
      "nien.co",
      "nien.com"
    ],
    "nien.co": [
      "chennien.com",
      "nien.com",
      "nien.org"
    ],
    "hearty.me": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "heartymail.com",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "hearty.app": [
      "alice.tw",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "hearty.gift": [
      "alice.tw",
      "hearty.app",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "hj.rs": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "jiayi.life",
      "miss.com.tw"
    ],
    "heartymail.com": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "alice.tw": [
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "jiayi.life": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "miss.com.tw"
    ],
    "miss.com.tw": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "jiayi.life"
    ],
    "talkdeskqaid.com": [
      "trytalkdesk.com"
    ],
    "trytalkdesk.com": [
      "talkdeskqaid.com"
    ],
    "talkdeskstgid.com": [
      "gettalkdesk.com"
    ],
    "gettalkdesk.com": [
      "talkdeskstgid.com"
    ],
    "onet.pl": [
      "businessinsider.com.pl",
      "fakt.pl",
      "medonet.pl",
      "plejada.pl"
    ],
    "fakt.pl": [
      "businessinsider.com.pl",
      "medonet.pl",
      "onet.pl",
      "plejada.pl"
    ],
    "businessinsider.com.pl": [
      "fakt.pl",
      "medonet.pl",
      "onet.pl",
      "plejada.pl"
    ],
    "medonet.pl": [
      "businessinsider.com.pl",
      "fakt.pl",
      "onet.pl",
      "plejada.pl"
    ],
    "plejada.pl": [
      "businessinsider.com.pl",
      "fakt.pl",
      "medonet.pl",
      "onet.pl"
    ],
    "elpais.com.uy": [
      "clubelpais.com.uy",
      "elpais.uy",
      "gallito.com.uy",
      "paula.com.uy"
    ],
    "clubelpais.com.uy": [
      "elpais.com.uy",
      "elpais.uy",
      "gallito.com.uy",
      "paula.com.uy"
    ],
    "paula.com.uy": [
      "clubelpais.com.uy",
      "elpais.com.uy",
      "elpais.uy",
      "gallito.com.uy"
    ],
    "gallito.com.uy": [
      "clubelpais.com.uy",
      "elpais.com.uy",
      "elpais.uy",
      "paula.com.uy"
    ],
    "elpais.uy": [
      "clubelpais.com.uy",
      "elpais.com.uy",
      "gallito.com.uy",
      "paula.com.uy"
    ],
    "libero.it": [
      "supereva.it"
    ],
    "supereva.it": [
      "libero.it"
    ],
    "rws1nvtvt.com": [
      "rws2nvtvt.com",
      "rws3nvtvt.com"
    ],
    "rws2nvtvt.com": [
      "rws1nvtvt.com",
      "rws3nvtvt.com"
    ],
    "rws3nvtvt.com": [
      "rws1nvtvt.com",
      "rws2nvtvt.com"
    ],
    "stripe.com": [],
    "repid.org": [
      "human-talk.org",
      "reshim.org"
    ],
    "reshim.org": [
      "human-talk.org",
      "repid.org"
    ],
    "human-talk.org": [
      "repid.org",
      "reshim.org"
    ],
    "ya.ru": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.ru": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.net": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "turbopages.org": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "auto.ru": [
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "kinopoisk.ru": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "clck.ru": [
      "auto.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "edadeal.ru": [
      "auto.ru",
      "clck.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "webvisor.com": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yastatic.net": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz"
    ],
    "ya.cc": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.az": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.by": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.kz": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.md": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.tj": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.tm": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.uz": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yastatic.net"
    ],
    "yandex.st": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.com": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.com.am": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.com.ru": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "victorymedium.com": [
      "standardsandpraiserepurpose.com"
    ],
    "standardsandpraiserepurpose.com": [
      "victorymedium.com"
    ],
    "startupislandtaiwan.com": [
      "startupislandtaiwan.net",
      "startupislandtaiwan.org"
    ],
    "startupislandtaiwan.net": [
      "startupislandtaiwan.com",
      "startupislandtaiwan.org"
    ],
    "startupislandtaiwan.org": [
      "startupislandtaiwan.com",
      "startupislandtaiwan.net"
    ],
    "carcostadvisor.com": [
      "carcostadvisor.be",
      "carcostadvisor.fr"
    ],
    "carcostadvisor.be": [
      "carcostadvisor.com",
      "carcostadvisor.fr"
    ],
    "carcostadvisor.fr": [
      "carcostadvisor.be",
      "carcostadvisor.com"
    ],
    "caracoltv.com": [
      "bluradio.com",
      "bumbox.com",
      "hjck.com",
      "noticiascaracol.com",
      "shock.co"
    ],
    "noticiascaracol.com": [
      "bluradio.com",
      "bumbox.com",
      "caracoltv.com",
      "hjck.com",
      "shock.co"
    ],
    "bluradio.com": [
      "bumbox.com",
      "caracoltv.com",
      "hjck.com",
      "noticiascaracol.com",
      "shock.co"
    ],
    "shock.co": [
      "bluradio.com",
      "bumbox.com",
      "caracoltv.com",
      "hjck.com",
      "noticiascaracol.com"
    ],
    "bumbox.com": [
      "bluradio.com",
      "caracoltv.com",
      "hjck.com",
      "noticiascaracol.com",
      "shock.co"
    ],
    "hjck.com": [
      "bluradio.com",
      "bumbox.com",
      "caracoltv.com",
      "noticiascaracol.com",
      "shock.co"
    ],
    "max.auto": [
      "firstlook.biz"
    ],
    "firstlook.biz": [
      "max.auto"
    ],
    "gridgames.app": [
      "wordle.at"
    ],
    "wordle.at": [
      "gridgames.app"
    ],
    "blackrock.com": [
      "blackrockadvisorelite.it",
      "cachematrix.com",
      "efront.com",
      "etfacademy.it",
      "ishares.com"
    ],
    "blackrockadvisorelite.it": [
      "blackrock.com",
      "cachematrix.com",
      "efront.com",
      "etfacademy.it",
      "ishares.com"
    ],
    "cachematrix.com": [
      "blackrock.com",
      "blackrockadvisorelite.it",
      "efront.com",
      "etfacademy.it",
      "ishares.com"
    ],
    "efront.com": [
      "blackrock.com",
      "blackrockadvisorelite.it",
      "cachematrix.com",
      "etfacademy.it",
      "ishares.com"
    ],
    "etfacademy.it": [
      "blackrock.com",
      "blackrockadvisorelite.it",
      "cachematrix.com",
      "efront.com",
      "ishares.com"
    ],
    "ishares.com": [
      "blackrock.com",
      "blackrockadvisorelite.it",
      "cachematrix.com",
      "efront.com",
      "etfacademy.it"
    ],
    "tvn.pl": [
      "player.pl",
      "tvn24.pl",
      "zdrowietvn.pl"
    ],
    "player.pl": [
      "tvn.pl",
      "tvn24.pl",
      "zdrowietvn.pl"
    ],
    "tvn24.pl": [
      "player.pl",
      "tvn.pl",
      "zdrowietvn.pl"
    ],
    "zdrowietvn.pl": [
      "player.pl",
      "tvn.pl",
      "tvn24.pl"
    ],
    "zalo.me": [
      "baomoi.com",
      "smoney.vn",
      "zingmp3.vn"
    ],
    "zingmp3.vn": [
      "baomoi.com",
      "smoney.vn",
      "zalo.me"
    ],
    "baomoi.com": [
      "smoney.vn",
      "zalo.me",
      "zingmp3.vn"
    ],
    "smoney.vn": [
      "baomoi.com",
      "zalo.me",
      "zingmp3.vn"
    ],
    "finn.no": [
      "mittanbud.no",
      "prisjakt.no"
    ],
    "prisjakt.no": [
      "finn.no",
      "mittanbud.no"
    ],
    "mittanbud.no": [
      "finn.no",
      "prisjakt.no"
    ],
    "laprensagrafica.com": [
      "eleconomista.net",
      "elgrafico.com",
      "ella.sv",
      "grupolpg.sv"
    ],
    "elgrafico.com": [
      "eleconomista.net",
      "ella.sv",
      "grupolpg.sv",
      "laprensagrafica.com"
    ],
    "eleconomista.net": [
      "elgrafico.com",
      "ella.sv",
      "grupolpg.sv",
      "laprensagrafica.com"
    ],
    "ella.sv": [
      "eleconomista.net",
      "elgrafico.com",
      "grupolpg.sv",
      "laprensagrafica.com"
    ],
    "grupolpg.sv": [
      "eleconomista.net",
      "elgrafico.com",
      "ella.sv",
      "laprensagrafica.com"
    ],
    "kaksya.in": [
      "nidhiacademyonline.com"
    ],
    "nidhiacademyonline.com": [
      "kaksya.in"
    ],
    "vrt.be": [
      "dewarmsteweek.be",
      "een.be",
      "radio1.be",
      "radio2.be",
      "sporza.be"
    ],
    "dewarmsteweek.be": [
      "een.be",
      "radio1.be",
      "radio2.be",
      "sporza.be",
      "vrt.be"
    ],
    "sporza.be": [
      "dewarmsteweek.be",
      "een.be",
      "radio1.be",
      "radio2.be",
      "vrt.be"
    ],
    "een.be": [
      "dewarmsteweek.be",
      "radio1.be",
      "radio2.be",
      "sporza.be",
      "vrt.be"
    ],
    "radio2.be": [
      "dewarmsteweek.be",
      "een.be",
      "radio1.be",
      "sporza.be",
      "vrt.be"
    ],
    "radio1.be": [
      "dewarmsteweek.be",
      "een.be",
      "radio2.be",
      "sporza.be",
      "vrt.be"
    ],
    "nvidia.com": [
      "geforcenow.com"
    ],
    "geforcenow.com": [
      "nvidia.com"
    ],
    "sapo.pt": [
      "meo.pt",
      "sapo.io"
    ],
    "meo.pt": [
      "sapo.io",
      "sapo.pt"
    ],
    "sapo.io": [
      "meo.pt",
      "sapo.pt"
    ],
    "tolteck.com": [
      "tolteck.app"
    ],
    "tolteck.app": [
      "tolteck.com"
    ],
    "p24.hu": [
      "24.hu",
      "hazipatika.com",
      "nlc.hu",
      "nosalty.hu",
      "startlap.hu"
    ],
    "24.hu": [
      "hazipatika.com",
      "nlc.hu",
      "nosalty.hu",
      "p24.hu",
      "startlap.hu"
    ],
    "startlap.hu": [
      "24.hu",
      "hazipatika.com",
      "nlc.hu",
      "nosalty.hu",
      "p24.hu"
    ],
    "nlc.hu": [
      "24.hu",
      "hazipatika.com",
      "nosalty.hu",
      "p24.hu",
      "startlap.hu"
    ],
    "hazipatika.com": [
      "24.hu",
      "nlc.hu",
      "nosalty.hu",
      "p24.hu",
      "startlap.hu"
    ],
    "nosalty.hu": [
      "24.hu",
      "hazipatika.com",
      "nlc.hu",
      "p24.hu",
      "startlap.hu"
    ],
    "cognitiveai.ru": [
      "cognitive-ai.ru"
    ],
    "cognitive-ai.ru": [
      "cognitiveai.ru"
    ],
    "citybibleforum.org": [
      "thirdspace.org.au"
    ],
    "thirdspace.org.au": [
      "citybibleforum.org"
    ],
    "p106.net": [
      "smpn106jkt.sch.id"
    ],
    "smpn106jkt.sch.id": [
      "p106.net"
    ],
    "indiatoday.in": [
      "aajtak.in",
      "businesstoday.in",
      "gnttv.com",
      "indiatodayne.in",
      "intoday.in"
    ],
    "aajtak.in": [
      "businesstoday.in",
      "gnttv.com",
      "indiatoday.in",
      "indiatodayne.in",
      "intoday.in"
    ],
    "businesstoday.in": [
      "aajtak.in",
      "gnttv.com",
      "indiatoday.in",
      "indiatodayne.in",
      "intoday.in"
    ],
    "intoday.in": [
      "aajtak.in",
      "businesstoday.in",
      "gnttv.com",
      "indiatoday.in",
      "indiatodayne.in"
    ],
    "gnttv.com": [
      "aajtak.in",
      "businesstoday.in",
      "indiatoday.in",
      "indiatodayne.in",
      "intoday.in"
    ],
    "indiatodayne.in": [
      "aajtak.in",
      "businesstoday.in",
      "gnttv.com",
      "indiatoday.in",
      "intoday.in"
    ],
    "naukri.com": [
      "ambitionbox.com",
      "infoedgeindia.com"
    ],
    "ambitionbox.com": [
      "infoedgeindia.com",
      "naukri.com"
    ],
    "infoedgeindia.com": [
      "ambitionbox.com",
      "naukri.com"
    ],
    "text.com": [
      "chatbot.com",
      "helpdesk.com",
      "knowledgebase.com",
      "livechat.com",
      "livechatinc.com",
      "openwidget.com"
    ],
    "livechat.com": [
      "chatbot.com",
      "helpdesk.com",
      "knowledgebase.com",
      "livechatinc.com",
      "openwidget.com",
      "text.com"
    ],
    "helpdesk.com": [
      "chatbot.com",
      "knowledgebase.com",
      "livechat.com",
      "livechatinc.com",
      "openwidget.com",
      "text.com"
    ],
    "chatbot.com": [
      "helpdesk.com",
      "knowledgebase.com",
      "livechat.com",
      "livechatinc.com",
      "openwidget.com",
      "text.com"
    ],
    "livechatinc.com": [
      "chatbot.com",
      "helpdesk.com",
      "knowledgebase.com",
      "livechat.com",
      "openwidget.com",
      "text.com"
    ],
    "knowledgebase.com": [
      "chatbot.com",
      "helpdesk.com",
      "livechat.com",
      "livechatinc.com",
      "openwidget.com",
      "text.com"
    ],
    "openwidget.com": [
      "chatbot.com",
      "helpdesk.com",
      "knowledgebase.com",
      "livechat.com",
      "livechatinc.com",
      "text.com"
    ],
    "thejournal.ie": [
      "the42.ie"
    ],
    "the42.ie": [
      "thejournal.ie"
    ],
    "html-load.com": [
      "07c225f3.online",
      "content-loader.com",
      "css-load.com",
      "html-load.cc",
      "img-load.com"
    ],
    "css-load.com": [
      "07c225f3.online",
      "content-loader.com",
      "html-load.cc",
      "html-load.com",
      "img-load.com"
    ],
    "img-load.com": [
      "07c225f3.online",
      "content-loader.com",
      "css-load.com",
      "html-load.cc",
      "html-load.com"
    ],
    "content-loader.com": [
      "07c225f3.online",
      "css-load.com",
      "html-load.cc",
      "html-load.com",
      "img-load.com"
    ],
    "07c225f3.online": [
      "content-loader.com",
      "css-load.com",
      "html-load.cc",
      "html-load.com",
      "img-load.com"
    ],
    "html-load.cc": [
      "07c225f3.online",
      "content-loader.com",
      "css-load.com",
      "html-load.com",
      "img-load.com"
    ],
    "interia.pl": [
      "deccoria.pl",
      "pomponik.pl",
      "smaker.pl",
      "terazgotuje.pl",
      "top.pl"
    ],
    "pomponik.pl": [
      "deccoria.pl",
      "interia.pl",
      "smaker.pl",
      "terazgotuje.pl",
      "top.pl"
    ],
    "deccoria.pl": [
      "interia.pl",
      "pomponik.pl",
      "smaker.pl",
      "terazgotuje.pl",
      "top.pl"
    ],
    "top.pl": [
      "deccoria.pl",
      "interia.pl",
      "pomponik.pl",
      "smaker.pl",
      "terazgotuje.pl"
    ],
    "smaker.pl": [
      "deccoria.pl",
      "interia.pl",
      "pomponik.pl",
      "terazgotuje.pl",
      "top.pl"
    ],
    "terazgotuje.pl": [
      "deccoria.pl",
      "interia.pl",
      "pomponik.pl",
      "smaker.pl",
      "top.pl"
    ],
    "graziadaily.co.uk": [
      "closeronline.co.uk",
      "heatworld.com",
      "motherandbaby.com",
      "takeabreak.co.uk",
      "yours.co.uk"
    ],
    "heatworld.com": [
      "closeronline.co.uk",
      "graziadaily.co.uk",
      "motherandbaby.com",
      "takeabreak.co.uk",
      "yours.co.uk"
    ],
    "closeronline.co.uk": [
      "graziadaily.co.uk",
      "heatworld.com",
      "motherandbaby.com",
      "takeabreak.co.uk",
      "yours.co.uk"
    ],
    "yours.co.uk": [
      "closeronline.co.uk",
      "graziadaily.co.uk",
      "heatworld.com",
      "motherandbaby.com",
      "takeabreak.co.uk"
    ],
    "motherandbaby.com": [
      "closeronline.co.uk",
      "graziadaily.co.uk",
      "heatworld.com",
      "takeabreak.co.uk",
      "yours.co.uk"
    ],
    "takeabreak.co.uk": [
      "closeronline.co.uk",
      "graziadaily.co.uk",
      "heatworld.com",
      "motherandbaby.com",
      "yours.co.uk"
    ],
    "drimer.io": [
      "drimer.travel"
    ],
    "drimer.travel": [
      "drimer.io"
    ],
    "zoom.us": [
      "zoom.com"
    ],
    "zoom.com": [
      "zoom.us"
    ]
  };
  function getRelatedDomains(domain) {
    const relatedDomains = getRelatedDomainsDictionary()[domain];
    return relatedDomains;
  }
  function getRelatedDomainsDictionary() {
    return relatedDomainsDictionary;
  }
  var assertNever$1 = {};
  Object.defineProperty(assertNever$1, "__esModule", { value: true });
  function assertNever(value, noThrow) {
    if (noThrow) {
      return value;
    }
    throw new Error("Unhandled discriminated union member: " + JSON.stringify(value));
  }
  assertNever$1.assertNever = assertNever;
  assertNever$1.default = assertNever;
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function U$1(e2) {
    switch (e2) {
      case LoginUiType.creditCard:
        return i18n._(
          /*i18n*/
          {
            id: "ooW934"
          }
        );
      case LoginUiType.wifi:
        return i18n._(
          /*i18n*/
          {
            id: "5VAKau"
          }
        );
      case LoginUiType.note:
        return i18n._(
          /*i18n*/
          {
            id: "tF8MKq"
          }
        );
      case LoginUiType.login:
      case void 0:
        return i18n._(
          /*i18n*/
          {
            id: "z0t9bb"
          }
        );
    }
  }
  function E$2(e2) {
    if (debugConsole.info("webauthn.get credential", e2), !e2)
      throw new Error("Unexpectedly received no credential");
    if (!(e2 instanceof PublicKeyCredential))
      throw new Error(`Unexpected credential type ${e2 == null ? void 0 : e2.type}`);
    if (!(e2.response instanceof AuthenticatorAssertionResponse))
      throw new Error("Unexpected AssertionResponse type");
    const {
      prf: r2
    } = e2.getClientExtensionResults();
    return {
      id: e2.id,
      rawId: new Uint8Array(e2.rawId),
      response: {
        authenticatorData: new Uint8Array(e2.response.authenticatorData),
        clientDataJSON: new Uint8Array(e2.response.clientDataJSON),
        signature: new Uint8Array(e2.response.signature),
        userHandle: e2.response.userHandle ? new Uint8Array(e2.response.userHandle) : void 0
      },
      prfExtensionResult: r2 != null && r2.results ? {
        first: new Uint8Array(r2.results.first),
        second: r2.results.second ? new Uint8Array(r2.results.second) : void 0
      } : void 0
    };
  }
  function h$3() {
    return navigator.credentials;
  }
  let P$1 = class P {
    constructor(r2, n2 = "DEBUG") {
      this.onDebugTriggered = r2, this.debugString = n2, this.index = 0, this.onKeypress = (s2) => {
        s2.defaultPrevented || (s2.key === this.debugString[this.index] ? (this.index += 1, this.index === this.debugString.length && (this.onDebugTriggered(), this.index = 0)) : this.index = 0);
      };
    }
    init() {
      window.addEventListener("keypress", this.onKeypress);
    }
    close() {
      window.removeEventListener("keypress", this.onKeypress);
    }
  };
  const T$1 = "0 0 0.5rem hsl(0deg 0% 0% / 50%)";
  JSON.parse('{"nYAZ22":["",["loginLabel"]," wurde gelscht."],"BBrYPy":["",["loginLabel"]," wurde nach ",["0"]," verschoben."],"+BllQ/":["",["loginLabel"]," wurde in den <0>Papierkorb</0> verschoben."],"d/ZbMk":"(gendert)","Gv57aB":[["fieldName"]," (alt)"],"9XZ3SQ":"#@$","qdmWOt":["0",["nonBreakingHyphen"],"9"],"sbGnrd":["a",["nonBreakingHyphen"],"z"],"umLW9t":["A",["nonBreakingHyphen"],"Z"],"m16xKo":"Hinzufgen","lyqwgn":"Label hinzufgen","iOiHwJ":"Weitere hinzufgen","CgUQh7":"Neues Feld hinzufgen","648VR4":"TOTP-Schlssel hinzufgen","xkWEmO":"Alle Felder sind Ende-zu-Ende-verschlsselt.","mac4Aw":"Alt","zVJj0U":"Android-App","DB8zMK":"bernehmen","NamUYY":["von ",["creationProfileEmail"]],"nmimYO":["von ",["editProfileEmail"]],"dEgA5A":"Abbrechen","bMFXRG":"Karteninhaber","xHIEQ5":"Kreditkartennummer","2SqvU5":"Uhrzeit wird berprft","RLe7Vk":"Wird berprft","xCJdfg":"Leeren","yz7wBu":"Schlieen","yrwl2P":"Konform","aIJHYe":"Zugriff erlauben","MpA0AY":"Besttige mit einem deiner Login-Gerte","F0GBL0":"Besttige mit deinem Handy","1yegnp":"Besttige mit deinem Security Key","6V3Ea3":"Kopiert","he3ygx":"Kopieren","t3sqJR":["Erstellt am ",["0"]],"ooW934":"Kreditkarte","F5QOVM":"Strg","W/50sr":"Entf","cnGeoo":"Lschen","pfa8F0":"Anzeigename","d3ZUIN":"E-Mail oder Nutzername","xDr/ct":"Ende","9Vnjc9":"Enter","nNWuY1":"Eintrags-Typ","dgi+MR":"Fehler beim berprfen des Passworts","zO1gmR":"Esc","sZg7s1":"Ablaufdatum","2Pjc5z":"Ablaufdatum (mm / yy)","7Bj3x9":"Fehlgeschlagen","19BWU3":"Passwort generieren","YU1MkM":"PIN generieren","Jf0PuK":"Zum Login gehen","76gPWk":"Okay","+AzmrG":"heylogin wurde aktualisiert","vLyv1R":"Verbergen","g9eOjA":"Inhalt verstecken","i0qMbr":"Pos1","62ft/Z":"https://help.heylogin.com/de/2be545c602c144d6992a50e6301afa18","mSlBXj":"Einfg","/Gcaah":"Unsicher","0FSRiz":"Ungltige Kreditkartennummer","Lyd22+":"Ungltiges Ablaufdatum","7xaBoY":"Ungltiger Sicherheitscode","oYNiCo":"Label bereits hinzugefgt","h8DugX":"Labels","hko/4A":"Labels:","Lr4lJo":["Zuletzt bearbeitet am ",["0"]],"NC2AI2":"Lnge","zUDyah":"Du wirst eingeloggt","z0t9bb":"Login","zUtMod":"Login abgebrochen","lh348v":"Login-Posteingang","a7UoOG":"Login-Status","gKfrpZ":["min. ",["0"]," Zeichen"],"2FYpfJ":"Mehr","3Siwmw":"Weitere Optionen","IK+8Ec":"In den Papierkorb verschieben","12Aozu":"Meine Logins","6YtxFj":"Name","1xTnZJ":"Name darf nicht leer sein!","MKYFuo":"Netzwerkname (SSID)","/nT6AE":"Neues Passwort","nr1I0W":"Keine App gefunden","xAAcWG":"Benachrichtigung kommt nicht an?","KiJn9B":"Notiz","CqOvzI":"Altes Passwort","yxTdsJ":"Webseite aufrufen","8ZsakT":"Passwort","kcggoH":"Passwort-Check:","dsVW+d":"Geprftes Passwort","9QBiCg":"Passwort ist leer","Xjatg3":"Passwort-Policy:","oENbfc":"Persnliche Logins","lojVac":"Bild","ycPJXO":"Bild","sXULwc":"PIN","XdSz+P":"Bitte gib ein Label ein","QsZjF+":"Bitte lade die Seite neu um die aktuelle Version zu verwenden.","Ysej7j":"Privater Account","3WxAes":"Erneut prfen","HpK/8d":"Neu laden","/7FPnu":"Label entfernen","Clnbgt":"Geteiltes Login entfernen","yKu/3Y":"Wiederherstellen","I89uD4":"Wiederherstellen","tfDRzk":"Speichern","mwMktx":[["changeCount","plural",{"one":"Eine nderung","other":["#"," nderungen"]}]," speichern"],"u5eWCX":"Neuen Eintrag speichern","idD8Ev":"Gespeichert","OFqAkw":"Erfolgreich gespeichert","uF9ruK":"Wird gespeichert","tF8MKq":"Sichere Notiz","FLkaGY":"Sicheres Passwort","wLmRnI":"Sicherheitscode","rmoyE2":["Sicherheitscode (",["cardCodeName"],", ",["1","plural",{"one":["#"," Ziffer"],"other":["#"," Ziffern"]}],")"],"byfRNP":"Login-Absender","PGetcZ":"Shift","8vETh9":"Anzeigen","h8lzfw":[["0"]," anzeigen"],"7C+Jn5":"Passwort anzeigen","2cIs6V":"PIN anzeigen","BqrHbB":"Sicherheitscode anzeigen","nld5XV":"TOTP-Schlssel anzeigen","vHxqT2":"Zeige WLAN-QR-Code","pOE8Vh":"Leerstaste","J8XjuC":"Uhrzeit ist jetzt korrekt.","kWroQx":"der Besitzer","QNFK92":"Ungespeicherte nderungen. <0>Jetzt speichern</0>","2vXxVm":["Diese Kreditkarte wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt."],"HoCMO6":"Diese Kreditkarte wird aus einem Team mit dir geteilt.","RCxO9Q":["Diese Kreditkarte wird aus dem Team ",["link"]," mit dir geteilt."],"xdufSh":["Diese Kreditkarte wird von ",["originEmail"]," mit dir geteilt."],"JWTc8Z":"Diese Kreditkarte wird von einem anderen Nutzer mit dir geteilt.","QAuBJT":["Dieses Login wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt."],"thM6gj":"Dieses Login wird aus einem Team mit dir geteilt.","sQ0SXs":["Dieses Login wird aus dem Team ",["link"]," mit dir geteilt."],"0lXBAq":["Dieses Login wird von ",["originEmail"]," mit dir geteilt."],"OXhtqX":"Dieses Login wird von einem anderen Nutzer mit dir geteilt.","c/nFq0":["Dieses Login wurde am ",["0"]," in deinen Login-Posteingang bermittelt."],"czBEzZ":["Dieses Login wird auch auf ",["0"]," weiteren Webseiten angezeigt."],"y4UGV2":["Dieses Login wird auch auf ",["0"]," und ",["1"]," angezeigt."],"ai680t":["Dieses Login wird auch auf ",["0"]," angezeigt."],"S/ZmvX":["Dieses Notiz wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt"],"lr/OH6":"Diese Notiz wird aus einem Team mit dir geteilt.","a9Vkxt":["Diese Notiz wird aus dem Team ",["link"]," mit dir geteilt."],"RzvhXF":["Dieses Notiz wird von ",["originEmail"]," mit dir geteilt"],"UMBnwA":"Diese Notiz wird von einem anderen Nutzer mit dir geteilt.","2DMQa6":"Dieses Passwort wurde auf einer Liste von geleakten Passwrtern gefunden. Bitte nicht verwenden!","ESK+7k":"Dieser TOTP-Code benutzt von der Voreinstellung abweichende Parameter.","DUExfD":["Dieses WLAN-Netzwerk wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt."],"QGWnC/":"Dieses WLAN-Netzwerk wird aus einem Team mit dir geteilt.","+JycaI":["Dieses WLAN-Netzwerk wird aus dem Team ",["link"]," mit dir geteilt."],"OoKYf3":["Dieses WLAN-Netzwerk wird von ",["originEmail"]," mit dir geteilt."],"oSL3k7":"Dieses WLAN-Netzwerk wird von einem anderen Nutzer mit dir geteilt.","Kvajkr":"TOTP","yoyvgB":"TOTP-Algorithmus","HqgpzW":"TOTP-Code knnte ungltig sein aufgrund abweichender Uhrzeit auf diesem Gert. Bitte stelle die Systemzeit auf die aktuelle Zeit.","dME5Kz":"TOTP-Code:","16oMiL":"TOTP-Lnge","rsWzn3":"TOTP-Periode","g4uCmi":"TOTP-Schlssel","KDw4GX":"Erneut versuchen","3dKLN3":"Unbekannte Kreditkarte","29VNqC":"Unbekannter Fehler","fEjABR":["Unbekannter Fehler: ",["0"]],"IU3aCs":"Unbekanntes Feld","+jQjTh":"Unbekanntes WLAN-Netzwerk","4QFgr2":"Unbenanntes Login","57/aFB":"Unbenanntes Team","/zWqH6":"Als Standardeinstellung nutzen","7sNhEz":"Nutzername","ZBkKyh":"Verletzt","IVBLxC":"Warte auf berprfung","On0aF2":"Website","1J9wMe":"Websites","5VAKau":"WLAN-Netzwerk","2rz/ET":"Du kannst sie nur lesen.","PwJojz":"Du kannst es nur lesen.","mJdpuD":"Du kannst es nur lesen.","7uotGR":"Du kannst sie nur lesen.","KBRW1Z":"Du kannst diese Kreditkarte nur lesen.","ntxE/T":"Du kannst dieses Login nur lesen.","U7HgqM":"Du kannst dieses Notiz nur lesen.","cyzc26":"Du kannst dieses WLAN-Netzwerk nur lesen.","du68I6":"Du kannst es nur zum Einloggen auf Webseiten verwenden.","c8d9tl":"Du kannst dieses Login nur zum Einloggen auf Webseiten verwenden.","T9CzYt":["Du hast ",["remainingMinutes","plural",{"one":"weniger als eine Minute","other":["#"," Minuten"]}]," Zeit, um die Kreditkarte anzupassen, danach kann nur noch ",["ownerEmail"]," editieren."],"KoxsxA":["Du hast ",["remainingMinutes","plural",{"one":"weniger als eine Minute","other":["#"," Minuten"]}]," Zeit, um das Login anzupassen, danach kann nur noch ",["ownerEmail"]," editieren."]}');
  JSON.parse('{"nYAZ22":["",["loginLabel"]," was deleted."],"BBrYPy":["",["loginLabel"]," was moved to ",["0"],"."],"+BllQ/":["",["loginLabel"]," was moved to the <0>recycle bin</0>."],"d/ZbMk":"(changed)","Gv57aB":[["fieldName"]," (old)"],"9XZ3SQ":"#@$","qdmWOt":["0",["nonBreakingHyphen"],"9"],"sbGnrd":["a",["nonBreakingHyphen"],"z"],"umLW9t":["A",["nonBreakingHyphen"],"Z"],"m16xKo":"Add","lyqwgn":"Add label","iOiHwJ":"Add more","CgUQh7":"Add new field","648VR4":"Add TOTP secret","xkWEmO":"All fields are end-to-end encrypted.","mac4Aw":"Alt","zVJj0U":"Android app","DB8zMK":"Apply","NamUYY":["by ",["creationProfileEmail"]],"nmimYO":["by ",["editProfileEmail"]],"dEgA5A":"Cancel","bMFXRG":"Card holder","xHIEQ5":"Card number","2SqvU5":"Checking system clock","RLe7Vk":"Checking","xCJdfg":"Clear","yz7wBu":"Close","yrwl2P":"Compliant","aIJHYe":"Confirm access","MpA0AY":"Confirm with one of your login devices","F0GBL0":"Confirm with your phone","1yegnp":"Confirm with your security key","6V3Ea3":"Copied","he3ygx":"Copy","t3sqJR":["Created on ",["0"]],"ooW934":"Credit card","F5QOVM":"Ctrl","W/50sr":"Del","cnGeoo":"Delete","pfa8F0":"Display name","d3ZUIN":"E-mail or username","xDr/ct":"End","9Vnjc9":"Enter","nNWuY1":"Entry type","dgi+MR":"Error checking password","zO1gmR":"Esc","sZg7s1":"Expiration date","2Pjc5z":"Expiration date (mm / yy)","7Bj3x9":"Failed","19BWU3":"Generate password","YU1MkM":"Generate PIN","Jf0PuK":"Go to login","76gPWk":"Got it","+AzmrG":"heylogin was updated","vLyv1R":"Hide","g9eOjA":"Hide content","i0qMbr":"Home","62ft/Z":"https://help.heylogin.com/en/4200f43b493c4bb18c8e16bffcd40071","mSlBXj":"Ins","/Gcaah":"Insecure","0FSRiz":"Invalid card number","Lyd22+":"Invalid expiration date","7xaBoY":"Invalid security code","oYNiCo":"Label already added","h8DugX":"Labels","hko/4A":"Labels:","Lr4lJo":["Last edited on ",["0"]],"NC2AI2":"Length","zUDyah":"Logging in","z0t9bb":"Login","zUtMod":"Login cancelled","lh348v":"Login Inbox","a7UoOG":"Login status","gKfrpZ":["min. ",["0"]," characters"],"2FYpfJ":"More","3Siwmw":"More options","IK+8Ec":"Move to recycle bin","12Aozu":"My Logins","6YtxFj":"Name","1xTnZJ":"Name may not be empty!","MKYFuo":"Network name (SSID)","/nT6AE":"New password","nr1I0W":"No app found","xAAcWG":"No notification received?","KiJn9B":"Note","CqOvzI":"Old password","yxTdsJ":"Open website","8ZsakT":"Password","kcggoH":"Password check:","dsVW+d":"Password checked","9QBiCg":"Password is empty","Xjatg3":"Password policy:","oENbfc":"Personal Logins","lojVac":"PgDn","ycPJXO":"PgUp","sXULwc":"PIN","XdSz+P":"Please enter a label","QsZjF+":"Please reload to use the latest version.","Ysej7j":"Private account","3WxAes":"Recheck","HpK/8d":"Reload","/7FPnu":"Remove label","Clnbgt":"Remove shared login","yKu/3Y":"Restore","I89uD4":"Restoring","tfDRzk":"Save","mwMktx":["Save ",["changeCount","plural",{"one":["#"," change"],"other":["#"," changes"]}]],"u5eWCX":"Save new entry","idD8Ev":"Saved","OFqAkw":"Saved successfully","uF9ruK":"Saving","tF8MKq":"Secure note","FLkaGY":"Secure password","wLmRnI":"Security code","rmoyE2":["Security code (",["cardCodeName"],", ",["0","plural",{"one":["#"," digit"],"other":["#"," digits"]}],")"],"byfRNP":"Sent by","PGetcZ":"Shift","8vETh9":"Show","h8lzfw":["Show ",["0"]],"7C+Jn5":"Show password","2cIs6V":"Show PIN","BqrHbB":"Show security code","nld5XV":"Show TOTP secret","vHxqT2":"Show WiFi QR code","pOE8Vh":"Space","J8XjuC":"System clock is correct now.","kWroQx":"the owner","QNFK92":"There are unsaved changes. <0>Save now</0>","2vXxVm":["This credit card is shared from a team by ",["linkedByEmail"],"."],"HoCMO6":"This credit card is shared from a team.","RCxO9Q":["This credit card is shared from team ",["link"],"."],"xdufSh":["This credit card is shared with you by ",["originEmail"],"."],"JWTc8Z":"This credit card is shared with you by another user.","QAuBJT":["This login is shared from a team by ",["linkedByEmail"],"."],"thM6gj":"This login is shared from a team.","sQ0SXs":["This login is shared from team ",["link"],"."],"0lXBAq":["This login is shared with you by ",["originEmail"],"."],"OXhtqX":"This login is shared with you by another user.","c/nFq0":["This login was submitted to your login inbox on ",["0"],"."],"czBEzZ":["This login will also be shown on ",["0"]," additional websites."],"y4UGV2":["This login will also be shown on ",["0"]," and ",["1"],"."],"ai680t":["This login will also be shown on ",["0"],"."],"S/ZmvX":["This note is shared from a team by ",["linkedByEmail"],"."],"lr/OH6":"This note is shared from a team.","a9Vkxt":["This note is shared from team ",["link"],"."],"RzvhXF":["This note is shared with you by ",["originEmail"],"."],"UMBnwA":"This note is shared with you by another user.","2DMQa6":"This password was found in a list of leaked passwords. Please do not use it!","ESK+7k":"This TOTP code uses parameters that differ from the default.","DUExfD":["This wifi network is shared from a team by ",["linkedByEmail"],"."],"QGWnC/":"This wifi network is shared from a team.","+JycaI":["This wifi network is shared from team ",["link"],"."],"OoKYf3":["This wifi network is shared with you by ",["originEmail"],"."],"oSL3k7":"This wifi network is shared with you by another user.","Kvajkr":"TOTP","yoyvgB":"TOTP algorithm","HqgpzW":"TOTP code might be invalid due to incorrect system clock on this device. Please set your system time to the current time.","dME5Kz":"TOTP code:","16oMiL":"TOTP length","rsWzn3":"TOTP period","g4uCmi":"TOTP secret","KDw4GX":"Try again","3dKLN3":"Unknown credit card","29VNqC":"Unknown error","fEjABR":["Unknown error: ",["0"]],"IU3aCs":"Unknown field","+jQjTh":"Unknown wifi network","4QFgr2":"Unnamed login","57/aFB":"Unnamed team","/zWqH6":"Use as default setting","7sNhEz":"Username","ZBkKyh":"Violated","IVBLxC":"Waiting to check","On0aF2":"Website","1J9wMe":"Websites","5VAKau":"Wifi network","2rz/ET":"You can only read it.","PwJojz":"You can only read it.","mJdpuD":"You can only read it.","7uotGR":"You can only read it.","KBRW1Z":"You can only read this credit card.","ntxE/T":"You can only read this login.","U7HgqM":"You can only read this note.","cyzc26":"You can only read this wifi network.","du68I6":"You can only use it to log in on websites.","c8d9tl":"You can only use this login to log in on websites.","T9CzYt":["You have ",["remainingMinutes","plural",{"one":"less than one minute","other":["#"," minutes"]}]," to edit this credit card. After that, only ",["ownerEmail"]," can edit it."],"KoxsxA":["You have ",["remainingMinutes","plural",{"one":"less than one minute","other":["#"," minutes"]}]," to edit this login. After that, only ",["ownerEmail"]," can edit it."]}');
  var psl = {};
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
  const require$$1 = [
    "ac",
    "com.ac",
    "edu.ac",
    "gov.ac",
    "net.ac",
    "mil.ac",
    "org.ac",
    "ad",
    "nom.ad",
    "ae",
    "co.ae",
    "net.ae",
    "org.ae",
    "sch.ae",
    "ac.ae",
    "gov.ae",
    "mil.ae",
    "aero",
    "accident-investigation.aero",
    "accident-prevention.aero",
    "aerobatic.aero",
    "aeroclub.aero",
    "aerodrome.aero",
    "agents.aero",
    "aircraft.aero",
    "airline.aero",
    "airport.aero",
    "air-surveillance.aero",
    "airtraffic.aero",
    "air-traffic-control.aero",
    "ambulance.aero",
    "amusement.aero",
    "association.aero",
    "author.aero",
    "ballooning.aero",
    "broker.aero",
    "caa.aero",
    "cargo.aero",
    "catering.aero",
    "certification.aero",
    "championship.aero",
    "charter.aero",
    "civilaviation.aero",
    "club.aero",
    "conference.aero",
    "consultant.aero",
    "consulting.aero",
    "control.aero",
    "council.aero",
    "crew.aero",
    "design.aero",
    "dgca.aero",
    "educator.aero",
    "emergency.aero",
    "engine.aero",
    "engineer.aero",
    "entertainment.aero",
    "equipment.aero",
    "exchange.aero",
    "express.aero",
    "federation.aero",
    "flight.aero",
    "fuel.aero",
    "gliding.aero",
    "government.aero",
    "groundhandling.aero",
    "group.aero",
    "hanggliding.aero",
    "homebuilt.aero",
    "insurance.aero",
    "journal.aero",
    "journalist.aero",
    "leasing.aero",
    "logistics.aero",
    "magazine.aero",
    "maintenance.aero",
    "media.aero",
    "microlight.aero",
    "modelling.aero",
    "navigation.aero",
    "parachuting.aero",
    "paragliding.aero",
    "passenger-association.aero",
    "pilot.aero",
    "press.aero",
    "production.aero",
    "recreation.aero",
    "repbody.aero",
    "res.aero",
    "research.aero",
    "rotorcraft.aero",
    "safety.aero",
    "scientist.aero",
    "services.aero",
    "show.aero",
    "skydiving.aero",
    "software.aero",
    "student.aero",
    "trader.aero",
    "trading.aero",
    "trainer.aero",
    "union.aero",
    "workinggroup.aero",
    "works.aero",
    "af",
    "gov.af",
    "com.af",
    "org.af",
    "net.af",
    "edu.af",
    "ag",
    "com.ag",
    "org.ag",
    "net.ag",
    "co.ag",
    "nom.ag",
    "ai",
    "off.ai",
    "com.ai",
    "net.ai",
    "org.ai",
    "al",
    "com.al",
    "edu.al",
    "gov.al",
    "mil.al",
    "net.al",
    "org.al",
    "am",
    "co.am",
    "com.am",
    "commune.am",
    "net.am",
    "org.am",
    "ao",
    "ed.ao",
    "gv.ao",
    "og.ao",
    "co.ao",
    "pb.ao",
    "it.ao",
    "aq",
    "ar",
    "bet.ar",
    "com.ar",
    "coop.ar",
    "edu.ar",
    "gob.ar",
    "gov.ar",
    "int.ar",
    "mil.ar",
    "musica.ar",
    "mutual.ar",
    "net.ar",
    "org.ar",
    "senasa.ar",
    "tur.ar",
    "arpa",
    "e164.arpa",
    "in-addr.arpa",
    "ip6.arpa",
    "iris.arpa",
    "uri.arpa",
    "urn.arpa",
    "as",
    "gov.as",
    "asia",
    "at",
    "ac.at",
    "co.at",
    "gv.at",
    "or.at",
    "sth.ac.at",
    "au",
    "com.au",
    "net.au",
    "org.au",
    "edu.au",
    "gov.au",
    "asn.au",
    "id.au",
    "info.au",
    "conf.au",
    "oz.au",
    "act.au",
    "nsw.au",
    "nt.au",
    "qld.au",
    "sa.au",
    "tas.au",
    "vic.au",
    "wa.au",
    "act.edu.au",
    "catholic.edu.au",
    "nsw.edu.au",
    "nt.edu.au",
    "qld.edu.au",
    "sa.edu.au",
    "tas.edu.au",
    "vic.edu.au",
    "wa.edu.au",
    "qld.gov.au",
    "sa.gov.au",
    "tas.gov.au",
    "vic.gov.au",
    "wa.gov.au",
    "schools.nsw.edu.au",
    "aw",
    "com.aw",
    "ax",
    "az",
    "com.az",
    "net.az",
    "int.az",
    "gov.az",
    "org.az",
    "edu.az",
    "info.az",
    "pp.az",
    "mil.az",
    "name.az",
    "pro.az",
    "biz.az",
    "ba",
    "com.ba",
    "edu.ba",
    "gov.ba",
    "mil.ba",
    "net.ba",
    "org.ba",
    "bb",
    "biz.bb",
    "co.bb",
    "com.bb",
    "edu.bb",
    "gov.bb",
    "info.bb",
    "net.bb",
    "org.bb",
    "store.bb",
    "tv.bb",
    "*.bd",
    "be",
    "ac.be",
    "bf",
    "gov.bf",
    "bg",
    "a.bg",
    "b.bg",
    "c.bg",
    "d.bg",
    "e.bg",
    "f.bg",
    "g.bg",
    "h.bg",
    "i.bg",
    "j.bg",
    "k.bg",
    "l.bg",
    "m.bg",
    "n.bg",
    "o.bg",
    "p.bg",
    "q.bg",
    "r.bg",
    "s.bg",
    "t.bg",
    "u.bg",
    "v.bg",
    "w.bg",
    "x.bg",
    "y.bg",
    "z.bg",
    "0.bg",
    "1.bg",
    "2.bg",
    "3.bg",
    "4.bg",
    "5.bg",
    "6.bg",
    "7.bg",
    "8.bg",
    "9.bg",
    "bh",
    "com.bh",
    "edu.bh",
    "net.bh",
    "org.bh",
    "gov.bh",
    "bi",
    "co.bi",
    "com.bi",
    "edu.bi",
    "or.bi",
    "org.bi",
    "biz",
    "bj",
    "asso.bj",
    "barreau.bj",
    "gouv.bj",
    "bm",
    "com.bm",
    "edu.bm",
    "gov.bm",
    "net.bm",
    "org.bm",
    "bn",
    "com.bn",
    "edu.bn",
    "gov.bn",
    "net.bn",
    "org.bn",
    "bo",
    "com.bo",
    "edu.bo",
    "gob.bo",
    "int.bo",
    "org.bo",
    "net.bo",
    "mil.bo",
    "tv.bo",
    "web.bo",
    "academia.bo",
    "agro.bo",
    "arte.bo",
    "blog.bo",
    "bolivia.bo",
    "ciencia.bo",
    "cooperativa.bo",
    "democracia.bo",
    "deporte.bo",
    "ecologia.bo",
    "economia.bo",
    "empresa.bo",
    "indigena.bo",
    "industria.bo",
    "info.bo",
    "medicina.bo",
    "movimiento.bo",
    "musica.bo",
    "natural.bo",
    "nombre.bo",
    "noticias.bo",
    "patria.bo",
    "politica.bo",
    "profesional.bo",
    "plurinacional.bo",
    "pueblo.bo",
    "revista.bo",
    "salud.bo",
    "tecnologia.bo",
    "tksat.bo",
    "transporte.bo",
    "wiki.bo",
    "br",
    "9guacu.br",
    "abc.br",
    "adm.br",
    "adv.br",
    "agr.br",
    "aju.br",
    "am.br",
    "anani.br",
    "aparecida.br",
    "app.br",
    "arq.br",
    "art.br",
    "ato.br",
    "b.br",
    "barueri.br",
    "belem.br",
    "bhz.br",
    "bib.br",
    "bio.br",
    "blog.br",
    "bmd.br",
    "boavista.br",
    "bsb.br",
    "campinagrande.br",
    "campinas.br",
    "caxias.br",
    "cim.br",
    "cng.br",
    "cnt.br",
    "com.br",
    "contagem.br",
    "coop.br",
    "coz.br",
    "cri.br",
    "cuiaba.br",
    "curitiba.br",
    "def.br",
    "des.br",
    "det.br",
    "dev.br",
    "ecn.br",
    "eco.br",
    "edu.br",
    "emp.br",
    "enf.br",
    "eng.br",
    "esp.br",
    "etc.br",
    "eti.br",
    "far.br",
    "feira.br",
    "flog.br",
    "floripa.br",
    "fm.br",
    "fnd.br",
    "fortal.br",
    "fot.br",
    "foz.br",
    "fst.br",
    "g12.br",
    "geo.br",
    "ggf.br",
    "goiania.br",
    "gov.br",
    "ac.gov.br",
    "al.gov.br",
    "am.gov.br",
    "ap.gov.br",
    "ba.gov.br",
    "ce.gov.br",
    "df.gov.br",
    "es.gov.br",
    "go.gov.br",
    "ma.gov.br",
    "mg.gov.br",
    "ms.gov.br",
    "mt.gov.br",
    "pa.gov.br",
    "pb.gov.br",
    "pe.gov.br",
    "pi.gov.br",
    "pr.gov.br",
    "rj.gov.br",
    "rn.gov.br",
    "ro.gov.br",
    "rr.gov.br",
    "rs.gov.br",
    "sc.gov.br",
    "se.gov.br",
    "sp.gov.br",
    "to.gov.br",
    "gru.br",
    "imb.br",
    "ind.br",
    "inf.br",
    "jab.br",
    "jampa.br",
    "jdf.br",
    "joinville.br",
    "jor.br",
    "jus.br",
    "leg.br",
    "lel.br",
    "log.br",
    "londrina.br",
    "macapa.br",
    "maceio.br",
    "manaus.br",
    "maringa.br",
    "mat.br",
    "med.br",
    "mil.br",
    "morena.br",
    "mp.br",
    "mus.br",
    "natal.br",
    "net.br",
    "niteroi.br",
    "*.nom.br",
    "not.br",
    "ntr.br",
    "odo.br",
    "ong.br",
    "org.br",
    "osasco.br",
    "palmas.br",
    "poa.br",
    "ppg.br",
    "pro.br",
    "psc.br",
    "psi.br",
    "pvh.br",
    "qsl.br",
    "radio.br",
    "rec.br",
    "recife.br",
    "rep.br",
    "ribeirao.br",
    "rio.br",
    "riobranco.br",
    "riopreto.br",
    "salvador.br",
    "sampa.br",
    "santamaria.br",
    "santoandre.br",
    "saobernardo.br",
    "saogonca.br",
    "seg.br",
    "sjc.br",
    "slg.br",
    "slz.br",
    "sorocaba.br",
    "srv.br",
    "taxi.br",
    "tc.br",
    "tec.br",
    "teo.br",
    "the.br",
    "tmp.br",
    "trd.br",
    "tur.br",
    "tv.br",
    "udi.br",
    "vet.br",
    "vix.br",
    "vlog.br",
    "wiki.br",
    "zlg.br",
    "bs",
    "com.bs",
    "net.bs",
    "org.bs",
    "edu.bs",
    "gov.bs",
    "bt",
    "com.bt",
    "edu.bt",
    "gov.bt",
    "net.bt",
    "org.bt",
    "bv",
    "bw",
    "co.bw",
    "org.bw",
    "by",
    "gov.by",
    "mil.by",
    "com.by",
    "of.by",
    "bz",
    "com.bz",
    "net.bz",
    "org.bz",
    "edu.bz",
    "gov.bz",
    "ca",
    "ab.ca",
    "bc.ca",
    "mb.ca",
    "nb.ca",
    "nf.ca",
    "nl.ca",
    "ns.ca",
    "nt.ca",
    "nu.ca",
    "on.ca",
    "pe.ca",
    "qc.ca",
    "sk.ca",
    "yk.ca",
    "gc.ca",
    "cat",
    "cc",
    "cd",
    "gov.cd",
    "cf",
    "cg",
    "ch",
    "ci",
    "org.ci",
    "or.ci",
    "com.ci",
    "co.ci",
    "edu.ci",
    "ed.ci",
    "ac.ci",
    "net.ci",
    "go.ci",
    "asso.ci",
    "aroport.ci",
    "int.ci",
    "presse.ci",
    "md.ci",
    "gouv.ci",
    "*.ck",
    "!www.ck",
    "cl",
    "co.cl",
    "gob.cl",
    "gov.cl",
    "mil.cl",
    "cm",
    "co.cm",
    "com.cm",
    "gov.cm",
    "net.cm",
    "cn",
    "ac.cn",
    "com.cn",
    "edu.cn",
    "gov.cn",
    "net.cn",
    "org.cn",
    "mil.cn",
    ".cn",
    ".cn",
    ".cn",
    "ah.cn",
    "bj.cn",
    "cq.cn",
    "fj.cn",
    "gd.cn",
    "gs.cn",
    "gz.cn",
    "gx.cn",
    "ha.cn",
    "hb.cn",
    "he.cn",
    "hi.cn",
    "hl.cn",
    "hn.cn",
    "jl.cn",
    "js.cn",
    "jx.cn",
    "ln.cn",
    "nm.cn",
    "nx.cn",
    "qh.cn",
    "sc.cn",
    "sd.cn",
    "sh.cn",
    "sn.cn",
    "sx.cn",
    "tj.cn",
    "xj.cn",
    "xz.cn",
    "yn.cn",
    "zj.cn",
    "hk.cn",
    "mo.cn",
    "tw.cn",
    "co",
    "arts.co",
    "com.co",
    "edu.co",
    "firm.co",
    "gov.co",
    "info.co",
    "int.co",
    "mil.co",
    "net.co",
    "nom.co",
    "org.co",
    "rec.co",
    "web.co",
    "com",
    "coop",
    "cr",
    "ac.cr",
    "co.cr",
    "ed.cr",
    "fi.cr",
    "go.cr",
    "or.cr",
    "sa.cr",
    "cu",
    "com.cu",
    "edu.cu",
    "org.cu",
    "net.cu",
    "gov.cu",
    "inf.cu",
    "cv",
    "com.cv",
    "edu.cv",
    "int.cv",
    "nome.cv",
    "org.cv",
    "cw",
    "com.cw",
    "edu.cw",
    "net.cw",
    "org.cw",
    "cx",
    "gov.cx",
    "cy",
    "ac.cy",
    "biz.cy",
    "com.cy",
    "ekloges.cy",
    "gov.cy",
    "ltd.cy",
    "mil.cy",
    "net.cy",
    "org.cy",
    "press.cy",
    "pro.cy",
    "tm.cy",
    "cz",
    "de",
    "dj",
    "dk",
    "dm",
    "com.dm",
    "net.dm",
    "org.dm",
    "edu.dm",
    "gov.dm",
    "do",
    "art.do",
    "com.do",
    "edu.do",
    "gob.do",
    "gov.do",
    "mil.do",
    "net.do",
    "org.do",
    "sld.do",
    "web.do",
    "dz",
    "art.dz",
    "asso.dz",
    "com.dz",
    "edu.dz",
    "gov.dz",
    "org.dz",
    "net.dz",
    "pol.dz",
    "soc.dz",
    "tm.dz",
    "ec",
    "com.ec",
    "info.ec",
    "net.ec",
    "fin.ec",
    "k12.ec",
    "med.ec",
    "pro.ec",
    "org.ec",
    "edu.ec",
    "gov.ec",
    "gob.ec",
    "mil.ec",
    "edu",
    "ee",
    "edu.ee",
    "gov.ee",
    "riik.ee",
    "lib.ee",
    "med.ee",
    "com.ee",
    "pri.ee",
    "aip.ee",
    "org.ee",
    "fie.ee",
    "eg",
    "com.eg",
    "edu.eg",
    "eun.eg",
    "gov.eg",
    "mil.eg",
    "name.eg",
    "net.eg",
    "org.eg",
    "sci.eg",
    "*.er",
    "es",
    "com.es",
    "nom.es",
    "org.es",
    "gob.es",
    "edu.es",
    "et",
    "com.et",
    "gov.et",
    "org.et",
    "edu.et",
    "biz.et",
    "name.et",
    "info.et",
    "net.et",
    "eu",
    "fi",
    "aland.fi",
    "fj",
    "ac.fj",
    "biz.fj",
    "com.fj",
    "gov.fj",
    "info.fj",
    "mil.fj",
    "name.fj",
    "net.fj",
    "org.fj",
    "pro.fj",
    "*.fk",
    "com.fm",
    "edu.fm",
    "net.fm",
    "org.fm",
    "fm",
    "fo",
    "fr",
    "asso.fr",
    "com.fr",
    "gouv.fr",
    "nom.fr",
    "prd.fr",
    "tm.fr",
    "aeroport.fr",
    "avocat.fr",
    "avoues.fr",
    "cci.fr",
    "chambagri.fr",
    "chirurgiens-dentistes.fr",
    "experts-comptables.fr",
    "geometre-expert.fr",
    "greta.fr",
    "huissier-justice.fr",
    "medecin.fr",
    "notaires.fr",
    "pharmacien.fr",
    "port.fr",
    "veterinaire.fr",
    "ga",
    "gb",
    "edu.gd",
    "gov.gd",
    "gd",
    "ge",
    "com.ge",
    "edu.ge",
    "gov.ge",
    "org.ge",
    "mil.ge",
    "net.ge",
    "pvt.ge",
    "gf",
    "gg",
    "co.gg",
    "net.gg",
    "org.gg",
    "gh",
    "com.gh",
    "edu.gh",
    "gov.gh",
    "org.gh",
    "mil.gh",
    "gi",
    "com.gi",
    "ltd.gi",
    "gov.gi",
    "mod.gi",
    "edu.gi",
    "org.gi",
    "gl",
    "co.gl",
    "com.gl",
    "edu.gl",
    "net.gl",
    "org.gl",
    "gm",
    "gn",
    "ac.gn",
    "com.gn",
    "edu.gn",
    "gov.gn",
    "org.gn",
    "net.gn",
    "gov",
    "gp",
    "com.gp",
    "net.gp",
    "mobi.gp",
    "edu.gp",
    "org.gp",
    "asso.gp",
    "gq",
    "gr",
    "com.gr",
    "edu.gr",
    "net.gr",
    "org.gr",
    "gov.gr",
    "gs",
    "gt",
    "com.gt",
    "edu.gt",
    "gob.gt",
    "ind.gt",
    "mil.gt",
    "net.gt",
    "org.gt",
    "gu",
    "com.gu",
    "edu.gu",
    "gov.gu",
    "guam.gu",
    "info.gu",
    "net.gu",
    "org.gu",
    "web.gu",
    "gw",
    "gy",
    "co.gy",
    "com.gy",
    "edu.gy",
    "gov.gy",
    "net.gy",
    "org.gy",
    "hk",
    "com.hk",
    "edu.hk",
    "gov.hk",
    "idv.hk",
    "net.hk",
    "org.hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    ".hk",
    "hm",
    "hn",
    "com.hn",
    "edu.hn",
    "org.hn",
    "net.hn",
    "mil.hn",
    "gob.hn",
    "hr",
    "iz.hr",
    "from.hr",
    "name.hr",
    "com.hr",
    "ht",
    "com.ht",
    "shop.ht",
    "firm.ht",
    "info.ht",
    "adult.ht",
    "net.ht",
    "pro.ht",
    "org.ht",
    "med.ht",
    "art.ht",
    "coop.ht",
    "pol.ht",
    "asso.ht",
    "edu.ht",
    "rel.ht",
    "gouv.ht",
    "perso.ht",
    "hu",
    "co.hu",
    "info.hu",
    "org.hu",
    "priv.hu",
    "sport.hu",
    "tm.hu",
    "2000.hu",
    "agrar.hu",
    "bolt.hu",
    "casino.hu",
    "city.hu",
    "erotica.hu",
    "erotika.hu",
    "film.hu",
    "forum.hu",
    "games.hu",
    "hotel.hu",
    "ingatlan.hu",
    "jogasz.hu",
    "konyvelo.hu",
    "lakas.hu",
    "media.hu",
    "news.hu",
    "reklam.hu",
    "sex.hu",
    "shop.hu",
    "suli.hu",
    "szex.hu",
    "tozsde.hu",
    "utazas.hu",
    "video.hu",
    "id",
    "ac.id",
    "biz.id",
    "co.id",
    "desa.id",
    "go.id",
    "mil.id",
    "my.id",
    "net.id",
    "or.id",
    "ponpes.id",
    "sch.id",
    "web.id",
    "ie",
    "gov.ie",
    "il",
    "ac.il",
    "co.il",
    "gov.il",
    "idf.il",
    "k12.il",
    "muni.il",
    "net.il",
    "org.il",
    "im",
    "ac.im",
    "co.im",
    "com.im",
    "ltd.co.im",
    "net.im",
    "org.im",
    "plc.co.im",
    "tt.im",
    "tv.im",
    "in",
    "co.in",
    "firm.in",
    "net.in",
    "org.in",
    "gen.in",
    "ind.in",
    "nic.in",
    "ac.in",
    "edu.in",
    "res.in",
    "gov.in",
    "mil.in",
    "info",
    "int",
    "eu.int",
    "io",
    "com.io",
    "iq",
    "gov.iq",
    "edu.iq",
    "mil.iq",
    "com.iq",
    "org.iq",
    "net.iq",
    "ir",
    "ac.ir",
    "co.ir",
    "gov.ir",
    "id.ir",
    "net.ir",
    "org.ir",
    "sch.ir",
    ".ir",
    ".ir",
    "is",
    "net.is",
    "com.is",
    "edu.is",
    "gov.is",
    "org.is",
    "int.is",
    "it",
    "gov.it",
    "edu.it",
    "abr.it",
    "abruzzo.it",
    "aosta-valley.it",
    "aostavalley.it",
    "bas.it",
    "basilicata.it",
    "cal.it",
    "calabria.it",
    "cam.it",
    "campania.it",
    "emilia-romagna.it",
    "emiliaromagna.it",
    "emr.it",
    "friuli-v-giulia.it",
    "friuli-ve-giulia.it",
    "friuli-vegiulia.it",
    "friuli-venezia-giulia.it",
    "friuli-veneziagiulia.it",
    "friuli-vgiulia.it",
    "friuliv-giulia.it",
    "friulive-giulia.it",
    "friulivegiulia.it",
    "friulivenezia-giulia.it",
    "friuliveneziagiulia.it",
    "friulivgiulia.it",
    "fvg.it",
    "laz.it",
    "lazio.it",
    "lig.it",
    "liguria.it",
    "lom.it",
    "lombardia.it",
    "lombardy.it",
    "lucania.it",
    "mar.it",
    "marche.it",
    "mol.it",
    "molise.it",
    "piedmont.it",
    "piemonte.it",
    "pmn.it",
    "pug.it",
    "puglia.it",
    "sar.it",
    "sardegna.it",
    "sardinia.it",
    "sic.it",
    "sicilia.it",
    "sicily.it",
    "taa.it",
    "tos.it",
    "toscana.it",
    "trentin-sud-tirol.it",
    "trentin-sd-tirol.it",
    "trentin-sudtirol.it",
    "trentin-sdtirol.it",
    "trentin-sued-tirol.it",
    "trentin-suedtirol.it",
    "trentino-a-adige.it",
    "trentino-aadige.it",
    "trentino-alto-adige.it",
    "trentino-altoadige.it",
    "trentino-s-tirol.it",
    "trentino-stirol.it",
    "trentino-sud-tirol.it",
    "trentino-sd-tirol.it",
    "trentino-sudtirol.it",
    "trentino-sdtirol.it",
    "trentino-sued-tirol.it",
    "trentino-suedtirol.it",
    "trentino.it",
    "trentinoa-adige.it",
    "trentinoaadige.it",
    "trentinoalto-adige.it",
    "trentinoaltoadige.it",
    "trentinos-tirol.it",
    "trentinostirol.it",
    "trentinosud-tirol.it",
    "trentinosd-tirol.it",
    "trentinosudtirol.it",
    "trentinosdtirol.it",
    "trentinosued-tirol.it",
    "trentinosuedtirol.it",
    "trentinsud-tirol.it",
    "trentinsd-tirol.it",
    "trentinsudtirol.it",
    "trentinsdtirol.it",
    "trentinsued-tirol.it",
    "trentinsuedtirol.it",
    "tuscany.it",
    "umb.it",
    "umbria.it",
    "val-d-aosta.it",
    "val-daosta.it",
    "vald-aosta.it",
    "valdaosta.it",
    "valle-aosta.it",
    "valle-d-aosta.it",
    "valle-daosta.it",
    "valleaosta.it",
    "valled-aosta.it",
    "valledaosta.it",
    "vallee-aoste.it",
    "valle-aoste.it",
    "vallee-d-aoste.it",
    "valle-d-aoste.it",
    "valleeaoste.it",
    "valleaoste.it",
    "valleedaoste.it",
    "valledaoste.it",
    "vao.it",
    "vda.it",
    "ven.it",
    "veneto.it",
    "ag.it",
    "agrigento.it",
    "al.it",
    "alessandria.it",
    "alto-adige.it",
    "altoadige.it",
    "an.it",
    "ancona.it",
    "andria-barletta-trani.it",
    "andria-trani-barletta.it",
    "andriabarlettatrani.it",
    "andriatranibarletta.it",
    "ao.it",
    "aosta.it",
    "aoste.it",
    "ap.it",
    "aq.it",
    "aquila.it",
    "ar.it",
    "arezzo.it",
    "ascoli-piceno.it",
    "ascolipiceno.it",
    "asti.it",
    "at.it",
    "av.it",
    "avellino.it",
    "ba.it",
    "balsan-sudtirol.it",
    "balsan-sdtirol.it",
    "balsan-suedtirol.it",
    "balsan.it",
    "bari.it",
    "barletta-trani-andria.it",
    "barlettatraniandria.it",
    "belluno.it",
    "benevento.it",
    "bergamo.it",
    "bg.it",
    "bi.it",
    "biella.it",
    "bl.it",
    "bn.it",
    "bo.it",
    "bologna.it",
    "bolzano-altoadige.it",
    "bolzano.it",
    "bozen-sudtirol.it",
    "bozen-sdtirol.it",
    "bozen-suedtirol.it",
    "bozen.it",
    "br.it",
    "brescia.it",
    "brindisi.it",
    "bs.it",
    "bt.it",
    "bulsan-sudtirol.it",
    "bulsan-sdtirol.it",
    "bulsan-suedtirol.it",
    "bulsan.it",
    "bz.it",
    "ca.it",
    "cagliari.it",
    "caltanissetta.it",
    "campidano-medio.it",
    "campidanomedio.it",
    "campobasso.it",
    "carbonia-iglesias.it",
    "carboniaiglesias.it",
    "carrara-massa.it",
    "carraramassa.it",
    "caserta.it",
    "catania.it",
    "catanzaro.it",
    "cb.it",
    "ce.it",
    "cesena-forli.it",
    "cesena-forl.it",
    "cesenaforli.it",
    "cesenaforl.it",
    "ch.it",
    "chieti.it",
    "ci.it",
    "cl.it",
    "cn.it",
    "co.it",
    "como.it",
    "cosenza.it",
    "cr.it",
    "cremona.it",
    "crotone.it",
    "cs.it",
    "ct.it",
    "cuneo.it",
    "cz.it",
    "dell-ogliastra.it",
    "dellogliastra.it",
    "en.it",
    "enna.it",
    "fc.it",
    "fe.it",
    "fermo.it",
    "ferrara.it",
    "fg.it",
    "fi.it",
    "firenze.it",
    "florence.it",
    "fm.it",
    "foggia.it",
    "forli-cesena.it",
    "forl-cesena.it",
    "forlicesena.it",
    "forlcesena.it",
    "fr.it",
    "frosinone.it",
    "ge.it",
    "genoa.it",
    "genova.it",
    "go.it",
    "gorizia.it",
    "gr.it",
    "grosseto.it",
    "iglesias-carbonia.it",
    "iglesiascarbonia.it",
    "im.it",
    "imperia.it",
    "is.it",
    "isernia.it",
    "kr.it",
    "la-spezia.it",
    "laquila.it",
    "laspezia.it",
    "latina.it",
    "lc.it",
    "le.it",
    "lecce.it",
    "lecco.it",
    "li.it",
    "livorno.it",
    "lo.it",
    "lodi.it",
    "lt.it",
    "lu.it",
    "lucca.it",
    "macerata.it",
    "mantova.it",
    "massa-carrara.it",
    "massacarrara.it",
    "matera.it",
    "mb.it",
    "mc.it",
    "me.it",
    "medio-campidano.it",
    "mediocampidano.it",
    "messina.it",
    "mi.it",
    "milan.it",
    "milano.it",
    "mn.it",
    "mo.it",
    "modena.it",
    "monza-brianza.it",
    "monza-e-della-brianza.it",
    "monza.it",
    "monzabrianza.it",
    "monzaebrianza.it",
    "monzaedellabrianza.it",
    "ms.it",
    "mt.it",
    "na.it",
    "naples.it",
    "napoli.it",
    "no.it",
    "novara.it",
    "nu.it",
    "nuoro.it",
    "og.it",
    "ogliastra.it",
    "olbia-tempio.it",
    "olbiatempio.it",
    "or.it",
    "oristano.it",
    "ot.it",
    "pa.it",
    "padova.it",
    "padua.it",
    "palermo.it",
    "parma.it",
    "pavia.it",
    "pc.it",
    "pd.it",
    "pe.it",
    "perugia.it",
    "pesaro-urbino.it",
    "pesarourbino.it",
    "pescara.it",
    "pg.it",
    "pi.it",
    "piacenza.it",
    "pisa.it",
    "pistoia.it",
    "pn.it",
    "po.it",
    "pordenone.it",
    "potenza.it",
    "pr.it",
    "prato.it",
    "pt.it",
    "pu.it",
    "pv.it",
    "pz.it",
    "ra.it",
    "ragusa.it",
    "ravenna.it",
    "rc.it",
    "re.it",
    "reggio-calabria.it",
    "reggio-emilia.it",
    "reggiocalabria.it",
    "reggioemilia.it",
    "rg.it",
    "ri.it",
    "rieti.it",
    "rimini.it",
    "rm.it",
    "rn.it",
    "ro.it",
    "roma.it",
    "rome.it",
    "rovigo.it",
    "sa.it",
    "salerno.it",
    "sassari.it",
    "savona.it",
    "si.it",
    "siena.it",
    "siracusa.it",
    "so.it",
    "sondrio.it",
    "sp.it",
    "sr.it",
    "ss.it",
    "suedtirol.it",
    "sdtirol.it",
    "sv.it",
    "ta.it",
    "taranto.it",
    "te.it",
    "tempio-olbia.it",
    "tempioolbia.it",
    "teramo.it",
    "terni.it",
    "tn.it",
    "to.it",
    "torino.it",
    "tp.it",
    "tr.it",
    "trani-andria-barletta.it",
    "trani-barletta-andria.it",
    "traniandriabarletta.it",
    "tranibarlettaandria.it",
    "trapani.it",
    "trento.it",
    "treviso.it",
    "trieste.it",
    "ts.it",
    "turin.it",
    "tv.it",
    "ud.it",
    "udine.it",
    "urbino-pesaro.it",
    "urbinopesaro.it",
    "va.it",
    "varese.it",
    "vb.it",
    "vc.it",
    "ve.it",
    "venezia.it",
    "venice.it",
    "verbania.it",
    "vercelli.it",
    "verona.it",
    "vi.it",
    "vibo-valentia.it",
    "vibovalentia.it",
    "vicenza.it",
    "viterbo.it",
    "vr.it",
    "vs.it",
    "vt.it",
    "vv.it",
    "je",
    "co.je",
    "net.je",
    "org.je",
    "*.jm",
    "jo",
    "com.jo",
    "org.jo",
    "net.jo",
    "edu.jo",
    "sch.jo",
    "gov.jo",
    "mil.jo",
    "name.jo",
    "jobs",
    "jp",
    "ac.jp",
    "ad.jp",
    "co.jp",
    "ed.jp",
    "go.jp",
    "gr.jp",
    "lg.jp",
    "ne.jp",
    "or.jp",
    "aichi.jp",
    "akita.jp",
    "aomori.jp",
    "chiba.jp",
    "ehime.jp",
    "fukui.jp",
    "fukuoka.jp",
    "fukushima.jp",
    "gifu.jp",
    "gunma.jp",
    "hiroshima.jp",
    "hokkaido.jp",
    "hyogo.jp",
    "ibaraki.jp",
    "ishikawa.jp",
    "iwate.jp",
    "kagawa.jp",
    "kagoshima.jp",
    "kanagawa.jp",
    "kochi.jp",
    "kumamoto.jp",
    "kyoto.jp",
    "mie.jp",
    "miyagi.jp",
    "miyazaki.jp",
    "nagano.jp",
    "nagasaki.jp",
    "nara.jp",
    "niigata.jp",
    "oita.jp",
    "okayama.jp",
    "okinawa.jp",
    "osaka.jp",
    "saga.jp",
    "saitama.jp",
    "shiga.jp",
    "shimane.jp",
    "shizuoka.jp",
    "tochigi.jp",
    "tokushima.jp",
    "tokyo.jp",
    "tottori.jp",
    "toyama.jp",
    "wakayama.jp",
    "yamagata.jp",
    "yamaguchi.jp",
    "yamanashi.jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    ".jp",
    "*.kawasaki.jp",
    "*.kitakyushu.jp",
    "*.kobe.jp",
    "*.nagoya.jp",
    "*.sapporo.jp",
    "*.sendai.jp",
    "*.yokohama.jp",
    "!city.kawasaki.jp",
    "!city.kitakyushu.jp",
    "!city.kobe.jp",
    "!city.nagoya.jp",
    "!city.sapporo.jp",
    "!city.sendai.jp",
    "!city.yokohama.jp",
    "aisai.aichi.jp",
    "ama.aichi.jp",
    "anjo.aichi.jp",
    "asuke.aichi.jp",
    "chiryu.aichi.jp",
    "chita.aichi.jp",
    "fuso.aichi.jp",
    "gamagori.aichi.jp",
    "handa.aichi.jp",
    "hazu.aichi.jp",
    "hekinan.aichi.jp",
    "higashiura.aichi.jp",
    "ichinomiya.aichi.jp",
    "inazawa.aichi.jp",
    "inuyama.aichi.jp",
    "isshiki.aichi.jp",
    "iwakura.aichi.jp",
    "kanie.aichi.jp",
    "kariya.aichi.jp",
    "kasugai.aichi.jp",
    "kira.aichi.jp",
    "kiyosu.aichi.jp",
    "komaki.aichi.jp",
    "konan.aichi.jp",
    "kota.aichi.jp",
    "mihama.aichi.jp",
    "miyoshi.aichi.jp",
    "nishio.aichi.jp",
    "nisshin.aichi.jp",
    "obu.aichi.jp",
    "oguchi.aichi.jp",
    "oharu.aichi.jp",
    "okazaki.aichi.jp",
    "owariasahi.aichi.jp",
    "seto.aichi.jp",
    "shikatsu.aichi.jp",
    "shinshiro.aichi.jp",
    "shitara.aichi.jp",
    "tahara.aichi.jp",
    "takahama.aichi.jp",
    "tobishima.aichi.jp",
    "toei.aichi.jp",
    "togo.aichi.jp",
    "tokai.aichi.jp",
    "tokoname.aichi.jp",
    "toyoake.aichi.jp",
    "toyohashi.aichi.jp",
    "toyokawa.aichi.jp",
    "toyone.aichi.jp",
    "toyota.aichi.jp",
    "tsushima.aichi.jp",
    "yatomi.aichi.jp",
    "akita.akita.jp",
    "daisen.akita.jp",
    "fujisato.akita.jp",
    "gojome.akita.jp",
    "hachirogata.akita.jp",
    "happou.akita.jp",
    "higashinaruse.akita.jp",
    "honjo.akita.jp",
    "honjyo.akita.jp",
    "ikawa.akita.jp",
    "kamikoani.akita.jp",
    "kamioka.akita.jp",
    "katagami.akita.jp",
    "kazuno.akita.jp",
    "kitaakita.akita.jp",
    "kosaka.akita.jp",
    "kyowa.akita.jp",
    "misato.akita.jp",
    "mitane.akita.jp",
    "moriyoshi.akita.jp",
    "nikaho.akita.jp",
    "noshiro.akita.jp",
    "odate.akita.jp",
    "oga.akita.jp",
    "ogata.akita.jp",
    "semboku.akita.jp",
    "yokote.akita.jp",
    "yurihonjo.akita.jp",
    "aomori.aomori.jp",
    "gonohe.aomori.jp",
    "hachinohe.aomori.jp",
    "hashikami.aomori.jp",
    "hiranai.aomori.jp",
    "hirosaki.aomori.jp",
    "itayanagi.aomori.jp",
    "kuroishi.aomori.jp",
    "misawa.aomori.jp",
    "mutsu.aomori.jp",
    "nakadomari.aomori.jp",
    "noheji.aomori.jp",
    "oirase.aomori.jp",
    "owani.aomori.jp",
    "rokunohe.aomori.jp",
    "sannohe.aomori.jp",
    "shichinohe.aomori.jp",
    "shingo.aomori.jp",
    "takko.aomori.jp",
    "towada.aomori.jp",
    "tsugaru.aomori.jp",
    "tsuruta.aomori.jp",
    "abiko.chiba.jp",
    "asahi.chiba.jp",
    "chonan.chiba.jp",
    "chosei.chiba.jp",
    "choshi.chiba.jp",
    "chuo.chiba.jp",
    "funabashi.chiba.jp",
    "futtsu.chiba.jp",
    "hanamigawa.chiba.jp",
    "ichihara.chiba.jp",
    "ichikawa.chiba.jp",
    "ichinomiya.chiba.jp",
    "inzai.chiba.jp",
    "isumi.chiba.jp",
    "kamagaya.chiba.jp",
    "kamogawa.chiba.jp",
    "kashiwa.chiba.jp",
    "katori.chiba.jp",
    "katsuura.chiba.jp",
    "kimitsu.chiba.jp",
    "kisarazu.chiba.jp",
    "kozaki.chiba.jp",
    "kujukuri.chiba.jp",
    "kyonan.chiba.jp",
    "matsudo.chiba.jp",
    "midori.chiba.jp",
    "mihama.chiba.jp",
    "minamiboso.chiba.jp",
    "mobara.chiba.jp",
    "mutsuzawa.chiba.jp",
    "nagara.chiba.jp",
    "nagareyama.chiba.jp",
    "narashino.chiba.jp",
    "narita.chiba.jp",
    "noda.chiba.jp",
    "oamishirasato.chiba.jp",
    "omigawa.chiba.jp",
    "onjuku.chiba.jp",
    "otaki.chiba.jp",
    "sakae.chiba.jp",
    "sakura.chiba.jp",
    "shimofusa.chiba.jp",
    "shirako.chiba.jp",
    "shiroi.chiba.jp",
    "shisui.chiba.jp",
    "sodegaura.chiba.jp",
    "sosa.chiba.jp",
    "tako.chiba.jp",
    "tateyama.chiba.jp",
    "togane.chiba.jp",
    "tohnosho.chiba.jp",
    "tomisato.chiba.jp",
    "urayasu.chiba.jp",
    "yachimata.chiba.jp",
    "yachiyo.chiba.jp",
    "yokaichiba.chiba.jp",
    "yokoshibahikari.chiba.jp",
    "yotsukaido.chiba.jp",
    "ainan.ehime.jp",
    "honai.ehime.jp",
    "ikata.ehime.jp",
    "imabari.ehime.jp",
    "iyo.ehime.jp",
    "kamijima.ehime.jp",
    "kihoku.ehime.jp",
    "kumakogen.ehime.jp",
    "masaki.ehime.jp",
    "matsuno.ehime.jp",
    "matsuyama.ehime.jp",
    "namikata.ehime.jp",
    "niihama.ehime.jp",
    "ozu.ehime.jp",
    "saijo.ehime.jp",
    "seiyo.ehime.jp",
    "shikokuchuo.ehime.jp",
    "tobe.ehime.jp",
    "toon.ehime.jp",
    "uchiko.ehime.jp",
    "uwajima.ehime.jp",
    "yawatahama.ehime.jp",
    "echizen.fukui.jp",
    "eiheiji.fukui.jp",
    "fukui.fukui.jp",
    "ikeda.fukui.jp",
    "katsuyama.fukui.jp",
    "mihama.fukui.jp",
    "minamiechizen.fukui.jp",
    "obama.fukui.jp",
    "ohi.fukui.jp",
    "ono.fukui.jp",
    "sabae.fukui.jp",
    "sakai.fukui.jp",
    "takahama.fukui.jp",
    "tsuruga.fukui.jp",
    "wakasa.fukui.jp",
    "ashiya.fukuoka.jp",
    "buzen.fukuoka.jp",
    "chikugo.fukuoka.jp",
    "chikuho.fukuoka.jp",
    "chikujo.fukuoka.jp",
    "chikushino.fukuoka.jp",
    "chikuzen.fukuoka.jp",
    "chuo.fukuoka.jp",
    "dazaifu.fukuoka.jp",
    "fukuchi.fukuoka.jp",
    "hakata.fukuoka.jp",
    "higashi.fukuoka.jp",
    "hirokawa.fukuoka.jp",
    "hisayama.fukuoka.jp",
    "iizuka.fukuoka.jp",
    "inatsuki.fukuoka.jp",
    "kaho.fukuoka.jp",
    "kasuga.fukuoka.jp",
    "kasuya.fukuoka.jp",
    "kawara.fukuoka.jp",
    "keisen.fukuoka.jp",
    "koga.fukuoka.jp",
    "kurate.fukuoka.jp",
    "kurogi.fukuoka.jp",
    "kurume.fukuoka.jp",
    "minami.fukuoka.jp",
    "miyako.fukuoka.jp",
    "miyama.fukuoka.jp",
    "miyawaka.fukuoka.jp",
    "mizumaki.fukuoka.jp",
    "munakata.fukuoka.jp",
    "nakagawa.fukuoka.jp",
    "nakama.fukuoka.jp",
    "nishi.fukuoka.jp",
    "nogata.fukuoka.jp",
    "ogori.fukuoka.jp",
    "okagaki.fukuoka.jp",
    "okawa.fukuoka.jp",
    "oki.fukuoka.jp",
    "omuta.fukuoka.jp",
    "onga.fukuoka.jp",
    "onojo.fukuoka.jp",
    "oto.fukuoka.jp",
    "saigawa.fukuoka.jp",
    "sasaguri.fukuoka.jp",
    "shingu.fukuoka.jp",
    "shinyoshitomi.fukuoka.jp",
    "shonai.fukuoka.jp",
    "soeda.fukuoka.jp",
    "sue.fukuoka.jp",
    "tachiarai.fukuoka.jp",
    "tagawa.fukuoka.jp",
    "takata.fukuoka.jp",
    "toho.fukuoka.jp",
    "toyotsu.fukuoka.jp",
    "tsuiki.fukuoka.jp",
    "ukiha.fukuoka.jp",
    "umi.fukuoka.jp",
    "usui.fukuoka.jp",
    "yamada.fukuoka.jp",
    "yame.fukuoka.jp",
    "yanagawa.fukuoka.jp",
    "yukuhashi.fukuoka.jp",
    "aizubange.fukushima.jp",
    "aizumisato.fukushima.jp",
    "aizuwakamatsu.fukushima.jp",
    "asakawa.fukushima.jp",
    "bandai.fukushima.jp",
    "date.fukushima.jp",
    "fukushima.fukushima.jp",
    "furudono.fukushima.jp",
    "futaba.fukushima.jp",
    "hanawa.fukushima.jp",
    "higashi.fukushima.jp",
    "hirata.fukushima.jp",
    "hirono.fukushima.jp",
    "iitate.fukushima.jp",
    "inawashiro.fukushima.jp",
    "ishikawa.fukushima.jp",
    "iwaki.fukushima.jp",
    "izumizaki.fukushima.jp",
    "kagamiishi.fukushima.jp",
    "kaneyama.fukushima.jp",
    "kawamata.fukushima.jp",
    "kitakata.fukushima.jp",
    "kitashiobara.fukushima.jp",
    "koori.fukushima.jp",
    "koriyama.fukushima.jp",
    "kunimi.fukushima.jp",
    "miharu.fukushima.jp",
    "mishima.fukushima.jp",
    "namie.fukushima.jp",
    "nango.fukushima.jp",
    "nishiaizu.fukushima.jp",
    "nishigo.fukushima.jp",
    "okuma.fukushima.jp",
    "omotego.fukushima.jp",
    "ono.fukushima.jp",
    "otama.fukushima.jp",
    "samegawa.fukushima.jp",
    "shimogo.fukushima.jp",
    "shirakawa.fukushima.jp",
    "showa.fukushima.jp",
    "soma.fukushima.jp",
    "sukagawa.fukushima.jp",
    "taishin.fukushima.jp",
    "tamakawa.fukushima.jp",
    "tanagura.fukushima.jp",
    "tenei.fukushima.jp",
    "yabuki.fukushima.jp",
    "yamato.fukushima.jp",
    "yamatsuri.fukushima.jp",
    "yanaizu.fukushima.jp",
    "yugawa.fukushima.jp",
    "anpachi.gifu.jp",
    "ena.gifu.jp",
    "gifu.gifu.jp",
    "ginan.gifu.jp",
    "godo.gifu.jp",
    "gujo.gifu.jp",
    "hashima.gifu.jp",
    "hichiso.gifu.jp",
    "hida.gifu.jp",
    "higashishirakawa.gifu.jp",
    "ibigawa.gifu.jp",
    "ikeda.gifu.jp",
    "kakamigahara.gifu.jp",
    "kani.gifu.jp",
    "kasahara.gifu.jp",
    "kasamatsu.gifu.jp",
    "kawaue.gifu.jp",
    "kitagata.gifu.jp",
    "mino.gifu.jp",
    "minokamo.gifu.jp",
    "mitake.gifu.jp",
    "mizunami.gifu.jp",
    "motosu.gifu.jp",
    "nakatsugawa.gifu.jp",
    "ogaki.gifu.jp",
    "sakahogi.gifu.jp",
    "seki.gifu.jp",
    "sekigahara.gifu.jp",
    "shirakawa.gifu.jp",
    "tajimi.gifu.jp",
    "takayama.gifu.jp",
    "tarui.gifu.jp",
    "toki.gifu.jp",
    "tomika.gifu.jp",
    "wanouchi.gifu.jp",
    "yamagata.gifu.jp",
    "yaotsu.gifu.jp",
    "yoro.gifu.jp",
    "annaka.gunma.jp",
    "chiyoda.gunma.jp",
    "fujioka.gunma.jp",
    "higashiagatsuma.gunma.jp",
    "isesaki.gunma.jp",
    "itakura.gunma.jp",
    "kanna.gunma.jp",
    "kanra.gunma.jp",
    "katashina.gunma.jp",
    "kawaba.gunma.jp",
    "kiryu.gunma.jp",
    "kusatsu.gunma.jp",
    "maebashi.gunma.jp",
    "meiwa.gunma.jp",
    "midori.gunma.jp",
    "minakami.gunma.jp",
    "naganohara.gunma.jp",
    "nakanojo.gunma.jp",
    "nanmoku.gunma.jp",
    "numata.gunma.jp",
    "oizumi.gunma.jp",
    "ora.gunma.jp",
    "ota.gunma.jp",
    "shibukawa.gunma.jp",
    "shimonita.gunma.jp",
    "shinto.gunma.jp",
    "showa.gunma.jp",
    "takasaki.gunma.jp",
    "takayama.gunma.jp",
    "tamamura.gunma.jp",
    "tatebayashi.gunma.jp",
    "tomioka.gunma.jp",
    "tsukiyono.gunma.jp",
    "tsumagoi.gunma.jp",
    "ueno.gunma.jp",
    "yoshioka.gunma.jp",
    "asaminami.hiroshima.jp",
    "daiwa.hiroshima.jp",
    "etajima.hiroshima.jp",
    "fuchu.hiroshima.jp",
    "fukuyama.hiroshima.jp",
    "hatsukaichi.hiroshima.jp",
    "higashihiroshima.hiroshima.jp",
    "hongo.hiroshima.jp",
    "jinsekikogen.hiroshima.jp",
    "kaita.hiroshima.jp",
    "kui.hiroshima.jp",
    "kumano.hiroshima.jp",
    "kure.hiroshima.jp",
    "mihara.hiroshima.jp",
    "miyoshi.hiroshima.jp",
    "naka.hiroshima.jp",
    "onomichi.hiroshima.jp",
    "osakikamijima.hiroshima.jp",
    "otake.hiroshima.jp",
    "saka.hiroshima.jp",
    "sera.hiroshima.jp",
    "seranishi.hiroshima.jp",
    "shinichi.hiroshima.jp",
    "shobara.hiroshima.jp",
    "takehara.hiroshima.jp",
    "abashiri.hokkaido.jp",
    "abira.hokkaido.jp",
    "aibetsu.hokkaido.jp",
    "akabira.hokkaido.jp",
    "akkeshi.hokkaido.jp",
    "asahikawa.hokkaido.jp",
    "ashibetsu.hokkaido.jp",
    "ashoro.hokkaido.jp",
    "assabu.hokkaido.jp",
    "atsuma.hokkaido.jp",
    "bibai.hokkaido.jp",
    "biei.hokkaido.jp",
    "bifuka.hokkaido.jp",
    "bihoro.hokkaido.jp",
    "biratori.hokkaido.jp",
    "chippubetsu.hokkaido.jp",
    "chitose.hokkaido.jp",
    "date.hokkaido.jp",
    "ebetsu.hokkaido.jp",
    "embetsu.hokkaido.jp",
    "eniwa.hokkaido.jp",
    "erimo.hokkaido.jp",
    "esan.hokkaido.jp",
    "esashi.hokkaido.jp",
    "fukagawa.hokkaido.jp",
    "fukushima.hokkaido.jp",
    "furano.hokkaido.jp",
    "furubira.hokkaido.jp",
    "haboro.hokkaido.jp",
    "hakodate.hokkaido.jp",
    "hamatonbetsu.hokkaido.jp",
    "hidaka.hokkaido.jp",
    "higashikagura.hokkaido.jp",
    "higashikawa.hokkaido.jp",
    "hiroo.hokkaido.jp",
    "hokuryu.hokkaido.jp",
    "hokuto.hokkaido.jp",
    "honbetsu.hokkaido.jp",
    "horokanai.hokkaido.jp",
    "horonobe.hokkaido.jp",
    "ikeda.hokkaido.jp",
    "imakane.hokkaido.jp",
    "ishikari.hokkaido.jp",
    "iwamizawa.hokkaido.jp",
    "iwanai.hokkaido.jp",
    "kamifurano.hokkaido.jp",
    "kamikawa.hokkaido.jp",
    "kamishihoro.hokkaido.jp",
    "kamisunagawa.hokkaido.jp",
    "kamoenai.hokkaido.jp",
    "kayabe.hokkaido.jp",
    "kembuchi.hokkaido.jp",
    "kikonai.hokkaido.jp",
    "kimobetsu.hokkaido.jp",
    "kitahiroshima.hokkaido.jp",
    "kitami.hokkaido.jp",
    "kiyosato.hokkaido.jp",
    "koshimizu.hokkaido.jp",
    "kunneppu.hokkaido.jp",
    "kuriyama.hokkaido.jp",
    "kuromatsunai.hokkaido.jp",
    "kushiro.hokkaido.jp",
    "kutchan.hokkaido.jp",
    "kyowa.hokkaido.jp",
    "mashike.hokkaido.jp",
    "matsumae.hokkaido.jp",
    "mikasa.hokkaido.jp",
    "minamifurano.hokkaido.jp",
    "mombetsu.hokkaido.jp",
    "moseushi.hokkaido.jp",
    "mukawa.hokkaido.jp",
    "muroran.hokkaido.jp",
    "naie.hokkaido.jp",
    "nakagawa.hokkaido.jp",
    "nakasatsunai.hokkaido.jp",
    "nakatombetsu.hokkaido.jp",
    "nanae.hokkaido.jp",
    "nanporo.hokkaido.jp",
    "nayoro.hokkaido.jp",
    "nemuro.hokkaido.jp",
    "niikappu.hokkaido.jp",
    "niki.hokkaido.jp",
    "nishiokoppe.hokkaido.jp",
    "noboribetsu.hokkaido.jp",
    "numata.hokkaido.jp",
    "obihiro.hokkaido.jp",
    "obira.hokkaido.jp",
    "oketo.hokkaido.jp",
    "okoppe.hokkaido.jp",
    "otaru.hokkaido.jp",
    "otobe.hokkaido.jp",
    "otofuke.hokkaido.jp",
    "otoineppu.hokkaido.jp",
    "oumu.hokkaido.jp",
    "ozora.hokkaido.jp",
    "pippu.hokkaido.jp",
    "rankoshi.hokkaido.jp",
    "rebun.hokkaido.jp",
    "rikubetsu.hokkaido.jp",
    "rishiri.hokkaido.jp",
    "rishirifuji.hokkaido.jp",
    "saroma.hokkaido.jp",
    "sarufutsu.hokkaido.jp",
    "shakotan.hokkaido.jp",
    "shari.hokkaido.jp",
    "shibecha.hokkaido.jp",
    "shibetsu.hokkaido.jp",
    "shikabe.hokkaido.jp",
    "shikaoi.hokkaido.jp",
    "shimamaki.hokkaido.jp",
    "shimizu.hokkaido.jp",
    "shimokawa.hokkaido.jp",
    "shinshinotsu.hokkaido.jp",
    "shintoku.hokkaido.jp",
    "shiranuka.hokkaido.jp",
    "shiraoi.hokkaido.jp",
    "shiriuchi.hokkaido.jp",
    "sobetsu.hokkaido.jp",
    "sunagawa.hokkaido.jp",
    "taiki.hokkaido.jp",
    "takasu.hokkaido.jp",
    "takikawa.hokkaido.jp",
    "takinoue.hokkaido.jp",
    "teshikaga.hokkaido.jp",
    "tobetsu.hokkaido.jp",
    "tohma.hokkaido.jp",
    "tomakomai.hokkaido.jp",
    "tomari.hokkaido.jp",
    "toya.hokkaido.jp",
    "toyako.hokkaido.jp",
    "toyotomi.hokkaido.jp",
    "toyoura.hokkaido.jp",
    "tsubetsu.hokkaido.jp",
    "tsukigata.hokkaido.jp",
    "urakawa.hokkaido.jp",
    "urausu.hokkaido.jp",
    "uryu.hokkaido.jp",
    "utashinai.hokkaido.jp",
    "wakkanai.hokkaido.jp",
    "wassamu.hokkaido.jp",
    "yakumo.hokkaido.jp",
    "yoichi.hokkaido.jp",
    "aioi.hyogo.jp",
    "akashi.hyogo.jp",
    "ako.hyogo.jp",
    "amagasaki.hyogo.jp",
    "aogaki.hyogo.jp",
    "asago.hyogo.jp",
    "ashiya.hyogo.jp",
    "awaji.hyogo.jp",
    "fukusaki.hyogo.jp",
    "goshiki.hyogo.jp",
    "harima.hyogo.jp",
    "himeji.hyogo.jp",
    "ichikawa.hyogo.jp",
    "inagawa.hyogo.jp",
    "itami.hyogo.jp",
    "kakogawa.hyogo.jp",
    "kamigori.hyogo.jp",
    "kamikawa.hyogo.jp",
    "kasai.hyogo.jp",
    "kasuga.hyogo.jp",
    "kawanishi.hyogo.jp",
    "miki.hyogo.jp",
    "minamiawaji.hyogo.jp",
    "nishinomiya.hyogo.jp",
    "nishiwaki.hyogo.jp",
    "ono.hyogo.jp",
    "sanda.hyogo.jp",
    "sannan.hyogo.jp",
    "sasayama.hyogo.jp",
    "sayo.hyogo.jp",
    "shingu.hyogo.jp",
    "shinonsen.hyogo.jp",
    "shiso.hyogo.jp",
    "sumoto.hyogo.jp",
    "taishi.hyogo.jp",
    "taka.hyogo.jp",
    "takarazuka.hyogo.jp",
    "takasago.hyogo.jp",
    "takino.hyogo.jp",
    "tamba.hyogo.jp",
    "tatsuno.hyogo.jp",
    "toyooka.hyogo.jp",
    "yabu.hyogo.jp",
    "yashiro.hyogo.jp",
    "yoka.hyogo.jp",
    "yokawa.hyogo.jp",
    "ami.ibaraki.jp",
    "asahi.ibaraki.jp",
    "bando.ibaraki.jp",
    "chikusei.ibaraki.jp",
    "daigo.ibaraki.jp",
    "fujishiro.ibaraki.jp",
    "hitachi.ibaraki.jp",
    "hitachinaka.ibaraki.jp",
    "hitachiomiya.ibaraki.jp",
    "hitachiota.ibaraki.jp",
    "ibaraki.ibaraki.jp",
    "ina.ibaraki.jp",
    "inashiki.ibaraki.jp",
    "itako.ibaraki.jp",
    "iwama.ibaraki.jp",
    "joso.ibaraki.jp",
    "kamisu.ibaraki.jp",
    "kasama.ibaraki.jp",
    "kashima.ibaraki.jp",
    "kasumigaura.ibaraki.jp",
    "koga.ibaraki.jp",
    "miho.ibaraki.jp",
    "mito.ibaraki.jp",
    "moriya.ibaraki.jp",
    "naka.ibaraki.jp",
    "namegata.ibaraki.jp",
    "oarai.ibaraki.jp",
    "ogawa.ibaraki.jp",
    "omitama.ibaraki.jp",
    "ryugasaki.ibaraki.jp",
    "sakai.ibaraki.jp",
    "sakuragawa.ibaraki.jp",
    "shimodate.ibaraki.jp",
    "shimotsuma.ibaraki.jp",
    "shirosato.ibaraki.jp",
    "sowa.ibaraki.jp",
    "suifu.ibaraki.jp",
    "takahagi.ibaraki.jp",
    "tamatsukuri.ibaraki.jp",
    "tokai.ibaraki.jp",
    "tomobe.ibaraki.jp",
    "tone.ibaraki.jp",
    "toride.ibaraki.jp",
    "tsuchiura.ibaraki.jp",
    "tsukuba.ibaraki.jp",
    "uchihara.ibaraki.jp",
    "ushiku.ibaraki.jp",
    "yachiyo.ibaraki.jp",
    "yamagata.ibaraki.jp",
    "yawara.ibaraki.jp",
    "yuki.ibaraki.jp",
    "anamizu.ishikawa.jp",
    "hakui.ishikawa.jp",
    "hakusan.ishikawa.jp",
    "kaga.ishikawa.jp",
    "kahoku.ishikawa.jp",
    "kanazawa.ishikawa.jp",
    "kawakita.ishikawa.jp",
    "komatsu.ishikawa.jp",
    "nakanoto.ishikawa.jp",
    "nanao.ishikawa.jp",
    "nomi.ishikawa.jp",
    "nonoichi.ishikawa.jp",
    "noto.ishikawa.jp",
    "shika.ishikawa.jp",
    "suzu.ishikawa.jp",
    "tsubata.ishikawa.jp",
    "tsurugi.ishikawa.jp",
    "uchinada.ishikawa.jp",
    "wajima.ishikawa.jp",
    "fudai.iwate.jp",
    "fujisawa.iwate.jp",
    "hanamaki.iwate.jp",
    "hiraizumi.iwate.jp",
    "hirono.iwate.jp",
    "ichinohe.iwate.jp",
    "ichinoseki.iwate.jp",
    "iwaizumi.iwate.jp",
    "iwate.iwate.jp",
    "joboji.iwate.jp",
    "kamaishi.iwate.jp",
    "kanegasaki.iwate.jp",
    "karumai.iwate.jp",
    "kawai.iwate.jp",
    "kitakami.iwate.jp",
    "kuji.iwate.jp",
    "kunohe.iwate.jp",
    "kuzumaki.iwate.jp",
    "miyako.iwate.jp",
    "mizusawa.iwate.jp",
    "morioka.iwate.jp",
    "ninohe.iwate.jp",
    "noda.iwate.jp",
    "ofunato.iwate.jp",
    "oshu.iwate.jp",
    "otsuchi.iwate.jp",
    "rikuzentakata.iwate.jp",
    "shiwa.iwate.jp",
    "shizukuishi.iwate.jp",
    "sumita.iwate.jp",
    "tanohata.iwate.jp",
    "tono.iwate.jp",
    "yahaba.iwate.jp",
    "yamada.iwate.jp",
    "ayagawa.kagawa.jp",
    "higashikagawa.kagawa.jp",
    "kanonji.kagawa.jp",
    "kotohira.kagawa.jp",
    "manno.kagawa.jp",
    "marugame.kagawa.jp",
    "mitoyo.kagawa.jp",
    "naoshima.kagawa.jp",
    "sanuki.kagawa.jp",
    "tadotsu.kagawa.jp",
    "takamatsu.kagawa.jp",
    "tonosho.kagawa.jp",
    "uchinomi.kagawa.jp",
    "utazu.kagawa.jp",
    "zentsuji.kagawa.jp",
    "akune.kagoshima.jp",
    "amami.kagoshima.jp",
    "hioki.kagoshima.jp",
    "isa.kagoshima.jp",
    "isen.kagoshima.jp",
    "izumi.kagoshima.jp",
    "kagoshima.kagoshima.jp",
    "kanoya.kagoshima.jp",
    "kawanabe.kagoshima.jp",
    "kinko.kagoshima.jp",
    "kouyama.kagoshima.jp",
    "makurazaki.kagoshima.jp",
    "matsumoto.kagoshima.jp",
    "minamitane.kagoshima.jp",
    "nakatane.kagoshima.jp",
    "nishinoomote.kagoshima.jp",
    "satsumasendai.kagoshima.jp",
    "soo.kagoshima.jp",
    "tarumizu.kagoshima.jp",
    "yusui.kagoshima.jp",
    "aikawa.kanagawa.jp",
    "atsugi.kanagawa.jp",
    "ayase.kanagawa.jp",
    "chigasaki.kanagawa.jp",
    "ebina.kanagawa.jp",
    "fujisawa.kanagawa.jp",
    "hadano.kanagawa.jp",
    "hakone.kanagawa.jp",
    "hiratsuka.kanagawa.jp",
    "isehara.kanagawa.jp",
    "kaisei.kanagawa.jp",
    "kamakura.kanagawa.jp",
    "kiyokawa.kanagawa.jp",
    "matsuda.kanagawa.jp",
    "minamiashigara.kanagawa.jp",
    "miura.kanagawa.jp",
    "nakai.kanagawa.jp",
    "ninomiya.kanagawa.jp",
    "odawara.kanagawa.jp",
    "oi.kanagawa.jp",
    "oiso.kanagawa.jp",
    "sagamihara.kanagawa.jp",
    "samukawa.kanagawa.jp",
    "tsukui.kanagawa.jp",
    "yamakita.kanagawa.jp",
    "yamato.kanagawa.jp",
    "yokosuka.kanagawa.jp",
    "yugawara.kanagawa.jp",
    "zama.kanagawa.jp",
    "zushi.kanagawa.jp",
    "aki.kochi.jp",
    "geisei.kochi.jp",
    "hidaka.kochi.jp",
    "higashitsuno.kochi.jp",
    "ino.kochi.jp",
    "kagami.kochi.jp",
    "kami.kochi.jp",
    "kitagawa.kochi.jp",
    "kochi.kochi.jp",
    "mihara.kochi.jp",
    "motoyama.kochi.jp",
    "muroto.kochi.jp",
    "nahari.kochi.jp",
    "nakamura.kochi.jp",
    "nankoku.kochi.jp",
    "nishitosa.kochi.jp",
    "niyodogawa.kochi.jp",
    "ochi.kochi.jp",
    "okawa.kochi.jp",
    "otoyo.kochi.jp",
    "otsuki.kochi.jp",
    "sakawa.kochi.jp",
    "sukumo.kochi.jp",
    "susaki.kochi.jp",
    "tosa.kochi.jp",
    "tosashimizu.kochi.jp",
    "toyo.kochi.jp",
    "tsuno.kochi.jp",
    "umaji.kochi.jp",
    "yasuda.kochi.jp",
    "yusuhara.kochi.jp",
    "amakusa.kumamoto.jp",
    "arao.kumamoto.jp",
    "aso.kumamoto.jp",
    "choyo.kumamoto.jp",
    "gyokuto.kumamoto.jp",
    "kamiamakusa.kumamoto.jp",
    "kikuchi.kumamoto.jp",
    "kumamoto.kumamoto.jp",
    "mashiki.kumamoto.jp",
    "mifune.kumamoto.jp",
    "minamata.kumamoto.jp",
    "minamioguni.kumamoto.jp",
    "nagasu.kumamoto.jp",
    "nishihara.kumamoto.jp",
    "oguni.kumamoto.jp",
    "ozu.kumamoto.jp",
    "sumoto.kumamoto.jp",
    "takamori.kumamoto.jp",
    "uki.kumamoto.jp",
    "uto.kumamoto.jp",
    "yamaga.kumamoto.jp",
    "yamato.kumamoto.jp",
    "yatsushiro.kumamoto.jp",
    "ayabe.kyoto.jp",
    "fukuchiyama.kyoto.jp",
    "higashiyama.kyoto.jp",
    "ide.kyoto.jp",
    "ine.kyoto.jp",
    "joyo.kyoto.jp",
    "kameoka.kyoto.jp",
    "kamo.kyoto.jp",
    "kita.kyoto.jp",
    "kizu.kyoto.jp",
    "kumiyama.kyoto.jp",
    "kyotamba.kyoto.jp",
    "kyotanabe.kyoto.jp",
    "kyotango.kyoto.jp",
    "maizuru.kyoto.jp",
    "minami.kyoto.jp",
    "minamiyamashiro.kyoto.jp",
    "miyazu.kyoto.jp",
    "muko.kyoto.jp",
    "nagaokakyo.kyoto.jp",
    "nakagyo.kyoto.jp",
    "nantan.kyoto.jp",
    "oyamazaki.kyoto.jp",
    "sakyo.kyoto.jp",
    "seika.kyoto.jp",
    "tanabe.kyoto.jp",
    "uji.kyoto.jp",
    "ujitawara.kyoto.jp",
    "wazuka.kyoto.jp",
    "yamashina.kyoto.jp",
    "yawata.kyoto.jp",
    "asahi.mie.jp",
    "inabe.mie.jp",
    "ise.mie.jp",
    "kameyama.mie.jp",
    "kawagoe.mie.jp",
    "kiho.mie.jp",
    "kisosaki.mie.jp",
    "kiwa.mie.jp",
    "komono.mie.jp",
    "kumano.mie.jp",
    "kuwana.mie.jp",
    "matsusaka.mie.jp",
    "meiwa.mie.jp",
    "mihama.mie.jp",
    "minamiise.mie.jp",
    "misugi.mie.jp",
    "miyama.mie.jp",
    "nabari.mie.jp",
    "shima.mie.jp",
    "suzuka.mie.jp",
    "tado.mie.jp",
    "taiki.mie.jp",
    "taki.mie.jp",
    "tamaki.mie.jp",
    "toba.mie.jp",
    "tsu.mie.jp",
    "udono.mie.jp",
    "ureshino.mie.jp",
    "watarai.mie.jp",
    "yokkaichi.mie.jp",
    "furukawa.miyagi.jp",
    "higashimatsushima.miyagi.jp",
    "ishinomaki.miyagi.jp",
    "iwanuma.miyagi.jp",
    "kakuda.miyagi.jp",
    "kami.miyagi.jp",
    "kawasaki.miyagi.jp",
    "marumori.miyagi.jp",
    "matsushima.miyagi.jp",
    "minamisanriku.miyagi.jp",
    "misato.miyagi.jp",
    "murata.miyagi.jp",
    "natori.miyagi.jp",
    "ogawara.miyagi.jp",
    "ohira.miyagi.jp",
    "onagawa.miyagi.jp",
    "osaki.miyagi.jp",
    "rifu.miyagi.jp",
    "semine.miyagi.jp",
    "shibata.miyagi.jp",
    "shichikashuku.miyagi.jp",
    "shikama.miyagi.jp",
    "shiogama.miyagi.jp",
    "shiroishi.miyagi.jp",
    "tagajo.miyagi.jp",
    "taiwa.miyagi.jp",
    "tome.miyagi.jp",
    "tomiya.miyagi.jp",
    "wakuya.miyagi.jp",
    "watari.miyagi.jp",
    "yamamoto.miyagi.jp",
    "zao.miyagi.jp",
    "aya.miyazaki.jp",
    "ebino.miyazaki.jp",
    "gokase.miyazaki.jp",
    "hyuga.miyazaki.jp",
    "kadogawa.miyazaki.jp",
    "kawaminami.miyazaki.jp",
    "kijo.miyazaki.jp",
    "kitagawa.miyazaki.jp",
    "kitakata.miyazaki.jp",
    "kitaura.miyazaki.jp",
    "kobayashi.miyazaki.jp",
    "kunitomi.miyazaki.jp",
    "kushima.miyazaki.jp",
    "mimata.miyazaki.jp",
    "miyakonojo.miyazaki.jp",
    "miyazaki.miyazaki.jp",
    "morotsuka.miyazaki.jp",
    "nichinan.miyazaki.jp",
    "nishimera.miyazaki.jp",
    "nobeoka.miyazaki.jp",
    "saito.miyazaki.jp",
    "shiiba.miyazaki.jp",
    "shintomi.miyazaki.jp",
    "takaharu.miyazaki.jp",
    "takanabe.miyazaki.jp",
    "takazaki.miyazaki.jp",
    "tsuno.miyazaki.jp",
    "achi.nagano.jp",
    "agematsu.nagano.jp",
    "anan.nagano.jp",
    "aoki.nagano.jp",
    "asahi.nagano.jp",
    "azumino.nagano.jp",
    "chikuhoku.nagano.jp",
    "chikuma.nagano.jp",
    "chino.nagano.jp",
    "fujimi.nagano.jp",
    "hakuba.nagano.jp",
    "hara.nagano.jp",
    "hiraya.nagano.jp",
    "iida.nagano.jp",
    "iijima.nagano.jp",
    "iiyama.nagano.jp",
    "iizuna.nagano.jp",
    "ikeda.nagano.jp",
    "ikusaka.nagano.jp",
    "ina.nagano.jp",
    "karuizawa.nagano.jp",
    "kawakami.nagano.jp",
    "kiso.nagano.jp",
    "kisofukushima.nagano.jp",
    "kitaaiki.nagano.jp",
    "komagane.nagano.jp",
    "komoro.nagano.jp",
    "matsukawa.nagano.jp",
    "matsumoto.nagano.jp",
    "miasa.nagano.jp",
    "minamiaiki.nagano.jp",
    "minamimaki.nagano.jp",
    "minamiminowa.nagano.jp",
    "minowa.nagano.jp",
    "miyada.nagano.jp",
    "miyota.nagano.jp",
    "mochizuki.nagano.jp",
    "nagano.nagano.jp",
    "nagawa.nagano.jp",
    "nagiso.nagano.jp",
    "nakagawa.nagano.jp",
    "nakano.nagano.jp",
    "nozawaonsen.nagano.jp",
    "obuse.nagano.jp",
    "ogawa.nagano.jp",
    "okaya.nagano.jp",
    "omachi.nagano.jp",
    "omi.nagano.jp",
    "ookuwa.nagano.jp",
    "ooshika.nagano.jp",
    "otaki.nagano.jp",
    "otari.nagano.jp",
    "sakae.nagano.jp",
    "sakaki.nagano.jp",
    "saku.nagano.jp",
    "sakuho.nagano.jp",
    "shimosuwa.nagano.jp",
    "shinanomachi.nagano.jp",
    "shiojiri.nagano.jp",
    "suwa.nagano.jp",
    "suzaka.nagano.jp",
    "takagi.nagano.jp",
    "takamori.nagano.jp",
    "takayama.nagano.jp",
    "tateshina.nagano.jp",
    "tatsuno.nagano.jp",
    "togakushi.nagano.jp",
    "togura.nagano.jp",
    "tomi.nagano.jp",
    "ueda.nagano.jp",
    "wada.nagano.jp",
    "yamagata.nagano.jp",
    "yamanouchi.nagano.jp",
    "yasaka.nagano.jp",
    "yasuoka.nagano.jp",
    "chijiwa.nagasaki.jp",
    "futsu.nagasaki.jp",
    "goto.nagasaki.jp",
    "hasami.nagasaki.jp",
    "hirado.nagasaki.jp",
    "iki.nagasaki.jp",
    "isahaya.nagasaki.jp",
    "kawatana.nagasaki.jp",
    "kuchinotsu.nagasaki.jp",
    "matsuura.nagasaki.jp",
    "nagasaki.nagasaki.jp",
    "obama.nagasaki.jp",
    "omura.nagasaki.jp",
    "oseto.nagasaki.jp",
    "saikai.nagasaki.jp",
    "sasebo.nagasaki.jp",
    "seihi.nagasaki.jp",
    "shimabara.nagasaki.jp",
    "shinkamigoto.nagasaki.jp",
    "togitsu.nagasaki.jp",
    "tsushima.nagasaki.jp",
    "unzen.nagasaki.jp",
    "ando.nara.jp",
    "gose.nara.jp",
    "heguri.nara.jp",
    "higashiyoshino.nara.jp",
    "ikaruga.nara.jp",
    "ikoma.nara.jp",
    "kamikitayama.nara.jp",
    "kanmaki.nara.jp",
    "kashiba.nara.jp",
    "kashihara.nara.jp",
    "katsuragi.nara.jp",
    "kawai.nara.jp",
    "kawakami.nara.jp",
    "kawanishi.nara.jp",
    "koryo.nara.jp",
    "kurotaki.nara.jp",
    "mitsue.nara.jp",
    "miyake.nara.jp",
    "nara.nara.jp",
    "nosegawa.nara.jp",
    "oji.nara.jp",
    "ouda.nara.jp",
    "oyodo.nara.jp",
    "sakurai.nara.jp",
    "sango.nara.jp",
    "shimoichi.nara.jp",
    "shimokitayama.nara.jp",
    "shinjo.nara.jp",
    "soni.nara.jp",
    "takatori.nara.jp",
    "tawaramoto.nara.jp",
    "tenkawa.nara.jp",
    "tenri.nara.jp",
    "uda.nara.jp",
    "yamatokoriyama.nara.jp",
    "yamatotakada.nara.jp",
    "yamazoe.nara.jp",
    "yoshino.nara.jp",
    "aga.niigata.jp",
    "agano.niigata.jp",
    "gosen.niigata.jp",
    "itoigawa.niigata.jp",
    "izumozaki.niigata.jp",
    "joetsu.niigata.jp",
    "kamo.niigata.jp",
    "kariwa.niigata.jp",
    "kashiwazaki.niigata.jp",
    "minamiuonuma.niigata.jp",
    "mitsuke.niigata.jp",
    "muika.niigata.jp",
    "murakami.niigata.jp",
    "myoko.niigata.jp",
    "nagaoka.niigata.jp",
    "niigata.niigata.jp",
    "ojiya.niigata.jp",
    "omi.niigata.jp",
    "sado.niigata.jp",
    "sanjo.niigata.jp",
    "seiro.niigata.jp",
    "seirou.niigata.jp",
    "sekikawa.niigata.jp",
    "shibata.niigata.jp",
    "tagami.niigata.jp",
    "tainai.niigata.jp",
    "tochio.niigata.jp",
    "tokamachi.niigata.jp",
    "tsubame.niigata.jp",
    "tsunan.niigata.jp",
    "uonuma.niigata.jp",
    "yahiko.niigata.jp",
    "yoita.niigata.jp",
    "yuzawa.niigata.jp",
    "beppu.oita.jp",
    "bungoono.oita.jp",
    "bungotakada.oita.jp",
    "hasama.oita.jp",
    "hiji.oita.jp",
    "himeshima.oita.jp",
    "hita.oita.jp",
    "kamitsue.oita.jp",
    "kokonoe.oita.jp",
    "kuju.oita.jp",
    "kunisaki.oita.jp",
    "kusu.oita.jp",
    "oita.oita.jp",
    "saiki.oita.jp",
    "taketa.oita.jp",
    "tsukumi.oita.jp",
    "usa.oita.jp",
    "usuki.oita.jp",
    "yufu.oita.jp",
    "akaiwa.okayama.jp",
    "asakuchi.okayama.jp",
    "bizen.okayama.jp",
    "hayashima.okayama.jp",
    "ibara.okayama.jp",
    "kagamino.okayama.jp",
    "kasaoka.okayama.jp",
    "kibichuo.okayama.jp",
    "kumenan.okayama.jp",
    "kurashiki.okayama.jp",
    "maniwa.okayama.jp",
    "misaki.okayama.jp",
    "nagi.okayama.jp",
    "niimi.okayama.jp",
    "nishiawakura.okayama.jp",
    "okayama.okayama.jp",
    "satosho.okayama.jp",
    "setouchi.okayama.jp",
    "shinjo.okayama.jp",
    "shoo.okayama.jp",
    "soja.okayama.jp",
    "takahashi.okayama.jp",
    "tamano.okayama.jp",
    "tsuyama.okayama.jp",
    "wake.okayama.jp",
    "yakage.okayama.jp",
    "aguni.okinawa.jp",
    "ginowan.okinawa.jp",
    "ginoza.okinawa.jp",
    "gushikami.okinawa.jp",
    "haebaru.okinawa.jp",
    "higashi.okinawa.jp",
    "hirara.okinawa.jp",
    "iheya.okinawa.jp",
    "ishigaki.okinawa.jp",
    "ishikawa.okinawa.jp",
    "itoman.okinawa.jp",
    "izena.okinawa.jp",
    "kadena.okinawa.jp",
    "kin.okinawa.jp",
    "kitadaito.okinawa.jp",
    "kitanakagusuku.okinawa.jp",
    "kumejima.okinawa.jp",
    "kunigami.okinawa.jp",
    "minamidaito.okinawa.jp",
    "motobu.okinawa.jp",
    "nago.okinawa.jp",
    "naha.okinawa.jp",
    "nakagusuku.okinawa.jp",
    "nakijin.okinawa.jp",
    "nanjo.okinawa.jp",
    "nishihara.okinawa.jp",
    "ogimi.okinawa.jp",
    "okinawa.okinawa.jp",
    "onna.okinawa.jp",
    "shimoji.okinawa.jp",
    "taketomi.okinawa.jp",
    "tarama.okinawa.jp",
    "tokashiki.okinawa.jp",
    "tomigusuku.okinawa.jp",
    "tonaki.okinawa.jp",
    "urasoe.okinawa.jp",
    "uruma.okinawa.jp",
    "yaese.okinawa.jp",
    "yomitan.okinawa.jp",
    "yonabaru.okinawa.jp",
    "yonaguni.okinawa.jp",
    "zamami.okinawa.jp",
    "abeno.osaka.jp",
    "chihayaakasaka.osaka.jp",
    "chuo.osaka.jp",
    "daito.osaka.jp",
    "fujiidera.osaka.jp",
    "habikino.osaka.jp",
    "hannan.osaka.jp",
    "higashiosaka.osaka.jp",
    "higashisumiyoshi.osaka.jp",
    "higashiyodogawa.osaka.jp",
    "hirakata.osaka.jp",
    "ibaraki.osaka.jp",
    "ikeda.osaka.jp",
    "izumi.osaka.jp",
    "izumiotsu.osaka.jp",
    "izumisano.osaka.jp",
    "kadoma.osaka.jp",
    "kaizuka.osaka.jp",
    "kanan.osaka.jp",
    "kashiwara.osaka.jp",
    "katano.osaka.jp",
    "kawachinagano.osaka.jp",
    "kishiwada.osaka.jp",
    "kita.osaka.jp",
    "kumatori.osaka.jp",
    "matsubara.osaka.jp",
    "minato.osaka.jp",
    "minoh.osaka.jp",
    "misaki.osaka.jp",
    "moriguchi.osaka.jp",
    "neyagawa.osaka.jp",
    "nishi.osaka.jp",
    "nose.osaka.jp",
    "osakasayama.osaka.jp",
    "sakai.osaka.jp",
    "sayama.osaka.jp",
    "sennan.osaka.jp",
    "settsu.osaka.jp",
    "shijonawate.osaka.jp",
    "shimamoto.osaka.jp",
    "suita.osaka.jp",
    "tadaoka.osaka.jp",
    "taishi.osaka.jp",
    "tajiri.osaka.jp",
    "takaishi.osaka.jp",
    "takatsuki.osaka.jp",
    "tondabayashi.osaka.jp",
    "toyonaka.osaka.jp",
    "toyono.osaka.jp",
    "yao.osaka.jp",
    "ariake.saga.jp",
    "arita.saga.jp",
    "fukudomi.saga.jp",
    "genkai.saga.jp",
    "hamatama.saga.jp",
    "hizen.saga.jp",
    "imari.saga.jp",
    "kamimine.saga.jp",
    "kanzaki.saga.jp",
    "karatsu.saga.jp",
    "kashima.saga.jp",
    "kitagata.saga.jp",
    "kitahata.saga.jp",
    "kiyama.saga.jp",
    "kouhoku.saga.jp",
    "kyuragi.saga.jp",
    "nishiarita.saga.jp",
    "ogi.saga.jp",
    "omachi.saga.jp",
    "ouchi.saga.jp",
    "saga.saga.jp",
    "shiroishi.saga.jp",
    "taku.saga.jp",
    "tara.saga.jp",
    "tosu.saga.jp",
    "yoshinogari.saga.jp",
    "arakawa.saitama.jp",
    "asaka.saitama.jp",
    "chichibu.saitama.jp",
    "fujimi.saitama.jp",
    "fujimino.saitama.jp",
    "fukaya.saitama.jp",
    "hanno.saitama.jp",
    "hanyu.saitama.jp",
    "hasuda.saitama.jp",
    "hatogaya.saitama.jp",
    "hatoyama.saitama.jp",
    "hidaka.saitama.jp",
    "higashichichibu.saitama.jp",
    "higashimatsuyama.saitama.jp",
    "honjo.saitama.jp",
    "ina.saitama.jp",
    "iruma.saitama.jp",
    "iwatsuki.saitama.jp",
    "kamiizumi.saitama.jp",
    "kamikawa.saitama.jp",
    "kamisato.saitama.jp",
    "kasukabe.saitama.jp",
    "kawagoe.saitama.jp",
    "kawaguchi.saitama.jp",
    "kawajima.saitama.jp",
    "kazo.saitama.jp",
    "kitamoto.saitama.jp",
    "koshigaya.saitama.jp",
    "kounosu.saitama.jp",
    "kuki.saitama.jp",
    "kumagaya.saitama.jp",
    "matsubushi.saitama.jp",
    "minano.saitama.jp",
    "misato.saitama.jp",
    "miyashiro.saitama.jp",
    "miyoshi.saitama.jp",
    "moroyama.saitama.jp",
    "nagatoro.saitama.jp",
    "namegawa.saitama.jp",
    "niiza.saitama.jp",
    "ogano.saitama.jp",
    "ogawa.saitama.jp",
    "ogose.saitama.jp",
    "okegawa.saitama.jp",
    "omiya.saitama.jp",
    "otaki.saitama.jp",
    "ranzan.saitama.jp",
    "ryokami.saitama.jp",
    "saitama.saitama.jp",
    "sakado.saitama.jp",
    "satte.saitama.jp",
    "sayama.saitama.jp",
    "shiki.saitama.jp",
    "shiraoka.saitama.jp",
    "soka.saitama.jp",
    "sugito.saitama.jp",
    "toda.saitama.jp",
    "tokigawa.saitama.jp",
    "tokorozawa.saitama.jp",
    "tsurugashima.saitama.jp",
    "urawa.saitama.jp",
    "warabi.saitama.jp",
    "yashio.saitama.jp",
    "yokoze.saitama.jp",
    "yono.saitama.jp",
    "yorii.saitama.jp",
    "yoshida.saitama.jp",
    "yoshikawa.saitama.jp",
    "yoshimi.saitama.jp",
    "aisho.shiga.jp",
    "gamo.shiga.jp",
    "higashiomi.shiga.jp",
    "hikone.shiga.jp",
    "koka.shiga.jp",
    "konan.shiga.jp",
    "kosei.shiga.jp",
    "koto.shiga.jp",
    "kusatsu.shiga.jp",
    "maibara.shiga.jp",
    "moriyama.shiga.jp",
    "nagahama.shiga.jp",
    "nishiazai.shiga.jp",
    "notogawa.shiga.jp",
    "omihachiman.shiga.jp",
    "otsu.shiga.jp",
    "ritto.shiga.jp",
    "ryuoh.shiga.jp",
    "takashima.shiga.jp",
    "takatsuki.shiga.jp",
    "torahime.shiga.jp",
    "toyosato.shiga.jp",
    "yasu.shiga.jp",
    "akagi.shimane.jp",
    "ama.shimane.jp",
    "gotsu.shimane.jp",
    "hamada.shimane.jp",
    "higashiizumo.shimane.jp",
    "hikawa.shimane.jp",
    "hikimi.shimane.jp",
    "izumo.shimane.jp",
    "kakinoki.shimane.jp",
    "masuda.shimane.jp",
    "matsue.shimane.jp",
    "misato.shimane.jp",
    "nishinoshima.shimane.jp",
    "ohda.shimane.jp",
    "okinoshima.shimane.jp",
    "okuizumo.shimane.jp",
    "shimane.shimane.jp",
    "tamayu.shimane.jp",
    "tsuwano.shimane.jp",
    "unnan.shimane.jp",
    "yakumo.shimane.jp",
    "yasugi.shimane.jp",
    "yatsuka.shimane.jp",
    "arai.shizuoka.jp",
    "atami.shizuoka.jp",
    "fuji.shizuoka.jp",
    "fujieda.shizuoka.jp",
    "fujikawa.shizuoka.jp",
    "fujinomiya.shizuoka.jp",
    "fukuroi.shizuoka.jp",
    "gotemba.shizuoka.jp",
    "haibara.shizuoka.jp",
    "hamamatsu.shizuoka.jp",
    "higashiizu.shizuoka.jp",
    "ito.shizuoka.jp",
    "iwata.shizuoka.jp",
    "izu.shizuoka.jp",
    "izunokuni.shizuoka.jp",
    "kakegawa.shizuoka.jp",
    "kannami.shizuoka.jp",
    "kawanehon.shizuoka.jp",
    "kawazu.shizuoka.jp",
    "kikugawa.shizuoka.jp",
    "kosai.shizuoka.jp",
    "makinohara.shizuoka.jp",
    "matsuzaki.shizuoka.jp",
    "minamiizu.shizuoka.jp",
    "mishima.shizuoka.jp",
    "morimachi.shizuoka.jp",
    "nishiizu.shizuoka.jp",
    "numazu.shizuoka.jp",
    "omaezaki.shizuoka.jp",
    "shimada.shizuoka.jp",
    "shimizu.shizuoka.jp",
    "shimoda.shizuoka.jp",
    "shizuoka.shizuoka.jp",
    "susono.shizuoka.jp",
    "yaizu.shizuoka.jp",
    "yoshida.shizuoka.jp",
    "ashikaga.tochigi.jp",
    "bato.tochigi.jp",
    "haga.tochigi.jp",
    "ichikai.tochigi.jp",
    "iwafune.tochigi.jp",
    "kaminokawa.tochigi.jp",
    "kanuma.tochigi.jp",
    "karasuyama.tochigi.jp",
    "kuroiso.tochigi.jp",
    "mashiko.tochigi.jp",
    "mibu.tochigi.jp",
    "moka.tochigi.jp",
    "motegi.tochigi.jp",
    "nasu.tochigi.jp",
    "nasushiobara.tochigi.jp",
    "nikko.tochigi.jp",
    "nishikata.tochigi.jp",
    "nogi.tochigi.jp",
    "ohira.tochigi.jp",
    "ohtawara.tochigi.jp",
    "oyama.tochigi.jp",
    "sakura.tochigi.jp",
    "sano.tochigi.jp",
    "shimotsuke.tochigi.jp",
    "shioya.tochigi.jp",
    "takanezawa.tochigi.jp",
    "tochigi.tochigi.jp",
    "tsuga.tochigi.jp",
    "ujiie.tochigi.jp",
    "utsunomiya.tochigi.jp",
    "yaita.tochigi.jp",
    "aizumi.tokushima.jp",
    "anan.tokushima.jp",
    "ichiba.tokushima.jp",
    "itano.tokushima.jp",
    "kainan.tokushima.jp",
    "komatsushima.tokushima.jp",
    "matsushige.tokushima.jp",
    "mima.tokushima.jp",
    "minami.tokushima.jp",
    "miyoshi.tokushima.jp",
    "mugi.tokushima.jp",
    "nakagawa.tokushima.jp",
    "naruto.tokushima.jp",
    "sanagochi.tokushima.jp",
    "shishikui.tokushima.jp",
    "tokushima.tokushima.jp",
    "wajiki.tokushima.jp",
    "adachi.tokyo.jp",
    "akiruno.tokyo.jp",
    "akishima.tokyo.jp",
    "aogashima.tokyo.jp",
    "arakawa.tokyo.jp",
    "bunkyo.tokyo.jp",
    "chiyoda.tokyo.jp",
    "chofu.tokyo.jp",
    "chuo.tokyo.jp",
    "edogawa.tokyo.jp",
    "fuchu.tokyo.jp",
    "fussa.tokyo.jp",
    "hachijo.tokyo.jp",
    "hachioji.tokyo.jp",
    "hamura.tokyo.jp",
    "higashikurume.tokyo.jp",
    "higashimurayama.tokyo.jp",
    "higashiyamato.tokyo.jp",
    "hino.tokyo.jp",
    "hinode.tokyo.jp",
    "hinohara.tokyo.jp",
    "inagi.tokyo.jp",
    "itabashi.tokyo.jp",
    "katsushika.tokyo.jp",
    "kita.tokyo.jp",
    "kiyose.tokyo.jp",
    "kodaira.tokyo.jp",
    "koganei.tokyo.jp",
    "kokubunji.tokyo.jp",
    "komae.tokyo.jp",
    "koto.tokyo.jp",
    "kouzushima.tokyo.jp",
    "kunitachi.tokyo.jp",
    "machida.tokyo.jp",
    "meguro.tokyo.jp",
    "minato.tokyo.jp",
    "mitaka.tokyo.jp",
    "mizuho.tokyo.jp",
    "musashimurayama.tokyo.jp",
    "musashino.tokyo.jp",
    "nakano.tokyo.jp",
    "nerima.tokyo.jp",
    "ogasawara.tokyo.jp",
    "okutama.tokyo.jp",
    "ome.tokyo.jp",
    "oshima.tokyo.jp",
    "ota.tokyo.jp",
    "setagaya.tokyo.jp",
    "shibuya.tokyo.jp",
    "shinagawa.tokyo.jp",
    "shinjuku.tokyo.jp",
    "suginami.tokyo.jp",
    "sumida.tokyo.jp",
    "tachikawa.tokyo.jp",
    "taito.tokyo.jp",
    "tama.tokyo.jp",
    "toshima.tokyo.jp",
    "chizu.tottori.jp",
    "hino.tottori.jp",
    "kawahara.tottori.jp",
    "koge.tottori.jp",
    "kotoura.tottori.jp",
    "misasa.tottori.jp",
    "nanbu.tottori.jp",
    "nichinan.tottori.jp",
    "sakaiminato.tottori.jp",
    "tottori.tottori.jp",
    "wakasa.tottori.jp",
    "yazu.tottori.jp",
    "yonago.tottori.jp",
    "asahi.toyama.jp",
    "fuchu.toyama.jp",
    "fukumitsu.toyama.jp",
    "funahashi.toyama.jp",
    "himi.toyama.jp",
    "imizu.toyama.jp",
    "inami.toyama.jp",
    "johana.toyama.jp",
    "kamiichi.toyama.jp",
    "kurobe.toyama.jp",
    "nakaniikawa.toyama.jp",
    "namerikawa.toyama.jp",
    "nanto.toyama.jp",
    "nyuzen.toyama.jp",
    "oyabe.toyama.jp",
    "taira.toyama.jp",
    "takaoka.toyama.jp",
    "tateyama.toyama.jp",
    "toga.toyama.jp",
    "tonami.toyama.jp",
    "toyama.toyama.jp",
    "unazuki.toyama.jp",
    "uozu.toyama.jp",
    "yamada.toyama.jp",
    "arida.wakayama.jp",
    "aridagawa.wakayama.jp",
    "gobo.wakayama.jp",
    "hashimoto.wakayama.jp",
    "hidaka.wakayama.jp",
    "hirogawa.wakayama.jp",
    "inami.wakayama.jp",
    "iwade.wakayama.jp",
    "kainan.wakayama.jp",
    "kamitonda.wakayama.jp",
    "katsuragi.wakayama.jp",
    "kimino.wakayama.jp",
    "kinokawa.wakayama.jp",
    "kitayama.wakayama.jp",
    "koya.wakayama.jp",
    "koza.wakayama.jp",
    "kozagawa.wakayama.jp",
    "kudoyama.wakayama.jp",
    "kushimoto.wakayama.jp",
    "mihama.wakayama.jp",
    "misato.wakayama.jp",
    "nachikatsuura.wakayama.jp",
    "shingu.wakayama.jp",
    "shirahama.wakayama.jp",
    "taiji.wakayama.jp",
    "tanabe.wakayama.jp",
    "wakayama.wakayama.jp",
    "yuasa.wakayama.jp",
    "yura.wakayama.jp",
    "asahi.yamagata.jp",
    "funagata.yamagata.jp",
    "higashine.yamagata.jp",
    "iide.yamagata.jp",
    "kahoku.yamagata.jp",
    "kaminoyama.yamagata.jp",
    "kaneyama.yamagata.jp",
    "kawanishi.yamagata.jp",
    "mamurogawa.yamagata.jp",
    "mikawa.yamagata.jp",
    "murayama.yamagata.jp",
    "nagai.yamagata.jp",
    "nakayama.yamagata.jp",
    "nanyo.yamagata.jp",
    "nishikawa.yamagata.jp",
    "obanazawa.yamagata.jp",
    "oe.yamagata.jp",
    "oguni.yamagata.jp",
    "ohkura.yamagata.jp",
    "oishida.yamagata.jp",
    "sagae.yamagata.jp",
    "sakata.yamagata.jp",
    "sakegawa.yamagata.jp",
    "shinjo.yamagata.jp",
    "shirataka.yamagata.jp",
    "shonai.yamagata.jp",
    "takahata.yamagata.jp",
    "tendo.yamagata.jp",
    "tozawa.yamagata.jp",
    "tsuruoka.yamagata.jp",
    "yamagata.yamagata.jp",
    "yamanobe.yamagata.jp",
    "yonezawa.yamagata.jp",
    "yuza.yamagata.jp",
    "abu.yamaguchi.jp",
    "hagi.yamaguchi.jp",
    "hikari.yamaguchi.jp",
    "hofu.yamaguchi.jp",
    "iwakuni.yamaguchi.jp",
    "kudamatsu.yamaguchi.jp",
    "mitou.yamaguchi.jp",
    "nagato.yamaguchi.jp",
    "oshima.yamaguchi.jp",
    "shimonoseki.yamaguchi.jp",
    "shunan.yamaguchi.jp",
    "tabuse.yamaguchi.jp",
    "tokuyama.yamaguchi.jp",
    "toyota.yamaguchi.jp",
    "ube.yamaguchi.jp",
    "yuu.yamaguchi.jp",
    "chuo.yamanashi.jp",
    "doshi.yamanashi.jp",
    "fuefuki.yamanashi.jp",
    "fujikawa.yamanashi.jp",
    "fujikawaguchiko.yamanashi.jp",
    "fujiyoshida.yamanashi.jp",
    "hayakawa.yamanashi.jp",
    "hokuto.yamanashi.jp",
    "ichikawamisato.yamanashi.jp",
    "kai.yamanashi.jp",
    "kofu.yamanashi.jp",
    "koshu.yamanashi.jp",
    "kosuge.yamanashi.jp",
    "minami-alps.yamanashi.jp",
    "minobu.yamanashi.jp",
    "nakamichi.yamanashi.jp",
    "nanbu.yamanashi.jp",
    "narusawa.yamanashi.jp",
    "nirasaki.yamanashi.jp",
    "nishikatsura.yamanashi.jp",
    "oshino.yamanashi.jp",
    "otsuki.yamanashi.jp",
    "showa.yamanashi.jp",
    "tabayama.yamanashi.jp",
    "tsuru.yamanashi.jp",
    "uenohara.yamanashi.jp",
    "yamanakako.yamanashi.jp",
    "yamanashi.yamanashi.jp",
    "ke",
    "ac.ke",
    "co.ke",
    "go.ke",
    "info.ke",
    "me.ke",
    "mobi.ke",
    "ne.ke",
    "or.ke",
    "sc.ke",
    "kg",
    "org.kg",
    "net.kg",
    "com.kg",
    "edu.kg",
    "gov.kg",
    "mil.kg",
    "*.kh",
    "ki",
    "edu.ki",
    "biz.ki",
    "net.ki",
    "org.ki",
    "gov.ki",
    "info.ki",
    "com.ki",
    "km",
    "org.km",
    "nom.km",
    "gov.km",
    "prd.km",
    "tm.km",
    "edu.km",
    "mil.km",
    "ass.km",
    "com.km",
    "coop.km",
    "asso.km",
    "presse.km",
    "medecin.km",
    "notaires.km",
    "pharmaciens.km",
    "veterinaire.km",
    "gouv.km",
    "kn",
    "net.kn",
    "org.kn",
    "edu.kn",
    "gov.kn",
    "kp",
    "com.kp",
    "edu.kp",
    "gov.kp",
    "org.kp",
    "rep.kp",
    "tra.kp",
    "kr",
    "ac.kr",
    "co.kr",
    "es.kr",
    "go.kr",
    "hs.kr",
    "kg.kr",
    "mil.kr",
    "ms.kr",
    "ne.kr",
    "or.kr",
    "pe.kr",
    "re.kr",
    "sc.kr",
    "busan.kr",
    "chungbuk.kr",
    "chungnam.kr",
    "daegu.kr",
    "daejeon.kr",
    "gangwon.kr",
    "gwangju.kr",
    "gyeongbuk.kr",
    "gyeonggi.kr",
    "gyeongnam.kr",
    "incheon.kr",
    "jeju.kr",
    "jeonbuk.kr",
    "jeonnam.kr",
    "seoul.kr",
    "ulsan.kr",
    "kw",
    "com.kw",
    "edu.kw",
    "emb.kw",
    "gov.kw",
    "ind.kw",
    "net.kw",
    "org.kw",
    "ky",
    "com.ky",
    "edu.ky",
    "net.ky",
    "org.ky",
    "kz",
    "org.kz",
    "edu.kz",
    "net.kz",
    "gov.kz",
    "mil.kz",
    "com.kz",
    "la",
    "int.la",
    "net.la",
    "info.la",
    "edu.la",
    "gov.la",
    "per.la",
    "com.la",
    "org.la",
    "lb",
    "com.lb",
    "edu.lb",
    "gov.lb",
    "net.lb",
    "org.lb",
    "lc",
    "com.lc",
    "net.lc",
    "co.lc",
    "org.lc",
    "edu.lc",
    "gov.lc",
    "li",
    "lk",
    "gov.lk",
    "sch.lk",
    "net.lk",
    "int.lk",
    "com.lk",
    "org.lk",
    "edu.lk",
    "ngo.lk",
    "soc.lk",
    "web.lk",
    "ltd.lk",
    "assn.lk",
    "grp.lk",
    "hotel.lk",
    "ac.lk",
    "lr",
    "com.lr",
    "edu.lr",
    "gov.lr",
    "org.lr",
    "net.lr",
    "ls",
    "ac.ls",
    "biz.ls",
    "co.ls",
    "edu.ls",
    "gov.ls",
    "info.ls",
    "net.ls",
    "org.ls",
    "sc.ls",
    "lt",
    "gov.lt",
    "lu",
    "lv",
    "com.lv",
    "edu.lv",
    "gov.lv",
    "org.lv",
    "mil.lv",
    "id.lv",
    "net.lv",
    "asn.lv",
    "conf.lv",
    "ly",
    "com.ly",
    "net.ly",
    "gov.ly",
    "plc.ly",
    "edu.ly",
    "sch.ly",
    "med.ly",
    "org.ly",
    "id.ly",
    "ma",
    "co.ma",
    "net.ma",
    "gov.ma",
    "org.ma",
    "ac.ma",
    "press.ma",
    "mc",
    "tm.mc",
    "asso.mc",
    "md",
    "me",
    "co.me",
    "net.me",
    "org.me",
    "edu.me",
    "ac.me",
    "gov.me",
    "its.me",
    "priv.me",
    "mg",
    "org.mg",
    "nom.mg",
    "gov.mg",
    "prd.mg",
    "tm.mg",
    "edu.mg",
    "mil.mg",
    "com.mg",
    "co.mg",
    "mh",
    "mil",
    "mk",
    "com.mk",
    "org.mk",
    "net.mk",
    "edu.mk",
    "gov.mk",
    "inf.mk",
    "name.mk",
    "ml",
    "com.ml",
    "edu.ml",
    "gouv.ml",
    "gov.ml",
    "net.ml",
    "org.ml",
    "presse.ml",
    "*.mm",
    "mn",
    "gov.mn",
    "edu.mn",
    "org.mn",
    "mo",
    "com.mo",
    "net.mo",
    "org.mo",
    "edu.mo",
    "gov.mo",
    "mobi",
    "mp",
    "mq",
    "mr",
    "gov.mr",
    "ms",
    "com.ms",
    "edu.ms",
    "gov.ms",
    "net.ms",
    "org.ms",
    "mt",
    "com.mt",
    "edu.mt",
    "net.mt",
    "org.mt",
    "mu",
    "com.mu",
    "net.mu",
    "org.mu",
    "gov.mu",
    "ac.mu",
    "co.mu",
    "or.mu",
    "museum",
    "academy.museum",
    "agriculture.museum",
    "air.museum",
    "airguard.museum",
    "alabama.museum",
    "alaska.museum",
    "amber.museum",
    "ambulance.museum",
    "american.museum",
    "americana.museum",
    "americanantiques.museum",
    "americanart.museum",
    "amsterdam.museum",
    "and.museum",
    "annefrank.museum",
    "anthro.museum",
    "anthropology.museum",
    "antiques.museum",
    "aquarium.museum",
    "arboretum.museum",
    "archaeological.museum",
    "archaeology.museum",
    "architecture.museum",
    "art.museum",
    "artanddesign.museum",
    "artcenter.museum",
    "artdeco.museum",
    "arteducation.museum",
    "artgallery.museum",
    "arts.museum",
    "artsandcrafts.museum",
    "asmatart.museum",
    "assassination.museum",
    "assisi.museum",
    "association.museum",
    "astronomy.museum",
    "atlanta.museum",
    "austin.museum",
    "australia.museum",
    "automotive.museum",
    "aviation.museum",
    "axis.museum",
    "badajoz.museum",
    "baghdad.museum",
    "bahn.museum",
    "bale.museum",
    "baltimore.museum",
    "barcelona.museum",
    "baseball.museum",
    "basel.museum",
    "baths.museum",
    "bauern.museum",
    "beauxarts.museum",
    "beeldengeluid.museum",
    "bellevue.museum",
    "bergbau.museum",
    "berkeley.museum",
    "berlin.museum",
    "bern.museum",
    "bible.museum",
    "bilbao.museum",
    "bill.museum",
    "birdart.museum",
    "birthplace.museum",
    "bonn.museum",
    "boston.museum",
    "botanical.museum",
    "botanicalgarden.museum",
    "botanicgarden.museum",
    "botany.museum",
    "brandywinevalley.museum",
    "brasil.museum",
    "bristol.museum",
    "british.museum",
    "britishcolumbia.museum",
    "broadcast.museum",
    "brunel.museum",
    "brussel.museum",
    "brussels.museum",
    "bruxelles.museum",
    "building.museum",
    "burghof.museum",
    "bus.museum",
    "bushey.museum",
    "cadaques.museum",
    "california.museum",
    "cambridge.museum",
    "can.museum",
    "canada.museum",
    "capebreton.museum",
    "carrier.museum",
    "cartoonart.museum",
    "casadelamoneda.museum",
    "castle.museum",
    "castres.museum",
    "celtic.museum",
    "center.museum",
    "chattanooga.museum",
    "cheltenham.museum",
    "chesapeakebay.museum",
    "chicago.museum",
    "children.museum",
    "childrens.museum",
    "childrensgarden.museum",
    "chiropractic.museum",
    "chocolate.museum",
    "christiansburg.museum",
    "cincinnati.museum",
    "cinema.museum",
    "circus.museum",
    "civilisation.museum",
    "civilization.museum",
    "civilwar.museum",
    "clinton.museum",
    "clock.museum",
    "coal.museum",
    "coastaldefence.museum",
    "cody.museum",
    "coldwar.museum",
    "collection.museum",
    "colonialwilliamsburg.museum",
    "coloradoplateau.museum",
    "columbia.museum",
    "columbus.museum",
    "communication.museum",
    "communications.museum",
    "community.museum",
    "computer.museum",
    "computerhistory.museum",
    "comunicaes.museum",
    "contemporary.museum",
    "contemporaryart.museum",
    "convent.museum",
    "copenhagen.museum",
    "corporation.museum",
    "correios-e-telecomunicaes.museum",
    "corvette.museum",
    "costume.museum",
    "countryestate.museum",
    "county.museum",
    "crafts.museum",
    "cranbrook.museum",
    "creation.museum",
    "cultural.museum",
    "culturalcenter.museum",
    "culture.museum",
    "cyber.museum",
    "cymru.museum",
    "dali.museum",
    "dallas.museum",
    "database.museum",
    "ddr.museum",
    "decorativearts.museum",
    "delaware.museum",
    "delmenhorst.museum",
    "denmark.museum",
    "depot.museum",
    "design.museum",
    "detroit.museum",
    "dinosaur.museum",
    "discovery.museum",
    "dolls.museum",
    "donostia.museum",
    "durham.museum",
    "eastafrica.museum",
    "eastcoast.museum",
    "education.museum",
    "educational.museum",
    "egyptian.museum",
    "eisenbahn.museum",
    "elburg.museum",
    "elvendrell.museum",
    "embroidery.museum",
    "encyclopedic.museum",
    "england.museum",
    "entomology.museum",
    "environment.museum",
    "environmentalconservation.museum",
    "epilepsy.museum",
    "essex.museum",
    "estate.museum",
    "ethnology.museum",
    "exeter.museum",
    "exhibition.museum",
    "family.museum",
    "farm.museum",
    "farmequipment.museum",
    "farmers.museum",
    "farmstead.museum",
    "field.museum",
    "figueres.museum",
    "filatelia.museum",
    "film.museum",
    "fineart.museum",
    "finearts.museum",
    "finland.museum",
    "flanders.museum",
    "florida.museum",
    "force.museum",
    "fortmissoula.museum",
    "fortworth.museum",
    "foundation.museum",
    "francaise.museum",
    "frankfurt.museum",
    "franziskaner.museum",
    "freemasonry.museum",
    "freiburg.museum",
    "fribourg.museum",
    "frog.museum",
    "fundacio.museum",
    "furniture.museum",
    "gallery.museum",
    "garden.museum",
    "gateway.museum",
    "geelvinck.museum",
    "gemological.museum",
    "geology.museum",
    "georgia.museum",
    "giessen.museum",
    "glas.museum",
    "glass.museum",
    "gorge.museum",
    "grandrapids.museum",
    "graz.museum",
    "guernsey.museum",
    "halloffame.museum",
    "hamburg.museum",
    "handson.museum",
    "harvestcelebration.museum",
    "hawaii.museum",
    "health.museum",
    "heimatunduhren.museum",
    "hellas.museum",
    "helsinki.museum",
    "hembygdsforbund.museum",
    "heritage.museum",
    "histoire.museum",
    "historical.museum",
    "historicalsociety.museum",
    "historichouses.museum",
    "historisch.museum",
    "historisches.museum",
    "history.museum",
    "historyofscience.museum",
    "horology.museum",
    "house.museum",
    "humanities.museum",
    "illustration.museum",
    "imageandsound.museum",
    "indian.museum",
    "indiana.museum",
    "indianapolis.museum",
    "indianmarket.museum",
    "intelligence.museum",
    "interactive.museum",
    "iraq.museum",
    "iron.museum",
    "isleofman.museum",
    "jamison.museum",
    "jefferson.museum",
    "jerusalem.museum",
    "jewelry.museum",
    "jewish.museum",
    "jewishart.museum",
    "jfk.museum",
    "journalism.museum",
    "judaica.museum",
    "judygarland.museum",
    "juedisches.museum",
    "juif.museum",
    "karate.museum",
    "karikatur.museum",
    "kids.museum",
    "koebenhavn.museum",
    "koeln.museum",
    "kunst.museum",
    "kunstsammlung.museum",
    "kunstunddesign.museum",
    "labor.museum",
    "labour.museum",
    "lajolla.museum",
    "lancashire.museum",
    "landes.museum",
    "lans.museum",
    "lns.museum",
    "larsson.museum",
    "lewismiller.museum",
    "lincoln.museum",
    "linz.museum",
    "living.museum",
    "livinghistory.museum",
    "localhistory.museum",
    "london.museum",
    "losangeles.museum",
    "louvre.museum",
    "loyalist.museum",
    "lucerne.museum",
    "luxembourg.museum",
    "luzern.museum",
    "mad.museum",
    "madrid.museum",
    "mallorca.museum",
    "manchester.museum",
    "mansion.museum",
    "mansions.museum",
    "manx.museum",
    "marburg.museum",
    "maritime.museum",
    "maritimo.museum",
    "maryland.museum",
    "marylhurst.museum",
    "media.museum",
    "medical.museum",
    "medizinhistorisches.museum",
    "meeres.museum",
    "memorial.museum",
    "mesaverde.museum",
    "michigan.museum",
    "midatlantic.museum",
    "military.museum",
    "mill.museum",
    "miners.museum",
    "mining.museum",
    "minnesota.museum",
    "missile.museum",
    "missoula.museum",
    "modern.museum",
    "moma.museum",
    "money.museum",
    "monmouth.museum",
    "monticello.museum",
    "montreal.museum",
    "moscow.museum",
    "motorcycle.museum",
    "muenchen.museum",
    "muenster.museum",
    "mulhouse.museum",
    "muncie.museum",
    "museet.museum",
    "museumcenter.museum",
    "museumvereniging.museum",
    "music.museum",
    "national.museum",
    "nationalfirearms.museum",
    "nationalheritage.museum",
    "nativeamerican.museum",
    "naturalhistory.museum",
    "naturalhistorymuseum.museum",
    "naturalsciences.museum",
    "nature.museum",
    "naturhistorisches.museum",
    "natuurwetenschappen.museum",
    "naumburg.museum",
    "naval.museum",
    "nebraska.museum",
    "neues.museum",
    "newhampshire.museum",
    "newjersey.museum",
    "newmexico.museum",
    "newport.museum",
    "newspaper.museum",
    "newyork.museum",
    "niepce.museum",
    "norfolk.museum",
    "north.museum",
    "nrw.museum",
    "nyc.museum",
    "nyny.museum",
    "oceanographic.museum",
    "oceanographique.museum",
    "omaha.museum",
    "online.museum",
    "ontario.museum",
    "openair.museum",
    "oregon.museum",
    "oregontrail.museum",
    "otago.museum",
    "oxford.museum",
    "pacific.museum",
    "paderborn.museum",
    "palace.museum",
    "paleo.museum",
    "palmsprings.museum",
    "panama.museum",
    "paris.museum",
    "pasadena.museum",
    "pharmacy.museum",
    "philadelphia.museum",
    "philadelphiaarea.museum",
    "philately.museum",
    "phoenix.museum",
    "photography.museum",
    "pilots.museum",
    "pittsburgh.museum",
    "planetarium.museum",
    "plantation.museum",
    "plants.museum",
    "plaza.museum",
    "portal.museum",
    "portland.museum",
    "portlligat.museum",
    "posts-and-telecommunications.museum",
    "preservation.museum",
    "presidio.museum",
    "press.museum",
    "project.museum",
    "public.museum",
    "pubol.museum",
    "quebec.museum",
    "railroad.museum",
    "railway.museum",
    "research.museum",
    "resistance.museum",
    "riodejaneiro.museum",
    "rochester.museum",
    "rockart.museum",
    "roma.museum",
    "russia.museum",
    "saintlouis.museum",
    "salem.museum",
    "salvadordali.museum",
    "salzburg.museum",
    "sandiego.museum",
    "sanfrancisco.museum",
    "santabarbara.museum",
    "santacruz.museum",
    "santafe.museum",
    "saskatchewan.museum",
    "satx.museum",
    "savannahga.museum",
    "schlesisches.museum",
    "schoenbrunn.museum",
    "schokoladen.museum",
    "school.museum",
    "schweiz.museum",
    "science.museum",
    "scienceandhistory.museum",
    "scienceandindustry.museum",
    "sciencecenter.museum",
    "sciencecenters.museum",
    "science-fiction.museum",
    "sciencehistory.museum",
    "sciences.museum",
    "sciencesnaturelles.museum",
    "scotland.museum",
    "seaport.museum",
    "settlement.museum",
    "settlers.museum",
    "shell.museum",
    "sherbrooke.museum",
    "sibenik.museum",
    "silk.museum",
    "ski.museum",
    "skole.museum",
    "society.museum",
    "sologne.museum",
    "soundandvision.museum",
    "southcarolina.museum",
    "southwest.museum",
    "space.museum",
    "spy.museum",
    "square.museum",
    "stadt.museum",
    "stalbans.museum",
    "starnberg.museum",
    "state.museum",
    "stateofdelaware.museum",
    "station.museum",
    "steam.museum",
    "steiermark.museum",
    "stjohn.museum",
    "stockholm.museum",
    "stpetersburg.museum",
    "stuttgart.museum",
    "suisse.museum",
    "surgeonshall.museum",
    "surrey.museum",
    "svizzera.museum",
    "sweden.museum",
    "sydney.museum",
    "tank.museum",
    "tcm.museum",
    "technology.museum",
    "telekommunikation.museum",
    "television.museum",
    "texas.museum",
    "textile.museum",
    "theater.museum",
    "time.museum",
    "timekeeping.museum",
    "topology.museum",
    "torino.museum",
    "touch.museum",
    "town.museum",
    "transport.museum",
    "tree.museum",
    "trolley.museum",
    "trust.museum",
    "trustee.museum",
    "uhren.museum",
    "ulm.museum",
    "undersea.museum",
    "university.museum",
    "usa.museum",
    "usantiques.museum",
    "usarts.museum",
    "uscountryestate.museum",
    "usculture.museum",
    "usdecorativearts.museum",
    "usgarden.museum",
    "ushistory.museum",
    "ushuaia.museum",
    "uslivinghistory.museum",
    "utah.museum",
    "uvic.museum",
    "valley.museum",
    "vantaa.museum",
    "versailles.museum",
    "viking.museum",
    "village.museum",
    "virginia.museum",
    "virtual.museum",
    "virtuel.museum",
    "vlaanderen.museum",
    "volkenkunde.museum",
    "wales.museum",
    "wallonie.museum",
    "war.museum",
    "washingtondc.museum",
    "watchandclock.museum",
    "watch-and-clock.museum",
    "western.museum",
    "westfalen.museum",
    "whaling.museum",
    "wildlife.museum",
    "williamsburg.museum",
    "windmill.museum",
    "workshop.museum",
    "york.museum",
    "yorkshire.museum",
    "yosemite.museum",
    "youth.museum",
    "zoological.museum",
    "zoology.museum",
    ".museum",
    ".museum",
    "mv",
    "aero.mv",
    "biz.mv",
    "com.mv",
    "coop.mv",
    "edu.mv",
    "gov.mv",
    "info.mv",
    "int.mv",
    "mil.mv",
    "museum.mv",
    "name.mv",
    "net.mv",
    "org.mv",
    "pro.mv",
    "mw",
    "ac.mw",
    "biz.mw",
    "co.mw",
    "com.mw",
    "coop.mw",
    "edu.mw",
    "gov.mw",
    "int.mw",
    "museum.mw",
    "net.mw",
    "org.mw",
    "mx",
    "com.mx",
    "org.mx",
    "gob.mx",
    "edu.mx",
    "net.mx",
    "my",
    "biz.my",
    "com.my",
    "edu.my",
    "gov.my",
    "mil.my",
    "name.my",
    "net.my",
    "org.my",
    "mz",
    "ac.mz",
    "adv.mz",
    "co.mz",
    "edu.mz",
    "gov.mz",
    "mil.mz",
    "net.mz",
    "org.mz",
    "na",
    "info.na",
    "pro.na",
    "name.na",
    "school.na",
    "or.na",
    "dr.na",
    "us.na",
    "mx.na",
    "ca.na",
    "in.na",
    "cc.na",
    "tv.na",
    "ws.na",
    "mobi.na",
    "co.na",
    "com.na",
    "org.na",
    "name",
    "nc",
    "asso.nc",
    "nom.nc",
    "ne",
    "net",
    "nf",
    "com.nf",
    "net.nf",
    "per.nf",
    "rec.nf",
    "web.nf",
    "arts.nf",
    "firm.nf",
    "info.nf",
    "other.nf",
    "store.nf",
    "ng",
    "com.ng",
    "edu.ng",
    "gov.ng",
    "i.ng",
    "mil.ng",
    "mobi.ng",
    "name.ng",
    "net.ng",
    "org.ng",
    "sch.ng",
    "ni",
    "ac.ni",
    "biz.ni",
    "co.ni",
    "com.ni",
    "edu.ni",
    "gob.ni",
    "in.ni",
    "info.ni",
    "int.ni",
    "mil.ni",
    "net.ni",
    "nom.ni",
    "org.ni",
    "web.ni",
    "nl",
    "no",
    "fhs.no",
    "vgs.no",
    "fylkesbibl.no",
    "folkebibl.no",
    "museum.no",
    "idrett.no",
    "priv.no",
    "mil.no",
    "stat.no",
    "dep.no",
    "kommune.no",
    "herad.no",
    "aa.no",
    "ah.no",
    "bu.no",
    "fm.no",
    "hl.no",
    "hm.no",
    "jan-mayen.no",
    "mr.no",
    "nl.no",
    "nt.no",
    "of.no",
    "ol.no",
    "oslo.no",
    "rl.no",
    "sf.no",
    "st.no",
    "svalbard.no",
    "tm.no",
    "tr.no",
    "va.no",
    "vf.no",
    "gs.aa.no",
    "gs.ah.no",
    "gs.bu.no",
    "gs.fm.no",
    "gs.hl.no",
    "gs.hm.no",
    "gs.jan-mayen.no",
    "gs.mr.no",
    "gs.nl.no",
    "gs.nt.no",
    "gs.of.no",
    "gs.ol.no",
    "gs.oslo.no",
    "gs.rl.no",
    "gs.sf.no",
    "gs.st.no",
    "gs.svalbard.no",
    "gs.tm.no",
    "gs.tr.no",
    "gs.va.no",
    "gs.vf.no",
    "akrehamn.no",
    "krehamn.no",
    "algard.no",
    "lgrd.no",
    "arna.no",
    "brumunddal.no",
    "bryne.no",
    "bronnoysund.no",
    "brnnysund.no",
    "drobak.no",
    "drbak.no",
    "egersund.no",
    "fetsund.no",
    "floro.no",
    "flor.no",
    "fredrikstad.no",
    "hokksund.no",
    "honefoss.no",
    "hnefoss.no",
    "jessheim.no",
    "jorpeland.no",
    "jrpeland.no",
    "kirkenes.no",
    "kopervik.no",
    "krokstadelva.no",
    "langevag.no",
    "langevg.no",
    "leirvik.no",
    "mjondalen.no",
    "mjndalen.no",
    "mo-i-rana.no",
    "mosjoen.no",
    "mosjen.no",
    "nesoddtangen.no",
    "orkanger.no",
    "osoyro.no",
    "osyro.no",
    "raholt.no",
    "rholt.no",
    "sandnessjoen.no",
    "sandnessjen.no",
    "skedsmokorset.no",
    "slattum.no",
    "spjelkavik.no",
    "stathelle.no",
    "stavern.no",
    "stjordalshalsen.no",
    "stjrdalshalsen.no",
    "tananger.no",
    "tranby.no",
    "vossevangen.no",
    "afjord.no",
    "fjord.no",
    "agdenes.no",
    "al.no",
    "l.no",
    "alesund.no",
    "lesund.no",
    "alstahaug.no",
    "alta.no",
    "lt.no",
    "alaheadju.no",
    "laheadju.no",
    "alvdal.no",
    "amli.no",
    "mli.no",
    "amot.no",
    "mot.no",
    "andebu.no",
    "andoy.no",
    "andy.no",
    "andasuolo.no",
    "ardal.no",
    "rdal.no",
    "aremark.no",
    "arendal.no",
    "s.no",
    "aseral.no",
    "seral.no",
    "asker.no",
    "askim.no",
    "askvoll.no",
    "askoy.no",
    "asky.no",
    "asnes.no",
    "snes.no",
    "audnedaln.no",
    "aukra.no",
    "aure.no",
    "aurland.no",
    "aurskog-holand.no",
    "aurskog-hland.no",
    "austevoll.no",
    "austrheim.no",
    "averoy.no",
    "avery.no",
    "balestrand.no",
    "ballangen.no",
    "balat.no",
    "blt.no",
    "balsfjord.no",
    "bahccavuotna.no",
    "bhccavuotna.no",
    "bamble.no",
    "bardu.no",
    "beardu.no",
    "beiarn.no",
    "bajddar.no",
    "bjddar.no",
    "baidar.no",
    "bidr.no",
    "berg.no",
    "bergen.no",
    "berlevag.no",
    "berlevg.no",
    "bearalvahki.no",
    "bearalvhki.no",
    "bindal.no",
    "birkenes.no",
    "bjarkoy.no",
    "bjarky.no",
    "bjerkreim.no",
    "bjugn.no",
    "bodo.no",
    "bod.no",
    "badaddja.no",
    "bdddj.no",
    "budejju.no",
    "bokn.no",
    "bremanger.no",
    "bronnoy.no",
    "brnny.no",
    "bygland.no",
    "bykle.no",
    "barum.no",
    "brum.no",
    "bo.telemark.no",
    "b.telemark.no",
    "bo.nordland.no",
    "b.nordland.no",
    "bievat.no",
    "bievt.no",
    "bomlo.no",
    "bmlo.no",
    "batsfjord.no",
    "btsfjord.no",
    "bahcavuotna.no",
    "bhcavuotna.no",
    "dovre.no",
    "drammen.no",
    "drangedal.no",
    "dyroy.no",
    "dyry.no",
    "donna.no",
    "dnna.no",
    "eid.no",
    "eidfjord.no",
    "eidsberg.no",
    "eidskog.no",
    "eidsvoll.no",
    "eigersund.no",
    "elverum.no",
    "enebakk.no",
    "engerdal.no",
    "etne.no",
    "etnedal.no",
    "evenes.no",
    "evenassi.no",
    "eveni.no",
    "evje-og-hornnes.no",
    "farsund.no",
    "fauske.no",
    "fuossko.no",
    "fuoisku.no",
    "fedje.no",
    "fet.no",
    "finnoy.no",
    "finny.no",
    "fitjar.no",
    "fjaler.no",
    "fjell.no",
    "flakstad.no",
    "flatanger.no",
    "flekkefjord.no",
    "flesberg.no",
    "flora.no",
    "fla.no",
    "fl.no",
    "folldal.no",
    "forsand.no",
    "fosnes.no",
    "frei.no",
    "frogn.no",
    "froland.no",
    "frosta.no",
    "frana.no",
    "frna.no",
    "froya.no",
    "frya.no",
    "fusa.no",
    "fyresdal.no",
    "forde.no",
    "frde.no",
    "gamvik.no",
    "gangaviika.no",
    "ggaviika.no",
    "gaular.no",
    "gausdal.no",
    "gildeskal.no",
    "gildeskl.no",
    "giske.no",
    "gjemnes.no",
    "gjerdrum.no",
    "gjerstad.no",
    "gjesdal.no",
    "gjovik.no",
    "gjvik.no",
    "gloppen.no",
    "gol.no",
    "gran.no",
    "grane.no",
    "granvin.no",
    "gratangen.no",
    "grimstad.no",
    "grong.no",
    "kraanghke.no",
    "kranghke.no",
    "grue.no",
    "gulen.no",
    "hadsel.no",
    "halden.no",
    "halsa.no",
    "hamar.no",
    "hamaroy.no",
    "habmer.no",
    "hbmer.no",
    "hapmir.no",
    "hpmir.no",
    "hammerfest.no",
    "hammarfeasta.no",
    "hmmrfeasta.no",
    "haram.no",
    "hareid.no",
    "harstad.no",
    "hasvik.no",
    "aknoluokta.no",
    "koluokta.no",
    "hattfjelldal.no",
    "aarborte.no",
    "haugesund.no",
    "hemne.no",
    "hemnes.no",
    "hemsedal.no",
    "heroy.more-og-romsdal.no",
    "hery.mre-og-romsdal.no",
    "heroy.nordland.no",
    "hery.nordland.no",
    "hitra.no",
    "hjartdal.no",
    "hjelmeland.no",
    "hobol.no",
    "hobl.no",
    "hof.no",
    "hol.no",
    "hole.no",
    "holmestrand.no",
    "holtalen.no",
    "holtlen.no",
    "hornindal.no",
    "horten.no",
    "hurdal.no",
    "hurum.no",
    "hvaler.no",
    "hyllestad.no",
    "hagebostad.no",
    "hgebostad.no",
    "hoyanger.no",
    "hyanger.no",
    "hoylandet.no",
    "hylandet.no",
    "ha.no",
    "h.no",
    "ibestad.no",
    "inderoy.no",
    "indery.no",
    "iveland.no",
    "jevnaker.no",
    "jondal.no",
    "jolster.no",
    "jlster.no",
    "karasjok.no",
    "karasjohka.no",
    "krjohka.no",
    "karlsoy.no",
    "galsa.no",
    "gls.no",
    "karmoy.no",
    "karmy.no",
    "kautokeino.no",
    "guovdageaidnu.no",
    "klepp.no",
    "klabu.no",
    "klbu.no",
    "kongsberg.no",
    "kongsvinger.no",
    "kragero.no",
    "krager.no",
    "kristiansand.no",
    "kristiansund.no",
    "krodsherad.no",
    "krdsherad.no",
    "kvalsund.no",
    "rahkkeravju.no",
    "rhkkervju.no",
    "kvam.no",
    "kvinesdal.no",
    "kvinnherad.no",
    "kviteseid.no",
    "kvitsoy.no",
    "kvitsy.no",
    "kvafjord.no",
    "kvfjord.no",
    "giehtavuoatna.no",
    "kvanangen.no",
    "kvnangen.no",
    "navuotna.no",
    "nvuotna.no",
    "kafjord.no",
    "kfjord.no",
    "gaivuotna.no",
    "givuotna.no",
    "larvik.no",
    "lavangen.no",
    "lavagis.no",
    "loabat.no",
    "loabt.no",
    "lebesby.no",
    "davvesiida.no",
    "leikanger.no",
    "leirfjord.no",
    "leka.no",
    "leksvik.no",
    "lenvik.no",
    "leangaviika.no",
    "leagaviika.no",
    "lesja.no",
    "levanger.no",
    "lier.no",
    "lierne.no",
    "lillehammer.no",
    "lillesand.no",
    "lindesnes.no",
    "lindas.no",
    "linds.no",
    "lom.no",
    "loppa.no",
    "lahppi.no",
    "lhppi.no",
    "lund.no",
    "lunner.no",
    "luroy.no",
    "lury.no",
    "luster.no",
    "lyngdal.no",
    "lyngen.no",
    "ivgu.no",
    "lardal.no",
    "lerdal.no",
    "lrdal.no",
    "lodingen.no",
    "ldingen.no",
    "lorenskog.no",
    "lrenskog.no",
    "loten.no",
    "lten.no",
    "malvik.no",
    "masoy.no",
    "msy.no",
    "muosat.no",
    "muost.no",
    "mandal.no",
    "marker.no",
    "marnardal.no",
    "masfjorden.no",
    "meland.no",
    "meldal.no",
    "melhus.no",
    "meloy.no",
    "mely.no",
    "meraker.no",
    "merker.no",
    "moareke.no",
    "moreke.no",
    "midsund.no",
    "midtre-gauldal.no",
    "modalen.no",
    "modum.no",
    "molde.no",
    "moskenes.no",
    "moss.no",
    "mosvik.no",
    "malselv.no",
    "mlselv.no",
    "malatvuopmi.no",
    "mlatvuopmi.no",
    "namdalseid.no",
    "aejrie.no",
    "namsos.no",
    "namsskogan.no",
    "naamesjevuemie.no",
    "nmesjevuemie.no",
    "laakesvuemie.no",
    "nannestad.no",
    "narvik.no",
    "narviika.no",
    "naustdal.no",
    "nedre-eiker.no",
    "nes.akershus.no",
    "nes.buskerud.no",
    "nesna.no",
    "nesodden.no",
    "nesseby.no",
    "unjarga.no",
    "unjrga.no",
    "nesset.no",
    "nissedal.no",
    "nittedal.no",
    "nord-aurdal.no",
    "nord-fron.no",
    "nord-odal.no",
    "norddal.no",
    "nordkapp.no",
    "davvenjarga.no",
    "davvenjrga.no",
    "nordre-land.no",
    "nordreisa.no",
    "raisa.no",
    "risa.no",
    "nore-og-uvdal.no",
    "notodden.no",
    "naroy.no",
    "nry.no",
    "notteroy.no",
    "nttery.no",
    "odda.no",
    "oksnes.no",
    "ksnes.no",
    "oppdal.no",
    "oppegard.no",
    "oppegrd.no",
    "orkdal.no",
    "orland.no",
    "rland.no",
    "orskog.no",
    "rskog.no",
    "orsta.no",
    "rsta.no",
    "os.hedmark.no",
    "os.hordaland.no",
    "osen.no",
    "osteroy.no",
    "ostery.no",
    "ostre-toten.no",
    "stre-toten.no",
    "overhalla.no",
    "ovre-eiker.no",
    "vre-eiker.no",
    "oyer.no",
    "yer.no",
    "oygarden.no",
    "ygarden.no",
    "oystre-slidre.no",
    "ystre-slidre.no",
    "porsanger.no",
    "porsangu.no",
    "porsgu.no",
    "porsgrunn.no",
    "radoy.no",
    "rady.no",
    "rakkestad.no",
    "rana.no",
    "ruovat.no",
    "randaberg.no",
    "rauma.no",
    "rendalen.no",
    "rennebu.no",
    "rennesoy.no",
    "rennesy.no",
    "rindal.no",
    "ringebu.no",
    "ringerike.no",
    "ringsaker.no",
    "rissa.no",
    "risor.no",
    "risr.no",
    "roan.no",
    "rollag.no",
    "rygge.no",
    "ralingen.no",
    "rlingen.no",
    "rodoy.no",
    "rdy.no",
    "romskog.no",
    "rmskog.no",
    "roros.no",
    "rros.no",
    "rost.no",
    "rst.no",
    "royken.no",
    "ryken.no",
    "royrvik.no",
    "ryrvik.no",
    "rade.no",
    "rde.no",
    "salangen.no",
    "siellak.no",
    "saltdal.no",
    "salat.no",
    "slt.no",
    "slat.no",
    "samnanger.no",
    "sande.more-og-romsdal.no",
    "sande.mre-og-romsdal.no",
    "sande.vestfold.no",
    "sandefjord.no",
    "sandnes.no",
    "sandoy.no",
    "sandy.no",
    "sarpsborg.no",
    "sauda.no",
    "sauherad.no",
    "sel.no",
    "selbu.no",
    "selje.no",
    "seljord.no",
    "sigdal.no",
    "siljan.no",
    "sirdal.no",
    "skaun.no",
    "skedsmo.no",
    "ski.no",
    "skien.no",
    "skiptvet.no",
    "skjervoy.no",
    "skjervy.no",
    "skierva.no",
    "skierv.no",
    "skjak.no",
    "skjk.no",
    "skodje.no",
    "skanland.no",
    "sknland.no",
    "skanit.no",
    "sknit.no",
    "smola.no",
    "smla.no",
    "snillfjord.no",
    "snasa.no",
    "snsa.no",
    "snoasa.no",
    "snaase.no",
    "snase.no",
    "sogndal.no",
    "sokndal.no",
    "sola.no",
    "solund.no",
    "songdalen.no",
    "sortland.no",
    "spydeberg.no",
    "stange.no",
    "stavanger.no",
    "steigen.no",
    "steinkjer.no",
    "stjordal.no",
    "stjrdal.no",
    "stokke.no",
    "stor-elvdal.no",
    "stord.no",
    "stordal.no",
    "storfjord.no",
    "omasvuotna.no",
    "strand.no",
    "stranda.no",
    "stryn.no",
    "sula.no",
    "suldal.no",
    "sund.no",
    "sunndal.no",
    "surnadal.no",
    "sveio.no",
    "svelvik.no",
    "sykkylven.no",
    "sogne.no",
    "sgne.no",
    "somna.no",
    "smna.no",
    "sondre-land.no",
    "sndre-land.no",
    "sor-aurdal.no",
    "sr-aurdal.no",
    "sor-fron.no",
    "sr-fron.no",
    "sor-odal.no",
    "sr-odal.no",
    "sor-varanger.no",
    "sr-varanger.no",
    "matta-varjjat.no",
    "mtta-vrjjat.no",
    "sorfold.no",
    "srfold.no",
    "sorreisa.no",
    "srreisa.no",
    "sorum.no",
    "srum.no",
    "tana.no",
    "deatnu.no",
    "time.no",
    "tingvoll.no",
    "tinn.no",
    "tjeldsund.no",
    "dielddanuorri.no",
    "tjome.no",
    "tjme.no",
    "tokke.no",
    "tolga.no",
    "torsken.no",
    "tranoy.no",
    "trany.no",
    "tromso.no",
    "troms.no",
    "tromsa.no",
    "romsa.no",
    "trondheim.no",
    "troandin.no",
    "trysil.no",
    "trana.no",
    "trna.no",
    "trogstad.no",
    "trgstad.no",
    "tvedestrand.no",
    "tydal.no",
    "tynset.no",
    "tysfjord.no",
    "divtasvuodna.no",
    "divttasvuotna.no",
    "tysnes.no",
    "tysvar.no",
    "tysvr.no",
    "tonsberg.no",
    "tnsberg.no",
    "ullensaker.no",
    "ullensvang.no",
    "ulvik.no",
    "utsira.no",
    "vadso.no",
    "vads.no",
    "cahcesuolo.no",
    "hcesuolo.no",
    "vaksdal.no",
    "valle.no",
    "vang.no",
    "vanylven.no",
    "vardo.no",
    "vard.no",
    "varggat.no",
    "vrggt.no",
    "vefsn.no",
    "vaapste.no",
    "vega.no",
    "vegarshei.no",
    "vegrshei.no",
    "vennesla.no",
    "verdal.no",
    "verran.no",
    "vestby.no",
    "vestnes.no",
    "vestre-slidre.no",
    "vestre-toten.no",
    "vestvagoy.no",
    "vestvgy.no",
    "vevelstad.no",
    "vik.no",
    "vikna.no",
    "vindafjord.no",
    "volda.no",
    "voss.no",
    "varoy.no",
    "vry.no",
    "vagan.no",
    "vgan.no",
    "voagat.no",
    "vagsoy.no",
    "vgsy.no",
    "vaga.no",
    "vg.no",
    "valer.ostfold.no",
    "vler.stfold.no",
    "valer.hedmark.no",
    "vler.hedmark.no",
    "*.np",
    "nr",
    "biz.nr",
    "info.nr",
    "gov.nr",
    "edu.nr",
    "org.nr",
    "net.nr",
    "com.nr",
    "nu",
    "nz",
    "ac.nz",
    "co.nz",
    "cri.nz",
    "geek.nz",
    "gen.nz",
    "govt.nz",
    "health.nz",
    "iwi.nz",
    "kiwi.nz",
    "maori.nz",
    "mil.nz",
    "mori.nz",
    "net.nz",
    "org.nz",
    "parliament.nz",
    "school.nz",
    "om",
    "co.om",
    "com.om",
    "edu.om",
    "gov.om",
    "med.om",
    "museum.om",
    "net.om",
    "org.om",
    "pro.om",
    "onion",
    "org",
    "pa",
    "ac.pa",
    "gob.pa",
    "com.pa",
    "org.pa",
    "sld.pa",
    "edu.pa",
    "net.pa",
    "ing.pa",
    "abo.pa",
    "med.pa",
    "nom.pa",
    "pe",
    "edu.pe",
    "gob.pe",
    "nom.pe",
    "mil.pe",
    "org.pe",
    "com.pe",
    "net.pe",
    "pf",
    "com.pf",
    "org.pf",
    "edu.pf",
    "*.pg",
    "ph",
    "com.ph",
    "net.ph",
    "org.ph",
    "gov.ph",
    "edu.ph",
    "ngo.ph",
    "mil.ph",
    "i.ph",
    "pk",
    "com.pk",
    "net.pk",
    "edu.pk",
    "org.pk",
    "fam.pk",
    "biz.pk",
    "web.pk",
    "gov.pk",
    "gob.pk",
    "gok.pk",
    "gon.pk",
    "gop.pk",
    "gos.pk",
    "info.pk",
    "pl",
    "com.pl",
    "net.pl",
    "org.pl",
    "aid.pl",
    "agro.pl",
    "atm.pl",
    "auto.pl",
    "biz.pl",
    "edu.pl",
    "gmina.pl",
    "gsm.pl",
    "info.pl",
    "mail.pl",
    "miasta.pl",
    "media.pl",
    "mil.pl",
    "nieruchomosci.pl",
    "nom.pl",
    "pc.pl",
    "powiat.pl",
    "priv.pl",
    "realestate.pl",
    "rel.pl",
    "sex.pl",
    "shop.pl",
    "sklep.pl",
    "sos.pl",
    "szkola.pl",
    "targi.pl",
    "tm.pl",
    "tourism.pl",
    "travel.pl",
    "turystyka.pl",
    "gov.pl",
    "ap.gov.pl",
    "ic.gov.pl",
    "is.gov.pl",
    "us.gov.pl",
    "kmpsp.gov.pl",
    "kppsp.gov.pl",
    "kwpsp.gov.pl",
    "psp.gov.pl",
    "wskr.gov.pl",
    "kwp.gov.pl",
    "mw.gov.pl",
    "ug.gov.pl",
    "um.gov.pl",
    "umig.gov.pl",
    "ugim.gov.pl",
    "upow.gov.pl",
    "uw.gov.pl",
    "starostwo.gov.pl",
    "pa.gov.pl",
    "po.gov.pl",
    "psse.gov.pl",
    "pup.gov.pl",
    "rzgw.gov.pl",
    "sa.gov.pl",
    "so.gov.pl",
    "sr.gov.pl",
    "wsa.gov.pl",
    "sko.gov.pl",
    "uzs.gov.pl",
    "wiih.gov.pl",
    "winb.gov.pl",
    "pinb.gov.pl",
    "wios.gov.pl",
    "witd.gov.pl",
    "wzmiuw.gov.pl",
    "piw.gov.pl",
    "wiw.gov.pl",
    "griw.gov.pl",
    "wif.gov.pl",
    "oum.gov.pl",
    "sdn.gov.pl",
    "zp.gov.pl",
    "uppo.gov.pl",
    "mup.gov.pl",
    "wuoz.gov.pl",
    "konsulat.gov.pl",
    "oirm.gov.pl",
    "augustow.pl",
    "babia-gora.pl",
    "bedzin.pl",
    "beskidy.pl",
    "bialowieza.pl",
    "bialystok.pl",
    "bielawa.pl",
    "bieszczady.pl",
    "boleslawiec.pl",
    "bydgoszcz.pl",
    "bytom.pl",
    "cieszyn.pl",
    "czeladz.pl",
    "czest.pl",
    "dlugoleka.pl",
    "elblag.pl",
    "elk.pl",
    "glogow.pl",
    "gniezno.pl",
    "gorlice.pl",
    "grajewo.pl",
    "ilawa.pl",
    "jaworzno.pl",
    "jelenia-gora.pl",
    "jgora.pl",
    "kalisz.pl",
    "kazimierz-dolny.pl",
    "karpacz.pl",
    "kartuzy.pl",
    "kaszuby.pl",
    "katowice.pl",
    "kepno.pl",
    "ketrzyn.pl",
    "klodzko.pl",
    "kobierzyce.pl",
    "kolobrzeg.pl",
    "konin.pl",
    "konskowola.pl",
    "kutno.pl",
    "lapy.pl",
    "lebork.pl",
    "legnica.pl",
    "lezajsk.pl",
    "limanowa.pl",
    "lomza.pl",
    "lowicz.pl",
    "lubin.pl",
    "lukow.pl",
    "malbork.pl",
    "malopolska.pl",
    "mazowsze.pl",
    "mazury.pl",
    "mielec.pl",
    "mielno.pl",
    "mragowo.pl",
    "naklo.pl",
    "nowaruda.pl",
    "nysa.pl",
    "olawa.pl",
    "olecko.pl",
    "olkusz.pl",
    "olsztyn.pl",
    "opoczno.pl",
    "opole.pl",
    "ostroda.pl",
    "ostroleka.pl",
    "ostrowiec.pl",
    "ostrowwlkp.pl",
    "pila.pl",
    "pisz.pl",
    "podhale.pl",
    "podlasie.pl",
    "polkowice.pl",
    "pomorze.pl",
    "pomorskie.pl",
    "prochowice.pl",
    "pruszkow.pl",
    "przeworsk.pl",
    "pulawy.pl",
    "radom.pl",
    "rawa-maz.pl",
    "rybnik.pl",
    "rzeszow.pl",
    "sanok.pl",
    "sejny.pl",
    "slask.pl",
    "slupsk.pl",
    "sosnowiec.pl",
    "stalowa-wola.pl",
    "skoczow.pl",
    "starachowice.pl",
    "stargard.pl",
    "suwalki.pl",
    "swidnica.pl",
    "swiebodzin.pl",
    "swinoujscie.pl",
    "szczecin.pl",
    "szczytno.pl",
    "tarnobrzeg.pl",
    "tgory.pl",
    "turek.pl",
    "tychy.pl",
    "ustka.pl",
    "walbrzych.pl",
    "warmia.pl",
    "warszawa.pl",
    "waw.pl",
    "wegrow.pl",
    "wielun.pl",
    "wlocl.pl",
    "wloclawek.pl",
    "wodzislaw.pl",
    "wolomin.pl",
    "wroclaw.pl",
    "zachpomor.pl",
    "zagan.pl",
    "zarow.pl",
    "zgora.pl",
    "zgorzelec.pl",
    "pm",
    "pn",
    "gov.pn",
    "co.pn",
    "org.pn",
    "edu.pn",
    "net.pn",
    "post",
    "pr",
    "com.pr",
    "net.pr",
    "org.pr",
    "gov.pr",
    "edu.pr",
    "isla.pr",
    "pro.pr",
    "biz.pr",
    "info.pr",
    "name.pr",
    "est.pr",
    "prof.pr",
    "ac.pr",
    "pro",
    "aaa.pro",
    "aca.pro",
    "acct.pro",
    "avocat.pro",
    "bar.pro",
    "cpa.pro",
    "eng.pro",
    "jur.pro",
    "law.pro",
    "med.pro",
    "recht.pro",
    "ps",
    "edu.ps",
    "gov.ps",
    "sec.ps",
    "plo.ps",
    "com.ps",
    "org.ps",
    "net.ps",
    "pt",
    "net.pt",
    "gov.pt",
    "org.pt",
    "edu.pt",
    "int.pt",
    "publ.pt",
    "com.pt",
    "nome.pt",
    "pw",
    "co.pw",
    "ne.pw",
    "or.pw",
    "ed.pw",
    "go.pw",
    "belau.pw",
    "py",
    "com.py",
    "coop.py",
    "edu.py",
    "gov.py",
    "mil.py",
    "net.py",
    "org.py",
    "qa",
    "com.qa",
    "edu.qa",
    "gov.qa",
    "mil.qa",
    "name.qa",
    "net.qa",
    "org.qa",
    "sch.qa",
    "re",
    "asso.re",
    "com.re",
    "nom.re",
    "ro",
    "arts.ro",
    "com.ro",
    "firm.ro",
    "info.ro",
    "nom.ro",
    "nt.ro",
    "org.ro",
    "rec.ro",
    "store.ro",
    "tm.ro",
    "www.ro",
    "rs",
    "ac.rs",
    "co.rs",
    "edu.rs",
    "gov.rs",
    "in.rs",
    "org.rs",
    "ru",
    "rw",
    "ac.rw",
    "co.rw",
    "coop.rw",
    "gov.rw",
    "mil.rw",
    "net.rw",
    "org.rw",
    "sa",
    "com.sa",
    "net.sa",
    "org.sa",
    "gov.sa",
    "med.sa",
    "pub.sa",
    "edu.sa",
    "sch.sa",
    "sb",
    "com.sb",
    "edu.sb",
    "gov.sb",
    "net.sb",
    "org.sb",
    "sc",
    "com.sc",
    "gov.sc",
    "net.sc",
    "org.sc",
    "edu.sc",
    "sd",
    "com.sd",
    "net.sd",
    "org.sd",
    "edu.sd",
    "med.sd",
    "tv.sd",
    "gov.sd",
    "info.sd",
    "se",
    "a.se",
    "ac.se",
    "b.se",
    "bd.se",
    "brand.se",
    "c.se",
    "d.se",
    "e.se",
    "f.se",
    "fh.se",
    "fhsk.se",
    "fhv.se",
    "g.se",
    "h.se",
    "i.se",
    "k.se",
    "komforb.se",
    "kommunalforbund.se",
    "komvux.se",
    "l.se",
    "lanbib.se",
    "m.se",
    "n.se",
    "naturbruksgymn.se",
    "o.se",
    "org.se",
    "p.se",
    "parti.se",
    "pp.se",
    "press.se",
    "r.se",
    "s.se",
    "t.se",
    "tm.se",
    "u.se",
    "w.se",
    "x.se",
    "y.se",
    "z.se",
    "sg",
    "com.sg",
    "net.sg",
    "org.sg",
    "gov.sg",
    "edu.sg",
    "per.sg",
    "sh",
    "com.sh",
    "net.sh",
    "gov.sh",
    "org.sh",
    "mil.sh",
    "si",
    "sj",
    "sk",
    "sl",
    "com.sl",
    "net.sl",
    "edu.sl",
    "gov.sl",
    "org.sl",
    "sm",
    "sn",
    "art.sn",
    "com.sn",
    "edu.sn",
    "gouv.sn",
    "org.sn",
    "perso.sn",
    "univ.sn",
    "so",
    "com.so",
    "edu.so",
    "gov.so",
    "me.so",
    "net.so",
    "org.so",
    "sr",
    "ss",
    "biz.ss",
    "com.ss",
    "edu.ss",
    "gov.ss",
    "me.ss",
    "net.ss",
    "org.ss",
    "sch.ss",
    "st",
    "co.st",
    "com.st",
    "consulado.st",
    "edu.st",
    "embaixada.st",
    "mil.st",
    "net.st",
    "org.st",
    "principe.st",
    "saotome.st",
    "store.st",
    "su",
    "sv",
    "com.sv",
    "edu.sv",
    "gob.sv",
    "org.sv",
    "red.sv",
    "sx",
    "gov.sx",
    "sy",
    "edu.sy",
    "gov.sy",
    "net.sy",
    "mil.sy",
    "com.sy",
    "org.sy",
    "sz",
    "co.sz",
    "ac.sz",
    "org.sz",
    "tc",
    "td",
    "tel",
    "tf",
    "tg",
    "th",
    "ac.th",
    "co.th",
    "go.th",
    "in.th",
    "mi.th",
    "net.th",
    "or.th",
    "tj",
    "ac.tj",
    "biz.tj",
    "co.tj",
    "com.tj",
    "edu.tj",
    "go.tj",
    "gov.tj",
    "int.tj",
    "mil.tj",
    "name.tj",
    "net.tj",
    "nic.tj",
    "org.tj",
    "test.tj",
    "web.tj",
    "tk",
    "tl",
    "gov.tl",
    "tm",
    "com.tm",
    "co.tm",
    "org.tm",
    "net.tm",
    "nom.tm",
    "gov.tm",
    "mil.tm",
    "edu.tm",
    "tn",
    "com.tn",
    "ens.tn",
    "fin.tn",
    "gov.tn",
    "ind.tn",
    "info.tn",
    "intl.tn",
    "mincom.tn",
    "nat.tn",
    "net.tn",
    "org.tn",
    "perso.tn",
    "tourism.tn",
    "to",
    "com.to",
    "gov.to",
    "net.to",
    "org.to",
    "edu.to",
    "mil.to",
    "tr",
    "av.tr",
    "bbs.tr",
    "bel.tr",
    "biz.tr",
    "com.tr",
    "dr.tr",
    "edu.tr",
    "gen.tr",
    "gov.tr",
    "info.tr",
    "mil.tr",
    "k12.tr",
    "kep.tr",
    "name.tr",
    "net.tr",
    "org.tr",
    "pol.tr",
    "tel.tr",
    "tsk.tr",
    "tv.tr",
    "web.tr",
    "nc.tr",
    "gov.nc.tr",
    "tt",
    "co.tt",
    "com.tt",
    "org.tt",
    "net.tt",
    "biz.tt",
    "info.tt",
    "pro.tt",
    "int.tt",
    "coop.tt",
    "jobs.tt",
    "mobi.tt",
    "travel.tt",
    "museum.tt",
    "aero.tt",
    "name.tt",
    "gov.tt",
    "edu.tt",
    "tv",
    "tw",
    "edu.tw",
    "gov.tw",
    "mil.tw",
    "com.tw",
    "net.tw",
    "org.tw",
    "idv.tw",
    "game.tw",
    "ebiz.tw",
    "club.tw",
    ".tw",
    ".tw",
    ".tw",
    "tz",
    "ac.tz",
    "co.tz",
    "go.tz",
    "hotel.tz",
    "info.tz",
    "me.tz",
    "mil.tz",
    "mobi.tz",
    "ne.tz",
    "or.tz",
    "sc.tz",
    "tv.tz",
    "ua",
    "com.ua",
    "edu.ua",
    "gov.ua",
    "in.ua",
    "net.ua",
    "org.ua",
    "cherkassy.ua",
    "cherkasy.ua",
    "chernigov.ua",
    "chernihiv.ua",
    "chernivtsi.ua",
    "chernovtsy.ua",
    "ck.ua",
    "cn.ua",
    "cr.ua",
    "crimea.ua",
    "cv.ua",
    "dn.ua",
    "dnepropetrovsk.ua",
    "dnipropetrovsk.ua",
    "donetsk.ua",
    "dp.ua",
    "if.ua",
    "ivano-frankivsk.ua",
    "kh.ua",
    "kharkiv.ua",
    "kharkov.ua",
    "kherson.ua",
    "khmelnitskiy.ua",
    "khmelnytskyi.ua",
    "kiev.ua",
    "kirovograd.ua",
    "km.ua",
    "kr.ua",
    "krym.ua",
    "ks.ua",
    "kv.ua",
    "kyiv.ua",
    "lg.ua",
    "lt.ua",
    "lugansk.ua",
    "lutsk.ua",
    "lv.ua",
    "lviv.ua",
    "mk.ua",
    "mykolaiv.ua",
    "nikolaev.ua",
    "od.ua",
    "odesa.ua",
    "odessa.ua",
    "pl.ua",
    "poltava.ua",
    "rivne.ua",
    "rovno.ua",
    "rv.ua",
    "sb.ua",
    "sebastopol.ua",
    "sevastopol.ua",
    "sm.ua",
    "sumy.ua",
    "te.ua",
    "ternopil.ua",
    "uz.ua",
    "uzhgorod.ua",
    "vinnica.ua",
    "vinnytsia.ua",
    "vn.ua",
    "volyn.ua",
    "yalta.ua",
    "zaporizhzhe.ua",
    "zaporizhzhia.ua",
    "zhitomir.ua",
    "zhytomyr.ua",
    "zp.ua",
    "zt.ua",
    "ug",
    "co.ug",
    "or.ug",
    "ac.ug",
    "sc.ug",
    "go.ug",
    "ne.ug",
    "com.ug",
    "org.ug",
    "uk",
    "ac.uk",
    "co.uk",
    "gov.uk",
    "ltd.uk",
    "me.uk",
    "net.uk",
    "nhs.uk",
    "org.uk",
    "plc.uk",
    "police.uk",
    "*.sch.uk",
    "us",
    "dni.us",
    "fed.us",
    "isa.us",
    "kids.us",
    "nsn.us",
    "ak.us",
    "al.us",
    "ar.us",
    "as.us",
    "az.us",
    "ca.us",
    "co.us",
    "ct.us",
    "dc.us",
    "de.us",
    "fl.us",
    "ga.us",
    "gu.us",
    "hi.us",
    "ia.us",
    "id.us",
    "il.us",
    "in.us",
    "ks.us",
    "ky.us",
    "la.us",
    "ma.us",
    "md.us",
    "me.us",
    "mi.us",
    "mn.us",
    "mo.us",
    "ms.us",
    "mt.us",
    "nc.us",
    "nd.us",
    "ne.us",
    "nh.us",
    "nj.us",
    "nm.us",
    "nv.us",
    "ny.us",
    "oh.us",
    "ok.us",
    "or.us",
    "pa.us",
    "pr.us",
    "ri.us",
    "sc.us",
    "sd.us",
    "tn.us",
    "tx.us",
    "ut.us",
    "vi.us",
    "vt.us",
    "va.us",
    "wa.us",
    "wi.us",
    "wv.us",
    "wy.us",
    "k12.ak.us",
    "k12.al.us",
    "k12.ar.us",
    "k12.as.us",
    "k12.az.us",
    "k12.ca.us",
    "k12.co.us",
    "k12.ct.us",
    "k12.dc.us",
    "k12.de.us",
    "k12.fl.us",
    "k12.ga.us",
    "k12.gu.us",
    "k12.ia.us",
    "k12.id.us",
    "k12.il.us",
    "k12.in.us",
    "k12.ks.us",
    "k12.ky.us",
    "k12.la.us",
    "k12.ma.us",
    "k12.md.us",
    "k12.me.us",
    "k12.mi.us",
    "k12.mn.us",
    "k12.mo.us",
    "k12.ms.us",
    "k12.mt.us",
    "k12.nc.us",
    "k12.ne.us",
    "k12.nh.us",
    "k12.nj.us",
    "k12.nm.us",
    "k12.nv.us",
    "k12.ny.us",
    "k12.oh.us",
    "k12.ok.us",
    "k12.or.us",
    "k12.pa.us",
    "k12.pr.us",
    "k12.sc.us",
    "k12.tn.us",
    "k12.tx.us",
    "k12.ut.us",
    "k12.vi.us",
    "k12.vt.us",
    "k12.va.us",
    "k12.wa.us",
    "k12.wi.us",
    "k12.wy.us",
    "cc.ak.us",
    "cc.al.us",
    "cc.ar.us",
    "cc.as.us",
    "cc.az.us",
    "cc.ca.us",
    "cc.co.us",
    "cc.ct.us",
    "cc.dc.us",
    "cc.de.us",
    "cc.fl.us",
    "cc.ga.us",
    "cc.gu.us",
    "cc.hi.us",
    "cc.ia.us",
    "cc.id.us",
    "cc.il.us",
    "cc.in.us",
    "cc.ks.us",
    "cc.ky.us",
    "cc.la.us",
    "cc.ma.us",
    "cc.md.us",
    "cc.me.us",
    "cc.mi.us",
    "cc.mn.us",
    "cc.mo.us",
    "cc.ms.us",
    "cc.mt.us",
    "cc.nc.us",
    "cc.nd.us",
    "cc.ne.us",
    "cc.nh.us",
    "cc.nj.us",
    "cc.nm.us",
    "cc.nv.us",
    "cc.ny.us",
    "cc.oh.us",
    "cc.ok.us",
    "cc.or.us",
    "cc.pa.us",
    "cc.pr.us",
    "cc.ri.us",
    "cc.sc.us",
    "cc.sd.us",
    "cc.tn.us",
    "cc.tx.us",
    "cc.ut.us",
    "cc.vi.us",
    "cc.vt.us",
    "cc.va.us",
    "cc.wa.us",
    "cc.wi.us",
    "cc.wv.us",
    "cc.wy.us",
    "lib.ak.us",
    "lib.al.us",
    "lib.ar.us",
    "lib.as.us",
    "lib.az.us",
    "lib.ca.us",
    "lib.co.us",
    "lib.ct.us",
    "lib.dc.us",
    "lib.fl.us",
    "lib.ga.us",
    "lib.gu.us",
    "lib.hi.us",
    "lib.ia.us",
    "lib.id.us",
    "lib.il.us",
    "lib.in.us",
    "lib.ks.us",
    "lib.ky.us",
    "lib.la.us",
    "lib.ma.us",
    "lib.md.us",
    "lib.me.us",
    "lib.mi.us",
    "lib.mn.us",
    "lib.mo.us",
    "lib.ms.us",
    "lib.mt.us",
    "lib.nc.us",
    "lib.nd.us",
    "lib.ne.us",
    "lib.nh.us",
    "lib.nj.us",
    "lib.nm.us",
    "lib.nv.us",
    "lib.ny.us",
    "lib.oh.us",
    "lib.ok.us",
    "lib.or.us",
    "lib.pa.us",
    "lib.pr.us",
    "lib.ri.us",
    "lib.sc.us",
    "lib.sd.us",
    "lib.tn.us",
    "lib.tx.us",
    "lib.ut.us",
    "lib.vi.us",
    "lib.vt.us",
    "lib.va.us",
    "lib.wa.us",
    "lib.wi.us",
    "lib.wy.us",
    "pvt.k12.ma.us",
    "chtr.k12.ma.us",
    "paroch.k12.ma.us",
    "ann-arbor.mi.us",
    "cog.mi.us",
    "dst.mi.us",
    "eaton.mi.us",
    "gen.mi.us",
    "mus.mi.us",
    "tec.mi.us",
    "washtenaw.mi.us",
    "uy",
    "com.uy",
    "edu.uy",
    "gub.uy",
    "mil.uy",
    "net.uy",
    "org.uy",
    "uz",
    "co.uz",
    "com.uz",
    "net.uz",
    "org.uz",
    "va",
    "vc",
    "com.vc",
    "net.vc",
    "org.vc",
    "gov.vc",
    "mil.vc",
    "edu.vc",
    "ve",
    "arts.ve",
    "bib.ve",
    "co.ve",
    "com.ve",
    "e12.ve",
    "edu.ve",
    "firm.ve",
    "gob.ve",
    "gov.ve",
    "info.ve",
    "int.ve",
    "mil.ve",
    "net.ve",
    "nom.ve",
    "org.ve",
    "rar.ve",
    "rec.ve",
    "store.ve",
    "tec.ve",
    "web.ve",
    "vg",
    "vi",
    "co.vi",
    "com.vi",
    "k12.vi",
    "net.vi",
    "org.vi",
    "vn",
    "com.vn",
    "net.vn",
    "org.vn",
    "edu.vn",
    "gov.vn",
    "int.vn",
    "ac.vn",
    "biz.vn",
    "info.vn",
    "name.vn",
    "pro.vn",
    "health.vn",
    "vu",
    "com.vu",
    "edu.vu",
    "net.vu",
    "org.vu",
    "wf",
    "ws",
    "com.ws",
    "net.ws",
    "org.ws",
    "gov.ws",
    "edu.ws",
    "yt",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "",
    "",
    "",
    "",
    "",
    "",
    "xxx",
    "ye",
    "com.ye",
    "edu.ye",
    "gov.ye",
    "net.ye",
    "mil.ye",
    "org.ye",
    "ac.za",
    "agric.za",
    "alt.za",
    "co.za",
    "edu.za",
    "gov.za",
    "grondar.za",
    "law.za",
    "mil.za",
    "net.za",
    "ngo.za",
    "nic.za",
    "nis.za",
    "nom.za",
    "org.za",
    "school.za",
    "tm.za",
    "web.za",
    "zm",
    "ac.zm",
    "biz.zm",
    "co.zm",
    "com.zm",
    "edu.zm",
    "gov.zm",
    "info.zm",
    "mil.zm",
    "net.zm",
    "org.zm",
    "sch.zm",
    "zw",
    "ac.zw",
    "co.zw",
    "gov.zw",
    "mil.zw",
    "org.zw",
    "aaa",
    "aarp",
    "abarth",
    "abb",
    "abbott",
    "abbvie",
    "abc",
    "able",
    "abogado",
    "abudhabi",
    "academy",
    "accenture",
    "accountant",
    "accountants",
    "aco",
    "actor",
    "adac",
    "ads",
    "adult",
    "aeg",
    "aetna",
    "afl",
    "africa",
    "agakhan",
    "agency",
    "aig",
    "airbus",
    "airforce",
    "airtel",
    "akdn",
    "alfaromeo",
    "alibaba",
    "alipay",
    "allfinanz",
    "allstate",
    "ally",
    "alsace",
    "alstom",
    "amazon",
    "americanexpress",
    "americanfamily",
    "amex",
    "amfam",
    "amica",
    "amsterdam",
    "analytics",
    "android",
    "anquan",
    "anz",
    "aol",
    "apartments",
    "app",
    "apple",
    "aquarelle",
    "arab",
    "aramco",
    "archi",
    "army",
    "art",
    "arte",
    "asda",
    "associates",
    "athleta",
    "attorney",
    "auction",
    "audi",
    "audible",
    "audio",
    "auspost",
    "author",
    "auto",
    "autos",
    "avianca",
    "aws",
    "axa",
    "azure",
    "baby",
    "baidu",
    "banamex",
    "bananarepublic",
    "band",
    "bank",
    "bar",
    "barcelona",
    "barclaycard",
    "barclays",
    "barefoot",
    "bargains",
    "baseball",
    "basketball",
    "bauhaus",
    "bayern",
    "bbc",
    "bbt",
    "bbva",
    "bcg",
    "bcn",
    "beats",
    "beauty",
    "beer",
    "bentley",
    "berlin",
    "best",
    "bestbuy",
    "bet",
    "bharti",
    "bible",
    "bid",
    "bike",
    "bing",
    "bingo",
    "bio",
    "black",
    "blackfriday",
    "blockbuster",
    "blog",
    "bloomberg",
    "blue",
    "bms",
    "bmw",
    "bnpparibas",
    "boats",
    "boehringer",
    "bofa",
    "bom",
    "bond",
    "boo",
    "book",
    "booking",
    "bosch",
    "bostik",
    "boston",
    "bot",
    "boutique",
    "box",
    "bradesco",
    "bridgestone",
    "broadway",
    "broker",
    "brother",
    "brussels",
    "bugatti",
    "build",
    "builders",
    "business",
    "buy",
    "buzz",
    "bzh",
    "cab",
    "cafe",
    "cal",
    "call",
    "calvinklein",
    "cam",
    "camera",
    "camp",
    "cancerresearch",
    "canon",
    "capetown",
    "capital",
    "capitalone",
    "car",
    "caravan",
    "cards",
    "care",
    "career",
    "careers",
    "cars",
    "casa",
    "case",
    "cash",
    "casino",
    "catering",
    "catholic",
    "cba",
    "cbn",
    "cbre",
    "cbs",
    "center",
    "ceo",
    "cern",
    "cfa",
    "cfd",
    "chanel",
    "channel",
    "charity",
    "chase",
    "chat",
    "cheap",
    "chintai",
    "christmas",
    "chrome",
    "church",
    "cipriani",
    "circle",
    "cisco",
    "citadel",
    "citi",
    "citic",
    "city",
    "cityeats",
    "claims",
    "cleaning",
    "click",
    "clinic",
    "clinique",
    "clothing",
    "cloud",
    "club",
    "clubmed",
    "coach",
    "codes",
    "coffee",
    "college",
    "cologne",
    "comcast",
    "commbank",
    "community",
    "company",
    "compare",
    "computer",
    "comsec",
    "condos",
    "construction",
    "consulting",
    "contact",
    "contractors",
    "cooking",
    "cookingchannel",
    "cool",
    "corsica",
    "country",
    "coupon",
    "coupons",
    "courses",
    "cpa",
    "credit",
    "creditcard",
    "creditunion",
    "cricket",
    "crown",
    "crs",
    "cruise",
    "cruises",
    "cuisinella",
    "cymru",
    "cyou",
    "dabur",
    "dad",
    "dance",
    "data",
    "date",
    "dating",
    "datsun",
    "day",
    "dclk",
    "dds",
    "deal",
    "dealer",
    "deals",
    "degree",
    "delivery",
    "dell",
    "deloitte",
    "delta",
    "democrat",
    "dental",
    "dentist",
    "desi",
    "design",
    "dev",
    "dhl",
    "diamonds",
    "diet",
    "digital",
    "direct",
    "directory",
    "discount",
    "discover",
    "dish",
    "diy",
    "dnp",
    "docs",
    "doctor",
    "dog",
    "domains",
    "dot",
    "download",
    "drive",
    "dtv",
    "dubai",
    "dunlop",
    "dupont",
    "durban",
    "dvag",
    "dvr",
    "earth",
    "eat",
    "eco",
    "edeka",
    "education",
    "email",
    "emerck",
    "energy",
    "engineer",
    "engineering",
    "enterprises",
    "epson",
    "equipment",
    "ericsson",
    "erni",
    "esq",
    "estate",
    "etisalat",
    "eurovision",
    "eus",
    "events",
    "exchange",
    "expert",
    "exposed",
    "express",
    "extraspace",
    "fage",
    "fail",
    "fairwinds",
    "faith",
    "family",
    "fan",
    "fans",
    "farm",
    "farmers",
    "fashion",
    "fast",
    "fedex",
    "feedback",
    "ferrari",
    "ferrero",
    "fiat",
    "fidelity",
    "fido",
    "film",
    "final",
    "finance",
    "financial",
    "fire",
    "firestone",
    "firmdale",
    "fish",
    "fishing",
    "fit",
    "fitness",
    "flickr",
    "flights",
    "flir",
    "florist",
    "flowers",
    "fly",
    "foo",
    "food",
    "foodnetwork",
    "football",
    "ford",
    "forex",
    "forsale",
    "forum",
    "foundation",
    "fox",
    "free",
    "fresenius",
    "frl",
    "frogans",
    "frontdoor",
    "frontier",
    "ftr",
    "fujitsu",
    "fun",
    "fund",
    "furniture",
    "futbol",
    "fyi",
    "gal",
    "gallery",
    "gallo",
    "gallup",
    "game",
    "games",
    "gap",
    "garden",
    "gay",
    "gbiz",
    "gdn",
    "gea",
    "gent",
    "genting",
    "george",
    "ggee",
    "gift",
    "gifts",
    "gives",
    "giving",
    "glass",
    "gle",
    "global",
    "globo",
    "gmail",
    "gmbh",
    "gmo",
    "gmx",
    "godaddy",
    "gold",
    "goldpoint",
    "golf",
    "goo",
    "goodyear",
    "goog",
    "google",
    "gop",
    "got",
    "grainger",
    "graphics",
    "gratis",
    "green",
    "gripe",
    "grocery",
    "group",
    "guardian",
    "gucci",
    "guge",
    "guide",
    "guitars",
    "guru",
    "hair",
    "hamburg",
    "hangout",
    "haus",
    "hbo",
    "hdfc",
    "hdfcbank",
    "health",
    "healthcare",
    "help",
    "helsinki",
    "here",
    "hermes",
    "hgtv",
    "hiphop",
    "hisamitsu",
    "hitachi",
    "hiv",
    "hkt",
    "hockey",
    "holdings",
    "holiday",
    "homedepot",
    "homegoods",
    "homes",
    "homesense",
    "honda",
    "horse",
    "hospital",
    "host",
    "hosting",
    "hot",
    "hoteles",
    "hotels",
    "hotmail",
    "house",
    "how",
    "hsbc",
    "hughes",
    "hyatt",
    "hyundai",
    "ibm",
    "icbc",
    "ice",
    "icu",
    "ieee",
    "ifm",
    "ikano",
    "imamat",
    "imdb",
    "immo",
    "immobilien",
    "inc",
    "industries",
    "infiniti",
    "ing",
    "ink",
    "institute",
    "insurance",
    "insure",
    "international",
    "intuit",
    "investments",
    "ipiranga",
    "irish",
    "ismaili",
    "ist",
    "istanbul",
    "itau",
    "itv",
    "jaguar",
    "java",
    "jcb",
    "jeep",
    "jetzt",
    "jewelry",
    "jio",
    "jll",
    "jmp",
    "jnj",
    "joburg",
    "jot",
    "joy",
    "jpmorgan",
    "jprs",
    "juegos",
    "juniper",
    "kaufen",
    "kddi",
    "kerryhotels",
    "kerrylogistics",
    "kerryproperties",
    "kfh",
    "kia",
    "kids",
    "kim",
    "kinder",
    "kindle",
    "kitchen",
    "kiwi",
    "koeln",
    "komatsu",
    "kosher",
    "kpmg",
    "kpn",
    "krd",
    "kred",
    "kuokgroup",
    "kyoto",
    "lacaixa",
    "lamborghini",
    "lamer",
    "lancaster",
    "lancia",
    "land",
    "landrover",
    "lanxess",
    "lasalle",
    "lat",
    "latino",
    "latrobe",
    "law",
    "lawyer",
    "lds",
    "lease",
    "leclerc",
    "lefrak",
    "legal",
    "lego",
    "lexus",
    "lgbt",
    "lidl",
    "life",
    "lifeinsurance",
    "lifestyle",
    "lighting",
    "like",
    "lilly",
    "limited",
    "limo",
    "lincoln",
    "linde",
    "link",
    "lipsy",
    "live",
    "living",
    "llc",
    "llp",
    "loan",
    "loans",
    "locker",
    "locus",
    "loft",
    "lol",
    "london",
    "lotte",
    "lotto",
    "love",
    "lpl",
    "lplfinancial",
    "ltd",
    "ltda",
    "lundbeck",
    "luxe",
    "luxury",
    "macys",
    "madrid",
    "maif",
    "maison",
    "makeup",
    "man",
    "management",
    "mango",
    "map",
    "market",
    "marketing",
    "markets",
    "marriott",
    "marshalls",
    "maserati",
    "mattel",
    "mba",
    "mckinsey",
    "med",
    "media",
    "meet",
    "melbourne",
    "meme",
    "memorial",
    "men",
    "menu",
    "merckmsd",
    "miami",
    "microsoft",
    "mini",
    "mint",
    "mit",
    "mitsubishi",
    "mlb",
    "mls",
    "mma",
    "mobile",
    "moda",
    "moe",
    "moi",
    "mom",
    "monash",
    "money",
    "monster",
    "mormon",
    "mortgage",
    "moscow",
    "moto",
    "motorcycles",
    "mov",
    "movie",
    "msd",
    "mtn",
    "mtr",
    "music",
    "mutual",
    "nab",
    "nagoya",
    "natura",
    "navy",
    "nba",
    "nec",
    "netbank",
    "netflix",
    "network",
    "neustar",
    "new",
    "news",
    "next",
    "nextdirect",
    "nexus",
    "nfl",
    "ngo",
    "nhk",
    "nico",
    "nike",
    "nikon",
    "ninja",
    "nissan",
    "nissay",
    "nokia",
    "northwesternmutual",
    "norton",
    "now",
    "nowruz",
    "nowtv",
    "nra",
    "nrw",
    "ntt",
    "nyc",
    "obi",
    "observer",
    "office",
    "okinawa",
    "olayan",
    "olayangroup",
    "oldnavy",
    "ollo",
    "omega",
    "one",
    "ong",
    "onl",
    "online",
    "ooo",
    "open",
    "oracle",
    "orange",
    "organic",
    "origins",
    "osaka",
    "otsuka",
    "ott",
    "ovh",
    "page",
    "panasonic",
    "paris",
    "pars",
    "partners",
    "parts",
    "party",
    "passagens",
    "pay",
    "pccw",
    "pet",
    "pfizer",
    "pharmacy",
    "phd",
    "philips",
    "phone",
    "photo",
    "photography",
    "photos",
    "physio",
    "pics",
    "pictet",
    "pictures",
    "pid",
    "pin",
    "ping",
    "pink",
    "pioneer",
    "pizza",
    "place",
    "play",
    "playstation",
    "plumbing",
    "plus",
    "pnc",
    "pohl",
    "poker",
    "politie",
    "porn",
    "pramerica",
    "praxi",
    "press",
    "prime",
    "prod",
    "productions",
    "prof",
    "progressive",
    "promo",
    "properties",
    "property",
    "protection",
    "pru",
    "prudential",
    "pub",
    "pwc",
    "qpon",
    "quebec",
    "quest",
    "racing",
    "radio",
    "read",
    "realestate",
    "realtor",
    "realty",
    "recipes",
    "red",
    "redstone",
    "redumbrella",
    "rehab",
    "reise",
    "reisen",
    "reit",
    "reliance",
    "ren",
    "rent",
    "rentals",
    "repair",
    "report",
    "republican",
    "rest",
    "restaurant",
    "review",
    "reviews",
    "rexroth",
    "rich",
    "richardli",
    "ricoh",
    "ril",
    "rio",
    "rip",
    "rocher",
    "rocks",
    "rodeo",
    "rogers",
    "room",
    "rsvp",
    "rugby",
    "ruhr",
    "run",
    "rwe",
    "ryukyu",
    "saarland",
    "safe",
    "safety",
    "sakura",
    "sale",
    "salon",
    "samsclub",
    "samsung",
    "sandvik",
    "sandvikcoromant",
    "sanofi",
    "sap",
    "sarl",
    "sas",
    "save",
    "saxo",
    "sbi",
    "sbs",
    "sca",
    "scb",
    "schaeffler",
    "schmidt",
    "scholarships",
    "school",
    "schule",
    "schwarz",
    "science",
    "scot",
    "search",
    "seat",
    "secure",
    "security",
    "seek",
    "select",
    "sener",
    "services",
    "ses",
    "seven",
    "sew",
    "sex",
    "sexy",
    "sfr",
    "shangrila",
    "sharp",
    "shaw",
    "shell",
    "shia",
    "shiksha",
    "shoes",
    "shop",
    "shopping",
    "shouji",
    "show",
    "showtime",
    "silk",
    "sina",
    "singles",
    "site",
    "ski",
    "skin",
    "sky",
    "skype",
    "sling",
    "smart",
    "smile",
    "sncf",
    "soccer",
    "social",
    "softbank",
    "software",
    "sohu",
    "solar",
    "solutions",
    "song",
    "sony",
    "soy",
    "spa",
    "space",
    "sport",
    "spot",
    "srl",
    "stada",
    "staples",
    "star",
    "statebank",
    "statefarm",
    "stc",
    "stcgroup",
    "stockholm",
    "storage",
    "store",
    "stream",
    "studio",
    "study",
    "style",
    "sucks",
    "supplies",
    "supply",
    "support",
    "surf",
    "surgery",
    "suzuki",
    "swatch",
    "swiss",
    "sydney",
    "systems",
    "tab",
    "taipei",
    "talk",
    "taobao",
    "target",
    "tatamotors",
    "tatar",
    "tattoo",
    "tax",
    "taxi",
    "tci",
    "tdk",
    "team",
    "tech",
    "technology",
    "temasek",
    "tennis",
    "teva",
    "thd",
    "theater",
    "theatre",
    "tiaa",
    "tickets",
    "tienda",
    "tiffany",
    "tips",
    "tires",
    "tirol",
    "tjmaxx",
    "tjx",
    "tkmaxx",
    "tmall",
    "today",
    "tokyo",
    "tools",
    "top",
    "toray",
    "toshiba",
    "total",
    "tours",
    "town",
    "toyota",
    "toys",
    "trade",
    "trading",
    "training",
    "travel",
    "travelchannel",
    "travelers",
    "travelersinsurance",
    "trust",
    "trv",
    "tube",
    "tui",
    "tunes",
    "tushu",
    "tvs",
    "ubank",
    "ubs",
    "unicom",
    "university",
    "uno",
    "uol",
    "ups",
    "vacations",
    "vana",
    "vanguard",
    "vegas",
    "ventures",
    "verisign",
    "versicherung",
    "vet",
    "viajes",
    "video",
    "vig",
    "viking",
    "villas",
    "vin",
    "vip",
    "virgin",
    "visa",
    "vision",
    "viva",
    "vivo",
    "vlaanderen",
    "vodka",
    "volkswagen",
    "volvo",
    "vote",
    "voting",
    "voto",
    "voyage",
    "vuelos",
    "wales",
    "walmart",
    "walter",
    "wang",
    "wanggou",
    "watch",
    "watches",
    "weather",
    "weatherchannel",
    "webcam",
    "weber",
    "website",
    "wedding",
    "weibo",
    "weir",
    "whoswho",
    "wien",
    "wiki",
    "williamhill",
    "win",
    "windows",
    "wine",
    "winners",
    "wme",
    "wolterskluwer",
    "woodside",
    "work",
    "works",
    "world",
    "wow",
    "wtc",
    "wtf",
    "xbox",
    "xerox",
    "xfinity",
    "xihuan",
    "xin",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "vermgensberater",
    "vermgensberatung",
    "",
    "",
    "",
    "",
    "",
    "",
    "xyz",
    "yachts",
    "yahoo",
    "yamaxun",
    "yandex",
    "yodobashi",
    "yoga",
    "yokohama",
    "you",
    "youtube",
    "yun",
    "zappos",
    "zara",
    "zero",
    "zip",
    "zone",
    "zuerich",
    "cc.ua",
    "inf.ua",
    "ltd.ua",
    "611.to",
    "graphox.us",
    "*.devcdnaccesso.com",
    "adobeaemcloud.com",
    "*.dev.adobeaemcloud.com",
    "hlx.live",
    "adobeaemcloud.net",
    "hlx.page",
    "hlx3.page",
    "beep.pl",
    "airkitapps.com",
    "airkitapps-au.com",
    "airkitapps.eu",
    "aivencloud.com",
    "barsy.ca",
    "*.compute.estate",
    "*.alces.network",
    "kasserver.com",
    "altervista.org",
    "alwaysdata.net",
    "cloudfront.net",
    "*.compute.amazonaws.com",
    "*.compute-1.amazonaws.com",
    "*.compute.amazonaws.com.cn",
    "us-east-1.amazonaws.com",
    "cn-north-1.eb.amazonaws.com.cn",
    "cn-northwest-1.eb.amazonaws.com.cn",
    "elasticbeanstalk.com",
    "ap-northeast-1.elasticbeanstalk.com",
    "ap-northeast-2.elasticbeanstalk.com",
    "ap-northeast-3.elasticbeanstalk.com",
    "ap-south-1.elasticbeanstalk.com",
    "ap-southeast-1.elasticbeanstalk.com",
    "ap-southeast-2.elasticbeanstalk.com",
    "ca-central-1.elasticbeanstalk.com",
    "eu-central-1.elasticbeanstalk.com",
    "eu-west-1.elasticbeanstalk.com",
    "eu-west-2.elasticbeanstalk.com",
    "eu-west-3.elasticbeanstalk.com",
    "sa-east-1.elasticbeanstalk.com",
    "us-east-1.elasticbeanstalk.com",
    "us-east-2.elasticbeanstalk.com",
    "us-gov-west-1.elasticbeanstalk.com",
    "us-west-1.elasticbeanstalk.com",
    "us-west-2.elasticbeanstalk.com",
    "*.elb.amazonaws.com",
    "*.elb.amazonaws.com.cn",
    "awsglobalaccelerator.com",
    "s3.amazonaws.com",
    "s3-ap-northeast-1.amazonaws.com",
    "s3-ap-northeast-2.amazonaws.com",
    "s3-ap-south-1.amazonaws.com",
    "s3-ap-southeast-1.amazonaws.com",
    "s3-ap-southeast-2.amazonaws.com",
    "s3-ca-central-1.amazonaws.com",
    "s3-eu-central-1.amazonaws.com",
    "s3-eu-west-1.amazonaws.com",
    "s3-eu-west-2.amazonaws.com",
    "s3-eu-west-3.amazonaws.com",
    "s3-external-1.amazonaws.com",
    "s3-fips-us-gov-west-1.amazonaws.com",
    "s3-sa-east-1.amazonaws.com",
    "s3-us-gov-west-1.amazonaws.com",
    "s3-us-east-2.amazonaws.com",
    "s3-us-west-1.amazonaws.com",
    "s3-us-west-2.amazonaws.com",
    "s3.ap-northeast-2.amazonaws.com",
    "s3.ap-south-1.amazonaws.com",
    "s3.cn-north-1.amazonaws.com.cn",
    "s3.ca-central-1.amazonaws.com",
    "s3.eu-central-1.amazonaws.com",
    "s3.eu-west-2.amazonaws.com",
    "s3.eu-west-3.amazonaws.com",
    "s3.us-east-2.amazonaws.com",
    "s3.dualstack.ap-northeast-1.amazonaws.com",
    "s3.dualstack.ap-northeast-2.amazonaws.com",
    "s3.dualstack.ap-south-1.amazonaws.com",
    "s3.dualstack.ap-southeast-1.amazonaws.com",
    "s3.dualstack.ap-southeast-2.amazonaws.com",
    "s3.dualstack.ca-central-1.amazonaws.com",
    "s3.dualstack.eu-central-1.amazonaws.com",
    "s3.dualstack.eu-west-1.amazonaws.com",
    "s3.dualstack.eu-west-2.amazonaws.com",
    "s3.dualstack.eu-west-3.amazonaws.com",
    "s3.dualstack.sa-east-1.amazonaws.com",
    "s3.dualstack.us-east-1.amazonaws.com",
    "s3.dualstack.us-east-2.amazonaws.com",
    "s3-website-us-east-1.amazonaws.com",
    "s3-website-us-west-1.amazonaws.com",
    "s3-website-us-west-2.amazonaws.com",
    "s3-website-ap-northeast-1.amazonaws.com",
    "s3-website-ap-southeast-1.amazonaws.com",
    "s3-website-ap-southeast-2.amazonaws.com",
    "s3-website-eu-west-1.amazonaws.com",
    "s3-website-sa-east-1.amazonaws.com",
    "s3-website.ap-northeast-2.amazonaws.com",
    "s3-website.ap-south-1.amazonaws.com",
    "s3-website.ca-central-1.amazonaws.com",
    "s3-website.eu-central-1.amazonaws.com",
    "s3-website.eu-west-2.amazonaws.com",
    "s3-website.eu-west-3.amazonaws.com",
    "s3-website.us-east-2.amazonaws.com",
    "t3l3p0rt.net",
    "tele.amune.org",
    "apigee.io",
    "siiites.com",
    "appspacehosted.com",
    "appspaceusercontent.com",
    "appudo.net",
    "on-aptible.com",
    "user.aseinet.ne.jp",
    "gv.vc",
    "d.gv.vc",
    "user.party.eus",
    "pimienta.org",
    "poivron.org",
    "potager.org",
    "sweetpepper.org",
    "myasustor.com",
    "cdn.prod.atlassian-dev.net",
    "translated.page",
    "myfritz.net",
    "onavstack.net",
    "*.awdev.ca",
    "*.advisor.ws",
    "ecommerce-shop.pl",
    "b-data.io",
    "backplaneapp.io",
    "balena-devices.com",
    "rs.ba",
    "*.banzai.cloud",
    "app.banzaicloud.io",
    "*.backyards.banzaicloud.io",
    "base.ec",
    "official.ec",
    "buyshop.jp",
    "fashionstore.jp",
    "handcrafted.jp",
    "kawaiishop.jp",
    "supersale.jp",
    "theshop.jp",
    "shopselect.net",
    "base.shop",
    "*.beget.app",
    "betainabox.com",
    "bnr.la",
    "bitbucket.io",
    "blackbaudcdn.net",
    "of.je",
    "bluebite.io",
    "boomla.net",
    "boutir.com",
    "boxfuse.io",
    "square7.ch",
    "bplaced.com",
    "bplaced.de",
    "square7.de",
    "bplaced.net",
    "square7.net",
    "shop.brendly.rs",
    "browsersafetymark.io",
    "uk0.bigv.io",
    "dh.bytemark.co.uk",
    "vm.bytemark.co.uk",
    "cafjs.com",
    "mycd.eu",
    "drr.ac",
    "uwu.ai",
    "carrd.co",
    "crd.co",
    "ju.mp",
    "ae.org",
    "br.com",
    "cn.com",
    "com.de",
    "com.se",
    "de.com",
    "eu.com",
    "gb.net",
    "hu.net",
    "jp.net",
    "jpn.com",
    "mex.com",
    "ru.com",
    "sa.com",
    "se.net",
    "uk.com",
    "uk.net",
    "us.com",
    "za.bz",
    "za.com",
    "ar.com",
    "hu.com",
    "kr.com",
    "no.com",
    "qc.com",
    "uy.com",
    "africa.com",
    "gr.com",
    "in.net",
    "web.in",
    "us.org",
    "co.com",
    "aus.basketball",
    "nz.basketball",
    "radio.am",
    "radio.fm",
    "c.la",
    "certmgr.org",
    "cx.ua",
    "discourse.group",
    "discourse.team",
    "cleverapps.io",
    "clerk.app",
    "clerkstage.app",
    "*.lcl.dev",
    "*.lclstage.dev",
    "*.stg.dev",
    "*.stgstage.dev",
    "clickrising.net",
    "c66.me",
    "cloud66.ws",
    "cloud66.zone",
    "jdevcloud.com",
    "wpdevcloud.com",
    "cloudaccess.host",
    "freesite.host",
    "cloudaccess.net",
    "cloudcontrolled.com",
    "cloudcontrolapp.com",
    "*.cloudera.site",
    "pages.dev",
    "trycloudflare.com",
    "workers.dev",
    "wnext.app",
    "co.ca",
    "*.otap.co",
    "co.cz",
    "c.cdn77.org",
    "cdn77-ssl.net",
    "r.cdn77.net",
    "rsc.cdn77.org",
    "ssl.origin.cdn77-secure.org",
    "cloudns.asia",
    "cloudns.biz",
    "cloudns.club",
    "cloudns.cc",
    "cloudns.eu",
    "cloudns.in",
    "cloudns.info",
    "cloudns.org",
    "cloudns.pro",
    "cloudns.pw",
    "cloudns.us",
    "cnpy.gdn",
    "codeberg.page",
    "co.nl",
    "co.no",
    "webhosting.be",
    "hosting-cluster.nl",
    "ac.ru",
    "edu.ru",
    "gov.ru",
    "int.ru",
    "mil.ru",
    "test.ru",
    "dyn.cosidns.de",
    "dynamisches-dns.de",
    "dnsupdater.de",
    "internet-dns.de",
    "l-o-g-i-n.de",
    "dynamic-dns.info",
    "feste-ip.net",
    "knx-server.net",
    "static-access.net",
    "realm.cz",
    "*.cryptonomic.net",
    "cupcake.is",
    "curv.dev",
    "*.customer-oci.com",
    "*.oci.customer-oci.com",
    "*.ocp.customer-oci.com",
    "*.ocs.customer-oci.com",
    "cyon.link",
    "cyon.site",
    "fnwk.site",
    "folionetwork.site",
    "platform0.app",
    "daplie.me",
    "localhost.daplie.me",
    "dattolocal.com",
    "dattorelay.com",
    "dattoweb.com",
    "mydatto.com",
    "dattolocal.net",
    "mydatto.net",
    "biz.dk",
    "co.dk",
    "firm.dk",
    "reg.dk",
    "store.dk",
    "dyndns.dappnode.io",
    "*.dapps.earth",
    "*.bzz.dapps.earth",
    "builtwithdark.com",
    "demo.datadetect.com",
    "instance.datadetect.com",
    "edgestack.me",
    "ddns5.com",
    "debian.net",
    "deno.dev",
    "deno-staging.dev",
    "dedyn.io",
    "deta.app",
    "deta.dev",
    "*.rss.my.id",
    "*.diher.solutions",
    "discordsays.com",
    "discordsez.com",
    "jozi.biz",
    "dnshome.de",
    "online.th",
    "shop.th",
    "drayddns.com",
    "shoparena.pl",
    "dreamhosters.com",
    "mydrobo.com",
    "drud.io",
    "drud.us",
    "duckdns.org",
    "bip.sh",
    "bitbridge.net",
    "dy.fi",
    "tunk.org",
    "dyndns-at-home.com",
    "dyndns-at-work.com",
    "dyndns-blog.com",
    "dyndns-free.com",
    "dyndns-home.com",
    "dyndns-ip.com",
    "dyndns-mail.com",
    "dyndns-office.com",
    "dyndns-pics.com",
    "dyndns-remote.com",
    "dyndns-server.com",
    "dyndns-web.com",
    "dyndns-wiki.com",
    "dyndns-work.com",
    "dyndns.biz",
    "dyndns.info",
    "dyndns.org",
    "dyndns.tv",
    "at-band-camp.net",
    "ath.cx",
    "barrel-of-knowledge.info",
    "barrell-of-knowledge.info",
    "better-than.tv",
    "blogdns.com",
    "blogdns.net",
    "blogdns.org",
    "blogsite.org",
    "boldlygoingnowhere.org",
    "broke-it.net",
    "buyshouses.net",
    "cechire.com",
    "dnsalias.com",
    "dnsalias.net",
    "dnsalias.org",
    "dnsdojo.com",
    "dnsdojo.net",
    "dnsdojo.org",
    "does-it.net",
    "doesntexist.com",
    "doesntexist.org",
    "dontexist.com",
    "dontexist.net",
    "dontexist.org",
    "doomdns.com",
    "doomdns.org",
    "dvrdns.org",
    "dyn-o-saur.com",
    "dynalias.com",
    "dynalias.net",
    "dynalias.org",
    "dynathome.net",
    "dyndns.ws",
    "endofinternet.net",
    "endofinternet.org",
    "endoftheinternet.org",
    "est-a-la-maison.com",
    "est-a-la-masion.com",
    "est-le-patron.com",
    "est-mon-blogueur.com",
    "for-better.biz",
    "for-more.biz",
    "for-our.info",
    "for-some.biz",
    "for-the.biz",
    "forgot.her.name",
    "forgot.his.name",
    "from-ak.com",
    "from-al.com",
    "from-ar.com",
    "from-az.net",
    "from-ca.com",
    "from-co.net",
    "from-ct.com",
    "from-dc.com",
    "from-de.com",
    "from-fl.com",
    "from-ga.com",
    "from-hi.com",
    "from-ia.com",
    "from-id.com",
    "from-il.com",
    "from-in.com",
    "from-ks.com",
    "from-ky.com",
    "from-la.net",
    "from-ma.com",
    "from-md.com",
    "from-me.org",
    "from-mi.com",
    "from-mn.com",
    "from-mo.com",
    "from-ms.com",
    "from-mt.com",
    "from-nc.com",
    "from-nd.com",
    "from-ne.com",
    "from-nh.com",
    "from-nj.com",
    "from-nm.com",
    "from-nv.com",
    "from-ny.net",
    "from-oh.com",
    "from-ok.com",
    "from-or.com",
    "from-pa.com",
    "from-pr.com",
    "from-ri.com",
    "from-sc.com",
    "from-sd.com",
    "from-tn.com",
    "from-tx.com",
    "from-ut.com",
    "from-va.com",
    "from-vt.com",
    "from-wa.com",
    "from-wi.com",
    "from-wv.com",
    "from-wy.com",
    "ftpaccess.cc",
    "fuettertdasnetz.de",
    "game-host.org",
    "game-server.cc",
    "getmyip.com",
    "gets-it.net",
    "go.dyndns.org",
    "gotdns.com",
    "gotdns.org",
    "groks-the.info",
    "groks-this.info",
    "ham-radio-op.net",
    "here-for-more.info",
    "hobby-site.com",
    "hobby-site.org",
    "home.dyndns.org",
    "homedns.org",
    "homeftp.net",
    "homeftp.org",
    "homeip.net",
    "homelinux.com",
    "homelinux.net",
    "homelinux.org",
    "homeunix.com",
    "homeunix.net",
    "homeunix.org",
    "iamallama.com",
    "in-the-band.net",
    "is-a-anarchist.com",
    "is-a-blogger.com",
    "is-a-bookkeeper.com",
    "is-a-bruinsfan.org",
    "is-a-bulls-fan.com",
    "is-a-candidate.org",
    "is-a-caterer.com",
    "is-a-celticsfan.org",
    "is-a-chef.com",
    "is-a-chef.net",
    "is-a-chef.org",
    "is-a-conservative.com",
    "is-a-cpa.com",
    "is-a-cubicle-slave.com",
    "is-a-democrat.com",
    "is-a-designer.com",
    "is-a-doctor.com",
    "is-a-financialadvisor.com",
    "is-a-geek.com",
    "is-a-geek.net",
    "is-a-geek.org",
    "is-a-green.com",
    "is-a-guru.com",
    "is-a-hard-worker.com",
    "is-a-hunter.com",
    "is-a-knight.org",
    "is-a-landscaper.com",
    "is-a-lawyer.com",
    "is-a-liberal.com",
    "is-a-libertarian.com",
    "is-a-linux-user.org",
    "is-a-llama.com",
    "is-a-musician.com",
    "is-a-nascarfan.com",
    "is-a-nurse.com",
    "is-a-painter.com",
    "is-a-patsfan.org",
    "is-a-personaltrainer.com",
    "is-a-photographer.com",
    "is-a-player.com",
    "is-a-republican.com",
    "is-a-rockstar.com",
    "is-a-socialist.com",
    "is-a-soxfan.org",
    "is-a-student.com",
    "is-a-teacher.com",
    "is-a-techie.com",
    "is-a-therapist.com",
    "is-an-accountant.com",
    "is-an-actor.com",
    "is-an-actress.com",
    "is-an-anarchist.com",
    "is-an-artist.com",
    "is-an-engineer.com",
    "is-an-entertainer.com",
    "is-by.us",
    "is-certified.com",
    "is-found.org",
    "is-gone.com",
    "is-into-anime.com",
    "is-into-cars.com",
    "is-into-cartoons.com",
    "is-into-games.com",
    "is-leet.com",
    "is-lost.org",
    "is-not-certified.com",
    "is-saved.org",
    "is-slick.com",
    "is-uberleet.com",
    "is-very-bad.org",
    "is-very-evil.org",
    "is-very-good.org",
    "is-very-nice.org",
    "is-very-sweet.org",
    "is-with-theband.com",
    "isa-geek.com",
    "isa-geek.net",
    "isa-geek.org",
    "isa-hockeynut.com",
    "issmarterthanyou.com",
    "isteingeek.de",
    "istmein.de",
    "kicks-ass.net",
    "kicks-ass.org",
    "knowsitall.info",
    "land-4-sale.us",
    "lebtimnetz.de",
    "leitungsen.de",
    "likes-pie.com",
    "likescandy.com",
    "merseine.nu",
    "mine.nu",
    "misconfused.org",
    "mypets.ws",
    "myphotos.cc",
    "neat-url.com",
    "office-on-the.net",
    "on-the-web.tv",
    "podzone.net",
    "podzone.org",
    "readmyblog.org",
    "saves-the-whales.com",
    "scrapper-site.net",
    "scrapping.cc",
    "selfip.biz",
    "selfip.com",
    "selfip.info",
    "selfip.net",
    "selfip.org",
    "sells-for-less.com",
    "sells-for-u.com",
    "sells-it.net",
    "sellsyourhome.org",
    "servebbs.com",
    "servebbs.net",
    "servebbs.org",
    "serveftp.net",
    "serveftp.org",
    "servegame.org",
    "shacknet.nu",
    "simple-url.com",
    "space-to-rent.com",
    "stuff-4-sale.org",
    "stuff-4-sale.us",
    "teaches-yoga.com",
    "thruhere.net",
    "traeumtgerade.de",
    "webhop.biz",
    "webhop.info",
    "webhop.net",
    "webhop.org",
    "worse-than.tv",
    "writesthisblog.com",
    "ddnss.de",
    "dyn.ddnss.de",
    "dyndns.ddnss.de",
    "dyndns1.de",
    "dyn-ip24.de",
    "home-webserver.de",
    "dyn.home-webserver.de",
    "myhome-server.de",
    "ddnss.org",
    "definima.net",
    "definima.io",
    "ondigitalocean.app",
    "*.digitaloceanspaces.com",
    "bci.dnstrace.pro",
    "ddnsfree.com",
    "ddnsgeek.com",
    "giize.com",
    "gleeze.com",
    "kozow.com",
    "loseyourip.com",
    "ooguy.com",
    "theworkpc.com",
    "casacam.net",
    "dynu.net",
    "accesscam.org",
    "camdvr.org",
    "freeddns.org",
    "mywire.org",
    "webredirect.org",
    "myddns.rocks",
    "blogsite.xyz",
    "dynv6.net",
    "e4.cz",
    "eero.online",
    "eero-stage.online",
    "elementor.cloud",
    "elementor.cool",
    "en-root.fr",
    "mytuleap.com",
    "tuleap-partners.com",
    "encr.app",
    "encoreapi.com",
    "onred.one",
    "staging.onred.one",
    "eu.encoway.cloud",
    "eu.org",
    "al.eu.org",
    "asso.eu.org",
    "at.eu.org",
    "au.eu.org",
    "be.eu.org",
    "bg.eu.org",
    "ca.eu.org",
    "cd.eu.org",
    "ch.eu.org",
    "cn.eu.org",
    "cy.eu.org",
    "cz.eu.org",
    "de.eu.org",
    "dk.eu.org",
    "edu.eu.org",
    "ee.eu.org",
    "es.eu.org",
    "fi.eu.org",
    "fr.eu.org",
    "gr.eu.org",
    "hr.eu.org",
    "hu.eu.org",
    "ie.eu.org",
    "il.eu.org",
    "in.eu.org",
    "int.eu.org",
    "is.eu.org",
    "it.eu.org",
    "jp.eu.org",
    "kr.eu.org",
    "lt.eu.org",
    "lu.eu.org",
    "lv.eu.org",
    "mc.eu.org",
    "me.eu.org",
    "mk.eu.org",
    "mt.eu.org",
    "my.eu.org",
    "net.eu.org",
    "ng.eu.org",
    "nl.eu.org",
    "no.eu.org",
    "nz.eu.org",
    "paris.eu.org",
    "pl.eu.org",
    "pt.eu.org",
    "q-a.eu.org",
    "ro.eu.org",
    "ru.eu.org",
    "se.eu.org",
    "si.eu.org",
    "sk.eu.org",
    "tr.eu.org",
    "uk.eu.org",
    "us.eu.org",
    "eurodir.ru",
    "eu-1.evennode.com",
    "eu-2.evennode.com",
    "eu-3.evennode.com",
    "eu-4.evennode.com",
    "us-1.evennode.com",
    "us-2.evennode.com",
    "us-3.evennode.com",
    "us-4.evennode.com",
    "twmail.cc",
    "twmail.net",
    "twmail.org",
    "mymailer.com.tw",
    "url.tw",
    "onfabrica.com",
    "apps.fbsbx.com",
    "ru.net",
    "adygeya.ru",
    "bashkiria.ru",
    "bir.ru",
    "cbg.ru",
    "com.ru",
    "dagestan.ru",
    "grozny.ru",
    "kalmykia.ru",
    "kustanai.ru",
    "marine.ru",
    "mordovia.ru",
    "msk.ru",
    "mytis.ru",
    "nalchik.ru",
    "nov.ru",
    "pyatigorsk.ru",
    "spb.ru",
    "vladikavkaz.ru",
    "vladimir.ru",
    "abkhazia.su",
    "adygeya.su",
    "aktyubinsk.su",
    "arkhangelsk.su",
    "armenia.su",
    "ashgabad.su",
    "azerbaijan.su",
    "balashov.su",
    "bashkiria.su",
    "bryansk.su",
    "bukhara.su",
    "chimkent.su",
    "dagestan.su",
    "east-kazakhstan.su",
    "exnet.su",
    "georgia.su",
    "grozny.su",
    "ivanovo.su",
    "jambyl.su",
    "kalmykia.su",
    "kaluga.su",
    "karacol.su",
    "karaganda.su",
    "karelia.su",
    "khakassia.su",
    "krasnodar.su",
    "kurgan.su",
    "kustanai.su",
    "lenug.su",
    "mangyshlak.su",
    "mordovia.su",
    "msk.su",
    "murmansk.su",
    "nalchik.su",
    "navoi.su",
    "north-kazakhstan.su",
    "nov.su",
    "obninsk.su",
    "penza.su",
    "pokrovsk.su",
    "sochi.su",
    "spb.su",
    "tashkent.su",
    "termez.su",
    "togliatti.su",
    "troitsk.su",
    "tselinograd.su",
    "tula.su",
    "tuva.su",
    "vladikavkaz.su",
    "vladimir.su",
    "vologda.su",
    "channelsdvr.net",
    "u.channelsdvr.net",
    "edgecompute.app",
    "fastly-terrarium.com",
    "fastlylb.net",
    "map.fastlylb.net",
    "freetls.fastly.net",
    "map.fastly.net",
    "a.prod.fastly.net",
    "global.prod.fastly.net",
    "a.ssl.fastly.net",
    "b.ssl.fastly.net",
    "global.ssl.fastly.net",
    "fastvps-server.com",
    "fastvps.host",
    "myfast.host",
    "fastvps.site",
    "myfast.space",
    "fedorainfracloud.org",
    "fedorapeople.org",
    "cloud.fedoraproject.org",
    "app.os.fedoraproject.org",
    "app.os.stg.fedoraproject.org",
    "conn.uk",
    "copro.uk",
    "hosp.uk",
    "mydobiss.com",
    "fh-muenster.io",
    "filegear.me",
    "filegear-au.me",
    "filegear-de.me",
    "filegear-gb.me",
    "filegear-ie.me",
    "filegear-jp.me",
    "filegear-sg.me",
    "firebaseapp.com",
    "fireweb.app",
    "flap.id",
    "onflashdrive.app",
    "fldrv.com",
    "fly.dev",
    "edgeapp.net",
    "shw.io",
    "flynnhosting.net",
    "forgeblocks.com",
    "id.forgerock.io",
    "framer.app",
    "framercanvas.com",
    "*.frusky.de",
    "ravpage.co.il",
    "0e.vc",
    "freebox-os.com",
    "freeboxos.com",
    "fbx-os.fr",
    "fbxos.fr",
    "freebox-os.fr",
    "freeboxos.fr",
    "freedesktop.org",
    "freemyip.com",
    "wien.funkfeuer.at",
    "*.futurecms.at",
    "*.ex.futurecms.at",
    "*.in.futurecms.at",
    "futurehosting.at",
    "futuremailing.at",
    "*.ex.ortsinfo.at",
    "*.kunden.ortsinfo.at",
    "*.statics.cloud",
    "independent-commission.uk",
    "independent-inquest.uk",
    "independent-inquiry.uk",
    "independent-panel.uk",
    "independent-review.uk",
    "public-inquiry.uk",
    "royal-commission.uk",
    "campaign.gov.uk",
    "service.gov.uk",
    "api.gov.uk",
    "gehirn.ne.jp",
    "usercontent.jp",
    "gentapps.com",
    "gentlentapis.com",
    "lab.ms",
    "cdn-edges.net",
    "ghost.io",
    "gsj.bz",
    "githubusercontent.com",
    "githubpreview.dev",
    "github.io",
    "gitlab.io",
    "gitapp.si",
    "gitpage.si",
    "glitch.me",
    "nog.community",
    "co.ro",
    "shop.ro",
    "lolipop.io",
    "angry.jp",
    "babyblue.jp",
    "babymilk.jp",
    "backdrop.jp",
    "bambina.jp",
    "bitter.jp",
    "blush.jp",
    "boo.jp",
    "boy.jp",
    "boyfriend.jp",
    "but.jp",
    "candypop.jp",
    "capoo.jp",
    "catfood.jp",
    "cheap.jp",
    "chicappa.jp",
    "chillout.jp",
    "chips.jp",
    "chowder.jp",
    "chu.jp",
    "ciao.jp",
    "cocotte.jp",
    "coolblog.jp",
    "cranky.jp",
    "cutegirl.jp",
    "daa.jp",
    "deca.jp",
    "deci.jp",
    "digick.jp",
    "egoism.jp",
    "fakefur.jp",
    "fem.jp",
    "flier.jp",
    "floppy.jp",
    "fool.jp",
    "frenchkiss.jp",
    "girlfriend.jp",
    "girly.jp",
    "gloomy.jp",
    "gonna.jp",
    "greater.jp",
    "hacca.jp",
    "heavy.jp",
    "her.jp",
    "hiho.jp",
    "hippy.jp",
    "holy.jp",
    "hungry.jp",
    "icurus.jp",
    "itigo.jp",
    "jellybean.jp",
    "kikirara.jp",
    "kill.jp",
    "kilo.jp",
    "kuron.jp",
    "littlestar.jp",
    "lolipopmc.jp",
    "lolitapunk.jp",
    "lomo.jp",
    "lovepop.jp",
    "lovesick.jp",
    "main.jp",
    "mods.jp",
    "mond.jp",
    "mongolian.jp",
    "moo.jp",
    "namaste.jp",
    "nikita.jp",
    "nobushi.jp",
    "noor.jp",
    "oops.jp",
    "parallel.jp",
    "parasite.jp",
    "pecori.jp",
    "peewee.jp",
    "penne.jp",
    "pepper.jp",
    "perma.jp",
    "pigboat.jp",
    "pinoko.jp",
    "punyu.jp",
    "pupu.jp",
    "pussycat.jp",
    "pya.jp",
    "raindrop.jp",
    "readymade.jp",
    "sadist.jp",
    "schoolbus.jp",
    "secret.jp",
    "staba.jp",
    "stripper.jp",
    "sub.jp",
    "sunnyday.jp",
    "thick.jp",
    "tonkotsu.jp",
    "under.jp",
    "upper.jp",
    "velvet.jp",
    "verse.jp",
    "versus.jp",
    "vivian.jp",
    "watson.jp",
    "weblike.jp",
    "whitesnow.jp",
    "zombie.jp",
    "heteml.net",
    "cloudapps.digital",
    "london.cloudapps.digital",
    "pymnt.uk",
    "homeoffice.gov.uk",
    "ro.im",
    "goip.de",
    "run.app",
    "a.run.app",
    "web.app",
    "*.0emm.com",
    "appspot.com",
    "*.r.appspot.com",
    "codespot.com",
    "googleapis.com",
    "googlecode.com",
    "pagespeedmobilizer.com",
    "publishproxy.com",
    "withgoogle.com",
    "withyoutube.com",
    "*.gateway.dev",
    "cloud.goog",
    "translate.goog",
    "*.usercontent.goog",
    "cloudfunctions.net",
    "blogspot.ae",
    "blogspot.al",
    "blogspot.am",
    "blogspot.ba",
    "blogspot.be",
    "blogspot.bg",
    "blogspot.bj",
    "blogspot.ca",
    "blogspot.cf",
    "blogspot.ch",
    "blogspot.cl",
    "blogspot.co.at",
    "blogspot.co.id",
    "blogspot.co.il",
    "blogspot.co.ke",
    "blogspot.co.nz",
    "blogspot.co.uk",
    "blogspot.co.za",
    "blogspot.com",
    "blogspot.com.ar",
    "blogspot.com.au",
    "blogspot.com.br",
    "blogspot.com.by",
    "blogspot.com.co",
    "blogspot.com.cy",
    "blogspot.com.ee",
    "blogspot.com.eg",
    "blogspot.com.es",
    "blogspot.com.mt",
    "blogspot.com.ng",
    "blogspot.com.tr",
    "blogspot.com.uy",
    "blogspot.cv",
    "blogspot.cz",
    "blogspot.de",
    "blogspot.dk",
    "blogspot.fi",
    "blogspot.fr",
    "blogspot.gr",
    "blogspot.hk",
    "blogspot.hr",
    "blogspot.hu",
    "blogspot.ie",
    "blogspot.in",
    "blogspot.is",
    "blogspot.it",
    "blogspot.jp",
    "blogspot.kr",
    "blogspot.li",
    "blogspot.lt",
    "blogspot.lu",
    "blogspot.md",
    "blogspot.mk",
    "blogspot.mr",
    "blogspot.mx",
    "blogspot.my",
    "blogspot.nl",
    "blogspot.no",
    "blogspot.pe",
    "blogspot.pt",
    "blogspot.qa",
    "blogspot.re",
    "blogspot.ro",
    "blogspot.rs",
    "blogspot.ru",
    "blogspot.se",
    "blogspot.sg",
    "blogspot.si",
    "blogspot.sk",
    "blogspot.sn",
    "blogspot.td",
    "blogspot.tw",
    "blogspot.ug",
    "blogspot.vn",
    "goupile.fr",
    "gov.nl",
    "awsmppl.com",
    "gnstigbestellen.de",
    "gnstigliefern.de",
    "fin.ci",
    "free.hr",
    "caa.li",
    "ua.rs",
    "conf.se",
    "hs.zone",
    "hs.run",
    "hashbang.sh",
    "hasura.app",
    "hasura-app.io",
    "pages.it.hs-heilbronn.de",
    "hepforge.org",
    "herokuapp.com",
    "herokussl.com",
    "ravendb.cloud",
    "myravendb.com",
    "ravendb.community",
    "ravendb.me",
    "development.run",
    "ravendb.run",
    "homesklep.pl",
    "secaas.hk",
    "hoplix.shop",
    "orx.biz",
    "biz.gl",
    "col.ng",
    "firm.ng",
    "gen.ng",
    "ltd.ng",
    "ngo.ng",
    "edu.scot",
    "sch.so",
    "hostyhosting.io",
    "hkkinen.fi",
    "*.moonscale.io",
    "moonscale.net",
    "iki.fi",
    "ibxos.it",
    "iliadboxos.it",
    "impertrixcdn.com",
    "impertrix.com",
    "smushcdn.com",
    "wphostedmail.com",
    "wpmucdn.com",
    "tempurl.host",
    "wpmudev.host",
    "dyn-berlin.de",
    "in-berlin.de",
    "in-brb.de",
    "in-butter.de",
    "in-dsl.de",
    "in-dsl.net",
    "in-dsl.org",
    "in-vpn.de",
    "in-vpn.net",
    "in-vpn.org",
    "biz.at",
    "info.at",
    "info.cx",
    "ac.leg.br",
    "al.leg.br",
    "am.leg.br",
    "ap.leg.br",
    "ba.leg.br",
    "ce.leg.br",
    "df.leg.br",
    "es.leg.br",
    "go.leg.br",
    "ma.leg.br",
    "mg.leg.br",
    "ms.leg.br",
    "mt.leg.br",
    "pa.leg.br",
    "pb.leg.br",
    "pe.leg.br",
    "pi.leg.br",
    "pr.leg.br",
    "rj.leg.br",
    "rn.leg.br",
    "ro.leg.br",
    "rr.leg.br",
    "rs.leg.br",
    "sc.leg.br",
    "se.leg.br",
    "sp.leg.br",
    "to.leg.br",
    "pixolino.com",
    "na4u.ru",
    "iopsys.se",
    "ipifony.net",
    "iservschule.de",
    "mein-iserv.de",
    "schulplattform.de",
    "schulserver.de",
    "test-iserv.de",
    "iserv.dev",
    "iobb.net",
    "mel.cloudlets.com.au",
    "cloud.interhostsolutions.be",
    "users.scale.virtualcloud.com.br",
    "mycloud.by",
    "alp1.ae.flow.ch",
    "appengine.flow.ch",
    "es-1.axarnet.cloud",
    "diadem.cloud",
    "vip.jelastic.cloud",
    "jele.cloud",
    "it1.eur.aruba.jenv-aruba.cloud",
    "it1.jenv-aruba.cloud",
    "keliweb.cloud",
    "cs.keliweb.cloud",
    "oxa.cloud",
    "tn.oxa.cloud",
    "uk.oxa.cloud",
    "primetel.cloud",
    "uk.primetel.cloud",
    "ca.reclaim.cloud",
    "uk.reclaim.cloud",
    "us.reclaim.cloud",
    "ch.trendhosting.cloud",
    "de.trendhosting.cloud",
    "jele.club",
    "amscompute.com",
    "clicketcloud.com",
    "dopaas.com",
    "hidora.com",
    "paas.hosted-by-previder.com",
    "rag-cloud.hosteur.com",
    "rag-cloud-ch.hosteur.com",
    "jcloud.ik-server.com",
    "jcloud-ver-jpc.ik-server.com",
    "demo.jelastic.com",
    "kilatiron.com",
    "paas.massivegrid.com",
    "jed.wafaicloud.com",
    "lon.wafaicloud.com",
    "ryd.wafaicloud.com",
    "j.scaleforce.com.cy",
    "jelastic.dogado.eu",
    "fi.cloudplatform.fi",
    "demo.datacenter.fi",
    "paas.datacenter.fi",
    "jele.host",
    "mircloud.host",
    "paas.beebyte.io",
    "sekd1.beebyteapp.io",
    "jele.io",
    "cloud-fr1.unispace.io",
    "jc.neen.it",
    "cloud.jelastic.open.tim.it",
    "jcloud.kz",
    "upaas.kazteleport.kz",
    "cloudjiffy.net",
    "fra1-de.cloudjiffy.net",
    "west1-us.cloudjiffy.net",
    "jls-sto1.elastx.net",
    "jls-sto2.elastx.net",
    "jls-sto3.elastx.net",
    "faststacks.net",
    "fr-1.paas.massivegrid.net",
    "lon-1.paas.massivegrid.net",
    "lon-2.paas.massivegrid.net",
    "ny-1.paas.massivegrid.net",
    "ny-2.paas.massivegrid.net",
    "sg-1.paas.massivegrid.net",
    "jelastic.saveincloud.net",
    "nordeste-idc.saveincloud.net",
    "j.scaleforce.net",
    "jelastic.tsukaeru.net",
    "sdscloud.pl",
    "unicloud.pl",
    "mircloud.ru",
    "jelastic.regruhosting.ru",
    "enscaled.sg",
    "jele.site",
    "jelastic.team",
    "orangecloud.tn",
    "j.layershift.co.uk",
    "phx.enscaled.us",
    "mircloud.us",
    "myjino.ru",
    "*.hosting.myjino.ru",
    "*.landing.myjino.ru",
    "*.spectrum.myjino.ru",
    "*.vps.myjino.ru",
    "jotelulu.cloud",
    "*.triton.zone",
    "*.cns.joyent.com",
    "js.org",
    "kaas.gg",
    "khplay.nl",
    "ktistory.com",
    "kapsi.fi",
    "keymachine.de",
    "kinghost.net",
    "uni5.net",
    "knightpoint.systems",
    "koobin.events",
    "oya.to",
    "kuleuven.cloud",
    "ezproxy.kuleuven.be",
    "co.krd",
    "edu.krd",
    "krellian.net",
    "webthings.io",
    "git-repos.de",
    "lcube-server.de",
    "svn-repos.de",
    "leadpages.co",
    "lpages.co",
    "lpusercontent.com",
    "lelux.site",
    "co.business",
    "co.education",
    "co.events",
    "co.financial",
    "co.network",
    "co.place",
    "co.technology",
    "app.lmpm.com",
    "linkyard.cloud",
    "linkyard-cloud.ch",
    "members.linode.com",
    "*.nodebalancer.linode.com",
    "*.linodeobjects.com",
    "ip.linodeusercontent.com",
    "we.bs",
    "*.user.localcert.dev",
    "localzone.xyz",
    "loginline.app",
    "loginline.dev",
    "loginline.io",
    "loginline.services",
    "loginline.site",
    "servers.run",
    "lohmus.me",
    "krasnik.pl",
    "leczna.pl",
    "lubartow.pl",
    "lublin.pl",
    "poniatowa.pl",
    "swidnik.pl",
    "glug.org.uk",
    "lug.org.uk",
    "lugs.org.uk",
    "barsy.bg",
    "barsy.co.uk",
    "barsyonline.co.uk",
    "barsycenter.com",
    "barsyonline.com",
    "barsy.club",
    "barsy.de",
    "barsy.eu",
    "barsy.in",
    "barsy.info",
    "barsy.io",
    "barsy.me",
    "barsy.menu",
    "barsy.mobi",
    "barsy.net",
    "barsy.online",
    "barsy.org",
    "barsy.pro",
    "barsy.pub",
    "barsy.ro",
    "barsy.shop",
    "barsy.site",
    "barsy.support",
    "barsy.uk",
    "*.magentosite.cloud",
    "mayfirst.info",
    "mayfirst.org",
    "hb.cldmail.ru",
    "cn.vu",
    "mazeplay.com",
    "mcpe.me",
    "mcdir.me",
    "mcdir.ru",
    "mcpre.ru",
    "vps.mcdir.ru",
    "mediatech.by",
    "mediatech.dev",
    "hra.health",
    "miniserver.com",
    "memset.net",
    "messerli.app",
    "*.cloud.metacentrum.cz",
    "custom.metacentrum.cz",
    "flt.cloud.muni.cz",
    "usr.cloud.muni.cz",
    "meteorapp.com",
    "eu.meteorapp.com",
    "co.pl",
    "*.azurecontainer.io",
    "azurewebsites.net",
    "azure-mobile.net",
    "cloudapp.net",
    "azurestaticapps.net",
    "1.azurestaticapps.net",
    "centralus.azurestaticapps.net",
    "eastasia.azurestaticapps.net",
    "eastus2.azurestaticapps.net",
    "westeurope.azurestaticapps.net",
    "westus2.azurestaticapps.net",
    "csx.cc",
    "mintere.site",
    "forte.id",
    "mozilla-iot.org",
    "bmoattachments.org",
    "net.ru",
    "org.ru",
    "pp.ru",
    "hostedpi.com",
    "customer.mythic-beasts.com",
    "caracal.mythic-beasts.com",
    "fentiger.mythic-beasts.com",
    "lynx.mythic-beasts.com",
    "ocelot.mythic-beasts.com",
    "oncilla.mythic-beasts.com",
    "onza.mythic-beasts.com",
    "sphinx.mythic-beasts.com",
    "vs.mythic-beasts.com",
    "x.mythic-beasts.com",
    "yali.mythic-beasts.com",
    "cust.retrosnub.co.uk",
    "ui.nabu.casa",
    "pony.club",
    "of.fashion",
    "in.london",
    "of.london",
    "from.marketing",
    "with.marketing",
    "for.men",
    "repair.men",
    "and.mom",
    "for.mom",
    "for.one",
    "under.one",
    "for.sale",
    "that.win",
    "from.work",
    "to.work",
    "cloud.nospamproxy.com",
    "netlify.app",
    "4u.com",
    "ngrok.io",
    "nh-serv.co.uk",
    "nfshost.com",
    "*.developer.app",
    "noop.app",
    "*.northflank.app",
    "*.build.run",
    "*.code.run",
    "*.database.run",
    "*.migration.run",
    "noticeable.news",
    "dnsking.ch",
    "mypi.co",
    "n4t.co",
    "001www.com",
    "ddnslive.com",
    "myiphost.com",
    "forumz.info",
    "16-b.it",
    "32-b.it",
    "64-b.it",
    "soundcast.me",
    "tcp4.me",
    "dnsup.net",
    "hicam.net",
    "now-dns.net",
    "ownip.net",
    "vpndns.net",
    "dynserv.org",
    "now-dns.org",
    "x443.pw",
    "now-dns.top",
    "ntdll.top",
    "freeddns.us",
    "crafting.xyz",
    "zapto.xyz",
    "nsupdate.info",
    "nerdpol.ovh",
    "blogsyte.com",
    "brasilia.me",
    "cable-modem.org",
    "ciscofreak.com",
    "collegefan.org",
    "couchpotatofries.org",
    "damnserver.com",
    "ddns.me",
    "ditchyourip.com",
    "dnsfor.me",
    "dnsiskinky.com",
    "dvrcam.info",
    "dynns.com",
    "eating-organic.net",
    "fantasyleague.cc",
    "geekgalaxy.com",
    "golffan.us",
    "health-carereform.com",
    "homesecuritymac.com",
    "homesecuritypc.com",
    "hopto.me",
    "ilovecollege.info",
    "loginto.me",
    "mlbfan.org",
    "mmafan.biz",
    "myactivedirectory.com",
    "mydissent.net",
    "myeffect.net",
    "mymediapc.net",
    "mypsx.net",
    "mysecuritycamera.com",
    "mysecuritycamera.net",
    "mysecuritycamera.org",
    "net-freaks.com",
    "nflfan.org",
    "nhlfan.net",
    "no-ip.ca",
    "no-ip.co.uk",
    "no-ip.net",
    "noip.us",
    "onthewifi.com",
    "pgafan.net",
    "point2this.com",
    "pointto.us",
    "privatizehealthinsurance.net",
    "quicksytes.com",
    "read-books.org",
    "securitytactics.com",
    "serveexchange.com",
    "servehumour.com",
    "servep2p.com",
    "servesarcasm.com",
    "stufftoread.com",
    "ufcfan.org",
    "unusualperson.com",
    "workisboring.com",
    "3utilities.com",
    "bounceme.net",
    "ddns.net",
    "ddnsking.com",
    "gotdns.ch",
    "hopto.org",
    "myftp.biz",
    "myftp.org",
    "myvnc.com",
    "no-ip.biz",
    "no-ip.info",
    "no-ip.org",
    "noip.me",
    "redirectme.net",
    "servebeer.com",
    "serveblog.net",
    "servecounterstrike.com",
    "serveftp.com",
    "servegame.com",
    "servehalflife.com",
    "servehttp.com",
    "serveirc.com",
    "serveminecraft.net",
    "servemp3.com",
    "servepics.com",
    "servequake.com",
    "sytes.net",
    "webhop.me",
    "zapto.org",
    "stage.nodeart.io",
    "pcloud.host",
    "nyc.mn",
    "static.observableusercontent.com",
    "cya.gg",
    "omg.lol",
    "cloudycluster.net",
    "omniwe.site",
    "service.one",
    "nid.io",
    "opensocial.site",
    "opencraft.hosting",
    "orsites.com",
    "operaunite.com",
    "tech.orange",
    "authgear-staging.com",
    "authgearapps.com",
    "skygearapp.com",
    "outsystemscloud.com",
    "*.webpaas.ovh.net",
    "*.hosting.ovh.net",
    "ownprovider.com",
    "own.pm",
    "*.owo.codes",
    "ox.rs",
    "oy.lc",
    "pgfog.com",
    "pagefrontapp.com",
    "pagexl.com",
    "*.paywhirl.com",
    "bar0.net",
    "bar1.net",
    "bar2.net",
    "rdv.to",
    "art.pl",
    "gliwice.pl",
    "krakow.pl",
    "poznan.pl",
    "wroc.pl",
    "zakopane.pl",
    "pantheonsite.io",
    "gotpantheon.com",
    "mypep.link",
    "perspecta.cloud",
    "lk3.ru",
    "on-web.fr",
    "bc.platform.sh",
    "ent.platform.sh",
    "eu.platform.sh",
    "us.platform.sh",
    "*.platformsh.site",
    "*.tst.site",
    "platter-app.com",
    "platter-app.dev",
    "platterp.us",
    "pdns.page",
    "plesk.page",
    "pleskns.com",
    "dyn53.io",
    "onporter.run",
    "co.bn",
    "postman-echo.com",
    "pstmn.io",
    "mock.pstmn.io",
    "httpbin.org",
    "prequalifyme.today",
    "xen.prgmr.com",
    "priv.at",
    "prvcy.page",
    "*.dweb.link",
    "protonet.io",
    "chirurgiens-dentistes-en-france.fr",
    "byen.site",
    "pubtls.org",
    "pythonanywhere.com",
    "eu.pythonanywhere.com",
    "qoto.io",
    "qualifioapp.com",
    "qbuser.com",
    "cloudsite.builders",
    "instances.spawn.cc",
    "instantcloud.cn",
    "ras.ru",
    "qa2.com",
    "qcx.io",
    "*.sys.qcx.io",
    "dev-myqnapcloud.com",
    "alpha-myqnapcloud.com",
    "myqnapcloud.com",
    "*.quipelements.com",
    "vapor.cloud",
    "vaporcloud.io",
    "rackmaze.com",
    "rackmaze.net",
    "g.vbrplsbx.io",
    "*.on-k3s.io",
    "*.on-rancher.cloud",
    "*.on-rio.io",
    "readthedocs.io",
    "rhcloud.com",
    "app.render.com",
    "onrender.com",
    "repl.co",
    "id.repl.co",
    "repl.run",
    "resindevice.io",
    "devices.resinstaging.io",
    "hzc.io",
    "wellbeingzone.eu",
    "wellbeingzone.co.uk",
    "adimo.co.uk",
    "itcouldbewor.se",
    "git-pages.rit.edu",
    "rocky.page",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "*.builder.code.com",
    "*.dev-builder.code.com",
    "*.stg-builder.code.com",
    "sandcats.io",
    "logoip.de",
    "logoip.com",
    "fr-par-1.baremetal.scw.cloud",
    "fr-par-2.baremetal.scw.cloud",
    "nl-ams-1.baremetal.scw.cloud",
    "fnc.fr-par.scw.cloud",
    "functions.fnc.fr-par.scw.cloud",
    "k8s.fr-par.scw.cloud",
    "nodes.k8s.fr-par.scw.cloud",
    "s3.fr-par.scw.cloud",
    "s3-website.fr-par.scw.cloud",
    "whm.fr-par.scw.cloud",
    "priv.instances.scw.cloud",
    "pub.instances.scw.cloud",
    "k8s.scw.cloud",
    "k8s.nl-ams.scw.cloud",
    "nodes.k8s.nl-ams.scw.cloud",
    "s3.nl-ams.scw.cloud",
    "s3-website.nl-ams.scw.cloud",
    "whm.nl-ams.scw.cloud",
    "k8s.pl-waw.scw.cloud",
    "nodes.k8s.pl-waw.scw.cloud",
    "s3.pl-waw.scw.cloud",
    "s3-website.pl-waw.scw.cloud",
    "scalebook.scw.cloud",
    "smartlabeling.scw.cloud",
    "dedibox.fr",
    "schokokeks.net",
    "gov.scot",
    "service.gov.scot",
    "scrysec.com",
    "firewall-gateway.com",
    "firewall-gateway.de",
    "my-gateway.de",
    "my-router.de",
    "spdns.de",
    "spdns.eu",
    "firewall-gateway.net",
    "my-firewall.org",
    "myfirewall.org",
    "spdns.org",
    "seidat.net",
    "sellfy.store",
    "senseering.net",
    "minisite.ms",
    "magnet.page",
    "biz.ua",
    "co.ua",
    "pp.ua",
    "shiftcrypto.dev",
    "shiftcrypto.io",
    "shiftedit.io",
    "myshopblocks.com",
    "myshopify.com",
    "shopitsite.com",
    "shopware.store",
    "mo-siemens.io",
    "1kapp.com",
    "appchizi.com",
    "applinzi.com",
    "sinaapp.com",
    "vipsinaapp.com",
    "siteleaf.net",
    "bounty-full.com",
    "alpha.bounty-full.com",
    "beta.bounty-full.com",
    "small-web.org",
    "vp4.me",
    "try-snowplow.com",
    "srht.site",
    "stackhero-network.com",
    "musician.io",
    "novecore.site",
    "static.land",
    "dev.static.land",
    "sites.static.land",
    "storebase.store",
    "vps-host.net",
    "atl.jelastic.vps-host.net",
    "njs.jelastic.vps-host.net",
    "ric.jelastic.vps-host.net",
    "playstation-cloud.com",
    "apps.lair.io",
    "*.stolos.io",
    "spacekit.io",
    "customer.speedpartner.de",
    "myspreadshop.at",
    "myspreadshop.com.au",
    "myspreadshop.be",
    "myspreadshop.ca",
    "myspreadshop.ch",
    "myspreadshop.com",
    "myspreadshop.de",
    "myspreadshop.dk",
    "myspreadshop.es",
    "myspreadshop.fi",
    "myspreadshop.fr",
    "myspreadshop.ie",
    "myspreadshop.it",
    "myspreadshop.net",
    "myspreadshop.nl",
    "myspreadshop.no",
    "myspreadshop.pl",
    "myspreadshop.se",
    "myspreadshop.co.uk",
    "api.stdlib.com",
    "storj.farm",
    "utwente.io",
    "soc.srcf.net",
    "user.srcf.net",
    "temp-dns.com",
    "supabase.co",
    "supabase.in",
    "supabase.net",
    "su.paba.se",
    "*.s5y.io",
    "*.sensiosite.cloud",
    "syncloud.it",
    "dscloud.biz",
    "direct.quickconnect.cn",
    "dsmynas.com",
    "familyds.com",
    "diskstation.me",
    "dscloud.me",
    "i234.me",
    "myds.me",
    "synology.me",
    "dscloud.mobi",
    "dsmynas.net",
    "familyds.net",
    "dsmynas.org",
    "familyds.org",
    "vpnplus.to",
    "direct.quickconnect.to",
    "tabitorder.co.il",
    "taifun-dns.de",
    "beta.tailscale.net",
    "ts.net",
    "gda.pl",
    "gdansk.pl",
    "gdynia.pl",
    "med.pl",
    "sopot.pl",
    "site.tb-hosting.com",
    "edugit.io",
    "s3.teckids.org",
    "telebit.app",
    "telebit.io",
    "*.telebit.xyz",
    "gwiddle.co.uk",
    "*.firenet.ch",
    "*.svc.firenet.ch",
    "reservd.com",
    "thingdustdata.com",
    "cust.dev.thingdust.io",
    "cust.disrec.thingdust.io",
    "cust.prod.thingdust.io",
    "cust.testing.thingdust.io",
    "reservd.dev.thingdust.io",
    "reservd.disrec.thingdust.io",
    "reservd.testing.thingdust.io",
    "tickets.io",
    "arvo.network",
    "azimuth.network",
    "tlon.network",
    "torproject.net",
    "pages.torproject.net",
    "bloxcms.com",
    "townnews-staging.com",
    "tbits.me",
    "12hp.at",
    "2ix.at",
    "4lima.at",
    "lima-city.at",
    "12hp.ch",
    "2ix.ch",
    "4lima.ch",
    "lima-city.ch",
    "trafficplex.cloud",
    "de.cool",
    "12hp.de",
    "2ix.de",
    "4lima.de",
    "lima-city.de",
    "1337.pictures",
    "clan.rip",
    "lima-city.rocks",
    "webspace.rocks",
    "lima.zone",
    "*.transurl.be",
    "*.transurl.eu",
    "*.transurl.nl",
    "site.transip.me",
    "tuxfamily.org",
    "dd-dns.de",
    "diskstation.eu",
    "diskstation.org",
    "dray-dns.de",
    "draydns.de",
    "dyn-vpn.de",
    "dynvpn.de",
    "mein-vigor.de",
    "my-vigor.de",
    "my-wan.de",
    "syno-ds.de",
    "synology-diskstation.de",
    "synology-ds.de",
    "typedream.app",
    "pro.typeform.com",
    "uber.space",
    "*.uberspace.de",
    "hk.com",
    "hk.org",
    "ltd.hk",
    "inc.hk",
    "name.pm",
    "sch.tf",
    "biz.wf",
    "sch.wf",
    "org.yt",
    "virtualuser.de",
    "virtual-user.de",
    "upli.io",
    "urown.cloud",
    "dnsupdate.info",
    "lib.de.us",
    "2038.io",
    "vercel.app",
    "vercel.dev",
    "now.sh",
    "router.management",
    "v-info.info",
    "voorloper.cloud",
    "neko.am",
    "nyaa.am",
    "be.ax",
    "cat.ax",
    "es.ax",
    "eu.ax",
    "gg.ax",
    "mc.ax",
    "us.ax",
    "xy.ax",
    "nl.ci",
    "xx.gl",
    "app.gp",
    "blog.gt",
    "de.gt",
    "to.gt",
    "be.gy",
    "cc.hn",
    "blog.kg",
    "io.kg",
    "jp.kg",
    "tv.kg",
    "uk.kg",
    "us.kg",
    "de.ls",
    "at.md",
    "de.md",
    "jp.md",
    "to.md",
    "indie.porn",
    "vxl.sh",
    "ch.tc",
    "me.tc",
    "we.tc",
    "nyan.to",
    "at.vg",
    "blog.vu",
    "dev.vu",
    "me.vu",
    "v.ua",
    "*.vultrobjects.com",
    "wafflecell.com",
    "*.webhare.dev",
    "reserve-online.net",
    "reserve-online.com",
    "bookonline.app",
    "hotelwithflight.com",
    "wedeploy.io",
    "wedeploy.me",
    "wedeploy.sh",
    "remotewd.com",
    "pages.wiardweb.com",
    "wmflabs.org",
    "toolforge.org",
    "wmcloud.org",
    "panel.gg",
    "daemon.panel.gg",
    "messwithdns.com",
    "woltlab-demo.com",
    "myforum.community",
    "community-pro.de",
    "diskussionsbereich.de",
    "community-pro.net",
    "meinforum.net",
    "affinitylottery.org.uk",
    "raffleentry.org.uk",
    "weeklylottery.org.uk",
    "wpenginepowered.com",
    "js.wpenginepowered.com",
    "wixsite.com",
    "editorx.io",
    "half.host",
    "xnbay.com",
    "u2.xnbay.com",
    "u2-local.xnbay.com",
    "cistron.nl",
    "demon.nl",
    "xs4all.space",
    "yandexcloud.net",
    "storage.yandexcloud.net",
    "website.yandexcloud.net",
    "official.academy",
    "yolasite.com",
    "ybo.faith",
    "yombo.me",
    "homelink.one",
    "ybo.party",
    "ybo.review",
    "ybo.science",
    "ybo.trade",
    "ynh.fr",
    "nohost.me",
    "noho.st",
    "za.net",
    "za.org",
    "bss.design",
    "basicserver.io",
    "virtualserver.io",
    "enterprisecloud.nu"
  ];
  (function(exports2) {
    var Punycode = require$$0;
    var internals = {};
    internals.rules = require$$1.map(function(rule) {
      return {
        rule,
        suffix: rule.replace(/^(\*\.|\!)/, ""),
        punySuffix: -1,
        wildcard: rule.charAt(0) === "*",
        exception: rule.charAt(0) === "!"
      };
    });
    internals.endsWith = function(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };
    internals.findRule = function(domain) {
      var punyDomain = Punycode.toASCII(domain);
      return internals.rules.reduce(function(memo, rule) {
        if (rule.punySuffix === -1) {
          rule.punySuffix = Punycode.toASCII(rule.suffix);
        }
        if (!internals.endsWith(punyDomain, "." + rule.punySuffix) && punyDomain !== rule.punySuffix) {
          return memo;
        }
        return rule;
      }, null);
    };
    exports2.errorCodes = {
      DOMAIN_TOO_SHORT: "Domain name too short.",
      DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
      LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
      LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
      LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
      LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
      LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
    };
    internals.validate = function(input) {
      var ascii = Punycode.toASCII(input);
      if (ascii.length < 1) {
        return "DOMAIN_TOO_SHORT";
      }
      if (ascii.length > 255) {
        return "DOMAIN_TOO_LONG";
      }
      var labels = ascii.split(".");
      var label;
      for (var i2 = 0; i2 < labels.length; ++i2) {
        label = labels[i2];
        if (!label.length) {
          return "LABEL_TOO_SHORT";
        }
        if (label.length > 63) {
          return "LABEL_TOO_LONG";
        }
        if (label.charAt(0) === "-") {
          return "LABEL_STARTS_WITH_DASH";
        }
        if (label.charAt(label.length - 1) === "-") {
          return "LABEL_ENDS_WITH_DASH";
        }
        if (!/^[a-z0-9\-]+$/.test(label)) {
          return "LABEL_INVALID_CHARS";
        }
      }
    };
    exports2.parse = function(input) {
      if (typeof input !== "string") {
        throw new TypeError("Domain name must be a string.");
      }
      var domain = input.slice(0).toLowerCase();
      if (domain.charAt(domain.length - 1) === ".") {
        domain = domain.slice(0, domain.length - 1);
      }
      var error2 = internals.validate(domain);
      if (error2) {
        return {
          input,
          error: {
            message: exports2.errorCodes[error2],
            code: error2
          }
        };
      }
      var parsed = {
        input,
        tld: null,
        sld: null,
        domain: null,
        subdomain: null,
        listed: false
      };
      var domainParts = domain.split(".");
      if (domainParts[domainParts.length - 1] === "local") {
        return parsed;
      }
      var handlePunycode = function() {
        if (!/xn--/.test(domain)) {
          return parsed;
        }
        if (parsed.domain) {
          parsed.domain = Punycode.toASCII(parsed.domain);
        }
        if (parsed.subdomain) {
          parsed.subdomain = Punycode.toASCII(parsed.subdomain);
        }
        return parsed;
      };
      var rule = internals.findRule(domain);
      if (!rule) {
        if (domainParts.length < 2) {
          return parsed;
        }
        parsed.tld = domainParts.pop();
        parsed.sld = domainParts.pop();
        parsed.domain = [parsed.sld, parsed.tld].join(".");
        if (domainParts.length) {
          parsed.subdomain = domainParts.pop();
        }
        return handlePunycode();
      }
      parsed.listed = true;
      var tldParts = rule.suffix.split(".");
      var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);
      if (rule.exception) {
        privateParts.push(tldParts.shift());
      }
      parsed.tld = tldParts.join(".");
      if (!privateParts.length) {
        return handlePunycode();
      }
      if (rule.wildcard) {
        tldParts.unshift(privateParts.pop());
        parsed.tld = tldParts.join(".");
      }
      if (!privateParts.length) {
        return handlePunycode();
      }
      parsed.sld = privateParts.pop();
      parsed.domain = [parsed.sld, parsed.tld].join(".");
      if (privateParts.length) {
        parsed.subdomain = privateParts.join(".");
      }
      return handlePunycode();
    };
    exports2.get = function(domain) {
      if (!domain) {
        return null;
      }
      return exports2.parse(domain).domain || null;
    };
    exports2.isValid = function(domain) {
      var parsed = exports2.parse(domain);
      return Boolean(parsed.domain && parsed.listed);
    };
  })(psl);
  const d$2 = /* @__PURE__ */ getDefaultExportFromCjs(psl);
  function f$3(t2) {
    let e2;
    try {
      e2 = new URL(t2);
    } catch {
      return;
    }
    const n2 = x$1(e2.hostname);
    if (!n2.error)
      return {
        url: e2,
        psl: n2
      };
  }
  const h$2 = /* @__PURE__ */ new Map();
  function x$1(t2) {
    const e2 = h$2.get(t2);
    if (e2)
      return e2;
    const n2 = d$2.parse(t2);
    return h$2.set(t2, n2), n2;
  }
  function requiredArgs(required, args) {
    if (args.length < required) {
      throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
    }
  }
  function toDate(argument) {
    requiredArgs(1, arguments);
    var argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
      return new Date(argument.getTime());
    } else if (typeof argument === "number" || argStr === "[object Number]") {
      return new Date(argument);
    } else {
      if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
        console.warn(new Error().stack);
      }
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate(dirtyDateLeft);
    var dateRight = toDate(dirtyDateRight);
    return dateLeft.getTime() - dateRight.getTime();
  }
  function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 1e3;
    return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
  }
  function toInteger(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }
    var number2 = Number(dirtyNumber);
    if (isNaN(number2)) {
      return number2;
    }
    return number2 < 0 ? Math.ceil(number2) : Math.floor(number2);
  }
  var MILLISECONDS_IN_HOUR = 36e5;
  var MILLISECONDS_IN_MINUTE = 6e4;
  var DEFAULT_ADDITIONAL_DIGITS = 2;
  var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  function parseISO(argument, dirtyOptions) {
    requiredArgs(1, arguments);
    var options = dirtyOptions || {};
    var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options.additionalDigits);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError("additionalDigits must be 0, 1 or 2");
    }
    if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
      return /* @__PURE__ */ new Date(NaN);
    }
    var dateStrings = splitDateString(argument);
    var date2;
    if (dateStrings.date) {
      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date2 = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }
    if (isNaN(date2) || !date2) {
      return /* @__PURE__ */ new Date(NaN);
    }
    var timestamp = date2.getTime();
    var time = 0;
    var offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time) || time === null) {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);
      if (isNaN(offset)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    } else {
      var dirtyDate = new Date(timestamp + time);
      var result2 = new Date(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate(), dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
      result2.setFullYear(dirtyDate.getUTCFullYear());
      return result2;
    }
    return new Date(timestamp + time + offset);
  }
  function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimiter);
    var timeString;
    if (/:/.test(array[0])) {
      dateStrings.date = null;
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];
      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(dateStrings.date.length, dateString.length);
      }
    }
    if (timeString) {
      var token = patterns.timezone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], "");
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }
    return dateStrings;
  }
  function parseYear(dateString, additionalDigits) {
    var regex2 = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
    var captures = dateString.match(regex2);
    if (!captures)
      return {
        year: null
      };
    var year = captures[1] && parseInt(captures[1]);
    var century = captures[2] && parseInt(captures[2]);
    return {
      year: century == null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }
  function parseDate(dateString, year) {
    if (year === null)
      return null;
    var captures = dateString.match(dateRegex);
    if (!captures)
      return null;
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      var date2 = /* @__PURE__ */ new Date(0);
      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      date2.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date2;
    }
  }
  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }
  function parseTime(timeString) {
    var captures = timeString.match(timeRegex);
    if (!captures)
      return null;
    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1e3;
  }
  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(",", ".")) || 0;
  }
  function parseTimezone(timezoneString) {
    if (timezoneString === "Z")
      return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures)
      return 0;
    var sign2 = captures[1] === "+" ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    return sign2 * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE);
  }
  function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date2 = /* @__PURE__ */ new Date(0);
    date2.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date2.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date2.setUTCDate(date2.getUTCDate() + diff);
    return date2;
  }
  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100;
  }
  function validateDate(year, month, date2) {
    return month >= 0 && month <= 11 && date2 >= 1 && date2 <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
  }
  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
  }
  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }
  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }
  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }
  function throttle(delay, noTrailing, callback, debounceMode) {
    var timeoutID;
    var cancelled = false;
    var lastExec = 0;
    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    }
    function cancel() {
      clearExistingTimeout();
      cancelled = true;
    }
    if (typeof noTrailing !== "boolean") {
      debounceMode = callback;
      callback = noTrailing;
      noTrailing = void 0;
    }
    function wrapper() {
      for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
        arguments_[_key] = arguments[_key];
      }
      var self2 = this;
      var elapsed = Date.now() - lastExec;
      if (cancelled) {
        return;
      }
      function exec() {
        lastExec = Date.now();
        callback.apply(self2, arguments_);
      }
      function clear() {
        timeoutID = void 0;
      }
      if (debounceMode && !timeoutID) {
        exec();
      }
      clearExistingTimeout();
      if (debounceMode === void 0 && elapsed > delay) {
        exec();
      } else if (noTrailing !== true) {
        timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
      }
    }
    wrapper.cancel = cancel;
    return wrapper;
  }
  function debounce$1(delay, atBegin, callback) {
    return callback === void 0 ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
  }
  function getCommonAncestor(...els) {
    const [firstAncestors, ...remainingAncestors] = els.map(getAncestors);
    for (let i2 = 0; true; i2++) {
      if (firstAncestors[i2] === void 0 || remainingAncestors.some((ancestors) => ancestors[i2] !== firstAncestors[i2])) {
        return firstAncestors[i2 - 1];
      }
    }
  }
  function getAncestors(el2) {
    const ancestors = [];
    let cur = el2;
    do {
      ancestors.unshift(cur);
      cur = getParentWithShadowDom(cur);
    } while (cur);
    return ancestors;
  }
  function getParentWithShadowDom(cur) {
    if (cur.parentElement) {
      return cur.parentElement;
    }
    const rootNode = cur.getRootNode();
    if (rootNode instanceof ShadowRoot) {
      if (rootNode.host instanceof HTMLElement) {
        return rootNode.host;
      }
    }
    return null;
  }
  function getShadowRoot(el2) {
    var _a3, _b, _c2, _d, _e;
    if (!(el2 instanceof HTMLElement)) {
      return void 0;
    }
    if ((_b = (_a3 = window.chrome) === null || _a3 === void 0 ? void 0 : _a3.dom) === null || _b === void 0 ? void 0 : _b.openOrClosedShadowRoot) {
      try {
        return (_c2 = window.chrome.dom.openOrClosedShadowRoot(el2)) !== null && _c2 !== void 0 ? _c2 : void 0;
      } catch (e2) {
        if (typeof e2 === "object" && e2 !== null && "message" in e2 && e2.message === "Extension context invalidated.") {
          return void 0;
        }
        throw e2;
      }
    }
    if (el2.openOrClosedShadowRoot !== void 0) {
      return (_d = el2.openOrClosedShadowRoot) !== null && _d !== void 0 ? _d : void 0;
    }
    return (_e = el2.shadowRoot) !== null && _e !== void 0 ? _e : void 0;
  }
  function querySelectorAllWithShadowRoots(selector2, rootNode = document) {
    const allEls = Array.from(rootNode.querySelectorAll("*"));
    const selectedEls = new Set(rootNode.querySelectorAll(selector2));
    return allEls.flatMap((el2) => {
      const result2 = [];
      if (selectedEls.has(el2)) {
        result2.push(el2);
      }
      const shadowRoot = getShadowRoot(el2);
      if (shadowRoot) {
        result2.push(...querySelectorAllWithShadowRoots(selector2, shadowRoot));
      }
      return result2;
    });
  }
  function getFormDefaultButton(formElement) {
    const candidates = Array.from(querySelectorAllWithShadowRoots("button, input")).filter((el2) => el2.form === formElement);
    const explicitSubmitEl = candidates.find((el2) => el2.getAttribute("type") === "submit");
    if (explicitSubmitEl) {
      return explicitSubmitEl;
    }
    return candidates.find((el2) => el2.type === "submit" || el2 instanceof HTMLInputElement && el2.type === "image");
  }
  function isVisible(el2) {
    let cur = el2;
    let boundingRectWithChildren;
    while (cur) {
      const computedStyle = getComputedStyle(cur);
      const boundingRect = cur.getBoundingClientRect();
      boundingRectWithChildren = mergeRects(boundingRect, boundingRectWithChildren);
      if (isElementVisuallyHidden(cur, computedStyle, boundingRect, boundingRectWithChildren)) {
        return false;
      }
      if (computedStyle.position === "fixed") {
        break;
      }
      if (computedStyle.position === "absolute") {
        cur = getPositionedAncestor(cur);
      } else {
        cur = cur.parentElement;
      }
    }
    return true;
  }
  function isElementVisuallyHidden(el2, computedStyle, boundingRect, childBoundingRect) {
    if (computedStyle.display === "contents") {
      return false;
    }
    if (computedStyle.visibility === "hidden") {
      return true;
    }
    const opacity = parseFloat(computedStyle.opacity);
    if (opacity < 0.01) {
      return true;
    }
    if (/rect\([01](px)?, [01](px)?, [01](px)?, [01](px)?\)/.exec(computedStyle.clip)) {
      return true;
    }
    if (el2.getClientRects().length === 0) {
      return true;
    }
    const { width: elWidth, height: elHeight } = boundingRect;
    if (elWidth < 5 && (computedStyle.overflow === "hidden" || computedStyle.overflowX === "hidden")) {
      return true;
    }
    if (elHeight < 5 && (computedStyle.overflow === "hidden" || computedStyle.overflowY === "hidden")) {
      return true;
    }
    const { left, top, bottom, right } = childBoundingRect;
    if (bottom < -document.documentElement.scrollTop || right < -document.documentElement.scrollLeft || left > document.documentElement.scrollWidth || top > document.documentElement.scrollHeight) {
      return true;
    }
    return false;
  }
  function mergeRects(l2, r2) {
    if (!r2) {
      return l2;
    }
    return {
      top: Math.min(l2.top, r2.top),
      left: Math.min(l2.left, r2.left),
      bottom: Math.max(l2.bottom, r2.bottom),
      right: Math.max(l2.right, r2.right)
    };
  }
  function getPositionedAncestor(el2) {
    let cur = el2.parentElement;
    while (cur) {
      const computedStyle = getComputedStyle(cur);
      if (computedStyle.position !== "static") {
        break;
      }
      cur = cur.parentElement;
    }
    return cur;
  }
  function querySelectorWithShadowRoots(selector2, rootNode = document) {
    const selectedEl = rootNode.querySelector(selector2);
    if (selectedEl) {
      return selectedEl;
    }
    const allEls = Array.from(rootNode.querySelectorAll("*"));
    for (const el2 of allEls) {
      const shadowRoot = getShadowRoot(el2);
      if (shadowRoot) {
        const result2 = querySelectorWithShadowRoots(selector2, shadowRoot);
        if (result2) {
          return result2;
        }
      }
    }
    return void 0;
  }
  const nonUserValueInputTypes = [
    // button like inputs
    "button",
    "submit",
    "image",
    "reset",
    // checkbox like inputs
    "radio",
    "checkbox",
    // other non-text inputs
    "file",
    "hidden"
  ];
  const attributeFilters = [
    // Ignore JS in event handlers, it can very easily keywords that would lead to misleading
    // detection (e.g. looking for event.keyCode) would trigger the "code" heuristic.
    ({ name }) => name.startsWith("on"),
    // Ignore the "accesskey" field. It can't contain information that's useful to us, but may be
    // abused. Example at time of writing: https://signin.infusionsoft.com/login
    ({ name }) => name === "accesskey",
    // auth0 login forms use "auth0-*" class names that mess with our heuristics.
    // However, auth0 forms are otherwise well detectable, so we just ignore class names there.
    ({ name, value }) => name === "class" && value.startsWith("auth0"),
    // Ignore value attribute for input elements where it usually contains user input, because
    // that is never an indicator of a login form.
    ({ el: el2, name }) => {
      return el2 instanceof HTMLInputElement && name === "value" && !nonUserValueInputTypes.includes(el2.type);
    }
  ];
  class HeuristicsPatternMatcher {
    constructor(...patterns2) {
      this.regexps = patterns2.map(HeuristicsPatternMatcher.createRegExp);
    }
    test(url) {
      return this.regexps.some((p2) => p2.test(url));
    }
    testAttributes(el2) {
      return Array.from(el2.attributes).some((attr2) => {
        const value = attr2.nodeValue;
        if (!value) {
          return false;
        }
        if (attributeFilters.some((f2) => f2({ el: el2, name: attr2.name, value }))) {
          return false;
        }
        return this.test(value);
      });
    }
    testText(el2) {
      const text = el2.textContent;
      if (!text) {
        return false;
      }
      return this.test(text);
    }
    static createRegExp(pattern) {
      const regexpStr = pattern.map((part, i2) => HeuristicsPatternMatcher.makeCaseInsensitive(part, i2 === 0)).join(HeuristicsPatternMatcher.PATTERN_PART_SEPARATOR);
      return new RegExp(`${regexpStr}${HeuristicsPatternMatcher.PATTERN_END}`);
    }
    static makeCaseInsensitive(regexpString, firstPart) {
      return [...regexpString].map((char, i2) => {
        const lowerCase = char.toLowerCase();
        const upperCase = char.toUpperCase();
        const caseInsensitive = lowerCase === upperCase ? char : `[${lowerCase}${upperCase}]`;
        if (firstPart && i2 === 0) {
          return String.raw`((^|[^a-zA-Z])${caseInsensitive}|${upperCase})`;
        }
        return caseInsensitive;
      }).join("");
    }
  }
  HeuristicsPatternMatcher.PATTERN_PART_SEPARATOR = String.raw`[_\s-]?`;
  HeuristicsPatternMatcher.PATTERN_END = String.raw`(?=[^a-z]|$)`;
  const heyloginPatternMatcher = new HeuristicsPatternMatcher(
    // the word "heylogin" tends to create false positives so we filter it in some places
    ["heylogin"]
  );
  const loginPatternMatcher = new HeuristicsPatternMatcher(["log", "in"], ["sign", "in"], ["einloggen"], ["auth"]);
  const registrationPatternMatcher = new HeuristicsPatternMatcher(["register"], ["registration"], ["sign", "up"], ["join"], ["trial"], ["registrierung"], ["registrieren"], ["anlegen"]);
  const passwordPatternMatcher = new HeuristicsPatternMatcher(["password"], ["pass"], ["pwd"], ["passwort"]);
  const currentPasswordPatternMatcher = new HeuristicsPatternMatcher(["current"], ["old"]);
  const newPasswordPatternMatcher = new HeuristicsPatternMatcher(["new"]);
  const repeatPasswordPatternMatcher = new HeuristicsPatternMatcher(["repeat"], ["confirm"], ["confirmation"], ["password2"], ["pwd2"], ["check"]);
  const codePatternMatcher = new HeuristicsPatternMatcher(["code"], ["tan"], ["rsa"]);
  const totpPatternMatcher = new HeuristicsPatternMatcher(["totp"], ["otp"], ["pin"], ["code"], ["token"], ["tfa"], ["2fa"], ["mfa"], ["2fpin"], ["challenge"], ["two", "factor"], ["time", "based"], ["one", "time"], ["sicherheitscode"]);
  const usernamePatternMatcher = new HeuristicsPatternMatcher(["user", "name"], ["login", "name"], ["user"], ["mail"], ["email"], ["identifier"], ["phone"]);
  const searchPatternMatcher = new HeuristicsPatternMatcher(["search"], ["filter"], ["suche"]);
  const postalPatternMatcher = new HeuristicsPatternMatcher(["postal"], ["zip"], ["postleit"], ["plz"]);
  const couponPatternMatcher = new HeuristicsPatternMatcher(
    ["claim"],
    ["coupon"],
    ["gutschein"],
    // came up as "redemptionCode" on ebay
    ["redemption"],
    ["voucher"]
  );
  const cvcPatternMatcher = new HeuristicsPatternMatcher(
    ["cvc"],
    ["cvv"],
    ["csc"],
    // cvc comes up as "creditCardVerificationNumber" on amazon
    ["credit"]
  );
  const newsletterPatternMatcher = new HeuristicsPatternMatcher(["newsletter"], ["subscribe"]);
  const stayLoggedInPatternMatcher = new HeuristicsPatternMatcher(["stay"], ["remember"], ["remember", "me"], ["remain"], ["keep"], ["persistent"], ["perm"], ["permanent"], ["auto", "log", "in"]);
  const submitPatternMatcher = new HeuristicsPatternMatcher(["submit"], ["log", "in"], ["sign", "in"], ["einloggen"], ["anmelden"], ["anmeldung"]);
  const socialLoginPatternMatcher = new HeuristicsPatternMatcher(
    // candidates from https://en.wikipedia.org/wiki/Social_login
    ["alipay"],
    ["apple"],
    ["facebook"],
    ["github"],
    ["google"],
    ["linkedin"],
    ["microsoft"],
    ["paypal"],
    ["twitter"],
    ["yahoo"],
    // generic matching for "login with" buttons
    ["with"],
    ["using"],
    ["sso"]
  );
  const cancelLoginPatternMatcher = new HeuristicsPatternMatcher(["cancel"], ["abort"], ["back"], ["abbrechen"], ["zurck"]);
  function analyzeAutocomplete(control, terms) {
    var _a3;
    const autocompleteString = (_a3 = control.getAttribute("autocomplete")) === null || _a3 === void 0 ? void 0 : _a3.trim();
    if (!autocompleteString) {
      return void 0;
    }
    const autocompleteParts = autocompleteString.split(/\s+/).map((s2) => s2.toLocaleLowerCase());
    return mapValues(terms, (t2) => autocompleteParts.includes(t2));
  }
  function mapValues(obj, transform) {
    const entries = Object.entries(obj);
    const transformedEntries = entries.map(([k2, v2]) => [k2, transform(v2)]);
    return Object.fromEntries(transformedEntries);
  }
  function analyzePasswordInput(control, context) {
    const autocomplete = analyzeAutocomplete(control, {
      password: "password",
      currentPassword: "current-password",
      newPassword: "new-password",
      code: "one-time-code"
    });
    const attributeHeuristics = {
      password: passwordPatternMatcher.testAttributes(control),
      currentPassword: currentPasswordPatternMatcher.testAttributes(control),
      newPassword: newPasswordPatternMatcher.testAttributes(control),
      repeatPassword: repeatPasswordPatternMatcher.testAttributes(control),
      code: codePatternMatcher.testAttributes(control),
      // CVC fields are sometimes of type password
      cvc: cvcPatternMatcher.testAttributes(control)
    };
    return {
      control,
      visible: context.isVisible(control),
      autocomplete,
      attributeHeuristics
    };
  }
  function analyzeCheckboxInput(control, context) {
    const attributeHeuristics = {
      stayLoggedIn: stayLoggedInPatternMatcher.testAttributes(control)
    };
    return {
      control,
      visible: context.isVisible(control),
      attributeHeuristics
    };
  }
  function analyzeFormControl(control, context) {
    return {
      control,
      visible: context.isVisible(control),
      readOnly: "readOnly" in control ? control.readOnly : false
    };
  }
  function analyzeGroupContainer(container, context) {
    const attributeHeuristics = {
      login: loginPatternMatcher.testAttributes(container),
      registration: registrationPatternMatcher.testAttributes(container),
      newsletter: newsletterPatternMatcher.testAttributes(container)
    };
    return {
      container,
      visible: context.isVisible(container),
      formElement: container instanceof HTMLFormElement,
      attributeHeuristics
    };
  }
  function analyzeHiddenInput(control) {
    const attributeHeuristics = {
      stayLoggedIn: stayLoggedInPatternMatcher.testAttributes(control)
    };
    return {
      control,
      attributeHeuristics
    };
  }
  function isTextInput(control) {
    return control instanceof HTMLInputElement && (control.type === "text" || control.type === "email" || control.type === "tel" || control.type === "number");
  }
  function analyzeTextInput(control, context) {
    const autocomplete = analyzeAutocomplete(control, {
      username: "username",
      totp: "one-time-code"
    });
    const attributeHeuristics = {
      username: usernamePatternMatcher.testAttributes(control),
      totp: totpPatternMatcher.testAttributes(control),
      search: searchPatternMatcher.testAttributes(control),
      newsletter: newsletterPatternMatcher.testAttributes(control),
      postal: postalPatternMatcher.testAttributes(control),
      coupon: couponPatternMatcher.testAttributes(control),
      cvc: cvcPatternMatcher.testAttributes(control)
    };
    return {
      control,
      visible: context.isVisible(control),
      readOnly: control.readOnly,
      disabled: control.disabled,
      empty: control.value === "",
      autocomplete,
      attributeHeuristics
    };
  }
  var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function analyzeFormControlGroup(group, context) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield context.checkCancel();
      const groupContainer = analyzeGroupContainer(group.container, context);
      const passwordInputs = [];
      const textInputs = [];
      const checkboxInputs = [];
      const hiddenInputs = [];
      const restControls = [];
      for (const control of group.controls) {
        yield context.checkCancel();
        if (control instanceof HTMLInputElement && control.type === "password") {
          passwordInputs.push(analyzePasswordInput(control, context));
        } else if (isTextInput(control)) {
          textInputs.push(analyzeTextInput(control, context));
        } else if (control instanceof HTMLInputElement && control.type === "checkbox") {
          checkboxInputs.push(analyzeCheckboxInput(control, context));
        } else if (control instanceof HTMLInputElement && control.type === "hidden") {
          hiddenInputs.push(analyzeHiddenInput(control));
        } else {
          restControls.push(analyzeFormControl(control, context));
        }
      }
      return {
        groupContainer,
        passwordInputs,
        textInputs,
        checkboxInputs,
        hiddenInputs,
        restControls
      };
    });
  }
  const MATCH_THRESHOLD = 0.3;
  const USERNAME_AUTOCOMPLETE_MATCH = 1;
  const USERNAME_HEURISTIC_MATCH = 0.8;
  const USERNAME_TYPE_EMAIL_MATCH = 0.7;
  const USERNAME_FALLBACK_MATCH = 0.4;
  const PASSWORD_AUTOCOMPLETE_MATCH = 1;
  const PASSWORD_HEURISTIC_USAGE_MATCH = 0.9;
  const PASSWORD_HEURISTIC_TYPE_MATCH = 0.8;
  const PASSWORD_TYPE_MATCH = 0.7;
  const PASSWORD_AUTOCOMPLETE_CURRENT_FOR_REGISTRATION_MATCH = 0.1;
  const TOTP_AUTOCOMPLETE_MATCH = 1;
  const TOTP_HEURISTIC_TYPE_MATCH = 0.6;
  const TOTP_TYPE_MATCH = 0.1;
  const ELEMENTS_MATCH_BONUS = 0.2;
  const URL_MATCH_BONUS = 0.4;
  const STAY_LOGGED_IN_BONUS = 0.2;
  const LOGIN_NO_USERNAME_MATCH = 0.5;
  const LOGIN_NO_PASSWORD_MATCH = 0.35;
  const LOGIN_TOTP_IN_TWO_STEP_PENALTY = 0.2;
  const LOGIN_UNUSED_CONTROL_MATCH_PENALTY_FACTOR = 0.1;
  const LOGIN_UNUSED_CONTROL_MATCH_PENALTY_MAX = 0.5;
  const REGISTRATION_NO_USERNAME_MATCH = 0.2;
  const MAX_FORM_CONTROL_WITHOUT_FORM_DISTANCE = 800;
  var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function getFormControlGroups(context) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return (yield getGroupedFormControls(context)).map(createFormControlGroup);
    });
  }
  function getGroupedFormControls(context) {
    var _a3;
    return __awaiter$3(this, void 0, void 0, function* () {
      const formControls = querySelectorAllWithShadowRoots("button, input, select, textarea");
      const groupedControls = [];
      const groupsByForm = /* @__PURE__ */ new Map();
      let controlsBetweenForms = [];
      for (const control of formControls) {
        const form = (_a3 = control.form) !== null && _a3 !== void 0 ? _a3 : void 0;
        if (form && groupsByForm.has(form)) {
          groupsByForm.get(form).push(control);
        } else if (form) {
          if (controlsBetweenForms.length) {
            const newGroups = yield processControlsBetweenForms(controlsBetweenForms, context);
            groupedControls.push(...newGroups);
            controlsBetweenForms = [];
          }
          const controls = [control];
          groupsByForm.set(form, controls);
          groupedControls.push(controls);
        } else {
          controlsBetweenForms.push(control);
        }
      }
      if (controlsBetweenForms.length) {
        const newGroups = yield processControlsBetweenForms(controlsBetweenForms, context);
        groupedControls.push(...newGroups);
      }
      return groupedControls;
    });
  }
  function createFormControlGroup(controls) {
    var _a3;
    return {
      container: (_a3 = controls[0].form) !== null && _a3 !== void 0 ? _a3 : getCommonAncestor(...controls),
      controls
    };
  }
  function processControlsBetweenForms(allControlsBetweenForms, context) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const controlsBetweenForms = yield context.cancelableFilter(allControlsBetweenForms, (el2) => context.isVisible(el2));
      if (!controlsBetweenForms.length) {
        return [];
      }
      return splitFormControlsWithTooLargeDistance(controlsBetweenForms);
    });
  }
  function splitFormControlsWithTooLargeDistance(controlsBetweenForms) {
    const tooLargeDistancePairIndex = getTooLargeDistancePairIndex(controlsBetweenForms);
    if (tooLargeDistancePairIndex === void 0) {
      return [controlsBetweenForms];
    }
    const left = controlsBetweenForms.slice(0, tooLargeDistancePairIndex);
    const right = controlsBetweenForms.slice(tooLargeDistancePairIndex);
    return [left, ...splitFormControlsWithTooLargeDistance(right)];
  }
  function getTooLargeDistancePairIndex(controlsBetweenForms) {
    for (let i2 = 2; i2 < controlsBetweenForms.length; i2 += 1) {
      const first = controlsBetweenForms[i2 - 1];
      const second = controlsBetweenForms[i2];
      const distance = manhattanDistance(first, second);
      if (distance > MAX_FORM_CONTROL_WITHOUT_FORM_DISTANCE) {
        return i2;
      }
    }
    return void 0;
  }
  function manhattanDistance(first, second) {
    const { top: top1, left: left1 } = getCenterPoint(first);
    const { top: top2, left: left2 } = getCenterPoint(second);
    return Math.max(Math.abs(left1 - left2), Math.abs(top1 - top2));
  }
  function getCenterPoint(control) {
    const { left, top, height, width } = control.getBoundingClientRect();
    return { left: left + width / 2, top: top + height / 2 };
  }
  function getElement(result2) {
    return result2.state === "foundMatching" ? result2.element : null;
  }
  function getElementsMatchModifier(containerElement, elements, positivePatterns, negativePatterns) {
    const innerEls = Object.values(elements).flatMap((el2) => el2 === null || el2 === containerElement ? [] : el2);
    const positive = testPatterns(containerElement, innerEls, positivePatterns);
    const negative = testPatterns(containerElement, innerEls, negativePatterns);
    if (positive && !negative) {
      return ELEMENTS_MATCH_BONUS;
    }
    if (!positive && negative) {
      return -ELEMENTS_MATCH_BONUS;
    }
    return 0;
  }
  function testPatterns(containerElement, innerElements, positivePatterns) {
    if (positivePatterns.some((p2) => p2.testAttributes(containerElement))) {
      return true;
    }
    return innerElements.some((el2) => positivePatterns.some((p2) => p2.testText(el2) || p2.testAttributes(el2)));
  }
  function getStayLoggedInElement(formControlGroup) {
    const byHeuristics = [...formControlGroup.checkboxInputs, ...formControlGroup.hiddenInputs].find((ci2) => ci2.attributeHeuristics.stayLoggedIn);
    if (byHeuristics) {
      return byHeuristics.control;
    }
    return null;
  }
  function getStayLoggedInModifier(formControlGroup, isPositive) {
    const hasStayLoggedInElement = getStayLoggedInElement(formControlGroup);
    return hasStayLoggedInElement ? (isPositive ? 1 : -1) * STAY_LOGGED_IN_BONUS : 0;
  }
  function getCandidatesFulfillingMostConditions(candidates, ...conditions) {
    let result2 = [];
    let maxFulfilledCount = 0;
    for (const el2 of candidates) {
      const fulfilledCount = conditions.reduce((total, cond) => cond(el2) ? total + 1 : total, 0);
      if (fulfilledCount > maxFulfilledCount) {
        maxFulfilledCount = fulfilledCount;
        result2 = [el2];
      } else if (fulfilledCount === maxFulfilledCount) {
        result2.push(el2);
      }
    }
    return result2;
  }
  function pickClosest(source, elements, container) {
    let cur = source;
    while (cur !== container) {
      const contained = elements.find((el2) => cur.contains(el2));
      if (contained) {
        return contained;
      }
      if (!cur.parentElement) {
        break;
      }
      cur = cur.parentElement;
    }
    return elements[0];
  }
  function getSubmitElement(passwordOrUsernameElement, formControlGroup) {
    if (formControlGroup.groupContainer.container instanceof HTMLFormElement) {
      const formDefaultButton = getFormDefaultButton(formControlGroup.groupContainer.container);
      if (formDefaultButton) {
        return formDefaultButton;
      }
      const likelyCandidates = getButtonCandidates(formControlGroup).filter((c2) => submitPatternMatcher.testAttributes(c2) || submitPatternMatcher.testText(c2));
      if (!likelyCandidates.length) {
        return null;
      }
      if (likelyCandidates.length === 1) {
        return likelyCandidates[0];
      }
      const moreLikelyCandidates = likelyCandidates.filter((c2) => !socialLoginPatternMatcher.testText(c2));
      return pickClosest(passwordOrUsernameElement, moreLikelyCandidates.length ? moreLikelyCandidates : likelyCandidates, formControlGroup.groupContainer.container);
    }
    const submitElement = getSubmitElementWithNoForm(passwordOrUsernameElement, formControlGroup);
    return submitElement;
  }
  function getSubmitElementWithNoForm(passwordOrUsernameElement, formControlGroup) {
    const allCandidates = getButtonCandidates(formControlGroup, true);
    if (!allCandidates.length) {
      return null;
    }
    if (allCandidates.length === 1) {
      return allCandidates[0];
    }
    const mostLikelyCandidates = getCandidatesFulfillingMostConditions(allCandidates, (c2) => submitPatternMatcher.testAttributes(c2) || submitPatternMatcher.testText(c2), (c2) => !socialLoginPatternMatcher.testText(c2), (c2) => !cancelLoginPatternMatcher.testAttributes(c2) && !cancelLoginPatternMatcher.testText(c2), (c2) => !c2.disabled);
    if (mostLikelyCandidates.length === 1) {
      return mostLikelyCandidates[0];
    }
    return pickClosest(passwordOrUsernameElement, mostLikelyCandidates, formControlGroup.groupContainer.container);
  }
  function getButtonCandidates(formControlGroup, includeDisabled = false) {
    return formControlGroup.restControls.filter((rc2) => (!rc2.control.disabled || includeDisabled) && rc2.visible && (rc2.control.type === "submit" || rc2.control.type === "button" || rc2.control.type === "image")).map((rc2) => rc2.control).filter(isButton);
  }
  function isButton(control) {
    return control instanceof HTMLInputElement || control instanceof HTMLButtonElement;
  }
  function getUsernameResult(textInputAnalyses, passwordElement, container) {
    const candidates = textInputAnalyses.filter((tia) => tia.visible && !tia.control.disabled && !tia.attributeHeuristics.search && !tia.attributeHeuristics.newsletter);
    const byAutocomplete = pickFromCandidates({
      candidates: candidates.filter((tea) => {
        var _a3;
        return (_a3 = tea.autocomplete) === null || _a3 === void 0 ? void 0 : _a3.username;
      }),
      passwordElement,
      container,
      match: USERNAME_AUTOCOMPLETE_MATCH
    });
    if (byAutocomplete.state === "foundMatching") {
      return byAutocomplete;
    }
    const byHeuristics = pickFromCandidates({
      candidates: candidates.filter((tea) => tea.attributeHeuristics.username),
      passwordElement,
      container,
      match: USERNAME_HEURISTIC_MATCH
    });
    if (byHeuristics.state === "foundMatching") {
      return byHeuristics;
    }
    const byTypeEmail = pickFromCandidates({
      candidates: candidates.filter((tea) => tea.control.type === "email"),
      passwordElement,
      container,
      match: USERNAME_TYPE_EMAIL_MATCH
    });
    if (byTypeEmail.state === "foundMatching") {
      return byTypeEmail;
    }
    return pickFromCandidates({
      candidates,
      passwordElement,
      container,
      match: USERNAME_FALLBACK_MATCH
    });
  }
  function pickFromCandidates({ candidates, passwordElement, container, match: match2 }) {
    if (candidates.length > 1 && passwordElement) {
      return {
        state: "foundMatching",
        element: pickClosest(passwordElement, candidates.map((ba2) => ba2.control), container),
        match: match2
      };
    }
    if (candidates.length >= 1) {
      return {
        state: "foundMatching",
        element: candidates[0].control,
        match: match2
      };
    }
    return { state: "notFound" };
  }
  function getLoginFormElements(formControlGroup) {
    const relElements = getRelevantFormElements(formControlGroup);
    if (!relElements || relElements.match === void 0) {
      return {
        elements: null,
        match: 0
      };
    }
    const elements = Object.assign(Object.assign({ containerElement: formControlGroup.groupContainer.container }, relElements.elements), completeElementsFromPrimaryElement(getPrimaryElement(relElements.elements), formControlGroup));
    const containerMatchModifier = getElementsMatchModifier(elements.containerElement, elements, [loginPatternMatcher], [registrationPatternMatcher, newsletterPatternMatcher]);
    const stayLoggedInModifier = getStayLoggedInModifier(formControlGroup, true);
    return {
      elements,
      match: additionalElementsPenalty(relElements.match, formControlGroup, elements) + containerMatchModifier + stayLoggedInModifier
    };
  }
  function getRelevantFormElements(formControlGroup) {
    var _a3;
    const passwordResult = getPasswordResult$1(formControlGroup.passwordInputs);
    const hiddenPasswordResult = getPasswordResult$1(formControlGroup.passwordInputs, false);
    const totpResult = getTotpResult(formControlGroup.textInputs);
    const usernameResult = getUsernameResult(formControlGroup.textInputs, (_a3 = getElement(passwordResult)) !== null && _a3 !== void 0 ? _a3 : getElement(hiddenPasswordResult), formControlGroup.groupContainer.container);
    if (passwordResult.state === "foundNotMatching") {
      return null;
    }
    const candidatePrimaryElements = [];
    if (passwordResult.state !== "notFound" && usernameResult) {
      const { element: passwordElement, match: passwordMatch } = passwordResult;
      const { element: usernameElement, match: usernameMatch } = usernameResult.state === "foundMatching" ? usernameResult : {
        element: null,
        match: LOGIN_NO_USERNAME_MATCH
      };
      const totpElements = totpResult.state === "foundMatching" && // we require at least a heuristic match here, to avoid dragging in a random text input
      totpResult.match >= TOTP_HEURISTIC_TYPE_MATCH && totpResult.element !== usernameElement && totpResult.element !== passwordElement ? totpResult.element : null;
      candidatePrimaryElements.push({
        elements: {
          passwordElement,
          usernameElement,
          totpElements
        },
        match: passwordMatch * usernameMatch
      });
    }
    if (hiddenPasswordResult.state === "foundMatching" && usernameResult.state === "foundMatching") {
      const { match: passwordMatch } = hiddenPasswordResult;
      const { element: usernameElement, match: usernameMatch } = usernameResult;
      const totpPenalty = totpResult.state === "foundMatching" && totpResult.match >= TOTP_HEURISTIC_TYPE_MATCH ? LOGIN_TOTP_IN_TWO_STEP_PENALTY : 0;
      candidatePrimaryElements.push({
        elements: {
          passwordElement: null,
          usernameElement,
          totpElements: null
        },
        match: passwordMatch * usernameMatch - totpPenalty
      });
    }
    if (usernameResult.state === "foundMatching") {
      const { element: usernameElement, match: usernameMatch } = usernameResult;
      candidatePrimaryElements.push({
        elements: {
          passwordElement: null,
          usernameElement,
          totpElements: null
        },
        match: usernameMatch * LOGIN_NO_PASSWORD_MATCH
      });
    }
    if (totpResult.state === "foundMatching" && passwordResult.state !== "foundMatching") {
      const { element: totpElements, match: totpMatch } = totpResult;
      candidatePrimaryElements.push({
        elements: {
          passwordElement: null,
          usernameElement: null,
          totpElements
        },
        match: totpMatch
      });
    }
    if (candidatePrimaryElements.length === 0) {
      return null;
    }
    candidatePrimaryElements.sort((a, b2) => b2.match - a.match);
    return candidatePrimaryElements[0];
  }
  function getPasswordResult$1(passwordInputAnalyses, visible = true) {
    var _a3, _b;
    const candidates = passwordInputAnalyses.filter((pa2) => pa2.visible === visible && !pa2.control.disabled && !pa2.attributeHeuristics.code && !pa2.attributeHeuristics.cvc);
    if (candidates.length === 1) {
      const candidate = candidates[0];
      let match2;
      if (((_a3 = candidate.autocomplete) === null || _a3 === void 0 ? void 0 : _a3.password) || ((_b = candidate.autocomplete) === null || _b === void 0 ? void 0 : _b.currentPassword)) {
        match2 = PASSWORD_AUTOCOMPLETE_MATCH;
      } else if (candidate.attributeHeuristics.password) {
        match2 = PASSWORD_HEURISTIC_TYPE_MATCH;
      } else {
        match2 = PASSWORD_TYPE_MATCH;
      }
      return {
        state: "foundMatching",
        element: candidate.control,
        match: match2
      };
    }
    if (candidates.length > 1) {
      return {
        state: "foundNotMatching"
      };
    }
    return { state: "notFound" };
  }
  function getTotpResult(textInputsAnalyses) {
    const candidates = textInputsAnalyses.flatMap((tia) => {
      var _a3;
      if (!tia.visible || !tia.empty || tia.readOnly || tia.disabled || tia.attributeHeuristics.search || tia.attributeHeuristics.newsletter || tia.attributeHeuristics.postal || tia.attributeHeuristics.coupon || tia.attributeHeuristics.cvc) {
        return [];
      }
      let match2;
      if ((_a3 = tia.autocomplete) === null || _a3 === void 0 ? void 0 : _a3.totp) {
        match2 = TOTP_AUTOCOMPLETE_MATCH;
      } else if (tia.attributeHeuristics.totp) {
        match2 = TOTP_HEURISTIC_TYPE_MATCH;
      } else {
        match2 = TOTP_TYPE_MATCH;
      }
      return Object.assign(Object.assign({}, tia), { match: match2 });
    });
    if (candidates.length === 6) {
      const element = candidates.map((c2) => c2.control);
      const yPositions = element.map((el2) => el2.getBoundingClientRect().y);
      const isVerticallyAligned = yPositions.every((yPos) => yPos === yPositions[0]);
      return {
        state: "foundMatching",
        element,
        match: isVerticallyAligned ? TOTP_HEURISTIC_TYPE_MATCH : Math.pow(candidates.reduce((acc, c2) => acc * c2.match, 1), 1 / 6)
      };
    }
    if (candidates.length >= 1) {
      const candidate = candidates.sort((a, b2) => b2.match - a.match)[0];
      return {
        state: "foundMatching",
        element: candidate.control,
        match: candidate.match
      };
    }
    return { state: "notFound" };
  }
  function getPrimaryElement(relElements) {
    if (relElements.passwordElement) {
      return relElements.passwordElement;
    }
    if (relElements.usernameElement) {
      return relElements.usernameElement;
    }
    const { totpElements } = relElements;
    return Array.isArray(totpElements) ? totpElements[0] : totpElements;
  }
  function completeElementsFromPrimaryElement(passwordOrUsernameElement, formControlGroup) {
    const submitElement = getSubmitElement(passwordOrUsernameElement, formControlGroup);
    const stayLoggedInElement = getStayLoggedInElement(formControlGroup);
    const formElement = formControlGroup.groupContainer.container instanceof HTMLFormElement ? formControlGroup.groupContainer.container : null;
    return { formElement, submitElement, stayLoggedInElement };
  }
  const IGNORED_PENALTY_CONTROL_TYPES = /* @__PURE__ */ new Set([
    "button",
    "submit",
    "reset",
    "image"
  ]);
  function additionalElementsPenalty(match2, formControlGroup, elements) {
    const detectedControls = new Set(Object.values(elements).flat());
    const unusedVisibleControls = [
      ...formControlGroup.textInputs.filter(({ attributeHeuristics, readOnly }) => !attributeHeuristics.newsletter && !attributeHeuristics.search && !readOnly),
      ...formControlGroup.restControls.filter(({ control, readOnly }) => !IGNORED_PENALTY_CONTROL_TYPES.has(control.type) && !readOnly),
      ...formControlGroup.checkboxInputs
    ].filter((analysis) => analysis.visible && !detectedControls.has(analysis.control));
    const penalty2 = Math.min(unusedVisibleControls.length * LOGIN_UNUSED_CONTROL_MATCH_PENALTY_FACTOR, LOGIN_UNUSED_CONTROL_MATCH_PENALTY_MAX);
    return match2 - penalty2;
  }
  function getRegistrationFormElements(formControlGroup) {
    const usernameAndPassword = getUsernameAndPasswords(formControlGroup);
    if (!usernameAndPassword) {
      return {
        elements: null,
        match: 0
      };
    }
    const submitElement = getSubmitElement(usernameAndPassword.elements.passwordElement, formControlGroup);
    const formElement = formControlGroup.groupContainer.container instanceof HTMLFormElement ? formControlGroup.groupContainer.container : null;
    const elements = Object.assign(Object.assign({ containerElement: formControlGroup.groupContainer.container }, usernameAndPassword.elements), {
      submitElement,
      formElement
    });
    const containerMatchModifier = getElementsMatchModifier(elements.containerElement, elements, [registrationPatternMatcher], [loginPatternMatcher, newsletterPatternMatcher]);
    const stayLoggedInModifier = getStayLoggedInModifier(formControlGroup, false);
    return {
      elements,
      match: usernameAndPassword.match + containerMatchModifier + stayLoggedInModifier
    };
  }
  function getUsernameAndPasswords(formControlGroup) {
    const passwordResult = getPasswordResult(formControlGroup.passwordInputs);
    if (passwordResult.state !== "foundMatching") {
      return null;
    }
    const { element: { passwordElement, repeatPasswordElement }, match: passwordMatch } = passwordResult;
    const usernameResult = getUsernameResult(formControlGroup.textInputs, passwordElement, formControlGroup.groupContainer.container);
    if (usernameResult.state === "foundMatching") {
      const { element: usernameElement, match: usernameMatch } = usernameResult;
      return {
        elements: {
          usernameElement,
          passwordElement,
          repeatPasswordElement
        },
        match: passwordMatch * usernameMatch
      };
    }
    return {
      elements: {
        usernameElement: null,
        passwordElement,
        repeatPasswordElement
      },
      match: passwordMatch * REGISTRATION_NO_USERNAME_MATCH
    };
  }
  function getPasswordResult(passwordInputAnalyses) {
    var _a3, _b, _c2, _d, _e;
    const candidates = passwordInputAnalyses.filter((pa2) => pa2.visible && !pa2.control.disabled && !pa2.attributeHeuristics.code && !pa2.attributeHeuristics.cvc);
    const extraRepeatCandidates = passwordInputAnalyses.filter((pa2) => pa2.visible && pa2.control.disabled && !pa2.attributeHeuristics.code && !pa2.attributeHeuristics.cvc);
    if (candidates.length === 2 || candidates.length === 1 && extraRepeatCandidates.length === 1) {
      let candidate1, candidate2;
      if (candidates.length === 2) {
        [candidate1, candidate2] = candidates;
      } else {
        candidate1 = candidates[0];
        candidate2 = extraRepeatCandidates[0];
      }
      if (((_a3 = candidate1.autocomplete) === null || _a3 === void 0 ? void 0 : _a3.currentPassword) || candidate1.attributeHeuristics.currentPassword) {
        return {
          state: "foundNotMatching"
        };
      }
      let match2;
      if ((_b = candidate1.autocomplete) === null || _b === void 0 ? void 0 : _b.newPassword) {
        match2 = PASSWORD_AUTOCOMPLETE_MATCH;
      } else if (candidate1.attributeHeuristics.password && candidate1.attributeHeuristics.newPassword) {
        match2 = PASSWORD_HEURISTIC_USAGE_MATCH;
      } else if (candidate1.attributeHeuristics.password) {
        match2 = PASSWORD_HEURISTIC_TYPE_MATCH;
      } else {
        match2 = PASSWORD_TYPE_MATCH;
      }
      if ((_c2 = candidate2.autocomplete) === null || _c2 === void 0 ? void 0 : _c2.newPassword) {
        match2 *= PASSWORD_AUTOCOMPLETE_MATCH;
      } else if (candidate2.attributeHeuristics.password && candidate2.attributeHeuristics.repeatPassword) {
        match2 = PASSWORD_HEURISTIC_USAGE_MATCH;
      } else if (candidate2.attributeHeuristics.password) {
        match2 = PASSWORD_HEURISTIC_TYPE_MATCH;
      } else {
        match2 = PASSWORD_TYPE_MATCH;
      }
      return {
        state: "foundMatching",
        element: {
          passwordElement: candidate1.control,
          repeatPasswordElement: candidate2.control
        },
        // compensate for multiplying two match values
        match: Math.pow(match2, 0.5)
      };
    }
    if (candidates.length === 1) {
      const candidate = candidates[0];
      let match2;
      if (((_d = candidate.autocomplete) === null || _d === void 0 ? void 0 : _d.currentPassword) || candidate.attributeHeuristics.currentPassword) {
        match2 = PASSWORD_AUTOCOMPLETE_CURRENT_FOR_REGISTRATION_MATCH;
      } else if ((_e = candidate.autocomplete) === null || _e === void 0 ? void 0 : _e.newPassword) {
        match2 = PASSWORD_AUTOCOMPLETE_MATCH;
      } else if (candidate.attributeHeuristics.password && candidate.attributeHeuristics.newPassword) {
        match2 = PASSWORD_HEURISTIC_USAGE_MATCH;
      } else if (candidate.attributeHeuristics.password) {
        match2 = PASSWORD_HEURISTIC_TYPE_MATCH;
      } else {
        match2 = PASSWORD_TYPE_MATCH;
      }
      return {
        state: "foundMatching",
        element: {
          passwordElement: candidate.control,
          repeatPasswordElement: null
        },
        match: match2
      };
    }
    if (candidates.length > 2) {
      return {
        state: "foundNotMatching"
      };
    }
    return { state: "notFound" };
  }
  class PredicateEvaluator {
    constructor(context) {
      this.context = context;
      this.evaluationsFns = {
        all: (p2) => p2.predicates.every((c2) => this.evaluate(c2)),
        atLeastOne: (p2) => p2.predicates.some((c2) => this.evaluate(c2)),
        elementExists: (p2) => {
          let element;
          try {
            element = document.querySelector(p2.selector);
          } catch (e2) {
            return false;
          }
          return !!element && (!p2.requireVisible || this.context.isVisible(element));
        }
      };
    }
    evaluate(predicate) {
      if (!predicate) {
        return true;
      }
      const evaluator = this.evaluationsFns[predicate.type];
      const result2 = evaluator(predicate);
      return predicate.negated ? !result2 : result2;
    }
  }
  const useDefaultDetection = Symbol("useDefaultDetection");
  function getOverrides({ overrideLibrary, hostname, context }) {
    const predicateEvaluator = new PredicateEvaluator(context);
    const overrideIndex = overrideLibrary.findIndex((webpageOverride) => {
      const hostnameMatch = !("hostnameContains" in webpageOverride) || hostname.includes(webpageOverride.hostnameContains);
      const predicateMatch = !("predicate" in webpageOverride) || predicateEvaluator.evaluate(webpageOverride.predicate);
      return hostnameMatch && predicateMatch;
    });
    if (overrideIndex === -1) {
      return {
        loginOverride: void 0,
        registrationOverride: void 0,
        appliedOverride: void 0
      };
    }
    const override = overrideLibrary[overrideIndex];
    let loginOverride;
    let registrationOverride;
    let loginRuleIndex = void 0;
    let registrationRuleIndex = void 0;
    for (const [i2, rule] of override.rules.entries()) {
      if (!predicateEvaluator.evaluate(rule.predicate)) {
        continue;
      }
      const oldLoginOverride = loginOverride;
      const oldRegistrationOverride = registrationOverride;
      if (rule.type === "loginForm" && loginOverride === void 0) {
        loginOverride = notFoundToUndefined(rule.selectors, getLoginFormElementsFromSelectors);
      } else if (rule.type === "registrationForm" && registrationOverride === void 0) {
        registrationOverride = notFoundToUndefined(rule.selectors, getRegistrationFormElementsFromSelectors);
      } else if (rule.type === "noForm") {
        loginOverride = null;
        registrationOverride = null;
      } else if (rule.type === "formKindHint") {
        if (rule.kind === "login") {
          loginOverride = useDefaultDetection;
          registrationOverride = registrationOverride === void 0 ? null : registrationOverride;
        } else if (rule.kind === "registration") {
          loginOverride = loginOverride === void 0 ? null : loginOverride;
          registrationOverride = useDefaultDetection;
        }
      }
      if (oldLoginOverride !== loginOverride) {
        loginRuleIndex = i2;
      }
      if (oldRegistrationOverride !== registrationOverride) {
        registrationRuleIndex = i2;
      }
      if (loginOverride !== void 0 && registrationOverride !== void 0) {
        break;
      }
    }
    return {
      loginOverride: loginOverride === useDefaultDetection ? void 0 : loginOverride,
      registrationOverride: registrationOverride === useDefaultDetection ? void 0 : registrationOverride,
      appliedOverride: {
        override,
        ruleIndexes: [.../* @__PURE__ */ new Set([loginRuleIndex, registrationRuleIndex])].sort().filter((i2) => i2 !== void 0)
      }
    };
  }
  class NotFoundError extends Error {
  }
  function notFoundToUndefined(formOverride, getElementsFromSelectors) {
    try {
      return getElementsFromSelectors(formOverride);
    } catch (e2) {
      if (e2 instanceof NotFoundError) {
        return void 0;
      }
      throw e2;
    }
  }
  function getLoginFormElementsFromSelectors(lfes) {
    if (!lfes) {
      return null;
    }
    const elements = {
      usernameElement: querySelectorOrNull(lfes.usernameElement),
      passwordElement: querySelectorOrNull(lfes.passwordElement),
      totpElements: querySelectorsOrNull(lfes.totpElements),
      formElement: querySelectorOrNull(lfes.formElement),
      submitElement: querySelectorOrNull(lfes.submitElement),
      stayLoggedInElement: querySelectorOrNull(lfes.stayLoggedInElement)
    };
    return Object.assign(Object.assign({}, elements), { containerElement: getContainerElement(elements) });
  }
  function getRegistrationFormElementsFromSelectors(rfes) {
    if (!rfes) {
      return null;
    }
    const elements = {
      passwordElement: querySelectorOrNull(rfes.passwordElement),
      repeatPasswordElement: querySelectorOrNull(rfes.repeatPasswordElement),
      formElement: querySelectorOrNull(rfes.formElement),
      usernameElement: querySelectorOrNull(rfes.usernameElement),
      submitElement: querySelectorOrNull(rfes.submitElement)
    };
    return Object.assign(Object.assign({}, elements), { containerElement: getContainerElement(elements) });
  }
  function getContainerElement(elements) {
    if (elements.formElement) {
      return elements.formElement;
    }
    const elementList = Object.values(elements).filter((v2) => v2 !== null);
    if (elementList.length) {
      return getCommonAncestor(...elementList);
    }
    return document.documentElement;
  }
  function querySelectorOrNull(selector2) {
    if (selector2 === null) {
      return null;
    }
    let el2;
    try {
      el2 = querySelectorWithShadowRoots(selector2);
    } catch (e2) {
      throw new NotFoundError();
    }
    if (el2 === void 0) {
      throw new NotFoundError();
    }
    return el2;
  }
  function querySelectorsOrNull(selector2) {
    if (Array.isArray(selector2)) {
      return selector2.map((sel) => querySelectorOrNull(sel));
    }
    return querySelectorOrNull(selector2);
  }
  var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function detectForms(context) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const { loginOverride, registrationOverride, appliedOverride } = getOverrides({
        overrideLibrary: context.overrideLibrary,
        hostname: window.location.hostname,
        context
      });
      if (loginOverride !== void 0 && registrationOverride !== void 0) {
        return {
          login: loginOverride,
          registration: registrationOverride,
          appliedOverride
        };
      }
      const allFormControlGroups = yield getFormControlGroups(context);
      const overrideElements = /* @__PURE__ */ new Set([
        ...loginOverride ? Object.values(loginOverride) : [],
        ...registrationOverride ? Object.values(registrationOverride) : []
      ]);
      const formControlGroups = allFormControlGroups.filter((group) => !group.controls.some((control) => overrideElements.has(control)));
      const formControlGroupAnalyses = yield Promise.all(formControlGroups.map((group) => analyzeFormControlGroup(group, context)));
      const { loginForms } = getLoginForms(formControlGroupAnalyses);
      const { registrationForms } = getRegistrationForms(formControlGroupAnalyses);
      yield context.checkCancel();
      const allForms = [...loginForms, ...registrationForms].sort(byMatch);
      let login = null;
      let loginAnalysis = null;
      let registration = null;
      let registrationAnalysis = null;
      for (const form of allForms) {
        if (form.type === "login" && loginOverride === void 0 && !login && form.analysis !== registrationAnalysis) {
          ({ elements: login, analysis: loginAnalysis } = form);
        } else if (form.type === "registration" && registrationOverride === void 0 && !registration && form.analysis !== loginAnalysis) {
          ({ elements: registration, analysis: registrationAnalysis } = form);
        }
      }
      return {
        login: loginOverride !== void 0 ? loginOverride : login,
        registration: registrationOverride !== void 0 ? registrationOverride : registration,
        appliedOverride
      };
    });
  }
  function getLoginForms(formControlGroupAnalyses) {
    const loginUrlMatchBonus = loginPatternMatcher.test(window.location.href) && !heyloginPatternMatcher.test(window.location.href) ? URL_MATCH_BONUS : 0;
    const allLoginForms = formControlGroupAnalyses.map((analysis) => {
      const { match: match2, elements } = getLoginFormElements(analysis);
      return {
        type: "login",
        analysis,
        match: match2 + loginUrlMatchBonus,
        elements
      };
    });
    const loginForms = allLoginForms.filter(({ match: match2 }) => match2 >= MATCH_THRESHOLD);
    return { loginForms, allLoginForms };
  }
  function getRegistrationForms(formControlGroupAnalyses) {
    const registrationUrlMatchBonus = registrationPatternMatcher.test(window.location.href) ? URL_MATCH_BONUS : 0;
    const allRegistrationForms = formControlGroupAnalyses.map((analysis) => {
      const { match: match2, elements } = getRegistrationFormElements(analysis);
      return {
        type: "registration",
        analysis,
        match: match2 + registrationUrlMatchBonus,
        elements
      };
    });
    const registrationForms = allRegistrationForms.filter(({ match: match2 }) => match2 >= MATCH_THRESHOLD);
    return { registrationForms, allRegistrationForms };
  }
  function byMatch({ match: l2 }, { match: r2 }) {
    return r2 - l2;
  }
  var Limit;
  (function(Limit2) {
    Limit2[Limit2["All"] = 0] = "All";
    Limit2[Limit2["Two"] = 1] = "Two";
    Limit2[Limit2["One"] = 2] = "One";
  })(Limit || (Limit = {}));
  let config$1;
  let rootDocument;
  function finder(input, options) {
    if (input.nodeType !== Node.ELEMENT_NODE) {
      throw new Error(`Can't generate CSS selector for non-element node type.`);
    }
    if ("html" === input.tagName.toLowerCase()) {
      return "html";
    }
    const defaults = {
      root: document.body,
      idName: (name) => true,
      className: (name) => true,
      tagName: (name) => true,
      attr: (name, value) => false,
      seedMinLength: 1,
      optimizedMinLength: 2,
      threshold: 1e3,
      maxNumberOfTries: 1e4
    };
    config$1 = Object.assign(Object.assign({}, defaults), options);
    rootDocument = findRootDocument(config$1.root, defaults);
    let path = bottomUpSearch(input, Limit.All, () => bottomUpSearch(input, Limit.Two, () => bottomUpSearch(input, Limit.One)));
    if (path) {
      const optimized = sort(optimize(path, input));
      if (optimized.length > 0) {
        path = optimized[0];
      }
      return selector(path);
    } else {
      throw new Error(`Selector was not found.`);
    }
  }
  function findRootDocument(rootNode, defaults) {
    if (rootNode.nodeType === Node.DOCUMENT_NODE) {
      return rootNode;
    }
    if (rootNode === defaults.root) {
      return rootNode.ownerDocument;
    }
    return rootNode;
  }
  function bottomUpSearch(input, limit, fallback2) {
    let path = null;
    let stack = [];
    let current = input;
    let i2 = 0;
    while (current && current !== config$1.root.parentElement) {
      let level = maybe(id$1(current)) || maybe(...attr(current)) || maybe(...classNames(current)) || maybe(tagName(current)) || [any()];
      const nth = index$2(current);
      if (limit === Limit.All) {
        if (nth) {
          level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));
        }
      } else if (limit === Limit.Two) {
        level = level.slice(0, 1);
        if (nth) {
          level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));
        }
      } else if (limit === Limit.One) {
        const [node] = level = level.slice(0, 1);
        if (nth && dispensableNth(node)) {
          level = [nthChild(node, nth)];
        }
      }
      for (let node of level) {
        node.level = i2;
      }
      stack.push(level);
      if (stack.length >= config$1.seedMinLength) {
        path = findUniquePath(stack, fallback2);
        if (path) {
          break;
        }
      }
      current = current.parentElement;
      i2++;
    }
    if (!path) {
      path = findUniquePath(stack, fallback2);
    }
    return path;
  }
  function findUniquePath(stack, fallback2) {
    const paths = sort(combinations(stack));
    if (paths.length > config$1.threshold) {
      return fallback2 ? fallback2() : null;
    }
    for (let candidate of paths) {
      if (unique(candidate)) {
        return candidate;
      }
    }
    return null;
  }
  function selector(path) {
    let node = path[0];
    let query = node.name;
    for (let i2 = 1; i2 < path.length; i2++) {
      const level = path[i2].level || 0;
      if (node.level === level - 1) {
        query = `${path[i2].name} > ${query}`;
      } else {
        query = `${path[i2].name} ${query}`;
      }
      node = path[i2];
    }
    return query;
  }
  function penalty(path) {
    return path.map((node) => node.penalty).reduce((acc, i2) => acc + i2, 0);
  }
  function unique(path) {
    switch (rootDocument.querySelectorAll(selector(path)).length) {
      case 0:
        throw new Error(`Can't select any node with this selector: ${selector(path)}`);
      case 1:
        return true;
      default:
        return false;
    }
  }
  function id$1(input) {
    const elementId = input.getAttribute("id");
    if (elementId && config$1.idName(elementId)) {
      return {
        name: "#" + cssesc(elementId, { isIdentifier: true }),
        penalty: 0
      };
    }
    return null;
  }
  function attr(input) {
    const attrs = Array.from(input.attributes).filter((attr2) => config$1.attr(attr2.name, attr2.value));
    return attrs.map((attr2) => ({
      name: "[" + cssesc(attr2.name, { isIdentifier: true }) + '="' + cssesc(attr2.value) + '"]',
      penalty: 0.5
    }));
  }
  function classNames(input) {
    const names = Array.from(input.classList).filter(config$1.className);
    return names.map((name) => ({
      name: "." + cssesc(name, { isIdentifier: true }),
      penalty: 1
    }));
  }
  function tagName(input) {
    const name = input.tagName.toLowerCase();
    if (config$1.tagName(name)) {
      return {
        name,
        penalty: 2
      };
    }
    return null;
  }
  function any() {
    return {
      name: "*",
      penalty: 3
    };
  }
  function index$2(input) {
    const parent = input.parentNode;
    if (!parent) {
      return null;
    }
    let child = parent.firstChild;
    if (!child) {
      return null;
    }
    let i2 = 0;
    while (child) {
      if (child.nodeType === Node.ELEMENT_NODE) {
        i2++;
      }
      if (child === input) {
        break;
      }
      child = child.nextSibling;
    }
    return i2;
  }
  function nthChild(node, i2) {
    return {
      name: node.name + `:nth-child(${i2})`,
      penalty: node.penalty + 1
    };
  }
  function dispensableNth(node) {
    return node.name !== "html" && !node.name.startsWith("#");
  }
  function maybe(...level) {
    const list = level.filter(notEmpty);
    if (list.length > 0) {
      return list;
    }
    return null;
  }
  function notEmpty(value) {
    return value !== null && value !== void 0;
  }
  function* combinations(stack, path = []) {
    if (stack.length > 0) {
      for (let node of stack[0]) {
        yield* combinations(stack.slice(1, stack.length), path.concat(node));
      }
    } else {
      yield path;
    }
  }
  function sort(paths) {
    return Array.from(paths).sort((a, b2) => penalty(a) - penalty(b2));
  }
  function* optimize(path, input, scope = {
    counter: 0,
    visited: /* @__PURE__ */ new Map()
  }) {
    if (path.length > 2 && path.length > config$1.optimizedMinLength) {
      for (let i2 = 1; i2 < path.length - 1; i2++) {
        if (scope.counter > config$1.maxNumberOfTries) {
          return;
        }
        scope.counter += 1;
        const newPath = [...path];
        newPath.splice(i2, 1);
        const newPathKey = selector(newPath);
        if (scope.visited.has(newPathKey)) {
          return;
        }
        if (unique(newPath) && same(newPath, input)) {
          yield newPath;
          scope.visited.set(newPathKey, true);
          yield* optimize(newPath, input, scope);
        }
      }
    }
  }
  function same(path, input) {
    return rootDocument.querySelector(selector(path)) === input;
  }
  const regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
  const regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
  const regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
  const defaultOptions = {
    "escapeEverything": false,
    "isIdentifier": false,
    "quotes": "single",
    "wrap": false
  };
  function cssesc(string, opt = {}) {
    const options = Object.assign(Object.assign({}, defaultOptions), opt);
    if (options.quotes != "single" && options.quotes != "double") {
      options.quotes = "single";
    }
    const quote2 = options.quotes == "double" ? '"' : "'";
    const isIdentifier = options.isIdentifier;
    const firstChar = string.charAt(0);
    let output = "";
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const character = string.charAt(counter++);
      let codePoint = character.charCodeAt(0);
      let value = void 0;
      if (codePoint < 32 || codePoint > 126) {
        if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
          } else {
            counter--;
          }
        }
        value = "\\" + codePoint.toString(16).toUpperCase() + " ";
      } else {
        if (options.escapeEverything) {
          if (regexAnySingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          }
        } else if (/[\t\n\f\r\x0B]/.test(character)) {
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else if (character == "\\" || !isIdentifier && (character == '"' && quote2 == character || character == "'" && quote2 == character) || isIdentifier && regexSingleEscape.test(character)) {
          value = "\\" + character;
        } else {
          value = character;
        }
      }
      output += value;
    }
    if (isIdentifier) {
      if (/^-[-\d]/.test(output)) {
        output = "\\-" + output.slice(1);
      } else if (/\d/.test(firstChar)) {
        output = "\\3" + firstChar + " " + output.slice(1);
      }
    }
    output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
      if ($1 && $1.length % 2) {
        return $0;
      }
      return ($1 || "") + $2;
    });
    if (!isIdentifier && options.wrap) {
      return quote2 + output + quote2;
    }
    return output;
  }
  var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class DetectFormsCanceled extends Error {
  }
  class DetectFormsContext {
    constructor(overrideLibrary) {
      this.overrideLibrary = overrideLibrary;
      this.canceled = false;
      this.lastCheckCancelTimestamp = 0;
      this.isVisibleCache = /* @__PURE__ */ new Map();
    }
    cancel() {
      this.canceled = true;
    }
    /**
     * Yields to the event loop and then checks if this context has been canceled and throws an
     * exception if that's the case.
     *
     * This should be called regularly during form detection, such that the logic is broken up into
     * roughly 1 frame (16ms) long chunks. Usage hints:
     *
     * - Call between the major steps of detection, and inside loops where a large amount of elements
     *   could be processed.
     * - Use a profiler to find long running individual parts of detection.
     * - Due to the skip logic additional calls are cheap, when in doubt just call
     */
    checkCancel() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const now = Date.now();
        if (now - this.lastCheckCancelTimestamp < 50) {
          return;
        }
        this.lastCheckCancelTimestamp = now;
        yield new Promise((resolve) => setTimeout(resolve, 0));
        if (this === null || this === void 0 ? void 0 : this.canceled) {
          throw new DetectFormsCanceled();
        }
      });
    }
    cancelableFilter(array, predicate) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const result2 = [];
        for (const [i2, el2] of array.entries()) {
          yield this.checkCancel();
          if (predicate(el2, i2, array)) {
            result2.push(el2);
          }
        }
        return result2;
      });
    }
    isVisible(el2) {
      const cached = this.isVisibleCache.get(el2);
      if (cached !== void 0) {
        return cached;
      }
      const result2 = isVisible(el2);
      this.isVisibleCache.set(el2, result2);
      return result2;
    }
  }
  var _dec$7, _class$7;
  let FormAutosnatch = (_dec$7 = Emittery$3.mixin("emitter"), _dec$7(_class$7 = class FormAutosnatch2 {
    constructor(formTracker, stateRestorationClient) {
      __publicField(this, "loginAutosnatchDisabled", false);
      __publicField(this, "registrationAutosnatchDisabled", false);
      __publicField(this, "usernameAutosnatch");
      __publicField(this, "registrationGeneratedPassword");
      __publicField(this, "overrideAutosnatchTargetVaultId");
      __publicField(this, "messageListener", makeMessageListener({
        DataUpdate: () => this.updateLoginAutosnatchEnabled()
      }));
      __publicField(this, "handleFormsChanged", ({
        oldForms,
        newForms
      }) => {
        this.removeListeners(oldForms);
        this.addListeners(newForms);
      });
      __publicField(this, "handleInputKeyEvent", (e2) => {
        if (e2.key === "Enter" && e2.currentTarget instanceof HTMLElement) {
          this.performAutosnatch(e2.currentTarget);
        }
      });
      __publicField(this, "handleFormSubmit", (e2) => {
        if (e2.currentTarget instanceof HTMLElement) {
          this.performAutosnatch(e2.currentTarget);
        }
      });
      __publicField(this, "handleFormClick", (e2) => {
        const {
          target
        } = e2;
        if (!(target instanceof HTMLInputElement) && !(target instanceof HTMLButtonElement) || target.type !== "submit") {
          return;
        }
        if (target.form) {
          this.performAutosnatch(target.form);
        }
      });
      __publicField(this, "handleFormKeyEvent", (e2) => {
        if (e2.key !== "Enter") {
          return;
        }
        const {
          target
        } = e2;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        if (target.form) {
          this.performAutosnatch(target.form);
        }
      });
      __publicField(this, "enqueueProcessLoginAutosnatch", debounce$1(300, true, (autosnatchLogin) => {
        this.processLoginAutosnatch(autosnatchLogin).catch(trackError);
      }));
      __publicField(this, "enqueueUpdateRegistrationAutosnatch", debounce$1(300, true, (autosnatchLogin) => {
        this.updateRegistrationAutosnatch(autosnatchLogin).catch(trackError);
      }));
      this.formTracker = formTracker;
      this.stateRestorationClient = stateRestorationClient;
    }
    init() {
      browser$1.runtime.onMessage.addListener(this.messageListener);
      this.formTracker.on("formsChanged", this.handleFormsChanged);
      this.handleFormsChanged({
        oldForms: {
          login: null,
          registration: null
        },
        newForms: this.formTracker.forms
      });
      this.restoreState().catch(trackError);
    }
    close() {
      browser$1.runtime.onMessage.removeListener(this.messageListener);
      this.formTracker.off("formsChanged", this.handleFormsChanged);
      this.handleFormsChanged({
        oldForms: this.formTracker.forms,
        newForms: {
          login: null,
          registration: null
        }
      });
    }
    async ignoringAutosnatch(cb2) {
      debugConsole.log("[FormAutosnatch]", "enter ignoring autosnatch");
      this.removeListeners(this.formTracker.forms);
      try {
        await cb2();
      } finally {
        debugConsole.log("[FormAutosnatch]", "leave ignoring autosnatch");
        this.addListeners(this.formTracker.forms);
      }
    }
    async updateLoginAutosnatchEnabled() {
      const result2 = await sendMessage({
        type: "GetAutosnatchSettings"
      });
      if (result2 === messageError) {
        return;
      }
      const enabled = !result2.disabled;
      this.loginAutosnatchDisabled = !enabled;
      this.emitter.emit("loginAutosnatchStateChanged", {
        enabled
      }).catch(trackError);
    }
    disableRegistrationAutosnatch() {
      this.registrationAutosnatchDisabled = true;
      this.registrationGeneratedPassword = void 0;
    }
    setRegistrationGeneratedPassword(registrationGeneratedPassword) {
      this.registrationGeneratedPassword = registrationGeneratedPassword;
    }
    getRegistrationUsername() {
      if (!this.formTracker.registrationElements) {
        return void 0;
      }
      return FormAutosnatch2.findRegistrationUsername(this.formTracker.registrationElements);
    }
    getOverrideTargetVault() {
      return this.overrideAutosnatchTargetVaultId;
    }
    setOverrideTargetVault(vaultId) {
      this.overrideAutosnatchTargetVaultId = vaultId;
    }
    async restoreState() {
      const stateToRestore = await this.stateRestorationClient.get("FormAutosnatch");
      this.usernameAutosnatch = this.usernameAutosnatch ?? stateToRestore;
      await this.updateLoginAutosnatchEnabled();
    }
    addListeners(newForms) {
      var _a3, _b, _c2, _d, _e, _f, _g, _h, _i;
      for (const key of ["login", "registration"]) {
        const formElements = newForms[key];
        (_a3 = formElements == null ? void 0 : formElements.formElement) == null ? void 0 : _a3.addEventListener("submit", this.handleFormSubmit, true);
        (_b = formElements == null ? void 0 : formElements.formElement) == null ? void 0 : _b.addEventListener("click", this.handleFormClick, true);
        (_c2 = formElements == null ? void 0 : formElements.formElement) == null ? void 0 : _c2.addEventListener("keyup", this.handleFormKeyEvent, true);
        (_d = formElements == null ? void 0 : formElements.formElement) == null ? void 0 : _d.addEventListener("keydown", this.handleFormKeyEvent, true);
        (_e = formElements == null ? void 0 : formElements.submitElement) == null ? void 0 : _e.addEventListener("click", this.handleFormSubmit, true);
        (_f = formElements == null ? void 0 : formElements.usernameElement) == null ? void 0 : _f.addEventListener("keydown", this.handleInputKeyEvent, true);
        (_g = formElements == null ? void 0 : formElements.passwordElement) == null ? void 0 : _g.addEventListener("keydown", this.handleInputKeyEvent, true);
        (_h = formElements == null ? void 0 : formElements.usernameElement) == null ? void 0 : _h.addEventListener("keyup", this.handleInputKeyEvent, true);
        (_i = formElements == null ? void 0 : formElements.passwordElement) == null ? void 0 : _i.addEventListener("keyup", this.handleInputKeyEvent, true);
      }
    }
    removeListeners(oldForms) {
      var _a3, _b, _c2, _d, _e, _f, _g, _h, _i;
      for (const key of ["login", "registration"]) {
        const formElements = oldForms[key];
        (_a3 = formElements == null ? void 0 : formElements.formElement) == null ? void 0 : _a3.removeEventListener("submit", this.handleFormSubmit, true);
        (_b = formElements == null ? void 0 : formElements.formElement) == null ? void 0 : _b.removeEventListener("click", this.handleFormClick, true);
        (_c2 = formElements == null ? void 0 : formElements.formElement) == null ? void 0 : _c2.removeEventListener("keyup", this.handleFormKeyEvent, true);
        (_d = formElements == null ? void 0 : formElements.formElement) == null ? void 0 : _d.removeEventListener("keydown", this.handleFormKeyEvent, true);
        (_e = formElements == null ? void 0 : formElements.submitElement) == null ? void 0 : _e.removeEventListener("click", this.handleFormSubmit, true);
        (_f = formElements == null ? void 0 : formElements.usernameElement) == null ? void 0 : _f.removeEventListener("keydown", this.handleInputKeyEvent, true);
        (_g = formElements == null ? void 0 : formElements.passwordElement) == null ? void 0 : _g.removeEventListener("keydown", this.handleInputKeyEvent, true);
        (_h = formElements == null ? void 0 : formElements.usernameElement) == null ? void 0 : _h.removeEventListener("keyup", this.handleInputKeyEvent, true);
        (_i = formElements == null ? void 0 : formElements.passwordElement) == null ? void 0 : _i.removeEventListener("keyup", this.handleInputKeyEvent, true);
      }
    }
    performAutosnatch(searchElement) {
      const result2 = this.getFormElements(searchElement);
      if (!result2) {
        return;
      }
      debugConsole.log("[FormAutosnatch]", "performing autosnatch for", result2);
      if (result2.type === "login") {
        this.performLoginAutosnatch(result2.formElements);
      } else {
        this.performRegistrationAutosnatch(result2.formElements);
      }
    }
    performLoginAutosnatch(formElements) {
      if (this.loginAutosnatchDisabled) {
        debugConsole.log("[FormAutosnatch]", "ABORT, login autosnatch disabled");
        return;
      }
      if (formElements.passwordElement) {
        const login = this.createLoginAutosnatchLogin(formElements);
        if (login) {
          debugConsole.log("[FormAutosnatch]", "found login", login);
          this.enqueueProcessLoginAutosnatch(login);
          sendMessage({
            type: "AddAchievements",
            achievements: [Achievement.EXT_AUTOSNATCH_FROM_LOGIN]
          }).catch(trackError);
        } else {
          this.performUsernameAutosnatch(formElements);
        }
      } else {
        this.performUsernameAutosnatch(formElements);
      }
    }
    performRegistrationAutosnatch(formElements) {
      if (this.registrationAutosnatchDisabled) {
        debugConsole.log("[FormAutosnatch]", "ABORT, registration autosnatch disabled");
        return;
      }
      let login = this.createRegistrationAutosnatchLogin(formElements);
      if (login) {
        debugConsole.log("[FormAutosnatch]", "found login", login);
        if (this.registrationGeneratedPassword && this.registrationGeneratedPassword.generatedPassword === login.password) {
          login = {
            ...login,
            autosnatchId: this.registrationGeneratedPassword.autosnatchId
          };
          this.enqueueUpdateRegistrationAutosnatch(login);
          return;
        }
        this.enqueueProcessLoginAutosnatch(login);
        sendMessage({
          type: "AddAchievements",
          achievements: [Achievement.EXT_AUTOSNATCH_FROM_REGISTRATION]
        }).catch(trackError);
      }
    }
    getFormElements(searchElement) {
      if (this.formTracker.loginElements && Object.values(this.formTracker.loginElements).includes(searchElement)) {
        return {
          type: "login",
          formElements: this.formTracker.loginElements
        };
      }
      if (this.formTracker.registrationElements && Object.values(this.formTracker.registrationElements).includes(searchElement)) {
        return {
          type: "registration",
          formElements: this.formTracker.registrationElements
        };
      }
      return null;
    }
    performUsernameAutosnatch(elements) {
      var _a3;
      const username = (_a3 = elements.usernameElement) == null ? void 0 : _a3.value;
      debugConsole.log("[FormAutosnatch]", "attempt username autosnatch with", username);
      if (username) {
        debugConsole.log("[FormAutosnatch]", "username autosnatch performed");
        this.usernameAutosnatch = {
          username,
          date: (/* @__PURE__ */ new Date()).toISOString()
        };
        this.stateRestorationClient.set("FormAutosnatch", this.usernameAutosnatch);
      }
    }
    async processLoginAutosnatch(login) {
      debugConsole.log("[FormAutosnatch]", "processing autosnatch");
      if (browser$1.extension.inIncognitoContext) {
        debugConsole.log("[FormAutosnatch]", "ABORT, incognito");
        return;
      }
      const disabledSiteSettingResult = await sendMessage({
        type: "GetDisabledSiteSettingForUrl",
        url: window.location.href
      });
      if (disabledSiteSettingResult === messageError) {
        debugConsole.log("[FormAutosnatch]", "ABORT, failed to get GetDisabledSiteSetting");
        return;
      }
      if (disabledSiteSettingResult.disabled) {
        debugConsole.log("[FormAutosnatch]", "ABORT, disabled for url");
        return;
      }
      debugConsole.log("[FormAutosnatch]", "login autosnatch performed with", login);
      await this.emitter.emit("autosnatchPerformed", {
        type: "loginAutosnatch",
        login
      });
      sendMessage({
        type: "LoginSnatched",
        login
      }).catch(trackError);
    }
    async updateRegistrationAutosnatch(login) {
      await this.emitter.emit("autosnatchPerformed", {
        type: "updateRegistrationAutosnatch",
        login
      });
      sendMessage({
        type: "UpdateAutosnatchLogin",
        login
      }).catch(trackError);
    }
    createLoginAutosnatchLogin(elements) {
      var _a3, _b;
      let username = (_a3 = elements.usernameElement) == null ? void 0 : _a3.value;
      if (!username && this.usernameAutosnatch && differenceInSeconds(/* @__PURE__ */ new Date(), parseISO(this.usernameAutosnatch.date)) < 45) {
        username = this.usernameAutosnatch.username;
      }
      const password = (_b = elements.passwordElement) == null ? void 0 : _b.value;
      if (!username || !password) {
        return void 0;
      }
      return {
        username,
        password,
        targetLoginId: void 0,
        overrideTargetVaultId: this.overrideAutosnatchTargetVaultId,
        autosnatchId: newUuid$1(),
        // Wait for the autosnatch notification so we can change target vault from there
        waitForTab: true,
        hideUntilCompletion: false,
        addTldPlus1: false,
        source: LoginSource.autosave,
        forceCreate: false
      };
    }
    createRegistrationAutosnatchLogin(elements) {
      var _a3;
      const username = FormAutosnatch2.findRegistrationUsername(elements);
      const password = (_a3 = elements.passwordElement) == null ? void 0 : _a3.value;
      if (!username || !password) {
        return void 0;
      }
      return {
        username,
        password,
        targetLoginId: void 0,
        overrideTargetVaultId: this.overrideAutosnatchTargetVaultId,
        autosnatchId: newUuid$1(),
        waitForTab: false,
        hideUntilCompletion: false,
        addTldPlus1: true,
        source: LoginSource.autosave,
        forceCreate: false
      };
    }
    static findRegistrationUsername(elements) {
      var _a3;
      const inputWithEmail = elements.containerElement ? querySelectorAllWithShadowRoots("input", elements.containerElement).find((el2) => (el2.type === "text" || el2.type === "email") && el2.value.includes("@")) : void 0;
      const username = (inputWithEmail == null ? void 0 : inputWithEmail.value) ?? ((_a3 = elements.usernameElement) == null ? void 0 : _a3.value);
      return username;
    }
  }) || _class$7);
  content;
  var _dec$6, _class$6;
  let DebugMode = (_dec$6 = Emittery$3.mixin("emitter"), _dec$6(_class$6 = class DebugMode2 {
    constructor() {
      __publicField(this, "debugFlag", false);
      __publicField(this, "localDebugOverrideFlag");
      __publicField(this, "handleStorageChanged", (changes, areaName) => {
        if (areaName !== "local" || changes.debug === void 0) {
          return;
        }
        this.internalUpdateDebugFlag(changes.debug.newValue);
      });
    }
    async init() {
      browser$1.storage.onChanged.addListener(this.handleStorageChanged);
      const {
        debug: storageDebugFlag
      } = await browser$1.storage.local.get("debug");
      this.internalUpdateDebugFlag(storageDebugFlag);
    }
    get debug() {
      return this.localDebugOverrideFlag ?? this.debugFlag;
    }
    set debug(newDebug) {
      this.internalUpdateDebugFlag(newDebug);
      browser$1.storage.local.set({
        debug: this.debugFlag
      }).catch(trackError);
    }
    get localDebugOverride() {
      return this.localDebugOverrideFlag;
    }
    set localDebugOverride(newOverride) {
      this.withEvents(() => {
        this.localDebugOverrideFlag = newOverride;
      });
    }
    internalUpdateDebugFlag(newDebugFlag) {
      this.withEvents(() => {
        this.debugFlag = newDebugFlag;
      });
    }
    withEvents(cb2) {
      const oldDebug = this.debug;
      cb2();
      if (oldDebug !== this.debug) {
        debugConsole.showDebugMessages = this.debug;
        this.emitter.emit("change", {
          debug: this.debug
        }).catch(trackError);
      }
    }
  }) || _class$6);
  const debugMode = new DebugMode();
  debugMode.init().catch(trackError);
  content;
  function getBox(el2) {
    if (el2.getClientRects().length === 0) {
      return null;
    }
    const {
      top: viewportTop,
      left: viewportLeft,
      width,
      height
    } = el2.getBoundingClientRect();
    const top = viewportTop + window.scrollY;
    const left = viewportLeft + window.scrollX;
    return {
      top,
      left,
      width,
      height
    };
  }
  function toCorners(box) {
    const {
      top,
      left,
      width,
      height
    } = box;
    return {
      top,
      left,
      bottom: top + height,
      right: left + width
    };
  }
  function toBox(corners) {
    const {
      top,
      left,
      bottom,
      right
    } = corners;
    return {
      top,
      left,
      width: right - left,
      height: bottom - top
    };
  }
  function getDocumentBox() {
    return {
      top: 0,
      left: 0,
      width: document.documentElement.scrollWidth,
      height: document.documentElement.scrollHeight
    };
  }
  function getBoxCoveringAll(...els) {
    const allCorners = Object.values(els).filter(notNull).map(getBox).filter(notNull).map(toCorners);
    if (allCorners.length === 0) {
      return null;
    }
    const corners = allCorners.reduce((p1, p2) => ({
      top: Math.min(p1.top, p2.top),
      left: Math.min(p1.left, p2.left),
      bottom: Math.max(p1.bottom, p2.bottom),
      right: Math.max(p1.right, p2.right)
    }));
    return toBox(corners);
  }
  function ensureInside(baseBox, boundingBox) {
    const {
      top: boundingTop,
      left: boundingLeft,
      width: boundingWidth,
      height: boundingHeight
    } = boundingBox;
    let {
      top,
      left
    } = baseBox;
    const {
      width,
      height
    } = baseBox;
    top = ensureInside1d(top, height, boundingTop, boundingHeight);
    left = ensureInside1d(left, width, boundingLeft, boundingWidth);
    return {
      top,
      left,
      width,
      height
    };
  }
  function ensureInside1d(start, length, boundingStart, boundingLength) {
    const boundingEnd = boundingStart + boundingLength;
    let s2 = start;
    if (s2 + length > boundingEnd) {
      s2 -= s2 + length - boundingEnd;
    }
    if (s2 < boundingStart) {
      s2 = boundingStart;
    }
    if (s2 + length > boundingEnd) {
      s2 -= (s2 + length - boundingEnd) / 2;
    }
    return s2;
  }
  function expandToContain(box, size, anchor) {
    let top;
    let height;
    if (box.height < size.height) {
      const heightDifference = size.height - box.height;
      top = box.top - heightDifference * anchor.top;
      height = size.height;
    } else {
      top = box.top;
      height = box.height;
    }
    let left;
    let width;
    if (box.width < size.width) {
      const widthDifference = size.width - box.width;
      left = box.left - widthDifference * anchor.left;
      width = size.width;
    } else {
      left = box.left;
      width = box.width;
    }
    return {
      top,
      height,
      left,
      width
    };
  }
  function expandByMargin({
    top,
    left,
    width,
    height
  }, margin) {
    return {
      top: top - margin,
      left: left - margin,
      width: width + margin * 2,
      height: height + margin * 2
    };
  }
  function doBoxesIntersect(a, b2) {
    return (
      // is distance between edge center points smaller than combined edge length in both axes?
      Math.abs(a.left + a.width / 2 - (b2.left + b2.width / 2)) * 2 < a.width + b2.width && Math.abs(a.top + a.height / 2 - (b2.top + b2.height / 2)) * 2 < a.height + b2.height
    );
  }
  function notNull(el2) {
    return el2 !== null;
  }
  content;
  function getZIndexInDocumentElement(targetEl) {
    if (targetEl === document.documentElement) {
      return 0;
    }
    const topmostStackingContext = getTopmostStackingContext(targetEl, document.documentElement);
    if (topmostStackingContext) {
      const z2 = getEffectiveZIndex(topmostStackingContext, document.documentElement);
      return z2;
    }
    const zIndexDesc = [targetEl, ...querySelectorAllWithShadowRoots("*", targetEl)].map((el2) => getEffectiveZIndex(el2, document.documentElement)).sort((zl2, zr) => zr - zl2);
    if (!zIndexDesc.length) {
      return 0;
    }
    return zIndexDesc[0];
  }
  function getEffectiveZIndex(el2, baseEl) {
    let cur = el2;
    let parent = getParentWithShadowDom(el2);
    do {
      const curStyle = getComputedStyle(cur);
      if (zIndexAppliesToElement(cur, curStyle)) {
        return parseInt(curStyle.zIndex, 10);
      }
      cur = parent;
      parent = cur ? getParentWithShadowDom(cur) : null;
    } while (cur && parent && parent !== baseEl);
    return 0;
  }
  function zIndexAppliesToElement(cur, curStyle) {
    if (curStyle.zIndex === "auto") {
      return false;
    }
    if (curStyle.position !== "static") {
      return true;
    }
    if (isFlexOrGridItem(cur)) {
      return true;
    }
    return false;
  }
  function getTopmostStackingContext(el2, baseEl) {
    const parents = [];
    let cur = el2;
    while (cur && cur !== baseEl) {
      parents.unshift(cur);
      cur = getParentWithShadowDom(cur);
    }
    const topmostStackingContext = parents.find(isStackingContext);
    return topmostStackingContext;
  }
  function isStackingContext(el2) {
    if (el2 === document.documentElement) {
      return true;
    }
    const sty = getComputedStyle(el2);
    const zIndexAuto = sty.zIndex === "auto";
    if ((sty.position === "absolute" || sty.position === "relative") && !zIndexAuto) {
      return true;
    }
    if (sty.position === "fixed" || sty.position === "sticky") {
      return true;
    }
    if (parseFloat(sty.opacity) < 1) {
      return true;
    }
    if (sty.getPropertyValue("mix-blend-mode") && sty.getPropertyValue("mix-blend-mode") !== "normal") {
      return true;
    }
    if (["transform", "filter", "perspective", "clip-path", "mask", "mask-image", "mask-border"].some((prop) => sty.getPropertyValue(prop) && sty.getPropertyValue(prop) !== "none")) {
      return true;
    }
    if (sty.getPropertyValue("isolation") === "isolate") {
      return true;
    }
    if (sty.getPropertyValue("-webkit-overflow-scrolling ") === "touch") {
      return true;
    }
    if (/\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/.test(sty.willChange)) {
      return true;
    }
    if (/\b(?:layout|paint|strict|content)\b/.test(sty.getPropertyValue("contain"))) {
      return true;
    }
    if (isFlexOrGridItem(el2) && !zIndexAuto) {
      return true;
    }
    return false;
  }
  function isFlexOrGridItem(el2) {
    const parentSty = el2.parentElement ? getComputedStyle(el2.parentElement) : {};
    return parentSty.display === "flex" || parentSty.display === "inline-flex" || parentSty.display === "grid" || parentSty.display === "inline-grid";
  }
  content;
  const MEASUREMENT_INTERVAL_LENGTH_MS = 1e4;
  const emptyStats = {
    detections: 0,
    detectionAvgWallTime: 0,
    cancelledDetections: 0,
    finishedDetections: 0
  };
  class FormDetectionPerformanceTracker {
    constructor(formTracker) {
      __publicField(this, "initTimestamp", 0);
      __publicField(this, "totalStats", {
        ...emptyStats
      });
      __publicField(this, "intervalStats");
      __publicField(this, "logIntervalId", 0);
      __publicField(this, "handleDetectionEnd", (event) => {
        debugConsole.timeStamp("detectionEnd");
        if (this.intervalStats) {
          this.addToStats(this.intervalStats.stats, event);
        }
        this.addToStats(this.totalStats, event);
      });
      this.formTracker = formTracker;
    }
    init() {
      this.initTimestamp = performance.now();
      this.resetIntervalStats(performance.now());
      this.formTracker.on("detectionEnd", this.handleDetectionEnd);
      this.logIntervalId = window.setInterval(() => this.logStats(), MEASUREMENT_INTERVAL_LENGTH_MS);
    }
    close() {
      this.formTracker.off("detectionEnd", this.handleDetectionEnd);
      window.clearInterval(this.logIntervalId);
    }
    addToStats(stats, event) {
      const wallTime = event.detectionEndMs - event.detectionStartMs;
      stats.detectionAvgWallTime = cumulativeAverage(stats.detectionAvgWallTime, stats.detections, wallTime);
      stats.detections += 1;
      if (event.cancelled) {
        stats.cancelledDetections += 1;
      } else {
        stats.finishedDetections += 1;
      }
    }
    resetIntervalStats(now) {
      this.intervalStats = {
        intervalStart: now,
        stats: {
          ...emptyStats
        }
      };
    }
    logStats() {
      const now = performance.now();
      if (this.intervalStats) {
        const intervalDuration = now - this.intervalStats.intervalStart;
        debugConsole.log("[FormDetectionPerformance]", `interval: ${Math.round(intervalDuration)}ms`, this.evaluateStats(this.intervalStats.stats, intervalDuration));
        this.resetIntervalStats(now);
      }
      const totalDuration = now - this.initTimestamp;
      debugConsole.log("[FormDetectionPerformance]", `total: ${Math.round(totalDuration)}ms`, this.evaluateStats(this.totalStats, totalDuration));
    }
    evaluateStats(stats, wallTimeMs) {
      return roundAll({
        ...stats,
        detectionsPerSecond: stats.detections / wallTimeMs * 1e3,
        detectionWallTimeRatio: stats.detections * stats.detectionAvgWallTime / wallTimeMs
      });
    }
  }
  function cumulativeAverage(previousAverage, perviousEventCount, newEvent) {
    return (previousAverage * perviousEventCount + newEvent) / (perviousEventCount + 1);
  }
  function roundAll(input) {
    return Object.fromEntries(Object.entries(input).map(([k2, v2]) => [k2, round2(v2)]));
  }
  function round2(number2) {
    return Math.round(number2 * 100) / 100;
  }
  content;
  content;
  content;
  content;
  content;
  content;
  function openConnection(name, connectionId) {
    const portName = makePortName(name, connectionId);
    let port;
    let retries = 0;
    while (!port && retries < 3) {
      try {
        port = browser$1.runtime.connect(void 0, {
          name: portName
        });
      } catch (e2) {
        if (!isWebExtError(e2, "UNEXPECTED_ERROR")) {
          throw e2;
        }
      }
      retries++;
    }
    if (!port) {
      throw new Error("Failed to open connection after retries");
    }
    return port;
  }
  function makePortName(name, connectionId) {
    if (!connectionId) {
      return name;
    }
    return `${name},${connectionId}`;
  }
  content;
  class FakeHover {
    constructor() {
      __publicField(this, "targetEl");
      __publicField(this, "styleEl");
    }
    start(el2) {
      if (this.targetEl === el2) {
        return;
      }
      if (this.targetEl) {
        this.stop();
      }
      el2.dispatchEvent(new MouseEvent("mouseover", {
        view: window,
        bubbles: true,
        cancelable: true,
        // Ensure that event propagates outside of shadow dom tree, see
        // https://pm.dartus.fr/posts/2021/shadow-dom-and-event-propagation/#what-about-standard-events
        composed: true
      }));
      this.addFakeHoverStyles(el2);
      this.targetEl = el2;
    }
    stop() {
      var _a3;
      if (!this.targetEl) {
        return;
      }
      this.targetEl.dispatchEvent(new MouseEvent("mouseout", {
        view: window,
        bubbles: true,
        cancelable: true,
        // Ensure that event propagates outside of shadow dom tree, see
        // https://pm.dartus.fr/posts/2021/shadow-dom-and-event-propagation/#what-about-standard-events
        composed: true
      }));
      (_a3 = this.styleEl) == null ? void 0 : _a3.remove();
      this.styleEl = void 0;
      this.targetEl = void 0;
    }
    addFakeHoverStyles(el2) {
      const parents = FakeHover.getParents(el2);
      const fakeHoverStyles = FakeHover.getFakeHoverStyles(parents);
      if (fakeHoverStyles.length) {
        const styleElement = document.createElement("style");
        styleElement.textContent = fakeHoverStyles.join("\n");
        document.head.appendChild(styleElement);
        this.styleEl = styleElement;
      }
    }
    static getParents(el2) {
      const parents = [];
      let cur = el2;
      while (cur) {
        parents.push(cur);
        cur = cur.parentElement;
      }
      return parents;
    }
    static getFakeHoverStyles(els) {
      const hoverRemovedStyles = [];
      const rules = Array.from(document.styleSheets).flatMap((s2) => FakeHover.getStyleRules(s2));
      for (const rule of rules) {
        for (const e2 of els) {
          const selector2 = rule.selectorText;
          if (selector2.includes(":hover")) {
            const selectorWithoutHover = selector2.replaceAll(":hover", ":nth-child(n)");
            try {
              if (e2.matches(selector2) !== e2.matches(selectorWithoutHover)) {
                hoverRemovedStyles.push(`${selectorWithoutHover} { ${rule.style.cssText} }`);
              }
            } catch {
            }
          }
        }
      }
      return hoverRemovedStyles;
    }
    static getStyleRules(styleSheet) {
      let rules;
      try {
        rules = styleSheet.cssRules;
      } catch (e2) {
        return [];
      }
      return Array.from(rules).filter((r2) => r2.type === CSSRule.STYLE_RULE);
    }
  }
  content;
  function wrapInShadow(...els) {
    const wrapper = document.createElement("div");
    const shadowRoot = wrapper.attachShadow({
      mode: "closed"
    });
    for (const el2 of els) {
      shadowRoot.appendChild(el2);
    }
    return wrapper;
  }
  content;
  class ShadowRootAwareMutationObserver {
    constructor(mutationCallback, newShadowRootCallback, options) {
      __publicField(this, "mutationObserver");
      __publicField(this, "observed", /* @__PURE__ */ new Set());
      __publicField(this, "shadowRoots", /* @__PURE__ */ new Set());
      __publicField(this, "observeAllShadowRootsDebounced", debounce$1(50, () => this.observeAllShadowRoots()));
      this.newShadowRootCallback = newShadowRootCallback;
      this.options = options;
      this.mutationObserver = new MutationObserver((mutations, observer) => {
        this.observeAllShadowRootsDebounced();
        mutationCallback(mutations, observer);
      });
    }
    observe(target) {
      this.observed.add(target);
      this.mutationObserver.observe(target, {
        ...this.options,
        childList: true,
        subtree: true,
        attributes: true
      });
      this.observeAllShadowRootsDebounced();
    }
    disconnect() {
      this.shadowRoots.clear();
      this.observed.clear();
      this.mutationObserver.disconnect();
    }
    observeAllShadowRoots() {
      let newShadowRoot = false;
      for (const el2 of this.observed) {
        if (el2 instanceof Element || el2 instanceof Document) {
          const els = querySelectorAllWithShadowRoots("*", el2);
          for (const child of els) {
            newShadowRoot || (newShadowRoot = this.observeElementShadowRoot(child));
          }
        }
      }
      if (newShadowRoot) {
        this.newShadowRootCallback();
      }
    }
    observeElementShadowRoot(el2) {
      const shadowRoot = getShadowRoot(el2);
      if (!shadowRoot || this.shadowRoots.has(shadowRoot)) {
        return false;
      }
      this.shadowRoots.add(shadowRoot);
      this.mutationObserver.observe(shadowRoot, {
        ...this.options,
        childList: true,
        subtree: true,
        attributes: true
      });
      return true;
    }
  }
  content;
  var _dec$5, _class$5;
  let ZIndexSync = (_dec$5 = Emittery$3.mixin("emitter"), _dec$5(_class$5 = class ZIndexSync2 {
    constructor() {
      __publicField(this, "zIndexes", /* @__PURE__ */ new WeakMap());
    }
    getZIndexInDocumentElement(el2) {
      const newZIndex = getZIndexInDocumentElement(el2);
      if (this.zIndexes.has(el2) && newZIndex !== this.zIndexes.get(el2)) {
        this.emitter.emit("zIndexUpdate", {
          el: el2
        }).catch(trackError);
      }
      this.zIndexes.set(el2, newZIndex);
      return newZIndex;
    }
  }) || _class$5);
  const zIndexSync = new ZIndexSync();
  content;
  const styleUrl = "data:text/css;base64,QGtleWZyYW1lcyBzbGlkZS1hbmQtZmFkZS1pbiB7CiAgMCUgewogICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwJSk7CiAgICBvcGFjaXR5OiAwOwogIH0KCiAgMTAwJSB7CiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7CiAgICBvcGFjaXR5OiAxOwogIH0KfQo=";
  const MAX_Z_INDEX = `${Math.pow(2, 31) - 1}`;
  const IFRAME_DEFAULT_STYLE = {
    border: "none",
    position: "absolute",
    boxSizing: "content-box",
    height: "0",
    // If the host page opts in to automatic dark mode for embedded elements (via `color-scheme: light
    // dark;`) iframes get a white background for whatever reasons. We force the color scheme back to
    // light only to prevent that.
    colorScheme: "light"
  };
  class IframePositionManager {
    constructor(options) {
      __publicField(this, "iframeOptions");
      __publicField(this, "iframeWrapper");
      __publicField(this, "iframe");
      __publicField(this, "mouseInside", false);
      __publicField(this, "freezeIframeBox", false);
      __publicField(this, "loaded", false);
      __publicField(this, "initialized", false);
      __publicField(this, "mutationObserver");
      __publicField(this, "intrinsicIframeSize", {
        width: 0,
        height: 0
      });
      __publicField(this, "extrinsicIframeSize", null);
      __publicField(this, "iframeBox", null);
      __publicField(this, "fakeHover", new FakeHover());
      __publicField(this, "updateIframeBoxThrottled", throttle(3, () => {
        window.requestAnimationFrame(() => {
          this.updateIframeBox();
        });
      }));
      __publicField(this, "handleZIndexUpdate", ({
        el: el2
      }) => {
        var _a3, _b;
        if (((_b = (_a3 = this.iframeOptions).getOverlayTargetElement) == null ? void 0 : _b.call(_a3)) === el2) {
          this.updateIframe();
        }
      });
      __publicField(this, "handleMutations", (mutations) => {
        const removedNodes = mutations.flatMap((m2) => Array.from(m2.removedNodes) ?? []);
        const addedNodes = mutations.flatMap((m2) => Array.from(m2.addedNodes) ?? []);
        if (
          // If iframe is removed, add it again. When the body element is added during load, make sure
          // our iframe is after it in document order, so it stacks correctly.
          (removedNodes.includes(this.iframeWrapper) || addedNodes.includes(document.body)) && // Reinserting the iframe will trigger a remove if it was already in the dom in another place.
          // This happens if the host page moves our iframe around. To prevent a loop, we check if the
          // iframe is actually not where we want it to be.
          !this.iframeIsCorrectlyInsertedInDom()
        ) {
          this.enqueueReinsertIframe();
        }
        this.updateIframeBoxThrottled();
      });
      __publicField(this, "reinsertIframeTimeoutId", NaN);
      __publicField(this, "reinsertIframeRecentRetries", 0);
      __publicField(this, "lastReinsertTimeMs", -Infinity);
      __publicField(this, "reinsertIframe", () => {
        debugConsole.log("[IframePositionManager]", "reinserting iframe", {
          retries: this.reinsertIframeRecentRetries,
          iframeParent: this.iframeWrapper.parentElement
        });
        this.lastReinsertTimeMs = Date.now();
        if (!this.iframeIsCorrectlyInsertedInDom()) {
          if (document.body) {
            document.body.after(this.iframeWrapper);
          } else {
            document.documentElement.appendChild(this.iframeWrapper);
          }
        }
      });
      this.iframeOptions = options;
      this.mutationObserver = new ShadowRootAwareMutationObserver(this.handleMutations, this.updateIframeBoxThrottled, {
        characterData: true
      });
      const {
        iframe,
        iframeWrapper
      } = this.createIframe();
      this.iframe = iframe;
      this.iframeWrapper = iframeWrapper;
      this.updateIframe();
    }
    init() {
      this.initialized = true;
      window.addEventListener("resize", this.updateIframeBoxThrottled);
      window.addEventListener("scroll", this.updateIframeBoxThrottled, true);
      window.addEventListener("transitionend", this.updateIframeBoxThrottled);
      window.addEventListener("transitioncancel", this.updateIframeBoxThrottled);
      this.updateIframeBox();
    }
    close() {
      this.initialized = false;
      window.removeEventListener("resize", this.updateIframeBoxThrottled);
      window.removeEventListener("scroll", this.updateIframeBoxThrottled, true);
      window.removeEventListener("transitionend", this.updateIframeBoxThrottled);
      window.removeEventListener("transitioncancel", this.updateIframeBoxThrottled);
      this.updateIframeBox();
    }
    async withFrozenIframe(cb2) {
      this.freezeIframeBox = true;
      try {
        await cb2();
      } finally {
        this.freezeIframeBox = false;
        this.updateIframeBoxThrottled();
      }
    }
    updatePosition() {
      this.updateIframeBoxThrottled();
    }
    setIntrinsicSize(size) {
      this.intrinsicIframeSize = size;
      debugConsole.log("[IframePositionManager]", "IntrinsicIframeSizeUpdate", this.intrinsicIframeSize);
      this.updateIframeBoxThrottled();
    }
    createIframe() {
      const iframe = document.createElement("iframe");
      Object.assign(iframe, this.iframeOptions.attributes);
      Object.assign(iframe.style, IFRAME_DEFAULT_STYLE);
      iframe.addEventListener("mouseenter", () => {
        var _a3, _b;
        this.mouseInside = true;
        const el2 = (_b = (_a3 = this.iframeOptions).getOverlayTargetElement) == null ? void 0 : _b.call(_a3);
        if (el2) {
          this.fakeHover.start(el2);
        }
      });
      iframe.addEventListener("mouseleave", () => {
        this.mouseInside = false;
        this.fakeHover.stop();
        this.updateIframeBoxThrottled();
      });
      iframe.addEventListener("animationend", () => {
        var _a3, _b;
        return (_b = (_a3 = this.iframeOptions).onEntryAnimated) == null ? void 0 : _b.call(_a3);
      });
      const onload = () => {
        this.loaded = true;
        iframe.removeEventListener("load", onload);
        this.updateIframe();
      };
      iframe.addEventListener("load", onload);
      const styleLink = document.createElement("link");
      styleLink.href = styleUrl;
      styleLink.rel = "stylesheet";
      const iframeWrapper = wrapInShadow(styleLink, iframe);
      iframeWrapper.style.setProperty("position", "static", "important");
      iframeWrapper.style.setProperty("display", "block", "important");
      iframeWrapper.style.setProperty("visibility", "visible", "important");
      iframeWrapper.style.setProperty("opacity", "1", "important");
      return {
        iframe,
        iframeWrapper
      };
    }
    enqueueReinsertIframe() {
      if (Date.now() - this.lastReinsertTimeMs > 6e4) {
        this.reinsertIframeRecentRetries = 0;
      }
      if (this.reinsertIframeRecentRetries === 0) {
        debugConsole.log("[IframePositionManager]", "iframe removed, reinserting immediately!");
        this.reinsertIframeRecentRetries += 1;
        this.reinsertIframe();
        return;
      }
      window.clearTimeout(this.reinsertIframeTimeoutId);
      const delay = Math.min(100 * 2 ** this.reinsertIframeRecentRetries, 6e4);
      debugConsole.log("[IframePositionManager]", `iframe removed, enqueuing reinsert in ${delay}ms`);
      this.reinsertIframeRecentRetries += 1;
      this.reinsertIframeTimeoutId = window.setTimeout(this.reinsertIframe, delay);
    }
    setIframeUrl(url) {
      this.iframeOptions.url = url;
      this.updateIframe();
    }
    iframeIsCorrectlyInsertedInDom() {
      if (!document.documentElement.contains(this.iframeWrapper)) {
        return false;
      }
      if (!document.body) {
        return true;
      }
      const childNodes = [...document.documentElement.childNodes];
      return childNodes.indexOf(document.body) < childNodes.indexOf(this.iframeWrapper);
    }
    updateIframeBox() {
      var _a3, _b;
      if (!this.initialized) {
        this.iframeBox = null;
        this.updateIframe();
        return;
      }
      const {
        box: overlayBox,
        forceHide
      } = this.iframeOptions.getOverlayBox();
      if (!overlayBox || forceHide) {
        if (this.mouseInside && !forceHide) {
          return;
        }
        this.iframeBox = null;
        this.updateIframe();
        return;
      }
      const extrinsicIframeSize = {
        width: overlayBox.width,
        height: overlayBox.height
      };
      let iframeBox = overlayBox;
      iframeBox = expandByMargin(iframeBox, this.iframeOptions.margin);
      iframeBox = expandToContain(iframeBox, this.iframeOptions.minSize ?? {
        width: 0,
        height: 0
      }, this.iframeOptions.anchor);
      iframeBox = expandToContain(iframeBox, this.intrinsicIframeSize, this.iframeOptions.anchor);
      const documentBox = expandByMargin(getDocumentBox(), this.iframeOptions.margin);
      iframeBox = ensureInside(iframeBox, documentBox);
      if (!Ee$1(iframeBox, this.iframeBox) || !Ee$1(extrinsicIframeSize, this.extrinsicIframeSize)) {
        if (this.freezeIframeBox && this.iframeBox && iframeBox.width * iframeBox.height <= ((_a3 = this.iframeBox) == null ? void 0 : _a3.width) * ((_b = this.iframeBox) == null ? void 0 : _b.height)) {
          return;
        }
        this.iframeBox = iframeBox;
        this.extrinsicIframeSize = extrinsicIframeSize;
        this.updateIframe();
      }
    }
    updateIframe() {
      var _a3, _b, _c2, _d, _e, _f;
      if (!this.iframeBox || !this.initialized) {
        this.iframe.style.display = "none";
        this.removeIframe();
        return;
      }
      this.insertIframe();
      const {
        top,
        left,
        width,
        height
      } = this.iframeBox;
      if (this.loaded) {
        Object.assign(
          this.iframe.style,
          this.iframeOptions.style,
          (_b = (_a3 = this.iframeOptions).getStyle) == null ? void 0 : _b.call(_a3, this.extrinsicIframeSize ?? this.iframeBox),
          // Only animate once iframe has a size, beforehand the animation would not be visible.
          ((_d = (_c2 = this.iframeOptions).getAnimateEntry) == null ? void 0 : _d.call(_c2)) && width > 0 && height > 0 ? {
            animation: "slide-and-fade-in 200ms ease-out"
          } : {}
        );
      }
      this.iframe.style.display = "block";
      this.iframe.style.top = `${top}px`;
      this.iframe.style.left = `${left}px`;
      this.iframe.style.width = `${width}px`;
      this.iframe.style.height = `${height}px`;
      this.iframe.style.zIndex = this.getZIndex();
      const extrinsicWidth = ((_e = this.extrinsicIframeSize) == null ? void 0 : _e.width) ?? width;
      const extrinsicHeight = ((_f = this.extrinsicIframeSize) == null ? void 0 : _f.height) ?? height;
      const iframeSrc = `${this.iframeOptions.url}#extrinsicWidth=${extrinsicWidth}&extrinsicHeight=${extrinsicHeight}`;
      if (this.iframe.src !== iframeSrc) {
        this.iframe.src = iframeSrc;
      }
    }
    insertIframe() {
      this.mutationObserver.observe(document.getRootNode());
      zIndexSync.on("zIndexUpdate", this.handleZIndexUpdate);
      if (!this.iframeIsCorrectlyInsertedInDom()) {
        debugConsole.log("[IframePositionManager]", "insert");
        if (document.body) {
          document.body.after(this.iframeWrapper);
        } else {
          document.documentElement.appendChild(this.iframeWrapper);
        }
        this.updateIframeBox();
      }
    }
    removeIframe() {
      this.mutationObserver.disconnect();
      zIndexSync.off("zIndexUpdate", this.handleZIndexUpdate);
      if (this.iframeWrapper.parentElement) {
        debugConsole.log("[IframePositionManager]", "remove");
        this.iframeWrapper.parentElement.removeChild(this.iframeWrapper);
      }
    }
    getZIndex() {
      var _a3, _b;
      const el2 = (_b = (_a3 = this.iframeOptions).getOverlayTargetElement) == null ? void 0 : _b.call(_a3);
      if (!el2) {
        return MAX_Z_INDEX;
      }
      return `${zIndexSync.getZIndexInDocumentElement(el2) + (this.iframeOptions.additionalZIndex ?? 0)}`;
    }
  }
  content;
  const overrideCreateIframeStateDescriptor = {
    mode: "overrideCreate",
    initialState: {
      override: void 0,
      intrinsicSize: {
        width: 0,
        height: 0
      },
      selectorResults: {},
      overrideIsReplace: false,
      align: "left"
    },
    reducer: (state, action) => {
      switch (action.type) {
        case "setOverride":
          return {
            ...state,
            override: action.override
          };
        case "setIntrinsicSize":
          return {
            ...state,
            intrinsicSize: action.size
          };
        case "setSelectElementState":
          return {
            ...state,
            selectElementState: action.selectElementState
          };
        case "setAlign":
          return {
            ...state,
            align: action.align
          };
      }
    }
  };
  content;
  var _dec$4, _class$4;
  let IframeStateManager = (_dec$4 = Emittery$3.mixin("emitter"), _dec$4(_class$4 = class IframeStateManager2 {
    constructor(descriptor, connectionPort) {
      __publicField(this, "internalState");
      this.descriptor = descriptor;
      this.connectionPort = connectionPort;
      this.internalState = descriptor.initialState;
      this.connectionPort.onMessage.addListener((msg) => {
        if (this.isDispatchStateActionMessage(msg)) {
          this.dispatch(...msg.actions);
        }
        if (this.isRequestStateMessage(msg)) {
          this.sendStateUpdate();
        }
      });
    }
    get state() {
      return this.internalState;
    }
    updateState(stateUpdate) {
      const oldState = this.internalState;
      const newState = {
        ...this.internalState,
        ...stateUpdate
      };
      this.internalState = newState;
      debugConsole.log("[IframeState]", this.descriptor.mode, "updateState", this.internalState);
      this.sendStateUpdate();
      this.emitter.emit("stateUpdate", {
        oldState,
        newState
      }).catch(trackError);
    }
    dispatch(...actions) {
      debugConsole.log("[IframeState]", this.descriptor.mode, "dispatch", ...actions);
      const oldState = this.internalState;
      const newState = actions.reduce((os2, action) => {
        this.emitter.emit("action", action).catch(trackError);
        return this.descriptor.reducer(os2, action);
      }, oldState);
      if (!Ee$1(oldState, newState)) {
        debugConsole.log("[IframeState]", this.descriptor.mode, "updating state from dispatch", newState);
        this.internalState = newState;
        this.sendStateUpdate();
        this.emitter.emit("stateUpdate", {
          oldState,
          newState
        }).catch(trackError);
      }
    }
    sendStateUpdate() {
      try {
        this.connectionPort.postMessage({
          type: "StateUpdate",
          iframeMode: this.descriptor.mode,
          state: this.internalState
        });
      } catch (e2) {
      }
    }
    isDispatchStateActionMessage(msg) {
      if (msg.type !== "DispatchStateActions") {
        return false;
      }
      this.checkIframeMode(msg);
      return true;
    }
    isRequestStateMessage(msg) {
      if (msg.type !== "RequestState") {
        return false;
      }
      this.checkIframeMode(msg);
      return true;
    }
    checkIframeMode(msg) {
      if (msg.iframeMode !== this.descriptor.mode) {
        throw new Error(`Received incorrect iframe mode message! Expected: ${this.descriptor.mode}, got: ${msg.iframeMode}`);
      }
    }
  }) || _class$4);
  content;
  function getOverrideSelectors(override) {
    const selectors = [];
    if (override.predicate) {
      selectors.push(...getPredicateSelectors(override.predicate));
    }
    selectors.push(...override.rules.flatMap(getRuleSelectors));
    return new Set(selectors);
  }
  function getPredicateSelectors(predicate) {
    switch (predicate.type) {
      case "elementExists":
        return [predicate.selector];
      case "all":
      case "atLeastOne":
        return predicate.predicates.flatMap(getPredicateSelectors);
    }
  }
  function getRuleSelectors(rule) {
    const predicateSelectors = rule.predicate ? getPredicateSelectors(rule.predicate) : [];
    if (rule.type === "noForm" || rule.type === "formKindHint") {
      return predicateSelectors;
    }
    if (!rule.selectors) {
      return predicateSelectors;
    }
    return [...predicateSelectors, ...Object.values(rule.selectors).filter((sel) => sel !== null)];
  }
  content;
  function getSelector(el2) {
    const root2 = el2.getRootNode();
    const rootEl = root2 === document ? document.documentElement : root2 instanceof ShadowRoot ? [...root2.children].find((ch2) => ch2.contains(el2)) : void 0;
    if (!rootEl) {
      return "";
    }
    try {
      return finder(el2, {
        root: rootEl,
        className: (name) => !name.startsWith("hlDebug")
      });
    } catch (e2) {
      return "";
    }
  }
  content;
  function htmlToElement(html) {
    const template = document.createElement("template");
    template.innerHTML = html.trim();
    const element = template.content.firstChild;
    return element;
  }
  content;
  function getTarget(e2, predicate) {
    const composedPath = e2.composedPath();
    const target = composedPath[0] ?? e2.target;
    if (!(target instanceof HTMLElement)) {
      return null;
    }
    let targetMatchingPredicate = target;
    while (targetMatchingPredicate) {
      if (predicate(targetMatchingPredicate)) {
        return targetMatchingPredicate;
      }
      targetMatchingPredicate = getParentWithShadowDom(targetMatchingPredicate);
    }
    return null;
  }
  function captureNextClick(predicate) {
    return new Promise((resolve, reject) => {
      const handleClick = (e2) => {
        e2.preventDefault();
        e2.stopImmediatePropagation();
        const target = getTarget(e2, predicate);
        removeListeners();
        if (target) {
          resolve(target);
        } else {
          reject();
        }
      };
      const handleKeyup = (e2) => {
        if (e2.key === "Escape") {
          removeListeners();
          reject();
        }
      };
      function removeListeners() {
        document.removeEventListener("click", handleClick, true);
        document.removeEventListener("keyup", handleKeyup, true);
      }
      document.addEventListener("click", handleClick, true);
      document.addEventListener("keyup", handleKeyup, true);
    });
  }
  function injectHighlighter() {
    const highlighterElement = htmlToElement(`
    <div 
      style="
        display: none;
        position: absolute; 
        z-index: ${Number.MAX_SAFE_INTEGER};
        pointer-events: none !important;
        box-sizing: border-box;
        padding: 5px;
        outline: 5px dashed #f00;
        background: rgb(255 0 0 / 30%);
        color: black;
        font-size: 12px;
        font-family: monospace;
        text-shadow: 0 0 5px white, 0 0 5px white, 0 0 5px white;
      "
    />
  `);
    document.body.appendChild(highlighterElement);
    return highlighterElement;
  }
  function injectStyleOverride() {
    const styleElement = htmlToElement(`
    <style>
    * {
      pointer-events: auto !important;
    }
    </style>
  `);
    document.head.appendChild(styleElement);
    return styleElement;
  }
  async function selectElement(predicate) {
    const highlighterElement = injectHighlighter();
    const styleOverrideElement = injectStyleOverride();
    const disabledElements = querySelectorAllWithShadowRoots("button:disabled, input:disabled");
    disabledElements.forEach((el2) => {
      el2.disabled = false;
    });
    let currentTarget;
    function handleMousemove(e2) {
      const target = getTarget(e2, predicate);
      if (target === currentTarget) {
        return;
      }
      currentTarget = target;
      if (target) {
        const box = getBox(target);
        if (box) {
          const selector2 = getSelector(target);
          highlighterElement.textContent = `${selector2} | ${target.tagName.toLowerCase()}`;
          highlighterElement.style.display = `block`;
          highlighterElement.style.top = `${box.top}px`;
          highlighterElement.style.left = `${box.left}px`;
          highlighterElement.style.width = `${box.width}px`;
          highlighterElement.style.height = `${box.height}px`;
          return;
        }
      }
      highlighterElement.style.display = `none`;
    }
    document.addEventListener("mousemove", handleMousemove);
    try {
      const result2 = await captureNextClick(predicate);
      return result2;
    } finally {
      document.removeEventListener("mousemove", handleMousemove);
      highlighterElement.remove();
      styleOverrideElement.remove();
      disabledElements.forEach((el2) => {
        el2.disabled = true;
      });
    }
  }
  content;
  class OverrideCreateOverlayManager {
    constructor(formTracker) {
      __publicField(this, "iframeManager");
      __publicField(this, "connectionPort");
      __publicField(this, "iframeStateManager");
      __publicField(this, "handleLoginFormChange", () => {
        this.updateAppliedInfoAndReplaceFlag();
      });
      __publicField(this, "handleStateUpdate", ({
        oldState,
        newState
      }) => {
        var _a3, _b;
        if (oldState.intrinsicSize !== newState.intrinsicSize || oldState.align !== newState.align) {
          this.iframeManager.updatePosition();
        }
        if (oldState.override !== newState.override) {
          this.handleOverrideChangedDebounced();
        }
        if (((_a3 = oldState.selectElementState) == null ? void 0 : _a3.state) !== "inProgress" && ((_b = newState.selectElementState) == null ? void 0 : _b.state) === "inProgress") {
          this.selectElement(newState.selectElementState.tagNames).catch(trackError);
        }
      });
      __publicField(this, "handleStorageChanged", (changes) => {
        if (changes.overrideInCreation === void 0) {
          return;
        }
        if (!Ee$1(this.iframeStateManager.state.override, changes.overrideInCreation.newValue)) {
          this.iframeStateManager.updateState({
            override: changes.overrideInCreation.newValue
          });
        }
      });
      __publicField(this, "handleOverrideChangedDebounced", debounce$1(500, () => this.handleOverrideChanged()));
      this.formTracker = formTracker;
      const connectionId = newUuid$1();
      this.connectionPort = openConnection("ForwardContent", connectionId);
      const search = new URLSearchParams({
        connectionId,
        mode: "overrideCreate",
        url: window.location.href
      }).toString();
      const url = `${browser$1.runtime.getURL("iframe.html")}?${search}`;
      this.iframeManager = new IframePositionManager({
        url,
        anchor: {
          top: 0,
          left: 0
        },
        margin: 0,
        getOverlayBox: this.getBox.bind(this),
        getOverlayTargetElement: () => void 0
      });
      this.iframeStateManager = new IframeStateManager(overrideCreateIframeStateDescriptor, this.connectionPort);
    }
    async init() {
      this.formTracker.on("loginFormChanged", this.handleLoginFormChange);
      this.iframeStateManager.on("stateUpdate", this.handleStateUpdate);
      browser$1.storage.local.onChanged.addListener(this.handleStorageChanged);
      this.iframeStateManager.updateState({
        ...this.getAppliedInfoAndReplaceFlagUpdate(),
        hostname: window.location.hostname
      });
      const {
        overrideInCreation
      } = await browser$1.storage.local.get("overrideInCreation");
      if (overrideInCreation) {
        this.iframeStateManager.updateState({
          override: overrideInCreation
        });
      }
      this.iframeManager.init();
      this.iframeManager.updatePosition();
    }
    async close() {
      this.formTracker.off("loginFormChanged", this.handleLoginFormChange);
      this.iframeStateManager.off("stateUpdate", this.handleStateUpdate);
      this.iframeManager.close();
    }
    handleOverrideChanged() {
      this.updateSelectorResults();
      this.updateDebugOverride().catch(trackError);
      browser$1.storage.local.set({
        overrideInCreation: this.iframeStateManager.state.override
      }).catch(trackError);
    }
    updateSelectorResults() {
      if (!this.iframeStateManager.state.override) {
        return;
      }
      const selectors = getOverrideSelectors(this.iframeStateManager.state.override);
      const newSelectorResults = {};
      for (const selector2 of selectors) {
        if (selector2 !== "") {
          try {
            newSelectorResults[selector2] = querySelectorWithShadowRoots(selector2) ? "found" : "notFound";
          } catch (e2) {
            newSelectorResults[selector2] = "malformed";
          }
        }
      }
      this.iframeStateManager.updateState({
        selectorResults: newSelectorResults
      });
    }
    async updateDebugOverride() {
      await this.formTracker.setDebugOverride(this.iframeStateManager.state.override);
      this.updateAppliedInfoAndReplaceFlag();
    }
    async selectElement(tagNames) {
      let element;
      try {
        element = await selectElement((el2) => el2 instanceof HTMLElement && (tagNames ? tagNames.includes(el2.tagName.toLowerCase()) : true));
        this.iframeStateManager.updateState({
          selectElementState: {
            state: "done",
            selector: getSelector(element)
          }
        });
      } catch (e2) {
        this.iframeStateManager.updateState({
          selectElementState: void 0
        });
      }
    }
    updateAppliedInfoAndReplaceFlag() {
      this.iframeStateManager.updateState(this.getAppliedInfoAndReplaceFlagUpdate());
    }
    getAppliedInfoAndReplaceFlagUpdate() {
      return {
        appliedInfo: this.formTracker.forms.appliedOverride,
        overrideIsReplace: this.formTracker.debugOverrideIsReplace
      };
    }
    getBox() {
      if (this.iframeStateManager.state.align === "right") {
        return {
          box: {
            top: 0,
            left: window.document.documentElement.clientLeft + window.document.documentElement.clientWidth - this.iframeStateManager.state.intrinsicSize.width,
            ...this.iframeStateManager.state.intrinsicSize
          }
        };
      }
      return {
        box: {
          top: 0,
          left: 0,
          ...this.iframeStateManager.state.intrinsicSize
        }
      };
    }
  }
  content;
  class FormDetectionDebug {
    constructor(formTracker, totpQrDetector) {
      __publicField(this, "zIndexHelperEl");
      __publicField(this, "testInProgress", false);
      __publicField(this, "styleElements", []);
      __publicField(this, "detectedForms");
      __publicField(this, "detectedTotpQr");
      __publicField(this, "overrideCreatorOverlayManager");
      __publicField(this, "formDetectionPerformanceTracker");
      __publicField(this, "handleDebugModeChange", () => {
        this.updateState();
      });
      __publicField(this, "handleFormsChanged", ({
        newForms
      }) => {
        this.removeDataAttributes();
        this.detectedForms = newForms;
        this.addDataAttributes();
      });
      __publicField(this, "handleTotpQrChanged", ({
        newTotpQr
      }) => {
        this.removeDataAttributes();
        this.detectedTotpQr = newTotpQr;
        this.addDataAttributes();
      });
      __publicField(this, "handleKeyDown", (e2) => {
        if (this.testInProgress || !e2.ctrlKey) {
          return;
        }
        (async () => {
          if (e2.key === "A") {
            this.testInProgress = true;
            await this.testIsVisible();
          }
          if (e2.key === "Z") {
            this.testInProgress = true;
            await this.testGetZIndex();
          }
          if (e2.key === "D") {
            this.testInProgress = true;
            await this.rerunDetection();
          }
          if (e2.key === "F") {
            this.testInProgress = true;
            await this.toggleOverrideCreator();
          }
          if (e2.key === "P") {
            this.testInProgress = true;
            this.toggleFormDetectionPerformanceTracker();
          }
        })().finally(() => {
          this.testInProgress = false;
        }).catch(trackError);
      });
      this.formTracker = formTracker;
      this.totpQrDetector = totpQrDetector;
    }
    init() {
      debugMode.on("change", this.handleDebugModeChange);
      this.updateState();
    }
    close() {
      debugMode.off("change", this.handleDebugModeChange);
      this.tearDown();
    }
    updateState() {
      if (debugMode.debug) {
        this.setUp();
      } else {
        this.tearDown();
      }
    }
    setUp() {
      this.formTracker.on("formsChanged", this.handleFormsChanged);
      this.totpQrDetector.on("totpQrChanged", this.handleTotpQrChanged);
      document.addEventListener("keydown", this.handleKeyDown);
      this.handleFormsChanged({
        newForms: this.formTracker.forms
      });
      if (new URLSearchParams(window.location.search).has("HEYPERF")) {
        this.toggleFormDetectionPerformanceTracker();
      }
    }
    tearDown() {
      var _a3;
      for (const styleElement of this.styleElements) {
        styleElement.remove();
      }
      this.formTracker.off("formsChanged", this.handleFormsChanged);
      this.totpQrDetector.off("totpQrChanged", this.handleTotpQrChanged);
      document.removeEventListener("keydown", this.handleKeyDown);
      this.removeDataAttributes();
      this.detectedForms = void 0;
      this.closeOverrideCreator().catch(trackError);
      (_a3 = this.formDetectionPerformanceTracker) == null ? void 0 : _a3.close();
    }
    toggleFormDetectionPerformanceTracker() {
      if (this.formDetectionPerformanceTracker) {
        debugConsole.log("[FormDetectionDebug]", "Closing FormDetectionPerformanceTracker");
        this.formDetectionPerformanceTracker.close();
        this.formDetectionPerformanceTracker = void 0;
      } else {
        debugConsole.log("[FormDetectionDebug]", "Opening FormDetectionPerformanceTracker");
        this.formDetectionPerformanceTracker = new FormDetectionPerformanceTracker(this.formTracker);
        this.formDetectionPerformanceTracker.init();
      }
    }
    async testIsVisible() {
      const el2 = await selectElement((arg) => true);
      debugConsole.log("[FormDetectionDebug]", isVisible(el2));
    }
    async testGetZIndex() {
      var _a3;
      const targetEl = await selectElement((pickEl) => true);
      const zIndex = getZIndexInDocumentElement(targetEl);
      debugConsole.log("[FormDetectionDebug]", targetEl, zIndex);
      const {
        top,
        left
      } = getBox(targetEl);
      (_a3 = this.zIndexHelperEl) == null ? void 0 : _a3.remove();
      this.zIndexHelperEl = document.createElement("div");
      Object.assign(this.zIndexHelperEl.style, {
        width: "100px",
        height: "100px",
        position: "fixed",
        top: top + "px",
        left: left + "px",
        border: "5px solid #f0f",
        background: "rgb(255 0 255 / 10%)",
        textAlign: "right",
        zIndex: zIndex + 1
      });
      this.zIndexHelperEl.innerText = `z: ${zIndex + 1}`;
      if (document.body) {
        document.body.after(this.zIndexHelperEl);
      } else {
        document.documentElement.appendChild(this.zIndexHelperEl);
      }
    }
    async rerunDetection() {
      await this.formTracker.updateForms();
      debugConsole.log("[FormDetectionDebug]", this.formTracker.forms);
    }
    async toggleOverrideCreator() {
      if (this.overrideCreatorOverlayManager) {
        await this.closeOverrideCreator();
      } else {
        await this.openOverrideCreator();
      }
    }
    async openOverrideCreator() {
      await this.closeOverrideCreator();
      this.overrideCreatorOverlayManager = new OverrideCreateOverlayManager(this.formTracker);
      await this.overrideCreatorOverlayManager.init();
    }
    async closeOverrideCreator() {
      var _a3;
      await ((_a3 = this.overrideCreatorOverlayManager) == null ? void 0 : _a3.close());
      this.overrideCreatorOverlayManager = void 0;
    }
    removeDataAttributes() {
      var _a3, _b, _c2, _d, _e, _f;
      if ((_a3 = this.detectedForms) == null ? void 0 : _a3.login) {
        for (const [key, el2] of Object.entries((_b = this.detectedForms) == null ? void 0 : _b.login)) {
          if (Array.isArray(el2)) {
            el2.forEach((e2) => e2.removeAttribute(`data-hlDebug${capitalize(key)}`));
          } else {
            el2 == null ? void 0 : el2.removeAttribute(`data-hlDebug${capitalize(key)}`);
          }
        }
      }
      if ((_c2 = this.detectedForms) == null ? void 0 : _c2.registration) {
        for (const [key, el2] of Object.entries((_d = this.detectedForms) == null ? void 0 : _d.registration)) {
          el2 == null ? void 0 : el2.removeAttribute(`data-hlDebug${capitalize(key)}`);
          el2 == null ? void 0 : el2.removeAttribute("data-hlDebugRegistration");
        }
      }
      if ((_e = this.detectedTotpQr) == null ? void 0 : _e.element) {
        (_f = this.detectedTotpQr) == null ? void 0 : _f.element.removeAttribute("data-hlDebugTotpQrElement");
      }
    }
    addDataAttributes() {
      var _a3, _b;
      const detectedForms = this.detectedForms;
      if (detectedForms == null ? void 0 : detectedForms.login) {
        for (const [key, el2] of Object.entries(detectedForms.login)) {
          if (Array.isArray(el2)) {
            el2.forEach((e2) => {
              this.ensureStyle(e2);
              e2.setAttribute(`data-hlDebug${capitalize(key)}`, "");
            });
          } else {
            this.ensureStyle(el2);
            el2 == null ? void 0 : el2.setAttribute(`data-hlDebug${capitalize(key)}`, "");
          }
        }
      }
      if (detectedForms == null ? void 0 : detectedForms.registration) {
        for (const [key, el2] of Object.entries(detectedForms.registration)) {
          this.ensureStyle(el2);
          el2 == null ? void 0 : el2.setAttribute(`data-hlDebug${capitalize(key)}`, "");
          el2 == null ? void 0 : el2.setAttribute("data-hlDebugRegistration", "");
        }
      }
      if ((_a3 = this.detectedTotpQr) == null ? void 0 : _a3.element) {
        (_b = this.detectedTotpQr) == null ? void 0 : _b.element.setAttribute("data-hlDebugTotpQrElement", "");
      }
    }
    ensureStyle(el2) {
      if (typeof el2 !== "object" || el2 === null || !(el2 instanceof HTMLElement)) {
        return;
      }
      const rootNode = el2.getRootNode();
      const target = rootNode === document ? document.documentElement : rootNode instanceof ShadowRoot ? rootNode : void 0;
      if (!target || this.styleElements.some((styleElement2) => styleElement2.parentNode === target)) {
        return;
      }
      const styleElement = this.createStyleElement();
      target.appendChild(styleElement);
      this.styleElements.push(styleElement);
    }
    createStyleElement() {
      const styleElement = document.createElement("style");
      styleElement.textContent = `
        [data-hlDebugContainerElement],
        [data-hlDebugFormElement],
        [data-hlDebugUsernameElement],
        [data-hlDebugPasswordElement],
        [data-hlDebugRepeatPasswordElement],
        [data-hlDebugSubmitElement],
        [data-hlDebugStayLoggedInElement],
        [data-hlDebugTotpElement],
        [data-hlDebugTotpElements],
        [data-hlDebugTotpQrElement]  {
          --hl-debug-style: solid;
          outline: 5px var(--hl-debug-style) var(--hl-debug-color) !important;
        }
        [data-hlDebugRegistration] {
          --hl-debug-style: dashed;
        }
        [data-hlDebugFormElement] {
          --hl-debug-color: #0f0;
        }
        [data-hlDebugContainerElement]:not([data-hlDebugFormElement]) {
          --hl-debug-color: #000;
        }
        [data-hlDebugUsernameElement] {
          --hl-debug-color: #0ff;
        }
        [data-hlDebugPasswordElement] {
          --hl-debug-color: #ff0;
        }
        [data-hlDebugRepeatPasswordElement] {
          --hl-debug-color: rebeccapurple;
        }
        [data-hlDebugSubmitElement] {
          --hl-debug-color: #f00;
        }
        [data-hlDebugStayLoggedInElement] {
          --hl-debug-color: #00f;
        }
        [data-hlDebugTotpElements] {
          --hl-debug-color: #8e47ff;
        }
        [data-hlDebugTotpQrElement] {
          --hl-debug-color: #f99;
        }
      `;
      return styleElement;
    }
  }
  function capitalize(s2) {
    return s2.charAt(0).toUpperCase() + s2.slice(1);
  }
  content;
  var _dec$3, _class$3;
  let FormTracker = (_dec$3 = Emittery$3.mixin("emitter"), _dec$3(_class$3 = class FormTracker2 {
    constructor() {
      __publicField(this, "detectedForms", {
        login: null,
        registration: null
      });
      __publicField(this, "mutationObserver");
      __publicField(this, "overrideLoginFormAsRegistration", false);
      __publicField(this, "overrideLibrary");
      __publicField(this, "debugOverride");
      __publicField(this, "computedOverrides");
      __publicField(this, "handleMessage", makeMessageListener({
        UrlUpdate: () => this.updateForms(),
        OverridesUpdate: async () => {
          this.computedOverrides = await this.getComputedOverrideLibrary(true);
          await this.updateForms();
        }
      }));
      __publicField(this, "handleMutations", (mutations) => {
        const changedNodes = mutations.flatMap((m2) => [m2.target, ...m2.addedNodes, ...m2.removedNodes]);
        if (
          // too many changed nodes to check all of them individually, so we just do the form update
          changedNodes.length > 100 || // one of the nodes changed or their children is an element related to html forms
          changedNodes.some((n2) => n2 instanceof HTMLElement && (["input", "button", "form"].includes(n2.tagName.toLowerCase()) || n2.querySelector("input, button, form")))
        ) {
          this.updateFormsRaf();
        }
      });
      __publicField(this, "updateFormsRafId", NaN);
      __publicField(this, "detectFormsContext");
      __publicField(this, "updateFormsRaf", () => {
        var _a3;
        window.cancelAnimationFrame(this.updateFormsRafId);
        (_a3 = this.detectFormsContext) == null ? void 0 : _a3.cancel();
        this.updateFormsRafId = window.requestAnimationFrame(() => {
          this.updateForms().catch(trackError);
        });
      });
      this.mutationObserver = new ShadowRootAwareMutationObserver(this.handleMutations, this.updateFormsRaf);
    }
    get forms() {
      return this.detectedForms;
    }
    get loginElements() {
      return this.detectedForms.login;
    }
    get registrationElements() {
      return this.detectedForms.registration;
    }
    get debugOverrideIsReplace() {
      var _a3;
      return !!((_a3 = this.computedOverrides) == null ? void 0 : _a3.debugOverrideIsReplace);
    }
    init() {
      this.updateForms().catch(trackError);
      this.mutationObserver.observe(document.getRootNode());
      window.addEventListener("transitionend", this.updateFormsRaf);
      window.addEventListener("transitioncancel", this.updateFormsRaf);
      window.addEventListener("animationend", this.updateFormsRaf);
      window.addEventListener("animationcancel", this.updateFormsRaf);
      window.addEventListener("change", this.updateFormsRaf, true);
      browser$1.runtime.onMessage.addListener(this.handleMessage);
    }
    close() {
      this.mutationObserver.disconnect();
      window.removeEventListener("transitionend", this.updateFormsRaf);
      window.removeEventListener("transitioncancel", this.updateFormsRaf);
      window.removeEventListener("animationend", this.updateFormsRaf);
      window.removeEventListener("animationcancel", this.updateFormsRaf);
      window.removeEventListener("change", this.updateFormsRaf, true);
      browser$1.runtime.onMessage.removeListener(this.handleMessage);
    }
    setOverrideLoginFormAsRegistration(value) {
      if (this.overrideLoginFormAsRegistration === value) {
        return;
      }
      this.overrideLoginFormAsRegistration = value;
      this.updateForms().catch(trackError);
    }
    async setDebugOverride(debugOverride) {
      if (this.debugOverride === debugOverride) {
        return;
      }
      this.debugOverride = debugOverride;
      this.computedOverrides = await this.getComputedOverrideLibrary();
      await this.updateForms();
    }
    async updateForms() {
      var _a3;
      (_a3 = this.detectFormsContext) == null ? void 0 : _a3.cancel();
      const detectionStartTimestamp = performance.now();
      if (!this.computedOverrides) {
        this.computedOverrides = await this.getComputedOverrideLibrary();
      }
      this.detectFormsContext = new DetectFormsContext(this.computedOverrides.library);
      const oldForms = this.detectedForms;
      let newForms;
      try {
        newForms = await detectForms(this.detectFormsContext);
      } catch (e2) {
        if (e2 instanceof DetectFormsCanceled) {
          this.emitDetectionEnd(detectionStartTimestamp, true);
          return;
        }
        throw e2;
      }
      if (this.overrideLoginFormAsRegistration && newForms.login && newForms.login.passwordElement) {
        newForms = {
          login: null,
          registration: {
            ...newForms.login,
            repeatPasswordElement: null
          }
        };
      }
      if (!detectedFormsEqual(oldForms, newForms)) {
        debugConsole.log("[FormTracker]", "found new forms", newForms);
        this.detectedForms = newForms;
        this.emitChangeEvents(oldForms, newForms).catch(trackError);
      }
      this.emitDetectionEnd(detectionStartTimestamp, false);
    }
    emitDetectionEnd(detectionStartTimestamp, cancelled) {
      this.emitter.emit("detectionEnd", {
        detectionEndMs: performance.now(),
        detectionStartMs: detectionStartTimestamp,
        cancelled
      }).catch(trackError);
    }
    async getComputedOverrideLibrary(forceRefreshOverrideLibrary = false) {
      let library = this.overrideLibrary ?? [];
      if (library.length === 0 || forceRefreshOverrideLibrary) {
        const freshLibrary = await sendMessage({
          type: "GetOverrideLibrary"
        });
        if (freshLibrary !== messageError) {
          library = freshLibrary;
        }
      }
      if (!this.debugOverride) {
        return {
          library
        };
      }
      const debugOverride = this.debugOverride;
      const debugOverrideIndex = library.findIndex((o2) => o2.id === debugOverride.id);
      if (debugOverrideIndex === -1) {
        return {
          library: [...library, debugOverride]
        };
      }
      const overrideLibraryWithDebug = [...library];
      overrideLibraryWithDebug.splice(debugOverrideIndex, 1, debugOverride);
      return {
        library: overrideLibraryWithDebug,
        debugOverrideIsReplace: true
      };
    }
    async emitChangeEvents(oldForms, newForms) {
      const eventPromises = [this.emitter.emit("formsChanged", {
        oldForms,
        newForms,
        context: {
          overrideLoginFormAsRegistration: this.overrideLoginFormAsRegistration
        }
      })];
      if (!loginFormElementsEqual(oldForms.login, newForms.login)) {
        eventPromises.push(this.emitter.emit("loginFormChanged", {
          oldLoginForm: oldForms.login,
          newLoginForm: newForms.login
        }));
      }
      if (!registrationFormElementsEqual(oldForms.registration, newForms.registration)) {
        eventPromises.push(this.emitter.emit("registrationFormChanged", {
          oldRegistrationForm: oldForms.registration,
          newRegistrationForm: newForms.registration
        }));
      }
      await Promise.all(eventPromises);
    }
  }) || _class$3);
  function detectedFormsEqual(left, right) {
    return loginFormElementsEqual(left.login, right.login) && registrationFormElementsEqual(left.registration, right.registration) && Ee$1(left.appliedOverride, right.appliedOverride);
  }
  function loginFormElementsEqual(left, right) {
    const leftTotpEls = left == null ? void 0 : left.totpElements;
    const rightTotpEls = right == null ? void 0 : right.totpElements;
    return (left == null ? void 0 : left.passwordElement) === (right == null ? void 0 : right.passwordElement) && (left == null ? void 0 : left.usernameElement) === (right == null ? void 0 : right.usernameElement) && (left == null ? void 0 : left.submitElement) === (right == null ? void 0 : right.submitElement) && (left == null ? void 0 : left.stayLoggedInElement) === (right == null ? void 0 : right.stayLoggedInElement) && (left == null ? void 0 : left.formElement) === (right == null ? void 0 : right.formElement) && (leftTotpEls === rightTotpEls || Array.isArray(leftTotpEls) && Array.isArray(rightTotpEls) && leftTotpEls.length === rightTotpEls.length && leftTotpEls.every((el2, i2) => el2 === rightTotpEls[i2]));
  }
  function registrationFormElementsEqual(left, right) {
    return (left == null ? void 0 : left.formElement) === (right == null ? void 0 : right.formElement) && (left == null ? void 0 : left.passwordElement) === (right == null ? void 0 : right.passwordElement) && (left == null ? void 0 : left.repeatPasswordElement) === (right == null ? void 0 : right.repeatPasswordElement) && (left == null ? void 0 : left.usernameElement) === (right == null ? void 0 : right.usernameElement) && (left == null ? void 0 : left.submitElement) === (right == null ? void 0 : right.submitElement);
  }
  content;
  function getTextContentWithShadowDom(rootNode) {
    if (!rootNode) {
      return "";
    }
    const roots = [rootNode, ...getShadowRoots(rootNode)];
    return roots.map((r2) => r2.textContent ?? "").join("");
  }
  function getShadowRoots(rootNode) {
    const allEls = Array.from(rootNode.querySelectorAll("*"));
    return allEls.flatMap((el2) => {
      const shadowRoot = getShadowRoot(el2);
      if (shadowRoot) {
        return [shadowRoot, ...getShadowRoots(shadowRoot)];
      }
      return [];
    });
  }
  content;
  function setInputValue(input, value) {
    setNativeValue(input, value);
    input.focus();
    (async () => {
      for (const el2 of eventSequence) {
        if (el2.type === "event") {
          const event = new el2.constructor(el2.name, {
            bubbles: true,
            // Ensure that event propagates outside of shadow dom tree, see
            // https://pm.dartus.fr/posts/2021/shadow-dom-and-event-propagation/#what-about-standard-events
            composed: true
          });
          input.dispatchEvent(event);
          setNativeValue(input, value);
        } else if (el2.type === "pause") {
          await sleep(el2.ms);
        }
      }
    })().catch(trackError);
  }
  const eventSequence = [
    {
      type: "event",
      name: "focus",
      constructor: FocusEvent
    },
    {
      type: "event",
      name: "click",
      constructor: MouseEvent
    },
    {
      type: "event",
      name: "keydown",
      constructor: KeyboardEvent
    },
    {
      type: "event",
      name: "keypress",
      constructor: KeyboardEvent
    },
    // for inputs that are react controlled components, see https://stackoverflow.com/a/60378508
    {
      type: "event",
      name: "input",
      constructor: InputEvent
    },
    {
      type: "event",
      name: "keyup",
      constructor: KeyboardEvent
    },
    {
      type: "event",
      name: "change",
      constructor: Event
    },
    // Fix for apple.com: they debounce their event handling but still require the input to be focused
    // when the event is finally handled, so we slightly delay the blur event.
    {
      type: "pause",
      ms: 75
    },
    {
      type: "event",
      name: "blur",
      constructor: FocusEvent
    }
  ];
  function setNativeValue(element, value) {
    const {
      set: valueSetter
    } = Object.getOwnPropertyDescriptor(element, "value") || {};
    const prototype = Object.getPrototypeOf(element);
    const {
      set: prototypeValueSetter
    } = Object.getOwnPropertyDescriptor(prototype, "value") || {};
    if (prototypeValueSetter && valueSetter !== prototypeValueSetter) {
      prototypeValueSetter.call(element, value);
    } else if (valueSetter) {
      valueSetter.call(element, value);
    } else {
      element.value = value;
    }
  }
  content;
  function submitForm(inputElement, submitElement) {
    if (inputElement.form) {
      simulateSubmitViaForm(inputElement, inputElement.form);
    } else {
      simulateSubmitWithoutForm(inputElement, submitElement);
    }
  }
  function simulateSubmitViaForm(inputElement, formElement) {
    try {
      dispatchThrowOnPreventDefault(inputElement, createEnterKeyEvent("keydown"));
      dispatchThrowOnPreventDefault(inputElement, createEnterKeyEvent("keypress"));
      implicitSubmit(formElement);
    } catch (e2) {
      if (!(e2 instanceof Cancel)) {
        throw e2;
      }
    } finally {
      inputElement.dispatchEvent(createEnterKeyEvent("keyup"));
    }
  }
  const INPUT_TYPES_BLOCKING_IMPLICIT_FORM_SUBMISSION = ["text", "search", "url", "tel", "email", "password", "date", "month", "week", "time", "datetime-local", "number"];
  function implicitSubmit(formElement) {
    const defaultSubmitButton = getFormDefaultButton(formElement);
    if (defaultSubmitButton) {
      const clickEvent = new PointerEvent("click", {
        view: window,
        bubbles: true,
        cancelable: true
      });
      const formSubmitted = listenForSubmitDuringCallback(formElement, () => {
        dispatchThrowOnPreventDefault(defaultSubmitButton, clickEvent);
      });
      if (formSubmitted) {
        return;
      }
    }
    const newDefaultSubmitButton = getFormDefaultButton(formElement);
    if (newDefaultSubmitButton) {
      formElement.requestSubmit(newDefaultSubmitButton);
    } else {
      const blockingFields = Array.from(formElement.querySelectorAll("input")).filter((el2) => el2.form === formElement && INPUT_TYPES_BLOCKING_IMPLICIT_FORM_SUBMISSION.includes(el2.type));
      if (blockingFields.length <= 1) {
        formElement.requestSubmit();
      }
    }
  }
  function listenForSubmitDuringCallback(formElement, cb2) {
    let formSubmitted = false;
    const handleFormSubmit = () => {
      formSubmitted = true;
      formElement.removeEventListener("submit", handleFormSubmit);
    };
    try {
      formElement.addEventListener("submit", handleFormSubmit);
      cb2();
    } finally {
      formElement.removeEventListener("submit", handleFormSubmit);
    }
    return formSubmitted;
  }
  function simulateSubmitWithoutForm(passwordElement, submitElement) {
    try {
      dispatchThrowOnPreventDefault(passwordElement, createEnterKeyEvent("keydown"));
      dispatchThrowOnPreventDefault(passwordElement, createEnterKeyEvent("keypress"));
    } catch (e2) {
      if (!(e2 instanceof Cancel)) {
        throw e2;
      }
    } finally {
      passwordElement.dispatchEvent(createEnterKeyEvent("keyup"));
    }
    if (submitElement) {
      submitElement.click();
    }
  }
  function dispatchThrowOnPreventDefault(element, event) {
    const noPreventDefault = element.dispatchEvent(event);
    if (!noPreventDefault) {
      throw new Cancel();
    }
  }
  function createEnterKeyEvent(type) {
    const key = "Enter";
    const keyCode = 13;
    const event = new KeyboardEvent(type, {
      view: window,
      bubbles: true,
      cancelable: true,
      // Ensure that event propagates outside of shadow dom tree, see
      // https://pm.dartus.fr/posts/2021/shadow-dom-and-event-propagation/#what-about-standard-events
      composed: true,
      key,
      code: key,
      // @ts-ignore property is deprecated and thus not in typings, but some webpages may still use it
      keyCode,
      // @ts-ignore property is deprecated and thus not in typings, but some webpages may still use it
      which: keyCode
    });
    return event;
  }
  content;
  const loginIframeStateDescriptor = {
    mode: "login",
    initialState: {
      intrinsicSize: {
        width: 0,
        height: 0
      }
    },
    reducer: (state, action) => {
      switch (action.type) {
        case "setIntrinsicSize":
          return {
            ...state,
            intrinsicSize: action.size
          };
        case "hide":
        case "updateLoginAndFillForm":
          return state;
      }
    }
  };
  content;
  const autosnatchIframeStateDescriptor = {
    mode: "autosnatch",
    initialState: {
      intrinsicSize: {
        width: 0,
        height: 0
      },
      expanded: false,
      visible: false,
      pageHasLogins: false
    },
    reducer: (state, action) => {
      switch (action.type) {
        case "setIntrinsicSize":
          return {
            ...state,
            intrinsicSize: action.size
          };
        case "setExpanded":
          return {
            ...state,
            expanded: action.expanded
          };
        case "setVisible":
          return {
            ...state,
            visible: action.visible
          };
        case "setAutosnatchTargetOverride":
          return {
            ...state,
            autosnatchTargetOverride: action.autosnatchTargetOverride
          };
        case "showPasswordGenerator":
        case "showLoginOverlay":
          return {
            ...state,
            expanded: false
          };
      }
    }
  };
  content;
  const AUTOSNATCH_OVERLAY_MAX_COLLAPSED_HEIGHT = 28;
  class AutosnatchOverlayManager {
    constructor(formTracker, autoSnatch, pageLogins, showLoginOverlay) {
      __publicField(this, "iframeStateManager");
      __publicField(this, "iframePositionManager");
      __publicField(this, "connectionPort");
      __publicField(this, "handleIframeAction", (action) => {
        if (action.type === "showPasswordGenerator") {
          this.formTracker.setOverrideLoginFormAsRegistration(true);
        } else if (action.type === "showLoginOverlay") {
          this.showLoginOverlay();
        }
      });
      __publicField(this, "handleStateUpdate", ({
        oldState,
        newState
      }) => {
        if (oldState.intrinsicSize !== newState.intrinsicSize) {
          this.iframePositionManager.setIntrinsicSize(newState.intrinsicSize);
        }
        if (newState.expanded && !oldState.expanded) {
          window.addEventListener("click", this.handleClick);
          window.addEventListener("keydown", this.handleKeydown);
        }
        if (!newState.expanded && oldState.expanded) {
          window.removeEventListener("click", this.handleClick);
          window.removeEventListener("keydown", this.handleKeydown);
        }
        if (newState.visible && !oldState.visible) {
          this.formTracker.on("loginFormChanged", this.handleLoginFormChange);
          this.iframePositionManager.init();
          this.iframePositionManager.updatePosition();
        }
        if (!newState.visible && oldState.visible) {
          this.autoSnatch.setOverrideTargetVault(void 0);
          this.formTracker.off("loginFormChanged", this.handleLoginFormChange);
          this.iframePositionManager.close();
        }
        if (newState.autosnatchTargetOverride !== oldState.autosnatchTargetOverride) {
          this.autoSnatch.setOverrideTargetVault(newState.autosnatchTargetOverride);
        }
      });
      __publicField(this, "handleLoginFormChange", () => {
        this.iframePositionManager.updatePosition();
      });
      __publicField(this, "handleLoginsChanged", ({
        newLogins
      }) => {
        const pageHasLogins = newLogins.length > 0;
        if (pageHasLogins === this.iframeStateManager.state.pageHasLogins) {
          return;
        }
        this.iframeStateManager.updateState({
          pageHasLogins
        });
      });
      __publicField(this, "handleKeydown", (e2) => {
        if (!e2.defaultPrevented && e2.key === "Escape") {
          this.setOverlayExpanded(false);
        }
      });
      __publicField(this, "handleClick", (e2) => {
        if (!e2.defaultPrevented && e2.button === 0) {
          this.setOverlayExpanded(false);
        }
      });
      this.formTracker = formTracker;
      this.autoSnatch = autoSnatch;
      this.pageLogins = pageLogins;
      this.showLoginOverlay = showLoginOverlay;
      const connectionId = newUuid$1();
      this.connectionPort = openConnection("ForwardContent", connectionId);
      const search = new URLSearchParams({
        connectionId,
        mode: "autosnatch",
        url: window.location.href
      }).toString();
      const url = `${browser$1.runtime.getURL("iframe.html")}?${search}`;
      this.iframePositionManager = new IframePositionManager({
        url,
        anchor: {
          top: 0,
          left: 1
        },
        margin: 0,
        getOverlayBox: this.getPasswordFieldBox.bind(this),
        getOverlayTargetElement: () => {
          var _a3;
          return (_a3 = this.formTracker.loginElements) == null ? void 0 : _a3.containerElement;
        }
      });
      this.iframeStateManager = new IframeStateManager(autosnatchIframeStateDescriptor, this.connectionPort);
    }
    init() {
      this.iframeStateManager.on("stateUpdate", this.handleStateUpdate);
      this.iframeStateManager.on("action", this.handleIframeAction);
      this.pageLogins.on("loginsChanged", this.handleLoginsChanged);
      this.setOverlayVisible(true);
      this.iframeStateManager.updateState({
        pageHasLogins: this.pageLogins.logins.length > 0
      });
    }
    close() {
      this.iframeStateManager.off("stateUpdate", this.handleStateUpdate);
      this.iframeStateManager.off("action", this.handleIframeAction);
      this.pageLogins.off("loginsChanged", this.handleLoginsChanged);
      this.setOverlayVisible(false);
    }
    setOverlayVisible(visible) {
      if (visible === this.iframeStateManager.state.visible) {
        return;
      }
      this.iframeStateManager.updateState({
        visible
      });
    }
    setOverlayExpanded(expanded) {
      if (expanded === this.iframeStateManager.state.expanded) {
        return;
      }
      this.iframeStateManager.updateState({
        expanded
      });
    }
    getPasswordFieldBox() {
      var _a3;
      const passwdEl = (_a3 = this.formTracker.loginElements) == null ? void 0 : _a3.passwordElement;
      if (!passwdEl) {
        return {
          box: null
        };
      }
      const passwdBox = getBox(passwdEl);
      if (!passwdBox) {
        return {
          box: null
        };
      }
      const height = Math.min(passwdBox.height - 2, AUTOSNATCH_OVERLAY_MAX_COLLAPSED_HEIGHT);
      const margin = Math.round((passwdBox.height - height) / 2);
      return {
        box: {
          top: passwdBox.top + margin,
          height,
          left: passwdBox.left + passwdBox.width - margin,
          width: 0
        }
      };
    }
  }
  content;
  function getLoginOverlayLandscape(extrinsicSize) {
    const aspectRatio = extrinsicSize.width / extrinsicSize.height;
    return extrinsicSize.height < 50 || extrinsicSize.height < 100 && aspectRatio >= 2.5;
  }
  content;
  class LoginOverlayManager {
    constructor(formTracker, totpQrDetector, connectionId) {
      __publicField(this, "iframeManager");
      __publicField(this, "overlayVisible", false);
      __publicField(this, "onChange", () => {
        this.iframeManager.updatePosition();
      });
      this.formTracker = formTracker;
      this.totpQrDetector = totpQrDetector;
      const search = new URLSearchParams({
        connectionId,
        mode: "login",
        url: window.location.href
      }).toString();
      const url = `${browser$1.runtime.getURL("iframe.html")}?${search}`;
      const popupBackgroundPortrait = browser$1.runtime.getURL("images/popup-background-portrait.png");
      const popupBackgroundLandscape = browser$1.runtime.getURL("images/popup-background-landscape.png");
      const popupSpinner = browser$1.runtime.getURL("images/popup-spinner.png");
      this.iframeManager = new IframePositionManager({
        url,
        margin: 0,
        anchor: {
          top: 0.5,
          left: 0.5
        },
        getOverlayBox: this.getFormBox.bind(this),
        getOverlayTargetElement: () => {
          var _a3;
          return (_a3 = this.formTracker.loginElements) == null ? void 0 : _a3.containerElement;
        },
        additionalZIndex: 2,
        minSize: {
          width: 0,
          // Minimum height the overlay can ever have (single login in landscape mode). Settings this
          // here avoids a useless resize for very small overlays.
          height: 50
        },
        getStyle: (size) => ({
          boxShadow: T$1,
          // The color set here is var(--hl-color-outer-space-900-m), but we don't have our shared css
          // file here, so we need to state it explicitly.
          backgroundColor: "hsl(240deg 27% 22%)",
          backgroundImage: `url(${popupSpinner}), url(${getLoginOverlayLandscape(size) ? popupBackgroundLandscape : popupBackgroundPortrait})`,
          backgroundSize: "auto, 100% 100%",
          backgroundPosition: "center",
          backgroundRepeat: "no-repeat"
        }),
        attributes: {
          allow: "publickey-credentials-get *"
        }
      });
    }
    async withFrozenOverlay(cb2) {
      await this.iframeManager.withFrozenIframe(cb2);
    }
    init() {
      this.iframeManager.init();
    }
    close() {
      this.iframeManager.close();
    }
    setOverlayVisible(newOverlayVisible) {
      if (this.overlayVisible === newOverlayVisible) {
        return;
      }
      this.overlayVisible = newOverlayVisible;
      this.iframeManager.updatePosition();
      if (this.overlayVisible) {
        this.formTracker.on("formsChanged", this.onChange);
        this.totpQrDetector.on("totpQrChanged", this.onChange);
      } else {
        this.formTracker.off("formsChanged", this.onChange);
        this.totpQrDetector.off("totpQrChanged", this.onChange);
      }
    }
    setIntrinsicOverlaySize(size) {
      this.iframeManager.setIntrinsicSize(size);
    }
    getFormBox() {
      if (!this.overlayVisible) {
        return {
          box: null,
          forceHide: true
        };
      }
      const els = this.formTracker.loginElements;
      if (!els) {
        return {
          box: null
        };
      }
      const boxesToAvoidCovering = this.getElementsToAvoidCovering(els).map(getBox).filter((b2) => !!b2);
      const allElsToCover = [els.passwordElement, els.usernameElement, ...Array.isArray(els.totpElements) ? els.totpElements : [els.totpElements]];
      const elsToCover = allElsToCover.filter(useElementForOverlayPositioning);
      const additionalElsToCover = [els.stayLoggedInElement, els.submitElement, els.formElement].filter(useElementForOverlayPositioning);
      while (additionalElsToCover.length) {
        const overlayPositionCandidate = getBoxCoveringAll(...elsToCover, ...additionalElsToCover);
        if (overlayPositionCandidate && // the form must cover some size
        overlayPositionCandidate.width > 0 && overlayPositionCandidate.height > 0 && // don't make the form too large, by area and by side length
        overlayPositionCandidate.width * overlayPositionCandidate.height < 600 * 400 && overlayPositionCandidate.width < 1e3 && overlayPositionCandidate.height < 1e3 && // don't cover a box to avoid
        !boxesToAvoidCovering.some((b2) => doBoxesIntersect(b2, overlayPositionCandidate))) {
          return {
            box: overlayPositionCandidate
          };
        }
        additionalElsToCover.pop();
      }
      if (elsToCover.length === 0) {
        return {
          box: getBoxCoveringAll(...allElsToCover.filter(isNotNull))
        };
      }
      return {
        box: getBoxCoveringAll(...elsToCover)
      };
    }
    getElementsToAvoidCovering(els) {
      const registrationEls = this.formTracker.registrationElements ? Object.values(this.formTracker.registrationElements).filter(useElementForOverlayPositioning) : [];
      const iframes = Array.from(querySelectorAllWithShadowRoots("iframe", els.containerElement)).filter(isVisible);
      const formEls = Object.values(els);
      const required = Array.from(querySelectorAllWithShadowRoots("input", els.containerElement)).filter((inp) => !formEls.includes(inp) && isVisible(inp) && inp.type !== "button");
      const fileInputs = Array.from(querySelectorAllWithShadowRoots("input[type=file]", els.containerElement)).map((el2) => isVisible(el2) ? el2 : el2.parentElement).filter((el2) => !!el2);
      const captchaElements = querySelectorAllWithShadowRoots(".captcha, #captcha, .g-recaptcha", els.containerElement);
      const totpQr = this.totpQrDetector.totpQr ? [this.totpQrDetector.totpQr.element] : [];
      return [...registrationEls, ...iframes, ...required, ...fileInputs, ...captchaElements, ...totpQr];
    }
  }
  function useElementForOverlayPositioning(el2) {
    if (el2 === null) {
      return false;
    }
    return isVisible(el2);
  }
  function isNotNull(el2) {
    if (el2 === null) {
      return false;
    }
    return true;
  }
  content;
  class PasswordClearer {
    constructor() {
      __publicField(this, "els", /* @__PURE__ */ new Set());
      __publicField(this, "observer", new ShadowRootAwareMutationObserver(this.handleMutations.bind(this), () => {
      }, {
        attributeFilter: ["type"]
      }));
    }
    init() {
      this.observer.observe(document.documentElement);
    }
    close() {
      var _a3;
      (_a3 = this.observer) == null ? void 0 : _a3.disconnect();
    }
    addElement(el2) {
      this.els.add(el2);
    }
    clearPasswordAndProtectedValues() {
      for (const el2 of this.els) {
        setInputValue(el2, "");
      }
      this.els.clear();
    }
    handleMutations(mutations) {
      for (const mutation of mutations) {
        if (mutation.type === "attributes" && mutation.target instanceof HTMLInputElement && this.els.has(mutation.target) && mutation.target.type !== "password") {
          this.clearInputValue(mutation.target);
        }
      }
    }
    clearInputValue(el2) {
      debugConsole.log("[PasswordClearer]", "clearing", el2);
      setInputValue(el2, "");
      this.els.delete(el2);
    }
  }
  content;
  const totpInputIframeStateDescriptor = {
    mode: "totpInput",
    initialState: {
      expanded: false,
      overlayGeometry: void 0,
      logins: [],
      intrinsicSize: {
        width: 0,
        height: 0
      },
      selectedLoginId: void 0
    },
    reducer: (state, action) => {
      switch (action.type) {
        case "setExpanded":
          return {
            ...state,
            expanded: action.expanded
          };
        case "setIntrinsicSize":
          return {
            ...state,
            intrinsicSize: action.size
          };
        case "setSelectedLoginId":
          return {
            ...state,
            selectedLoginId: action.selectedLoginId
          };
      }
    }
  };
  content;
  async function getUnprotectedValueForContentLogin(l2, value) {
    var _a3;
    return (_a3 = await getUnprotectedValueForContentLoginWithContentId(l2, value)) == null ? void 0 : _a3.unencrypted;
  }
  async function getUnprotectedValueForContentLoginWithContentId(l2, value) {
    if (!l2.vaultMetadata) {
      return void 0;
    }
    return getUnprotectedValueForVaultWithContentId(l2.vaultMetadata.id, value);
  }
  async function getUnprotectedValueForVaultWithContentId(vaultId, value) {
    if ("unencrypted" in value) {
      return value;
    }
    const response = await sendMessage({
      type: "GetUnprotectedValue",
      vaultId,
      value
    });
    if (response === messageError) {
      return void 0;
    }
    return response;
  }
  content;
  var _dec$2, _class$2;
  const TOTP_INPUT_OVERLAY_RIGHT_OF_INPUT_COLLAPSED_SIZE = {
    width: 38,
    height: 38
  };
  const TOTP_INPUT_OVERLAY_RIGHT_OF_INPUT_MARGIN_LEFT = 6;
  const TOTP_INPUT_OVERLAY_OVERLAY_INPUT_MAX_HEIGHT = 32;
  const TOTP_INPUT_OVERLAY_OVERLAY_INPUT_MIN_HEIGHT = 16;
  const TOTP_INPUT_OVERLAY_OVERLAY_INPUT_MARGIN = 2;
  let TotpInputOverlayManager = (_dec$2 = Emittery$3.mixin("emitter"), _dec$2(_class$2 = class TotpInputOverlayManager2 {
    constructor(formTracker, pageLogins) {
      __publicField(this, "connectionPort");
      __publicField(this, "iframeStateManager");
      __publicField(this, "iframePositionManager");
      __publicField(this, "connectionId");
      __publicField(this, "overlayVisible", false);
      __publicField(this, "handleMessage", makeMessageListener({
        UnlockStateUpdate: () => this.updateTotpLogins().catch(trackError)
      }));
      __publicField(this, "handleLoginsChanged", () => {
        this.updateTotpLogins().catch(trackError);
      });
      __publicField(this, "handleStateUpdate", ({
        oldState,
        newState
      }) => {
        if (oldState.intrinsicSize !== newState.intrinsicSize) {
          this.iframePositionManager.updatePosition();
        }
        if (newState.expanded && !oldState.expanded) {
          window.addEventListener("click", this.handleClick);
          window.addEventListener("keydown", this.handleKeydown);
        } else if (!newState.expanded && oldState.expanded) {
          window.removeEventListener("click", this.handleClick);
          window.removeEventListener("keydown", this.handleKeydown);
        }
        if (newState.selectedLoginId && !oldState.selectedLoginId) {
          const login = this.iframeStateManager.state.logins.find((l2) => l2.id === newState.selectedLoginId);
          if (!login) {
            trackError(new Error("totp login not found"));
            return;
          }
          this.emitter.emit("loginSelected", {
            loginId: newState.selectedLoginId,
            totp: login.totpParameters
          }).catch(trackError);
          this.iframeStateManager.updateState({
            selectedLoginId: void 0
          });
        }
      });
      __publicField(this, "handleLoginFormChange", () => {
        this.updateOverlayPosition();
      });
      __publicField(this, "handleKeydown", (e2) => {
        if (!e2.defaultPrevented && e2.key === "Escape") {
          this.iframeStateManager.updateState({
            expanded: false
          });
        }
      });
      __publicField(this, "handleClick", (e2) => {
        if (!e2.defaultPrevented && e2.button === 0) {
          this.iframeStateManager.updateState({
            expanded: false
          });
        }
      });
      this.formTracker = formTracker;
      this.pageLogins = pageLogins;
      this.connectionId = newUuid$1();
      this.connectionPort = openConnection("ForwardContent", this.connectionId);
      const search = new URLSearchParams({
        connectionId: this.connectionId,
        mode: "totpInput",
        url: window.location.href
      });
      const url = `${browser$1.runtime.getURL("iframe.html")}?${search}`;
      this.iframePositionManager = new IframePositionManager({
        url,
        anchor: {
          top: 0,
          left: 1
        },
        margin: 0,
        getOverlayBox: this.getBox.bind(this),
        getOverlayTargetElement: this.getTotpInputElement.bind(this),
        attributes: {
          allow: "publickey-credentials-get *"
        }
      });
      this.iframeStateManager = new IframeStateManager(totpInputIframeStateDescriptor, this.connectionPort);
    }
    init() {
      this.iframeStateManager.on("stateUpdate", this.handleStateUpdate);
      this.pageLogins.on("loginsChanged", this.handleLoginsChanged);
      browser$1.runtime.onMessage.addListener(this.handleMessage);
      this.iframePositionManager.init();
      this.handleLoginsChanged();
    }
    close() {
      this.iframeStateManager.off("stateUpdate", this.handleStateUpdate);
      this.pageLogins.off("loginsChanged", this.handleLoginsChanged);
      browser$1.runtime.onMessage.removeListener(this.handleMessage);
      this.iframePositionManager.close();
    }
    setOverlayVisible(newOverlayVisible) {
      if (this.overlayVisible === newOverlayVisible) {
        return;
      }
      this.overlayVisible = newOverlayVisible;
      if (this.overlayVisible) {
        this.formTracker.on("loginFormChanged", this.handleLoginFormChange);
      } else {
        this.formTracker.off("loginFormChanged", this.handleLoginFormChange);
      }
      this.updateOverlayPosition();
    }
    updateOverlayPosition() {
      var _a3;
      this.iframeStateManager.updateState({
        overlayGeometry: (_a3 = this.getTotpInputElementData()) == null ? void 0 : _a3.overlayGeometry
      });
      this.iframePositionManager.updatePosition();
    }
    async updateTotpLogins() {
      const totpLogins = (await Promise.all(this.pageLogins.logins.map(async (l2) => {
        var _a3;
        if (!l2.totp || !((_a3 = l2.vaultMetadata) == null ? void 0 : _a3.id)) {
          return [];
        }
        const totpSecret = await getUnprotectedValueForContentLogin(l2, l2.totp);
        return {
          id: l2.id,
          displayName: getLoginDisplayLabel(l2) ?? i18n._(
            /*i18n*/
            {
              id: "4QFgr2"
            }
          ),
          totpParameters: totpSecret ? {
            secret: totpSecret,
            algorithm: getValueWithPlaceholder(l2.totpAlgorithm),
            digits: l2.totpDigits,
            period: l2.totpPeriod
          } : void 0
        };
      }))).flat();
      this.iframeStateManager.updateState({
        logins: totpLogins
      });
    }
    getTotpInputElementData() {
      var _a3, _b;
      const elements = (_a3 = this.formTracker.loginElements) == null ? void 0 : _a3.totpElements;
      if (!elements) {
        return void 0;
      }
      if (elements instanceof Array) {
        return {
          element: elements[5],
          overlayGeometry: {
            type: "rightOfInput"
          }
        };
      }
      const buttonHeight = Math.min(
        TOTP_INPUT_OVERLAY_OVERLAY_INPUT_MAX_HEIGHT,
        // Leave a few pixels margin
        (((_b = getBox(elements)) == null ? void 0 : _b.height) ?? Infinity) - 2 * TOTP_INPUT_OVERLAY_OVERLAY_INPUT_MARGIN
      );
      if (buttonHeight < TOTP_INPUT_OVERLAY_OVERLAY_INPUT_MIN_HEIGHT) {
        return {
          element: elements,
          overlayGeometry: {
            type: "rightOfInput"
          }
        };
      }
      return {
        element: elements,
        overlayGeometry: {
          type: "overlayInput",
          buttonHeight
        }
      };
    }
    getTotpInputElement() {
      var _a3;
      return (_a3 = this.getTotpInputElementData()) == null ? void 0 : _a3.element;
    }
    getBox() {
      if (!this.overlayVisible) {
        return {
          box: null,
          forceHide: true
        };
      }
      const elementData = this.getTotpInputElementData();
      if (!elementData) {
        return {
          box: null
        };
      }
      const elementBox = getBox(elementData.element);
      if (!elementBox) {
        return {
          box: null
        };
      }
      const intrinsicSize = this.iframeStateManager.state.intrinsicSize;
      if (elementData.overlayGeometry.type === "rightOfInput") {
        const right = elementBox.left + elementBox.width + TOTP_INPUT_OVERLAY_RIGHT_OF_INPUT_COLLAPSED_SIZE.width + TOTP_INPUT_OVERLAY_RIGHT_OF_INPUT_MARGIN_LEFT;
        return {
          box: {
            ...intrinsicSize,
            left: right - intrinsicSize.width,
            top: elementBox.top - (TOTP_INPUT_OVERLAY_RIGHT_OF_INPUT_COLLAPSED_SIZE.height - elementBox.height) / 2
          }
        };
      }
      const margin = (elementBox.height - elementData.overlayGeometry.buttonHeight) / 2;
      const left = elementBox.left + elementBox.width - margin - intrinsicSize.width;
      return {
        box: {
          ...intrinsicSize,
          left,
          top: elementBox.top + margin
        }
      };
    }
  }) || _class$2);
  content;
  const waitForElementsTimeout = Symbol("waitForElementsTimeout");
  let LoginFormFiller$1 = (_a2 = class {
    constructor(pageLogins, formTracker, totpQrDetector, formAutosnatch, stateRestorationClient, clientOutdated) {
      __publicField(this, "connectionPort");
      __publicField(this, "visibleOverlay");
      __publicField(this, "loginOverlayStateManager");
      __publicField(this, "loginOverlayManager");
      __publicField(this, "totpInputOverlayManager");
      __publicField(this, "autosnatchOverlayManager");
      __publicField(this, "passwordClearer");
      __publicField(this, "hideOverlay", false);
      __publicField(this, "fillInProgress", false);
      __publicField(this, "hostPageInteractionSinceOverlayShow", false);
      __publicField(this, "enableAvoidBuiltinPasswordManagerHack");
      __publicField(this, "handleMessage", makeMessageListener({
        FillForm: ({
          username,
          password,
          totp,
          totpAlgorithm,
          totpDigits,
          totpPeriod,
          hideSecrets,
          customFields
        }) => {
          debugConsole.log("[LoginFormFiller]", "FillForm", window.location.href);
          const totpParameters = totp ? {
            secret: totp,
            totpAlgorithm,
            totpDigits,
            totpPeriod
          } : void 0;
          this.fillForm({
            username,
            password,
            totp: totpParameters,
            customFields
          }, hideSecrets).catch(trackError);
        }
      }));
      __publicField(this, "handleStateUpdate", ({
        oldState,
        newState
      }) => {
        if (oldState.intrinsicSize !== newState.intrinsicSize) {
          this.loginOverlayManager.setIntrinsicOverlaySize(newState.intrinsicSize);
        }
      });
      __publicField(this, "handleIframeAction", (action) => {
        if (action.type === "updateLoginAndFillForm") {
          const {
            username,
            password,
            totp,
            targetLoginId,
            targetVaultId
          } = action;
          this.updateLoginAndFillForm({
            username,
            password,
            totp
          }, targetVaultId, targetLoginId).catch(trackError);
        } else if (action.type === "hide") {
          this.hideIframe();
        }
      });
      __publicField(this, "handleTotpLoginSelected", ({
        totp
      }) => {
        this.fillTotpForm(totp).catch(trackError);
      });
      __publicField(this, "handleLoginsChanged", () => {
        this.updateOverlayShown();
        this.loginOverlayStateManager.updateState({
          logins: this.pageLogins.logins,
          preferredLoginIds: this.getPreferredLoginIds()
        });
      });
      __publicField(this, "handleLoginFormChanged", () => {
        this.updateOverlayShown();
        this.loginOverlayStateManager.updateState({
          preferredLoginIds: this.getPreferredLoginIds()
        });
      });
      __publicField(this, "handleAutosnatchPerformed", () => {
        this.hideOverlay = true;
        this.updateOverlayShown();
      });
      __publicField(this, "handleKeydown", (e2) => {
        if (this.visibleOverlay !== "login" || this.checkAndMarkHostPageInteraction() || e2.defaultPrevented) {
          return;
        }
        if (e2.key === "Escape") {
          e2.preventDefault();
          this.hideIframe();
        } else if (e2.key === "Enter") {
          e2.preventDefault();
          this.connectionPort.postMessage({
            type: "PerformEnterDefaultAction"
          });
        }
      });
      __publicField(this, "handleMousedown", () => {
        if (this.visibleOverlay !== "login") {
          return;
        }
        this.checkAndMarkHostPageInteraction();
      });
      this.pageLogins = pageLogins;
      this.formTracker = formTracker;
      this.totpQrDetector = totpQrDetector;
      this.formAutosnatch = formAutosnatch;
      this.stateRestorationClient = stateRestorationClient;
      this.clientOutdated = clientOutdated;
      const connectionId = newUuid$1();
      this.connectionPort = openConnection("ForwardContent", connectionId);
      this.loginOverlayManager = new LoginOverlayManager(this.formTracker, this.totpQrDetector, connectionId);
      this.loginOverlayStateManager = new IframeStateManager(loginIframeStateDescriptor, this.connectionPort);
      this.loginOverlayStateManager.updateState({
        logins: this.pageLogins.logins
      });
      this.totpInputOverlayManager = new TotpInputOverlayManager(this.formTracker, this.pageLogins);
      if (formAutosnatch) {
        this.autosnatchOverlayManager = new AutosnatchOverlayManager(formTracker, formAutosnatch, pageLogins, () => {
          this.hideOverlay = false;
          this.updateOverlayShown();
        });
      }
      this.passwordClearer = new PasswordClearer();
      const browserInfo = Bowser.parse(window.navigator.userAgent);
      this.enableAvoidBuiltinPasswordManagerHack = // Safari does not support privacy.services.passwordSavingEnabled API
      browserInfo.browser.name === "Safari" || // Firefox on Android supports but does not actually respect privacy.services.passwordSavingEnabled
      // see https://bugzilla.mozilla.org/show_bug.cgi?id=1875780
      browserInfo.os.name === "Android" && browserInfo.browser.name === "Firefox";
    }
    async init() {
      var _a3, _b;
      (_a3 = this.autosnatchOverlayManager) == null ? void 0 : _a3.init();
      this.passwordClearer.init();
      this.loginOverlayManager.init();
      this.totpInputOverlayManager.init();
      browser$1.runtime.onMessage.addListener(this.handleMessage);
      this.loginOverlayStateManager.on("stateUpdate", this.handleStateUpdate);
      this.loginOverlayStateManager.on("action", this.handleIframeAction);
      (_b = this.formAutosnatch) == null ? void 0 : _b.on("autosnatchPerformed", this.handleAutosnatchPerformed);
      this.formTracker.on("loginFormChanged", this.handleLoginFormChanged);
      this.pageLogins.on("loginsChanged", this.handleLoginsChanged);
      window.addEventListener("keydown", this.handleKeydown);
      window.addEventListener("mousedown", this.handleMousedown);
      this.totpInputOverlayManager.on("loginSelected", this.handleTotpLoginSelected);
      await this.restoreState();
      this.updateOverlayShown();
      this.loginOverlayStateManager.updateState({
        preferredLoginIds: this.getPreferredLoginIds()
      });
    }
    close() {
      var _a3, _b;
      (_a3 = this.autosnatchOverlayManager) == null ? void 0 : _a3.close();
      this.passwordClearer.close();
      this.loginOverlayManager.close();
      this.totpInputOverlayManager.close();
      browser$1.runtime.onMessage.removeListener(this.handleMessage);
      this.loginOverlayStateManager.off("stateUpdate", this.handleStateUpdate);
      this.loginOverlayStateManager.off("action", this.handleIframeAction);
      (_b = this.formAutosnatch) == null ? void 0 : _b.off("autosnatchPerformed", this.handleAutosnatchPerformed);
      this.formTracker.off("loginFormChanged", this.handleLoginFormChanged);
      this.pageLogins.off("loginsChanged", this.handleLoginsChanged);
      window.removeEventListener("keydown", this.handleKeydown);
      window.removeEventListener("mousedown", this.handleMousedown);
      this.totpInputOverlayManager.off("loginSelected", this.handleTotpLoginSelected);
    }
    setClientOutdated(newClientOutdated) {
      this.clientOutdated = newClientOutdated;
      this.updateOverlayShown();
    }
    checkAndMarkHostPageInteraction() {
      if (this.hostPageInteractionSinceOverlayShow) {
        return true;
      }
      debugConsole.log("[LoginFormFiller]", "recording page interaction, global keyboard shortcuts disabled");
      this.hostPageInteractionSinceOverlayShow = true;
      return false;
    }
    hideIframe() {
      if (this.fillInProgress) {
        return;
      }
      this.hideOverlay = true;
      this.updateOverlayShown();
    }
    async restoreState() {
      const stateToRestore = await this.stateRestorationClient.get("LoginFormFiller");
      if (!stateToRestore) {
        return;
      }
      debugConsole.log("[LoginFormFiller]", "restoring state", stateToRestore.type);
      if (stateToRestore.type === "TwoStepWaitForPassword") {
        try {
          await this.fillTwoStepFormPassword(stateToRestore.password, stateToRestore.hideSecrets, stateToRestore.totp);
        } catch (e2) {
          if (e2 instanceof NoPasswordFieldFound) {
            return;
          }
          throw e2;
        }
      } else if (stateToRestore.type === "WaitForTOTP") {
        this.hideOverlay = true;
        await windowLoadEvent();
        await this.fillTotpForm(stateToRestore.totp);
      } else if (stateToRestore.type === "WaitForSuccess") {
        await this.waitForLoginSuccess();
      }
    }
    updateOverlayShown() {
      const oldVisibleOverlay = this.visibleOverlay;
      const showableOverlay = this.getShowableOverlayType();
      const newVisibleOverlay = this.hideOverlay ? void 0 : showableOverlay;
      this.visibleOverlay = newVisibleOverlay;
      if (oldVisibleOverlay === "login" && newVisibleOverlay !== "login") {
        this.passwordClearer.clearPasswordAndProtectedValues();
      }
      if (oldVisibleOverlay !== "login" && newVisibleOverlay === "login") {
        this.hostPageInteractionSinceOverlayShow = false;
      }
      const showLoginOverlay = newVisibleOverlay === "login";
      this.loginOverlayManager.setOverlayVisible(showLoginOverlay);
      const showTotpInputOverlay = newVisibleOverlay === "totp";
      this.totpInputOverlayManager.setOverlayVisible(showTotpInputOverlay);
    }
    getShowableOverlayType() {
      var _a3, _b, _c2, _d;
      const totpElementShown = !!((_a3 = this.formTracker.loginElements) == null ? void 0 : _a3.totpElements);
      const totpLoginSet = (_b = this.pageLogins.logins) == null ? void 0 : _b.some(({
        totp
      }) => totp);
      const usernameElementShown = !!((_c2 = this.formTracker.loginElements) == null ? void 0 : _c2.usernameElement);
      const passwordElementShown = !!((_d = this.formTracker.loginElements) == null ? void 0 : _d.passwordElement);
      const loginSet = isDefinedAndNotEmpty(this.pageLogins.logins);
      const isFillableLoginForm = (usernameElementShown || passwordElementShown) && loginSet;
      const isFillableTotpForm = totpElementShown && totpLoginSet;
      if (isFillableLoginForm || this.clientOutdated) {
        return "login";
      }
      if (isFillableTotpForm) {
        return "totp";
      }
      return void 0;
    }
    async updateLoginAndFillForm({
      username,
      password,
      totp
    }, targetVaultId, targetLoginId) {
      await sendMessage({
        type: "LoginSnatched",
        login: {
          username,
          password,
          targetLoginId,
          waitForTab: false,
          hideUntilCompletion: false,
          autosnatchId: newUuid$1(),
          overrideTargetVaultId: targetVaultId,
          addTldPlus1: false,
          source: LoginSource.updateLoginFromOverlay,
          forceCreate: false
        }
      });
      await this.fillForm({
        username,
        password,
        totp
      }, false);
    }
    getPreferredLoginIds() {
      if (this.visibleOverlay !== "login") {
        return void 0;
      }
      if (this.pageLogins.logins.length <= 1) {
        return void 0;
      }
      const textContent = getTextContentWithShadowDom(document.body);
      const result2 = this.pageLogins.logins.flatMap(({
        id: id2,
        username
      }) => {
        if (username && textContent.includes(username)) {
          return id2;
        }
        return [];
      });
      if (!result2.length) {
        return void 0;
      }
      return result2;
    }
    async fillForm(parameters, hideSecrets) {
      if (this.hideOverlay || this.fillInProgress) {
        return;
      }
      try {
        this.fillInProgress = true;
        await this.loginOverlayManager.withFrozenOverlay(async () => {
          const {
            loginElements: elements
          } = this.formTracker;
          if (!elements) {
            return;
          }
          if (elements.stayLoggedInElement) {
            elements.stayLoggedInElement.checked = true;
          }
          if (elements.passwordElement) {
            await this.fillOneStepForm(parameters, hideSecrets, elements);
          } else if (elements.usernameElement) {
            try {
              await this.fillTwoStepForm(parameters, hideSecrets, elements);
            } catch (e2) {
              if (e2 instanceof NoPasswordFieldFound) {
                return;
              }
              throw e2;
            }
          } else if (elements.totpElements) {
            await this.fillTotpForm(parameters.totp);
          }
        });
      } finally {
        this.fillInProgress = false;
      }
    }
    async fillOneStepForm({
      username,
      password,
      totp,
      customFields
    }, hideSecrets, elements) {
      let totpFilled = false;
      if (elements.totpElements && totp) {
        this.fillTotpInput(elements.totpElements, totp);
        this.stateRestorationClient.set("LoginFormFiller", {
          type: "WaitForSuccess"
        });
        totpFilled = true;
      } else {
        this.stateRestorationClient.set("LoginFormFiller", {
          type: "WaitForTOTP",
          totp
        });
      }
      if (elements.usernameElement !== null) {
        setInputValue(elements.usernameElement, username);
      }
      this.fillCustomFieldValues(elements.containerElement, customFields);
      if (hideSecrets) {
        this.passwordClearer.addElement(elements.passwordElement);
      }
      await this.submitField(password, elements.passwordElement, elements);
      if (totpFilled) {
        await this.waitForLoginSuccess();
      } else {
        await this.fillTotpForm(totp);
      }
    }
    async fillTwoStepForm({
      username,
      password,
      totp,
      customFields
    }, hideSecrets, elements) {
      this.stateRestorationClient.set("LoginFormFiller", {
        type: "TwoStepWaitForPassword",
        password,
        totp
      });
      this.fillCustomFieldValues(elements.containerElement, customFields);
      await this.submitField(username, elements.usernameElement, elements);
      await this.fillTwoStepFormPassword(password, hideSecrets, totp);
    }
    async fillTwoStepFormPassword(password, hideSecrets, totp) {
      const oneStepElements = await this.waitForElementsWithTimeout((lfe) => !!(lfe == null ? void 0 : lfe.passwordElement), _a2.TWO_STEP_PASSWORD_ELEMENT_TIMEOUT);
      if (oneStepElements === waitForElementsTimeout) {
        debugConsole.log("[LoginFormFiller]", "LOGIN FAILED, NO PASSWORD FIELD FOUND");
        this.stateRestorationClient.set("LoginFormFiller", void 0);
        this.hideOverlay = true;
        this.updateOverlayShown();
        this.stateRestorationClient.set("LoginFormFiller", void 0);
        throw new NoPasswordFieldFound();
      }
      this.stateRestorationClient.set("LoginFormFiller", {
        type: "WaitForTOTP",
        totp
      });
      if (hideSecrets) {
        this.passwordClearer.addElement(oneStepElements.passwordElement);
      }
      await this.submitField(password, oneStepElements.passwordElement, oneStepElements);
      await this.fillTotpForm(totp);
    }
    async fillTotpForm(totp) {
      var _a3;
      if (!totp) {
        this.stateRestorationClient.set("LoginFormFiller", {
          type: "WaitForSuccess"
        });
        await this.waitForLoginSuccess();
        return;
      }
      debugConsole.log("[LoginFormFiller] Started waiting for new elements");
      const elements = await this.waitForElementsWithTimeout((lfe) => !!(lfe == null ? void 0 : lfe.totpElements), _a2.TOTP_ELEMENT_TIMEOUT);
      if (elements === waitForElementsTimeout) {
        debugConsole.log("[LoginFormFiller] waitForElementsTimeout failed");
        this.stateRestorationClient.set("LoginFormFiller", {
          type: "WaitForSuccess"
        });
        await this.waitForLoginSuccess();
        return;
      }
      debugConsole.log("[LoginFormFiller] Received elements", elements);
      this.hideOverlay = true;
      this.updateOverlayShown();
      await shortSleep();
      const totpCode = calculateTotp(totp.secret, totp.algorithm ?? DEFAULT_TOTP_ALGORITHM, totp.digits ?? DEFAULT_TOTP_DIGITS, totp.period ?? DEFAULT_TOTP_PERIOD).totp;
      if (Array.isArray(elements.totpElements) && elements.totpElements.length !== totpCode.length) {
        debugConsole.log("[LoginFormFiller] bailing from totp autofill due to mismatch in totp code length and input element count");
        this.stateRestorationClient.set("LoginFormFiller", {
          type: "WaitForSuccess"
        });
        await this.waitForLoginSuccess();
        return;
      }
      if (this.visibleOverlay !== "login") {
        if (Array.isArray(elements.totpElements)) {
          for (let elIndex = 0; elIndex < totpCode.length - 1; elIndex++) {
            setInputValue(elements.totpElements[elIndex], totpCode[elIndex]);
            await shortSleep(100);
          }
        } else {
          for (let insertLength = 1; insertLength < totpCode.length; insertLength++) {
            setInputValue(elements.totpElements, totpCode.slice(0, insertLength));
            await shortSleep(100);
          }
        }
      }
      this.stateRestorationClient.set("LoginFormFiller", {
        type: "WaitForSuccess"
      });
      if (Array.isArray(elements.totpElements)) {
        for (let i2 = 0; i2 < totpCode.length - 1; i2++) {
          setInputValue(elements.totpElements[i2], totpCode[i2]);
        }
        if (window.location.hostname === "paypal.com" || window.location.hostname === "www.paypal.com") {
          setInputValue(elements.totpElements[5], totpCode[5]);
          (_a3 = elements.totpElements[5].form) == null ? void 0 : _a3.requestSubmit();
        } else {
          await this.submitField(totpCode[5], elements.totpElements[5], elements);
        }
      } else {
        await this.submitField(totpCode, elements.totpElements, elements);
      }
    }
    fillCustomFieldValues(container, customFields) {
      if (!(customFields == null ? void 0 : customFields.length)) {
        return;
      }
      const fillTargets = [
        // consider all inputs in the container element as valid targets
        ...querySelectorAllWithShadowRoots("input, select", container),
        // for forms, also consider inputs that aren't physically in the form but logically associated with it
        ...container instanceof HTMLFormElement ? container.elements : []
      ];
      for (const cf2 of customFields) {
        if (cf2.name.trim() === "") {
          continue;
        }
        const target = fillTargets.find(makeCustomFieldPredicate("id", cf2.name)) ?? fillTargets.find(makeCustomFieldPredicate("name", cf2.name));
        if (target && (!cf2.protected || target.type === "password")) {
          if (target instanceof HTMLSelectElement) {
            const optionIndex = [...target.options].findIndex((option) => option.value === cf2.value || option.textContent === cf2.value);
            if (optionIndex !== -1) {
              target.selectedIndex = optionIndex;
            }
          } else {
            setInputValue(target, cf2.value);
            if (cf2.protected) {
              this.passwordClearer.addElement(target);
            }
          }
        }
      }
    }
    fillTotpInput(totpElements, totp) {
      const totpCode = calculateTotp(totp.secret, totp.algorithm ?? DEFAULT_TOTP_ALGORITHM, totp.digits ?? DEFAULT_TOTP_DIGITS, totp.period ?? DEFAULT_TOTP_PERIOD).totp;
      if (Array.isArray(totpElements)) {
        for (let i2 = 0; i2 < totpCode.length - 1; i2++) {
          setInputValue(totpElements[i2], totpCode[i2]);
        }
      } else {
        setInputValue(totpElements, totpCode);
      }
    }
    async waitForLoginSuccess() {
      const elements = await this.waitForElementsWithTimeout((lfe) => lfe === null, _a2.SUCCESS_TIMEOUT);
      debugConsole.log("[LoginFormFiller]", elements === waitForElementsTimeout ? "LOGIN FAILED" : "LOGIN SUCCESS");
      this.hideOverlay = true;
      this.updateOverlayShown();
      this.stateRestorationClient.set("LoginFormFiller", void 0);
    }
    async submitField(value, inputElement, elements) {
      let unloading = false;
      const beforeunload = () => {
        unloading = true;
      };
      try {
        window.addEventListener("beforeunload", beforeunload);
        await this.withAvoidBuiltinPasswordManagerHack(inputElement, async () => {
          var _a3, _b;
          setInputValue(inputElement, value);
          await shortSleep();
          if (unloading) {
            debugConsole.log("[LoginFormFiller]", "skipping form submit because unload is already in progress");
            return;
          }
          let submitElement;
          if ((_a3 = this.formTracker.loginElements) == null ? void 0 : _a3.submitElement) {
            submitElement = (_b = this.formTracker.loginElements) == null ? void 0 : _b.submitElement;
          } else {
            submitElement = elements.submitElement;
          }
          if (this.formAutosnatch) {
            await this.formAutosnatch.ignoringAutosnatch(async () => {
              const requestsSettledPromise = sendMessage({
                type: "WaitForSenderTabRequestsSettled",
                timeoutMs: 6e4
              });
              await shortSleep(10);
              submitForm(inputElement, submitElement);
              await requestsSettledPromise;
              await shortSleep();
            });
          } else {
            submitForm(inputElement, submitElement);
          }
        });
      } finally {
        window.removeEventListener("beforeunload", beforeunload);
      }
    }
    async waitForElementsWithTimeout(predicate, timeoutMs) {
      try {
        const cancelToken = new CancelToken();
        const result2 = await Promise.race([this.waitForElements(predicate, cancelToken), new Promise((resolve) => setTimeout(() => resolve(waitForElementsTimeout), timeoutMs))]);
        cancelToken.cancel();
        return result2;
      } catch (e2) {
        if (e2 instanceof Cancel) {
          return waitForElementsTimeout;
        }
        throw e2;
      }
    }
    async waitForElements(predicate, cancelToken) {
      if (predicate(this.formTracker.loginElements)) {
        return this.formTracker.loginElements;
      }
      const loginFormChangedEvents = this.formTracker.events("loginFormChanged");
      this.formTracker.updateForms().catch(trackError);
      for await (const {
        newLoginForm
      } of loginFormChangedEvents) {
        if (cancelToken == null ? void 0 : cancelToken.isCancelled) {
          throw new Cancel();
        }
        if (predicate(newLoginForm)) {
          return newLoginForm;
        }
      }
      throw new Cancel();
    }
    /**
     * Hides form submission from some builtin password managers.
     *
     * In other browsers we can disable the browser password manager (see
     * disableBrowserPasswordManager.ts), but Safari and Firefox on Android don't implement or don't
     * respect the browser.privacy API needed for that.
     *
     * We need to do some shenanigans to confuse builtin login form detection. Previously we were
     * messing with the input field's type, but this broke sign-in on okta.com, so we're now inserting
     * additional decoy password elements.
     */
    async withAvoidBuiltinPasswordManagerHack(inputElement, cb2) {
      if (!this.enableAvoidBuiltinPasswordManagerHack || inputElement.type !== "password") {
        await cb2();
        return;
      }
      const decoyPwInputs = [
        // Firefox gives up on >5 password elements
        // see https://searchfox.org/mozilla-central/source/toolkit/components/passwordmgr/LoginManagerChild.sys.mjs#978
        makeDecoyPasswordEl(),
        makeDecoyPasswordEl(),
        makeDecoyPasswordEl(),
        makeDecoyPasswordEl(),
        makeDecoyPasswordEl()
      ];
      try {
        this.formTracker.close();
        decoyPwInputs.forEach((el2) => inputElement.insertAdjacentElement("afterend", el2));
        await cb2();
      } finally {
        decoyPwInputs.forEach((el2) => el2.remove());
        this.formTracker.init();
      }
    }
  }, __publicField(_a2, "TWO_STEP_PASSWORD_ELEMENT_TIMEOUT", 5e3), // Some sites (e.g. playstation.com) take quite some time before displaying the totp entry ui, so
  // we use a longer timeout here.
  __publicField(_a2, "TOTP_ELEMENT_TIMEOUT", 1e4), __publicField(_a2, "SUCCESS_TIMEOUT", 5e3), _a2);
  function makeDecoyPasswordEl() {
    const el2 = document.createElement("input");
    el2.type = "password";
    el2.style.clipPath = "inset(50%)";
    el2.style.position = "fixed";
    el2.value = "....";
    return el2;
  }
  async function windowLoadEvent() {
    debugConsole.log("[LoginFormFiller]", `waiting for load, readyState: ${document.readyState}`);
    if (document.readyState !== "complete") {
      await new Promise((resolve) => {
        const onLoad = () => {
          debugConsole.log("[LoginFormFiller]", "load event triggered");
          resolve();
          window.removeEventListener("load", onLoad);
        };
        window.addEventListener("load", onLoad);
      });
    }
  }
  function isDefinedAndNotEmpty(logins) {
    return !!logins && !!logins.length;
  }
  function shortSleep(ms = 300) {
    return sleep(ms);
  }
  function makeCustomFieldPredicate(field, customFieldName) {
    return (el2) => (el2 instanceof HTMLInputElement || el2 instanceof HTMLSelectElement) && el2[field] === customFieldName;
  }
  class NoPasswordFieldFound extends Error {
  }
  content;
  async function copyToClipboard(value) {
    try {
      if (window.ClipboardItem && navigator.clipboard.write) {
        const filteredValue = typeof value === "string" ? value : value.then((v2) => v2 ?? "");
        const text = new ClipboardItem({
          "text/plain": filteredValue
        });
        await navigator.clipboard.write([text]);
        return await filteredValue;
      } else {
        const text = await value;
        if (text !== void 0) {
          await navigator.clipboard.writeText(text);
        }
        return text;
      }
    } catch (e2) {
      const text = await value;
      if (text !== void 0) {
        fallbackCopyTextToClipboard(text);
      }
      return text;
    }
  }
  function fallbackCopyTextToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      const successful = document.execCommand("copy");
      if (!successful) {
        throw new Error("unable to copy!");
      }
    } finally {
      document.body.removeChild(textArea);
    }
  }
  content;
  const passwordGeneratorIframeStateDescriptor = {
    mode: "passwordGenerator",
    initialState: {
      hidden: false,
      intrinsicSize: {
        width: 0,
        height: 0
      },
      expanded: false,
      insertInitialPassword: false
    },
    reducer: (state, action) => {
      switch (action.type) {
        case "setIntrinsicSize":
          return {
            ...state,
            intrinsicSize: action.size
          };
        case "setHidden":
          return {
            ...state,
            hidden: action.hidden
          };
        case "setAutosnatchTargetOverride":
          return {
            ...state,
            autosnatchTargetOverride: action.autosnatchTargetOverride
          };
        case "setGeneratedPassword":
          return {
            ...state,
            generatedPassword: action.generatedPassword
          };
        case "setExpanded":
          return {
            ...state,
            expanded: action.expanded
          };
        case "writeToClipboard":
          return state;
      }
    }
  };
  content;
  const repeatPasswordIframeStateDescriptor = {
    mode: "repeatPassword",
    initialState: {
      intrinsicSize: {
        width: 0,
        height: 0
      },
      expanded: false
    },
    reducer: (state, action) => {
      switch (action.type) {
        case "setIntrinsicSize":
          return {
            ...state,
            intrinsicSize: action.size
          };
        case "setExpanded":
          return {
            ...state,
            expanded: action.expanded
          };
        case "hide":
        case "insertPassword":
          return state;
      }
    }
  };
  content;
  class PasswordGeneratorOverlayManager {
    constructor(formTracker) {
      __publicField(this, "generatorIframePositionManager");
      __publicField(this, "generatorStateManager");
      __publicField(this, "generatorConnectionId");
      __publicField(this, "repeatPasswordIframePositionManager");
      __publicField(this, "repeatPasswordStateManager");
      __publicField(this, "onRegistrationFormChanged", () => {
        this.generatorIframePositionManager.updatePosition();
        this.repeatPasswordIframePositionManager.updatePosition();
      });
      this.formTracker = formTracker;
      ({
        positionManager: this.generatorIframePositionManager,
        connectionId: this.generatorConnectionId,
        stateManager: this.generatorStateManager
      } = PasswordGeneratorOverlayManager.createIframeAndConnection(passwordGeneratorIframeStateDescriptor, "passwordGenerator", this.getPasswordFieldBox.bind(this), () => {
        var _a3;
        return (_a3 = this.formTracker.registrationElements) == null ? void 0 : _a3.passwordElement;
      }, 11));
      ({
        positionManager: this.repeatPasswordIframePositionManager,
        stateManager: this.repeatPasswordStateManager
      } = PasswordGeneratorOverlayManager.createIframeAndConnection(repeatPasswordIframeStateDescriptor, "repeatPassword", this.getRepeatPasswordFieldBox.bind(this), () => {
        var _a3;
        return ((_a3 = this.formTracker.registrationElements) == null ? void 0 : _a3.repeatPasswordElement) ?? void 0;
      }, 10));
    }
    setInsertInitialPassword(value) {
      this.generatorStateManager.updateState({
        insertInitialPassword: value
      });
    }
    static getIframeUrl(connectionId, mode2) {
      const search = new URLSearchParams({
        connectionId,
        mode: mode2,
        url: window.location.href
      });
      return `${browser$1.runtime.getURL("iframe.html")}?${search.toString()}`;
    }
    static createIframeAndConnection(descriptor, mode2, getOverlayBox, getOverlayTargetElement, additionalZIndex) {
      const connectionId = newUuid$1();
      const connectionPort = openConnection("ForwardContent", connectionId);
      const stateManager = new IframeStateManager(descriptor, connectionPort);
      const url = this.getIframeUrl(connectionId, mode2);
      const positionManager = new IframePositionManager({
        url,
        margin: 0,
        anchor: {
          top: 0,
          left: 0
        },
        getOverlayBox,
        getOverlayTargetElement,
        additionalZIndex
      });
      stateManager.on("stateUpdate", ({
        oldState,
        newState
      }) => {
        if (oldState.intrinsicSize !== newState.intrinsicSize) {
          positionManager.setIntrinsicSize(newState.intrinsicSize);
        }
      });
      return {
        positionManager,
        connectionId,
        stateManager
      };
    }
    insertOverlay() {
      this.formTracker.on("registrationFormChanged", this.onRegistrationFormChanged);
      this.generatorIframePositionManager.init();
      this.repeatPasswordIframePositionManager.init();
    }
    removeOverlay() {
      this.formTracker.off("registrationFormChanged", this.onRegistrationFormChanged);
      this.generatorIframePositionManager.close();
      this.repeatPasswordIframePositionManager.close();
    }
    getPasswordFieldBox() {
      const els = this.formTracker.registrationElements;
      if (!els) {
        return {
          box: null
        };
      }
      return {
        box: getBoxCoveringAll(els.passwordElement)
      };
    }
    getRepeatPasswordFieldBox() {
      const els = this.formTracker.registrationElements;
      if (!els || !els.repeatPasswordElement) {
        return {
          box: null
        };
      }
      return {
        box: getBoxCoveringAll(els.repeatPasswordElement)
      };
    }
  }
  content;
  class RegistrationPasswordGeneration {
    constructor(formTracker, formAutosnatch) {
      __publicField(this, "overlayManager");
      __publicField(this, "autosnatchId");
      __publicField(this, "hidden", false);
      __publicField(this, "showOverlay");
      __publicField(this, "initialPasswordInserted", false);
      __publicField(this, "handlePasswordGeneratorStateUpdate", ({
        oldState,
        newState
      }) => {
        if (oldState.generatedPassword !== newState.generatedPassword && newState.generatedPassword !== void 0) {
          this.updateGeneratedPassword(newState.generatedPassword).catch(trackError);
        }
        if (!oldState.hidden && newState.hidden) {
          this.handleHideIframe();
        }
        if (oldState.expanded !== newState.expanded) {
          this.overlayManager.repeatPasswordStateManager.updateState({
            expanded: newState.expanded
          });
        }
        if (oldState.passwordInsertedTimestampMs !== newState.passwordInsertedTimestampMs) {
          this.overlayManager.repeatPasswordStateManager.updateState({
            passwordInsertedTimestampMs: newState.passwordInsertedTimestampMs
          });
        }
        if (oldState.autosnatchTargetOverride !== newState.autosnatchTargetOverride) {
          this.formAutosnatch.setOverrideTargetVault(newState.autosnatchTargetOverride);
          debugConsole.log("[RegistrationPasswordGeneration]", "handling OverrideAutosnatchTarget", newState.autosnatchTargetOverride);
          if (this.autosnatchId) {
            sendMessage({
              type: "UpdateAutosnatchLogin",
              login: {
                autosnatchId: this.autosnatchId,
                overrideTargetVaultId: newState.autosnatchTargetOverride
              }
            }).catch(trackError);
          }
        }
      });
      __publicField(this, "handlePasswordGeneratorAction", (action) => {
        if (action.type === "writeToClipboard") {
          this.writeToClipboard(action.text, action.clearAfterTimeout).catch(trackError);
        }
      });
      __publicField(this, "handleRepeatPasswordStateUpdate", ({
        oldState,
        newState
      }) => {
        if (oldState.expanded !== newState.expanded) {
          this.overlayManager.generatorStateManager.updateState({
            expanded: newState.expanded
          });
        }
      });
      __publicField(this, "handleRepeatPasswordAction", (action) => {
        if (action.type === "insertPassword") {
          this.overlayManager.setInsertInitialPassword(true);
          this.initialPasswordInserted = true;
        }
        if (action.type === "hide") {
          this.overlayManager.generatorStateManager.updateState({
            hidden: true
          });
        }
      });
      __publicField(this, "handleFormsChanged", ({
        context
      }) => {
        this.insertGeneratedPassword();
        if (context.overrideLoginFormAsRegistration && !this.initialPasswordInserted) {
          this.overlayManager.setInsertInitialPassword(true);
          this.initialPasswordInserted = true;
        }
      });
      this.formTracker = formTracker;
      this.formAutosnatch = formAutosnatch;
      this.overlayManager = new PasswordGeneratorOverlayManager(this.formTracker);
    }
    async init() {
      this.overlayManager.generatorStateManager.on("stateUpdate", this.handlePasswordGeneratorStateUpdate);
      this.overlayManager.generatorStateManager.on("action", this.handlePasswordGeneratorAction);
      this.overlayManager.repeatPasswordStateManager.on("stateUpdate", this.handleRepeatPasswordStateUpdate);
      this.overlayManager.repeatPasswordStateManager.on("action", this.handleRepeatPasswordAction);
      this.formTracker.on("formsChanged", this.handleFormsChanged);
      this.updateOverlayVisibility();
    }
    close() {
      this.overlayManager.generatorStateManager.off("stateUpdate", this.handlePasswordGeneratorStateUpdate);
      this.overlayManager.generatorStateManager.off("action", this.handlePasswordGeneratorAction);
      this.overlayManager.repeatPasswordStateManager.off("stateUpdate", this.handleRepeatPasswordStateUpdate);
      this.overlayManager.repeatPasswordStateManager.off("action", this.handleRepeatPasswordAction);
      this.formTracker.off("formsChanged", this.handleFormsChanged);
      this.overlayManager.removeOverlay();
    }
    handleHideIframe() {
      this.hidden = true;
      this.updateOverlayVisibility();
      this.formAutosnatch.disableRegistrationAutosnatch();
      this.formTracker.setOverrideLoginFormAsRegistration(false);
      this.overlayManager.setInsertInitialPassword(false);
      this.initialPasswordInserted = false;
    }
    isAutosnatchActive(autosnatchId) {
      return this.autosnatchId === autosnatchId;
    }
    async writeToClipboard(value, clearAfterTimeout) {
      await sendMessage({
        type: "SetClearValueFromClipboardAfterTimeout",
        clearAfterTimeout: !!clearAfterTimeout,
        value
      });
      await copyToClipboard(value);
    }
    async updateGeneratedPassword(generatedPassword) {
      this.insertGeneratedPassword();
      if (!this.autosnatchId) {
        this.autosnatchId = newUuid$1();
        this.formAutosnatch.setRegistrationGeneratedPassword({
          autosnatchId: this.autosnatchId,
          generatedPassword
        });
        const login = {
          autosnatchId: this.autosnatchId,
          waitForTab: true,
          hideUntilCompletion: true,
          password: generatedPassword,
          username: this.formAutosnatch.getRegistrationUsername() ?? "",
          targetLoginId: void 0,
          overrideTargetVaultId: this.formAutosnatch.getOverrideTargetVault(),
          addTldPlus1: true,
          source: LoginSource.registrationPasswordGeneration,
          forceCreate: true
        };
        await sendMessage({
          type: "LoginSnatched",
          login
        });
      } else {
        const login = {
          autosnatchId: this.autosnatchId,
          password: generatedPassword
        };
        this.formAutosnatch.setRegistrationGeneratedPassword({
          autosnatchId: this.autosnatchId,
          generatedPassword
        });
        await sendMessage({
          type: "UpdateAutosnatchLogin",
          login
        });
      }
    }
    updateOverlayVisibility() {
      const oldShowOverlay = this.showOverlay;
      const newShowOverlay = !this.hidden;
      if (oldShowOverlay === newShowOverlay) {
        return;
      }
      this.showOverlay = newShowOverlay;
      if (this.showOverlay) {
        this.overlayManager.insertOverlay();
      } else {
        this.overlayManager.removeOverlay();
        if (this.overlayManager.generatorStateManager.state.generatedPassword) {
          this.overlayManager.generatorStateManager.updateState({
            generatedPassword: ""
          });
          this.setPasswordFieldValue("");
        }
      }
    }
    insertGeneratedPassword() {
      if (this.overlayManager.generatorStateManager.state.generatedPassword === void 0) {
        return;
      }
      this.overlayManager.generatorStateManager.updateState({
        passwordInsertedTimestampMs: Date.now()
      });
      this.setPasswordFieldValue(this.overlayManager.generatorStateManager.state.generatedPassword);
    }
    setPasswordFieldValue(value) {
      if (!this.formTracker.registrationElements) {
        return;
      }
      const {
        passwordElement,
        repeatPasswordElement
      } = this.formTracker.registrationElements;
      if (passwordElement.value !== value) {
        setInputValue(passwordElement, value);
      }
      if (repeatPasswordElement && repeatPasswordElement.value !== value) {
        setInputValue(repeatPasswordElement, value);
      }
    }
  }
  content;
  class StateRestorationClient {
    constructor() {
      __publicField(this, "dataForNextPageRestoration", {});
      __publicField(this, "stateToRestore");
      __publicField(this, "isUnloading", false);
      __publicField(this, "handleBeforeunload", () => {
        this.isUnloading = true;
        this.sendSaveMessageIfNecessary();
      });
    }
    async init() {
      const getContentScriptStateResponse = await sendMessage({
        type: "GetContentScriptState"
      });
      this.stateToRestore = getContentScriptStateResponse === messageError ? void 0 : getContentScriptStateResponse;
      window.addEventListener("beforeunload", this.handleBeforeunload);
    }
    close() {
      window.removeEventListener("beforeunload", this.handleBeforeunload);
    }
    set(key, value) {
      this.dataForNextPageRestoration[key] = value;
      if (this.isUnloading) {
        this.sendSaveMessageIfNecessary();
      }
    }
    async get(key) {
      if (!this.stateToRestore || !this.stateToRestore[key]) {
        return void 0;
      }
      return this.stateToRestore[key];
    }
    sendSaveMessageIfNecessary() {
      if (Object.keys(this.dataForNextPageRestoration).length) {
        sendMessage({
          type: "SaveContentScriptState",
          state: this.dataForNextPageRestoration
        }).catch(trackError);
      }
    }
  }
  content;
  function isHeyloginWebappHost(host) {
    return host === "heylogin.app" || host === "staging.heylogin.app" || host.endsWith(".review.heylogin.dev");
  }
  content;
  class LoginFormFiller {
    constructor() {
      __publicField(this, "target", null);
      __publicField(this, "updateElement", (e2) => {
        this.target = e2.target;
      });
      __publicField(this, "handleMessage", makeMessageListener({
        FillActive: ({
          value
        }) => {
          this.fillActiveField(value);
        }
      }));
    }
    init() {
      browser$1.runtime.onMessage.addListener(this.handleMessage);
      document.addEventListener("contextmenu", this.updateElement);
    }
    close() {
      browser$1.runtime.onMessage.removeListener(this.handleMessage);
      document.removeEventListener("contextmenu", this.updateElement);
    }
    fillActiveField(value) {
      if (this.target instanceof HTMLInputElement) {
        setInputValue(this.target, value);
      }
    }
  }
  content;
  const autosnatchNotificationIframeStateDescriptor = {
    mode: "autosnatchNotification",
    initialState: {
      intrinsicSize: {
        width: 0,
        height: 0
      },
      autosnatchInfo: void 0,
      uiState: void 0
    },
    reducer: (state, action) => {
      switch (action.type) {
        case "setIntrinsicSize":
          return {
            ...state,
            intrinsicSize: action.size
          };
        case "undo":
          return state;
        case "close":
          return state;
        case "moveLogin":
          return state;
        case "setExpanded":
          return {
            ...state,
            uiState: state.uiState ? {
              ...state.uiState,
              expanded: action.expanded
            } : void 0
          };
        case "setMoveSelected":
          return {
            ...state,
            uiState: state.uiState ? {
              ...state.uiState,
              moveSelected: action.moveSelected
            } : void 0
          };
        case "setMoveTargetInternal":
          return {
            ...state,
            uiState: state.uiState ? {
              ...state.uiState,
              moveTargetInternal: action.moveTargetInternal
            } : void 0
          };
      }
    }
  };
  content;
  function isUndoableContentLogin(l2) {
    return !!l2.undo;
  }
  content;
  const AUTOSNATCH_OVERLAY_MARGIN_PX = {
    right: 11 - AUTOSNATCH_OVERLAY_SHADOW_WIDTH_PX,
    top: 2
  };
  const STATE_KEY = "autosnatchNotificationState";
  class AutosnatchNotificationOverlayManager {
    constructor(pageLogins, stateRestorationClient, formAutosnatch) {
      __publicField(this, "connectionPort");
      __publicField(this, "iframeStateManager");
      __publicField(this, "iframePositionManager");
      __publicField(this, "connectionId");
      __publicField(this, "autosnatchTargetOptions");
      __publicField(this, "handleIframeAction", (action) => {
        var _a3, _b, _c2, _d, _e, _f, _g, _h;
        debugConsole.log("[AutosnatchNotificationOverlayManager]", "handling action", action);
        if (action.type === "undo") {
          if (!((_a3 = this.iframeStateManager.state.autosnatchInfo) == null ? void 0 : _a3.id) || !this.iframeStateManager.state.uiState) {
            return;
          }
          sendMessage({
            type: "UndoAutosnatch",
            id: (_b = this.iframeStateManager.state.autosnatchInfo) == null ? void 0 : _b.id
          }).catch(trackError);
          this.iframeStateManager.updateState({
            uiState: {
              ...this.iframeStateManager.state.uiState,
              state: ((_c2 = this.iframeStateManager.state.uiState) == null ? void 0 : _c2.state) === "passwordChanged" ? "passwordChangeUndone" : "snatchUndone"
            }
          });
        } else if (action.type === "close") {
          if ((_d = this.iframeStateManager.state.autosnatchInfo) == null ? void 0 : _d.id) {
            sendMessage({
              type: "MarkAutosnatchesSeen",
              ids: [(_e = this.iframeStateManager.state.autosnatchInfo) == null ? void 0 : _e.id]
            }).catch(trackError);
            sendMessage({
              type: "UpdateAutosnatchLogin",
              login: {
                autosnatchId: (_f = this.iframeStateManager.state.autosnatchInfo) == null ? void 0 : _f.id,
                waitForTab: false
              }
            }).catch(trackError);
            this.iframeStateManager.updateState({
              uiState: void 0,
              autosnatchInfo: void 0
            });
            this.iframePositionManager.updatePosition();
          }
        } else if (action.type === "moveLogin") {
          if (this.iframeStateManager.state.uiState) {
            sendMessage({
              type: "UpdateAutosnatchLogin",
              login: {
                autosnatchId: (_g = this.iframeStateManager.state.autosnatchInfo) == null ? void 0 : _g.id,
                overrideTargetVaultId: action.targetVaultId
              }
            }).catch(trackError);
            let organizationInfo;
            let vaultInfo;
            if (this.autosnatchTargetOptions) {
              for (const g2 of (_h = this.autosnatchTargetOptions) == null ? void 0 : _h.targetGroups) {
                for (const v2 of g2.vaults) {
                  if (v2.vaultId === action.targetVaultId) {
                    vaultInfo = {
                      id: action.targetVaultId,
                      type: VaultType.PRIVATE,
                      name: v2.label
                    };
                    organizationInfo = g2.organizationId ? {
                      name: g2.accountLabel
                    } : void 0;
                  }
                }
              }
            }
            this.iframeStateManager.updateState({
              uiState: {
                ...this.iframeStateManager.state.uiState,
                state: "loginMoved",
                moveSelected: false,
                expanded: false,
                login: {
                  ...this.iframeStateManager.state.uiState.login,
                  organizationInfo,
                  vaultInfo
                }
              }
            });
          }
        }
      });
      __publicField(this, "handleStateUpdate", ({
        oldState,
        newState
      }) => {
        if (oldState.intrinsicSize !== newState.intrinsicSize || oldState.uiState !== newState.uiState) {
          this.iframePositionManager.updatePosition();
        }
        this.stateRestorationClient.set(STATE_KEY, newState);
      });
      __publicField(this, "handleAutosnatchPerformed", (props) => {
        if (props.type === "updateRegistrationAutosnatch") {
          return;
        }
        this.updateState({
          autosnatchInfo: {
            id: props.login.autosnatchId,
            performedAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        });
      });
      __publicField(this, "handleLoginsChanged", ({
        newLogins
      }) => {
        this.updateAutosnatchLogin(newLogins);
      });
      __publicField(this, "handleMessage", makeMessageListener({
        DataUpdate: () => this.updateAutosnatchTargetOptions().catch(trackError)
      }));
      this.pageLogins = pageLogins;
      this.stateRestorationClient = stateRestorationClient;
      this.formAutosnatch = formAutosnatch;
      this.connectionId = newUuid$1();
      this.connectionPort = openConnection("ForwardContent", this.connectionId);
      const search = new URLSearchParams({
        connectionId: this.connectionId,
        mode: "autosnatchNotification",
        url: window.location.href
      });
      const url = `${browser$1.runtime.getURL("iframe.html")}?${search}`;
      this.iframePositionManager = new IframePositionManager({
        url,
        anchor: {
          top: 0,
          left: 1
        },
        margin: 0,
        getOverlayBox: this.getBox.bind(this),
        getOverlayTargetElement: () => void 0,
        style: {
          position: "fixed"
        },
        getAnimateEntry: () => {
          var _a3;
          return !((_a3 = this.iframeStateManager.state.uiState) == null ? void 0 : _a3.entryAnimationShown);
        },
        onEntryAnimated: () => this.iframeStateManager.updateState({
          uiState: this.iframeStateManager.state.uiState ? {
            ...this.iframeStateManager.state.uiState,
            entryAnimationShown: true
          } : void 0
        })
      });
      this.iframeStateManager = new IframeStateManager(autosnatchNotificationIframeStateDescriptor, this.connectionPort);
    }
    async init() {
      this.pageLogins.on("loginsChanged", this.handleLoginsChanged);
      this.iframeStateManager.on("stateUpdate", this.handleStateUpdate);
      this.iframeStateManager.on("action", this.handleIframeAction);
      this.formAutosnatch.on("autosnatchPerformed", this.handleAutosnatchPerformed);
      browser$1.runtime.onMessage.addListener(this.handleMessage);
      await this.updateAutosnatchTargetOptions();
      this.iframePositionManager.init();
      const storedState = await this.stateRestorationClient.get(STATE_KEY);
      if (storedState) {
        this.updateState(storedState);
      }
      this.handleLoginsChanged({
        newLogins: this.pageLogins.logins,
        oldLogins: []
      });
      this.iframePositionManager.updatePosition();
    }
    close() {
      this.pageLogins.off("loginsChanged", this.handleLoginsChanged);
      this.iframeStateManager.off("stateUpdate", this.handleStateUpdate);
      this.iframeStateManager.off("action", this.handleIframeAction);
      this.iframePositionManager.close();
      this.formAutosnatch.off("autosnatchPerformed", this.handleAutosnatchPerformed);
      browser$1.runtime.onMessage.removeListener(this.handleMessage);
    }
    isAutosnatchActive(autosnatchId) {
      var _a3;
      const result2 = ((_a3 = this.iframeStateManager.state.autosnatchInfo) == null ? void 0 : _a3.id) === autosnatchId && (isRecentAutosnatch(this.iframeStateManager.state.autosnatchInfo.performedAt) || this.iframeStateManager.state.uiState);
      return result2;
    }
    updateAutosnatchLogin(logins) {
      var _a3, _b, _c2, _d;
      const autosnatchInfo = this.iframeStateManager.state.autosnatchInfo;
      if (!autosnatchInfo) {
        return;
      }
      const oldState = ((_a3 = this.iframeStateManager.state.autosnatchInfo) == null ? void 0 : _a3.id) === autosnatchInfo.id ? this.iframeStateManager.state : void 0;
      if (!isRecentAutosnatch(autosnatchInfo.performedAt) && !(oldState == null ? void 0 : oldState.uiState)) {
        debugConsole.log("[AutosnatchNotificationOverlayManager] updateAutosnatchLogin", "Clearing autosnatchInfo as snatch is not recent");
        this.iframeStateManager.updateState({
          autosnatchInfo: void 0
        });
        return;
      }
      const recentAutosnatchLogin = logins.find((l2) => isUndoableContentLogin(l2) && l2.undo.id === autosnatchInfo.id);
      if (!recentAutosnatchLogin) {
        if (this.iframeStateManager.state.uiState && ((_b = this.iframeStateManager.state.uiState) == null ? void 0 : _b.state) !== "snatchUndone") {
          debugConsole.log("[AutosnatchNotificationOverlayManager] updateAutosnatchLogin", "Clearing uiState as not recentAutosnatchLoginFound");
          this.iframeStateManager.updateState({
            uiState: void 0
          });
        }
        return;
      }
      debugConsole.log("[AutosnatchNotificationOverlayManager] updateAutosnatchLogin", "updating state");
      this.updateState({
        uiState: {
          useFullVaultLabel: !!this.autosnatchTargetOptions && (this.autosnatchTargetOptions.hasDisabledProfiles || this.autosnatchTargetOptions.targetGroups.length > 1),
          expanded: false,
          moveSelected: false,
          login: {
            username: recentAutosnatchLogin.username || void 0,
            vaultInfo: recentAutosnatchLogin.vaultMetadata ? {
              id: recentAutosnatchLogin.vaultMetadata.id,
              type: recentAutosnatchLogin.vaultMetadata.type,
              name: recentAutosnatchLogin.vaultMetadata.name
            } : void 0,
            organizationInfo: recentAutosnatchLogin.organization ? {
              name: recentAutosnatchLogin.organization.name
            } : void 0,
            url: recentAutosnatchLogin.loginUrl
          },
          state: recentAutosnatchLogin.undo.type === "create" ? "snatched" : "passwordChanged",
          moveTargetInternal: (_c2 = recentAutosnatchLogin.vaultMetadata) == null ? void 0 : _c2.id,
          entryAnimationShown: ((_d = oldState == null ? void 0 : oldState.uiState) == null ? void 0 : _d.entryAnimationShown) ?? false
        }
      });
    }
    async updateAutosnatchTargetOptions() {
      const response = await sendMessage({
        type: "GetAutosnatchTargets"
      });
      if (response !== messageError) {
        this.autosnatchTargetOptions = response;
      }
    }
    updateState(stateUpdate) {
      this.iframeStateManager.updateState(stateUpdate);
      if (stateUpdate.intrinsicSize || stateUpdate.uiState) {
        this.iframePositionManager.updatePosition();
      }
    }
    getBox() {
      if (!this.iframeStateManager.state.uiState) {
        return {
          box: null,
          forceHide: true
        };
      }
      return {
        box: {
          top: AUTOSNATCH_OVERLAY_MARGIN_PX.top,
          left: window.document.documentElement.clientLeft + window.document.documentElement.clientWidth - this.iframeStateManager.state.intrinsicSize.width - AUTOSNATCH_OVERLAY_MARGIN_PX.right,
          ...this.iframeStateManager.state.intrinsicSize
        }
      };
    }
  }
  function isRecentAutosnatch(performedAt) {
    const performedAtDate = new Date(performedAt);
    return Date.now() - performedAtDate.getTime() < 10 * 1e3;
  }
  content;
  class HeyloginComConnector {
    init() {
      if (this.isHeyloginCom()) {
        document.documentElement.setAttribute("data-heylogin-extension", "");
      }
    }
    close() {
      if (this.isHeyloginCom()) {
        document.documentElement.removeAttribute("data-heylogin-extension");
      }
    }
    isHeyloginCom() {
      const {
        hostname
      } = window.location;
      const isHeyloginCom = hostname === "www.heylogin.com" || hostname === "heylogin.com";
      return isHeyloginCom;
    }
  }
  content;
  class HeyloginWebappConnector {
    constructor() {
      __publicField(this, "syncClientCoreParametersWithWebMutex", new Mutex$1());
      __publicField(this, "webextMessageListener", makeMessageListener({
        DataUpdate: () => {
          this.syncClientCoreParametersWithWeb().catch(trackError);
        }
      }));
      __publicField(this, "domMessageListener", (event) => {
        if (event.source !== window) {
          return;
        }
        const parseResult = ToExtensionMessage.safeParse(event.data);
        if (parseResult.success) {
          switch (parseResult.data.type) {
            case "clientCoreParametersChange":
              this.syncClientCoreParametersWithWeb().catch(trackError);
              return;
            case "isExtensionAvailable":
              this.sendExtensionAvailable().catch(trackError);
              return;
            case "openShortcutSettings":
              sendMessage({
                type: "OpenShortcutSettings"
              }).catch(trackError);
              return;
            case "getClientCoreParametersResponse":
              return;
            case "setClearValueFromClipboardAfterTimeout":
              sendMessage({
                type: "SetClearValueFromClipboardAfterTimeout",
                clearAfterTimeout: parseResult.data.clearAfterTimeout,
                value: parseResult.data.value
              }).catch(trackError);
              return;
            default:
              assertExhaustive(parseResult.data);
          }
        }
      });
    }
    async init() {
      window.addEventListener("message", this.domMessageListener);
      browser$1.runtime.onMessage.addListener(this.webextMessageListener);
      this.sendExtensionAvailable().catch(trackError);
      await this.syncClientCoreParametersWithWeb();
    }
    close() {
      window.removeEventListener("message", this.domMessageListener);
      browser$1.runtime.onMessage.removeListener(this.webextMessageListener);
    }
    async sendExtensionAvailable() {
      const globalSearchShortcutMsg = await sendMessage({
        type: "GetGlobalSearchShortcut"
      });
      const msg = {
        type: "extensionAvailableInfo",
        globalSearch: globalSearchShortcutMsg === messageError ? void 0 : {
          shortcut: globalSearchShortcutMsg.globalSearchShortcut
        }
      };
      window.postMessage(msg, "*");
    }
    async syncClientCoreParametersWithWeb() {
      await this.syncClientCoreParametersWithWebMutex.runExclusive(async () => {
        let webappClientCoreParameters = await this.getWebappClientCoreParameters();
        if (webappClientCoreParameters) {
          debugConsole.log("[CoreParametersWebappSync]", "updating extension CCP from webapp CCP");
          await sendMessage({
            type: "WebappClientCoreParametersExtracted",
            clientCoreParametersJSON: jsonStringifyFreeze(webappClientCoreParameters)
          });
          return;
        }
        const extensionCCPMessage = await sendMessage({
          type: "GetClientCoreParameters"
        });
        if (extensionCCPMessage === messageError || extensionCCPMessage === void 0) {
          return;
        }
        webappClientCoreParameters = await this.getWebappClientCoreParameters();
        if (webappClientCoreParameters) {
          return;
        }
        debugConsole.log("[CoreParametersWebappSync]", "updating webapp CCP from extension");
        const message = {
          type: "setClientCoreParameters",
          clientCoreParametersJSON: extensionCCPMessage.clientCoreParametersJSON
        };
        window.postMessage(message, "*");
      });
    }
    async getWebappClientCoreParameters() {
      var _a3;
      if (window.self !== window.top) {
        return null;
      }
      const responsePromise = waitForMessage((data) => GetClientCoreParametersResponseMessage.parse(data), 1e3);
      const message = {
        type: "getClientCoreParametersRequest"
      };
      window.postMessage(message, "*");
      const serializedCCP = (_a3 = await responsePromise) == null ? void 0 : _a3.clientCoreParametersJSON;
      if (serializedCCP === void 0) {
        return null;
      }
      try {
        return ClientCoreParameters.parse(jsonParseThaw(serializedCCP));
      } catch (e2) {
        await this.reportIncompatibleCCP(e2, serializedCCP);
        return null;
      }
    }
    async reportIncompatibleCCP(e2, serializedCCP) {
      const {
        reportedIncompatibleCCP
      } = await browser$1.storage.local.get("reportedIncompatibleCCP");
      if (serializedCCP === reportedIncompatibleCCP) {
        debugConsole.log("[CoreParametersWebappSync]", "got incompatible CCP, not reporting because it was reported previously");
        return;
      }
      debugConsole.log("[CoreParametersWebappSync]", "got incompatible CCP, reporting");
      trackError(e2);
      await browser$1.storage.local.set({
        reportedIncompatibleCCP: serializedCCP
      });
    }
  }
  function waitForMessage(parse, timeoutMs) {
    return new Promise((resolve) => {
      const timeoutId = window.setTimeout(() => {
        resolve(void 0);
        cleanup();
      }, timeoutMs);
      function handleMessage(event) {
        let message;
        try {
          message = parse(event.data);
        } catch (e2) {
          return;
        }
        resolve(message);
        cleanup();
      }
      function cleanup() {
        window.removeEventListener("message", handleMessage);
        window.clearTimeout(timeoutId);
      }
      window.addEventListener("message", handleMessage);
    });
  }
  content;
  var _dec$1, _class$1;
  let PageLogins = (_dec$1 = Emittery$3.mixin("emitter"), _dec$1(_class$1 = class PageLogins2 {
    constructor() {
      __publicField(this, "pageLogins", []);
      __publicField(this, "handleMessage", makeMessageListener({
        UrlUpdate: () => {
          debugConsole.log("[PageLogins]", "UrlUpdate");
          this.checkForLogin();
        },
        DataUpdate: () => {
          debugConsole.log("[PageLogins]", "DataUpdate");
          this.checkForLogin();
        }
      }));
      __publicField(this, "checkForLogin", throttle(500, () => {
        this.asyncCheckForLogin().catch(trackError);
      }));
    }
    get logins() {
      return this.pageLogins;
    }
    async init() {
      browser$1.runtime.onMessage.addListener(this.handleMessage);
      await this.asyncCheckForLogin();
    }
    close() {
      browser$1.runtime.onMessage.removeListener(this.handleMessage);
    }
    async asyncCheckForLogin() {
      const oldLogins = this.pageLogins;
      const getLoginsResponse = await sendMessage({
        type: "GetLogins"
      });
      if (getLoginsResponse === messageError) {
        return;
      }
      debugConsole.log("[PageLogins]", "asyncCheckForLogin", getLoginsResponse);
      const newLogins = (getLoginsResponse == null ? void 0 : getLoginsResponse.logins) ?? [];
      this.pageLogins = newLogins;
      if (!Ee$1(oldLogins, newLogins)) {
        await this.emitter.emit("loginsChanged", {
          oldLogins,
          newLogins
        });
      }
    }
  }) || _class$1);
  content;
  var _dec, _class;
  const TOTP_QR_MIN_SIZE = 80;
  const TOTP_QR_MIN_ASPECT_RATIO = 0.95;
  const TOTP_QR_MAX_ASPECT_RATIO = 1.05;
  let TotpQrDetector = (_dec = Emittery$3.mixin("emitter"), _dec(_class = class TotpQrDetector2 {
    constructor() {
      __publicField(this, "qrElementCandidates", /* @__PURE__ */ new Set());
      __publicField(this, "mutationObserver");
      __publicField(this, "intersectionObserver");
      __publicField(this, "detectedTotpQr", null);
      __publicField(this, "updateCandidateElementsInProgress", false);
      __publicField(this, "updateTotpQrInProgress", false);
      __publicField(this, "updateCandidateElementsRafId", NaN);
      __publicField(this, "updateCandidateElementsDebounced", debounce$1(250, () => {
        window.cancelAnimationFrame(this.updateCandidateElementsRafId);
        this.updateCandidateElementsRafId = window.requestAnimationFrame(() => {
          this.updateCandidateElements().catch(trackError);
        });
      }));
      this.mutationObserver = new ShadowRootAwareMutationObserver(this.updateCandidateElementsDebounced, this.updateCandidateElementsDebounced);
    }
    get totpQr() {
      return this.detectedTotpQr;
    }
    init() {
      this.updateCandidateElements().catch(trackError);
      this.mutationObserver.observe(document.getRootNode());
      document.documentElement.addEventListener("load", this.updateCandidateElementsDebounced, true);
      window.addEventListener("load", this.updateCandidateElementsDebounced);
    }
    close() {
      var _a3;
      this.mutationObserver.disconnect();
      (_a3 = this.intersectionObserver) == null ? void 0 : _a3.disconnect();
      document.documentElement.removeEventListener("load", this.updateCandidateElementsDebounced, true);
      window.removeEventListener("load", this.updateCandidateElementsDebounced);
    }
    async updateCandidateElements() {
      if (this.updateCandidateElementsInProgress) {
        debugConsole.log("[TotpQrDetector]", "skipping update candidates due to it still running");
        return;
      }
      try {
        this.updateCandidateElementsInProgress = true;
        await this.doUpdateCandidateElements();
      } finally {
        this.updateCandidateElementsInProgress = false;
      }
    }
    async doUpdateCandidateElements() {
      const possibleCandidateElements = Array.from(querySelectorAllWithShadowRoots('img[src^="data:"], img[src*="qr"], svg, canvas, table[class*="qr"]'));
      const newCandidates = possibleCandidateElements.filter((el2) => {
        const {
          width,
          height
        } = el2.getBoundingClientRect();
        if (width < TOTP_QR_MIN_SIZE || height < TOTP_QR_MIN_SIZE) {
          return false;
        }
        const aspectRatio = width / height;
        return aspectRatio >= TOTP_QR_MIN_ASPECT_RATIO && aspectRatio <= TOTP_QR_MAX_ASPECT_RATIO;
      });
      const candidatesChanged = newCandidates.length !== this.qrElementCandidates.size || newCandidates.some((el2) => !this.qrElementCandidates.has(el2));
      if (candidatesChanged) {
        debugConsole.log("[TotpQrDetector]", "candidates changed", newCandidates);
        this.qrElementCandidates = new Set(newCandidates);
        await this.updateTotpQr();
        this.setupIntersectionObserver();
      }
    }
    setupIntersectionObserver() {
      var _a3;
      (_a3 = this.intersectionObserver) == null ? void 0 : _a3.disconnect();
      if (this.qrElementCandidates.size === 0) {
        this.intersectionObserver = void 0;
        return;
      }
      this.intersectionObserver = new IntersectionObserver((entries) => {
        var _a4;
        if (!((_a4 = this.detectedTotpQr) == null ? void 0 : _a4.element) && entries.some((e2) => e2.isIntersecting)) {
          this.updateTotpQr().catch(trackError);
        }
      }, {
        threshold: 1
      });
      for (const candidate of this.qrElementCandidates) {
        this.intersectionObserver.observe(candidate);
      }
    }
    async updateTotpQr() {
      if (this.updateTotpQrInProgress) {
        debugConsole.log("[TotpQrDetector]", "skipping update totp qr due to it still running");
        return;
      }
      try {
        this.updateTotpQrInProgress = true;
        await this.doUpdateTotpQr();
      } finally {
        this.updateTotpQrInProgress = false;
      }
    }
    async doUpdateTotpQr() {
      const oldTotpQr = this.detectedTotpQr;
      const newTotpQr = await this.detectTotpQr();
      if ((newTotpQr == null ? void 0 : newTotpQr.element) !== (oldTotpQr == null ? void 0 : oldTotpQr.element) || !Ee$1(newTotpQr == null ? void 0 : newTotpQr.totpParameters, oldTotpQr == null ? void 0 : oldTotpQr.totpParameters)) {
        debugConsole.log("[TotpQrDetector]", "new detection", newTotpQr);
        this.detectedTotpQr = newTotpQr;
        await this.emitter.emit("totpQrChanged", {
          oldTotpQr,
          newTotpQr
        });
      }
    }
    async detectTotpQr() {
      if (this.qrElementCandidates.size === 0) {
        return null;
      }
      const rects = [...this.qrElementCandidates].map((c2) => {
        const {
          left,
          right,
          bottom,
          top
        } = c2.getBoundingClientRect();
        return {
          left,
          right,
          bottom,
          top
        };
      });
      const response = await this.getResponseWithRetry(rects, window.devicePixelRatio);
      if (response === messageError || response.status !== "found") {
        return null;
      }
      const elements = document.elementsFromPoint(response.x, response.y);
      const element = elements.find((el2) => this.qrElementCandidates.has(el2)) ?? this.qrElementCandidates.values().next().value;
      return {
        element,
        totpParameters: response.totpParameters
      };
    }
    async getResponseWithRetry(rects, devicePixelRatio) {
      let tries = 0;
      let response;
      do {
        if (tries) {
          const delayMs = 1e3 * 2 ** Math.min(tries, 4);
          debugConsole.log("[TotpQrDetector]", `got recoverable error retrying in ${delayMs} ms`);
          await sleep(delayMs);
        }
        response = await sendMessage({
          type: "DetectTotpQrSecretForTab",
          rects,
          devicePixelRatio
        });
        tries += 1;
        if (tries > 10) {
          return {
            status: "notFound"
          };
        }
      } while (response !== messageError && response.status === "retryLater");
      return response;
    }
  }) || _class);
  content;
  const totpQrIframeStateDescriptor = {
    mode: "totpQr",
    initialState: {
      hidden: false,
      intrinsicSize: {
        width: 0,
        height: 0
      }
    },
    reducer: (state, action) => {
      switch (action.type) {
        case "setIntrinsicSize":
          return {
            ...state,
            intrinsicSize: action.size
          };
        case "setHidden":
          return {
            ...state,
            hidden: action.hidden
          };
      }
    }
  };
  content;
  class TotpQrSaver {
    constructor(pageLogins, totpQrDetector) {
      __publicField(this, "iframePositionManager");
      __publicField(this, "iframeStateManager");
      __publicField(this, "visible", false);
      __publicField(this, "connectionId");
      __publicField(this, "connectionPort");
      __publicField(this, "handleStateUpdate", ({
        oldState,
        newState
      }) => {
        if (oldState.hidden !== newState.hidden) {
          this.setOverlayVisible(!newState.hidden);
        }
        if (oldState.intrinsicSize !== newState.intrinsicSize) {
          this.iframePositionManager.updatePosition();
        }
      });
      __publicField(this, "handleLoginsChanged", () => {
        this.iframeStateManager.updateState({
          logins: this.pageLogins.logins
        });
        this.iframePositionManager.updatePosition();
      });
      __publicField(this, "handleQrCodeChanged", () => {
        var _a3;
        this.iframeStateManager.updateState({
          totpParameters: (_a3 = this.totpQrDetector.totpQr) == null ? void 0 : _a3.totpParameters
        });
        this.iframePositionManager.updatePosition();
      });
      this.pageLogins = pageLogins;
      this.totpQrDetector = totpQrDetector;
      this.connectionId = newUuid$1();
      this.connectionPort = openConnection("ForwardContent", this.connectionId);
      const url = this.getIframeUrl(this.connectionId);
      this.iframePositionManager = new IframePositionManager({
        url,
        anchor: {
          top: 0.5,
          left: 0.5
        },
        margin: 0,
        getOverlayBox: this.getTotpQrBox.bind(this),
        getStyle: () => ({
          boxShadow: T$1
        }),
        attributes: {
          allow: "publickey-credentials-get *"
        }
      });
      this.iframeStateManager = new IframeStateManager(totpQrIframeStateDescriptor, this.connectionPort);
    }
    getIframeUrl(connectionId) {
      const params = new URLSearchParams({
        connectionId,
        mode: "totpQr"
      });
      const search = params.toString();
      const url = `${browser$1.runtime.getURL("iframe.html")}?${search}`;
      return url;
    }
    init() {
      var _a3;
      this.setOverlayVisible(true);
      this.iframeStateManager.on("stateUpdate", this.handleStateUpdate);
      this.iframeStateManager.updateState({
        totpParameters: (_a3 = this.totpQrDetector.totpQr) == null ? void 0 : _a3.totpParameters,
        logins: this.pageLogins.logins
      });
    }
    close() {
      this.setOverlayVisible(false);
      this.iframeStateManager.off("stateUpdate", this.handleStateUpdate);
      this.iframeStateManager.updateState({
        hidden: true
      });
    }
    setOverlayVisible(visible) {
      if (this.visible === visible) {
        return;
      }
      this.visible = visible;
      if (visible) {
        this.pageLogins.on("loginsChanged", this.handleLoginsChanged);
        this.totpQrDetector.on("totpQrChanged", this.handleQrCodeChanged);
        this.iframePositionManager.init();
      } else {
        this.pageLogins.off("loginsChanged", this.handleLoginsChanged);
        this.totpQrDetector.off("totpQrChanged", this.handleQrCodeChanged);
        this.iframePositionManager.close();
      }
    }
    getTotpQrBox() {
      var _a3;
      if (!this.pageLogins.logins.length) {
        return {
          box: null
        };
      }
      const qrEl = (_a3 = this.totpQrDetector.totpQr) == null ? void 0 : _a3.element;
      if (!qrEl) {
        return {
          box: null
        };
      }
      const qrElBox = getBox(qrEl);
      if (!qrElBox) {
        return {
          box: null
        };
      }
      return {
        box: {
          top: qrElBox.top,
          left: qrElBox.left,
          width: qrElBox.width,
          height: qrElBox.height
        }
      };
    }
  }
  content;
  const ACTIVITY_EVENT_TYPES = ["mousedown", "keydown"];
  const THROTTLE_SECONDS = 10;
  class UserActivityTracker {
    constructor() {
      __publicField(this, "updateLastActivity", throttle(1e3 * THROTTLE_SECONDS, () => {
        sendMessage({
          type: "PingActivity"
        }).catch(trackError);
      }));
    }
    init() {
      const listenerOptions = {
        capture: true
      };
      for (const eventType of ACTIVITY_EVENT_TYPES) {
        window.addEventListener(eventType, this.updateLastActivity, listenerOptions);
      }
    }
    close() {
      const listenerOptions = {
        capture: true
      };
      for (const eventType of ACTIVITY_EVENT_TYPES) {
        window.removeEventListener(eventType, this.updateLastActivity, listenerOptions);
      }
    }
  }
  content;
  const _GlobalListenersRemoved = class _GlobalListenersRemoved {
    constructor(onGlobalListenersRemoved) {
      __publicField(this, "eventTimeoutId");
      __publicField(this, "mutationObserver");
      __publicField(this, "handleMutations", (entries) => {
        const documentReplaced = entries.some((entry) => Array.from(entry.addedNodes).includes(document.documentElement));
        if (documentReplaced) {
          this.eventTimeoutId = window.setTimeout(this.handleEventNotEmitted);
          window.dispatchEvent(new CustomEvent(_GlobalListenersRemoved.TEST_EVENT_NAME, {
            detail: this.eventTimeoutId
          }));
        }
      });
      __publicField(this, "handleTestEvent", (e2) => {
        if (e2 instanceof CustomEvent && typeof e2.detail === "number") {
          window.clearTimeout(e2.detail);
        }
      });
      __publicField(this, "handleEventNotEmitted", () => {
        this.onGlobalListenersRemoved();
      });
      this.onGlobalListenersRemoved = onGlobalListenersRemoved;
      this.mutationObserver = new MutationObserver(this.handleMutations.bind(this));
    }
    init() {
      window.addEventListener(_GlobalListenersRemoved.TEST_EVENT_NAME, this.handleTestEvent);
      this.mutationObserver.observe(document, {
        childList: true
      });
    }
    close() {
      window.removeEventListener(_GlobalListenersRemoved.TEST_EVENT_NAME, this.handleTestEvent);
      this.mutationObserver.disconnect();
    }
  };
  __publicField(_GlobalListenersRemoved, "TEST_EVENT_NAME", "listenerStillAttachedTestEvent");
  let GlobalListenersRemoved = _GlobalListenersRemoved;
  content;
  var Call$1;
  var hasRequiredCall;
  function requireCall() {
    if (hasRequiredCall)
      return Call$1;
    hasRequiredCall = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var callBound2 = callBound$8;
    var $apply = GetIntrinsic2("%Reflect.apply%", true) || callBound2("%Function.prototype.apply%");
    Call$1 = function Call2(F2, V2) {
      var args = arguments.length > 2 ? arguments[2] : [];
      return $apply(F2, V2, args);
    };
    return Call$1;
  }
  var IsPropertyKey$2;
  var hasRequiredIsPropertyKey;
  function requireIsPropertyKey() {
    if (hasRequiredIsPropertyKey)
      return IsPropertyKey$2;
    hasRequiredIsPropertyKey = 1;
    IsPropertyKey$2 = function IsPropertyKey2(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
    return IsPropertyKey$2;
  }
  var Type$5 = function Type2(x2) {
    if (x2 === null) {
      return "Null";
    }
    if (typeof x2 === "undefined") {
      return "Undefined";
    }
    if (typeof x2 === "function" || typeof x2 === "object") {
      return "Object";
    }
    if (typeof x2 === "number") {
      return "Number";
    }
    if (typeof x2 === "boolean") {
      return "Boolean";
    }
    if (typeof x2 === "string") {
      return "String";
    }
  };
  var ES5Type = Type$5;
  var Type$4 = function Type2(x2) {
    if (typeof x2 === "symbol") {
      return "Symbol";
    }
    return ES5Type(x2);
  };
  var GetIntrinsic$5 = GetIntrinsic$d;
  var $TypeError$3 = GetIntrinsic$5("%TypeError%");
  var inspect$1 = objectInspect;
  var IsPropertyKey$1 = requireIsPropertyKey();
  var Type$3 = Type$4;
  var Get$2 = function Get2(O2, P2) {
    if (Type$3(O2) !== "Object") {
      throw new $TypeError$3("Assertion failed: Type(O) is not Object");
    }
    if (!IsPropertyKey$1(P2)) {
      throw new $TypeError$3("Assertion failed: IsPropertyKey(P) is not true, got " + inspect$1(P2));
    }
    return O2[P2];
  };
  var getIteratorMethod;
  var hasRequiredGetIteratorMethod;
  function requireGetIteratorMethod() {
    if (hasRequiredGetIteratorMethod)
      return getIteratorMethod;
    hasRequiredGetIteratorMethod = 1;
    var hasSymbols2 = hasSymbols$7();
    var GetIntrinsic2 = GetIntrinsic$d;
    var callBound2 = callBound$8;
    var $iterator2 = GetIntrinsic2("%Symbol.iterator%", true);
    var $stringSlice2 = callBound2("String.prototype.slice");
    getIteratorMethod = function getIteratorMethod2(ES, iterable) {
      var usingIterator;
      if (hasSymbols2) {
        usingIterator = ES.GetMethod(iterable, $iterator2);
      } else if (ES.IsArray(iterable)) {
        usingIterator = function() {
          var i2 = -1;
          var arr = this;
          return {
            next: function() {
              i2 += 1;
              return {
                done: i2 >= arr.length,
                value: arr[i2]
              };
            }
          };
        };
      } else if (ES.Type(iterable) === "String") {
        usingIterator = function() {
          var i2 = 0;
          return {
            next: function() {
              var nextIndex = ES.AdvanceStringIndex(iterable, i2, true);
              var value = $stringSlice2(iterable, i2, nextIndex);
              i2 = nextIndex;
              return {
                done: nextIndex > iterable.length,
                value
              };
            }
          };
        };
      }
      return usingIterator;
    };
    return getIteratorMethod;
  }
  var _isNaN;
  var hasRequired_isNaN;
  function require_isNaN() {
    if (hasRequired_isNaN)
      return _isNaN;
    hasRequired_isNaN = 1;
    _isNaN = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
    return _isNaN;
  }
  var _isFinite;
  var hasRequired_isFinite;
  function require_isFinite() {
    if (hasRequired_isFinite)
      return _isFinite;
    hasRequired_isFinite = 1;
    var $isNaN = Number.isNaN || function(a) {
      return a !== a;
    };
    _isFinite = Number.isFinite || function(x2) {
      return typeof x2 === "number" && !$isNaN(x2) && x2 !== Infinity && x2 !== -Infinity;
    };
    return _isFinite;
  }
  var IsInteger;
  var hasRequiredIsInteger;
  function requireIsInteger() {
    if (hasRequiredIsInteger)
      return IsInteger;
    hasRequiredIsInteger = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $Math = GetIntrinsic2("%Math%");
    var $floor = $Math.floor;
    var $abs = $Math.abs;
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    IsInteger = function IsInteger2(argument) {
      if (typeof argument !== "number" || $isNaN(argument) || !$isFinite(argument)) {
        return false;
      }
      var abs = $abs(argument);
      return $floor(abs) === abs;
    };
    return IsInteger;
  }
  var maxSafeInteger;
  var hasRequiredMaxSafeInteger;
  function requireMaxSafeInteger() {
    if (hasRequiredMaxSafeInteger)
      return maxSafeInteger;
    hasRequiredMaxSafeInteger = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $Math = GetIntrinsic2("%Math%");
    var $Number = GetIntrinsic2("%Number%");
    maxSafeInteger = $Number.MAX_SAFE_INTEGER || $Math.pow(2, 53) - 1;
    return maxSafeInteger;
  }
  var AdvanceStringIndex;
  var hasRequiredAdvanceStringIndex;
  function requireAdvanceStringIndex() {
    if (hasRequiredAdvanceStringIndex)
      return AdvanceStringIndex;
    hasRequiredAdvanceStringIndex = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var IsInteger2 = requireIsInteger();
    var Type2 = Type$4;
    var MAX_SAFE_INTEGER2 = requireMaxSafeInteger();
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var $charCodeAt2 = callBound$8("String.prototype.charCodeAt");
    AdvanceStringIndex = function AdvanceStringIndex2(S2, index2, unicode) {
      if (Type2(S2) !== "String") {
        throw new $TypeError2("Assertion failed: `S` must be a String");
      }
      if (!IsInteger2(index2) || index2 < 0 || index2 > MAX_SAFE_INTEGER2) {
        throw new $TypeError2("Assertion failed: `length` must be an integer >= 0 and <= 2**53");
      }
      if (Type2(unicode) !== "Boolean") {
        throw new $TypeError2("Assertion failed: `unicode` must be a Boolean");
      }
      if (!unicode) {
        return index2 + 1;
      }
      var length = S2.length;
      if (index2 + 1 >= length) {
        return index2 + 1;
      }
      var first = $charCodeAt2(S2, index2);
      if (first < 55296 || first > 56319) {
        return index2 + 1;
      }
      var second = $charCodeAt2(S2, index2 + 1);
      if (second < 56320 || second > 57343) {
        return index2 + 1;
      }
      return index2 + 2;
    };
    return AdvanceStringIndex;
  }
  var GetIntrinsic$4 = GetIntrinsic$d;
  var $TypeError$2 = GetIntrinsic$4("%TypeError%");
  var CheckObjectCoercible = function CheckObjectCoercible2(value, optMessage) {
    if (value == null) {
      throw new $TypeError$2(optMessage || "Cannot call method on " + value);
    }
    return value;
  };
  var RequireObjectCoercible$1 = CheckObjectCoercible;
  var ToObject;
  var hasRequiredToObject;
  function requireToObject() {
    if (hasRequiredToObject)
      return ToObject;
    hasRequiredToObject = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $Object2 = GetIntrinsic2("%Object%");
    var RequireObjectCoercible2 = RequireObjectCoercible$1;
    ToObject = function ToObject2(value) {
      RequireObjectCoercible2(value);
      return $Object2(value);
    };
    return ToObject;
  }
  var GetV;
  var hasRequiredGetV;
  function requireGetV() {
    if (hasRequiredGetV)
      return GetV;
    hasRequiredGetV = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var IsPropertyKey2 = requireIsPropertyKey();
    var ToObject2 = requireToObject();
    GetV = function GetV2(V2, P2) {
      if (!IsPropertyKey2(P2)) {
        throw new $TypeError2("Assertion failed: IsPropertyKey(P) is not true");
      }
      var O2 = ToObject2(V2);
      return O2[P2];
    };
    return GetV;
  }
  var isCallable;
  var hasRequiredIsCallable$1;
  function requireIsCallable$1() {
    if (hasRequiredIsCallable$1)
      return isCallable;
    hasRequiredIsCallable$1 = 1;
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_2) {
        if (_2 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e2) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var toStr2 = Object.prototype.toString;
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var hasToStringTag2 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
    isCallable = reflectApply ? function isCallable2(value) {
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (typeof value === "function" && !value.prototype) {
        return true;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e2) {
        if (e2 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value);
    } : function isCallable2(value) {
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (typeof value === "function" && !value.prototype) {
        return true;
      }
      if (hasToStringTag2) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass2 = toStr2.call(value);
      return strClass2 === fnClass || strClass2 === genClass;
    };
    return isCallable;
  }
  var IsCallable$1;
  var hasRequiredIsCallable;
  function requireIsCallable() {
    if (hasRequiredIsCallable)
      return IsCallable$1;
    hasRequiredIsCallable = 1;
    IsCallable$1 = requireIsCallable$1();
    return IsCallable$1;
  }
  var GetMethod;
  var hasRequiredGetMethod;
  function requireGetMethod() {
    if (hasRequiredGetMethod)
      return GetMethod;
    hasRequiredGetMethod = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var GetV2 = requireGetV();
    var IsCallable2 = requireIsCallable();
    var IsPropertyKey2 = requireIsPropertyKey();
    GetMethod = function GetMethod2(O2, P2) {
      if (!IsPropertyKey2(P2)) {
        throw new $TypeError2("Assertion failed: IsPropertyKey(P) is not true");
      }
      var func = GetV2(O2, P2);
      if (func == null) {
        return void 0;
      }
      if (!IsCallable2(func)) {
        throw new $TypeError2(P2 + "is not a function");
      }
      return func;
    };
    return GetMethod;
  }
  var GetIntrinsic$3 = GetIntrinsic$d;
  var $Array = GetIntrinsic$3("%Array%");
  var toStr = !$Array.isArray && callBound$8("Object.prototype.toString");
  var IsArray$1 = $Array.isArray || function IsArray2(argument) {
    return toStr(argument) === "[object Array]";
  };
  var GetIterator$1;
  var hasRequiredGetIterator;
  function requireGetIterator() {
    if (hasRequiredGetIterator)
      return GetIterator$1;
    hasRequiredGetIterator = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var getIteratorMethod2 = requireGetIteratorMethod();
    var AdvanceStringIndex2 = requireAdvanceStringIndex();
    var Call2 = requireCall();
    var GetMethod2 = requireGetMethod();
    var IsArray2 = IsArray$1;
    var Type2 = Type$4;
    GetIterator$1 = function GetIterator2(obj, method) {
      var actualMethod = method;
      if (arguments.length < 2) {
        actualMethod = getIteratorMethod2(
          {
            AdvanceStringIndex: AdvanceStringIndex2,
            GetMethod: GetMethod2,
            IsArray: IsArray2,
            Type: Type2
          },
          obj
        );
      }
      var iterator2 = Call2(actualMethod, obj);
      if (Type2(iterator2) !== "Object") {
        throw new $TypeError2("iterator must return an object");
      }
      return iterator2;
    };
    return GetIterator$1;
  }
  var IteratorClose$1;
  var hasRequiredIteratorClose;
  function requireIteratorClose() {
    if (hasRequiredIteratorClose)
      return IteratorClose$1;
    hasRequiredIteratorClose = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var Call2 = requireCall();
    var GetMethod2 = requireGetMethod();
    var IsCallable2 = requireIsCallable();
    var Type2 = Type$4;
    IteratorClose$1 = function IteratorClose2(iterator2, completion) {
      if (Type2(iterator2) !== "Object") {
        throw new $TypeError2("Assertion failed: Type(iterator) is not Object");
      }
      if (!IsCallable2(completion)) {
        throw new $TypeError2("Assertion failed: completion is not a thunk for a Completion Record");
      }
      var completionThunk = completion;
      var iteratorReturn = GetMethod2(iterator2, "return");
      if (typeof iteratorReturn === "undefined") {
        return completionThunk();
      }
      var completionRecord;
      try {
        var innerResult = Call2(iteratorReturn, iterator2, []);
      } catch (e2) {
        completionThunk();
        completionThunk = null;
        throw e2;
      }
      completionRecord = completionThunk();
      completionThunk = null;
      if (Type2(innerResult) !== "Object") {
        throw new $TypeError2("iterator .return must return an object");
      }
      return completionRecord;
    };
    return IteratorClose$1;
  }
  var ToBoolean;
  var hasRequiredToBoolean;
  function requireToBoolean() {
    if (hasRequiredToBoolean)
      return ToBoolean;
    hasRequiredToBoolean = 1;
    ToBoolean = function ToBoolean2(value) {
      return !!value;
    };
    return ToBoolean;
  }
  var IteratorComplete;
  var hasRequiredIteratorComplete;
  function requireIteratorComplete() {
    if (hasRequiredIteratorComplete)
      return IteratorComplete;
    hasRequiredIteratorComplete = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var Get2 = Get$2;
    var ToBoolean2 = requireToBoolean();
    var Type2 = Type$4;
    IteratorComplete = function IteratorComplete2(iterResult) {
      if (Type2(iterResult) !== "Object") {
        throw new $TypeError2("Assertion failed: Type(iterResult) is not Object");
      }
      return ToBoolean2(Get2(iterResult, "done"));
    };
    return IteratorComplete;
  }
  var Invoke;
  var hasRequiredInvoke;
  function requireInvoke() {
    if (hasRequiredInvoke)
      return Invoke;
    hasRequiredInvoke = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var $arraySlice = callBound$8("Array.prototype.slice");
    var Call2 = requireCall();
    var GetV2 = requireGetV();
    var IsPropertyKey2 = requireIsPropertyKey();
    Invoke = function Invoke2(O2, P2) {
      if (!IsPropertyKey2(P2)) {
        throw new $TypeError2("P must be a Property Key");
      }
      var argumentsList = $arraySlice(arguments, 2);
      var func = GetV2(O2, P2);
      return Call2(func, O2, argumentsList);
    };
    return Invoke;
  }
  var IteratorNext;
  var hasRequiredIteratorNext;
  function requireIteratorNext() {
    if (hasRequiredIteratorNext)
      return IteratorNext;
    hasRequiredIteratorNext = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var Invoke2 = requireInvoke();
    var Type2 = Type$4;
    IteratorNext = function IteratorNext2(iterator2, value) {
      var result2 = Invoke2(iterator2, "next", arguments.length < 2 ? [] : [value]);
      if (Type2(result2) !== "Object") {
        throw new $TypeError2("iterator next must return an object");
      }
      return result2;
    };
    return IteratorNext;
  }
  var IteratorStep$1;
  var hasRequiredIteratorStep;
  function requireIteratorStep() {
    if (hasRequiredIteratorStep)
      return IteratorStep$1;
    hasRequiredIteratorStep = 1;
    var IteratorComplete2 = requireIteratorComplete();
    var IteratorNext2 = requireIteratorNext();
    IteratorStep$1 = function IteratorStep2(iterator2) {
      var result2 = IteratorNext2(iterator2);
      var done = IteratorComplete2(result2);
      return done === true ? false : result2;
    };
    return IteratorStep$1;
  }
  var IteratorValue$1;
  var hasRequiredIteratorValue;
  function requireIteratorValue() {
    if (hasRequiredIteratorValue)
      return IteratorValue$1;
    hasRequiredIteratorValue = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var Get2 = Get$2;
    var Type2 = Type$4;
    IteratorValue$1 = function IteratorValue2(iterResult) {
      if (Type2(iterResult) !== "Object") {
        throw new $TypeError2("Assertion failed: Type(iterResult) is not Object");
      }
      return Get2(iterResult, "value");
    };
    return IteratorValue$1;
  }
  var inspect = objectInspect;
  var GetIntrinsic$2 = GetIntrinsic$d;
  var $TypeError$1 = GetIntrinsic$2("%TypeError%");
  var Call = requireCall();
  var Get$1 = Get$2;
  var GetIterator = requireGetIterator();
  var IsCallable = requireIsCallable();
  var IteratorClose = requireIteratorClose();
  var IteratorStep = requireIteratorStep();
  var IteratorValue = requireIteratorValue();
  var Type$2 = Type$4;
  var AddEntriesFromIterable$1 = function AddEntriesFromIterable2(target, iterable, adder2) {
    if (!IsCallable(adder2)) {
      throw new $TypeError$1("Assertion failed: `adder` is not callable");
    }
    if (iterable == null) {
      throw new $TypeError$1("Assertion failed: `iterable` is present, and not nullish");
    }
    var iteratorRecord = GetIterator(iterable);
    while (true) {
      var next = IteratorStep(iteratorRecord);
      if (!next) {
        return target;
      }
      var nextItem = IteratorValue(next);
      if (Type$2(nextItem) !== "Object") {
        var error2 = new $TypeError$1("iterator next must return an Object, got " + inspect(nextItem));
        return IteratorClose(
          iteratorRecord,
          function() {
            throw error2;
          }
          // eslint-disable-line no-loop-func
        );
      }
      try {
        var k2 = Get$1(nextItem, "0");
        var v2 = Get$1(nextItem, "1");
        Call(adder2, target, [k2, v2]);
      } catch (e2) {
        return IteratorClose(
          iteratorRecord,
          function() {
            throw e2;
          }
        );
      }
    }
  };
  var DefineOwnProperty;
  var hasRequiredDefineOwnProperty;
  function requireDefineOwnProperty() {
    if (hasRequiredDefineOwnProperty)
      return DefineOwnProperty;
    hasRequiredDefineOwnProperty = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = null;
      }
    }
    var callBound2 = callBound$8;
    var $isEnumerable = callBound2("Object.prototype.propertyIsEnumerable");
    DefineOwnProperty = function DefineOwnProperty2(IsDataDescriptor2, SameValue2, FromPropertyDescriptor2, O2, P2, desc) {
      if (!$defineProperty) {
        if (!IsDataDescriptor2(desc)) {
          return false;
        }
        if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
          return false;
        }
        if (P2 in O2 && $isEnumerable(O2, P2) !== !!desc["[[Enumerable]]"]) {
          return false;
        }
        var V2 = desc["[[Value]]"];
        O2[P2] = V2;
        return SameValue2(O2[P2], V2);
      }
      $defineProperty(O2, P2, FromPropertyDescriptor2(desc));
      return true;
    };
    return DefineOwnProperty;
  }
  var assertRecord;
  var hasRequiredAssertRecord;
  function requireAssertRecord() {
    if (hasRequiredAssertRecord)
      return assertRecord;
    hasRequiredAssertRecord = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var $SyntaxError2 = GetIntrinsic2("%SyntaxError%");
    var has2 = src;
    var predicates = {
      // https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
      "Property Descriptor": function isPropertyDescriptor(Type2, Desc) {
        if (Type2(Desc) !== "Object") {
          return false;
        }
        var allowed = {
          "[[Configurable]]": true,
          "[[Enumerable]]": true,
          "[[Get]]": true,
          "[[Set]]": true,
          "[[Value]]": true,
          "[[Writable]]": true
        };
        for (var key in Desc) {
          if (has2(Desc, key) && !allowed[key]) {
            return false;
          }
        }
        var isData = has2(Desc, "[[Value]]");
        var IsAccessor = has2(Desc, "[[Get]]") || has2(Desc, "[[Set]]");
        if (isData && IsAccessor) {
          throw new $TypeError2("Property Descriptors may not be both accessor and data descriptors");
        }
        return true;
      }
    };
    assertRecord = function assertRecord2(Type2, recordType2, argumentName, value) {
      var predicate = predicates[recordType2];
      if (typeof predicate !== "function") {
        throw new $SyntaxError2("unknown record type: " + recordType2);
      }
      if (!predicate(Type2, value)) {
        throw new $TypeError2(argumentName + " must be a " + recordType2);
      }
    };
    return assertRecord;
  }
  var FromPropertyDescriptor;
  var hasRequiredFromPropertyDescriptor;
  function requireFromPropertyDescriptor() {
    if (hasRequiredFromPropertyDescriptor)
      return FromPropertyDescriptor;
    hasRequiredFromPropertyDescriptor = 1;
    var assertRecord2 = requireAssertRecord();
    var Type2 = Type$4;
    FromPropertyDescriptor = function FromPropertyDescriptor2(Desc) {
      if (typeof Desc === "undefined") {
        return Desc;
      }
      assertRecord2(Type2, "Property Descriptor", "Desc", Desc);
      var obj = {};
      if ("[[Value]]" in Desc) {
        obj.value = Desc["[[Value]]"];
      }
      if ("[[Writable]]" in Desc) {
        obj.writable = Desc["[[Writable]]"];
      }
      if ("[[Get]]" in Desc) {
        obj.get = Desc["[[Get]]"];
      }
      if ("[[Set]]" in Desc) {
        obj.set = Desc["[[Set]]"];
      }
      if ("[[Enumerable]]" in Desc) {
        obj.enumerable = Desc["[[Enumerable]]"];
      }
      if ("[[Configurable]]" in Desc) {
        obj.configurable = Desc["[[Configurable]]"];
      }
      return obj;
    };
    return FromPropertyDescriptor;
  }
  var IsRegExp;
  var hasRequiredIsRegExp;
  function requireIsRegExp() {
    if (hasRequiredIsRegExp)
      return IsRegExp;
    hasRequiredIsRegExp = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $match = GetIntrinsic2("%Symbol.match%", true);
    var hasRegExpMatcher = isRegex$1;
    var ToBoolean2 = requireToBoolean();
    IsRegExp = function IsRegExp2(argument) {
      if (!argument || typeof argument !== "object") {
        return false;
      }
      if ($match) {
        var isRegExp2 = argument[$match];
        if (typeof isRegExp2 !== "undefined") {
          return ToBoolean2(isRegExp2);
        }
      }
      return hasRegExpMatcher(argument);
    };
    return IsRegExp;
  }
  var ToPropertyDescriptor;
  var hasRequiredToPropertyDescriptor;
  function requireToPropertyDescriptor() {
    if (hasRequiredToPropertyDescriptor)
      return ToPropertyDescriptor;
    hasRequiredToPropertyDescriptor = 1;
    var has2 = src;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var Type2 = Type$4;
    var ToBoolean2 = requireToBoolean();
    var IsCallable2 = requireIsCallable();
    ToPropertyDescriptor = function ToPropertyDescriptor2(Obj) {
      if (Type2(Obj) !== "Object") {
        throw new $TypeError2("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (has2(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean2(Obj.enumerable);
      }
      if (has2(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean2(Obj.configurable);
      }
      if (has2(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (has2(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean2(Obj.writable);
      }
      if (has2(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable2(getter)) {
          throw new $TypeError2("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (has2(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable2(setter)) {
          throw new $TypeError2("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((has2(desc, "[[Get]]") || has2(desc, "[[Set]]")) && (has2(desc, "[[Value]]") || has2(desc, "[[Writable]]"))) {
        throw new $TypeError2("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
    return ToPropertyDescriptor;
  }
  var OrdinaryGetOwnProperty;
  var hasRequiredOrdinaryGetOwnProperty;
  function requireOrdinaryGetOwnProperty() {
    if (hasRequiredOrdinaryGetOwnProperty)
      return OrdinaryGetOwnProperty;
    hasRequiredOrdinaryGetOwnProperty = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $gOPD2 = requireGetOwnPropertyDescriptor$1();
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var callBound2 = callBound$8;
    var $isEnumerable = callBound2("Object.prototype.propertyIsEnumerable");
    var has2 = src;
    var IsArray2 = IsArray$1;
    var IsPropertyKey2 = requireIsPropertyKey();
    var IsRegExp2 = requireIsRegExp();
    var ToPropertyDescriptor2 = requireToPropertyDescriptor();
    var Type2 = Type$4;
    OrdinaryGetOwnProperty = function OrdinaryGetOwnProperty2(O2, P2) {
      if (Type2(O2) !== "Object") {
        throw new $TypeError2("Assertion failed: O must be an Object");
      }
      if (!IsPropertyKey2(P2)) {
        throw new $TypeError2("Assertion failed: P must be a Property Key");
      }
      if (!has2(O2, P2)) {
        return void 0;
      }
      if (!$gOPD2) {
        var arrayLength = IsArray2(O2) && P2 === "length";
        var regexLastIndex = IsRegExp2(O2) && P2 === "lastIndex";
        return {
          "[[Configurable]]": !(arrayLength || regexLastIndex),
          "[[Enumerable]]": $isEnumerable(O2, P2),
          "[[Value]]": O2[P2],
          "[[Writable]]": true
        };
      }
      return ToPropertyDescriptor2($gOPD2(O2, P2));
    };
    return OrdinaryGetOwnProperty;
  }
  var IsDataDescriptor;
  var hasRequiredIsDataDescriptor;
  function requireIsDataDescriptor() {
    if (hasRequiredIsDataDescriptor)
      return IsDataDescriptor;
    hasRequiredIsDataDescriptor = 1;
    var has2 = src;
    var assertRecord2 = requireAssertRecord();
    var Type2 = Type$4;
    IsDataDescriptor = function IsDataDescriptor2(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord2(Type2, "Property Descriptor", "Desc", Desc);
      if (!has2(Desc, "[[Value]]") && !has2(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
    return IsDataDescriptor;
  }
  var isPrimitive$1;
  var hasRequiredIsPrimitive$1;
  function requireIsPrimitive$1() {
    if (hasRequiredIsPrimitive$1)
      return isPrimitive$1;
    hasRequiredIsPrimitive$1 = 1;
    isPrimitive$1 = function isPrimitive2(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
    return isPrimitive$1;
  }
  var IsExtensible;
  var hasRequiredIsExtensible;
  function requireIsExtensible() {
    if (hasRequiredIsExtensible)
      return IsExtensible;
    hasRequiredIsExtensible = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $Object2 = GetIntrinsic2("%Object%");
    var isPrimitive2 = requireIsPrimitive$1();
    var $preventExtensions = $Object2.preventExtensions;
    var $isExtensible = $Object2.isExtensible;
    IsExtensible = $preventExtensions ? function IsExtensible2(obj) {
      return !isPrimitive2(obj) && $isExtensible(obj);
    } : function IsExtensible2(obj) {
      return !isPrimitive2(obj);
    };
    return IsExtensible;
  }
  var SameValue;
  var hasRequiredSameValue;
  function requireSameValue() {
    if (hasRequiredSameValue)
      return SameValue;
    hasRequiredSameValue = 1;
    var $isNaN = require_isNaN();
    SameValue = function SameValue2(x2, y2) {
      if (x2 === y2) {
        if (x2 === 0) {
          return 1 / x2 === 1 / y2;
        }
        return true;
      }
      return $isNaN(x2) && $isNaN(y2);
    };
    return SameValue;
  }
  var CreateDataProperty$1;
  var hasRequiredCreateDataProperty;
  function requireCreateDataProperty() {
    if (hasRequiredCreateDataProperty)
      return CreateDataProperty$1;
    hasRequiredCreateDataProperty = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    var DefineOwnProperty2 = requireDefineOwnProperty();
    var FromPropertyDescriptor2 = requireFromPropertyDescriptor();
    var OrdinaryGetOwnProperty2 = requireOrdinaryGetOwnProperty();
    var IsDataDescriptor2 = requireIsDataDescriptor();
    var IsExtensible2 = requireIsExtensible();
    var IsPropertyKey2 = requireIsPropertyKey();
    var SameValue2 = requireSameValue();
    var Type2 = Type$4;
    CreateDataProperty$1 = function CreateDataProperty2(O2, P2, V2) {
      if (Type2(O2) !== "Object") {
        throw new $TypeError2("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey2(P2)) {
        throw new $TypeError2("Assertion failed: IsPropertyKey(P) is not true");
      }
      var oldDesc = OrdinaryGetOwnProperty2(O2, P2);
      var extensible = !oldDesc || IsExtensible2(O2);
      var immutable = oldDesc && (!oldDesc["[[Writable]]"] || !oldDesc["[[Configurable]]"]);
      if (immutable || !extensible) {
        return false;
      }
      return DefineOwnProperty2(
        IsDataDescriptor2,
        SameValue2,
        FromPropertyDescriptor2,
        O2,
        P2,
        {
          "[[Configurable]]": true,
          "[[Enumerable]]": true,
          "[[Value]]": V2,
          "[[Writable]]": true
        }
      );
    };
    return CreateDataProperty$1;
  }
  var GetIntrinsic$1 = GetIntrinsic$d;
  var $TypeError = GetIntrinsic$1("%TypeError%");
  var CreateDataProperty = requireCreateDataProperty();
  var IsPropertyKey = requireIsPropertyKey();
  var Type$1 = Type$4;
  var CreateDataPropertyOrThrow$1 = function CreateDataPropertyOrThrow2(O2, P2, V2) {
    if (Type$1(O2) !== "Object") {
      throw new $TypeError("Assertion failed: Type(O) is not Object");
    }
    if (!IsPropertyKey(P2)) {
      throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
    }
    var success = CreateDataProperty(O2, P2, V2);
    if (!success) {
      throw new $TypeError("unable to create data property");
    }
    return success;
  };
  var isPrimitive;
  var hasRequiredIsPrimitive;
  function requireIsPrimitive() {
    if (hasRequiredIsPrimitive)
      return isPrimitive;
    hasRequiredIsPrimitive = 1;
    isPrimitive = function isPrimitive2(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
    return isPrimitive;
  }
  var es2015;
  var hasRequiredEs2015;
  function requireEs2015() {
    if (hasRequiredEs2015)
      return es2015;
    hasRequiredEs2015 = 1;
    var hasSymbols2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol";
    var isPrimitive2 = requireIsPrimitive();
    var isCallable2 = requireIsCallable$1();
    var isDate2 = isDateObject;
    var isSymbol2 = isSymbolExports;
    var ordinaryToPrimitive = function OrdinaryToPrimitive(O2, hint) {
      if (typeof O2 === "undefined" || O2 === null) {
        throw new TypeError("Cannot call method on " + O2);
      }
      if (typeof hint !== "string" || hint !== "number" && hint !== "string") {
        throw new TypeError('hint must be "string" or "number"');
      }
      var methodNames = hint === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
      var method, result2, i2;
      for (i2 = 0; i2 < methodNames.length; ++i2) {
        method = O2[methodNames[i2]];
        if (isCallable2(method)) {
          result2 = method.call(O2);
          if (isPrimitive2(result2)) {
            return result2;
          }
        }
      }
      throw new TypeError("No default value");
    };
    var GetMethod2 = function GetMethod3(O2, P2) {
      var func = O2[P2];
      if (func !== null && typeof func !== "undefined") {
        if (!isCallable2(func)) {
          throw new TypeError(func + " returned for property " + P2 + " of object " + O2 + " is not a function");
        }
        return func;
      }
      return void 0;
    };
    es2015 = function ToPrimitive2(input) {
      if (isPrimitive2(input)) {
        return input;
      }
      var hint = "default";
      if (arguments.length > 1) {
        if (arguments[1] === String) {
          hint = "string";
        } else if (arguments[1] === Number) {
          hint = "number";
        }
      }
      var exoticToPrim;
      if (hasSymbols2) {
        if (Symbol.toPrimitive) {
          exoticToPrim = GetMethod2(input, Symbol.toPrimitive);
        } else if (isSymbol2(input)) {
          exoticToPrim = Symbol.prototype.valueOf;
        }
      }
      if (typeof exoticToPrim !== "undefined") {
        var result2 = exoticToPrim.call(input, hint);
        if (isPrimitive2(result2)) {
          return result2;
        }
        throw new TypeError("unable to convert exotic object to primitive");
      }
      if (hint === "default" && (isDate2(input) || isSymbol2(input))) {
        hint = "string";
      }
      return ordinaryToPrimitive(input, hint === "default" ? "number" : hint);
    };
    return es2015;
  }
  var ToPrimitive$1;
  var hasRequiredToPrimitive;
  function requireToPrimitive() {
    if (hasRequiredToPrimitive)
      return ToPrimitive$1;
    hasRequiredToPrimitive = 1;
    var toPrimitive = requireEs2015();
    ToPrimitive$1 = function ToPrimitive2(input) {
      if (arguments.length > 1) {
        return toPrimitive(input, arguments[1]);
      }
      return toPrimitive(input);
    };
    return ToPrimitive$1;
  }
  var ToString$1;
  var hasRequiredToString;
  function requireToString() {
    if (hasRequiredToString)
      return ToString$1;
    hasRequiredToString = 1;
    var GetIntrinsic2 = GetIntrinsic$d;
    var $String2 = GetIntrinsic2("%String%");
    var $TypeError2 = GetIntrinsic2("%TypeError%");
    ToString$1 = function ToString2(argument) {
      if (typeof argument === "symbol") {
        throw new $TypeError2("Cannot convert a Symbol value to a string");
      }
      return $String2(argument);
    };
    return ToString$1;
  }
  var GetIntrinsic = GetIntrinsic$d;
  var $String = GetIntrinsic("%String%");
  var ToPrimitive = requireToPrimitive();
  var ToString = requireToString();
  var ToPropertyKey$1 = function ToPropertyKey2(argument) {
    var key = ToPrimitive(argument, $String);
    return typeof key === "symbol" ? key : ToString(key);
  };
  var AddEntriesFromIterable = AddEntriesFromIterable$1;
  var CreateDataPropertyOrThrow = CreateDataPropertyOrThrow$1;
  var Get = Get$2;
  var IsArray = IsArray$1;
  var RequireObjectCoercible = RequireObjectCoercible$1;
  var ToPropertyKey = ToPropertyKey$1;
  var Type = Type$4;
  var adder = function addDataProperty(key, value) {
    var O2 = this;
    var propertyKey = ToPropertyKey(key);
    CreateDataPropertyOrThrow(O2, propertyKey, value);
  };
  var legacyAssign = function assign2(obj, entries) {
    for (var i2 = 0; i2 < entries.length; ++i2) {
      var entry = entries[i2];
      if (Type(entry) !== "Object") {
        throw new TypeError("iterator returned a non-object; entry expected");
      }
      var key = Get(entry, "0");
      var value = Get(entry, "1");
      var propertyKey = ToPropertyKey(key);
      CreateDataPropertyOrThrow(obj, propertyKey, value);
    }
  };
  var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var implementation$2 = function fromEntries(iterable) {
    RequireObjectCoercible(iterable);
    var obj = {};
    if (!hasSymbols) {
      if (!IsArray(iterable)) {
        throw new TypeError("this environment lacks native Symbols, and can not support non-Array iterables");
      }
      legacyAssign(obj, iterable);
      return obj;
    }
    return AddEntriesFromIterable(obj, iterable, adder);
  };
  var implementation$1 = implementation$2;
  var polyfill$1 = function getPolyfill2() {
    return typeof Object.fromEntries === "function" ? Object.fromEntries : implementation$1;
  };
  var getPolyfill$1 = polyfill$1;
  var define$1 = defineProperties_1;
  var shim$1 = function shimEntries() {
    var polyfill2 = getPolyfill$1();
    define$1(Object, { fromEntries: polyfill2 }, {
      fromEntries: function testEntries() {
        return Object.fromEntries !== polyfill2;
      }
    });
    return polyfill2;
  };
  var define = defineProperties_1;
  var bind = functionBind;
  var implementation = implementation$2;
  var getPolyfill = polyfill$1;
  var shim = shim$1;
  var polyfill = bind.call(getPolyfill());
  define(polyfill, {
    getPolyfill,
    implementation,
    shim
  });
  var object_fromentries = polyfill;
  const Bo = /* @__PURE__ */ getDefaultExportFromCjs(object_fromentries);
  const t$1 = "_defaultStyle_14p2i_104", n$3 = "_highlightStyle_14p2i_105", i$1 = "_darkMode_14p2i_108", o = "_lightMode_14p2i_115", l$1 = "_Link_14p2i_158", _ = "_noAnimation_14p2i_190", e$2 = "_UnstyledButton_14p2i_205", d$1 = {
    defaultStyle: t$1,
    highlightStyle: n$3,
    darkMode: i$1,
    lightMode: o,
    Link: l$1,
    noAnimation: _,
    UnstyledButton: e$2
  };
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /** @license React v17.0.1
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var f$2 = reactExports, g$1 = 60103;
  reactJsxRuntime_production_min.Fragment = 60107;
  if ("function" === typeof Symbol && Symbol.for) {
    var h$1 = Symbol.for;
    g$1 = h$1("react.element");
    reactJsxRuntime_production_min.Fragment = h$1("react.fragment");
  }
  var m$2 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n$2 = Object.prototype.hasOwnProperty, p$1 = { key: true, ref: true, __self: true, __source: true };
  function q$1(c2, a, k2) {
    var b2, d2 = {}, e2 = null, l2 = null;
    void 0 !== k2 && (e2 = "" + k2);
    void 0 !== a.key && (e2 = "" + a.key);
    void 0 !== a.ref && (l2 = a.ref);
    for (b2 in a)
      n$2.call(a, b2) && !p$1.hasOwnProperty(b2) && (d2[b2] = a[b2]);
    if (c2 && c2.defaultProps)
      for (b2 in a = c2.defaultProps, a)
        void 0 === d2[b2] && (d2[b2] = a[b2]);
    return { $$typeof: g$1, type: c2, key: e2, ref: l2, props: d2, _owner: m$2.current };
  }
  reactJsxRuntime_production_min.jsx = q$1;
  reactJsxRuntime_production_min.jsxs = q$1;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  const Fragment = jsxRuntimeExports.Fragment;
  const jsx = jsxRuntimeExports.jsx;
  const jsxs = jsxRuntimeExports.jsxs;
  var classnames = { exports: {} };
  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  (function(module2) {
    (function() {
      var hasOwn2 = {}.hasOwnProperty;
      function classNames2() {
        var classes = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg) && arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          } else if (argType === "object") {
            for (var key in arg) {
              if (hasOwn2.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (module2.exports) {
        classNames2.default = classNames2;
        module2.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames);
  var classnamesExports = classnames.exports;
  const f$1 = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
  var lib$1 = {};
  var useMedia = {};
  var utilities = {};
  var camelToHyphen$1 = {};
  Object.defineProperty(camelToHyphen$1, "__esModule", { value: true });
  function camelToHyphen(camelString) {
    return camelString.replace(/[A-Z]/g, function(string) {
      return "-" + string.toLowerCase();
    }).toLowerCase();
  }
  camelToHyphen$1.default = camelToHyphen;
  var queryObjectToString$1 = {};
  Object.defineProperty(queryObjectToString$1, "__esModule", { value: true });
  var camelToHyphen_1$1 = camelToHyphen$1;
  var QUERY_COMBINATOR = " and ";
  function queryObjectToString(query) {
    if (typeof query === "string") {
      return query;
    }
    return Object.entries(query).map(function(_a3) {
      var feature = _a3[0], value = _a3[1];
      var convertedFeature = camelToHyphen_1$1.default(feature);
      var convertedValue = value;
      if (typeof convertedValue === "boolean") {
        return convertedValue ? convertedFeature : "not " + convertedFeature;
      }
      if (typeof convertedValue === "number" && /[height|width]$/.test(convertedFeature)) {
        convertedValue = convertedValue + "px";
      }
      return "(" + convertedFeature + ": " + convertedValue + ")";
    }).join(QUERY_COMBINATOR);
  }
  queryObjectToString$1.default = queryObjectToString;
  var noop$4 = {};
  Object.defineProperty(noop$4, "__esModule", { value: true });
  function noop$3() {
  }
  noop$4.default = noop$3;
  Object.defineProperty(utilities, "__esModule", { value: true });
  var camelToHyphen_1 = camelToHyphen$1;
  utilities.camelToHyphen = camelToHyphen_1.default;
  var queryObjectToString_1 = queryObjectToString$1;
  utilities.queryObjectToString = queryObjectToString_1.default;
  var noop_1 = noop$4;
  utilities.noop = noop_1.default;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var react_1 = reactExports;
    var utilities_1 = utilities;
    exports2.mockMediaQueryList = {
      media: "",
      matches: false,
      onchange: utilities_1.noop,
      addListener: utilities_1.noop,
      removeListener: utilities_1.noop,
      addEventListener: utilities_1.noop,
      removeEventListener: utilities_1.noop,
      dispatchEvent: function(_2) {
        return true;
      }
    };
    var createUseMedia = function(effect) {
      return function(rawQuery, defaultState) {
        if (defaultState === void 0) {
          defaultState = false;
        }
        var _a3 = react_1.useState(defaultState), state = _a3[0], setState = _a3[1];
        var query = utilities_1.queryObjectToString(rawQuery);
        effect(function() {
          var mounted = true;
          var mediaQueryList = typeof window === "undefined" ? exports2.mockMediaQueryList : window.matchMedia(query);
          var onChange = function() {
            if (!mounted) {
              return;
            }
            setState(Boolean(mediaQueryList.matches));
          };
          mediaQueryList.addListener(onChange);
          setState(mediaQueryList.matches);
          return function() {
            mounted = false;
            mediaQueryList.removeListener(onChange);
          };
        }, [query]);
        return state;
      };
    };
    exports2.useMedia = createUseMedia(react_1.useEffect);
    exports2.useMediaLayout = createUseMedia(react_1.useLayoutEffect);
    exports2.default = exports2.useMedia;
  })(useMedia);
  Object.defineProperty(lib$1, "__esModule", { value: true });
  var useMedia_1 = useMedia;
  lib$1.default = useMedia_1.default;
  lib$1.useMedia = useMedia_1.useMedia;
  lib$1.useMediaLayout = useMedia_1.useMediaLayout;
  var mousetrap = { exports: {} };
  (function(module2) {
    (function(window2, document2, undefined$12) {
      if (!window2) {
        return;
      }
      var _MAP = {
        8: "backspace",
        9: "tab",
        13: "enter",
        16: "shift",
        17: "ctrl",
        18: "alt",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "ins",
        46: "del",
        91: "meta",
        93: "meta",
        224: "meta"
      };
      var _KEYCODE_MAP = {
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      };
      var _SHIFT_MAP = {
        "~": "`",
        "!": "1",
        "@": "2",
        "#": "3",
        "$": "4",
        "%": "5",
        "^": "6",
        "&": "7",
        "*": "8",
        "(": "9",
        ")": "0",
        "_": "-",
        "+": "=",
        ":": ";",
        '"': "'",
        "<": ",",
        ">": ".",
        "?": "/",
        "|": "\\"
      };
      var _SPECIAL_ALIASES = {
        "option": "alt",
        "command": "meta",
        "return": "enter",
        "escape": "esc",
        "plus": "+",
        "mod": /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
      };
      var _REVERSE_MAP;
      for (var i2 = 1; i2 < 20; ++i2) {
        _MAP[111 + i2] = "f" + i2;
      }
      for (i2 = 0; i2 <= 9; ++i2) {
        _MAP[i2 + 96] = i2.toString();
      }
      function _addEvent(object, type, callback) {
        if (object.addEventListener) {
          object.addEventListener(type, callback, false);
          return;
        }
        object.attachEvent("on" + type, callback);
      }
      function _characterFromEvent(e2) {
        if (e2.type == "keypress") {
          var character = String.fromCharCode(e2.which);
          if (!e2.shiftKey) {
            character = character.toLowerCase();
          }
          return character;
        }
        if (_MAP[e2.which]) {
          return _MAP[e2.which];
        }
        if (_KEYCODE_MAP[e2.which]) {
          return _KEYCODE_MAP[e2.which];
        }
        return String.fromCharCode(e2.which).toLowerCase();
      }
      function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(",") === modifiers2.sort().join(",");
      }
      function _eventModifiers(e2) {
        var modifiers = [];
        if (e2.shiftKey) {
          modifiers.push("shift");
        }
        if (e2.altKey) {
          modifiers.push("alt");
        }
        if (e2.ctrlKey) {
          modifiers.push("ctrl");
        }
        if (e2.metaKey) {
          modifiers.push("meta");
        }
        return modifiers;
      }
      function _preventDefault(e2) {
        if (e2.preventDefault) {
          e2.preventDefault();
          return;
        }
        e2.returnValue = false;
      }
      function _stopPropagation(e2) {
        if (e2.stopPropagation) {
          e2.stopPropagation();
          return;
        }
        e2.cancelBubble = true;
      }
      function _isModifier(key) {
        return key == "shift" || key == "ctrl" || key == "alt" || key == "meta";
      }
      function _getReverseMap() {
        if (!_REVERSE_MAP) {
          _REVERSE_MAP = {};
          for (var key in _MAP) {
            if (key > 95 && key < 112) {
              continue;
            }
            if (_MAP.hasOwnProperty(key)) {
              _REVERSE_MAP[_MAP[key]] = key;
            }
          }
        }
        return _REVERSE_MAP;
      }
      function _pickBestAction(key, modifiers, action) {
        if (!action) {
          action = _getReverseMap()[key] ? "keydown" : "keypress";
        }
        if (action == "keypress" && modifiers.length) {
          action = "keydown";
        }
        return action;
      }
      function _keysFromString(combination) {
        if (combination === "+") {
          return ["+"];
        }
        combination = combination.replace(/\+{2}/g, "+plus");
        return combination.split("+");
      }
      function _getKeyInfo(combination, action) {
        var keys2;
        var key;
        var i3;
        var modifiers = [];
        keys2 = _keysFromString(combination);
        for (i3 = 0; i3 < keys2.length; ++i3) {
          key = keys2[i3];
          if (_SPECIAL_ALIASES[key]) {
            key = _SPECIAL_ALIASES[key];
          }
          if (action && action != "keypress" && _SHIFT_MAP[key]) {
            key = _SHIFT_MAP[key];
            modifiers.push("shift");
          }
          if (_isModifier(key)) {
            modifiers.push(key);
          }
        }
        action = _pickBestAction(key, modifiers, action);
        return {
          key,
          modifiers,
          action
        };
      }
      function _belongsTo(element, ancestor) {
        if (element === null || element === document2) {
          return false;
        }
        if (element === ancestor) {
          return true;
        }
        return _belongsTo(element.parentNode, ancestor);
      }
      function Mousetrap(targetElement) {
        var self2 = this;
        targetElement = targetElement || document2;
        if (!(self2 instanceof Mousetrap)) {
          return new Mousetrap(targetElement);
        }
        self2.target = targetElement;
        self2._callbacks = {};
        self2._directMap = {};
        var _sequenceLevels = {};
        var _resetTimer;
        var _ignoreNextKeyup = false;
        var _ignoreNextKeypress = false;
        var _nextExpectedAction = false;
        function _resetSequences(doNotReset) {
          doNotReset = doNotReset || {};
          var activeSequences = false, key;
          for (key in _sequenceLevels) {
            if (doNotReset[key]) {
              activeSequences = true;
              continue;
            }
            _sequenceLevels[key] = 0;
          }
          if (!activeSequences) {
            _nextExpectedAction = false;
          }
        }
        function _getMatches(character, modifiers, e2, sequenceName, combination, level) {
          var i3;
          var callback;
          var matches2 = [];
          var action = e2.type;
          if (!self2._callbacks[character]) {
            return [];
          }
          if (action == "keyup" && _isModifier(character)) {
            modifiers = [character];
          }
          for (i3 = 0; i3 < self2._callbacks[character].length; ++i3) {
            callback = self2._callbacks[character][i3];
            if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
              continue;
            }
            if (action != callback.action) {
              continue;
            }
            if (action == "keypress" && !e2.metaKey && !e2.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
              var deleteCombo = !sequenceName && callback.combo == combination;
              var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
              if (deleteCombo || deleteSequence) {
                self2._callbacks[character].splice(i3, 1);
              }
              matches2.push(callback);
            }
          }
          return matches2;
        }
        function _fireCallback(callback, e2, combo, sequence) {
          if (self2.stopCallback(e2, e2.target || e2.srcElement, combo, sequence)) {
            return;
          }
          if (callback(e2, combo) === false) {
            _preventDefault(e2);
            _stopPropagation(e2);
          }
        }
        self2._handleKey = function(character, modifiers, e2) {
          var callbacks = _getMatches(character, modifiers, e2);
          var i3;
          var doNotReset = {};
          var maxLevel = 0;
          var processedSequenceCallback = false;
          for (i3 = 0; i3 < callbacks.length; ++i3) {
            if (callbacks[i3].seq) {
              maxLevel = Math.max(maxLevel, callbacks[i3].level);
            }
          }
          for (i3 = 0; i3 < callbacks.length; ++i3) {
            if (callbacks[i3].seq) {
              if (callbacks[i3].level != maxLevel) {
                continue;
              }
              processedSequenceCallback = true;
              doNotReset[callbacks[i3].seq] = 1;
              _fireCallback(callbacks[i3].callback, e2, callbacks[i3].combo, callbacks[i3].seq);
              continue;
            }
            if (!processedSequenceCallback) {
              _fireCallback(callbacks[i3].callback, e2, callbacks[i3].combo);
            }
          }
          var ignoreThisKeypress = e2.type == "keypress" && _ignoreNextKeypress;
          if (e2.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
            _resetSequences(doNotReset);
          }
          _ignoreNextKeypress = processedSequenceCallback && e2.type == "keydown";
        };
        function _handleKeyEvent(e2) {
          if (typeof e2.which !== "number") {
            e2.which = e2.keyCode;
          }
          var character = _characterFromEvent(e2);
          if (!character) {
            return;
          }
          if (e2.type == "keyup" && _ignoreNextKeyup === character) {
            _ignoreNextKeyup = false;
            return;
          }
          self2.handleKey(character, _eventModifiers(e2), e2);
        }
        function _resetSequenceTimer() {
          clearTimeout(_resetTimer);
          _resetTimer = setTimeout(_resetSequences, 1e3);
        }
        function _bindSequence(combo, keys2, callback, action) {
          _sequenceLevels[combo] = 0;
          function _increaseSequence(nextAction) {
            return function() {
              _nextExpectedAction = nextAction;
              ++_sequenceLevels[combo];
              _resetSequenceTimer();
            };
          }
          function _callbackAndReset(e2) {
            _fireCallback(callback, e2, combo);
            if (action !== "keyup") {
              _ignoreNextKeyup = _characterFromEvent(e2);
            }
            setTimeout(_resetSequences, 10);
          }
          for (var i3 = 0; i3 < keys2.length; ++i3) {
            var isFinal = i3 + 1 === keys2.length;
            var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys2[i3 + 1]).action);
            _bindSingle(keys2[i3], wrappedCallback, action, combo, i3);
          }
        }
        function _bindSingle(combination, callback, action, sequenceName, level) {
          self2._directMap[combination + ":" + action] = callback;
          combination = combination.replace(/\s+/g, " ");
          var sequence = combination.split(" ");
          var info;
          if (sequence.length > 1) {
            _bindSequence(combination, sequence, callback, action);
            return;
          }
          info = _getKeyInfo(combination, action);
          self2._callbacks[info.key] = self2._callbacks[info.key] || [];
          _getMatches(info.key, info.modifiers, { type: info.action }, sequenceName, combination, level);
          self2._callbacks[info.key][sequenceName ? "unshift" : "push"]({
            callback,
            modifiers: info.modifiers,
            action: info.action,
            seq: sequenceName,
            level,
            combo: combination
          });
        }
        self2._bindMultiple = function(combinations2, callback, action) {
          for (var i3 = 0; i3 < combinations2.length; ++i3) {
            _bindSingle(combinations2[i3], callback, action);
          }
        };
        _addEvent(targetElement, "keypress", _handleKeyEvent);
        _addEvent(targetElement, "keydown", _handleKeyEvent);
        _addEvent(targetElement, "keyup", _handleKeyEvent);
      }
      Mousetrap.prototype.bind = function(keys2, callback, action) {
        var self2 = this;
        keys2 = keys2 instanceof Array ? keys2 : [keys2];
        self2._bindMultiple.call(self2, keys2, callback, action);
        return self2;
      };
      Mousetrap.prototype.unbind = function(keys2, action) {
        var self2 = this;
        return self2.bind.call(self2, keys2, function() {
        }, action);
      };
      Mousetrap.prototype.trigger = function(keys2, action) {
        var self2 = this;
        if (self2._directMap[keys2 + ":" + action]) {
          self2._directMap[keys2 + ":" + action]({}, keys2);
        }
        return self2;
      };
      Mousetrap.prototype.reset = function() {
        var self2 = this;
        self2._callbacks = {};
        self2._directMap = {};
        return self2;
      };
      Mousetrap.prototype.stopCallback = function(e2, element) {
        var self2 = this;
        if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
          return false;
        }
        if (_belongsTo(element, self2.target)) {
          return false;
        }
        if ("composedPath" in e2 && typeof e2.composedPath === "function") {
          var initialEventTarget = e2.composedPath()[0];
          if (initialEventTarget !== e2.target) {
            element = initialEventTarget;
          }
        }
        return element.tagName == "INPUT" || element.tagName == "SELECT" || element.tagName == "TEXTAREA" || element.isContentEditable;
      };
      Mousetrap.prototype.handleKey = function() {
        var self2 = this;
        return self2._handleKey.apply(self2, arguments);
      };
      Mousetrap.addKeycodes = function(object) {
        for (var key in object) {
          if (object.hasOwnProperty(key)) {
            _MAP[key] = object[key];
          }
        }
        _REVERSE_MAP = null;
      };
      Mousetrap.init = function() {
        var documentMousetrap = Mousetrap(document2);
        for (var method in documentMousetrap) {
          if (method.charAt(0) !== "_") {
            Mousetrap[method] = function(method2) {
              return function() {
                return documentMousetrap[method2].apply(documentMousetrap, arguments);
              };
            }(method);
          }
        }
      };
      Mousetrap.init();
      window2.Mousetrap = Mousetrap;
      if (module2.exports) {
        module2.exports = Mousetrap;
      }
      if (typeof undefined$12 === "function" && undefined$12.amd) {
        undefined$12(function() {
          return Mousetrap;
        });
      }
    })(typeof window !== "undefined" ? window : null, typeof window !== "undefined" ? document : null);
  })(mousetrap);
  var isProduction = true;
  function warning(condition, message) {
    if (!isProduction) {
      if (condition) {
        return;
      }
      var text = "Warning: " + message;
      if (typeof console !== "undefined") {
        console.warn(text);
      }
      try {
        throw Error(text);
      } catch (x2) {
      }
    }
  }
  const SvgE05728E87Cd1Ca23 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 2", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M1.488.012A1.503 1.503 0 0 0 .42 2.56l7.353 7.353A32.31 32.31 0 0 0 .17 19.301a1.53 1.53 0 0 0 0 1.379C.46 21.27 7.45 35 20 35a18.35 18.35 0 0 0 9.836-3.023l7.584 7.584a1.47 1.47 0 0 0 1.06.439 1.45 1.45 0 0 0 1.1-.41 1.49 1.49 0 0 0 0-2.12l-37-37A1.503 1.503 0 0 0 1.488.013zM19.855 5.07a16.18 16.18 0 0 0-3.685.44 1.5 1.5 0 1 0 .68 2.92A13.9 13.9 0 0 1 20 8.07c9.23 0 15.26 9.33 16.77 11.93a29.8 29.8 0 0 1-3.11 4.45 1.49 1.49 0 0 0 .18 2.11 1.48 1.48 0 0 0 1 .36l.02-.04a1.5 1.5 0 0 0 1.14-.54 31.88 31.88 0 0 0 3.82-5.62 1.5 1.5 0 0 0 0-1.38C39.53 18.76 32.55 5.07 20 5.07a16.18 16.18 0 0 0-.145 0zM9.9 12.041l4.495 4.494A6.55 6.55 0 0 0 19.84 26.76l.28-.09a6.47 6.47 0 0 0 3.325-1.084L27.66 29.8A15.32 15.32 0 0 1 20 32c-9.23 0-15.26-9.37-16.77-12a29.25 29.25 0 0 1 6.67-7.959zm6.688 6.688 4.674 4.673a3.56 3.56 0 0 1-1.282.309 3.62 3.62 0 0 1-2.55-.922 3.55 3.55 0 0 1-.842-4.06z" }));
  const Svg5D0Be631Bf7D3947 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 1", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M20 5C7.45 5 .46 18.72.17 19.31a1.5 1.5 0 0 0 0 1.34c.29.58 7.28 14.28 19.83 14.28 12.55 0 19.54-13.7 19.83-14.3a1.44 1.44 0 0 0 0-1.34C39.54 18.7 32.55 5 20 5zm0 3c9.24 0 15.28 9.37 16.78 12-1.5 2.59-7.55 12-16.78 12S4.73 22.61 3.22 20C4.73 17.36 10.76 8 20 8zm0 5.43a6.54 6.54 0 0 0 0 13.08A6.54 6.54 0 0 0 26.54 20 6.52 6.52 0 0 0 20 13.43zm0 3a3.52 3.52 0 0 1 2.54 1.07 3.48 3.48 0 0 1 1 2.5A3.54 3.54 0 1 1 20 16.43z" }));
  var reactDom = { exports: {} };
  var reactDom_production_min = {};
  var scheduler = { exports: {} };
  var scheduler_production_min = {};
  /** @license React v0.20.1
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function(exports2) {
    var f2, g2, h2, k2;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports2.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q2 = p2.now();
      exports2.unstable_now = function() {
        return p2.now() - q2;
      };
    }
    if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
      var t2 = null, u2 = null, w2 = function() {
        if (null !== t2)
          try {
            var a = exports2.unstable_now();
            t2(true, a);
            t2 = null;
          } catch (b2) {
            throw setTimeout(w2, 0), b2;
          }
      };
      f2 = function(a) {
        null !== t2 ? setTimeout(f2, 0, a) : (t2 = a, setTimeout(w2, 0));
      };
      g2 = function(a, b2) {
        u2 = setTimeout(a, b2);
      };
      h2 = function() {
        clearTimeout(u2);
      };
      exports2.unstable_shouldYield = function() {
        return false;
      };
      k2 = exports2.unstable_forceFrameRate = function() {
      };
    } else {
      var x2 = window.setTimeout, y2 = window.clearTimeout;
      if ("undefined" !== typeof console) {
        var z2 = window.cancelAnimationFrame;
        "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        "function" !== typeof z2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      }
      var A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
      exports2.unstable_shouldYield = function() {
        return exports2.unstable_now() >= E2;
      };
      k2 = function() {
      };
      exports2.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      var F2 = new MessageChannel(), G2 = F2.port2;
      F2.port1.onmessage = function() {
        if (null !== B2) {
          var a = exports2.unstable_now();
          E2 = a + D2;
          try {
            B2(true, a) ? G2.postMessage(null) : (A2 = false, B2 = null);
          } catch (b2) {
            throw G2.postMessage(null), b2;
          }
        } else
          A2 = false;
      };
      f2 = function(a) {
        B2 = a;
        A2 || (A2 = true, G2.postMessage(null));
      };
      g2 = function(a, b2) {
        C2 = x2(function() {
          a(exports2.unstable_now());
        }, b2);
      };
      h2 = function() {
        y2(C2);
        C2 = -1;
      };
    }
    function H2(a, b2) {
      var c2 = a.length;
      a.push(b2);
      a:
        for (; ; ) {
          var d2 = c2 - 1 >>> 1, e2 = a[d2];
          if (void 0 !== e2 && 0 < I2(e2, b2))
            a[d2] = b2, a[c2] = e2, c2 = d2;
          else
            break a;
        }
    }
    function J2(a) {
      a = a[0];
      return void 0 === a ? null : a;
    }
    function K2(a) {
      var b2 = a[0];
      if (void 0 !== b2) {
        var c2 = a.pop();
        if (c2 !== b2) {
          a[0] = c2;
          a:
            for (var d2 = 0, e2 = a.length; d2 < e2; ) {
              var m2 = 2 * (d2 + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];
              if (void 0 !== n2 && 0 > I2(n2, c2))
                void 0 !== r2 && 0 > I2(r2, n2) ? (a[d2] = r2, a[v2] = c2, d2 = v2) : (a[d2] = n2, a[m2] = c2, d2 = m2);
              else if (void 0 !== r2 && 0 > I2(r2, c2))
                a[d2] = r2, a[v2] = c2, d2 = v2;
              else
                break a;
            }
        }
        return b2;
      }
      return null;
    }
    function I2(a, b2) {
      var c2 = a.sortIndex - b2.sortIndex;
      return 0 !== c2 ? c2 : a.id - b2.id;
    }
    var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
    function T2(a) {
      for (var b2 = J2(M2); null !== b2; ) {
        if (null === b2.callback)
          K2(M2);
        else if (b2.startTime <= a)
          K2(M2), b2.sortIndex = b2.expirationTime, H2(L2, b2);
        else
          break;
        b2 = J2(M2);
      }
    }
    function U2(a) {
      S2 = false;
      T2(a);
      if (!R2)
        if (null !== J2(L2))
          R2 = true, f2(V2);
        else {
          var b2 = J2(M2);
          null !== b2 && g2(U2, b2.startTime - a);
        }
    }
    function V2(a, b2) {
      R2 = false;
      S2 && (S2 = false, h2());
      Q2 = true;
      var c2 = P2;
      try {
        T2(b2);
        for (O2 = J2(L2); null !== O2 && (!(O2.expirationTime > b2) || a && !exports2.unstable_shouldYield()); ) {
          var d2 = O2.callback;
          if ("function" === typeof d2) {
            O2.callback = null;
            P2 = O2.priorityLevel;
            var e2 = d2(O2.expirationTime <= b2);
            b2 = exports2.unstable_now();
            "function" === typeof e2 ? O2.callback = e2 : O2 === J2(L2) && K2(L2);
            T2(b2);
          } else
            K2(L2);
          O2 = J2(L2);
        }
        if (null !== O2)
          var m2 = true;
        else {
          var n2 = J2(M2);
          null !== n2 && g2(U2, n2.startTime - b2);
          m2 = false;
        }
        return m2;
      } finally {
        O2 = null, P2 = c2, Q2 = false;
      }
    }
    var W2 = k2;
    exports2.unstable_IdlePriority = 5;
    exports2.unstable_ImmediatePriority = 1;
    exports2.unstable_LowPriority = 4;
    exports2.unstable_NormalPriority = 3;
    exports2.unstable_Profiling = null;
    exports2.unstable_UserBlockingPriority = 2;
    exports2.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports2.unstable_continueExecution = function() {
      R2 || Q2 || (R2 = true, f2(V2));
    };
    exports2.unstable_getCurrentPriorityLevel = function() {
      return P2;
    };
    exports2.unstable_getFirstCallbackNode = function() {
      return J2(L2);
    };
    exports2.unstable_next = function(a) {
      switch (P2) {
        case 1:
        case 2:
        case 3:
          var b2 = 3;
          break;
        default:
          b2 = P2;
      }
      var c2 = P2;
      P2 = b2;
      try {
        return a();
      } finally {
        P2 = c2;
      }
    };
    exports2.unstable_pauseExecution = function() {
    };
    exports2.unstable_requestPaint = W2;
    exports2.unstable_runWithPriority = function(a, b2) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c2 = P2;
      P2 = a;
      try {
        return b2();
      } finally {
        P2 = c2;
      }
    };
    exports2.unstable_scheduleCallback = function(a, b2, c2) {
      var d2 = exports2.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
      switch (a) {
        case 1:
          var e2 = -1;
          break;
        case 2:
          e2 = 250;
          break;
        case 5:
          e2 = 1073741823;
          break;
        case 4:
          e2 = 1e4;
          break;
        default:
          e2 = 5e3;
      }
      e2 = c2 + e2;
      a = { id: N2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
      c2 > d2 ? (a.sortIndex = c2, H2(M2, a), null === J2(L2) && a === J2(M2) && (S2 ? h2() : S2 = true, g2(U2, c2 - d2))) : (a.sortIndex = e2, H2(L2, a), R2 || Q2 || (R2 = true, f2(V2)));
      return a;
    };
    exports2.unstable_wrapCallback = function(a) {
      var b2 = P2;
      return function() {
        var c2 = P2;
        P2 = b2;
        try {
          return a.apply(this, arguments);
        } finally {
          P2 = c2;
        }
      };
    };
  })(scheduler_production_min);
  {
    scheduler.exports = scheduler_production_min;
  }
  var schedulerExports = scheduler.exports;
  /** @license React v17.0.1
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var aa$1 = reactExports, m$1 = objectAssign, r$2 = schedulerExports;
  function y$2(a) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
      b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  if (!aa$1)
    throw Error(y$2(227));
  var ba$1 = /* @__PURE__ */ new Set(), ca$1 = {};
  function da$1(a, b2) {
    ea$1(a, b2);
    ea$1(a + "Capture", b2);
  }
  function ea$1(a, b2) {
    ca$1[a] = b2;
    for (a = 0; a < b2.length; a++)
      ba$1.add(b2[a]);
  }
  var fa$1 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha$1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia$1 = Object.prototype.hasOwnProperty, ja$1 = {}, ka$1 = {};
  function la$1(a) {
    if (ia$1.call(ka$1, a))
      return true;
    if (ia$1.call(ja$1, a))
      return false;
    if (ha$1.test(a))
      return ka$1[a] = true;
    ja$1[a] = true;
    return false;
  }
  function ma$1(a, b2, c2, d2) {
    if (null !== c2 && 0 === c2.type)
      return false;
    switch (typeof b2) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2)
          return false;
        if (null !== c2)
          return !c2.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function na$1(a, b2, c2, d2) {
    if (null === b2 || "undefined" === typeof b2 || ma$1(a, b2, c2, d2))
      return true;
    if (d2)
      return false;
    if (null !== c2)
      switch (c2.type) {
        case 3:
          return !b2;
        case 4:
          return false === b2;
        case 5:
          return isNaN(b2);
        case 6:
          return isNaN(b2) || 1 > b2;
      }
    return false;
  }
  function B$1(a, b2, c2, d2, e2, f2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = e2;
    this.mustUseProperty = c2;
    this.propertyName = a;
    this.type = b2;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var D$1 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    D$1[a] = new B$1(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b2 = a[0];
    D$1[b2] = new B$1(b2, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    D$1[a] = new B$1(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    D$1[a] = new B$1(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    D$1[a] = new B$1(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    D$1[a] = new B$1(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    D$1[a] = new B$1(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    D$1[a] = new B$1(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    D$1[a] = new B$1(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var oa$1 = /[\-:]([a-z])/g;
  function pa$1(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b2 = a.replace(
      oa$1,
      pa$1
    );
    D$1[b2] = new B$1(b2, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b2 = a.replace(oa$1, pa$1);
    D$1[b2] = new B$1(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b2 = a.replace(oa$1, pa$1);
    D$1[b2] = new B$1(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    D$1[a] = new B$1(a, 1, false, a.toLowerCase(), null, false, false);
  });
  D$1.xlinkHref = new B$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    D$1[a] = new B$1(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function qa$1(a, b2, c2, d2) {
    var e2 = D$1.hasOwnProperty(b2) ? D$1[b2] : null;
    var f2 = null !== e2 ? 0 === e2.type : d2 ? false : !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1] ? false : true;
    f2 || (na$1(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? la$1(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2))));
  }
  var ra$1 = aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa$1 = 60103, ta$1 = 60106, ua$1 = 60107, wa$1 = 60108, xa$1 = 60114, ya$1 = 60109, za$1 = 60110, Aa$1 = 60112, Ba$1 = 60113, Ca$1 = 60120, Da$1 = 60115, Ea = 60116, Fa$1 = 60121, Ga = 60128, Ha$1 = 60129, Ia$1 = 60130, Ja = 60131;
  if ("function" === typeof Symbol && Symbol.for) {
    var E$1 = Symbol.for;
    sa$1 = E$1("react.element");
    ta$1 = E$1("react.portal");
    ua$1 = E$1("react.fragment");
    wa$1 = E$1("react.strict_mode");
    xa$1 = E$1("react.profiler");
    ya$1 = E$1("react.provider");
    za$1 = E$1("react.context");
    Aa$1 = E$1("react.forward_ref");
    Ba$1 = E$1("react.suspense");
    Ca$1 = E$1("react.suspense_list");
    Da$1 = E$1("react.memo");
    Ea = E$1("react.lazy");
    Fa$1 = E$1("react.block");
    E$1("react.scope");
    Ga = E$1("react.opaque.id");
    Ha$1 = E$1("react.debug_trace_mode");
    Ia$1 = E$1("react.offscreen");
    Ja = E$1("react.legacy_hidden");
  }
  var Ka$1 = "function" === typeof Symbol && Symbol.iterator;
  function La$1(a) {
    if (null === a || "object" !== typeof a)
      return null;
    a = Ka$1 && a[Ka$1] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var Ma$1;
  function Na$1(a) {
    if (void 0 === Ma$1)
      try {
        throw Error();
      } catch (c2) {
        var b2 = c2.stack.trim().match(/\n( *(at )?)/);
        Ma$1 = b2 && b2[1] || "";
      }
    return "\n" + Ma$1 + a;
  }
  var Oa$1 = false;
  function Pa$1(a, b2) {
    if (!a || Oa$1)
      return "";
    Oa$1 = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b2)
        if (b2 = function() {
          throw Error();
        }, Object.defineProperty(b2.prototype, "props", { set: function() {
          throw Error();
        } }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b2, []);
          } catch (k2) {
            var d2 = k2;
          }
          Reflect.construct(a, [], b2);
        } else {
          try {
            b2.call();
          } catch (k2) {
            d2 = k2;
          }
          a.call(b2.prototype);
        }
      else {
        try {
          throw Error();
        } catch (k2) {
          d2 = k2;
        }
        a();
      }
    } catch (k2) {
      if (k2 && d2 && "string" === typeof k2.stack) {
        for (var e2 = k2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
          h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--)
          if (e2[g2] !== f2[h2]) {
            if (1 !== g2 || 1 !== h2) {
              do
                if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2])
                  return "\n" + e2[g2].replace(" at new ", " at ");
              while (1 <= g2 && 0 <= h2);
            }
            break;
          }
      }
    } finally {
      Oa$1 = false, Error.prepareStackTrace = c2;
    }
    return (a = a ? a.displayName || a.name : "") ? Na$1(a) : "";
  }
  function Qa(a) {
    switch (a.tag) {
      case 5:
        return Na$1(a.type);
      case 16:
        return Na$1("Lazy");
      case 13:
        return Na$1("Suspense");
      case 19:
        return Na$1("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Pa$1(a.type, false), a;
      case 11:
        return a = Pa$1(a.type.render, false), a;
      case 22:
        return a = Pa$1(a.type._render, false), a;
      case 1:
        return a = Pa$1(a.type, true), a;
      default:
        return "";
    }
  }
  function Ra$1(a) {
    if (null == a)
      return null;
    if ("function" === typeof a)
      return a.displayName || a.name || null;
    if ("string" === typeof a)
      return a;
    switch (a) {
      case ua$1:
        return "Fragment";
      case ta$1:
        return "Portal";
      case xa$1:
        return "Profiler";
      case wa$1:
        return "StrictMode";
      case Ba$1:
        return "Suspense";
      case Ca$1:
        return "SuspenseList";
    }
    if ("object" === typeof a)
      switch (a.$$typeof) {
        case za$1:
          return (a.displayName || "Context") + ".Consumer";
        case ya$1:
          return (a._context.displayName || "Context") + ".Provider";
        case Aa$1:
          var b2 = a.render;
          b2 = b2.displayName || b2.name || "";
          return a.displayName || ("" !== b2 ? "ForwardRef(" + b2 + ")" : "ForwardRef");
        case Da$1:
          return Ra$1(a.type);
        case Fa$1:
          return Ra$1(a._render);
        case Ea:
          b2 = a._payload;
          a = a._init;
          try {
            return Ra$1(a(b2));
          } catch (c2) {
          }
      }
    return null;
  }
  function Sa$1(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "object":
      case "string":
      case "undefined":
        return a;
      default:
        return "";
    }
  }
  function Ta$1(a) {
    var b2 = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
  }
  function Ua$1(a) {
    var b2 = Ta$1(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
    if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e2 = c2.get, f2 = c2.set;
      Object.defineProperty(a, b2, { configurable: true, get: function() {
        return e2.call(this);
      }, set: function(a2) {
        d2 = "" + a2;
        f2.call(this, a2);
      } });
      Object.defineProperty(a, b2, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a2) {
        d2 = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null;
        delete a[b2];
      } };
    }
  }
  function Va$1(a) {
    a._valueTracker || (a._valueTracker = Ua$1(a));
  }
  function Wa$1(a) {
    if (!a)
      return false;
    var b2 = a._valueTracker;
    if (!b2)
      return true;
    var c2 = b2.getValue();
    var d2 = "";
    a && (d2 = Ta$1(a) ? a.checked ? "true" : "false" : a.value);
    a = d2;
    return a !== c2 ? (b2.setValue(a), true) : false;
  }
  function Xa$1(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a)
      return null;
    try {
      return a.activeElement || a.body;
    } catch (b2) {
      return a.body;
    }
  }
  function Ya(a, b2) {
    var c2 = b2.checked;
    return m$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
  }
  function Za$1(a, b2) {
    var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
    c2 = Sa$1(null != b2.value ? b2.value : c2);
    a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
  }
  function $a(a, b2) {
    b2 = b2.checked;
    null != b2 && qa$1(a, "checked", b2, false);
  }
  function ab(a, b2) {
    $a(a, b2);
    var c2 = Sa$1(b2.value), d2 = b2.type;
    if (null != c2)
      if ("number" === d2) {
        if (0 === c2 && "" === a.value || a.value != c2)
          a.value = "" + c2;
      } else
        a.value !== "" + c2 && (a.value = "" + c2);
    else if ("submit" === d2 || "reset" === d2) {
      a.removeAttribute("value");
      return;
    }
    b2.hasOwnProperty("value") ? bb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && bb(a, b2.type, Sa$1(b2.defaultValue));
    null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
  }
  function cb(a, b2, c2) {
    if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
      var d2 = b2.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
        return;
      b2 = "" + a._wrapperState.initialValue;
      c2 || b2 === a.value || (a.value = b2);
      a.defaultValue = b2;
    }
    c2 = a.name;
    "" !== c2 && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c2 && (a.name = c2);
  }
  function bb(a, b2, c2) {
    if ("number" !== b2 || Xa$1(a.ownerDocument) !== a)
      null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
  }
  function db(a) {
    var b2 = "";
    aa$1.Children.forEach(a, function(a2) {
      null != a2 && (b2 += a2);
    });
    return b2;
  }
  function eb(a, b2) {
    a = m$1({ children: void 0 }, b2);
    if (b2 = db(b2.children))
      a.children = b2;
    return a;
  }
  function fb(a, b2, c2, d2) {
    a = a.options;
    if (b2) {
      b2 = {};
      for (var e2 = 0; e2 < c2.length; e2++)
        b2["$" + c2[e2]] = true;
      for (c2 = 0; c2 < a.length; c2++)
        e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa$1(c2);
      b2 = null;
      for (e2 = 0; e2 < a.length; e2++) {
        if (a[e2].value === c2) {
          a[e2].selected = true;
          d2 && (a[e2].defaultSelected = true);
          return;
        }
        null !== b2 || a[e2].disabled || (b2 = a[e2]);
      }
      null !== b2 && (b2.selected = true);
    }
  }
  function gb(a, b2) {
    if (null != b2.dangerouslySetInnerHTML)
      throw Error(y$2(91));
    return m$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b2) {
    var c2 = b2.value;
    if (null == c2) {
      c2 = b2.children;
      b2 = b2.defaultValue;
      if (null != c2) {
        if (null != b2)
          throw Error(y$2(92));
        if (Array.isArray(c2)) {
          if (!(1 >= c2.length))
            throw Error(y$2(93));
          c2 = c2[0];
        }
        b2 = c2;
      }
      null == b2 && (b2 = "");
      c2 = b2;
    }
    a._wrapperState = { initialValue: Sa$1(c2) };
  }
  function ib(a, b2) {
    var c2 = Sa$1(b2.value), d2 = Sa$1(b2.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
    null != d2 && (a.defaultValue = "" + d2);
  }
  function jb(a) {
    var b2 = a.textContent;
    b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
  }
  var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
  function lb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function mb(a, b2) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
  }
  var nb, ob = function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b2, c2, d2, e2);
      });
    } : a;
  }(function(a, b2) {
    if (a.namespaceURI !== kb.svg || "innerHTML" in a)
      a.innerHTML = b2;
    else {
      nb = nb || document.createElement("div");
      nb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
      for (b2 = nb.firstChild; a.firstChild; )
        a.removeChild(a.firstChild);
      for (; b2.firstChild; )
        a.appendChild(b2.firstChild);
    }
  });
  function pb(a, b2) {
    if (b2) {
      var c2 = a.firstChild;
      if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b2;
        return;
      }
    }
    a.textContent = b2;
  }
  var qb = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, rb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(qb).forEach(function(a) {
    rb.forEach(function(b2) {
      b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
      qb[b2] = qb[a];
    });
  });
  function sb(a, b2, c2) {
    return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || qb.hasOwnProperty(a) && qb[a] ? ("" + b2).trim() : b2 + "px";
  }
  function tb(a, b2) {
    a = a.style;
    for (var c2 in b2)
      if (b2.hasOwnProperty(c2)) {
        var d2 = 0 === c2.indexOf("--"), e2 = sb(c2, b2[c2], d2);
        "float" === c2 && (c2 = "cssFloat");
        d2 ? a.setProperty(c2, e2) : a[c2] = e2;
      }
  }
  var ub = m$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function vb(a, b2) {
    if (b2) {
      if (ub[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
        throw Error(y$2(137, a));
      if (null != b2.dangerouslySetInnerHTML) {
        if (null != b2.children)
          throw Error(y$2(60));
        if (!("object" === typeof b2.dangerouslySetInnerHTML && "__html" in b2.dangerouslySetInnerHTML))
          throw Error(y$2(61));
      }
      if (null != b2.style && "object" !== typeof b2.style)
        throw Error(y$2(62));
    }
  }
  function wb(a, b2) {
    if (-1 === a.indexOf("-"))
      return "string" === typeof b2.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb)
        throw Error(y$2(280));
      var b2 = a.stateNode;
      b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b2 = Ab;
      Ab = zb = null;
      Bb(a);
      if (b2)
        for (a = 0; a < b2.length; a++)
          Bb(b2[a]);
    }
  }
  function Gb(a, b2) {
    return a(b2);
  }
  function Hb(a, b2, c2, d2, e2) {
    return a(b2, c2, d2, e2);
  }
  function Ib() {
  }
  var Jb = Gb, Kb = false, Lb = false;
  function Mb() {
    if (null !== zb || null !== Ab)
      Ib(), Fb();
  }
  function Nb(a, b2, c2) {
    if (Lb)
      return a(b2, c2);
    Lb = true;
    try {
      return Jb(a, b2, c2);
    } finally {
      Lb = false, Mb();
    }
  }
  function Ob(a, b2) {
    var c2 = a.stateNode;
    if (null === c2)
      return null;
    var d2 = Db(c2);
    if (null === d2)
      return null;
    c2 = d2[b2];
    a:
      switch (b2) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
          a = !d2;
          break a;
        default:
          a = false;
      }
    if (a)
      return null;
    if (c2 && "function" !== typeof c2)
      throw Error(y$2(231, b2, typeof c2));
    return c2;
  }
  var Pb = false;
  if (fa$1)
    try {
      var Qb = {};
      Object.defineProperty(Qb, "passive", { get: function() {
        Pb = true;
      } });
      window.addEventListener("test", Qb, Qb);
      window.removeEventListener("test", Qb, Qb);
    } catch (a) {
      Pb = false;
    }
  function Rb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b2.apply(c2, l2);
    } catch (n2) {
      this.onError(n2);
    }
  }
  var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a) {
    Sb = true;
    Tb = a;
  } };
  function Xb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
    Sb = false;
    Tb = null;
    Rb.apply(Wb, arguments);
  }
  function Yb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
    Xb.apply(this, arguments);
    if (Sb) {
      if (Sb) {
        var l2 = Tb;
        Sb = false;
        Tb = null;
      } else
        throw Error(y$2(198));
      Ub || (Ub = true, Vb = l2);
    }
  }
  function Zb(a) {
    var b2 = a, c2 = a;
    if (a.alternate)
      for (; b2.return; )
        b2 = b2.return;
    else {
      a = b2;
      do
        b2 = a, 0 !== (b2.flags & 1026) && (c2 = b2.return), a = b2.return;
      while (a);
    }
    return 3 === b2.tag ? c2 : null;
  }
  function $b(a) {
    if (13 === a.tag) {
      var b2 = a.memoizedState;
      null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
      if (null !== b2)
        return b2.dehydrated;
    }
    return null;
  }
  function ac$1(a) {
    if (Zb(a) !== a)
      throw Error(y$2(188));
  }
  function bc$1(a) {
    var b2 = a.alternate;
    if (!b2) {
      b2 = Zb(a);
      if (null === b2)
        throw Error(y$2(188));
      return b2 !== a ? null : a;
    }
    for (var c2 = a, d2 = b2; ; ) {
      var e2 = c2.return;
      if (null === e2)
        break;
      var f2 = e2.alternate;
      if (null === f2) {
        d2 = e2.return;
        if (null !== d2) {
          c2 = d2;
          continue;
        }
        break;
      }
      if (e2.child === f2.child) {
        for (f2 = e2.child; f2; ) {
          if (f2 === c2)
            return ac$1(e2), a;
          if (f2 === d2)
            return ac$1(e2), b2;
          f2 = f2.sibling;
        }
        throw Error(y$2(188));
      }
      if (c2.return !== d2.return)
        c2 = e2, d2 = f2;
      else {
        for (var g2 = false, h2 = e2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = e2;
            d2 = f2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = e2;
            c2 = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = f2;
              d2 = e2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = f2;
              c2 = e2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2)
            throw Error(y$2(189));
        }
      }
      if (c2.alternate !== d2)
        throw Error(y$2(190));
    }
    if (3 !== c2.tag)
      throw Error(y$2(188));
    return c2.stateNode.current === c2 ? a : b2;
  }
  function cc$1(a) {
    a = bc$1(a);
    if (!a)
      return null;
    for (var b2 = a; ; ) {
      if (5 === b2.tag || 6 === b2.tag)
        return b2;
      if (b2.child)
        b2.child.return = b2, b2 = b2.child;
      else {
        if (b2 === a)
          break;
        for (; !b2.sibling; ) {
          if (!b2.return || b2.return === a)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
    }
    return null;
  }
  function dc$1(a, b2) {
    for (var c2 = a.alternate; null !== b2; ) {
      if (b2 === a || b2 === c2)
        return true;
      b2 = b2.return;
    }
    return false;
  }
  var ec$1, fc$1, gc$1, hc$1, ic$1 = false, jc$1 = [], kc$1 = null, lc$1 = null, mc$1 = null, nc$1 = /* @__PURE__ */ new Map(), oc$1 = /* @__PURE__ */ new Map(), pc$1 = [], qc$1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function rc$1(a, b2, c2, d2, e2) {
    return { blockedOn: a, domEventName: b2, eventSystemFlags: c2 | 16, nativeEvent: e2, targetContainers: [d2] };
  }
  function sc$1(a, b2) {
    switch (a) {
      case "focusin":
      case "focusout":
        kc$1 = null;
        break;
      case "dragenter":
      case "dragleave":
        lc$1 = null;
        break;
      case "mouseover":
      case "mouseout":
        mc$1 = null;
        break;
      case "pointerover":
      case "pointerout":
        nc$1.delete(b2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        oc$1.delete(b2.pointerId);
    }
  }
  function tc$1(a, b2, c2, d2, e2, f2) {
    if (null === a || a.nativeEvent !== f2)
      return a = rc$1(b2, c2, d2, e2, f2), null !== b2 && (b2 = Cb(b2), null !== b2 && fc$1(b2)), a;
    a.eventSystemFlags |= d2;
    b2 = a.targetContainers;
    null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
    return a;
  }
  function uc$1(a, b2, c2, d2, e2) {
    switch (b2) {
      case "focusin":
        return kc$1 = tc$1(kc$1, a, b2, c2, d2, e2), true;
      case "dragenter":
        return lc$1 = tc$1(lc$1, a, b2, c2, d2, e2), true;
      case "mouseover":
        return mc$1 = tc$1(mc$1, a, b2, c2, d2, e2), true;
      case "pointerover":
        var f2 = e2.pointerId;
        nc$1.set(f2, tc$1(nc$1.get(f2) || null, a, b2, c2, d2, e2));
        return true;
      case "gotpointercapture":
        return f2 = e2.pointerId, oc$1.set(f2, tc$1(oc$1.get(f2) || null, a, b2, c2, d2, e2)), true;
    }
    return false;
  }
  function vc$1(a) {
    var b2 = wc$1(a.target);
    if (null !== b2) {
      var c2 = Zb(b2);
      if (null !== c2) {
        if (b2 = c2.tag, 13 === b2) {
          if (b2 = $b(c2), null !== b2) {
            a.blockedOn = b2;
            hc$1(a.lanePriority, function() {
              r$2.unstable_runWithPriority(a.priority, function() {
                gc$1(c2);
              });
            });
            return;
          }
        } else if (3 === b2 && c2.stateNode.hydrate) {
          a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function xc$1(a) {
    if (null !== a.blockedOn)
      return false;
    for (var b2 = a.targetContainers; 0 < b2.length; ) {
      var c2 = yc$1(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
      if (null !== c2)
        return b2 = Cb(c2), null !== b2 && fc$1(b2), a.blockedOn = c2, false;
      b2.shift();
    }
    return true;
  }
  function zc$1(a, b2, c2) {
    xc$1(a) && c2.delete(b2);
  }
  function Ac$1() {
    for (ic$1 = false; 0 < jc$1.length; ) {
      var a = jc$1[0];
      if (null !== a.blockedOn) {
        a = Cb(a.blockedOn);
        null !== a && ec$1(a);
        break;
      }
      for (var b2 = a.targetContainers; 0 < b2.length; ) {
        var c2 = yc$1(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
        if (null !== c2) {
          a.blockedOn = c2;
          break;
        }
        b2.shift();
      }
      null === a.blockedOn && jc$1.shift();
    }
    null !== kc$1 && xc$1(kc$1) && (kc$1 = null);
    null !== lc$1 && xc$1(lc$1) && (lc$1 = null);
    null !== mc$1 && xc$1(mc$1) && (mc$1 = null);
    nc$1.forEach(zc$1);
    oc$1.forEach(zc$1);
  }
  function Bc$1(a, b2) {
    a.blockedOn === b2 && (a.blockedOn = null, ic$1 || (ic$1 = true, r$2.unstable_scheduleCallback(r$2.unstable_NormalPriority, Ac$1)));
  }
  function Cc$1(a) {
    function b2(b3) {
      return Bc$1(b3, a);
    }
    if (0 < jc$1.length) {
      Bc$1(jc$1[0], a);
      for (var c2 = 1; c2 < jc$1.length; c2++) {
        var d2 = jc$1[c2];
        d2.blockedOn === a && (d2.blockedOn = null);
      }
    }
    null !== kc$1 && Bc$1(kc$1, a);
    null !== lc$1 && Bc$1(lc$1, a);
    null !== mc$1 && Bc$1(mc$1, a);
    nc$1.forEach(b2);
    oc$1.forEach(b2);
    for (c2 = 0; c2 < pc$1.length; c2++)
      d2 = pc$1[c2], d2.blockedOn === a && (d2.blockedOn = null);
    for (; 0 < pc$1.length && (c2 = pc$1[0], null === c2.blockedOn); )
      vc$1(c2), null === c2.blockedOn && pc$1.shift();
  }
  function Dc$1(a, b2) {
    var c2 = {};
    c2[a.toLowerCase()] = b2.toLowerCase();
    c2["Webkit" + a] = "webkit" + b2;
    c2["Moz" + a] = "moz" + b2;
    return c2;
  }
  var Ec$1 = { animationend: Dc$1("Animation", "AnimationEnd"), animationiteration: Dc$1("Animation", "AnimationIteration"), animationstart: Dc$1("Animation", "AnimationStart"), transitionend: Dc$1("Transition", "TransitionEnd") }, Fc$1 = {}, Gc$1 = {};
  fa$1 && (Gc$1 = document.createElement("div").style, "AnimationEvent" in window || (delete Ec$1.animationend.animation, delete Ec$1.animationiteration.animation, delete Ec$1.animationstart.animation), "TransitionEvent" in window || delete Ec$1.transitionend.transition);
  function Hc$1(a) {
    if (Fc$1[a])
      return Fc$1[a];
    if (!Ec$1[a])
      return a;
    var b2 = Ec$1[a], c2;
    for (c2 in b2)
      if (b2.hasOwnProperty(c2) && c2 in Gc$1)
        return Fc$1[a] = b2[c2];
    return a;
  }
  var Ic$1 = Hc$1("animationend"), Jc$1 = Hc$1("animationiteration"), Kc$1 = Hc$1("animationstart"), Lc$1 = Hc$1("transitionend"), Mc$1 = /* @__PURE__ */ new Map(), Nc$1 = /* @__PURE__ */ new Map(), Oc$1 = [
    "abort",
    "abort",
    Ic$1,
    "animationEnd",
    Jc$1,
    "animationIteration",
    Kc$1,
    "animationStart",
    "canplay",
    "canPlay",
    "canplaythrough",
    "canPlayThrough",
    "durationchange",
    "durationChange",
    "emptied",
    "emptied",
    "encrypted",
    "encrypted",
    "ended",
    "ended",
    "error",
    "error",
    "gotpointercapture",
    "gotPointerCapture",
    "load",
    "load",
    "loadeddata",
    "loadedData",
    "loadedmetadata",
    "loadedMetadata",
    "loadstart",
    "loadStart",
    "lostpointercapture",
    "lostPointerCapture",
    "playing",
    "playing",
    "progress",
    "progress",
    "seeking",
    "seeking",
    "stalled",
    "stalled",
    "suspend",
    "suspend",
    "timeupdate",
    "timeUpdate",
    Lc$1,
    "transitionEnd",
    "waiting",
    "waiting"
  ];
  function Pc$1(a, b2) {
    for (var c2 = 0; c2 < a.length; c2 += 2) {
      var d2 = a[c2], e2 = a[c2 + 1];
      e2 = "on" + (e2[0].toUpperCase() + e2.slice(1));
      Nc$1.set(d2, b2);
      Mc$1.set(d2, e2);
      da$1(e2, [d2]);
    }
  }
  var Qc$1 = r$2.unstable_now;
  Qc$1();
  var F$1 = 8;
  function Rc$1(a) {
    if (0 !== (1 & a))
      return F$1 = 15, 1;
    if (0 !== (2 & a))
      return F$1 = 14, 2;
    if (0 !== (4 & a))
      return F$1 = 13, 4;
    var b2 = 24 & a;
    if (0 !== b2)
      return F$1 = 12, b2;
    if (0 !== (a & 32))
      return F$1 = 11, 32;
    b2 = 192 & a;
    if (0 !== b2)
      return F$1 = 10, b2;
    if (0 !== (a & 256))
      return F$1 = 9, 256;
    b2 = 3584 & a;
    if (0 !== b2)
      return F$1 = 8, b2;
    if (0 !== (a & 4096))
      return F$1 = 7, 4096;
    b2 = 4186112 & a;
    if (0 !== b2)
      return F$1 = 6, b2;
    b2 = 62914560 & a;
    if (0 !== b2)
      return F$1 = 5, b2;
    if (a & 67108864)
      return F$1 = 4, 67108864;
    if (0 !== (a & 134217728))
      return F$1 = 3, 134217728;
    b2 = 805306368 & a;
    if (0 !== b2)
      return F$1 = 2, b2;
    if (0 !== (1073741824 & a))
      return F$1 = 1, 1073741824;
    F$1 = 8;
    return a;
  }
  function Sc$1(a) {
    switch (a) {
      case 99:
        return 15;
      case 98:
        return 10;
      case 97:
      case 96:
        return 8;
      case 95:
        return 2;
      default:
        return 0;
    }
  }
  function Tc$1(a) {
    switch (a) {
      case 15:
      case 14:
        return 99;
      case 13:
      case 12:
      case 11:
      case 10:
        return 98;
      case 9:
      case 8:
      case 7:
      case 6:
      case 4:
      case 5:
        return 97;
      case 3:
      case 2:
      case 1:
        return 95;
      case 0:
        return 90;
      default:
        throw Error(y$2(358, a));
    }
  }
  function Uc$1(a, b2) {
    var c2 = a.pendingLanes;
    if (0 === c2)
      return F$1 = 0;
    var d2 = 0, e2 = 0, f2 = a.expiredLanes, g2 = a.suspendedLanes, h2 = a.pingedLanes;
    if (0 !== f2)
      d2 = f2, e2 = F$1 = 15;
    else if (f2 = c2 & 134217727, 0 !== f2) {
      var k2 = f2 & ~g2;
      0 !== k2 ? (d2 = Rc$1(k2), e2 = F$1) : (h2 &= f2, 0 !== h2 && (d2 = Rc$1(h2), e2 = F$1));
    } else
      f2 = c2 & ~g2, 0 !== f2 ? (d2 = Rc$1(f2), e2 = F$1) : 0 !== h2 && (d2 = Rc$1(h2), e2 = F$1);
    if (0 === d2)
      return 0;
    d2 = 31 - Vc$1(d2);
    d2 = c2 & ((0 > d2 ? 0 : 1 << d2) << 1) - 1;
    if (0 !== b2 && b2 !== d2 && 0 === (b2 & g2)) {
      Rc$1(b2);
      if (e2 <= F$1)
        return b2;
      F$1 = e2;
    }
    b2 = a.entangledLanes;
    if (0 !== b2)
      for (a = a.entanglements, b2 &= d2; 0 < b2; )
        c2 = 31 - Vc$1(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
    return d2;
  }
  function Wc$1(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function Xc$1(a, b2) {
    switch (a) {
      case 15:
        return 1;
      case 14:
        return 2;
      case 12:
        return a = Yc$1(24 & ~b2), 0 === a ? Xc$1(10, b2) : a;
      case 10:
        return a = Yc$1(192 & ~b2), 0 === a ? Xc$1(8, b2) : a;
      case 8:
        return a = Yc$1(3584 & ~b2), 0 === a && (a = Yc$1(4186112 & ~b2), 0 === a && (a = 512)), a;
      case 2:
        return b2 = Yc$1(805306368 & ~b2), 0 === b2 && (b2 = 268435456), b2;
    }
    throw Error(y$2(358, a));
  }
  function Yc$1(a) {
    return a & -a;
  }
  function Zc$1(a) {
    for (var b2 = [], c2 = 0; 31 > c2; c2++)
      b2.push(a);
    return b2;
  }
  function $c$1(a, b2, c2) {
    a.pendingLanes |= b2;
    var d2 = b2 - 1;
    a.suspendedLanes &= d2;
    a.pingedLanes &= d2;
    a = a.eventTimes;
    b2 = 31 - Vc$1(b2);
    a[b2] = c2;
  }
  var Vc$1 = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
  function ad(a) {
    return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
  }
  var dd = r$2.unstable_UserBlockingPriority, ed = r$2.unstable_runWithPriority, fd = true;
  function gd(a, b2, c2, d2) {
    Kb || Ib();
    var e2 = hd, f2 = Kb;
    Kb = true;
    try {
      Hb(e2, a, b2, c2, d2);
    } finally {
      (Kb = f2) || Mb();
    }
  }
  function id(a, b2, c2, d2) {
    ed(dd, hd.bind(null, a, b2, c2, d2));
  }
  function hd(a, b2, c2, d2) {
    if (fd) {
      var e2;
      if ((e2 = 0 === (b2 & 4)) && 0 < jc$1.length && -1 < qc$1.indexOf(a))
        a = rc$1(null, a, b2, c2, d2), jc$1.push(a);
      else {
        var f2 = yc$1(a, b2, c2, d2);
        if (null === f2)
          e2 && sc$1(a, d2);
        else {
          if (e2) {
            if (-1 < qc$1.indexOf(a)) {
              a = rc$1(f2, a, b2, c2, d2);
              jc$1.push(a);
              return;
            }
            if (uc$1(f2, a, b2, c2, d2))
              return;
            sc$1(a, d2);
          }
          jd(a, b2, d2, null, c2);
        }
      }
    }
  }
  function yc$1(a, b2, c2, d2) {
    var e2 = xb(d2);
    e2 = wc$1(e2);
    if (null !== e2) {
      var f2 = Zb(e2);
      if (null === f2)
        e2 = null;
      else {
        var g2 = f2.tag;
        if (13 === g2) {
          e2 = $b(f2);
          if (null !== e2)
            return e2;
          e2 = null;
        } else if (3 === g2) {
          if (f2.stateNode.hydrate)
            return 3 === f2.tag ? f2.stateNode.containerInfo : null;
          e2 = null;
        } else
          f2 !== e2 && (e2 = null);
      }
    }
    jd(a, b2, d2, e2, c2);
    return null;
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md)
      return md;
    var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
    for (a = 0; a < c2 && b2[a] === e2[a]; a++)
      ;
    var g2 = c2 - a;
    for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
      ;
    return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
  }
  function od(a) {
    var b2 = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b2(b3, d2, e2, f2, g2) {
      this._reactName = b3;
      this._targetInst = e2;
      this.type = d2;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c2 in a)
        a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    m$1(b2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b2;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad$1 = m$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    if ("movementX" in a)
      return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd$1 = rd(Ad$1), Cd = m$1({}, Ad$1, { dataTransfer: 0 }), Dd = rd(Cd), Ed$1 = m$1({}, ud, { relatedTarget: 0 }), Fd$1 = rd(Ed$1), Gd = m$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m$1({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = m$1({}, sd, { data: 0 }), Ld = rd(Kd), Md$1 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od$1 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd$1(a) {
    var b2 = this.nativeEvent;
    return b2.getModifierState ? b2.getModifierState(a) : (a = Od$1[a]) ? !!b2[a] : false;
  }
  function zd() {
    return Pd$1;
  }
  var Qd = m$1({}, ud, { key: function(a) {
    if (a.key) {
      var b2 = Md$1[a.key] || a.key;
      if ("Unidentified" !== b2)
        return b2;
    }
    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = m$1({}, Ad$1, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td$1 = rd(Sd), Ud = m$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd$1 = m$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd$1), Yd = m$1({}, Ad$1, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d$1 = [9, 13, 27, 32], ae = fa$1 && "CompositionEvent" in window, be$1 = null;
  fa$1 && "documentMode" in document && (be$1 = document.documentMode);
  var ce = fa$1 && "TextEvent" in window && !be$1, de$1 = fa$1 && (!ae || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$1 = false;
  function ge(a, b2) {
    switch (a) {
      case "keyup":
        return -1 !== $d$1.indexOf(b2.keyCode);
      case "keydown":
        return 229 !== b2.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he$1(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie = false;
  function je(a, b2) {
    switch (a) {
      case "compositionend":
        return he$1(b2);
      case "keypress":
        if (32 !== b2.which)
          return null;
        fe$1 = true;
        return ee$1;
      case "textInput":
        return a = b2.data, a === ee$1 && fe$1 ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b2) {
    if (ie)
      return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
          if (b2.char && 1 < b2.char.length)
            return b2.char;
          if (b2.which)
            return String.fromCharCode(b2.which);
        }
        return null;
      case "compositionend":
        return de$1 && "ko" !== b2.locale ? null : b2.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a) {
    var b2 = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
  }
  function ne(a, b2, c2, d2) {
    Eb(d2);
    b2 = oe$1(b2, "onChange");
    0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
  }
  var pe = null, qe = null;
  function re(a) {
    se(a, 0);
  }
  function te(a) {
    var b2 = ue(a);
    if (Wa$1(b2))
      return a;
  }
  function ve$1(a, b2) {
    if ("change" === a)
      return b2;
  }
  var we = false;
  if (fa$1) {
    var xe$1;
    if (fa$1) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze$1 = document.createElement("div");
        ze$1.setAttribute("oninput", "return;");
        ye = "function" === typeof ze$1.oninput;
      }
      xe$1 = ye;
    } else
      xe$1 = false;
    we = xe$1 && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b2 = [];
      ne(b2, qe, a, xb(a));
      a = re;
      if (Kb)
        a(b2);
      else {
        Kb = true;
        try {
          Gb(a, b2);
        } finally {
          Kb = false, Mb();
        }
      }
    }
  }
  function Ce$1(a, b2, c2) {
    "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a)
      return te(qe);
  }
  function Ee(a, b2) {
    if ("click" === a)
      return te(b2);
  }
  function Fe(a, b2) {
    if ("input" === a || "change" === a)
      return te(b2);
  }
  function Ge$1(a, b2) {
    return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge$1, Ie = Object.prototype.hasOwnProperty;
  function Je(a, b2) {
    if (He(a, b2))
      return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
      return false;
    var c2 = Object.keys(a), d2 = Object.keys(b2);
    if (c2.length !== d2.length)
      return false;
    for (d2 = 0; d2 < c2.length; d2++)
      if (!Ie.call(b2, c2[d2]) || !He(a[c2[d2]], b2[c2[d2]]))
        return false;
    return true;
  }
  function Ke$1(a) {
    for (; a && a.firstChild; )
      a = a.firstChild;
    return a;
  }
  function Le$1(a, b2) {
    var c2 = Ke$1(a);
    a = 0;
    for (var d2; c2; ) {
      if (3 === c2.nodeType) {
        d2 = a + c2.textContent.length;
        if (a <= b2 && d2 >= b2)
          return { node: c2, offset: b2 - a };
        a = d2;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Ke$1(c2);
    }
  }
  function Me(a, b2) {
    return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Me(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
  }
  function Ne() {
    for (var a = window, b2 = Xa$1(); b2 instanceof a.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b2.contentWindow.location.href;
      } catch (d2) {
        c2 = false;
      }
      if (c2)
        a = b2.contentWindow;
      else
        break;
      b2 = Xa$1(a.document);
    }
    return b2;
  }
  function Oe(a) {
    var b2 = a && a.nodeName && a.nodeName.toLowerCase();
    return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
  }
  var Pe = fa$1 && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re = null, Se$1 = null, Te = false;
  function Ue(a, b2, c2) {
    var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te || null == Qe$1 || Qe$1 !== Xa$1(d2) || (d2 = Qe$1, "selectionStart" in d2 && Oe(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Je(Se$1, d2) || (Se$1 = d2, d2 = oe$1(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
  }
  Pc$1(
    "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
    0
  );
  Pc$1("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
  Pc$1(Oc$1, 2);
  for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We$1 = 0; We$1 < Ve.length; We$1++)
    Nc$1.set(Ve[We$1], 0);
  ea$1("onMouseEnter", ["mouseout", "mouseover"]);
  ea$1("onMouseLeave", ["mouseout", "mouseover"]);
  ea$1("onPointerEnter", ["pointerout", "pointerover"]);
  ea$1("onPointerLeave", ["pointerout", "pointerover"]);
  da$1("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  da$1("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  da$1("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  da$1("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  da$1("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  da$1("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye$1 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
  function Ze(a, b2, c2) {
    var d2 = a.type || "unknown-event";
    a.currentTarget = c2;
    Yb(d2, b2, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b2) {
    b2 = 0 !== (b2 & 4);
    for (var c2 = 0; c2 < a.length; c2++) {
      var d2 = a[c2], e2 = d2.event;
      d2 = d2.listeners;
      a: {
        var f2 = void 0;
        if (b2)
          for (var g2 = d2.length - 1; 0 <= g2; g2--) {
            var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
            h2 = h2.listener;
            if (k2 !== f2 && e2.isPropagationStopped())
              break a;
            Ze(e2, h2, l2);
            f2 = k2;
          }
        else
          for (g2 = 0; g2 < d2.length; g2++) {
            h2 = d2[g2];
            k2 = h2.instance;
            l2 = h2.currentTarget;
            h2 = h2.listener;
            if (k2 !== f2 && e2.isPropagationStopped())
              break a;
            Ze(e2, h2, l2);
            f2 = k2;
          }
      }
    }
    if (Ub)
      throw a = Vb, Ub = false, Vb = null, a;
  }
  function G$2(a, b2) {
    var c2 = $e(b2), d2 = a + "__bubble";
    c2.has(d2) || (af(b2, a, 2, false), c2.add(d2));
  }
  var bf = "_reactListening" + Math.random().toString(36).slice(2);
  function cf(a) {
    a[bf] || (a[bf] = true, ba$1.forEach(function(b2) {
      Ye$1.has(b2) || df(b2, false, a, null);
      df(b2, true, a, null);
    }));
  }
  function df(a, b2, c2, d2) {
    var e2 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f2 = c2;
    "selectionchange" === a && 9 !== c2.nodeType && (f2 = c2.ownerDocument);
    if (null !== d2 && !b2 && Ye$1.has(a)) {
      if ("scroll" !== a)
        return;
      e2 |= 2;
      f2 = d2;
    }
    var g2 = $e(f2), h2 = a + "__" + (b2 ? "capture" : "bubble");
    g2.has(h2) || (b2 && (e2 |= 4), af(f2, a, e2, b2), g2.add(h2));
  }
  function af(a, b2, c2, d2) {
    var e2 = Nc$1.get(b2);
    switch (void 0 === e2 ? 2 : e2) {
      case 0:
        e2 = gd;
        break;
      case 1:
        e2 = id;
        break;
      default:
        e2 = hd;
    }
    c2 = e2.bind(null, b2, c2, a);
    e2 = void 0;
    !Pb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
    d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
  }
  function jd(a, b2, c2, d2, e2) {
    var f2 = d2;
    if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
      a:
        for (; ; ) {
          if (null === d2)
            return;
          var g2 = d2.tag;
          if (3 === g2 || 4 === g2) {
            var h2 = d2.stateNode.containerInfo;
            if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
              break;
            if (4 === g2)
              for (g2 = d2.return; null !== g2; ) {
                var k2 = g2.tag;
                if (3 === k2 || 4 === k2) {
                  if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                    return;
                }
                g2 = g2.return;
              }
            for (; null !== h2; ) {
              g2 = wc$1(h2);
              if (null === g2)
                return;
              k2 = g2.tag;
              if (5 === k2 || 6 === k2) {
                d2 = f2 = g2;
                continue a;
              }
              h2 = h2.parentNode;
            }
          }
          d2 = d2.return;
        }
    Nb(function() {
      var d3 = f2, e3 = xb(c2), g3 = [];
      a: {
        var h3 = Mc$1.get(a);
        if (void 0 !== h3) {
          var k3 = td, x2 = a;
          switch (a) {
            case "keypress":
              if (0 === od(c2))
                break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              x2 = "focus";
              k3 = Fd$1;
              break;
            case "focusout":
              x2 = "blur";
              k3 = Fd$1;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd$1;
              break;
            case "click":
              if (2 === c2.button)
                break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd$1;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case Ic$1:
            case Jc$1:
            case Kc$1:
              k3 = Hd;
              break;
            case Lc$1:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td$1;
          }
          var w2 = 0 !== (b2 & 4), z2 = !w2 && "scroll" === a, u2 = w2 ? null !== h3 ? h3 + "Capture" : null : h3;
          w2 = [];
          for (var t2 = d3, q2; null !== t2; ) {
            q2 = t2;
            var v2 = q2.stateNode;
            5 === q2.tag && null !== v2 && (q2 = v2, null !== u2 && (v2 = Ob(t2, u2), null != v2 && w2.push(ef(t2, v2, q2))));
            if (z2)
              break;
            t2 = t2.return;
          }
          0 < w2.length && (h3 = new k3(h3, x2, null, c2, e3), g3.push({ event: h3, listeners: w2 }));
        }
      }
      if (0 === (b2 & 7)) {
        a: {
          h3 = "mouseover" === a || "pointerover" === a;
          k3 = "mouseout" === a || "pointerout" === a;
          if (h3 && 0 === (b2 & 16) && (x2 = c2.relatedTarget || c2.fromElement) && (wc$1(x2) || x2[ff]))
            break a;
          if (k3 || h3) {
            h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (x2 = c2.relatedTarget || c2.toElement, k3 = d3, x2 = x2 ? wc$1(x2) : null, null !== x2 && (z2 = Zb(x2), x2 !== z2 || 5 !== x2.tag && 6 !== x2.tag))
                x2 = null;
            } else
              k3 = null, x2 = d3;
            if (k3 !== x2) {
              w2 = Bd$1;
              v2 = "onMouseLeave";
              u2 = "onMouseEnter";
              t2 = "mouse";
              if ("pointerout" === a || "pointerover" === a)
                w2 = Td$1, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
              z2 = null == k3 ? h3 : ue(k3);
              q2 = null == x2 ? h3 : ue(x2);
              h3 = new w2(v2, t2 + "leave", k3, c2, e3);
              h3.target = z2;
              h3.relatedTarget = q2;
              v2 = null;
              wc$1(e3) === d3 && (w2 = new w2(u2, t2 + "enter", x2, c2, e3), w2.target = q2, w2.relatedTarget = z2, v2 = w2);
              z2 = v2;
              if (k3 && x2)
                b: {
                  w2 = k3;
                  u2 = x2;
                  t2 = 0;
                  for (q2 = w2; q2; q2 = gf(q2))
                    t2++;
                  q2 = 0;
                  for (v2 = u2; v2; v2 = gf(v2))
                    q2++;
                  for (; 0 < t2 - q2; )
                    w2 = gf(w2), t2--;
                  for (; 0 < q2 - t2; )
                    u2 = gf(u2), q2--;
                  for (; t2--; ) {
                    if (w2 === u2 || null !== u2 && w2 === u2.alternate)
                      break b;
                    w2 = gf(w2);
                    u2 = gf(u2);
                  }
                  w2 = null;
                }
              else
                w2 = null;
              null !== k3 && hf(g3, h3, k3, w2, false);
              null !== x2 && null !== z2 && hf(g3, z2, x2, w2, true);
            }
          }
        }
        a: {
          h3 = d3 ? ue(d3) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type)
            var J2 = ve$1;
          else if (me(h3))
            if (we)
              J2 = Fe;
            else {
              J2 = De;
              var K2 = Ce$1;
            }
          else
            (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (J2 = Ee);
          if (J2 && (J2 = J2(a, d3))) {
            ne(g3, J2, c2, e3);
            break a;
          }
          K2 && K2(a, h3, d3);
          "focusout" === a && (K2 = h3._wrapperState) && K2.controlled && "number" === h3.type && bb(h3, "number", h3.value);
        }
        K2 = d3 ? ue(d3) : window;
        switch (a) {
          case "focusin":
            if (me(K2) || "true" === K2.contentEditable)
              Qe$1 = K2, Re = d3, Se$1 = null;
            break;
          case "focusout":
            Se$1 = Re = Qe$1 = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g3, c2, e3);
            break;
          case "selectionchange":
            if (Pe)
              break;
          case "keydown":
          case "keyup":
            Ue(g3, c2, e3);
        }
        var Q2;
        if (ae)
          b: {
            switch (a) {
              case "compositionstart":
                var L2 = "onCompositionStart";
                break b;
              case "compositionend":
                L2 = "onCompositionEnd";
                break b;
              case "compositionupdate":
                L2 = "onCompositionUpdate";
                break b;
            }
            L2 = void 0;
          }
        else
          ie ? ge(a, c2) && (L2 = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (L2 = "onCompositionStart");
        L2 && (de$1 && "ko" !== c2.locale && (ie || "onCompositionStart" !== L2 ? "onCompositionEnd" === L2 && ie && (Q2 = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe$1(d3, L2), 0 < K2.length && (L2 = new Ld(L2, a, null, c2, e3), g3.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he$1(c2), null !== Q2 && (L2.data = Q2))));
        if (Q2 = ce ? je(a, c2) : ke(a, c2))
          d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld(
            "onBeforeInput",
            "beforeinput",
            null,
            c2,
            e3
          ), g3.push({ event: e3, listeners: d3 }), e3.data = Q2);
      }
      se(g3, b2);
    });
  }
  function ef(a, b2, c2) {
    return { instance: a, listener: b2, currentTarget: c2 };
  }
  function oe$1(a, b2) {
    for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
      var e2 = a, f2 = e2.stateNode;
      5 === e2.tag && null !== f2 && (e2 = f2, f2 = Ob(a, c2), null != f2 && d2.unshift(ef(a, f2, e2)), f2 = Ob(a, b2), null != f2 && d2.push(ef(a, f2, e2)));
      a = a.return;
    }
    return d2;
  }
  function gf(a) {
    if (null === a)
      return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function hf(a, b2, c2, d2, e2) {
    for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
      var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
      if (null !== k2 && k2 === d2)
        break;
      5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Ob(c2, f2), null != k2 && g2.unshift(ef(c2, k2, h2))) : e2 || (k2 = Ob(c2, f2), null != k2 && g2.push(ef(c2, k2, h2))));
      c2 = c2.return;
    }
    0 !== g2.length && a.push({ event: b2, listeners: g2 });
  }
  function jf() {
  }
  var kf = null, lf = null;
  function mf(a, b2) {
    switch (a) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        return !!b2.autoFocus;
    }
    return false;
  }
  function nf(a, b2) {
    return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
  }
  var of = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
  function qf(a) {
    1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
  }
  function rf(a) {
    for (; null != a; a = a.nextSibling) {
      var b2 = a.nodeType;
      if (1 === b2 || 3 === b2)
        break;
    }
    return a;
  }
  function sf(a) {
    a = a.previousSibling;
    for (var b2 = 0; a; ) {
      if (8 === a.nodeType) {
        var c2 = a.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b2)
            return a;
          b2--;
        } else
          "/$" === c2 && b2++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var tf = 0;
  function uf(a) {
    return { $$typeof: Ga, toString: a, valueOf: a };
  }
  var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
  function wc$1(a) {
    var b2 = a[wf];
    if (b2)
      return b2;
    for (var c2 = a.parentNode; c2; ) {
      if (b2 = c2[ff] || c2[wf]) {
        c2 = b2.alternate;
        if (null !== b2.child || null !== c2 && null !== c2.child)
          for (a = sf(a); null !== a; ) {
            if (c2 = a[wf])
              return c2;
            a = sf(a);
          }
        return b2;
      }
      a = c2;
      c2 = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[wf] || a[ff];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag)
      return a.stateNode;
    throw Error(y$2(33));
  }
  function Db(a) {
    return a[xf] || null;
  }
  function $e(a) {
    var b2 = a[yf];
    void 0 === b2 && (b2 = a[yf] = /* @__PURE__ */ new Set());
    return b2;
  }
  var zf = [], Af = -1;
  function Bf(a) {
    return { current: a };
  }
  function H$1(a) {
    0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
  }
  function I$1(a, b2) {
    Af++;
    zf[Af] = a.current;
    a.current = b2;
  }
  var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
  function Ef(a, b2) {
    var c2 = a.type.contextTypes;
    if (!c2)
      return Cf;
    var d2 = a.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
      return d2.__reactInternalMemoizedMaskedChildContext;
    var e2 = {}, f2;
    for (f2 in c2)
      e2[f2] = b2[f2];
    d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
    return e2;
  }
  function Ff(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function Gf() {
    H$1(N);
    H$1(M);
  }
  function Hf(a, b2, c2) {
    if (M.current !== Cf)
      throw Error(y$2(168));
    I$1(M, b2);
    I$1(N, c2);
  }
  function If(a, b2, c2) {
    var d2 = a.stateNode;
    a = b2.childContextTypes;
    if ("function" !== typeof d2.getChildContext)
      return c2;
    d2 = d2.getChildContext();
    for (var e2 in d2)
      if (!(e2 in a))
        throw Error(y$2(108, Ra$1(b2) || "Unknown", e2));
    return m$1({}, c2, d2);
  }
  function Jf(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
    Df = M.current;
    I$1(M, a);
    I$1(N, N.current);
    return true;
  }
  function Kf(a, b2, c2) {
    var d2 = a.stateNode;
    if (!d2)
      throw Error(y$2(169));
    c2 ? (a = If(a, b2, Df), d2.__reactInternalMemoizedMergedChildContext = a, H$1(N), H$1(M), I$1(M, a)) : H$1(N);
    I$1(N, c2);
  }
  var Lf = null, Mf = null, Nf = r$2.unstable_runWithPriority, Of = r$2.unstable_scheduleCallback, Pf = r$2.unstable_cancelCallback, Qf = r$2.unstable_shouldYield, Rf = r$2.unstable_requestPaint, Sf = r$2.unstable_now, Tf = r$2.unstable_getCurrentPriorityLevel, Uf = r$2.unstable_ImmediatePriority, Vf = r$2.unstable_UserBlockingPriority, Wf = r$2.unstable_NormalPriority, Xf = r$2.unstable_LowPriority, Yf = r$2.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
  }, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {
    return Sf() - dg;
  };
  function eg() {
    switch (Tf()) {
      case Uf:
        return 99;
      case Vf:
        return 98;
      case Wf:
        return 97;
      case Xf:
        return 96;
      case Yf:
        return 95;
      default:
        throw Error(y$2(332));
    }
  }
  function fg(a) {
    switch (a) {
      case 99:
        return Uf;
      case 98:
        return Vf;
      case 97:
        return Wf;
      case 96:
        return Xf;
      case 95:
        return Yf;
      default:
        throw Error(y$2(332));
    }
  }
  function gg(a, b2) {
    a = fg(a);
    return Nf(a, b2);
  }
  function hg(a, b2, c2) {
    a = fg(a);
    return Of(a, b2, c2);
  }
  function ig() {
    if (null !== bg) {
      var a = bg;
      bg = null;
      Pf(a);
    }
    jg();
  }
  function jg() {
    if (!cg && null !== ag) {
      cg = true;
      var a = 0;
      try {
        var b2 = ag;
        gg(99, function() {
          for (; a < b2.length; a++) {
            var c2 = b2[a];
            do
              c2 = c2(true);
            while (null !== c2);
          }
        });
        ag = null;
      } catch (c2) {
        throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c2;
      } finally {
        cg = false;
      }
    }
  }
  var kg = ra$1.ReactCurrentBatchConfig;
  function lg(a, b2) {
    if (a && a.defaultProps) {
      b2 = m$1({}, b2);
      a = a.defaultProps;
      for (var c2 in a)
        void 0 === b2[c2] && (b2[c2] = a[c2]);
      return b2;
    }
    return b2;
  }
  var mg = Bf(null), ng = null, og = null, pg = null;
  function qg() {
    pg = og = ng = null;
  }
  function rg(a) {
    var b2 = mg.current;
    H$1(mg);
    a.type._context._currentValue = b2;
  }
  function sg(a, b2) {
    for (; null !== a; ) {
      var c2 = a.alternate;
      if ((a.childLanes & b2) === b2)
        if (null === c2 || (c2.childLanes & b2) === b2)
          break;
        else
          c2.childLanes |= b2;
      else
        a.childLanes |= b2, null !== c2 && (c2.childLanes |= b2);
      a = a.return;
    }
  }
  function tg(a, b2) {
    ng = a;
    pg = og = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (ug = true), a.firstContext = null);
  }
  function vg(a, b2) {
    if (pg !== a && false !== b2 && 0 !== b2) {
      if ("number" !== typeof b2 || 1073741823 === b2)
        pg = a, b2 = 1073741823;
      b2 = { context: a, observedBits: b2, next: null };
      if (null === og) {
        if (null === ng)
          throw Error(y$2(308));
        og = b2;
        ng.dependencies = { lanes: 0, firstContext: b2, responders: null };
      } else
        og = og.next = b2;
    }
    return a._currentValue;
  }
  var wg = false;
  function xg(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
  }
  function yg(a, b2) {
    a = a.updateQueue;
    b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function zg(a, b2) {
    return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
  }
  function Ag(a, b2) {
    a = a.updateQueue;
    if (null !== a) {
      a = a.shared;
      var c2 = a.pending;
      null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
      a.pending = b2;
    }
  }
  function Bg(a, b2) {
    var c2 = a.updateQueue, d2 = a.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
      var e2 = null, f2 = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
          c2 = c2.next;
        } while (null !== c2);
        null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
      } else
        e2 = f2 = b2;
      c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
      a.updateQueue = c2;
      return;
    }
    a = c2.lastBaseUpdate;
    null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
    c2.lastBaseUpdate = b2;
  }
  function Cg(a, b2, c2, d2) {
    var e2 = a.updateQueue;
    wg = false;
    var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
    if (null !== h2) {
      e2.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null;
      null === g2 ? f2 = l2 : g2.next = l2;
      g2 = k2;
      var n2 = a.alternate;
      if (null !== n2) {
        n2 = n2.updateQueue;
        var A2 = n2.lastBaseUpdate;
        A2 !== g2 && (null === A2 ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k2);
      }
    }
    if (null !== f2) {
      A2 = e2.baseState;
      g2 = 0;
      n2 = l2 = k2 = null;
      do {
        h2 = f2.lane;
        var p2 = f2.eventTime;
        if ((d2 & h2) === h2) {
          null !== n2 && (n2 = n2.next = {
            eventTime: p2,
            lane: 0,
            tag: f2.tag,
            payload: f2.payload,
            callback: f2.callback,
            next: null
          });
          a: {
            var C2 = a, x2 = f2;
            h2 = b2;
            p2 = c2;
            switch (x2.tag) {
              case 1:
                C2 = x2.payload;
                if ("function" === typeof C2) {
                  A2 = C2.call(p2, A2, h2);
                  break a;
                }
                A2 = C2;
                break a;
              case 3:
                C2.flags = C2.flags & -4097 | 64;
              case 0:
                C2 = x2.payload;
                h2 = "function" === typeof C2 ? C2.call(p2, A2, h2) : C2;
                if (null === h2 || void 0 === h2)
                  break a;
                A2 = m$1({}, A2, h2);
                break a;
              case 2:
                wg = true;
            }
          }
          null !== f2.callback && (a.flags |= 32, h2 = e2.effects, null === h2 ? e2.effects = [f2] : h2.push(f2));
        } else
          p2 = { eventTime: p2, lane: h2, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null }, null === n2 ? (l2 = n2 = p2, k2 = A2) : n2 = n2.next = p2, g2 |= h2;
        f2 = f2.next;
        if (null === f2)
          if (h2 = e2.shared.pending, null === h2)
            break;
          else
            f2 = h2.next, h2.next = null, e2.lastBaseUpdate = h2, e2.shared.pending = null;
      } while (1);
      null === n2 && (k2 = A2);
      e2.baseState = k2;
      e2.firstBaseUpdate = l2;
      e2.lastBaseUpdate = n2;
      Dg |= g2;
      a.lanes = g2;
      a.memoizedState = A2;
    }
  }
  function Eg(a, b2, c2) {
    a = b2.effects;
    b2.effects = null;
    if (null !== a)
      for (b2 = 0; b2 < a.length; b2++) {
        var d2 = a[b2], e2 = d2.callback;
        if (null !== e2) {
          d2.callback = null;
          d2 = c2;
          if ("function" !== typeof e2)
            throw Error(y$2(191, e2));
          e2.call(d2);
        }
      }
  }
  var Fg = new aa$1.Component().refs;
  function Gg(a, b2, c2, d2) {
    b2 = a.memoizedState;
    c2 = c2(d2, b2);
    c2 = null === c2 || void 0 === c2 ? b2 : m$1({}, b2, c2);
    a.memoizedState = c2;
    0 === a.lanes && (a.updateQueue.baseState = c2);
  }
  var Kg = { isMounted: function(a) {
    return (a = a._reactInternals) ? Zb(a) === a : false;
  }, enqueueSetState: function(a, b2, c2) {
    a = a._reactInternals;
    var d2 = Hg(), e2 = Ig(a), f2 = zg(d2, e2);
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    Ag(a, f2);
    Jg(a, e2, d2);
  }, enqueueReplaceState: function(a, b2, c2) {
    a = a._reactInternals;
    var d2 = Hg(), e2 = Ig(a), f2 = zg(d2, e2);
    f2.tag = 1;
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    Ag(a, f2);
    Jg(a, e2, d2);
  }, enqueueForceUpdate: function(a, b2) {
    a = a._reactInternals;
    var c2 = Hg(), d2 = Ig(a), e2 = zg(c2, d2);
    e2.tag = 2;
    void 0 !== b2 && null !== b2 && (e2.callback = b2);
    Ag(a, e2);
    Jg(a, d2, c2);
  } };
  function Lg(a, b2, c2, d2, e2, f2, g2) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Je(c2, d2) || !Je(e2, f2) : true;
  }
  function Mg(a, b2, c2) {
    var d2 = false, e2 = Cf;
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = vg(f2) : (e2 = Ff(b2) ? Df : M.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Ef(a, e2) : Cf);
    b2 = new b2(c2, f2);
    a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
    b2.updater = Kg;
    a.stateNode = b2;
    b2._reactInternals = a;
    d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
    return b2;
  }
  function Ng(a, b2, c2, d2) {
    a = b2.state;
    "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
    "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
    b2.state !== a && Kg.enqueueReplaceState(b2, b2.state, null);
  }
  function Og(a, b2, c2, d2) {
    var e2 = a.stateNode;
    e2.props = c2;
    e2.state = a.memoizedState;
    e2.refs = Fg;
    xg(a);
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? e2.context = vg(f2) : (f2 = Ff(b2) ? Df : M.current, e2.context = Ef(a, f2));
    Cg(a, c2, e2, d2);
    e2.state = a.memoizedState;
    f2 = b2.getDerivedStateFromProps;
    "function" === typeof f2 && (Gg(a, b2, f2, c2), e2.state = a.memoizedState);
    "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Kg.enqueueReplaceState(e2, e2.state, null), Cg(a, c2, e2, d2), e2.state = a.memoizedState);
    "function" === typeof e2.componentDidMount && (a.flags |= 4);
  }
  var Pg = Array.isArray;
  function Qg(a, b2, c2) {
    a = c2.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag)
            throw Error(y$2(309));
          var d2 = c2.stateNode;
        }
        if (!d2)
          throw Error(y$2(147, a));
        var e2 = "" + a;
        if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === e2)
          return b2.ref;
        b2 = function(a2) {
          var b3 = d2.refs;
          b3 === Fg && (b3 = d2.refs = {});
          null === a2 ? delete b3[e2] : b3[e2] = a2;
        };
        b2._stringRef = e2;
        return b2;
      }
      if ("string" !== typeof a)
        throw Error(y$2(284));
      if (!c2._owner)
        throw Error(y$2(290, a));
    }
    return a;
  }
  function Rg(a, b2) {
    if ("textarea" !== a.type)
      throw Error(y$2(31, "[object Object]" === Object.prototype.toString.call(b2) ? "object with keys {" + Object.keys(b2).join(", ") + "}" : b2));
  }
  function Sg(a) {
    function b2(b3, c3) {
      if (a) {
        var d3 = b3.lastEffect;
        null !== d3 ? (d3.nextEffect = c3, b3.lastEffect = c3) : b3.firstEffect = b3.lastEffect = c3;
        c3.nextEffect = null;
        c3.flags = 8;
      }
    }
    function c2(c3, d3) {
      if (!a)
        return null;
      for (; null !== d3; )
        b2(c3, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a2, b3) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
        null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
      return a2;
    }
    function e2(a2, b3) {
      a2 = Tg(a2, b3);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f2(b3, c3, d3) {
      b3.index = d3;
      if (!a)
        return c3;
      d3 = b3.alternate;
      if (null !== d3)
        return d3 = d3.index, d3 < c3 ? (b3.flags = 2, c3) : d3;
      b3.flags = 2;
      return c3;
    }
    function g2(b3) {
      a && null === b3.alternate && (b3.flags = 2);
      return b3;
    }
    function h2(a2, b3, c3, d3) {
      if (null === b3 || 6 !== b3.tag)
        return b3 = Ug(c3, a2.mode, d3), b3.return = a2, b3;
      b3 = e2(b3, c3);
      b3.return = a2;
      return b3;
    }
    function k2(a2, b3, c3, d3) {
      if (null !== b3 && b3.elementType === c3.type)
        return d3 = e2(b3, c3.props), d3.ref = Qg(a2, b3, c3), d3.return = a2, d3;
      d3 = Vg(c3.type, c3.key, c3.props, null, a2.mode, d3);
      d3.ref = Qg(a2, b3, c3);
      d3.return = a2;
      return d3;
    }
    function l2(a2, b3, c3, d3) {
      if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
        return b3 = Wg(c3, a2.mode, d3), b3.return = a2, b3;
      b3 = e2(b3, c3.children || []);
      b3.return = a2;
      return b3;
    }
    function n2(a2, b3, c3, d3, f3) {
      if (null === b3 || 7 !== b3.tag)
        return b3 = Xg(c3, a2.mode, d3, f3), b3.return = a2, b3;
      b3 = e2(b3, c3);
      b3.return = a2;
      return b3;
    }
    function A2(a2, b3, c3) {
      if ("string" === typeof b3 || "number" === typeof b3)
        return b3 = Ug("" + b3, a2.mode, c3), b3.return = a2, b3;
      if ("object" === typeof b3 && null !== b3) {
        switch (b3.$$typeof) {
          case sa$1:
            return c3 = Vg(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = Qg(a2, null, b3), c3.return = a2, c3;
          case ta$1:
            return b3 = Wg(b3, a2.mode, c3), b3.return = a2, b3;
        }
        if (Pg(b3) || La$1(b3))
          return b3 = Xg(
            b3,
            a2.mode,
            c3,
            null
          ), b3.return = a2, b3;
        Rg(a2, b3);
      }
      return null;
    }
    function p2(a2, b3, c3, d3) {
      var e3 = null !== b3 ? b3.key : null;
      if ("string" === typeof c3 || "number" === typeof c3)
        return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case sa$1:
            return c3.key === e3 ? c3.type === ua$1 ? n2(a2, b3, c3.props.children, d3, e3) : k2(a2, b3, c3, d3) : null;
          case ta$1:
            return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
        }
        if (Pg(c3) || La$1(c3))
          return null !== e3 ? null : n2(a2, b3, c3, d3, null);
        Rg(a2, c3);
      }
      return null;
    }
    function C2(a2, b3, c3, d3, e3) {
      if ("string" === typeof d3 || "number" === typeof d3)
        return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case sa$1:
            return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, d3.type === ua$1 ? n2(b3, a2, d3.props.children, e3, d3.key) : k2(b3, a2, d3, e3);
          case ta$1:
            return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
        }
        if (Pg(d3) || La$1(d3))
          return a2 = a2.get(c3) || null, n2(b3, a2, d3, e3, null);
        Rg(b3, d3);
      }
      return null;
    }
    function x2(e3, g3, h3, k3) {
      for (var l3 = null, t2 = null, u2 = g3, z2 = g3 = 0, q2 = null; null !== u2 && z2 < h3.length; z2++) {
        u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
        var n3 = p2(e3, u2, h3[z2], k3);
        if (null === n3) {
          null === u2 && (u2 = q2);
          break;
        }
        a && u2 && null === n3.alternate && b2(e3, u2);
        g3 = f2(n3, g3, z2);
        null === t2 ? l3 = n3 : t2.sibling = n3;
        t2 = n3;
        u2 = q2;
      }
      if (z2 === h3.length)
        return c2(e3, u2), l3;
      if (null === u2) {
        for (; z2 < h3.length; z2++)
          u2 = A2(e3, h3[z2], k3), null !== u2 && (g3 = f2(u2, g3, z2), null === t2 ? l3 = u2 : t2.sibling = u2, t2 = u2);
        return l3;
      }
      for (u2 = d2(e3, u2); z2 < h3.length; z2++)
        q2 = C2(u2, e3, z2, h3[z2], k3), null !== q2 && (a && null !== q2.alternate && u2.delete(null === q2.key ? z2 : q2.key), g3 = f2(q2, g3, z2), null === t2 ? l3 = q2 : t2.sibling = q2, t2 = q2);
      a && u2.forEach(function(a2) {
        return b2(e3, a2);
      });
      return l3;
    }
    function w2(e3, g3, h3, k3) {
      var l3 = La$1(h3);
      if ("function" !== typeof l3)
        throw Error(y$2(150));
      h3 = l3.call(h3);
      if (null == h3)
        throw Error(y$2(151));
      for (var t2 = l3 = null, u2 = g3, z2 = g3 = 0, q2 = null, n3 = h3.next(); null !== u2 && !n3.done; z2++, n3 = h3.next()) {
        u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
        var w3 = p2(e3, u2, n3.value, k3);
        if (null === w3) {
          null === u2 && (u2 = q2);
          break;
        }
        a && u2 && null === w3.alternate && b2(e3, u2);
        g3 = f2(w3, g3, z2);
        null === t2 ? l3 = w3 : t2.sibling = w3;
        t2 = w3;
        u2 = q2;
      }
      if (n3.done)
        return c2(e3, u2), l3;
      if (null === u2) {
        for (; !n3.done; z2++, n3 = h3.next())
          n3 = A2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
        return l3;
      }
      for (u2 = d2(e3, u2); !n3.done; z2++, n3 = h3.next())
        n3 = C2(u2, e3, z2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && u2.delete(null === n3.key ? z2 : n3.key), g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
      a && u2.forEach(function(a2) {
        return b2(e3, a2);
      });
      return l3;
    }
    return function(a2, d3, f3, h3) {
      var k3 = "object" === typeof f3 && null !== f3 && f3.type === ua$1 && null === f3.key;
      k3 && (f3 = f3.props.children);
      var l3 = "object" === typeof f3 && null !== f3;
      if (l3)
        switch (f3.$$typeof) {
          case sa$1:
            a: {
              l3 = f3.key;
              for (k3 = d3; null !== k3; ) {
                if (k3.key === l3) {
                  switch (k3.tag) {
                    case 7:
                      if (f3.type === ua$1) {
                        c2(a2, k3.sibling);
                        d3 = e2(k3, f3.props.children);
                        d3.return = a2;
                        a2 = d3;
                        break a;
                      }
                      break;
                    default:
                      if (k3.elementType === f3.type) {
                        c2(a2, k3.sibling);
                        d3 = e2(k3, f3.props);
                        d3.ref = Qg(a2, k3, f3);
                        d3.return = a2;
                        a2 = d3;
                        break a;
                      }
                  }
                  c2(a2, k3);
                  break;
                } else
                  b2(a2, k3);
                k3 = k3.sibling;
              }
              f3.type === ua$1 ? (d3 = Xg(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Vg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Qg(a2, d3, f3), h3.return = a2, a2 = h3);
            }
            return g2(a2);
          case ta$1:
            a: {
              for (k3 = f3.key; null !== d3; ) {
                if (d3.key === k3)
                  if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                    c2(a2, d3.sibling);
                    d3 = e2(d3, f3.children || []);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  } else {
                    c2(a2, d3);
                    break;
                  }
                else
                  b2(a2, d3);
                d3 = d3.sibling;
              }
              d3 = Wg(f3, a2.mode, h3);
              d3.return = a2;
              a2 = d3;
            }
            return g2(a2);
        }
      if ("string" === typeof f3 || "number" === typeof f3)
        return f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = Ug(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2);
      if (Pg(f3))
        return x2(a2, d3, f3, h3);
      if (La$1(f3))
        return w2(a2, d3, f3, h3);
      l3 && Rg(a2, f3);
      if ("undefined" === typeof f3 && !k3)
        switch (a2.tag) {
          case 1:
          case 22:
          case 0:
          case 11:
          case 15:
            throw Error(y$2(152, Ra$1(a2.type) || "Component"));
        }
      return c2(a2, d3);
    };
  }
  var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
  function dh(a) {
    if (a === $g)
      throw Error(y$2(174));
    return a;
  }
  function eh(a, b2) {
    I$1(ch, b2);
    I$1(bh, a);
    I$1(ah, $g);
    a = b2.nodeType;
    switch (a) {
      case 9:
      case 11:
        b2 = (b2 = b2.documentElement) ? b2.namespaceURI : mb(null, "");
        break;
      default:
        a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = mb(b2, a);
    }
    H$1(ah);
    I$1(ah, b2);
  }
  function fh() {
    H$1(ah);
    H$1(bh);
    H$1(ch);
  }
  function gh(a) {
    dh(ch.current);
    var b2 = dh(ah.current);
    var c2 = mb(b2, a.type);
    b2 !== c2 && (I$1(bh, a), I$1(ah, c2));
  }
  function hh(a) {
    bh.current === a && (H$1(ah), H$1(bh));
  }
  var P = Bf(0);
  function ih(a) {
    for (var b2 = a; null !== b2; ) {
      if (13 === b2.tag) {
        var c2 = b2.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
          return b2;
      } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
        if (0 !== (b2.flags & 64))
          return b2;
      } else if (null !== b2.child) {
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
      if (b2 === a)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a)
          return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
    return null;
  }
  var jh = null, kh = null, lh = false;
  function mh(a, b2) {
    var c2 = nh(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.type = "DELETED";
    c2.stateNode = b2;
    c2.return = a;
    c2.flags = 8;
    null !== a.lastEffect ? (a.lastEffect.nextEffect = c2, a.lastEffect = c2) : a.firstEffect = a.lastEffect = c2;
  }
  function oh(a, b2) {
    switch (a.tag) {
      case 5:
        var c2 = a.type;
        b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
        return null !== b2 ? (a.stateNode = b2, true) : false;
      case 6:
        return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, true) : false;
      case 13:
        return false;
      default:
        return false;
    }
  }
  function ph(a) {
    if (lh) {
      var b2 = kh;
      if (b2) {
        var c2 = b2;
        if (!oh(a, b2)) {
          b2 = rf(c2.nextSibling);
          if (!b2 || !oh(a, b2)) {
            a.flags = a.flags & -1025 | 2;
            lh = false;
            jh = a;
            return;
          }
          mh(jh, c2);
        }
        jh = a;
        kh = rf(b2.firstChild);
      } else
        a.flags = a.flags & -1025 | 2, lh = false, jh = a;
    }
  }
  function qh(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
      a = a.return;
    jh = a;
  }
  function rh(a) {
    if (a !== jh)
      return false;
    if (!lh)
      return qh(a), lh = true, false;
    var b2 = a.type;
    if (5 !== a.tag || "head" !== b2 && "body" !== b2 && !nf(b2, a.memoizedProps))
      for (b2 = kh; b2; )
        mh(a, b2), b2 = rf(b2.nextSibling);
    qh(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a)
        throw Error(y$2(317));
      a: {
        a = a.nextSibling;
        for (b2 = 0; a; ) {
          if (8 === a.nodeType) {
            var c2 = a.data;
            if ("/$" === c2) {
              if (0 === b2) {
                kh = rf(a.nextSibling);
                break a;
              }
              b2--;
            } else
              "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
          }
          a = a.nextSibling;
        }
        kh = null;
      }
    } else
      kh = jh ? rf(a.stateNode.nextSibling) : null;
    return true;
  }
  function sh() {
    kh = jh = null;
    lh = false;
  }
  var th = [];
  function uh() {
    for (var a = 0; a < th.length; a++)
      th[a]._workInProgressVersionPrimary = null;
    th.length = 0;
  }
  var vh = ra$1.ReactCurrentDispatcher, wh = ra$1.ReactCurrentBatchConfig, xh = 0, R = null, S = null, T = null, yh = false, zh = false;
  function Ah() {
    throw Error(y$2(321));
  }
  function Bh(a, b2) {
    if (null === b2)
      return false;
    for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
      if (!He(a[c2], b2[c2]))
        return false;
    return true;
  }
  function Ch(a, b2, c2, d2, e2, f2) {
    xh = f2;
    R = b2;
    b2.memoizedState = null;
    b2.updateQueue = null;
    b2.lanes = 0;
    vh.current = null === a || null === a.memoizedState ? Dh : Eh;
    a = c2(d2, e2);
    if (zh) {
      f2 = 0;
      do {
        zh = false;
        if (!(25 > f2))
          throw Error(y$2(301));
        f2 += 1;
        T = S = null;
        b2.updateQueue = null;
        vh.current = Fh;
        a = c2(d2, e2);
      } while (zh);
    }
    vh.current = Gh;
    b2 = null !== S && null !== S.next;
    xh = 0;
    T = S = R = null;
    yh = false;
    if (b2)
      throw Error(y$2(300));
    return a;
  }
  function Hh() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === T ? R.memoizedState = T = a : T = T.next = a;
    return T;
  }
  function Ih() {
    if (null === S) {
      var a = R.alternate;
      a = null !== a ? a.memoizedState : null;
    } else
      a = S.next;
    var b2 = null === T ? R.memoizedState : T.next;
    if (null !== b2)
      T = b2, S = a;
    else {
      if (null === a)
        throw Error(y$2(310));
      S = a;
      a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
      null === T ? R.memoizedState = T = a : T = T.next = a;
    }
    return T;
  }
  function Jh(a, b2) {
    return "function" === typeof b2 ? b2(a) : b2;
  }
  function Kh(a) {
    var b2 = Ih(), c2 = b2.queue;
    if (null === c2)
      throw Error(y$2(311));
    c2.lastRenderedReducer = a;
    var d2 = S, e2 = d2.baseQueue, f2 = c2.pending;
    if (null !== f2) {
      if (null !== e2) {
        var g2 = e2.next;
        e2.next = f2.next;
        f2.next = g2;
      }
      d2.baseQueue = e2 = f2;
      c2.pending = null;
    }
    if (null !== e2) {
      e2 = e2.next;
      d2 = d2.baseState;
      var h2 = g2 = f2 = null, k2 = e2;
      do {
        var l2 = k2.lane;
        if ((xh & l2) === l2)
          null !== h2 && (h2 = h2.next = { lane: 0, action: k2.action, eagerReducer: k2.eagerReducer, eagerState: k2.eagerState, next: null }), d2 = k2.eagerReducer === a ? k2.eagerState : a(d2, k2.action);
        else {
          var n2 = {
            lane: l2,
            action: k2.action,
            eagerReducer: k2.eagerReducer,
            eagerState: k2.eagerState,
            next: null
          };
          null === h2 ? (g2 = h2 = n2, f2 = d2) : h2 = h2.next = n2;
          R.lanes |= l2;
          Dg |= l2;
        }
        k2 = k2.next;
      } while (null !== k2 && k2 !== e2);
      null === h2 ? f2 = d2 : h2.next = g2;
      He(d2, b2.memoizedState) || (ug = true);
      b2.memoizedState = d2;
      b2.baseState = f2;
      b2.baseQueue = h2;
      c2.lastRenderedState = d2;
    }
    return [b2.memoizedState, c2.dispatch];
  }
  function Lh(a) {
    var b2 = Ih(), c2 = b2.queue;
    if (null === c2)
      throw Error(y$2(311));
    c2.lastRenderedReducer = a;
    var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
    if (null !== e2) {
      c2.pending = null;
      var g2 = e2 = e2.next;
      do
        f2 = a(f2, g2.action), g2 = g2.next;
      while (g2 !== e2);
      He(f2, b2.memoizedState) || (ug = true);
      b2.memoizedState = f2;
      null === b2.baseQueue && (b2.baseState = f2);
      c2.lastRenderedState = f2;
    }
    return [f2, d2];
  }
  function Mh(a, b2, c2) {
    var d2 = b2._getVersion;
    d2 = d2(b2._source);
    var e2 = b2._workInProgressVersionPrimary;
    if (null !== e2)
      a = e2 === d2;
    else if (a = a.mutableReadLanes, a = (xh & a) === a)
      b2._workInProgressVersionPrimary = d2, th.push(b2);
    if (a)
      return c2(b2._source);
    th.push(b2);
    throw Error(y$2(350));
  }
  function Nh(a, b2, c2, d2) {
    var e2 = U;
    if (null === e2)
      throw Error(y$2(349));
    var f2 = b2._getVersion, g2 = f2(b2._source), h2 = vh.current, k2 = h2.useState(function() {
      return Mh(e2, b2, c2);
    }), l2 = k2[1], n2 = k2[0];
    k2 = T;
    var A2 = a.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
    A2 = A2.subscribe;
    var w2 = R;
    a.memoizedState = { refs: p2, source: b2, subscribe: d2 };
    h2.useEffect(function() {
      p2.getSnapshot = c2;
      p2.setSnapshot = l2;
      var a2 = f2(b2._source);
      if (!He(g2, a2)) {
        a2 = c2(b2._source);
        He(n2, a2) || (l2(a2), a2 = Ig(w2), e2.mutableReadLanes |= a2 & e2.pendingLanes);
        a2 = e2.mutableReadLanes;
        e2.entangledLanes |= a2;
        for (var d3 = e2.entanglements, h3 = a2; 0 < h3; ) {
          var k3 = 31 - Vc$1(h3), v2 = 1 << k3;
          d3[k3] |= a2;
          h3 &= ~v2;
        }
      }
    }, [c2, b2, d2]);
    h2.useEffect(function() {
      return d2(b2._source, function() {
        var a2 = p2.getSnapshot, c3 = p2.setSnapshot;
        try {
          c3(a2(b2._source));
          var d3 = Ig(w2);
          e2.mutableReadLanes |= d3 & e2.pendingLanes;
        } catch (q2) {
          c3(function() {
            throw q2;
          });
        }
      });
    }, [b2, d2]);
    He(C2, c2) && He(x2, b2) && He(A2, d2) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a.dispatch = l2 = Oh.bind(null, R, a), k2.queue = a, k2.baseQueue = null, n2 = Mh(e2, b2, c2), k2.memoizedState = k2.baseState = n2);
    return n2;
  }
  function Ph(a, b2, c2) {
    var d2 = Ih();
    return Nh(d2, a, b2, c2);
  }
  function Qh(a) {
    var b2 = Hh();
    "function" === typeof a && (a = a());
    b2.memoizedState = b2.baseState = a;
    a = b2.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
    a = a.dispatch = Oh.bind(null, R, a);
    return [b2.memoizedState, a];
  }
  function Rh(a, b2, c2, d2) {
    a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
    b2 = R.updateQueue;
    null === b2 ? (b2 = { lastEffect: null }, R.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
    return a;
  }
  function Sh(a) {
    var b2 = Hh();
    a = { current: a };
    return b2.memoizedState = a;
  }
  function Th() {
    return Ih().memoizedState;
  }
  function Uh(a, b2, c2, d2) {
    var e2 = Hh();
    R.flags |= a;
    e2.memoizedState = Rh(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
  }
  function Vh(a, b2, c2, d2) {
    var e2 = Ih();
    d2 = void 0 === d2 ? null : d2;
    var f2 = void 0;
    if (null !== S) {
      var g2 = S.memoizedState;
      f2 = g2.destroy;
      if (null !== d2 && Bh(d2, g2.deps)) {
        Rh(b2, c2, f2, d2);
        return;
      }
    }
    R.flags |= a;
    e2.memoizedState = Rh(1 | b2, c2, f2, d2);
  }
  function Wh(a, b2) {
    return Uh(516, 4, a, b2);
  }
  function Xh(a, b2) {
    return Vh(516, 4, a, b2);
  }
  function Yh(a, b2) {
    return Vh(4, 2, a, b2);
  }
  function Zh(a, b2) {
    if ("function" === typeof b2)
      return a = a(), b2(a), function() {
        b2(null);
      };
    if (null !== b2 && void 0 !== b2)
      return a = a(), b2.current = a, function() {
        b2.current = null;
      };
  }
  function $h(a, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
    return Vh(4, 2, Zh.bind(null, b2, a), c2);
  }
  function ai() {
  }
  function bi$1(a, b2) {
    var c2 = Ih();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Bh(b2, d2[1]))
      return d2[0];
    c2.memoizedState = [a, b2];
    return a;
  }
  function ci(a, b2) {
    var c2 = Ih();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Bh(b2, d2[1]))
      return d2[0];
    a = a();
    c2.memoizedState = [a, b2];
    return a;
  }
  function di(a, b2) {
    var c2 = eg();
    gg(98 > c2 ? 98 : c2, function() {
      a(true);
    });
    gg(97 < c2 ? 97 : c2, function() {
      var c3 = wh.transition;
      wh.transition = 1;
      try {
        a(false), b2();
      } finally {
        wh.transition = c3;
      }
    });
  }
  function Oh(a, b2, c2) {
    var d2 = Hg(), e2 = Ig(a), f2 = { lane: e2, action: c2, eagerReducer: null, eagerState: null, next: null }, g2 = b2.pending;
    null === g2 ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
    b2.pending = f2;
    g2 = a.alternate;
    if (a === R || null !== g2 && g2 === R)
      zh = yh = true;
    else {
      if (0 === a.lanes && (null === g2 || 0 === g2.lanes) && (g2 = b2.lastRenderedReducer, null !== g2))
        try {
          var h2 = b2.lastRenderedState, k2 = g2(h2, c2);
          f2.eagerReducer = g2;
          f2.eagerState = k2;
          if (He(k2, h2))
            return;
        } catch (l2) {
        } finally {
        }
      Jg(a, e2, d2);
    }
  }
  var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a, b2) {
    Hh().memoizedState = [a, void 0 === b2 ? null : b2];
    return a;
  }, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
    return Uh(4, 2, Zh.bind(
      null,
      b2,
      a
    ), c2);
  }, useLayoutEffect: function(a, b2) {
    return Uh(4, 2, a, b2);
  }, useMemo: function(a, b2) {
    var c2 = Hh();
    b2 = void 0 === b2 ? null : b2;
    a = a();
    c2.memoizedState = [a, b2];
    return a;
  }, useReducer: function(a, b2, c2) {
    var d2 = Hh();
    b2 = void 0 !== c2 ? c2(b2) : b2;
    d2.memoizedState = d2.baseState = b2;
    a = d2.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
    a = a.dispatch = Oh.bind(null, R, a);
    return [d2.memoizedState, a];
  }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
    var b2 = Qh(a), c2 = b2[0], d2 = b2[1];
    Wh(function() {
      var b3 = wh.transition;
      wh.transition = 1;
      try {
        d2(a);
      } finally {
        wh.transition = b3;
      }
    }, [a]);
    return c2;
  }, useTransition: function() {
    var a = Qh(false), b2 = a[0];
    a = di.bind(null, a[1]);
    Sh(a);
    return [a, b2];
  }, useMutableSource: function(a, b2, c2) {
    var d2 = Hh();
    d2.memoizedState = { refs: { getSnapshot: b2, setSnapshot: null }, source: a, subscribe: c2 };
    return Nh(d2, a, b2, c2);
  }, useOpaqueIdentifier: function() {
    if (lh) {
      var a = false, b2 = uf(function() {
        a || (a = true, c2("r:" + (tf++).toString(36)));
        throw Error(y$2(355));
      }), c2 = Qh(b2)[1];
      0 === (R.mode & 2) && (R.flags |= 516, Rh(
        5,
        function() {
          c2("r:" + (tf++).toString(36));
        },
        void 0,
        null
      ));
      return b2;
    }
    b2 = "r:" + (tf++).toString(36);
    Qh(b2);
    return b2;
  }, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi$1, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
    return Kh(Jh);
  }, useDebugValue: ai, useDeferredValue: function(a) {
    var b2 = Kh(Jh), c2 = b2[0], d2 = b2[1];
    Xh(function() {
      var b3 = wh.transition;
      wh.transition = 1;
      try {
        d2(a);
      } finally {
        wh.transition = b3;
      }
    }, [a]);
    return c2;
  }, useTransition: function() {
    var a = Kh(Jh)[0];
    return [
      Th().current,
      a
    ];
  }, useMutableSource: Ph, useOpaqueIdentifier: function() {
    return Kh(Jh)[0];
  }, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi$1, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
    return Lh(Jh);
  }, useDebugValue: ai, useDeferredValue: function(a) {
    var b2 = Lh(Jh), c2 = b2[0], d2 = b2[1];
    Xh(function() {
      var b3 = wh.transition;
      wh.transition = 1;
      try {
        d2(a);
      } finally {
        wh.transition = b3;
      }
    }, [a]);
    return c2;
  }, useTransition: function() {
    var a = Lh(Jh)[0];
    return [
      Th().current,
      a
    ];
  }, useMutableSource: Ph, useOpaqueIdentifier: function() {
    return Lh(Jh)[0];
  }, unstable_isNewReconciler: false }, ei = ra$1.ReactCurrentOwner, ug = false;
  function fi(a, b2, c2, d2) {
    b2.child = null === a ? Zg(b2, null, c2, d2) : Yg(b2, a.child, c2, d2);
  }
  function gi(a, b2, c2, d2, e2) {
    c2 = c2.render;
    var f2 = b2.ref;
    tg(b2, e2);
    d2 = Ch(a, b2, c2, d2, f2, e2);
    if (null !== a && !ug)
      return b2.updateQueue = a.updateQueue, b2.flags &= -517, a.lanes &= ~e2, hi(a, b2, e2);
    b2.flags |= 1;
    fi(a, b2, d2, e2);
    return b2.child;
  }
  function ii(a, b2, c2, d2, e2, f2) {
    if (null === a) {
      var g2 = c2.type;
      if ("function" === typeof g2 && !ji(g2) && void 0 === g2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
        return b2.tag = 15, b2.type = g2, ki(a, b2, g2, d2, e2, f2);
      a = Vg(c2.type, null, d2, b2, b2.mode, f2);
      a.ref = b2.ref;
      a.return = b2;
      return b2.child = a;
    }
    g2 = a.child;
    if (0 === (e2 & f2) && (e2 = g2.memoizedProps, c2 = c2.compare, c2 = null !== c2 ? c2 : Je, c2(e2, d2) && a.ref === b2.ref))
      return hi(a, b2, f2);
    b2.flags |= 1;
    a = Tg(g2, d2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  function ki(a, b2, c2, d2, e2, f2) {
    if (null !== a && Je(a.memoizedProps, d2) && a.ref === b2.ref)
      if (ug = false, 0 !== (f2 & e2))
        0 !== (a.flags & 16384) && (ug = true);
      else
        return b2.lanes = a.lanes, hi(a, b2, f2);
    return li(a, b2, c2, d2, f2);
  }
  function mi(a, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
    if ("hidden" === d2.mode || "unstable-defer-without-hiding" === d2.mode)
      if (0 === (b2.mode & 4))
        b2.memoizedState = { baseLanes: 0 }, ni(b2, c2);
      else if (0 !== (c2 & 1073741824))
        b2.memoizedState = { baseLanes: 0 }, ni(b2, null !== f2 ? f2.baseLanes : c2);
      else
        return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a }, ni(b2, a), null;
    else
      null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, ni(b2, d2);
    fi(a, b2, e2, c2);
    return b2.child;
  }
  function oi(a, b2) {
    var c2 = b2.ref;
    if (null === a && null !== c2 || null !== a && a.ref !== c2)
      b2.flags |= 128;
  }
  function li(a, b2, c2, d2, e2) {
    var f2 = Ff(c2) ? Df : M.current;
    f2 = Ef(b2, f2);
    tg(b2, e2);
    c2 = Ch(a, b2, c2, d2, f2, e2);
    if (null !== a && !ug)
      return b2.updateQueue = a.updateQueue, b2.flags &= -517, a.lanes &= ~e2, hi(a, b2, e2);
    b2.flags |= 1;
    fi(a, b2, c2, e2);
    return b2.child;
  }
  function pi(a, b2, c2, d2, e2) {
    if (Ff(c2)) {
      var f2 = true;
      Jf(b2);
    } else
      f2 = false;
    tg(b2, e2);
    if (null === b2.stateNode)
      null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2), Mg(b2, c2, d2), Og(b2, c2, d2, e2), d2 = true;
    else if (null === a) {
      var g2 = b2.stateNode, h2 = b2.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c2.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = vg(l2) : (l2 = Ff(c2) ? Df : M.current, l2 = Ef(b2, l2));
      var n2 = c2.getDerivedStateFromProps, A2 = "function" === typeof n2 || "function" === typeof g2.getSnapshotBeforeUpdate;
      A2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Ng(b2, g2, d2, l2);
      wg = false;
      var p2 = b2.memoizedState;
      g2.state = p2;
      Cg(b2, d2, g2, e2);
      k2 = b2.memoizedState;
      h2 !== d2 || p2 !== k2 || N.current || wg ? ("function" === typeof n2 && (Gg(b2, c2, n2, d2), k2 = b2.memoizedState), (h2 = wg || Lg(b2, c2, h2, d2, p2, k2, l2)) ? (A2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4), d2 = false);
    } else {
      g2 = b2.stateNode;
      yg(a, b2);
      h2 = b2.memoizedProps;
      l2 = b2.type === b2.elementType ? h2 : lg(b2.type, h2);
      g2.props = l2;
      A2 = b2.pendingProps;
      p2 = g2.context;
      k2 = c2.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = vg(k2) : (k2 = Ff(c2) ? Df : M.current, k2 = Ef(b2, k2));
      var C2 = c2.getDerivedStateFromProps;
      (n2 = "function" === typeof C2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== A2 || p2 !== k2) && Ng(b2, g2, d2, k2);
      wg = false;
      p2 = b2.memoizedState;
      g2.state = p2;
      Cg(b2, d2, g2, e2);
      var x2 = b2.memoizedState;
      h2 !== A2 || p2 !== x2 || N.current || wg ? ("function" === typeof C2 && (Gg(b2, c2, C2, d2), x2 = b2.memoizedState), (l2 = wg || Lg(b2, c2, l2, d2, p2, x2, k2)) ? (n2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(
        d2,
        x2,
        k2
      ), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, x2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 256)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && p2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && p2 === a.memoizedState || (b2.flags |= 256), b2.memoizedProps = d2, b2.memoizedState = x2), g2.props = d2, g2.state = x2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && p2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && p2 === a.memoizedState || (b2.flags |= 256), d2 = false);
    }
    return qi(a, b2, c2, d2, f2, e2);
  }
  function qi(a, b2, c2, d2, e2, f2) {
    oi(a, b2);
    var g2 = 0 !== (b2.flags & 64);
    if (!d2 && !g2)
      return e2 && Kf(b2, c2, false), hi(a, b2, f2);
    d2 = b2.stateNode;
    ei.current = b2;
    var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
    b2.flags |= 1;
    null !== a && g2 ? (b2.child = Yg(b2, a.child, null, f2), b2.child = Yg(b2, null, h2, f2)) : fi(a, b2, h2, f2);
    b2.memoizedState = d2.state;
    e2 && Kf(b2, c2, true);
    return b2.child;
  }
  function ri(a) {
    var b2 = a.stateNode;
    b2.pendingContext ? Hf(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && Hf(a, b2.context, false);
    eh(a, b2.containerInfo);
  }
  var si = { dehydrated: null, retryLane: 0 };
  function ti(a, b2, c2) {
    var d2 = b2.pendingProps, e2 = P.current, f2 = false, g2;
    (g2 = 0 !== (b2.flags & 64)) || (g2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
    g2 ? (f2 = true, b2.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d2.fallback || true === d2.unstable_avoidThisFallback || (e2 |= 1);
    I$1(P, e2 & 1);
    if (null === a) {
      void 0 !== d2.fallback && ph(b2);
      a = d2.children;
      e2 = d2.fallback;
      if (f2)
        return a = ui(b2, a, e2, c2), b2.child.memoizedState = { baseLanes: c2 }, b2.memoizedState = si, a;
      if ("number" === typeof d2.unstable_expectedLoadTime)
        return a = ui(b2, a, e2, c2), b2.child.memoizedState = { baseLanes: c2 }, b2.memoizedState = si, b2.lanes = 33554432, a;
      c2 = vi({ mode: "visible", children: a }, b2.mode, c2, null);
      c2.return = b2;
      return b2.child = c2;
    }
    if (null !== a.memoizedState) {
      if (f2)
        return d2 = wi(a, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c2 } : { baseLanes: e2.baseLanes | c2 }, f2.childLanes = a.childLanes & ~c2, b2.memoizedState = si, d2;
      c2 = xi(a, b2, d2.children, c2);
      b2.memoizedState = null;
      return c2;
    }
    if (f2)
      return d2 = wi(a, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c2 } : { baseLanes: e2.baseLanes | c2 }, f2.childLanes = a.childLanes & ~c2, b2.memoizedState = si, d2;
    c2 = xi(a, b2, d2.children, c2);
    b2.memoizedState = null;
    return c2;
  }
  function ui(a, b2, c2, d2) {
    var e2 = a.mode, f2 = a.child;
    b2 = { mode: "hidden", children: b2 };
    0 === (e2 & 2) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = b2) : f2 = vi(b2, e2, 0, null);
    c2 = Xg(c2, e2, d2, null);
    f2.return = a;
    c2.return = a;
    f2.sibling = c2;
    a.child = f2;
    return c2;
  }
  function xi(a, b2, c2, d2) {
    var e2 = a.child;
    a = e2.sibling;
    c2 = Tg(e2, { mode: "visible", children: c2 });
    0 === (b2.mode & 2) && (c2.lanes = d2);
    c2.return = b2;
    c2.sibling = null;
    null !== a && (a.nextEffect = null, a.flags = 8, b2.firstEffect = b2.lastEffect = a);
    return b2.child = c2;
  }
  function wi(a, b2, c2, d2, e2) {
    var f2 = b2.mode, g2 = a.child;
    a = g2.sibling;
    var h2 = { mode: "hidden", children: c2 };
    0 === (f2 & 2) && b2.child !== g2 ? (c2 = b2.child, c2.childLanes = 0, c2.pendingProps = h2, g2 = c2.lastEffect, null !== g2 ? (b2.firstEffect = c2.firstEffect, b2.lastEffect = g2, g2.nextEffect = null) : b2.firstEffect = b2.lastEffect = null) : c2 = Tg(g2, h2);
    null !== a ? d2 = Tg(a, d2) : (d2 = Xg(d2, f2, e2, null), d2.flags |= 2);
    d2.return = b2;
    c2.return = b2;
    c2.sibling = d2;
    b2.child = c2;
    return d2;
  }
  function yi(a, b2) {
    a.lanes |= b2;
    var c2 = a.alternate;
    null !== c2 && (c2.lanes |= b2);
    sg(a.return, b2);
  }
  function zi(a, b2, c2, d2, e2, f2) {
    var g2 = a.memoizedState;
    null === g2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2, lastEffect: f2 } : (g2.isBackwards = b2, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d2, g2.tail = c2, g2.tailMode = e2, g2.lastEffect = f2);
  }
  function Ai(a, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
    fi(a, b2, d2.children, c2);
    d2 = P.current;
    if (0 !== (d2 & 2))
      d2 = d2 & 1 | 2, b2.flags |= 64;
    else {
      if (null !== a && 0 !== (a.flags & 64))
        a:
          for (a = b2.child; null !== a; ) {
            if (13 === a.tag)
              null !== a.memoizedState && yi(a, c2);
            else if (19 === a.tag)
              yi(a, c2);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b2)
              break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b2)
                break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
      d2 &= 1;
    }
    I$1(P, d2);
    if (0 === (b2.mode & 2))
      b2.memoizedState = null;
    else
      switch (e2) {
        case "forwards":
          c2 = b2.child;
          for (e2 = null; null !== c2; )
            a = c2.alternate, null !== a && null === ih(a) && (e2 = c2), c2 = c2.sibling;
          c2 = e2;
          null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
          zi(b2, false, e2, c2, f2, b2.lastEffect);
          break;
        case "backwards":
          c2 = null;
          e2 = b2.child;
          for (b2.child = null; null !== e2; ) {
            a = e2.alternate;
            if (null !== a && null === ih(a)) {
              b2.child = e2;
              break;
            }
            a = e2.sibling;
            e2.sibling = c2;
            c2 = e2;
            e2 = a;
          }
          zi(b2, true, c2, null, f2, b2.lastEffect);
          break;
        case "together":
          zi(b2, false, null, null, void 0, b2.lastEffect);
          break;
        default:
          b2.memoizedState = null;
      }
    return b2.child;
  }
  function hi(a, b2, c2) {
    null !== a && (b2.dependencies = a.dependencies);
    Dg |= b2.lanes;
    if (0 !== (c2 & b2.childLanes)) {
      if (null !== a && b2.child !== a.child)
        throw Error(y$2(153));
      if (null !== b2.child) {
        a = b2.child;
        c2 = Tg(a, a.pendingProps);
        b2.child = c2;
        for (c2.return = b2; null !== a.sibling; )
          a = a.sibling, c2 = c2.sibling = Tg(a, a.pendingProps), c2.return = b2;
        c2.sibling = null;
      }
      return b2.child;
    }
    return null;
  }
  var Bi, Ci, Di, Ei$1;
  Bi = function(a, b2) {
    for (var c2 = b2.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag)
        a.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b2)
        break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b2)
          return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Ci = function() {
  };
  Di = function(a, b2, c2, d2) {
    var e2 = a.memoizedProps;
    if (e2 !== d2) {
      a = b2.stateNode;
      dh(ah.current);
      var f2 = null;
      switch (c2) {
        case "input":
          e2 = Ya(a, e2);
          d2 = Ya(a, d2);
          f2 = [];
          break;
        case "option":
          e2 = eb(a, e2);
          d2 = eb(a, d2);
          f2 = [];
          break;
        case "select":
          e2 = m$1({}, e2, { value: void 0 });
          d2 = m$1({}, d2, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e2 = gb(a, e2);
          d2 = gb(a, d2);
          f2 = [];
          break;
        default:
          "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = jf);
      }
      vb(c2, d2);
      var g2;
      c2 = null;
      for (l2 in e2)
        if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
          if ("style" === l2) {
            var h2 = e2[l2];
            for (g2 in h2)
              h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
          } else
            "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ca$1.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d2) {
        var k2 = d2[l2];
        h2 = null != e2 ? e2[l2] : void 0;
        if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
          if ("style" === l2)
            if (h2) {
              for (g2 in h2)
                !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
              for (g2 in k2)
                k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
            } else
              c2 || (f2 || (f2 = []), f2.push(l2, c2)), c2 = k2;
          else
            "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ca$1.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && G$2("scroll", a), f2 || h2 === k2 || (f2 = [])) : "object" === typeof k2 && null !== k2 && k2.$$typeof === Ga ? k2.toString() : (f2 = f2 || []).push(l2, k2));
      }
      c2 && (f2 = f2 || []).push(
        "style",
        c2
      );
      var l2 = f2;
      if (b2.updateQueue = l2)
        b2.flags |= 4;
    }
  };
  Ei$1 = function(a, b2, c2, d2) {
    c2 !== d2 && (b2.flags |= 4);
  };
  function Fi(a, b2) {
    if (!lh)
      switch (a.tailMode) {
        case "hidden":
          b2 = a.tail;
          for (var c2 = null; null !== b2; )
            null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
          null === c2 ? a.tail = null : c2.sibling = null;
          break;
        case "collapsed":
          c2 = a.tail;
          for (var d2 = null; null !== c2; )
            null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
          null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
      }
  }
  function Gi(a, b2, c2) {
    var d2 = b2.pendingProps;
    switch (b2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return null;
      case 1:
        return Ff(b2.type) && Gf(), null;
      case 3:
        fh();
        H$1(N);
        H$1(M);
        uh();
        d2 = b2.stateNode;
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a || null === a.child)
          rh(b2) ? b2.flags |= 4 : d2.hydrate || (b2.flags |= 256);
        Ci(b2);
        return null;
      case 5:
        hh(b2);
        var e2 = dh(ch.current);
        c2 = b2.type;
        if (null !== a && null != b2.stateNode)
          Di(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 128);
        else {
          if (!d2) {
            if (null === b2.stateNode)
              throw Error(y$2(166));
            return null;
          }
          a = dh(ah.current);
          if (rh(b2)) {
            d2 = b2.stateNode;
            c2 = b2.type;
            var f2 = b2.memoizedProps;
            d2[wf] = b2;
            d2[xf] = f2;
            switch (c2) {
              case "dialog":
                G$2("cancel", d2);
                G$2("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                G$2("load", d2);
                break;
              case "video":
              case "audio":
                for (a = 0; a < Xe.length; a++)
                  G$2(Xe[a], d2);
                break;
              case "source":
                G$2("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                G$2("error", d2);
                G$2("load", d2);
                break;
              case "details":
                G$2("toggle", d2);
                break;
              case "input":
                Za$1(d2, f2);
                G$2("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f2.multiple };
                G$2("invalid", d2);
                break;
              case "textarea":
                hb(d2, f2), G$2("invalid", d2);
            }
            vb(c2, f2);
            a = null;
            for (var g2 in f2)
              f2.hasOwnProperty(g2) && (e2 = f2[g2], "children" === g2 ? "string" === typeof e2 ? d2.textContent !== e2 && (a = ["children", e2]) : "number" === typeof e2 && d2.textContent !== "" + e2 && (a = ["children", "" + e2]) : ca$1.hasOwnProperty(g2) && null != e2 && "onScroll" === g2 && G$2("scroll", d2));
            switch (c2) {
              case "input":
                Va$1(d2);
                cb(d2, f2, true);
                break;
              case "textarea":
                Va$1(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d2.onclick = jf);
            }
            d2 = a;
            b2.updateQueue = d2;
            null !== d2 && (b2.flags |= 4);
          } else {
            g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
            a === kb.html && (a = lb(c2));
            a === kb.html ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
            a[wf] = b2;
            a[xf] = d2;
            Bi(a, b2, false, false);
            b2.stateNode = a;
            g2 = wb(c2, d2);
            switch (c2) {
              case "dialog":
                G$2("cancel", a);
                G$2("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                G$2("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < Xe.length; e2++)
                  G$2(Xe[e2], a);
                e2 = d2;
                break;
              case "source":
                G$2("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                G$2("error", a);
                G$2("load", a);
                e2 = d2;
                break;
              case "details":
                G$2("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za$1(a, d2);
                e2 = Ya(a, d2);
                G$2("invalid", a);
                break;
              case "option":
                e2 = eb(a, d2);
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = m$1({}, d2, { value: void 0 });
                G$2("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                G$2("invalid", a);
                break;
              default:
                e2 = d2;
            }
            vb(c2, e2);
            var h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? tb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && ob(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && pb(a, k2) : "number" === typeof k2 && pb(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ca$1.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && G$2("scroll", a) : null != k2 && qa$1(a, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va$1(a);
                cb(a, d2, false);
                break;
              case "textarea":
                Va$1(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa$1(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(a, !!d2.multiple, d2.defaultValue, true);
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = jf);
            }
            mf(c2, d2) && (b2.flags |= 4);
          }
          null !== b2.ref && (b2.flags |= 128);
        }
        return null;
      case 6:
        if (a && null != b2.stateNode)
          Ei$1(a, b2, a.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b2.stateNode)
            throw Error(y$2(166));
          c2 = dh(ch.current);
          dh(ah.current);
          rh(b2) ? (d2 = b2.stateNode, c2 = b2.memoizedProps, d2[wf] = b2, d2.nodeValue !== c2 && (b2.flags |= 4)) : (d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[wf] = b2, b2.stateNode = d2);
        }
        return null;
      case 13:
        H$1(P);
        d2 = b2.memoizedState;
        if (0 !== (b2.flags & 64))
          return b2.lanes = c2, b2;
        d2 = null !== d2;
        c2 = false;
        null === a ? void 0 !== b2.memoizedProps.fallback && rh(b2) : c2 = null !== a.memoizedState;
        if (d2 && !c2 && 0 !== (b2.mode & 2))
          if (null === a && true !== b2.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1))
            0 === V$1 && (V$1 = 3);
          else {
            if (0 === V$1 || 3 === V$1)
              V$1 = 4;
            null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii$1(U, W);
          }
        if (d2 || c2)
          b2.flags |= 4;
        return null;
      case 4:
        return fh(), Ci(b2), null === a && cf(b2.stateNode.containerInfo), null;
      case 10:
        return rg(b2), null;
      case 17:
        return Ff(b2.type) && Gf(), null;
      case 19:
        H$1(P);
        d2 = b2.memoizedState;
        if (null === d2)
          return null;
        f2 = 0 !== (b2.flags & 64);
        g2 = d2.rendering;
        if (null === g2)
          if (f2)
            Fi(d2, false);
          else {
            if (0 !== V$1 || null !== a && 0 !== (a.flags & 64))
              for (a = b2.child; null !== a; ) {
                g2 = ih(a);
                if (null !== g2) {
                  b2.flags |= 64;
                  Fi(d2, false);
                  f2 = g2.updateQueue;
                  null !== f2 && (b2.updateQueue = f2, b2.flags |= 4);
                  null === d2.lastEffect && (b2.firstEffect = null);
                  b2.lastEffect = d2.lastEffect;
                  d2 = c2;
                  for (c2 = b2.child; null !== c2; )
                    f2 = c2, a = d2, f2.flags &= 2, f2.nextEffect = null, f2.firstEffect = null, f2.lastEffect = null, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                  I$1(P, P.current & 1 | 2);
                  return b2.child;
                }
                a = a.sibling;
              }
            null !== d2.tail && O() > Ji$1 && (b2.flags |= 64, f2 = true, Fi(d2, false), b2.lanes = 33554432);
          }
        else {
          if (!f2)
            if (a = ih(g2), null !== a) {
              if (b2.flags |= 64, f2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Fi(d2, true), null === d2.tail && "hidden" === d2.tailMode && !g2.alternate && !lh)
                return b2 = b2.lastEffect = d2.lastEffect, null !== b2 && (b2.nextEffect = null), null;
            } else
              2 * O() - d2.renderingStartTime > Ji$1 && 1073741824 !== c2 && (b2.flags |= 64, f2 = true, Fi(d2, false), b2.lanes = 33554432);
          d2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = d2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, d2.last = g2);
        }
        return null !== d2.tail ? (c2 = d2.tail, d2.rendering = c2, d2.tail = c2.sibling, d2.lastEffect = b2.lastEffect, d2.renderingStartTime = O(), c2.sibling = null, b2 = P.current, I$1(P, f2 ? b2 & 1 | 2 : b2 & 1), c2) : null;
      case 23:
      case 24:
        return Ki(), null !== a && null !== a.memoizedState !== (null !== b2.memoizedState) && "unstable-defer-without-hiding" !== d2.mode && (b2.flags |= 4), null;
    }
    throw Error(y$2(156, b2.tag));
  }
  function Li$1(a) {
    switch (a.tag) {
      case 1:
        Ff(a.type) && Gf();
        var b2 = a.flags;
        return b2 & 4096 ? (a.flags = b2 & -4097 | 64, a) : null;
      case 3:
        fh();
        H$1(N);
        H$1(M);
        uh();
        b2 = a.flags;
        if (0 !== (b2 & 64))
          throw Error(y$2(285));
        a.flags = b2 & -4097 | 64;
        return a;
      case 5:
        return hh(a), null;
      case 13:
        return H$1(P), b2 = a.flags, b2 & 4096 ? (a.flags = b2 & -4097 | 64, a) : null;
      case 19:
        return H$1(P), null;
      case 4:
        return fh(), null;
      case 10:
        return rg(a), null;
      case 23:
      case 24:
        return Ki(), null;
      default:
        return null;
    }
  }
  function Mi(a, b2) {
    try {
      var c2 = "", d2 = b2;
      do
        c2 += Qa(d2), d2 = d2.return;
      while (d2);
      var e2 = c2;
    } catch (f2) {
      e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a, source: b2, stack: e2 };
  }
  function Ni(a, b2) {
    try {
      console.error(b2.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Oi = "function" === typeof WeakMap ? WeakMap : Map;
  function Pi$1(a, b2, c2) {
    c2 = zg(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d2 = b2.value;
    c2.callback = function() {
      Qi$1 || (Qi$1 = true, Ri = d2);
      Ni(a, b2);
    };
    return c2;
  }
  function Si$1(a, b2, c2) {
    c2 = zg(-1, c2);
    c2.tag = 3;
    var d2 = a.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e2 = b2.value;
      c2.payload = function() {
        Ni(a, b2);
        return d2(e2);
      };
    }
    var f2 = a.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
      "function" !== typeof d2 && (null === Ti$1 ? Ti$1 = /* @__PURE__ */ new Set([this]) : Ti$1.add(this), Ni(a, b2));
      var c3 = b2.stack;
      this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  var Ui = "function" === typeof WeakSet ? WeakSet : Set;
  function Vi(a) {
    var b2 = a.ref;
    if (null !== b2)
      if ("function" === typeof b2)
        try {
          b2(null);
        } catch (c2) {
          Wi(a, c2);
        }
      else
        b2.current = null;
  }
  function Xi$1(a, b2) {
    switch (b2.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        return;
      case 1:
        if (b2.flags & 256 && null !== a) {
          var c2 = a.memoizedProps, d2 = a.memoizedState;
          a = b2.stateNode;
          b2 = a.getSnapshotBeforeUpdate(b2.elementType === b2.type ? c2 : lg(b2.type, c2), d2);
          a.__reactInternalSnapshotBeforeUpdate = b2;
        }
        return;
      case 3:
        b2.flags & 256 && qf(b2.stateNode.containerInfo);
        return;
      case 5:
      case 6:
      case 4:
      case 17:
        return;
    }
    throw Error(y$2(163));
  }
  function Yi$1(a, b2, c2) {
    switch (c2.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        b2 = c2.updateQueue;
        b2 = null !== b2 ? b2.lastEffect : null;
        if (null !== b2) {
          a = b2 = b2.next;
          do {
            if (3 === (a.tag & 3)) {
              var d2 = a.create;
              a.destroy = d2();
            }
            a = a.next;
          } while (a !== b2);
        }
        b2 = c2.updateQueue;
        b2 = null !== b2 ? b2.lastEffect : null;
        if (null !== b2) {
          a = b2 = b2.next;
          do {
            var e2 = a;
            d2 = e2.next;
            e2 = e2.tag;
            0 !== (e2 & 4) && 0 !== (e2 & 1) && (Zi$1(c2, a), $i$1(c2, a));
            a = d2;
          } while (a !== b2);
        }
        return;
      case 1:
        a = c2.stateNode;
        c2.flags & 4 && (null === b2 ? a.componentDidMount() : (d2 = c2.elementType === c2.type ? b2.memoizedProps : lg(c2.type, b2.memoizedProps), a.componentDidUpdate(
          d2,
          b2.memoizedState,
          a.__reactInternalSnapshotBeforeUpdate
        )));
        b2 = c2.updateQueue;
        null !== b2 && Eg(c2, b2, a);
        return;
      case 3:
        b2 = c2.updateQueue;
        if (null !== b2) {
          a = null;
          if (null !== c2.child)
            switch (c2.child.tag) {
              case 5:
                a = c2.child.stateNode;
                break;
              case 1:
                a = c2.child.stateNode;
            }
          Eg(c2, b2, a);
        }
        return;
      case 5:
        a = c2.stateNode;
        null === b2 && c2.flags & 4 && mf(c2.type, c2.memoizedProps) && a.focus();
        return;
      case 6:
        return;
      case 4:
        return;
      case 12:
        return;
      case 13:
        null === c2.memoizedState && (c2 = c2.alternate, null !== c2 && (c2 = c2.memoizedState, null !== c2 && (c2 = c2.dehydrated, null !== c2 && Cc$1(c2))));
        return;
      case 19:
      case 17:
      case 20:
      case 21:
      case 23:
      case 24:
        return;
    }
    throw Error(y$2(163));
  }
  function aj(a, b2) {
    for (var c2 = a; ; ) {
      if (5 === c2.tag) {
        var d2 = c2.stateNode;
        if (b2)
          d2 = d2.style, "function" === typeof d2.setProperty ? d2.setProperty("display", "none", "important") : d2.display = "none";
        else {
          d2 = c2.stateNode;
          var e2 = c2.memoizedProps.style;
          e2 = void 0 !== e2 && null !== e2 && e2.hasOwnProperty("display") ? e2.display : null;
          d2.style.display = sb("display", e2);
        }
      } else if (6 === c2.tag)
        c2.stateNode.nodeValue = b2 ? "" : c2.memoizedProps;
      else if ((23 !== c2.tag && 24 !== c2.tag || null === c2.memoizedState || c2 === a) && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === a)
        break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === a)
          return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  }
  function bj(a, b2) {
    if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
      try {
        Mf.onCommitFiberUnmount(Lf, b2);
      } catch (f2) {
      }
    switch (b2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        a = b2.updateQueue;
        if (null !== a && (a = a.lastEffect, null !== a)) {
          var c2 = a = a.next;
          do {
            var d2 = c2, e2 = d2.destroy;
            d2 = d2.tag;
            if (void 0 !== e2)
              if (0 !== (d2 & 4))
                Zi$1(b2, c2);
              else {
                d2 = b2;
                try {
                  e2();
                } catch (f2) {
                  Wi(d2, f2);
                }
              }
            c2 = c2.next;
          } while (c2 !== a);
        }
        break;
      case 1:
        Vi(b2);
        a = b2.stateNode;
        if ("function" === typeof a.componentWillUnmount)
          try {
            a.props = b2.memoizedProps, a.state = b2.memoizedState, a.componentWillUnmount();
          } catch (f2) {
            Wi(
              b2,
              f2
            );
          }
        break;
      case 5:
        Vi(b2);
        break;
      case 4:
        cj(a, b2);
    }
  }
  function dj(a) {
    a.alternate = null;
    a.child = null;
    a.dependencies = null;
    a.firstEffect = null;
    a.lastEffect = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.return = null;
    a.updateQueue = null;
  }
  function ej(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function fj(a) {
    a: {
      for (var b2 = a.return; null !== b2; ) {
        if (ej(b2))
          break a;
        b2 = b2.return;
      }
      throw Error(y$2(160));
    }
    var c2 = b2;
    b2 = c2.stateNode;
    switch (c2.tag) {
      case 5:
        var d2 = false;
        break;
      case 3:
        b2 = b2.containerInfo;
        d2 = true;
        break;
      case 4:
        b2 = b2.containerInfo;
        d2 = true;
        break;
      default:
        throw Error(y$2(161));
    }
    c2.flags & 16 && (pb(b2, ""), c2.flags &= -17);
    a:
      b:
        for (c2 = a; ; ) {
          for (; null === c2.sibling; ) {
            if (null === c2.return || ej(c2.return)) {
              c2 = null;
              break a;
            }
            c2 = c2.return;
          }
          c2.sibling.return = c2.return;
          for (c2 = c2.sibling; 5 !== c2.tag && 6 !== c2.tag && 18 !== c2.tag; ) {
            if (c2.flags & 2)
              continue b;
            if (null === c2.child || 4 === c2.tag)
              continue b;
            else
              c2.child.return = c2, c2 = c2.child;
          }
          if (!(c2.flags & 2)) {
            c2 = c2.stateNode;
            break a;
          }
        }
    d2 ? gj(a, c2, b2) : hj(a, c2, b2);
  }
  function gj(a, b2, c2) {
    var d2 = a.tag, e2 = 5 === d2 || 6 === d2;
    if (e2)
      a = e2 ? a.stateNode : a.stateNode.instance, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = jf));
    else if (4 !== d2 && (a = a.child, null !== a))
      for (gj(a, b2, c2), a = a.sibling; null !== a; )
        gj(a, b2, c2), a = a.sibling;
  }
  function hj(a, b2, c2) {
    var d2 = a.tag, e2 = 5 === d2 || 6 === d2;
    if (e2)
      a = e2 ? a.stateNode : a.stateNode.instance, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
    else if (4 !== d2 && (a = a.child, null !== a))
      for (hj(a, b2, c2), a = a.sibling; null !== a; )
        hj(a, b2, c2), a = a.sibling;
  }
  function cj(a, b2) {
    for (var c2 = b2, d2 = false, e2, f2; ; ) {
      if (!d2) {
        d2 = c2.return;
        a:
          for (; ; ) {
            if (null === d2)
              throw Error(y$2(160));
            e2 = d2.stateNode;
            switch (d2.tag) {
              case 5:
                f2 = false;
                break a;
              case 3:
                e2 = e2.containerInfo;
                f2 = true;
                break a;
              case 4:
                e2 = e2.containerInfo;
                f2 = true;
                break a;
            }
            d2 = d2.return;
          }
        d2 = true;
      }
      if (5 === c2.tag || 6 === c2.tag) {
        a:
          for (var g2 = a, h2 = c2, k2 = h2; ; )
            if (bj(g2, k2), null !== k2.child && 4 !== k2.tag)
              k2.child.return = k2, k2 = k2.child;
            else {
              if (k2 === h2)
                break a;
              for (; null === k2.sibling; ) {
                if (null === k2.return || k2.return === h2)
                  break a;
                k2 = k2.return;
              }
              k2.sibling.return = k2.return;
              k2 = k2.sibling;
            }
        f2 ? (g2 = e2, h2 = c2.stateNode, 8 === g2.nodeType ? g2.parentNode.removeChild(h2) : g2.removeChild(h2)) : e2.removeChild(c2.stateNode);
      } else if (4 === c2.tag) {
        if (null !== c2.child) {
          e2 = c2.stateNode.containerInfo;
          f2 = true;
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
      } else if (bj(a, c2), null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b2)
        break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b2)
          return;
        c2 = c2.return;
        4 === c2.tag && (d2 = false);
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  }
  function ij(a, b2) {
    switch (b2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        var c2 = b2.updateQueue;
        c2 = null !== c2 ? c2.lastEffect : null;
        if (null !== c2) {
          var d2 = c2 = c2.next;
          do
            3 === (d2.tag & 3) && (a = d2.destroy, d2.destroy = void 0, void 0 !== a && a()), d2 = d2.next;
          while (d2 !== c2);
        }
        return;
      case 1:
        return;
      case 5:
        c2 = b2.stateNode;
        if (null != c2) {
          d2 = b2.memoizedProps;
          var e2 = null !== a ? a.memoizedProps : d2;
          a = b2.type;
          var f2 = b2.updateQueue;
          b2.updateQueue = null;
          if (null !== f2) {
            c2[xf] = d2;
            "input" === a && "radio" === d2.type && null != d2.name && $a(c2, d2);
            wb(a, e2);
            b2 = wb(a, d2);
            for (e2 = 0; e2 < f2.length; e2 += 2) {
              var g2 = f2[e2], h2 = f2[e2 + 1];
              "style" === g2 ? tb(c2, h2) : "dangerouslySetInnerHTML" === g2 ? ob(c2, h2) : "children" === g2 ? pb(c2, h2) : qa$1(c2, g2, h2, b2);
            }
            switch (a) {
              case "input":
                ab(c2, d2);
                break;
              case "textarea":
                ib(c2, d2);
                break;
              case "select":
                a = c2._wrapperState.wasMultiple, c2._wrapperState.wasMultiple = !!d2.multiple, f2 = d2.value, null != f2 ? fb(c2, !!d2.multiple, f2, false) : a !== !!d2.multiple && (null != d2.defaultValue ? fb(c2, !!d2.multiple, d2.defaultValue, true) : fb(c2, !!d2.multiple, d2.multiple ? [] : "", false));
            }
          }
        }
        return;
      case 6:
        if (null === b2.stateNode)
          throw Error(y$2(162));
        b2.stateNode.nodeValue = b2.memoizedProps;
        return;
      case 3:
        c2 = b2.stateNode;
        c2.hydrate && (c2.hydrate = false, Cc$1(c2.containerInfo));
        return;
      case 12:
        return;
      case 13:
        null !== b2.memoizedState && (jj = O(), aj(b2.child, true));
        kj(b2);
        return;
      case 19:
        kj(b2);
        return;
      case 17:
        return;
      case 23:
      case 24:
        aj(b2, null !== b2.memoizedState);
        return;
    }
    throw Error(y$2(163));
  }
  function kj(a) {
    var b2 = a.updateQueue;
    if (null !== b2) {
      a.updateQueue = null;
      var c2 = a.stateNode;
      null === c2 && (c2 = a.stateNode = new Ui());
      b2.forEach(function(b3) {
        var d2 = lj.bind(null, a, b3);
        c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
      });
    }
  }
  function mj(a, b2) {
    return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b2 = b2.memoizedState, null !== b2 && null === b2.dehydrated) : false;
  }
  var nj = Math.ceil, oj = ra$1.ReactCurrentDispatcher, pj = ra$1.ReactCurrentOwner, X = 0, U = null, Y$1 = null, W = 0, qj = 0, rj = Bf(0), V$1 = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji$1 = Infinity;
  function wj() {
    Ji$1 = O() + 500;
  }
  var Z$1 = null, Qi$1 = false, Ri = null, Ti$1 = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
  function Hg() {
    return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
  }
  function Ig(a) {
    a = a.mode;
    if (0 === (a & 2))
      return 1;
    if (0 === (a & 4))
      return 99 === eg() ? 1 : 2;
    0 === Gj && (Gj = tj);
    if (0 !== kg.transition) {
      0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
      a = Gj;
      var b2 = 4186112 & ~Hj;
      b2 &= -b2;
      0 === b2 && (a = 4186112 & ~a, b2 = a & -a, 0 === b2 && (b2 = 8192));
      return b2;
    }
    a = eg();
    0 !== (X & 4) && 98 === a ? a = Xc$1(12, Gj) : (a = Sc$1(a), a = Xc$1(a, Gj));
    return a;
  }
  function Jg(a, b2, c2) {
    if (50 < Dj)
      throw Dj = 0, Ej = null, Error(y$2(185));
    a = Kj(a, b2);
    if (null === a)
      return null;
    $c$1(a, b2, c2);
    a === U && (Hi |= b2, 4 === V$1 && Ii$1(a, W));
    var d2 = eg();
    1 === b2 ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c2), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d2 && 99 !== d2 || (null === Cj ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c2));
    vj = a;
  }
  function Kj(a, b2) {
    a.lanes |= b2;
    var c2 = a.alternate;
    null !== c2 && (c2.lanes |= b2);
    c2 = a;
    for (a = a.return; null !== a; )
      a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  function Mj(a, b2) {
    for (var c2 = a.callbackNode, d2 = a.suspendedLanes, e2 = a.pingedLanes, f2 = a.expirationTimes, g2 = a.pendingLanes; 0 < g2; ) {
      var h2 = 31 - Vc$1(g2), k2 = 1 << h2, l2 = f2[h2];
      if (-1 === l2) {
        if (0 === (k2 & d2) || 0 !== (k2 & e2)) {
          l2 = b2;
          Rc$1(k2);
          var n2 = F$1;
          f2[h2] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
        }
      } else
        l2 <= b2 && (a.expiredLanes |= k2);
      g2 &= ~k2;
    }
    d2 = Uc$1(a, a === U ? W : 0);
    b2 = F$1;
    if (0 === d2)
      null !== c2 && (c2 !== Zf && Pf(c2), a.callbackNode = null, a.callbackPriority = 0);
    else {
      if (null !== c2) {
        if (a.callbackPriority === b2)
          return;
        c2 !== Zf && Pf(c2);
      }
      15 === b2 ? (c2 = Lj.bind(null, a), null === ag ? (ag = [c2], bg = Of(Uf, jg)) : ag.push(c2), c2 = Zf) : 14 === b2 ? c2 = hg(99, Lj.bind(null, a)) : (c2 = Tc$1(b2), c2 = hg(c2, Nj.bind(null, a)));
      a.callbackPriority = b2;
      a.callbackNode = c2;
    }
  }
  function Nj(a) {
    Fj = -1;
    Hj = Gj = 0;
    if (0 !== (X & 48))
      throw Error(y$2(327));
    var b2 = a.callbackNode;
    if (Oj() && a.callbackNode !== b2)
      return null;
    var c2 = Uc$1(a, a === U ? W : 0);
    if (0 === c2)
      return null;
    var d2 = c2;
    var e2 = X;
    X |= 16;
    var f2 = Pj();
    if (U !== a || W !== d2)
      wj(), Qj(a, d2);
    do
      try {
        Rj();
        break;
      } catch (h2) {
        Sj(a, h2);
      }
    while (1);
    qg();
    oj.current = f2;
    X = e2;
    null !== Y$1 ? d2 = 0 : (U = null, W = 0, d2 = V$1);
    if (0 !== (tj & Hi))
      Qj(a, 0);
    else if (0 !== d2) {
      2 === d2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c2 = Wc$1(a), 0 !== c2 && (d2 = Tj(a, c2)));
      if (1 === d2)
        throw b2 = sj, Qj(a, 0), Ii$1(a, c2), Mj(a, O()), b2;
      a.finishedWork = a.current.alternate;
      a.finishedLanes = c2;
      switch (d2) {
        case 0:
        case 1:
          throw Error(y$2(345));
        case 2:
          Uj(a);
          break;
        case 3:
          Ii$1(a, c2);
          if ((c2 & 62914560) === c2 && (d2 = jj + 500 - O(), 10 < d2)) {
            if (0 !== Uc$1(a, 0))
              break;
            e2 = a.suspendedLanes;
            if ((e2 & c2) !== c2) {
              Hg();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = of(Uj.bind(null, a), d2);
            break;
          }
          Uj(a);
          break;
        case 4:
          Ii$1(a, c2);
          if ((c2 & 4186112) === c2)
            break;
          d2 = a.eventTimes;
          for (e2 = -1; 0 < c2; ) {
            var g2 = 31 - Vc$1(c2);
            f2 = 1 << g2;
            g2 = d2[g2];
            g2 > e2 && (e2 = g2);
            c2 &= ~f2;
          }
          c2 = e2;
          c2 = O() - c2;
          c2 = (120 > c2 ? 120 : 480 > c2 ? 480 : 1080 > c2 ? 1080 : 1920 > c2 ? 1920 : 3e3 > c2 ? 3e3 : 4320 > c2 ? 4320 : 1960 * nj(c2 / 1960)) - c2;
          if (10 < c2) {
            a.timeoutHandle = of(Uj.bind(null, a), c2);
            break;
          }
          Uj(a);
          break;
        case 5:
          Uj(a);
          break;
        default:
          throw Error(y$2(329));
      }
    }
    Mj(a, O());
    return a.callbackNode === b2 ? Nj.bind(null, a) : null;
  }
  function Ii$1(a, b2) {
    b2 &= ~uj;
    b2 &= ~Hi;
    a.suspendedLanes |= b2;
    a.pingedLanes &= ~b2;
    for (a = a.expirationTimes; 0 < b2; ) {
      var c2 = 31 - Vc$1(b2), d2 = 1 << c2;
      a[c2] = -1;
      b2 &= ~d2;
    }
  }
  function Lj(a) {
    if (0 !== (X & 48))
      throw Error(y$2(327));
    Oj();
    if (a === U && 0 !== (a.expiredLanes & W)) {
      var b2 = W;
      var c2 = Tj(a, b2);
      0 !== (tj & Hi) && (b2 = Uc$1(a, b2), c2 = Tj(a, b2));
    } else
      b2 = Uc$1(a, 0), c2 = Tj(a, b2);
    0 !== a.tag && 2 === c2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b2 = Wc$1(a), 0 !== b2 && (c2 = Tj(a, b2)));
    if (1 === c2)
      throw c2 = sj, Qj(a, 0), Ii$1(a, b2), Mj(a, O()), c2;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b2;
    Uj(a);
    Mj(a, O());
    return null;
  }
  function Vj() {
    if (null !== Cj) {
      var a = Cj;
      Cj = null;
      a.forEach(function(a2) {
        a2.expiredLanes |= 24 & a2.pendingLanes;
        Mj(a2, O());
      });
    }
    ig();
  }
  function Wj(a, b2) {
    var c2 = X;
    X |= 1;
    try {
      return a(b2);
    } finally {
      X = c2, 0 === X && (wj(), ig());
    }
  }
  function Xj(a, b2) {
    var c2 = X;
    X &= -2;
    X |= 8;
    try {
      return a(b2);
    } finally {
      X = c2, 0 === X && (wj(), ig());
    }
  }
  function ni(a, b2) {
    I$1(rj, qj);
    qj |= b2;
    tj |= b2;
  }
  function Ki() {
    qj = rj.current;
    H$1(rj);
  }
  function Qj(a, b2) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c2 = a.timeoutHandle;
    -1 !== c2 && (a.timeoutHandle = -1, pf(c2));
    if (null !== Y$1)
      for (c2 = Y$1.return; null !== c2; ) {
        var d2 = c2;
        switch (d2.tag) {
          case 1:
            d2 = d2.type.childContextTypes;
            null !== d2 && void 0 !== d2 && Gf();
            break;
          case 3:
            fh();
            H$1(N);
            H$1(M);
            uh();
            break;
          case 5:
            hh(d2);
            break;
          case 4:
            fh();
            break;
          case 13:
            H$1(P);
            break;
          case 19:
            H$1(P);
            break;
          case 10:
            rg(d2);
            break;
          case 23:
          case 24:
            Ki();
        }
        c2 = c2.return;
      }
    U = a;
    Y$1 = Tg(a.current, null);
    W = qj = tj = b2;
    V$1 = 0;
    sj = null;
    uj = Hi = Dg = 0;
  }
  function Sj(a, b2) {
    do {
      var c2 = Y$1;
      try {
        qg();
        vh.current = Gh;
        if (yh) {
          for (var d2 = R.memoizedState; null !== d2; ) {
            var e2 = d2.queue;
            null !== e2 && (e2.pending = null);
            d2 = d2.next;
          }
          yh = false;
        }
        xh = 0;
        T = S = R = null;
        zh = false;
        pj.current = null;
        if (null === c2 || null === c2.return) {
          V$1 = 1;
          sj = b2;
          Y$1 = null;
          break;
        }
        a: {
          var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
          b2 = W;
          h2.flags |= 2048;
          h2.firstEffect = h2.lastEffect = null;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2;
            if (0 === (h2.mode & 2)) {
              var n2 = h2.alternate;
              n2 ? (h2.updateQueue = n2.updateQueue, h2.memoizedState = n2.memoizedState, h2.lanes = n2.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
            }
            var A2 = 0 !== (P.current & 1), p2 = g2;
            do {
              var C2;
              if (C2 = 13 === p2.tag) {
                var x2 = p2.memoizedState;
                if (null !== x2)
                  C2 = null !== x2.dehydrated ? true : false;
                else {
                  var w2 = p2.memoizedProps;
                  C2 = void 0 === w2.fallback ? false : true !== w2.unstable_avoidThisFallback ? true : A2 ? false : true;
                }
              }
              if (C2) {
                var z2 = p2.updateQueue;
                if (null === z2) {
                  var u2 = /* @__PURE__ */ new Set();
                  u2.add(l2);
                  p2.updateQueue = u2;
                } else
                  z2.add(l2);
                if (0 === (p2.mode & 2)) {
                  p2.flags |= 64;
                  h2.flags |= 16384;
                  h2.flags &= -2981;
                  if (1 === h2.tag)
                    if (null === h2.alternate)
                      h2.tag = 17;
                    else {
                      var t2 = zg(-1, 1);
                      t2.tag = 2;
                      Ag(h2, t2);
                    }
                  h2.lanes |= 1;
                  break a;
                }
                k2 = void 0;
                h2 = b2;
                var q2 = f2.pingCache;
                null === q2 ? (q2 = f2.pingCache = new Oi(), k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)) : (k2 = q2.get(l2), void 0 === k2 && (k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)));
                if (!k2.has(h2)) {
                  k2.add(h2);
                  var v2 = Yj.bind(null, f2, l2, h2);
                  l2.then(v2, v2);
                }
                p2.flags |= 4096;
                p2.lanes = b2;
                break a;
              }
              p2 = p2.return;
            } while (null !== p2);
            k2 = Error((Ra$1(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
          }
          5 !== V$1 && (V$1 = 2);
          k2 = Mi(k2, h2);
          p2 = g2;
          do {
            switch (p2.tag) {
              case 3:
                f2 = k2;
                p2.flags |= 4096;
                b2 &= -b2;
                p2.lanes |= b2;
                var J2 = Pi$1(p2, f2, b2);
                Bg(p2, J2);
                break a;
              case 1:
                f2 = k2;
                var K2 = p2.type, Q2 = p2.stateNode;
                if (0 === (p2.flags & 64) && ("function" === typeof K2.getDerivedStateFromError || null !== Q2 && "function" === typeof Q2.componentDidCatch && (null === Ti$1 || !Ti$1.has(Q2)))) {
                  p2.flags |= 4096;
                  b2 &= -b2;
                  p2.lanes |= b2;
                  var L2 = Si$1(p2, f2, b2);
                  Bg(p2, L2);
                  break a;
                }
            }
            p2 = p2.return;
          } while (null !== p2);
        }
        Zj(c2);
      } catch (va2) {
        b2 = va2;
        Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Pj() {
    var a = oj.current;
    oj.current = Gh;
    return null === a ? Gh : a;
  }
  function Tj(a, b2) {
    var c2 = X;
    X |= 16;
    var d2 = Pj();
    U === a && W === b2 || Qj(a, b2);
    do
      try {
        ak();
        break;
      } catch (e2) {
        Sj(a, e2);
      }
    while (1);
    qg();
    X = c2;
    oj.current = d2;
    if (null !== Y$1)
      throw Error(y$2(261));
    U = null;
    W = 0;
    return V$1;
  }
  function ak() {
    for (; null !== Y$1; )
      bk(Y$1);
  }
  function Rj() {
    for (; null !== Y$1 && !Qf(); )
      bk(Y$1);
  }
  function bk(a) {
    var b2 = ck(a.alternate, a, qj);
    a.memoizedProps = a.pendingProps;
    null === b2 ? Zj(a) : Y$1 = b2;
    pj.current = null;
  }
  function Zj(a) {
    var b2 = a;
    do {
      var c2 = b2.alternate;
      a = b2.return;
      if (0 === (b2.flags & 2048)) {
        c2 = Gi(c2, b2, qj);
        if (null !== c2) {
          Y$1 = c2;
          return;
        }
        c2 = b2;
        if (24 !== c2.tag && 23 !== c2.tag || null === c2.memoizedState || 0 !== (qj & 1073741824) || 0 === (c2.mode & 4)) {
          for (var d2 = 0, e2 = c2.child; null !== e2; )
            d2 |= e2.lanes | e2.childLanes, e2 = e2.sibling;
          c2.childLanes = d2;
        }
        null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b2.firstEffect), null !== b2.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b2.firstEffect), a.lastEffect = b2.lastEffect), 1 < b2.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b2 : a.firstEffect = b2, a.lastEffect = b2));
      } else {
        c2 = Li$1(b2);
        if (null !== c2) {
          c2.flags &= 2047;
          Y$1 = c2;
          return;
        }
        null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
      }
      b2 = b2.sibling;
      if (null !== b2) {
        Y$1 = b2;
        return;
      }
      Y$1 = b2 = a;
    } while (null !== b2);
    0 === V$1 && (V$1 = 5);
  }
  function Uj(a) {
    var b2 = eg();
    gg(99, dk.bind(null, a, b2));
    return null;
  }
  function dk(a, b2) {
    do
      Oj();
    while (null !== yj);
    if (0 !== (X & 48))
      throw Error(y$2(327));
    var c2 = a.finishedWork;
    if (null === c2)
      return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c2 === a.current)
      throw Error(y$2(177));
    a.callbackNode = null;
    var d2 = c2.lanes | c2.childLanes, e2 = d2, f2 = a.pendingLanes & ~e2;
    a.pendingLanes = e2;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= e2;
    a.mutableReadLanes &= e2;
    a.entangledLanes &= e2;
    e2 = a.entanglements;
    for (var g2 = a.eventTimes, h2 = a.expirationTimes; 0 < f2; ) {
      var k2 = 31 - Vc$1(f2), l2 = 1 << k2;
      e2[k2] = 0;
      g2[k2] = -1;
      h2[k2] = -1;
      f2 &= ~l2;
    }
    null !== Cj && 0 === (d2 & 24) && Cj.has(a) && Cj.delete(a);
    a === U && (Y$1 = U = null, W = 0);
    1 < c2.flags ? null !== c2.lastEffect ? (c2.lastEffect.nextEffect = c2, d2 = c2.firstEffect) : d2 = c2 : d2 = c2.firstEffect;
    if (null !== d2) {
      e2 = X;
      X |= 32;
      pj.current = null;
      kf = fd;
      g2 = Ne();
      if (Oe(g2)) {
        if ("selectionStart" in g2)
          h2 = { start: g2.selectionStart, end: g2.selectionEnd };
        else
          a:
            if (h2 = (h2 = g2.ownerDocument) && h2.defaultView || window, (l2 = h2.getSelection && h2.getSelection()) && 0 !== l2.rangeCount) {
              h2 = l2.anchorNode;
              f2 = l2.anchorOffset;
              k2 = l2.focusNode;
              l2 = l2.focusOffset;
              try {
                h2.nodeType, k2.nodeType;
              } catch (va2) {
                h2 = null;
                break a;
              }
              var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w2 = g2, z2 = null;
              b:
                for (; ; ) {
                  for (var u2; ; ) {
                    w2 !== h2 || 0 !== f2 && 3 !== w2.nodeType || (A2 = n2 + f2);
                    w2 !== k2 || 0 !== l2 && 3 !== w2.nodeType || (p2 = n2 + l2);
                    3 === w2.nodeType && (n2 += w2.nodeValue.length);
                    if (null === (u2 = w2.firstChild))
                      break;
                    z2 = w2;
                    w2 = u2;
                  }
                  for (; ; ) {
                    if (w2 === g2)
                      break b;
                    z2 === h2 && ++C2 === f2 && (A2 = n2);
                    z2 === k2 && ++x2 === l2 && (p2 = n2);
                    if (null !== (u2 = w2.nextSibling))
                      break;
                    w2 = z2;
                    z2 = w2.parentNode;
                  }
                  w2 = u2;
                }
              h2 = -1 === A2 || -1 === p2 ? null : { start: A2, end: p2 };
            } else
              h2 = null;
        h2 = h2 || { start: 0, end: 0 };
      } else
        h2 = null;
      lf = { focusedElem: g2, selectionRange: h2 };
      fd = false;
      Ij = null;
      Jj = false;
      Z$1 = d2;
      do
        try {
          ek();
        } catch (va2) {
          if (null === Z$1)
            throw Error(y$2(330));
          Wi(Z$1, va2);
          Z$1 = Z$1.nextEffect;
        }
      while (null !== Z$1);
      Ij = null;
      Z$1 = d2;
      do
        try {
          for (g2 = a; null !== Z$1; ) {
            var t2 = Z$1.flags;
            t2 & 16 && pb(Z$1.stateNode, "");
            if (t2 & 128) {
              var q2 = Z$1.alternate;
              if (null !== q2) {
                var v2 = q2.ref;
                null !== v2 && ("function" === typeof v2 ? v2(null) : v2.current = null);
              }
            }
            switch (t2 & 1038) {
              case 2:
                fj(Z$1);
                Z$1.flags &= -3;
                break;
              case 6:
                fj(Z$1);
                Z$1.flags &= -3;
                ij(Z$1.alternate, Z$1);
                break;
              case 1024:
                Z$1.flags &= -1025;
                break;
              case 1028:
                Z$1.flags &= -1025;
                ij(Z$1.alternate, Z$1);
                break;
              case 4:
                ij(Z$1.alternate, Z$1);
                break;
              case 8:
                h2 = Z$1;
                cj(g2, h2);
                var J2 = h2.alternate;
                dj(h2);
                null !== J2 && dj(J2);
            }
            Z$1 = Z$1.nextEffect;
          }
        } catch (va2) {
          if (null === Z$1)
            throw Error(y$2(330));
          Wi(Z$1, va2);
          Z$1 = Z$1.nextEffect;
        }
      while (null !== Z$1);
      v2 = lf;
      q2 = Ne();
      t2 = v2.focusedElem;
      g2 = v2.selectionRange;
      if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
        null !== g2 && Oe(t2) && (q2 = g2.start, v2 = g2.end, void 0 === v2 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h2 = t2.textContent.length, J2 = Math.min(g2.start, h2), g2 = void 0 === g2.end ? J2 : Math.min(g2.end, h2), !v2.extend && J2 > g2 && (h2 = g2, g2 = J2, J2 = h2), h2 = Le$1(t2, J2), f2 = Le$1(t2, g2), h2 && f2 && (1 !== v2.rangeCount || v2.anchorNode !== h2.node || v2.anchorOffset !== h2.offset || v2.focusNode !== f2.node || v2.focusOffset !== f2.offset) && (q2 = q2.createRange(), q2.setStart(h2.node, h2.offset), v2.removeAllRanges(), J2 > g2 ? (v2.addRange(q2), v2.extend(f2.node, f2.offset)) : (q2.setEnd(f2.node, f2.offset), v2.addRange(q2))))));
        q2 = [];
        for (v2 = t2; v2 = v2.parentNode; )
          1 === v2.nodeType && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
        "function" === typeof t2.focus && t2.focus();
        for (t2 = 0; t2 < q2.length; t2++)
          v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
      }
      fd = !!kf;
      lf = kf = null;
      a.current = c2;
      Z$1 = d2;
      do
        try {
          for (t2 = a; null !== Z$1; ) {
            var K2 = Z$1.flags;
            K2 & 36 && Yi$1(t2, Z$1.alternate, Z$1);
            if (K2 & 128) {
              q2 = void 0;
              var Q2 = Z$1.ref;
              if (null !== Q2) {
                var L2 = Z$1.stateNode;
                switch (Z$1.tag) {
                  case 5:
                    q2 = L2;
                    break;
                  default:
                    q2 = L2;
                }
                "function" === typeof Q2 ? Q2(q2) : Q2.current = q2;
              }
            }
            Z$1 = Z$1.nextEffect;
          }
        } catch (va2) {
          if (null === Z$1)
            throw Error(y$2(330));
          Wi(Z$1, va2);
          Z$1 = Z$1.nextEffect;
        }
      while (null !== Z$1);
      Z$1 = null;
      $f();
      X = e2;
    } else
      a.current = c2;
    if (xj)
      xj = false, yj = a, zj = b2;
    else
      for (Z$1 = d2; null !== Z$1; )
        b2 = Z$1.nextEffect, Z$1.nextEffect = null, Z$1.flags & 8 && (K2 = Z$1, K2.sibling = null, K2.stateNode = null), Z$1 = b2;
    d2 = a.pendingLanes;
    0 === d2 && (Ti$1 = null);
    1 === d2 ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
    c2 = c2.stateNode;
    if (Mf && "function" === typeof Mf.onCommitFiberRoot)
      try {
        Mf.onCommitFiberRoot(Lf, c2, void 0, 64 === (c2.current.flags & 64));
      } catch (va2) {
      }
    Mj(a, O());
    if (Qi$1)
      throw Qi$1 = false, a = Ri, Ri = null, a;
    if (0 !== (X & 8))
      return null;
    ig();
    return null;
  }
  function ek() {
    for (; null !== Z$1; ) {
      var a = Z$1.alternate;
      Jj || null === Ij || (0 !== (Z$1.flags & 8) ? dc$1(Z$1, Ij) && (Jj = true) : 13 === Z$1.tag && mj(a, Z$1) && dc$1(Z$1, Ij) && (Jj = true));
      var b2 = Z$1.flags;
      0 !== (b2 & 256) && Xi$1(a, Z$1);
      0 === (b2 & 512) || xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
      Z$1 = Z$1.nextEffect;
    }
  }
  function Oj() {
    if (90 !== zj) {
      var a = 97 < zj ? 97 : zj;
      zj = 90;
      return gg(a, fk);
    }
    return false;
  }
  function $i$1(a, b2) {
    Aj.push(b2, a);
    xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
  }
  function Zi$1(a, b2) {
    Bj.push(b2, a);
    xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
  }
  function fk() {
    if (null === yj)
      return false;
    var a = yj;
    yj = null;
    if (0 !== (X & 48))
      throw Error(y$2(331));
    var b2 = X;
    X |= 32;
    var c2 = Bj;
    Bj = [];
    for (var d2 = 0; d2 < c2.length; d2 += 2) {
      var e2 = c2[d2], f2 = c2[d2 + 1], g2 = e2.destroy;
      e2.destroy = void 0;
      if ("function" === typeof g2)
        try {
          g2();
        } catch (k2) {
          if (null === f2)
            throw Error(y$2(330));
          Wi(f2, k2);
        }
    }
    c2 = Aj;
    Aj = [];
    for (d2 = 0; d2 < c2.length; d2 += 2) {
      e2 = c2[d2];
      f2 = c2[d2 + 1];
      try {
        var h2 = e2.create;
        e2.destroy = h2();
      } catch (k2) {
        if (null === f2)
          throw Error(y$2(330));
        Wi(f2, k2);
      }
    }
    for (h2 = a.current.firstEffect; null !== h2; )
      a = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a;
    X = b2;
    ig();
    return true;
  }
  function gk(a, b2, c2) {
    b2 = Mi(c2, b2);
    b2 = Pi$1(a, b2, 1);
    Ag(a, b2);
    b2 = Hg();
    a = Kj(a, 1);
    null !== a && ($c$1(a, 1, b2), Mj(a, b2));
  }
  function Wi(a, b2) {
    if (3 === a.tag)
      gk(a, a, b2);
    else
      for (var c2 = a.return; null !== c2; ) {
        if (3 === c2.tag) {
          gk(c2, a, b2);
          break;
        } else if (1 === c2.tag) {
          var d2 = c2.stateNode;
          if ("function" === typeof c2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ti$1 || !Ti$1.has(d2))) {
            a = Mi(b2, a);
            var e2 = Si$1(c2, a, 1);
            Ag(c2, e2);
            e2 = Hg();
            c2 = Kj(c2, 1);
            if (null !== c2)
              $c$1(c2, 1, e2), Mj(c2, e2);
            else if ("function" === typeof d2.componentDidCatch && (null === Ti$1 || !Ti$1.has(d2)))
              try {
                d2.componentDidCatch(b2, a);
              } catch (f2) {
              }
            break;
          }
        }
        c2 = c2.return;
      }
  }
  function Yj(a, b2, c2) {
    var d2 = a.pingCache;
    null !== d2 && d2.delete(b2);
    b2 = Hg();
    a.pingedLanes |= a.suspendedLanes & c2;
    U === a && (W & c2) === c2 && (4 === V$1 || 3 === V$1 && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c2);
    Mj(a, b2);
  }
  function lj(a, b2) {
    var c2 = a.stateNode;
    null !== c2 && c2.delete(b2);
    b2 = 0;
    0 === b2 && (b2 = a.mode, 0 === (b2 & 2) ? b2 = 1 : 0 === (b2 & 4) ? b2 = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b2 = Yc$1(62914560 & ~Gj), 0 === b2 && (b2 = 4194304)));
    c2 = Hg();
    a = Kj(a, b2);
    null !== a && ($c$1(a, b2, c2), Mj(a, c2));
  }
  var ck;
  ck = function(a, b2, c2) {
    var d2 = b2.lanes;
    if (null !== a)
      if (a.memoizedProps !== b2.pendingProps || N.current)
        ug = true;
      else if (0 !== (c2 & d2))
        ug = 0 !== (a.flags & 16384) ? true : false;
      else {
        ug = false;
        switch (b2.tag) {
          case 3:
            ri(b2);
            sh();
            break;
          case 5:
            gh(b2);
            break;
          case 1:
            Ff(b2.type) && Jf(b2);
            break;
          case 4:
            eh(b2, b2.stateNode.containerInfo);
            break;
          case 10:
            d2 = b2.memoizedProps.value;
            var e2 = b2.type._context;
            I$1(mg, e2._currentValue);
            e2._currentValue = d2;
            break;
          case 13:
            if (null !== b2.memoizedState) {
              if (0 !== (c2 & b2.child.childLanes))
                return ti(a, b2, c2);
              I$1(P, P.current & 1);
              b2 = hi(a, b2, c2);
              return null !== b2 ? b2.sibling : null;
            }
            I$1(P, P.current & 1);
            break;
          case 19:
            d2 = 0 !== (c2 & b2.childLanes);
            if (0 !== (a.flags & 64)) {
              if (d2)
                return Ai(a, b2, c2);
              b2.flags |= 64;
            }
            e2 = b2.memoizedState;
            null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
            I$1(P, P.current);
            if (d2)
              break;
            else
              return null;
          case 23:
          case 24:
            return b2.lanes = 0, mi(a, b2, c2);
        }
        return hi(a, b2, c2);
      }
    else
      ug = false;
    b2.lanes = 0;
    switch (b2.tag) {
      case 2:
        d2 = b2.type;
        null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
        a = b2.pendingProps;
        e2 = Ef(b2, M.current);
        tg(b2, c2);
        e2 = Ch(null, b2, d2, a, e2, c2);
        b2.flags |= 1;
        if ("object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof) {
          b2.tag = 1;
          b2.memoizedState = null;
          b2.updateQueue = null;
          if (Ff(d2)) {
            var f2 = true;
            Jf(b2);
          } else
            f2 = false;
          b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null;
          xg(b2);
          var g2 = d2.getDerivedStateFromProps;
          "function" === typeof g2 && Gg(b2, d2, g2, a);
          e2.updater = Kg;
          b2.stateNode = e2;
          e2._reactInternals = b2;
          Og(b2, d2, a, c2);
          b2 = qi(null, b2, d2, true, f2, c2);
        } else
          b2.tag = 0, fi(null, b2, e2, c2), b2 = b2.child;
        return b2;
      case 16:
        e2 = b2.elementType;
        a: {
          null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
          a = b2.pendingProps;
          f2 = e2._init;
          e2 = f2(e2._payload);
          b2.type = e2;
          f2 = b2.tag = hk(e2);
          a = lg(e2, a);
          switch (f2) {
            case 0:
              b2 = li(null, b2, e2, a, c2);
              break a;
            case 1:
              b2 = pi(null, b2, e2, a, c2);
              break a;
            case 11:
              b2 = gi(null, b2, e2, a, c2);
              break a;
            case 14:
              b2 = ii(null, b2, e2, lg(e2.type, a), d2, c2);
              break a;
          }
          throw Error(y$2(306, e2, ""));
        }
        return b2;
      case 0:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), li(a, b2, d2, e2, c2);
      case 1:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), pi(a, b2, d2, e2, c2);
      case 3:
        ri(b2);
        d2 = b2.updateQueue;
        if (null === a || null === d2)
          throw Error(y$2(282));
        d2 = b2.pendingProps;
        e2 = b2.memoizedState;
        e2 = null !== e2 ? e2.element : null;
        yg(a, b2);
        Cg(b2, d2, null, c2);
        d2 = b2.memoizedState.element;
        if (d2 === e2)
          sh(), b2 = hi(a, b2, c2);
        else {
          e2 = b2.stateNode;
          if (f2 = e2.hydrate)
            kh = rf(b2.stateNode.containerInfo.firstChild), jh = b2, f2 = lh = true;
          if (f2) {
            a = e2.mutableSourceEagerHydrationData;
            if (null != a)
              for (e2 = 0; e2 < a.length; e2 += 2)
                f2 = a[e2], f2._workInProgressVersionPrimary = a[e2 + 1], th.push(f2);
            c2 = Zg(b2, null, d2, c2);
            for (b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 1024, c2 = c2.sibling;
          } else
            fi(a, b2, d2, c2), sh();
          b2 = b2.child;
        }
        return b2;
      case 5:
        return gh(b2), null === a && ph(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, nf(d2, e2) ? g2 = null : null !== f2 && nf(d2, f2) && (b2.flags |= 16), oi(a, b2), fi(a, b2, g2, c2), b2.child;
      case 6:
        return null === a && ph(b2), null;
      case 13:
        return ti(a, b2, c2);
      case 4:
        return eh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Yg(b2, null, d2, c2) : fi(a, b2, d2, c2), b2.child;
      case 11:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), gi(a, b2, d2, e2, c2);
      case 7:
        return fi(a, b2, b2.pendingProps, c2), b2.child;
      case 8:
        return fi(
          a,
          b2,
          b2.pendingProps.children,
          c2
        ), b2.child;
      case 12:
        return fi(a, b2, b2.pendingProps.children, c2), b2.child;
      case 10:
        a: {
          d2 = b2.type._context;
          e2 = b2.pendingProps;
          g2 = b2.memoizedProps;
          f2 = e2.value;
          var h2 = b2.type._context;
          I$1(mg, h2._currentValue);
          h2._currentValue = f2;
          if (null !== g2)
            if (h2 = g2.value, f2 = He(h2, f2) ? 0 : ("function" === typeof d2._calculateChangedBits ? d2._calculateChangedBits(h2, f2) : 1073741823) | 0, 0 === f2) {
              if (g2.children === e2.children && !N.current) {
                b2 = hi(a, b2, c2);
                break a;
              }
            } else
              for (h2 = b2.child, null !== h2 && (h2.return = b2); null !== h2; ) {
                var k2 = h2.dependencies;
                if (null !== k2) {
                  g2 = h2.child;
                  for (var l2 = k2.firstContext; null !== l2; ) {
                    if (l2.context === d2 && 0 !== (l2.observedBits & f2)) {
                      1 === h2.tag && (l2 = zg(-1, c2 & -c2), l2.tag = 2, Ag(h2, l2));
                      h2.lanes |= c2;
                      l2 = h2.alternate;
                      null !== l2 && (l2.lanes |= c2);
                      sg(h2.return, c2);
                      k2.lanes |= c2;
                      break;
                    }
                    l2 = l2.next;
                  }
                } else
                  g2 = 10 === h2.tag ? h2.type === b2.type ? null : h2.child : h2.child;
                if (null !== g2)
                  g2.return = h2;
                else
                  for (g2 = h2; null !== g2; ) {
                    if (g2 === b2) {
                      g2 = null;
                      break;
                    }
                    h2 = g2.sibling;
                    if (null !== h2) {
                      h2.return = g2.return;
                      g2 = h2;
                      break;
                    }
                    g2 = g2.return;
                  }
                h2 = g2;
              }
          fi(a, b2, e2.children, c2);
          b2 = b2.child;
        }
        return b2;
      case 9:
        return e2 = b2.type, f2 = b2.pendingProps, d2 = f2.children, tg(b2, c2), e2 = vg(
          e2,
          f2.unstable_observedBits
        ), d2 = d2(e2), b2.flags |= 1, fi(a, b2, d2, c2), b2.child;
      case 14:
        return e2 = b2.type, f2 = lg(e2, b2.pendingProps), f2 = lg(e2.type, f2), ii(a, b2, e2, f2, d2, c2);
      case 15:
        return ki(a, b2, b2.type, b2.pendingProps, d2, c2);
      case 17:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2), b2.tag = 1, Ff(d2) ? (a = true, Jf(b2)) : a = false, tg(b2, c2), Mg(b2, d2, e2), Og(b2, d2, e2, c2), qi(null, b2, d2, true, a, c2);
      case 19:
        return Ai(a, b2, c2);
      case 23:
        return mi(a, b2, c2);
      case 24:
        return mi(a, b2, c2);
    }
    throw Error(y$2(156, b2.tag));
  };
  function ik(a, b2, c2, d2) {
    this.tag = a;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b2;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.flags = 0;
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function nh(a, b2, c2, d2) {
    return new ik(a, b2, c2, d2);
  }
  function ji(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function hk(a) {
    if ("function" === typeof a)
      return ji(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Aa$1)
        return 11;
      if (a === Da$1)
        return 14;
    }
    return 2;
  }
  function Tg(a, b2) {
    var c2 = a.alternate;
    null === c2 ? (c2 = nh(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
    c2.childLanes = a.childLanes;
    c2.lanes = a.lanes;
    c2.child = a.child;
    c2.memoizedProps = a.memoizedProps;
    c2.memoizedState = a.memoizedState;
    c2.updateQueue = a.updateQueue;
    b2 = a.dependencies;
    c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
    c2.sibling = a.sibling;
    c2.index = a.index;
    c2.ref = a.ref;
    return c2;
  }
  function Vg(a, b2, c2, d2, e2, f2) {
    var g2 = 2;
    d2 = a;
    if ("function" === typeof a)
      ji(a) && (g2 = 1);
    else if ("string" === typeof a)
      g2 = 5;
    else
      a:
        switch (a) {
          case ua$1:
            return Xg(c2.children, e2, f2, b2);
          case Ha$1:
            g2 = 8;
            e2 |= 16;
            break;
          case wa$1:
            g2 = 8;
            e2 |= 1;
            break;
          case xa$1:
            return a = nh(12, c2, b2, e2 | 8), a.elementType = xa$1, a.type = xa$1, a.lanes = f2, a;
          case Ba$1:
            return a = nh(13, c2, b2, e2), a.type = Ba$1, a.elementType = Ba$1, a.lanes = f2, a;
          case Ca$1:
            return a = nh(19, c2, b2, e2), a.elementType = Ca$1, a.lanes = f2, a;
          case Ia$1:
            return vi(c2, e2, f2, b2);
          case Ja:
            return a = nh(24, c2, b2, e2), a.elementType = Ja, a.lanes = f2, a;
          default:
            if ("object" === typeof a && null !== a)
              switch (a.$$typeof) {
                case ya$1:
                  g2 = 10;
                  break a;
                case za$1:
                  g2 = 9;
                  break a;
                case Aa$1:
                  g2 = 11;
                  break a;
                case Da$1:
                  g2 = 14;
                  break a;
                case Ea:
                  g2 = 16;
                  d2 = null;
                  break a;
                case Fa$1:
                  g2 = 22;
                  break a;
              }
            throw Error(y$2(130, null == a ? a : typeof a, ""));
        }
    b2 = nh(g2, c2, b2, e2);
    b2.elementType = a;
    b2.type = d2;
    b2.lanes = f2;
    return b2;
  }
  function Xg(a, b2, c2, d2) {
    a = nh(7, a, d2, b2);
    a.lanes = c2;
    return a;
  }
  function vi(a, b2, c2, d2) {
    a = nh(23, a, d2, b2);
    a.elementType = Ia$1;
    a.lanes = c2;
    return a;
  }
  function Ug(a, b2, c2) {
    a = nh(6, a, null, b2);
    a.lanes = c2;
    return a;
  }
  function Wg(a, b2, c2) {
    b2 = nh(4, null !== a.children ? a.children : [], a.key, b2);
    b2.lanes = c2;
    b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
    return b2;
  }
  function jk(a, b2, c2) {
    this.tag = b2;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.pendingContext = this.context = null;
    this.hydrate = c2;
    this.callbackNode = null;
    this.callbackPriority = 0;
    this.eventTimes = Zc$1(0);
    this.expirationTimes = Zc$1(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = Zc$1(0);
    this.mutableSourceEagerHydrationData = null;
  }
  function kk(a, b2, c2) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: ta$1, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
  }
  function lk(a, b2, c2, d2) {
    var e2 = b2.current, f2 = Hg(), g2 = Ig(e2);
    a:
      if (c2) {
        c2 = c2._reactInternals;
        b: {
          if (Zb(c2) !== c2 || 1 !== c2.tag)
            throw Error(y$2(170));
          var h2 = c2;
          do {
            switch (h2.tag) {
              case 3:
                h2 = h2.stateNode.context;
                break b;
              case 1:
                if (Ff(h2.type)) {
                  h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                  break b;
                }
            }
            h2 = h2.return;
          } while (null !== h2);
          throw Error(y$2(171));
        }
        if (1 === c2.tag) {
          var k2 = c2.type;
          if (Ff(k2)) {
            c2 = If(c2, k2, h2);
            break a;
          }
        }
        c2 = h2;
      } else
        c2 = Cf;
    null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
    b2 = zg(f2, g2);
    b2.payload = { element: a };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b2.callback = d2);
    Ag(e2, b2);
    Jg(e2, g2, f2);
    return g2;
  }
  function mk(a) {
    a = a.current;
    if (!a.child)
      return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function nk(a, b2) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c2 = a.retryLane;
      a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
    }
  }
  function ok(a, b2) {
    nk(a, b2);
    (a = a.alternate) && nk(a, b2);
  }
  function pk() {
    return null;
  }
  function qk(a, b2, c2) {
    var d2 = null != c2 && null != c2.hydrationOptions && c2.hydrationOptions.mutableSources || null;
    c2 = new jk(a, b2, null != c2 && true === c2.hydrate);
    b2 = nh(3, null, null, 2 === b2 ? 7 : 1 === b2 ? 3 : 0);
    c2.current = b2;
    b2.stateNode = c2;
    xg(b2);
    a[ff] = c2.current;
    cf(8 === a.nodeType ? a.parentNode : a);
    if (d2)
      for (a = 0; a < d2.length; a++) {
        b2 = d2[a];
        var e2 = b2._getVersion;
        e2 = e2(b2._source);
        null == c2.mutableSourceEagerHydrationData ? c2.mutableSourceEagerHydrationData = [b2, e2] : c2.mutableSourceEagerHydrationData.push(b2, e2);
      }
    this._internalRoot = c2;
  }
  qk.prototype.render = function(a) {
    lk(a, this._internalRoot, null, null);
  };
  qk.prototype.unmount = function() {
    var a = this._internalRoot, b2 = a.containerInfo;
    lk(null, a, null, function() {
      b2[ff] = null;
    });
  };
  function rk(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function sk(a, b2) {
    b2 || (b2 = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b2 = !(!b2 || 1 !== b2.nodeType || !b2.hasAttribute("data-reactroot")));
    if (!b2)
      for (var c2; c2 = a.lastChild; )
        a.removeChild(c2);
    return new qk(a, 0, b2 ? { hydrate: true } : void 0);
  }
  function tk(a, b2, c2, d2, e2) {
    var f2 = c2._reactRootContainer;
    if (f2) {
      var g2 = f2._internalRoot;
      if ("function" === typeof e2) {
        var h2 = e2;
        e2 = function() {
          var a2 = mk(g2);
          h2.call(a2);
        };
      }
      lk(b2, g2, a, e2);
    } else {
      f2 = c2._reactRootContainer = sk(c2, d2);
      g2 = f2._internalRoot;
      if ("function" === typeof e2) {
        var k2 = e2;
        e2 = function() {
          var a2 = mk(g2);
          k2.call(a2);
        };
      }
      Xj(function() {
        lk(b2, g2, a, e2);
      });
    }
    return mk(g2);
  }
  ec$1 = function(a) {
    if (13 === a.tag) {
      var b2 = Hg();
      Jg(a, 4, b2);
      ok(a, 4);
    }
  };
  fc$1 = function(a) {
    if (13 === a.tag) {
      var b2 = Hg();
      Jg(a, 67108864, b2);
      ok(a, 67108864);
    }
  };
  gc$1 = function(a) {
    if (13 === a.tag) {
      var b2 = Hg(), c2 = Ig(a);
      Jg(a, c2, b2);
      ok(a, c2);
    }
  };
  hc$1 = function(a, b2) {
    return b2();
  };
  yb = function(a, b2, c2) {
    switch (b2) {
      case "input":
        ab(a, c2);
        b2 = c2.name;
        if ("radio" === c2.type && null != b2) {
          for (c2 = a; c2.parentNode; )
            c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
          for (b2 = 0; b2 < c2.length; b2++) {
            var d2 = c2[b2];
            if (d2 !== a && d2.form === a.form) {
              var e2 = Db(d2);
              if (!e2)
                throw Error(y$2(90));
              Wa$1(d2);
              ab(d2, e2);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c2);
        break;
      case "select":
        b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
    }
  };
  Gb = Wj;
  Hb = function(a, b2, c2, d2, e2) {
    var f2 = X;
    X |= 4;
    try {
      return gg(98, a.bind(null, b2, c2, d2, e2));
    } finally {
      X = f2, 0 === X && (wj(), ig());
    }
  };
  Ib = function() {
    0 === (X & 49) && (Vj(), Oj());
  };
  Jb = function(a, b2) {
    var c2 = X;
    X |= 2;
    try {
      return a(b2);
    } finally {
      X = c2, 0 === X && (wj(), ig());
    }
  };
  function uk(a, b2) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!rk(b2))
      throw Error(y$2(200));
    return kk(a, b2, null, c2);
  }
  var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc$1, bundleType: 0, version: "17.0.1", rendererPackageName: "react-dom" };
  var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra$1.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    a = cc$1(a);
    return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!yk.isDisabled && yk.supportsFiber)
      try {
        Lf = yk.inject(xk), Mf = yk;
      } catch (a) {
      }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
  reactDom_production_min.createPortal = uk;
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a)
      return null;
    if (1 === a.nodeType)
      return a;
    var b2 = a._reactInternals;
    if (void 0 === b2) {
      if ("function" === typeof a.render)
        throw Error(y$2(188));
      throw Error(y$2(268, Object.keys(a)));
    }
    a = cc$1(b2);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a, b2) {
    var c2 = X;
    if (0 !== (c2 & 48))
      return a(b2);
    X |= 1;
    try {
      if (a)
        return gg(99, a.bind(null, b2));
    } finally {
      X = c2, ig();
    }
  };
  reactDom_production_min.hydrate = function(a, b2, c2) {
    if (!rk(b2))
      throw Error(y$2(200));
    return tk(null, a, b2, true, c2);
  };
  reactDom_production_min.render = function(a, b2, c2) {
    if (!rk(b2))
      throw Error(y$2(200));
    return tk(null, a, b2, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!rk(a))
      throw Error(y$2(40));
    return a._reactRootContainer ? (Xj(function() {
      tk(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[ff] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Wj;
  reactDom_production_min.unstable_createPortal = function(a, b2) {
    return uk(a, b2, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
  };
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
    if (!rk(c2))
      throw Error(y$2(200));
    if (null == a || void 0 === a._reactInternals)
      throw Error(y$2(38));
    return tk(a, b2, c2, false, d2);
  };
  reactDom_production_min.version = "17.0.1";
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = reactDom_production_min;
  }
  var reactDomExports = reactDom.exports;
  const _r = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
  const SvgB1C9Ac3221E94B98 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 49, height: 49, viewBox: "0 0 49 49", ...props }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("clipPath", { id: "checkmark_svg__a" }, /* @__PURE__ */ reactExports.createElement("path", { fill: "none", d: "M0 0h49v49H0z" }))), /* @__PURE__ */ reactExports.createElement("g", { clipPath: "url(#checkmark_svg__a)" }, /* @__PURE__ */ reactExports.createElement("path", { d: "M17.373 37.182l23.465-35.2A4.454 4.454 0 0 1 47.015.747a4.454 4.454 0 0 1 1.235 6.177l-26.727 40.09a4.455 4.455 0 0 1-7.088.428L1.072 31.854a4.454 4.454 0 0 1 .483-6.281 4.455 4.455 0 0 1 6.281.483z" })));
  const Svg32192847008Cf9Fc = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 3", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M16.54.07a5.48 5.48 0 0 0-5.48 5.48v2a1.5 1.5 0 0 0 3 0v-2a2.49 2.49 0 0 1 2.48-2.48h17.92a2.48 2.48 0 0 1 2.48 2.48v17.91a2.48 2.48 0 0 1-2.48 2.48h-2a1.5 1.5 0 0 0 0 3h2a5.49 5.49 0 0 0 5.48-5.48V5.55A5.48 5.48 0 0 0 34.46.07H16.54zM5.57 11a5.5 5.5 0 0 0-5.48 5.53v17.91a5.49 5.49 0 0 0 5.48 5.48h17.92A5.49 5.49 0 0 0 29 34.44V16.53A5.49 5.49 0 0 0 23.49 11H5.57zm0 3h17.92A2.49 2.49 0 0 1 26 16.53v17.91a2.49 2.49 0 0 1-2.51 2.48H5.57a2.48 2.48 0 0 1-2.48-2.48V16.48A2.49 2.49 0 0 1 5.57 14z" }));
  function _extends$4() {
    _extends$4 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$4.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose$4(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var ReactPropTypesSecret$5 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  var ReactPropTypesSecret_1$2 = ReactPropTypesSecret$5;
  var ReactPropTypesSecret$4 = ReactPropTypesSecret_1$2;
  function emptyFunction$2() {
  }
  function emptyFunctionWithReset$2() {
  }
  emptyFunctionWithReset$2.resetWarningCache = emptyFunction$2;
  var factoryWithThrowingShims$2 = function() {
    function shim2(props, propName, componentName, location2, propFullName, secret) {
      if (secret === ReactPropTypesSecret$4) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim2.isRequired = shim2;
    function getShim() {
      return shim2;
    }
    var ReactPropTypes = {
      array: shim2,
      bool: shim2,
      func: shim2,
      number: shim2,
      object: shim2,
      string: shim2,
      symbol: shim2,
      any: shim2,
      arrayOf: getShim,
      element: shim2,
      elementType: shim2,
      instanceOf: getShim,
      node: shim2,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset$2,
      resetWarningCache: emptyFunction$2
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  {
    factoryWithThrowingShims$2();
  }
  function hasClass(element, className) {
    if (element.classList)
      return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }
  function addClass(element, className) {
    if (element.classList)
      element.classList.add(className);
    else if (!hasClass(element, className))
      if (typeof element.className === "string")
        element.className = element.className + " " + className;
      else
        element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
  }
  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
  }
  function removeClass$1(element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else if (typeof element.className === "string") {
      element.className = replaceClassName(element.className, className);
    } else {
      element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
    }
  }
  const config = {
    disabled: false
  };
  const TransitionGroupContext = we$1.createContext(null);
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition$1 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(Transition2, _React$Component);
    function Transition2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;
      if (timeout != null && typeof timeout !== "number") {
        exit = timeout.exit;
        enter = timeout.enter;
        appear = timeout.appear !== void 0 ? timeout.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [_r.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
      if (!mounting && !enter || config.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : _r.findDOMNode(this);
      if (!exit || config.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function(event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function() {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
      this.setNextCallback(handler);
      var node = this.props.nodeRef ? this.props.nodeRef.current : _r.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };
    _proto.render = function render() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children = _this$props.children;
      _this$props.in;
      _this$props.mountOnEnter;
      _this$props.unmountOnExit;
      _this$props.appear;
      _this$props.enter;
      _this$props.exit;
      _this$props.timeout;
      _this$props.addEndListener;
      _this$props.onEnter;
      _this$props.onEntering;
      _this$props.onEntered;
      _this$props.onExit;
      _this$props.onExiting;
      _this$props.onExited;
      _this$props.nodeRef;
      var childProps = _objectWithoutPropertiesLoose$4(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ we$1.createElement(TransitionGroupContext.Provider, {
          value: null
        }, typeof children === "function" ? children(status, childProps) : we$1.cloneElement(we$1.Children.only(children), childProps))
      );
    };
    return Transition2;
  }(we$1.Component);
  Transition$1.contextType = TransitionGroupContext;
  Transition$1.propTypes = {};
  function noop$2() {
  }
  Transition$1.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
  };
  Transition$1.UNMOUNTED = UNMOUNTED;
  Transition$1.EXITED = EXITED;
  Transition$1.ENTERING = ENTERING;
  Transition$1.ENTERED = ENTERED;
  Transition$1.EXITING = EXITING;
  const Transition$2 = Transition$1;
  var _addClass = function addClass$1(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c2) {
      return addClass(node, c2);
    });
  };
  var removeClass = function removeClass2(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c2) {
      return removeClass$1(node, c2);
    });
  };
  var CSSTransition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(CSSTransition2, _React$Component);
    function CSSTransition2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };
      _this.onEnter = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
        _this.removeClasses(node, "exit");
        _this.addClass(node, appearing ? "appear" : "enter", "base");
        if (_this.props.onEnter) {
          _this.props.onEnter(maybeNode, maybeAppearing);
        }
      };
      _this.onEntering = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
        var type = appearing ? "appear" : "enter";
        _this.addClass(node, type, "active");
        if (_this.props.onEntering) {
          _this.props.onEntering(maybeNode, maybeAppearing);
        }
      };
      _this.onEntered = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
        var type = appearing ? "appear" : "enter";
        _this.removeClasses(node, type);
        _this.addClass(node, type, "done");
        if (_this.props.onEntered) {
          _this.props.onEntered(maybeNode, maybeAppearing);
        }
      };
      _this.onExit = function(maybeNode) {
        var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
        _this.removeClasses(node, "appear");
        _this.removeClasses(node, "enter");
        _this.addClass(node, "exit", "base");
        if (_this.props.onExit) {
          _this.props.onExit(maybeNode);
        }
      };
      _this.onExiting = function(maybeNode) {
        var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
        _this.addClass(node, "exit", "active");
        if (_this.props.onExiting) {
          _this.props.onExiting(maybeNode);
        }
      };
      _this.onExited = function(maybeNode) {
        var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
        _this.removeClasses(node, "exit");
        _this.addClass(node, "exit", "done");
        if (_this.props.onExited) {
          _this.props.onExited(maybeNode);
        }
      };
      _this.resolveArguments = function(maybeNode, maybeAppearing) {
        return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
      };
      _this.getClassNames = function(type) {
        var classNames2 = _this.props.classNames;
        var isStringClassNames = typeof classNames2 === "string";
        var prefix = isStringClassNames && classNames2 ? classNames2 + "-" : "";
        var baseClassName = isStringClassNames ? "" + prefix + type : classNames2[type];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
        return {
          baseClassName,
          activeClassName,
          doneClassName
        };
      };
      return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass2(node, type, phase) {
      var className = this.getClassNames(type)[phase + "ClassName"];
      var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
      if (type === "appear" && phase === "done" && doneClassName) {
        className += " " + doneClassName;
      }
      if (phase === "active") {
        node && node.scrollTop;
      }
      if (className) {
        this.appliedClasses[type][phase] = className;
        _addClass(node, className);
      }
    };
    _proto.removeClasses = function removeClasses(node, type) {
      var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type] = {};
      if (baseClassName) {
        removeClass(node, baseClassName);
      }
      if (activeClassName) {
        removeClass(node, activeClassName);
      }
      if (doneClassName) {
        removeClass(node, doneClassName);
      }
    };
    _proto.render = function render() {
      var _this$props = this.props;
      _this$props.classNames;
      var props = _objectWithoutPropertiesLoose$4(_this$props, ["classNames"]);
      return /* @__PURE__ */ we$1.createElement(Transition$2, _extends$4({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };
    return CSSTransition2;
  }(we$1.Component);
  CSSTransition.defaultProps = {
    classNames: ""
  };
  CSSTransition.propTypes = {};
  const Ut = CSSTransition;
  function _assertThisInitialized$2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function getChildMapping(children, mapFn) {
    var mapper = function mapper2(child) {
      return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
    };
    var result2 = /* @__PURE__ */ Object.create(null);
    if (children)
      reactExports.Children.map(children, function(c2) {
        return c2;
      }).forEach(function(child) {
        result2[child.key] = mapper(child);
      });
    return result2;
  }
  function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};
    function getValueForKey(key) {
      return key in next ? next[key] : prev[key];
    }
    var nextKeysPending = /* @__PURE__ */ Object.create(null);
    var pendingKeys = [];
    for (var prevKey in prev) {
      if (prevKey in next) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }
    var i2;
    var childMapping = {};
    for (var nextKey in next) {
      if (nextKeysPending[nextKey]) {
        for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
          var pendingNextKey = nextKeysPending[nextKey][i2];
          childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }
    for (i2 = 0; i2 < pendingKeys.length; i2++) {
      childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
    }
    return childMapping;
  }
  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }
  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function(child) {
      return reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, "appear", props),
        enter: getProp(child, "enter", props),
        exit: getProp(child, "exit", props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function(key) {
      var child = children[key];
      if (!reactExports.isValidElement(child))
        return;
      var hasPrev = key in prevChildMapping;
      var hasNext = key in nextChildMapping;
      var prevChild = prevChildMapping[key];
      var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
      if (hasNext && (!hasPrev || isLeaving)) {
        children[key] = reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        children[key] = reactExports.cloneElement(child, {
          in: false
        });
      } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
        children[key] = reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      }
    });
    return children;
  }
  var values = Object.values || function(obj) {
    return Object.keys(obj).map(function(k2) {
      return obj[k2];
    });
  };
  var defaultProps = {
    component: "div",
    childFactory: function childFactory(child) {
      return child;
    }
  };
  var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(TransitionGroup2, _React$Component);
    function TransitionGroup2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var handleExited = _this.handleExited.bind(_assertThisInitialized$2(_this));
      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited,
        firstRender: true
      };
      return _this;
    }
    var _proto = TransitionGroup2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };
    TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };
    _proto.handleExited = function handleExited(child, node) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping)
        return;
      if (child.props.onExited) {
        child.props.onExited(node);
      }
      if (this.mounted) {
        this.setState(function(state) {
          var children = _extends$4({}, state.children);
          delete children[child.key];
          return {
            children
          };
        });
      }
    };
    _proto.render = function render() {
      var _this$props = this.props, Component = _this$props.component, childFactory = _this$props.childFactory, props = _objectWithoutPropertiesLoose$4(_this$props, ["component", "childFactory"]);
      var contextValue = this.state.contextValue;
      var children = values(this.state.children).map(childFactory);
      delete props.appear;
      delete props.enter;
      delete props.exit;
      if (Component === null) {
        return /* @__PURE__ */ we$1.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, children);
      }
      return /* @__PURE__ */ we$1.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, /* @__PURE__ */ we$1.createElement(Component, props, children));
    };
    return TransitionGroup2;
  }(we$1.Component);
  TransitionGroup.propTypes = {};
  TransitionGroup.defaultProps = defaultProps;
  const hr = TransitionGroup;
  const Svg1Bcfd951Ee5Cd05C = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 18.672, height: 18.672, viewBox: "0 0 18.672 18.672", ...props }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("style", null, ".close_svg__a{fill:none;stroke:currentColor;stroke-width:2px}")), /* @__PURE__ */ reactExports.createElement("path", { className: "close_svg__a", d: "M.707.707l17.258 17.258M17.965.707L.707 17.965" }));
  function _extends$3() {
    _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var index$1 = reactExports.useLayoutEffect;
  var useLatest = function useLatest2(value) {
    var ref = reactExports.useRef(value);
    index$1(function() {
      ref.current = value;
    });
    return ref;
  };
  var updateRef = function updateRef2(ref, value) {
    if (typeof ref === "function") {
      ref(value);
      return;
    }
    ref.current = value;
  };
  var useComposedRef = function useComposedRef2(libRef, userRef) {
    var prevUserRef = reactExports.useRef();
    return reactExports.useCallback(function(instance) {
      libRef.current = instance;
      if (prevUserRef.current) {
        updateRef(prevUserRef.current, null);
      }
      prevUserRef.current = userRef;
      if (!userRef) {
        return;
      }
      updateRef(userRef, instance);
    }, [userRef]);
  };
  var HIDDEN_TEXTAREA_STYLE = {
    "min-height": "0",
    "max-height": "none",
    height: "0",
    visibility: "hidden",
    overflow: "hidden",
    position: "absolute",
    "z-index": "-1000",
    top: "0",
    right: "0"
  };
  var forceHiddenStyles = function forceHiddenStyles2(node) {
    Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function(key) {
      node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], "important");
    });
  };
  var forceHiddenStyles$1 = forceHiddenStyles;
  var hiddenTextarea = null;
  var getHeight = function getHeight2(node, sizingData) {
    var height = node.scrollHeight;
    if (sizingData.sizingStyle.boxSizing === "border-box") {
      return height + sizingData.borderSize;
    }
    return height - sizingData.paddingSize;
  };
  function calculateNodeHeight(sizingData, value, minRows, maxRows) {
    if (minRows === void 0) {
      minRows = 1;
    }
    if (maxRows === void 0) {
      maxRows = Infinity;
    }
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      hiddenTextarea.setAttribute("tabindex", "-1");
      hiddenTextarea.setAttribute("aria-hidden", "true");
      forceHiddenStyles$1(hiddenTextarea);
    }
    if (hiddenTextarea.parentNode === null) {
      document.body.appendChild(hiddenTextarea);
    }
    var paddingSize = sizingData.paddingSize, borderSize = sizingData.borderSize, sizingStyle = sizingData.sizingStyle;
    var boxSizing = sizingStyle.boxSizing;
    Object.keys(sizingStyle).forEach(function(_key) {
      var key = _key;
      hiddenTextarea.style[key] = sizingStyle[key];
    });
    forceHiddenStyles$1(hiddenTextarea);
    hiddenTextarea.value = value;
    var height = getHeight(hiddenTextarea, sizingData);
    hiddenTextarea.value = value;
    height = getHeight(hiddenTextarea, sizingData);
    hiddenTextarea.value = "x";
    var rowHeight = hiddenTextarea.scrollHeight - paddingSize;
    var minHeight = rowHeight * minRows;
    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    var maxHeight = rowHeight * maxRows;
    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
    return [height, rowHeight];
  }
  var noop$1 = function noop2() {
  };
  var pick = function pick2(props, obj) {
    return props.reduce(function(acc, prop) {
      acc[prop] = obj[prop];
      return acc;
    }, {});
  };
  var SIZING_STYLE = [
    "borderBottomWidth",
    "borderLeftWidth",
    "borderRightWidth",
    "borderTopWidth",
    "boxSizing",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "letterSpacing",
    "lineHeight",
    "paddingBottom",
    "paddingLeft",
    "paddingRight",
    "paddingTop",
    // non-standard
    "tabSize",
    "textIndent",
    // non-standard
    "textRendering",
    "textTransform",
    "width",
    "wordBreak"
  ];
  var isIE = !!document.documentElement.currentStyle;
  var getSizingData = function getSizingData2(node) {
    var style = window.getComputedStyle(node);
    if (style === null) {
      return null;
    }
    var sizingStyle = pick(SIZING_STYLE, style);
    var boxSizing = sizingStyle.boxSizing;
    if (boxSizing === "") {
      return null;
    }
    if (isIE && boxSizing === "border-box") {
      sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + "px";
    }
    var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
    var borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
    return {
      sizingStyle,
      paddingSize,
      borderSize
    };
  };
  var getSizingData$1 = getSizingData;
  function useListener(target, type, listener) {
    var latestListener = useLatest(listener);
    reactExports.useLayoutEffect(function() {
      var handler = function handler2(ev) {
        return latestListener.current(ev);
      };
      if (!target) {
        return;
      }
      target.addEventListener(type, handler);
      return function() {
        return target.removeEventListener(type, handler);
      };
    }, []);
  }
  var useWindowResizeListener = function useWindowResizeListener2(listener) {
    useListener(window, "resize", listener);
  };
  var useFontsLoadedListener = function useFontsLoadedListener2(listener) {
    useListener(document.fonts, "loadingdone", listener);
  };
  var _excluded = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"];
  var TextareaAutosize = function TextareaAutosize2(_ref, userRef) {
    var cacheMeasurements = _ref.cacheMeasurements, maxRows = _ref.maxRows, minRows = _ref.minRows, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? noop$1 : _ref$onChange, _ref$onHeightChange = _ref.onHeightChange, onHeightChange = _ref$onHeightChange === void 0 ? noop$1 : _ref$onHeightChange, props = _objectWithoutPropertiesLoose$3(_ref, _excluded);
    var isControlled = props.value !== void 0;
    var libRef = reactExports.useRef(null);
    var ref = useComposedRef(libRef, userRef);
    var heightRef = reactExports.useRef(0);
    var measurementsCacheRef = reactExports.useRef();
    var resizeTextarea = function resizeTextarea2() {
      var node = libRef.current;
      var nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData$1(node);
      if (!nodeSizingData) {
        return;
      }
      measurementsCacheRef.current = nodeSizingData;
      var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || "x", minRows, maxRows), height = _calculateNodeHeight[0], rowHeight = _calculateNodeHeight[1];
      if (heightRef.current !== height) {
        heightRef.current = height;
        node.style.setProperty("height", height + "px", "important");
        onHeightChange(height, {
          rowHeight
        });
      }
    };
    var handleChange = function handleChange2(event) {
      if (!isControlled) {
        resizeTextarea();
      }
      onChange(event);
    };
    {
      reactExports.useLayoutEffect(resizeTextarea);
      useWindowResizeListener(resizeTextarea);
      useFontsLoadedListener(resizeTextarea);
      return /* @__PURE__ */ reactExports.createElement("textarea", _extends$3({}, props, {
        onChange: handleChange,
        ref
      }));
    }
  };
  var index = /* @__PURE__ */ reactExports.forwardRef(TextareaAutosize);
  const SvgE7A3F077F365818E = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: 24, viewBox: "0 0 24 24", width: 24, ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M0 0h24v24H0z", fill: "none" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" }));
  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _extends$2() {
    _extends$2 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  var propTypes = { exports: {} };
  var ReactPropTypesSecret$3 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  var ReactPropTypesSecret_1$1 = ReactPropTypesSecret$3;
  var ReactPropTypesSecret$2 = ReactPropTypesSecret_1$1;
  function emptyFunction$1() {
  }
  function emptyFunctionWithReset$1() {
  }
  emptyFunctionWithReset$1.resetWarningCache = emptyFunction$1;
  var factoryWithThrowingShims$1 = function() {
    function shim2(props, propName, componentName, location2, propFullName, secret) {
      if (secret === ReactPropTypesSecret$2) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim2.isRequired = shim2;
    function getShim() {
      return shim2;
    }
    var ReactPropTypes = {
      array: shim2,
      bigint: shim2,
      bool: shim2,
      func: shim2,
      number: shim2,
      object: shim2,
      string: shim2,
      symbol: shim2,
      any: shim2,
      arrayOf: getShim,
      element: shim2,
      elementType: shim2,
      instanceOf: getShim,
      node: shim2,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset$1,
      resetWarningCache: emptyFunction$1
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  {
    propTypes.exports = factoryWithThrowingShims$1();
  }
  var propTypesExports = propTypes.exports;
  const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
  var reactIs_production_min = {};
  /** @license React v17.0.2
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b = 60103, c = 60106, d = 60107, e$1 = 60108, f = 60114, g = 60109, h = 60110, k = 60112, l = 60113, m = 60120, n$1 = 60115, p = 60116, q = 60121, r$1 = 60122, u = 60117, v = 60129, w = 60131;
  if ("function" === typeof Symbol && Symbol.for) {
    var x = Symbol.for;
    b = x("react.element");
    c = x("react.portal");
    d = x("react.fragment");
    e$1 = x("react.strict_mode");
    f = x("react.profiler");
    g = x("react.provider");
    h = x("react.context");
    k = x("react.forward_ref");
    l = x("react.suspense");
    m = x("react.suspense_list");
    n$1 = x("react.memo");
    p = x("react.lazy");
    q = x("react.block");
    r$1 = x("react.server.block");
    u = x("react.fundamental");
    v = x("react.debug_trace_mode");
    w = x("react.legacy_hidden");
  }
  function y$1(a) {
    if ("object" === typeof a && null !== a) {
      var t2 = a.$$typeof;
      switch (t2) {
        case b:
          switch (a = a.type, a) {
            case d:
            case f:
            case e$1:
            case l:
            case m:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case h:
                case k:
                case p:
                case n$1:
                case g:
                  return a;
                default:
                  return t2;
              }
          }
        case c:
          return t2;
      }
    }
  }
  var z = g, A = b, B = k, C = d, D = p, E = n$1, F = c, G$1 = f, H = e$1, I = l;
  reactIs_production_min.ContextConsumer = h;
  reactIs_production_min.ContextProvider = z;
  reactIs_production_min.Element = A;
  reactIs_production_min.ForwardRef = B;
  reactIs_production_min.Fragment = C;
  reactIs_production_min.Lazy = D;
  reactIs_production_min.Memo = E;
  reactIs_production_min.Portal = F;
  reactIs_production_min.Profiler = G$1;
  reactIs_production_min.StrictMode = H;
  reactIs_production_min.Suspense = I;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a) {
    return y$1(a) === h;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return y$1(a) === g;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === b;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return y$1(a) === k;
  };
  reactIs_production_min.isFragment = function(a) {
    return y$1(a) === d;
  };
  reactIs_production_min.isLazy = function(a) {
    return y$1(a) === p;
  };
  reactIs_production_min.isMemo = function(a) {
    return y$1(a) === n$1;
  };
  reactIs_production_min.isPortal = function(a) {
    return y$1(a) === c;
  };
  reactIs_production_min.isProfiler = function(a) {
    return y$1(a) === f;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return y$1(a) === e$1;
  };
  reactIs_production_min.isSuspense = function(a) {
    return y$1(a) === l;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === d || a === f || a === v || a === e$1 || a === l || a === m || a === w || "object" === typeof a && null !== a && (a.$$typeof === p || a.$$typeof === n$1 || a.$$typeof === g || a.$$typeof === h || a.$$typeof === k || a.$$typeof === u || a.$$typeof === q || a[0] === r$1) ? true : false;
  };
  reactIs_production_min.typeOf = y$1;
  function t(t2) {
    return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
  }
  function e(t2, e2) {
    return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
  }
  function n(t2, n2) {
    if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
      var r2 = getComputedStyle(t2, null);
      return e(r2.overflowY, n2) || e(r2.overflowX, n2) || function(t3) {
        var e2 = function(t4) {
          if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
            return null;
          try {
            return t4.ownerDocument.defaultView.frameElement;
          } catch (t5) {
            return null;
          }
        }(t3);
        return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
      }(t2);
    }
    return false;
  }
  function r(t2, e2, n2, r2, i2, o2, l2, d2) {
    return o2 < t2 && l2 > e2 || o2 > t2 && l2 < e2 ? 0 : o2 <= t2 && d2 <= n2 || l2 >= e2 && d2 >= n2 ? o2 - t2 - r2 : l2 > e2 && d2 < n2 || o2 < t2 && d2 > n2 ? l2 - e2 + i2 : 0;
  }
  function compute(e2, i2) {
    var o2 = window, l2 = i2.scrollMode, d2 = i2.block, u2 = i2.inline, h2 = i2.boundary, a = i2.skipOverflowHiddenElements, c2 = "function" == typeof h2 ? h2 : function(t2) {
      return t2 !== h2;
    };
    if (!t(e2))
      throw new TypeError("Invalid target");
    for (var f2 = document.scrollingElement || document.documentElement, s2 = [], p2 = e2; t(p2) && c2(p2); ) {
      if ((p2 = p2.parentElement) === f2) {
        s2.push(p2);
        break;
      }
      null != p2 && p2 === document.body && n(p2) && !n(document.documentElement) || null != p2 && n(p2, a) && s2.push(p2);
    }
    for (var m2 = o2.visualViewport ? o2.visualViewport.width : innerWidth, g2 = o2.visualViewport ? o2.visualViewport.height : innerHeight, w2 = window.scrollX || pageXOffset, v2 = window.scrollY || pageYOffset, W2 = e2.getBoundingClientRect(), b2 = W2.height, H2 = W2.width, y2 = W2.top, E2 = W2.right, M2 = W2.bottom, V2 = W2.left, x2 = "start" === d2 || "nearest" === d2 ? y2 : "end" === d2 ? M2 : y2 + b2 / 2, I2 = "center" === u2 ? V2 + H2 / 2 : "end" === u2 ? E2 : V2, C2 = [], T2 = 0; T2 < s2.length; T2++) {
      var k2 = s2[T2], B2 = k2.getBoundingClientRect(), D2 = B2.height, O2 = B2.width, R2 = B2.top, X2 = B2.right, Y2 = B2.bottom, L2 = B2.left;
      if ("if-needed" === l2 && y2 >= 0 && V2 >= 0 && M2 <= g2 && E2 <= m2 && y2 >= R2 && M2 <= Y2 && V2 >= L2 && E2 <= X2)
        return C2;
      var S2 = getComputedStyle(k2), j = parseInt(S2.borderLeftWidth, 10), q2 = parseInt(S2.borderTopWidth, 10), z2 = parseInt(S2.borderRightWidth, 10), A2 = parseInt(S2.borderBottomWidth, 10), F2 = 0, G2 = 0, J2 = "offsetWidth" in k2 ? k2.offsetWidth - k2.clientWidth - j - z2 : 0, K2 = "offsetHeight" in k2 ? k2.offsetHeight - k2.clientHeight - q2 - A2 : 0;
      if (f2 === k2)
        F2 = "start" === d2 ? x2 : "end" === d2 ? x2 - g2 : "nearest" === d2 ? r(v2, v2 + g2, g2, q2, A2, v2 + x2, v2 + x2 + b2, b2) : x2 - g2 / 2, G2 = "start" === u2 ? I2 : "center" === u2 ? I2 - m2 / 2 : "end" === u2 ? I2 - m2 : r(w2, w2 + m2, m2, j, z2, w2 + I2, w2 + I2 + H2, H2), F2 = Math.max(0, F2 + v2), G2 = Math.max(0, G2 + w2);
      else {
        F2 = "start" === d2 ? x2 - R2 - q2 : "end" === d2 ? x2 - Y2 + A2 + K2 : "nearest" === d2 ? r(R2, Y2, D2, q2, A2 + K2, x2, x2 + b2, b2) : x2 - (R2 + D2 / 2) + K2 / 2, G2 = "start" === u2 ? I2 - L2 - j : "center" === u2 ? I2 - (L2 + O2 / 2) + J2 / 2 : "end" === u2 ? I2 - X2 + z2 + J2 : r(L2, X2, O2, j, z2 + J2, I2, I2 + H2, H2);
        var N2 = k2.scrollLeft, P2 = k2.scrollTop;
        x2 += P2 - (F2 = Math.max(0, Math.min(P2 + F2, k2.scrollHeight - D2 + K2))), I2 += N2 - (G2 = Math.max(0, Math.min(N2 + G2, k2.scrollWidth - O2 + J2)));
      }
      C2.push({ el: k2, top: F2, left: G2 });
    }
    return C2;
  }
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
  
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
  
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
  var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign2(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign$1.apply(this, arguments);
  };
  var idCounter = 0;
  function noop() {
  }
  function scrollIntoView(node, menuNode) {
    if (!node) {
      return;
    }
    var actions = compute(node, {
      boundary: menuNode,
      block: "nearest",
      scrollMode: "if-needed"
    });
    actions.forEach(function(_ref) {
      var el2 = _ref.el, top = _ref.top, left = _ref.left;
      el2.scrollTop = top;
      el2.scrollLeft = left;
    });
  }
  function isOrContainsNode(parent, child, environment) {
    var result2 = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
    return result2;
  }
  function debounce(fn, time) {
    var timeoutId;
    function cancel() {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    }
    function wrapper() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      cancel();
      timeoutId = setTimeout(function() {
        timeoutId = null;
        fn.apply(void 0, args);
      }, time);
    }
    wrapper.cancel = cancel;
    return wrapper;
  }
  function callAllEventHandlers() {
    for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      fns[_key2] = arguments[_key2];
    }
    return function(event) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return fns.some(function(fn) {
        if (fn) {
          fn.apply(void 0, [event].concat(args));
        }
        return event.preventDownshiftDefault || event.hasOwnProperty("nativeEvent") && event.nativeEvent.preventDownshiftDefault;
      });
    };
  }
  function handleRefs() {
    for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      refs[_key4] = arguments[_key4];
    }
    return function(node) {
      refs.forEach(function(ref) {
        if (typeof ref === "function") {
          ref(node);
        } else if (ref) {
          ref.current = node;
        }
      });
    };
  }
  function generateId() {
    return String(idCounter++);
  }
  function getA11yStatusMessage$1(_ref2) {
    var isOpen = _ref2.isOpen, resultCount = _ref2.resultCount, previousResultCount = _ref2.previousResultCount;
    if (!isOpen) {
      return "";
    }
    if (!resultCount) {
      return "No results are available.";
    }
    if (resultCount !== previousResultCount) {
      return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select.";
    }
    return "";
  }
  function getState(state, props) {
    return Object.keys(state).reduce(function(prevState, key) {
      prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
      return prevState;
    }, {});
  }
  function isControlledProp(props, key) {
    return props[key] !== void 0;
  }
  function normalizeArrowKey(event) {
    var key = event.key, keyCode = event.keyCode;
    if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
      return "Arrow" + key;
    }
    return key;
  }
  function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
    if (circular === void 0) {
      circular = true;
    }
    if (itemCount === 0) {
      return -1;
    }
    var itemsLastIndex = itemCount - 1;
    if (typeof baseIndex !== "number" || baseIndex < 0 || baseIndex >= itemCount) {
      baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
    }
    var newIndex = baseIndex + moveAmount;
    if (newIndex < 0) {
      newIndex = circular ? itemsLastIndex : 0;
    } else if (newIndex > itemsLastIndex) {
      newIndex = circular ? 0 : itemsLastIndex;
    }
    var nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);
    if (nonDisabledNewIndex === -1) {
      return baseIndex >= itemCount ? -1 : baseIndex;
    }
    return nonDisabledNewIndex;
  }
  function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
    var currentElementNode = getItemNodeFromIndex(baseIndex);
    if (!currentElementNode || !currentElementNode.hasAttribute("disabled")) {
      return baseIndex;
    }
    if (moveAmount > 0) {
      for (var index2 = baseIndex + 1; index2 < itemCount; index2++) {
        if (!getItemNodeFromIndex(index2).hasAttribute("disabled")) {
          return index2;
        }
      }
    } else {
      for (var _index = baseIndex - 1; _index >= 0; _index--) {
        if (!getItemNodeFromIndex(_index).hasAttribute("disabled")) {
          return _index;
        }
      }
    }
    if (circular) {
      return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
    }
    return -1;
  }
  function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
    if (checkActiveElement === void 0) {
      checkActiveElement = true;
    }
    return downshiftElements.some(function(contextNode) {
      return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
    });
  }
  var cleanupStatus = debounce(function(documentProp) {
    getStatusDiv(documentProp).textContent = "";
  }, 500);
  function setStatus(status, documentProp) {
    var div = getStatusDiv(documentProp);
    if (!status) {
      return;
    }
    div.textContent = status;
    cleanupStatus(documentProp);
  }
  function getStatusDiv(documentProp) {
    if (documentProp === void 0) {
      documentProp = document;
    }
    var statusDiv = documentProp.getElementById("a11y-status-message");
    if (statusDiv) {
      return statusDiv;
    }
    statusDiv = documentProp.createElement("div");
    statusDiv.setAttribute("id", "a11y-status-message");
    statusDiv.setAttribute("role", "status");
    statusDiv.setAttribute("aria-live", "polite");
    statusDiv.setAttribute("aria-relevant", "additions text");
    Object.assign(statusDiv.style, {
      border: "0",
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0",
      position: "absolute",
      width: "1px"
    });
    documentProp.body.appendChild(statusDiv);
    return statusDiv;
  }
  var _excluded$3 = ["isInitialMount", "highlightedIndex", "items", "environment"];
  var dropdownDefaultStateValues = {
    highlightedIndex: -1,
    isOpen: false,
    selectedItem: null,
    inputValue: ""
  };
  function callOnChangeProps(action, state, newState) {
    var props = action.props, type = action.type;
    var changes = {};
    Object.keys(state).forEach(function(key) {
      invokeOnChangeHandler(key, action, state, newState);
      if (newState[key] !== state[key]) {
        changes[key] = newState[key];
      }
    });
    if (props.onStateChange && Object.keys(changes).length) {
      props.onStateChange(_extends$2({
        type
      }, changes));
    }
  }
  function invokeOnChangeHandler(key, action, state, newState) {
    var props = action.props, type = action.type;
    var handler = "on" + capitalizeString(key) + "Change";
    if (props[handler] && newState[key] !== void 0 && newState[key] !== state[key]) {
      props[handler](_extends$2({
        type
      }, newState));
    }
  }
  function stateReducer(s2, a) {
    return a.changes;
  }
  function getA11ySelectionMessage(selectionParameters) {
    var selectedItem = selectionParameters.selectedItem, itemToStringLocal = selectionParameters.itemToString;
    return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : "";
  }
  var updateA11yStatus = debounce(function(getA11yMessage, document2) {
    setStatus(getA11yMessage(), document2);
  }, 200);
  var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  function useElementIds(_ref) {
    var _ref$id = _ref.id, id2 = _ref$id === void 0 ? "downshift-" + generateId() : _ref$id, labelId = _ref.labelId, menuId = _ref.menuId, getItemId = _ref.getItemId, toggleButtonId = _ref.toggleButtonId, inputId = _ref.inputId;
    var elementIdsRef = reactExports.useRef({
      labelId: labelId || id2 + "-label",
      menuId: menuId || id2 + "-menu",
      getItemId: getItemId || function(index2) {
        return id2 + "-item-" + index2;
      },
      toggleButtonId: toggleButtonId || id2 + "-toggle-button",
      inputId: inputId || id2 + "-input"
    });
    return elementIdsRef.current;
  }
  function getItemIndex(index2, item, items) {
    if (index2 !== void 0) {
      return index2;
    }
    if (items.length === 0) {
      return -1;
    }
    return items.indexOf(item);
  }
  function itemToString(item) {
    return item ? String(item) : "";
  }
  function capitalizeString(string) {
    return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
  }
  function useLatestRef(val) {
    var ref = reactExports.useRef(val);
    ref.current = val;
    return ref;
  }
  function useEnhancedReducer(reducer, initialState, props) {
    var prevStateRef = reactExports.useRef();
    var actionRef = reactExports.useRef();
    var enhancedReducer = reactExports.useCallback(function(state2, action2) {
      actionRef.current = action2;
      state2 = getState(state2, action2.props);
      var changes = reducer(state2, action2);
      var newState = action2.props.stateReducer(state2, _extends$2({}, action2, {
        changes
      }));
      return newState;
    }, [reducer]);
    var _useReducer = reactExports.useReducer(enhancedReducer, initialState), state = _useReducer[0], dispatch = _useReducer[1];
    var propsRef = useLatestRef(props);
    var dispatchWithProps = reactExports.useCallback(function(action2) {
      return dispatch(_extends$2({
        props: propsRef.current
      }, action2));
    }, [propsRef]);
    var action = actionRef.current;
    reactExports.useEffect(function() {
      if (action && prevStateRef.current && prevStateRef.current !== state) {
        callOnChangeProps(action, getState(prevStateRef.current, action.props), state);
      }
      prevStateRef.current = state;
    }, [state, props, action]);
    return [state, dispatchWithProps];
  }
  var defaultProps$3 = {
    itemToString,
    stateReducer,
    getA11ySelectionMessage,
    scrollIntoView,
    circularNavigation: false,
    environment: (
      /* istanbul ignore next (ssr) */
      typeof window === "undefined" ? {} : window
    )
  };
  function getDefaultValue$1(props, propKey, defaultStateValues) {
    if (defaultStateValues === void 0) {
      defaultStateValues = dropdownDefaultStateValues;
    }
    var defaultPropKey = "default" + capitalizeString(propKey);
    if (defaultPropKey in props) {
      return props[defaultPropKey];
    }
    return defaultStateValues[propKey];
  }
  function getInitialValue$1(props, propKey, defaultStateValues) {
    if (defaultStateValues === void 0) {
      defaultStateValues = dropdownDefaultStateValues;
    }
    if (propKey in props) {
      return props[propKey];
    }
    var initialPropKey = "initial" + capitalizeString(propKey);
    if (initialPropKey in props) {
      return props[initialPropKey];
    }
    return getDefaultValue$1(props, propKey, defaultStateValues);
  }
  function getInitialState$2(props) {
    var selectedItem = getInitialValue$1(props, "selectedItem");
    var isOpen = getInitialValue$1(props, "isOpen");
    var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
    var inputValue = getInitialValue$1(props, "inputValue");
    return {
      highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,
      isOpen,
      selectedItem,
      inputValue
    };
  }
  function getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {
    var items = props.items, initialHighlightedIndex = props.initialHighlightedIndex, defaultHighlightedIndex = props.defaultHighlightedIndex;
    var selectedItem = state.selectedItem, highlightedIndex = state.highlightedIndex;
    if (items.length === 0) {
      return -1;
    }
    if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex) {
      return initialHighlightedIndex;
    }
    if (defaultHighlightedIndex !== void 0) {
      return defaultHighlightedIndex;
    }
    if (selectedItem) {
      if (offset === 0) {
        return items.indexOf(selectedItem);
      }
      return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);
    }
    if (offset === 0) {
      return -1;
    }
    return offset < 0 ? items.length - 1 : 0;
  }
  function useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {
    var mouseAndTouchTrackersRef = reactExports.useRef({
      isMouseDown: false,
      isTouchMove: false
    });
    reactExports.useEffect(function() {
      var onMouseDown = function onMouseDown2() {
        mouseAndTouchTrackersRef.current.isMouseDown = true;
      };
      var onMouseUp = function onMouseUp2(event) {
        mouseAndTouchTrackersRef.current.isMouseDown = false;
        if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref) {
          return ref.current;
        }), environment)) {
          handleBlur();
        }
      };
      var onTouchStart = function onTouchStart2() {
        mouseAndTouchTrackersRef.current.isTouchMove = false;
      };
      var onTouchMove = function onTouchMove2() {
        mouseAndTouchTrackersRef.current.isTouchMove = true;
      };
      var onTouchEnd = function onTouchEnd2(event) {
        if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref) {
          return ref.current;
        }), environment, false)) {
          handleBlur();
        }
      };
      environment.addEventListener("mousedown", onMouseDown);
      environment.addEventListener("mouseup", onMouseUp);
      environment.addEventListener("touchstart", onTouchStart);
      environment.addEventListener("touchmove", onTouchMove);
      environment.addEventListener("touchend", onTouchEnd);
      return function cleanup() {
        environment.removeEventListener("mousedown", onMouseDown);
        environment.removeEventListener("mouseup", onMouseUp);
        environment.removeEventListener("touchstart", onTouchStart);
        environment.removeEventListener("touchmove", onTouchMove);
        environment.removeEventListener("touchend", onTouchEnd);
      };
    }, [isOpen, environment]);
    return mouseAndTouchTrackersRef;
  }
  var useGetterPropsCalledChecker = function useGetterPropsCalledChecker2() {
    return noop;
  };
  function useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {
    var isInitialMount = _ref2.isInitialMount, highlightedIndex = _ref2.highlightedIndex, items = _ref2.items, environment = _ref2.environment, rest = _objectWithoutPropertiesLoose$2(_ref2, _excluded$3);
    reactExports.useEffect(function() {
      if (isInitialMount || false) {
        return;
      }
      updateA11yStatus(function() {
        return getA11yMessage(_extends$2({
          highlightedIndex,
          highlightedItem: items[highlightedIndex],
          resultCount: items.length
        }, rest));
      }, environment.document);
    }, dependencyArray);
  }
  function useScrollIntoView(_ref3) {
    var highlightedIndex = _ref3.highlightedIndex, isOpen = _ref3.isOpen, itemRefs = _ref3.itemRefs, getItemNodeFromIndex = _ref3.getItemNodeFromIndex, menuElement = _ref3.menuElement, scrollIntoViewProp = _ref3.scrollIntoView;
    var shouldScrollRef = reactExports.useRef(true);
    useIsomorphicLayoutEffect$1(function() {
      if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
        return;
      }
      if (shouldScrollRef.current === false) {
        shouldScrollRef.current = true;
      } else {
        scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
      }
    }, [highlightedIndex]);
    return shouldScrollRef;
  }
  var useControlPropsValidator = noop;
  function downshiftCommonReducer(state, action, stateChangeTypes) {
    var type = action.type, props = action.props;
    var changes;
    switch (type) {
      case stateChangeTypes.ItemMouseMove:
        changes = {
          highlightedIndex: action.index
        };
        break;
      case stateChangeTypes.MenuMouseLeave:
        changes = {
          highlightedIndex: -1
        };
        break;
      case stateChangeTypes.ToggleButtonClick:
      case stateChangeTypes.FunctionToggleMenu:
        changes = {
          isOpen: !state.isOpen,
          highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
        };
        break;
      case stateChangeTypes.FunctionOpenMenu:
        changes = {
          isOpen: true,
          highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
        };
        break;
      case stateChangeTypes.FunctionCloseMenu:
        changes = {
          isOpen: false
        };
        break;
      case stateChangeTypes.FunctionSetHighlightedIndex:
        changes = {
          highlightedIndex: action.highlightedIndex
        };
        break;
      case stateChangeTypes.FunctionSetInputValue:
        changes = {
          inputValue: action.inputValue
        };
        break;
      case stateChangeTypes.FunctionReset:
        changes = {
          highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
          isOpen: getDefaultValue$1(props, "isOpen"),
          selectedItem: getDefaultValue$1(props, "selectedItem"),
          inputValue: getDefaultValue$1(props, "inputValue")
        };
        break;
      default:
        throw new Error("Reducer called without proper action type.");
    }
    return _extends$2({}, state, changes);
  }
  ({
    items: PropTypes.array.isRequired,
    itemToString: PropTypes.func,
    getA11yStatusMessage: PropTypes.func,
    getA11ySelectionMessage: PropTypes.func,
    circularNavigation: PropTypes.bool,
    highlightedIndex: PropTypes.number,
    defaultHighlightedIndex: PropTypes.number,
    initialHighlightedIndex: PropTypes.number,
    isOpen: PropTypes.bool,
    defaultIsOpen: PropTypes.bool,
    initialIsOpen: PropTypes.bool,
    selectedItem: PropTypes.any,
    initialSelectedItem: PropTypes.any,
    defaultSelectedItem: PropTypes.any,
    id: PropTypes.string,
    labelId: PropTypes.string,
    menuId: PropTypes.string,
    getItemId: PropTypes.func,
    toggleButtonId: PropTypes.string,
    stateReducer: PropTypes.func,
    onSelectedItemChange: PropTypes.func,
    onHighlightedIndexChange: PropTypes.func,
    onStateChange: PropTypes.func,
    onIsOpenChange: PropTypes.func,
    environment: PropTypes.shape({
      addEventListener: PropTypes.func,
      removeEventListener: PropTypes.func,
      document: PropTypes.shape({
        getElementById: PropTypes.func,
        activeElement: PropTypes.any,
        body: PropTypes.any
      })
    })
  });
  function getA11yStatusMessage(_a3) {
    var isOpen = _a3.isOpen, resultCount = _a3.resultCount, previousResultCount = _a3.previousResultCount;
    if (!isOpen) {
      return "";
    }
    if (!resultCount) {
      return "No results are available.";
    }
    if (resultCount !== previousResultCount) {
      return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.";
    }
    return "";
  }
  __assign$1(__assign$1({}, defaultProps$3), { getA11yStatusMessage });
  var InputKeyDownArrowDown = 0;
  var InputKeyDownArrowUp = 1;
  var InputKeyDownEscape = 2;
  var InputKeyDownHome = 3;
  var InputKeyDownEnd = 4;
  var InputKeyDownEnter = 5;
  var InputChange = 6;
  var InputBlur = 7;
  var MenuMouseLeave = 8;
  var ItemMouseMove = 9;
  var ItemClick = 10;
  var ToggleButtonClick = 11;
  var FunctionToggleMenu = 12;
  var FunctionOpenMenu = 13;
  var FunctionCloseMenu = 14;
  var FunctionSetHighlightedIndex = 15;
  var FunctionSelectItem = 16;
  var FunctionSetInputValue = 17;
  var FunctionReset$1 = 18;
  var ControlledPropUpdatedSelectedItem = 19;
  var stateChangeTypes$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    InputKeyDownArrowDown,
    InputKeyDownArrowUp,
    InputKeyDownEscape,
    InputKeyDownHome,
    InputKeyDownEnd,
    InputKeyDownEnter,
    InputChange,
    InputBlur,
    MenuMouseLeave,
    ItemMouseMove,
    ItemClick,
    ToggleButtonClick,
    FunctionToggleMenu,
    FunctionOpenMenu,
    FunctionCloseMenu,
    FunctionSetHighlightedIndex,
    FunctionSelectItem,
    FunctionSetInputValue,
    FunctionReset: FunctionReset$1,
    ControlledPropUpdatedSelectedItem
  });
  function getInitialState$1(props) {
    var initialState = getInitialState$2(props);
    var selectedItem = initialState.selectedItem;
    var inputValue = initialState.inputValue;
    if (inputValue === "" && selectedItem && props.defaultInputValue === void 0 && props.initialInputValue === void 0 && props.inputValue === void 0) {
      inputValue = props.itemToString(selectedItem);
    }
    return _extends$2({}, initialState, {
      inputValue
    });
  }
  ({
    items: PropTypes.array.isRequired,
    itemToString: PropTypes.func,
    getA11yStatusMessage: PropTypes.func,
    getA11ySelectionMessage: PropTypes.func,
    circularNavigation: PropTypes.bool,
    highlightedIndex: PropTypes.number,
    defaultHighlightedIndex: PropTypes.number,
    initialHighlightedIndex: PropTypes.number,
    isOpen: PropTypes.bool,
    defaultIsOpen: PropTypes.bool,
    initialIsOpen: PropTypes.bool,
    selectedItem: PropTypes.any,
    initialSelectedItem: PropTypes.any,
    defaultSelectedItem: PropTypes.any,
    inputValue: PropTypes.string,
    defaultInputValue: PropTypes.string,
    initialInputValue: PropTypes.string,
    id: PropTypes.string,
    labelId: PropTypes.string,
    menuId: PropTypes.string,
    getItemId: PropTypes.func,
    inputId: PropTypes.string,
    toggleButtonId: PropTypes.string,
    stateReducer: PropTypes.func,
    onSelectedItemChange: PropTypes.func,
    onHighlightedIndexChange: PropTypes.func,
    onStateChange: PropTypes.func,
    onIsOpenChange: PropTypes.func,
    onInputValueChange: PropTypes.func,
    environment: PropTypes.shape({
      addEventListener: PropTypes.func,
      removeEventListener: PropTypes.func,
      document: PropTypes.shape({
        getElementById: PropTypes.func,
        activeElement: PropTypes.any,
        body: PropTypes.any
      })
    })
  });
  function useControlledReducer(reducer, initialState, props) {
    var previousSelectedItemRef = reactExports.useRef();
    var _useEnhancedReducer = useEnhancedReducer(reducer, initialState, props), state = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
    reactExports.useEffect(function() {
      if (isControlledProp(props, "selectedItem")) {
        if (previousSelectedItemRef.current !== props.selectedItem) {
          dispatch({
            type: ControlledPropUpdatedSelectedItem,
            inputValue: props.itemToString(props.selectedItem)
          });
        }
        previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
      }
    });
    return [getState(state, props), dispatch];
  }
  var validatePropTypes$1 = noop;
  var defaultProps$1 = _extends$2({}, defaultProps$3, {
    getA11yStatusMessage: getA11yStatusMessage$1,
    circularNavigation: true
  });
  function downshiftUseComboboxReducer(state, action) {
    var type = action.type, props = action.props, shiftKey = action.shiftKey;
    var changes;
    switch (type) {
      case ItemClick:
        changes = {
          isOpen: getDefaultValue$1(props, "isOpen"),
          highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
          selectedItem: props.items[action.index],
          inputValue: props.itemToString(props.items[action.index])
        };
        break;
      case InputKeyDownArrowDown:
        if (state.isOpen) {
          changes = {
            highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
          };
        } else {
          changes = {
            highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
            isOpen: props.items.length >= 0
          };
        }
        break;
      case InputKeyDownArrowUp:
        if (state.isOpen) {
          changes = {
            highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
          };
        } else {
          changes = {
            highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
            isOpen: props.items.length >= 0
          };
        }
        break;
      case InputKeyDownEnter:
        changes = _extends$2({}, state.isOpen && state.highlightedIndex >= 0 && {
          selectedItem: props.items[state.highlightedIndex],
          isOpen: getDefaultValue$1(props, "isOpen"),
          highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
          inputValue: props.itemToString(props.items[state.highlightedIndex])
        });
        break;
      case InputKeyDownEscape:
        changes = _extends$2({
          isOpen: false,
          highlightedIndex: -1
        }, !state.isOpen && {
          selectedItem: null,
          inputValue: ""
        });
        break;
      case InputKeyDownHome:
        changes = {
          highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
        };
        break;
      case InputKeyDownEnd:
        changes = {
          highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
        };
        break;
      case InputBlur:
        changes = _extends$2({
          isOpen: false,
          highlightedIndex: -1
        }, state.highlightedIndex >= 0 && action.selectItem && {
          selectedItem: props.items[state.highlightedIndex],
          inputValue: props.itemToString(props.items[state.highlightedIndex])
        });
        break;
      case InputChange:
        changes = {
          isOpen: true,
          highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
          inputValue: action.inputValue
        };
        break;
      case FunctionSelectItem:
        changes = {
          selectedItem: action.selectedItem,
          inputValue: props.itemToString(action.selectedItem)
        };
        break;
      case ControlledPropUpdatedSelectedItem:
        changes = {
          inputValue: action.inputValue
        };
        break;
      default:
        return downshiftCommonReducer(state, action, stateChangeTypes$1);
    }
    return _extends$2({}, state, changes);
  }
  var _excluded$1 = ["onMouseLeave", "refKey", "ref"], _excluded2$1 = ["item", "index", "refKey", "ref", "onMouseMove", "onClick", "onPress"], _excluded3 = ["onClick", "onPress", "refKey", "ref"], _excluded4 = ["onKeyDown", "onChange", "onInput", "onBlur", "onChangeText", "refKey", "ref"], _excluded5 = ["refKey", "ref"];
  useCombobox.stateChangeTypes = stateChangeTypes$1;
  function useCombobox(userProps) {
    if (userProps === void 0) {
      userProps = {};
    }
    validatePropTypes$1();
    var props = _extends$2({}, defaultProps$1, userProps);
    var initialIsOpen = props.initialIsOpen, defaultIsOpen = props.defaultIsOpen, items = props.items, scrollIntoView2 = props.scrollIntoView, environment = props.environment, getA11yStatusMessage2 = props.getA11yStatusMessage, getA11ySelectionMessage2 = props.getA11ySelectionMessage, itemToString2 = props.itemToString;
    var initialState = getInitialState$1(props);
    var _useControlledReducer = useControlledReducer(downshiftUseComboboxReducer, initialState, props), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
    var isOpen = state.isOpen, highlightedIndex = state.highlightedIndex, selectedItem = state.selectedItem, inputValue = state.inputValue;
    var menuRef = reactExports.useRef(null);
    var itemRefs = reactExports.useRef({});
    var inputRef = reactExports.useRef(null);
    var toggleButtonRef = reactExports.useRef(null);
    var comboboxRef = reactExports.useRef(null);
    var isInitialMountRef = reactExports.useRef(true);
    var elementIds = useElementIds(props);
    var previousResultCountRef = reactExports.useRef();
    var latest = useLatestRef({
      state,
      props
    });
    var getItemNodeFromIndex = reactExports.useCallback(function(index2) {
      return itemRefs.current[elementIds.getItemId(index2)];
    }, [elementIds]);
    useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], _extends$2({
      isInitialMount: isInitialMountRef.current,
      previousResultCount: previousResultCountRef.current,
      items,
      environment,
      itemToString: itemToString2
    }, state));
    useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], _extends$2({
      isInitialMount: isInitialMountRef.current,
      previousResultCount: previousResultCountRef.current,
      items,
      environment,
      itemToString: itemToString2
    }, state));
    var shouldScrollRef = useScrollIntoView({
      menuElement: menuRef.current,
      highlightedIndex,
      isOpen,
      itemRefs,
      scrollIntoView: scrollIntoView2,
      getItemNodeFromIndex
    });
    useControlPropsValidator({
      isInitialMount: isInitialMountRef.current,
      props,
      state
    });
    reactExports.useEffect(function() {
      var focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;
      if (focusOnOpen && inputRef.current) {
        inputRef.current.focus();
      }
    }, []);
    reactExports.useEffect(function() {
      if (isInitialMountRef.current) {
        return;
      }
      previousResultCountRef.current = items.length;
    });
    var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, function() {
      dispatch({
        type: InputBlur,
        selectItem: false
      });
    });
    var setGetterPropCallInfo = useGetterPropsCalledChecker();
    reactExports.useEffect(function() {
      isInitialMountRef.current = false;
    }, []);
    reactExports.useEffect(function() {
      if (!isOpen) {
        itemRefs.current = {};
      }
    }, [isOpen]);
    var inputKeyDownHandlers = reactExports.useMemo(function() {
      return {
        ArrowDown: function ArrowDown(event) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownArrowDown,
            shiftKey: event.shiftKey,
            getItemNodeFromIndex
          });
        },
        ArrowUp: function ArrowUp(event) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownArrowUp,
            shiftKey: event.shiftKey,
            getItemNodeFromIndex
          });
        },
        Home: function Home(event) {
          if (!latest.current.state.isOpen) {
            return;
          }
          event.preventDefault();
          dispatch({
            type: InputKeyDownHome,
            getItemNodeFromIndex
          });
        },
        End: function End(event) {
          if (!latest.current.state.isOpen) {
            return;
          }
          event.preventDefault();
          dispatch({
            type: InputKeyDownEnd,
            getItemNodeFromIndex
          });
        },
        Escape: function Escape() {
          var latestState = latest.current.state;
          if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {
            dispatch({
              type: InputKeyDownEscape
            });
          }
        },
        Enter: function Enter(event) {
          var latestState = latest.current.state;
          if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229) {
            return;
          }
          event.preventDefault();
          dispatch({
            type: InputKeyDownEnter,
            getItemNodeFromIndex
          });
        }
      };
    }, [dispatch, latest, getItemNodeFromIndex]);
    var getLabelProps = reactExports.useCallback(function(labelProps) {
      return _extends$2({
        id: elementIds.labelId,
        htmlFor: elementIds.inputId
      }, labelProps);
    }, [elementIds]);
    var getMenuProps = reactExports.useCallback(function(_temp, _temp2) {
      var _extends2;
      var _ref = _temp === void 0 ? {} : _temp, onMouseLeave = _ref.onMouseLeave, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref = _ref.ref, rest = _objectWithoutPropertiesLoose$2(_ref, _excluded$1);
      var _ref2 = _temp2 === void 0 ? {} : _temp2;
      _ref2.suppressRefError;
      return _extends$2((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function(menuNode) {
        menuRef.current = menuNode;
      }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, function() {
        dispatch({
          type: MenuMouseLeave
        });
      }), _extends2), rest);
    }, [dispatch, setGetterPropCallInfo, elementIds]);
    var getItemProps = reactExports.useCallback(function(_temp3) {
      var _extends3, _ref4;
      var _ref3 = _temp3 === void 0 ? {} : _temp3, item = _ref3.item, index2 = _ref3.index, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref = _ref3.ref, onMouseMove = _ref3.onMouseMove, onClick = _ref3.onClick;
      _ref3.onPress;
      var rest = _objectWithoutPropertiesLoose$2(_ref3, _excluded2$1);
      var _latest$current = latest.current, latestProps = _latest$current.props, latestState = _latest$current.state;
      var itemIndex = getItemIndex(index2, item, latestProps.items);
      if (itemIndex < 0) {
        throw new Error("Pass either item or item index in getItemProps!");
      }
      var onSelectKey = "onClick";
      var customClickHandler = onClick;
      var itemHandleMouseMove = function itemHandleMouseMove2() {
        if (index2 === latestState.highlightedIndex) {
          return;
        }
        shouldScrollRef.current = false;
        dispatch({
          type: ItemMouseMove,
          index: index2
        });
      };
      var itemHandleClick = function itemHandleClick2() {
        dispatch({
          type: ItemClick,
          index: index2
        });
        if (inputRef.current) {
          inputRef.current.focus();
        }
      };
      return _extends$2((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function(itemNode) {
        if (itemNode) {
          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;
        }
      }), _extends3.role = "option", _extends3["aria-selected"] = "" + (itemIndex === latestState.highlightedIndex), _extends3.id = elementIds.getItemId(itemIndex), _extends3), !rest.disabled && (_ref4 = {
        onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove)
      }, _ref4[onSelectKey] = callAllEventHandlers(customClickHandler, itemHandleClick), _ref4), rest);
    }, [dispatch, latest, shouldScrollRef, elementIds]);
    var getToggleButtonProps = reactExports.useCallback(function(_temp4) {
      var _extends4;
      var _ref5 = _temp4 === void 0 ? {} : _temp4, onClick = _ref5.onClick;
      _ref5.onPress;
      var _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref = _ref5.ref, rest = _objectWithoutPropertiesLoose$2(_ref5, _excluded3);
      var toggleButtonHandleClick = function toggleButtonHandleClick2() {
        dispatch({
          type: ToggleButtonClick
        });
        if (!latest.current.state.isOpen && inputRef.current) {
          inputRef.current.focus();
        }
      };
      return _extends$2((_extends4 = {}, _extends4[refKey] = handleRefs(ref, function(toggleButtonNode) {
        toggleButtonRef.current = toggleButtonNode;
      }), _extends4.id = elementIds.toggleButtonId, _extends4.tabIndex = -1, _extends4), !rest.disabled && _extends$2({}, {
        onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)
      }), rest);
    }, [dispatch, latest, elementIds]);
    var getInputProps = reactExports.useCallback(function(_temp5, _temp6) {
      var _extends5;
      var _ref6 = _temp5 === void 0 ? {} : _temp5, onKeyDown = _ref6.onKeyDown, onChange = _ref6.onChange, onInput = _ref6.onInput, onBlur = _ref6.onBlur;
      _ref6.onChangeText;
      var _ref6$refKey = _ref6.refKey, refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey, ref = _ref6.ref, rest = _objectWithoutPropertiesLoose$2(_ref6, _excluded4);
      var _ref7 = _temp6 === void 0 ? {} : _temp6;
      _ref7.suppressRefError;
      var latestState = latest.current.state;
      var inputHandleKeyDown = function inputHandleKeyDown2(event) {
        var key = normalizeArrowKey(event);
        if (key && inputKeyDownHandlers[key]) {
          inputKeyDownHandlers[key](event);
        }
      };
      var inputHandleChange = function inputHandleChange2(event) {
        dispatch({
          type: InputChange,
          inputValue: event.target.value
        });
      };
      var inputHandleBlur = function inputHandleBlur2() {
        if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
          dispatch({
            type: InputBlur,
            selectItem: true
          });
        }
      };
      var onChangeKey = "onChange";
      var eventHandlers = {};
      if (!rest.disabled) {
        var _eventHandlers;
        eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, inputHandleBlur), _eventHandlers);
      }
      return _extends$2((_extends5 = {}, _extends5[refKey] = handleRefs(ref, function(inputNode) {
        inputRef.current = inputNode;
      }), _extends5.id = elementIds.inputId, _extends5["aria-autocomplete"] = "list", _extends5["aria-controls"] = elementIds.menuId, _extends5), latestState.isOpen && latestState.highlightedIndex > -1 && {
        "aria-activedescendant": elementIds.getItemId(latestState.highlightedIndex)
      }, {
        "aria-labelledby": elementIds.labelId,
        // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
        // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
        autoComplete: "off",
        value: latestState.inputValue
      }, eventHandlers, rest);
    }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);
    var getComboboxProps = reactExports.useCallback(function(_temp7, _temp8) {
      var _extends6;
      var _ref8 = _temp7 === void 0 ? {} : _temp7, _ref8$refKey = _ref8.refKey, refKey = _ref8$refKey === void 0 ? "ref" : _ref8$refKey, ref = _ref8.ref, rest = _objectWithoutPropertiesLoose$2(_ref8, _excluded5);
      var _ref9 = _temp8 === void 0 ? {} : _temp8;
      _ref9.suppressRefError;
      return _extends$2((_extends6 = {}, _extends6[refKey] = handleRefs(ref, function(comboboxNode) {
        comboboxRef.current = comboboxNode;
      }), _extends6.role = "combobox", _extends6["aria-haspopup"] = "listbox", _extends6["aria-owns"] = elementIds.menuId, _extends6["aria-expanded"] = latest.current.state.isOpen, _extends6), rest);
    }, [latest, setGetterPropCallInfo, elementIds]);
    var toggleMenu = reactExports.useCallback(function() {
      dispatch({
        type: FunctionToggleMenu
      });
    }, [dispatch]);
    var closeMenu = reactExports.useCallback(function() {
      dispatch({
        type: FunctionCloseMenu
      });
    }, [dispatch]);
    var openMenu = reactExports.useCallback(function() {
      dispatch({
        type: FunctionOpenMenu
      });
    }, [dispatch]);
    var setHighlightedIndex = reactExports.useCallback(function(newHighlightedIndex) {
      dispatch({
        type: FunctionSetHighlightedIndex,
        highlightedIndex: newHighlightedIndex
      });
    }, [dispatch]);
    var selectItem = reactExports.useCallback(function(newSelectedItem) {
      dispatch({
        type: FunctionSelectItem,
        selectedItem: newSelectedItem
      });
    }, [dispatch]);
    var setInputValue2 = reactExports.useCallback(function(newInputValue) {
      dispatch({
        type: FunctionSetInputValue,
        inputValue: newInputValue
      });
    }, [dispatch]);
    var reset = reactExports.useCallback(function() {
      dispatch({
        type: FunctionReset$1
      });
    }, [dispatch]);
    return {
      // prop getters.
      getItemProps,
      getLabelProps,
      getMenuProps,
      getInputProps,
      getComboboxProps,
      getToggleButtonProps,
      // actions.
      toggleMenu,
      openMenu,
      closeMenu,
      setHighlightedIndex,
      setInputValue: setInputValue2,
      selectItem,
      reset,
      // state.
      highlightedIndex,
      isOpen,
      selectedItem,
      inputValue
    };
  }
  function getA11yRemovalMessage(selectionParameters) {
    var removedSelectedItem = selectionParameters.removedSelectedItem, itemToStringLocal = selectionParameters.itemToString;
    return itemToStringLocal(removedSelectedItem) + " has been removed.";
  }
  ({
    selectedItems: PropTypes.array,
    initialSelectedItems: PropTypes.array,
    defaultSelectedItems: PropTypes.array,
    itemToString: PropTypes.func,
    getA11yRemovalMessage: PropTypes.func,
    stateReducer: PropTypes.func,
    activeIndex: PropTypes.number,
    initialActiveIndex: PropTypes.number,
    defaultActiveIndex: PropTypes.number,
    onActiveIndexChange: PropTypes.func,
    onSelectedItemsChange: PropTypes.func,
    keyNavigationNext: PropTypes.string,
    keyNavigationPrevious: PropTypes.string,
    environment: PropTypes.shape({
      addEventListener: PropTypes.func,
      removeEventListener: PropTypes.func,
      document: PropTypes.shape({
        getElementById: PropTypes.func,
        activeElement: PropTypes.any,
        body: PropTypes.any
      })
    })
  });
  ({
    itemToString: defaultProps$3.itemToString,
    stateReducer: defaultProps$3.stateReducer,
    environment: defaultProps$3.environment,
    getA11yRemovalMessage,
    keyNavigationNext: "ArrowRight",
    keyNavigationPrevious: "ArrowLeft"
  });
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
  
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
  
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  function __extends(d2, b2) {
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  }
  var VIEWBOX_WIDTH = 100;
  var VIEWBOX_HEIGHT = 100;
  var VIEWBOX_HEIGHT_HALF = 50;
  var VIEWBOX_CENTER_X = 50;
  var VIEWBOX_CENTER_Y = 50;
  function Path(_a3) {
    var className = _a3.className, counterClockwise = _a3.counterClockwise, dashRatio = _a3.dashRatio, pathRadius = _a3.pathRadius, strokeWidth = _a3.strokeWidth, style = _a3.style;
    return reactExports.createElement("path", { className, style: Object.assign({}, style, getDashStyle({ pathRadius, dashRatio, counterClockwise })), d: getPathDescription({
      pathRadius,
      counterClockwise
    }), strokeWidth, fillOpacity: 0 });
  }
  function getPathDescription(_a3) {
    var pathRadius = _a3.pathRadius, counterClockwise = _a3.counterClockwise;
    var radius = pathRadius;
    var rotation = counterClockwise ? 1 : 0;
    return "\n      M " + VIEWBOX_CENTER_X + "," + VIEWBOX_CENTER_Y + "\n      m 0,-" + radius + "\n      a " + radius + "," + radius + " " + rotation + " 1 1 0," + 2 * radius + "\n      a " + radius + "," + radius + " " + rotation + " 1 1 0,-" + 2 * radius + "\n    ";
  }
  function getDashStyle(_a3) {
    var counterClockwise = _a3.counterClockwise, dashRatio = _a3.dashRatio, pathRadius = _a3.pathRadius;
    var diameter = Math.PI * 2 * pathRadius;
    var gapLength = (1 - dashRatio) * diameter;
    return {
      strokeDasharray: diameter + "px " + diameter + "px",
      strokeDashoffset: (counterClockwise ? -gapLength : gapLength) + "px"
    };
  }
  var CircularProgressbar = function(_super) {
    __extends(CircularProgressbar2, _super);
    function CircularProgressbar2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CircularProgressbar2.prototype.getBackgroundPadding = function() {
      if (!this.props.background) {
        return 0;
      }
      return this.props.backgroundPadding;
    };
    CircularProgressbar2.prototype.getPathRadius = function() {
      return VIEWBOX_HEIGHT_HALF - this.props.strokeWidth / 2 - this.getBackgroundPadding();
    };
    CircularProgressbar2.prototype.getPathRatio = function() {
      var _a3 = this.props, value = _a3.value, minValue = _a3.minValue, maxValue = _a3.maxValue;
      var boundedValue = Math.min(Math.max(value, minValue), maxValue);
      return (boundedValue - minValue) / (maxValue - minValue);
    };
    CircularProgressbar2.prototype.render = function() {
      var _a3 = this.props, circleRatio = _a3.circleRatio, className = _a3.className, classes = _a3.classes, counterClockwise = _a3.counterClockwise, styles = _a3.styles, strokeWidth = _a3.strokeWidth, text = _a3.text;
      var pathRadius = this.getPathRadius();
      var pathRatio = this.getPathRatio();
      return reactExports.createElement(
        "svg",
        { className: classes.root + " " + className, style: styles.root, viewBox: "0 0 " + VIEWBOX_WIDTH + " " + VIEWBOX_HEIGHT, "data-test-id": "CircularProgressbar" },
        this.props.background ? reactExports.createElement("circle", { className: classes.background, style: styles.background, cx: VIEWBOX_CENTER_X, cy: VIEWBOX_CENTER_Y, r: VIEWBOX_HEIGHT_HALF }) : null,
        reactExports.createElement(Path, { className: classes.trail, counterClockwise, dashRatio: circleRatio, pathRadius, strokeWidth, style: styles.trail }),
        reactExports.createElement(Path, { className: classes.path, counterClockwise, dashRatio: pathRatio * circleRatio, pathRadius, strokeWidth, style: styles.path }),
        text ? reactExports.createElement("text", { className: classes.text, style: styles.text, x: VIEWBOX_CENTER_X, y: VIEWBOX_CENTER_Y }, text) : null
      );
    };
    CircularProgressbar2.defaultProps = {
      background: false,
      backgroundPadding: 0,
      circleRatio: 1,
      classes: {
        root: "CircularProgressbar",
        trail: "CircularProgressbar-trail",
        path: "CircularProgressbar-path",
        text: "CircularProgressbar-text",
        background: "CircularProgressbar-background"
      },
      counterClockwise: false,
      className: "",
      maxValue: 100,
      minValue: 0,
      strokeWidth: 8,
      styles: {
        root: {},
        trail: {},
        path: {},
        text: {},
        background: {}
      },
      text: ""
    };
    return CircularProgressbar2;
  }(reactExports.Component);
  const tagRe = /<([a-zA-Z0-9]+)>(.*?)<\/\1>|<([a-zA-Z0-9]+)\/>/;
  const nlRe = /(?:\r\n|\r|\n)/g;
  const voidElementTags = {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true,
    menuitem: true
  };
  function formatElements(value, elements = {}) {
    const uniqueId = makeCounter(0, "$lingui$");
    const parts = value.replace(nlRe, "").split(tagRe);
    if (parts.length === 1)
      return value;
    const tree = [];
    const before = parts.shift();
    if (before)
      tree.push(before);
    for (const [index2, children, after] of getElements(parts)) {
      let element = typeof index2 !== "undefined" ? elements[index2] : void 0;
      if (!element || voidElementTags[element.type] && children) {
        if (!element) {
          console.error(
            `Can't use element at index '${index2}' as it is not declared in the original translation`
          );
        } else {
          console.error(
            `${element.type} is a void element tag therefore it must have no children`
          );
        }
        element = we$1.createElement(we$1.Fragment);
      }
      if (Array.isArray(element)) {
        element = we$1.createElement(we$1.Fragment, {}, element);
      }
      tree.push(
        we$1.cloneElement(
          element,
          { key: uniqueId() },
          // format children for pair tags
          // unpaired tags might have children if it's a component passed as a variable
          children ? formatElements(children, elements) : element.props.children
        )
      );
      if (after)
        tree.push(after);
    }
    return tree;
  }
  function getElements(parts) {
    if (!parts.length)
      return [];
    const [paired, children, unpaired, after] = parts.slice(0, 4);
    const triple = [paired || unpaired, children || "", after];
    return [triple].concat(getElements(parts.slice(4, parts.length)));
  }
  const makeCounter = (count = 0, prefix = "") => () => `${prefix}_${count++}`;
  function TransNoContext(props) {
    const {
      render,
      component,
      id: id2,
      message,
      formats,
      lingui: { i18n: i18n2, defaultComponent }
    } = props;
    const values2 = { ...props.values };
    const components = { ...props.components };
    if (values2) {
      Object.keys(values2).forEach((key) => {
        const value = values2[key];
        const valueIsReactEl = we$1.isValidElement(value) || Array.isArray(value) && value.every(we$1.isValidElement);
        if (!valueIsReactEl)
          return;
        const index2 = Object.keys(components).length;
        components[index2] = value;
        values2[key] = `<${index2}/>`;
      });
    }
    const _translation = i18n2 && typeof i18n2._ === "function" ? i18n2._(id2, values2, { message, formats }) : id2;
    const translation = _translation ? formatElements(_translation, components) : null;
    if (render === null || component === null) {
      return translation;
    }
    const FallbackComponent = defaultComponent || RenderFragment;
    const i18nProps = {
      id: id2,
      message,
      translation,
      isTranslated: id2 !== translation && message !== translation,
      children: translation
      // for type-compatibility with `component` prop
    };
    if (render && component) {
      console.error(
        "You can't use both `component` and `render` prop at the same time. `component` is ignored."
      );
    } else if (render && typeof render !== "function") {
      console.error(
        `Invalid value supplied to prop \`render\`. It must be a function, provided ${render}`
      );
    } else if (component && typeof component !== "function") {
      console.error(
        `Invalid value supplied to prop \`component\`. It must be a React component, provided ${component}`
      );
      return we$1.createElement(FallbackComponent, i18nProps, translation);
    }
    if (typeof render === "function") {
      return render(i18nProps);
    }
    const Component = component || FallbackComponent;
    return we$1.createElement(Component, i18nProps, translation);
  }
  const RenderFragment = ({ children }) => {
    return /* @__PURE__ */ we$1.createElement(we$1.Fragment, null, children);
  };
  const LinguiContext = we$1.createContext(null);
  function useLingui() {
    const context = we$1.useContext(LinguiContext);
    return context;
  }
  function Trans(props) {
    const lingui = useLingui();
    return we$1.createElement(TransNoContext, { ...props, lingui });
  }
  const Svg46Dde8092160Efa1 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { viewBox: "0 0 14.685 8.391", height: 8.391, width: 14.685, ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M7.338 5.863 1.788.307A1.049 1.049 0 0 0 .305 1.793L6.6 8.087a1.047 1.047 0 0 0 1.443.03l6.334-6.324A1.05 1.05 0 1 0 12.894.307z" }));
  const SvgFca912Dd1Ab82474 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 8.394, height: 14.683, viewBox: "0 0 8.394 14.683", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m2.53 7.339 5.556-5.551A1.049 1.049 0 0 0 6.6.307L.306 6.6a1.047 1.047 0 0 0-.031 1.443L6.6 14.377a1.049 1.049 0 1 0 1.486-1.482z" }));
  const Svg1B8Acf1Cc5Bb7E55 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 8.394, height: 14.683, viewBox: "0 0 8.394 14.683", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M5.864 7.344.308 12.895a1.049 1.049 0 0 0 1.486 1.481l6.294-6.293a1.047 1.047 0 0 0 .031-1.443L1.794.306A1.05 1.05 0 1 0 .308 1.788z" }));
  const SvgEd18499E3448Aad6 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { viewBox: "0 0 14.685 8.391", height: 8.391, width: 14.685, ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m7.346 2.528 5.551 5.556a1.049 1.049 0 0 0 1.481-1.486L8.085.304a1.047 1.047 0 0 0-1.443-.03L.308 6.597A1.05 1.05 0 1 0 1.79 8.084z" }));
  var isArray$2 = Array.isArray;
  var keyList = Object.keys;
  var hasProp = Object.prototype.hasOwnProperty;
  var hasElementType = typeof Element !== "undefined";
  function equal(a, b2) {
    if (a === b2)
      return true;
    if (a && b2 && typeof a == "object" && typeof b2 == "object") {
      var arrA = isArray$2(a), arrB = isArray$2(b2), i2, length, key;
      if (arrA && arrB) {
        length = a.length;
        if (length != b2.length)
          return false;
        for (i2 = length; i2-- !== 0; )
          if (!equal(a[i2], b2[i2]))
            return false;
        return true;
      }
      if (arrA != arrB)
        return false;
      var dateA = a instanceof Date, dateB = b2 instanceof Date;
      if (dateA != dateB)
        return false;
      if (dateA && dateB)
        return a.getTime() == b2.getTime();
      var regexpA = a instanceof RegExp, regexpB = b2 instanceof RegExp;
      if (regexpA != regexpB)
        return false;
      if (regexpA && regexpB)
        return a.toString() == b2.toString();
      var keys2 = keyList(a);
      length = keys2.length;
      if (length !== keyList(b2).length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!hasProp.call(b2, keys2[i2]))
          return false;
      if (hasElementType && a instanceof Element && b2 instanceof Element)
        return a === b2;
      for (i2 = length; i2-- !== 0; ) {
        key = keys2[i2];
        if (key === "_owner" && a.$$typeof) {
          continue;
        } else {
          if (!equal(a[key], b2[key]))
            return false;
        }
      }
      return true;
    }
    return a !== a && b2 !== b2;
  }
  var reactFastCompare = function exportedEqual(a, b2) {
    try {
      return equal(a, b2);
    } catch (error2) {
      if (error2.message && error2.message.match(/stack|recursion/i) || error2.number === -2146828260) {
        console.warn("Warning: react-fast-compare does not handle circular references.", error2.name, error2.message);
        return false;
      }
      throw error2;
    }
  };
  const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
  var isMergeableObject = function isMergeableObject2(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      Object.keys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    Object.keys(source).forEach(function(key) {
      if (!options.isMergeableObject(source[key]) || !target[key]) {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      } else {
        destination[key] = deepmerge(target[key], source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  const freeGlobal$1 = freeGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal$1 || freeSelf || Function("return this")();
  const root$1 = root;
  var Symbol$1 = root$1.Symbol;
  const Symbol$2 = Symbol$1;
  var objectProto$d = Object.prototype;
  var hasOwnProperty$a = objectProto$d.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$d.toString;
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result2 = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result2;
  }
  var objectProto$c = Object.prototype;
  var nativeObjectToString = objectProto$c.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  const getPrototype$1 = getPrototype;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var objectTag$3 = "[object Object]";
  var funcProto$2 = Function.prototype, objectProto$b = Object.prototype;
  var funcToString$2 = funcProto$2.toString;
  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  var objectCtorString = funcToString$2.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
      return false;
    }
    var proto2 = getPrototype$1(value);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty$9.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result2 = data["delete"](key);
    this.size = data.size;
    return result2;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function isObject$1(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction$1(value) {
    if (!isObject$1(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }
  var coreJsData = root$1["__core-js_shared__"];
  const coreJsData$1 = coreJsData;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var funcProto$1 = Function.prototype;
  var funcToString$1 = funcProto$1.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto$a = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var Map$1 = getNative(root$1, "Map");
  const Map$2 = Map$1;
  var nativeCreate = getNative(Object, "create");
  const nativeCreate$1 = nativeCreate;
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result2 = this.has(key) && delete this.__data__[key];
    this.size -= result2 ? 1 : 0;
    return result2;
  }
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  var objectProto$9 = Object.prototype;
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result2 = data[key];
      return result2 === HASH_UNDEFINED$1 ? void 0 : result2;
    }
    return hasOwnProperty$7.call(data, key) ? data[key] : void 0;
  }
  var objectProto$8 = Object.prototype;
  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$6.call(data, key);
  }
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$2 || ListCache)(),
      "string": new Hash()
    };
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function mapCacheDelete(key) {
    var result2 = getMapData(this, key)["delete"](key);
    this.size -= result2 ? 1 : 0;
    return result2;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayEach(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e2) {
    }
  }();
  const defineProperty$1 = defineProperty;
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty$1) {
      defineProperty$1(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result2 = Array(n2);
    while (++index2 < n2) {
      result2[index2] = iteratee(index2);
    }
    return result2;
  }
  var argsTag$2 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$2;
  }
  var objectProto$6 = Object.prototype;
  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
  var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
  };
  const isArguments$1 = isArguments;
  var isArray = Array.isArray;
  const isArray$1 = isArray;
  function stubFalse() {
    return false;
  }
  var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
  var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse;
  const isBuffer$1 = isBuffer;
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
  var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal$1.process;
  var nodeUtil = function() {
    try {
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  const nodeUtil$1 = nodeUtil;
  var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  const isTypedArray$1 = isTypedArray;
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length)))) {
        result2.push(key);
      }
    }
    return result2;
  }
  var objectProto$4 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
    return value === proto2;
  }
  var nativeKeys = overArg(Object.keys, Object);
  const nativeKeys$1 = nativeKeys;
  var objectProto$3 = Object.prototype;
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys$1(object);
    }
    var result2 = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$2.call(object, key) && key != "constructor") {
        result2.push(key);
      }
    }
    return result2;
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction$1(value);
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  function nativeKeysIn(object) {
    var result2 = [];
    if (object != null) {
      for (var key in Object(object)) {
        result2.push(key);
      }
    }
    return result2;
  }
  var objectProto$2 = Object.prototype;
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject$1(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result2 = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty$1.call(object, key)))) {
        result2.push(key);
      }
    }
    return result2;
  }
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result2);
    return result2;
  }
  function copyArray(source, array) {
    var index2 = -1, length = source.length;
    array || (array = Array(length));
    while (++index2 < length) {
      array[index2] = source[index2];
    }
    return array;
  }
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result2[resIndex++] = value;
      }
    }
    return result2;
  }
  function stubArray() {
    return [];
  }
  var objectProto$1 = Object.prototype;
  var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  const getSymbols$1 = getSymbols;
  function copySymbols(source, object) {
    return copyObject(source, getSymbols$1(source), object);
  }
  function arrayPush(array, values2) {
    var index2 = -1, length = values2.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values2[index2];
    }
    return array;
  }
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result2 = [];
    while (object) {
      arrayPush(result2, getSymbols$1(object));
      object = getPrototype$1(object);
    }
    return result2;
  };
  const getSymbolsIn$1 = getSymbolsIn;
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn$1(source), object);
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result2 = keysFunc(object);
    return isArray$1(object) ? result2 : arrayPush(result2, symbolsFunc(object));
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols$1);
  }
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
  }
  var DataView$1 = getNative(root$1, "DataView");
  const DataView$2 = DataView$1;
  var Promise$1 = getNative(root$1, "Promise");
  const Promise$2 = Promise$1;
  var Set$1 = getNative(root$1, "Set");
  const Set$2 = Set$1;
  var WeakMap$1 = getNative(root$1, "WeakMap");
  const WeakMap$2 = WeakMap$1;
  var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
  var dataViewTag$2 = "[object DataView]";
  var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
  var getTag = baseGetTag;
  if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag(new Map$2()) != mapTag$3 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$3 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
    getTag = function(value) {
      var result2 = baseGetTag(value), Ctor = result2 == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$2;
          case mapCtorString:
            return mapTag$3;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$3;
          case weakMapCtorString:
            return weakMapTag$1;
        }
      }
      return result2;
    };
  }
  const getTag$1 = getTag;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result2 = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
      result2.index = array.index;
      result2.input = array.input;
    }
    return result2;
  }
  var Uint8Array$1 = root$1.Uint8Array;
  const Uint8Array$2 = Uint8Array$1;
  function cloneArrayBuffer(arrayBuffer) {
    var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$2(result2).set(new Uint8Array$2(arrayBuffer));
    return result2;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result2.lastIndex = regexp.lastIndex;
    return result2;
  }
  var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$1:
        return cloneArrayBuffer(object);
      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);
      case dataViewTag$1:
        return cloneDataView(object, isDeep);
      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object, isDeep);
      case mapTag$2:
        return new Ctor();
      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);
      case regexpTag$1:
        return cloneRegExp(object);
      case setTag$2:
        return new Ctor();
      case symbolTag$2:
        return cloneSymbol(object);
    }
  }
  var objectCreate = Object.create;
  var baseCreate = function() {
    function object() {
    }
    return function(proto2) {
      if (!isObject$1(proto2)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto2);
      }
      object.prototype = proto2;
      var result2 = new object();
      object.prototype = void 0;
      return result2;
    };
  }();
  const baseCreate$1 = baseCreate;
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
  }
  var mapTag$1 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag$1(value) == mapTag$1;
  }
  var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  const isMap$1 = isMap;
  var setTag$1 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$1;
  }
  var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  const isSet$1 = isSet;
  var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result2, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
    if (customizer) {
      result2 = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result2 !== void 0) {
      return result2;
    }
    if (!isObject$1(value)) {
      return value;
    }
    var isArr = isArray$1(value);
    if (isArr) {
      result2 = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result2);
      }
    } else {
      var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer$1(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result2 = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result2 = initCloneByTag(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result2);
    if (isSet$1(value)) {
      value.forEach(function(subValue) {
        result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap$1(value)) {
      value.forEach(function(subValue, key2) {
        result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
    return result2;
  }
  var CLONE_SYMBOLS_FLAG$1 = 4;
  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG$1);
  }
  function arrayMap(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length, result2 = Array(length);
    while (++index2 < length) {
      result2[index2] = iteratee(array[index2], index2, array);
    }
    return result2;
  }
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
      if (cache2.has(key)) {
        return cache2.get(key);
      }
      var result2 = func.apply(this, args);
      memoized.cache = cache2.set(key, result2) || cache2;
      return result2;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result2 = memoize(func, function(key) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key;
    });
    var cache2 = result2.cache;
    return result2;
  }
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result2 = [];
    if (string.charCodeAt(0) === 46) {
      result2.push("");
    }
    string.replace(rePropName, function(match2, number2, quote2, subString) {
      result2.push(quote2 ? subString.replace(reEscapeChar, "$1") : number2 || match2);
    });
    return result2;
  });
  const stringToPath$1 = stringToPath;
  var INFINITY$1 = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result2 = value + "";
    return result2 == "0" && 1 / value == -INFINITY$1 ? "-0" : result2;
  }
  var INFINITY = 1 / 0;
  var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray$1(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result2 = value + "";
    return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function toPath(value) {
    if (isArray$1(value)) {
      return arrayMap(value, toKey);
    }
    return isSymbol(value) ? [value] : copyArray(stringToPath$1(toString(value)));
  }
  var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }
  function _extends$1() {
    _extends$1 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _assertThisInitialized$1(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  var isEmptyArray = function isEmptyArray2(value) {
    return Array.isArray(value) && value.length === 0;
  };
  var isFunction = function isFunction2(obj) {
    return typeof obj === "function";
  };
  var isObject = function isObject2(obj) {
    return obj !== null && typeof obj === "object";
  };
  var isInteger = function isInteger2(obj) {
    return String(Math.floor(Number(obj))) === obj;
  };
  var isString = function isString2(obj) {
    return Object.prototype.toString.call(obj) === "[object String]";
  };
  var isEmptyChildren = function isEmptyChildren2(children) {
    return reactExports.Children.count(children) === 0;
  };
  var isPromise = function isPromise2(value) {
    return isObject(value) && isFunction(value.then);
  };
  function getIn(obj, key, def, p2) {
    if (p2 === void 0) {
      p2 = 0;
    }
    var path = toPath(key);
    while (obj && p2 < path.length) {
      obj = obj[path[p2++]];
    }
    return obj === void 0 ? def : obj;
  }
  function setIn(obj, path, value) {
    var res = clone(obj);
    var resVal = res;
    var i2 = 0;
    var pathArray = toPath(path);
    for (; i2 < pathArray.length - 1; i2++) {
      var currentPath = pathArray[i2];
      var currentObj = getIn(obj, pathArray.slice(0, i2 + 1));
      if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {
        resVal = resVal[currentPath] = clone(currentObj);
      } else {
        var nextPath = pathArray[i2 + 1];
        resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
      }
    }
    if ((i2 === 0 ? obj : resVal)[pathArray[i2]] === value) {
      return obj;
    }
    if (value === void 0) {
      delete resVal[pathArray[i2]];
    } else {
      resVal[pathArray[i2]] = value;
    }
    if (i2 === 0 && value === void 0) {
      delete res[pathArray[i2]];
    }
    return res;
  }
  function setNestedObjectValues(object, value, visited, response) {
    if (visited === void 0) {
      visited = /* @__PURE__ */ new WeakMap();
    }
    if (response === void 0) {
      response = {};
    }
    for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
      var k2 = _Object$keys[_i];
      var val = object[k2];
      if (isObject(val)) {
        if (!visited.get(val)) {
          visited.set(val, true);
          response[k2] = Array.isArray(val) ? [] : {};
          setNestedObjectValues(val, value, visited, response[k2]);
        }
      } else {
        response[k2] = value;
      }
    }
    return response;
  }
  var FormikContext = /* @__PURE__ */ reactExports.createContext(void 0);
  FormikContext.displayName = "FormikContext";
  var FormikProvider = FormikContext.Provider;
  var FormikConsumer = FormikContext.Consumer;
  function useFormikContext() {
    var formik = reactExports.useContext(FormikContext);
    !!!formik ? warning(false) : void 0;
    return formik;
  }
  function formikReducer(state, msg) {
    switch (msg.type) {
      case "SET_VALUES":
        return _extends$1({}, state, {
          values: msg.payload
        });
      case "SET_TOUCHED":
        return _extends$1({}, state, {
          touched: msg.payload
        });
      case "SET_ERRORS":
        if (isEqual(state.errors, msg.payload)) {
          return state;
        }
        return _extends$1({}, state, {
          errors: msg.payload
        });
      case "SET_STATUS":
        return _extends$1({}, state, {
          status: msg.payload
        });
      case "SET_ISSUBMITTING":
        return _extends$1({}, state, {
          isSubmitting: msg.payload
        });
      case "SET_ISVALIDATING":
        return _extends$1({}, state, {
          isValidating: msg.payload
        });
      case "SET_FIELD_VALUE":
        return _extends$1({}, state, {
          values: setIn(state.values, msg.payload.field, msg.payload.value)
        });
      case "SET_FIELD_TOUCHED":
        return _extends$1({}, state, {
          touched: setIn(state.touched, msg.payload.field, msg.payload.value)
        });
      case "SET_FIELD_ERROR":
        return _extends$1({}, state, {
          errors: setIn(state.errors, msg.payload.field, msg.payload.value)
        });
      case "RESET_FORM":
        return _extends$1({}, state, msg.payload);
      case "SET_FORMIK_STATE":
        return msg.payload(state);
      case "SUBMIT_ATTEMPT":
        return _extends$1({}, state, {
          touched: setNestedObjectValues(state.values, true),
          isSubmitting: true,
          submitCount: state.submitCount + 1
        });
      case "SUBMIT_FAILURE":
        return _extends$1({}, state, {
          isSubmitting: false
        });
      case "SUBMIT_SUCCESS":
        return _extends$1({}, state, {
          isSubmitting: false
        });
      default:
        return state;
    }
  }
  var emptyErrors = {};
  var emptyTouched = {};
  function useFormik(_ref) {
    var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose$1(_ref, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]);
    var props = _extends$1({
      validateOnChange,
      validateOnBlur,
      validateOnMount,
      onSubmit
    }, rest);
    var initialValues = reactExports.useRef(props.initialValues);
    var initialErrors = reactExports.useRef(props.initialErrors || emptyErrors);
    var initialTouched = reactExports.useRef(props.initialTouched || emptyTouched);
    var initialStatus = reactExports.useRef(props.initialStatus);
    var isMounted = reactExports.useRef(false);
    var fieldRegistry = reactExports.useRef({});
    reactExports.useEffect(function() {
      isMounted.current = true;
      return function() {
        isMounted.current = false;
      };
    }, []);
    var _React$useReducer = reactExports.useReducer(formikReducer, {
      values: props.initialValues,
      errors: props.initialErrors || emptyErrors,
      touched: props.initialTouched || emptyTouched,
      status: props.initialStatus,
      isSubmitting: false,
      isValidating: false,
      submitCount: 0
    }), state = _React$useReducer[0], dispatch = _React$useReducer[1];
    var runValidateHandler = reactExports.useCallback(function(values2, field) {
      return new Promise(function(resolve, reject) {
        var maybePromisedErrors = props.validate(values2, field);
        if (maybePromisedErrors == null) {
          resolve(emptyErrors);
        } else if (isPromise(maybePromisedErrors)) {
          maybePromisedErrors.then(function(errors2) {
            resolve(errors2 || emptyErrors);
          }, function(actualException) {
            reject(actualException);
          });
        } else {
          resolve(maybePromisedErrors);
        }
      });
    }, [props.validate]);
    var runValidationSchema = reactExports.useCallback(function(values2, field) {
      var validationSchema = props.validationSchema;
      var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;
      var promise = field && schema.validateAt ? schema.validateAt(field, values2) : validateYupSchema(values2, schema);
      return new Promise(function(resolve, reject) {
        promise.then(function() {
          resolve(emptyErrors);
        }, function(err) {
          if (err.name === "ValidationError") {
            resolve(yupToFormErrors(err));
          } else {
            reject(err);
          }
        });
      });
    }, [props.validationSchema]);
    var runSingleFieldLevelValidation = reactExports.useCallback(function(field, value) {
      return new Promise(function(resolve) {
        return resolve(fieldRegistry.current[field].validate(value));
      });
    }, []);
    var runFieldLevelValidations = reactExports.useCallback(function(values2) {
      var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f2) {
        return isFunction(fieldRegistry.current[f2].validate);
      });
      var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f2) {
        return runSingleFieldLevelValidation(f2, getIn(values2, f2));
      }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
      return Promise.all(fieldValidations).then(function(fieldErrorsList) {
        return fieldErrorsList.reduce(function(prev, curr, index2) {
          if (curr === "DO_NOT_DELETE_YOU_WILL_BE_FIRED") {
            return prev;
          }
          if (curr) {
            prev = setIn(prev, fieldKeysWithValidation[index2], curr);
          }
          return prev;
        }, {});
      });
    }, [runSingleFieldLevelValidation]);
    var runAllValidations = reactExports.useCallback(function(values2) {
      return Promise.all([runFieldLevelValidations(values2), props.validationSchema ? runValidationSchema(values2) : {}, props.validate ? runValidateHandler(values2) : {}]).then(function(_ref2) {
        var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];
        var combinedErrors = deepmerge_1.all([fieldErrors, schemaErrors, validateErrors], {
          arrayMerge
        });
        return combinedErrors;
      });
    }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]);
    var validateFormWithHighPriority = useEventCallback(function(values2) {
      if (values2 === void 0) {
        values2 = state.values;
      }
      dispatch({
        type: "SET_ISVALIDATING",
        payload: true
      });
      return runAllValidations(values2).then(function(combinedErrors) {
        if (!!isMounted.current) {
          dispatch({
            type: "SET_ISVALIDATING",
            payload: false
          });
          dispatch({
            type: "SET_ERRORS",
            payload: combinedErrors
          });
        }
        return combinedErrors;
      });
    });
    reactExports.useEffect(function() {
      if (validateOnMount && isMounted.current === true && isEqual(initialValues.current, props.initialValues)) {
        validateFormWithHighPriority(initialValues.current);
      }
    }, [validateOnMount, validateFormWithHighPriority]);
    var resetForm = reactExports.useCallback(function(nextState) {
      var values2 = nextState && nextState.values ? nextState.values : initialValues.current;
      var errors2 = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};
      var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};
      var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;
      initialValues.current = values2;
      initialErrors.current = errors2;
      initialTouched.current = touched;
      initialStatus.current = status;
      var dispatchFn = function dispatchFn2() {
        dispatch({
          type: "RESET_FORM",
          payload: {
            isSubmitting: !!nextState && !!nextState.isSubmitting,
            errors: errors2,
            touched,
            status,
            values: values2,
            isValidating: !!nextState && !!nextState.isValidating,
            submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === "number" ? nextState.submitCount : 0
          }
        });
      };
      if (props.onReset) {
        var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);
        if (isPromise(maybePromisedOnReset)) {
          maybePromisedOnReset.then(dispatchFn);
        } else {
          dispatchFn();
        }
      } else {
        dispatchFn();
      }
    }, [props.initialErrors, props.initialStatus, props.initialTouched]);
    reactExports.useEffect(function() {
      if (isMounted.current === true && !isEqual(initialValues.current, props.initialValues)) {
        if (enableReinitialize) {
          initialValues.current = props.initialValues;
          resetForm();
        }
        if (validateOnMount) {
          validateFormWithHighPriority(initialValues.current);
        }
      }
    }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);
    reactExports.useEffect(function() {
      if (enableReinitialize && isMounted.current === true && !isEqual(initialErrors.current, props.initialErrors)) {
        initialErrors.current = props.initialErrors || emptyErrors;
        dispatch({
          type: "SET_ERRORS",
          payload: props.initialErrors || emptyErrors
        });
      }
    }, [enableReinitialize, props.initialErrors]);
    reactExports.useEffect(function() {
      if (enableReinitialize && isMounted.current === true && !isEqual(initialTouched.current, props.initialTouched)) {
        initialTouched.current = props.initialTouched || emptyTouched;
        dispatch({
          type: "SET_TOUCHED",
          payload: props.initialTouched || emptyTouched
        });
      }
    }, [enableReinitialize, props.initialTouched]);
    reactExports.useEffect(function() {
      if (enableReinitialize && isMounted.current === true && !isEqual(initialStatus.current, props.initialStatus)) {
        initialStatus.current = props.initialStatus;
        dispatch({
          type: "SET_STATUS",
          payload: props.initialStatus
        });
      }
    }, [enableReinitialize, props.initialStatus, props.initialTouched]);
    var validateField = useEventCallback(function(name) {
      if (fieldRegistry.current[name] && isFunction(fieldRegistry.current[name].validate)) {
        var value = getIn(state.values, name);
        var maybePromise = fieldRegistry.current[name].validate(value);
        if (isPromise(maybePromise)) {
          dispatch({
            type: "SET_ISVALIDATING",
            payload: true
          });
          return maybePromise.then(function(x2) {
            return x2;
          }).then(function(error2) {
            dispatch({
              type: "SET_FIELD_ERROR",
              payload: {
                field: name,
                value: error2
              }
            });
            dispatch({
              type: "SET_ISVALIDATING",
              payload: false
            });
          });
        } else {
          dispatch({
            type: "SET_FIELD_ERROR",
            payload: {
              field: name,
              value: maybePromise
            }
          });
          return Promise.resolve(maybePromise);
        }
      } else if (props.validationSchema) {
        dispatch({
          type: "SET_ISVALIDATING",
          payload: true
        });
        return runValidationSchema(state.values, name).then(function(x2) {
          return x2;
        }).then(function(error2) {
          dispatch({
            type: "SET_FIELD_ERROR",
            payload: {
              field: name,
              value: error2[name]
            }
          });
          dispatch({
            type: "SET_ISVALIDATING",
            payload: false
          });
        });
      }
      return Promise.resolve();
    });
    var registerField = reactExports.useCallback(function(name, _ref3) {
      var validate2 = _ref3.validate;
      fieldRegistry.current[name] = {
        validate: validate2
      };
    }, []);
    var unregisterField = reactExports.useCallback(function(name) {
      delete fieldRegistry.current[name];
    }, []);
    var setTouched = useEventCallback(function(touched, shouldValidate) {
      dispatch({
        type: "SET_TOUCHED",
        payload: touched
      });
      var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
      return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
    });
    var setErrors = reactExports.useCallback(function(errors2) {
      dispatch({
        type: "SET_ERRORS",
        payload: errors2
      });
    }, []);
    var setValues = useEventCallback(function(values2, shouldValidate) {
      var resolvedValues = isFunction(values2) ? values2(state.values) : values2;
      dispatch({
        type: "SET_VALUES",
        payload: resolvedValues
      });
      var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
      return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();
    });
    var setFieldError = reactExports.useCallback(function(field, value) {
      dispatch({
        type: "SET_FIELD_ERROR",
        payload: {
          field,
          value
        }
      });
    }, []);
    var setFieldValue = useEventCallback(function(field, value, shouldValidate) {
      dispatch({
        type: "SET_FIELD_VALUE",
        payload: {
          field,
          value
        }
      });
      var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
      return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();
    });
    var executeChange = reactExports.useCallback(function(eventOrTextValue, maybePath) {
      var field = maybePath;
      var val = eventOrTextValue;
      var parsed;
      if (!isString(eventOrTextValue)) {
        if (eventOrTextValue.persist) {
          eventOrTextValue.persist();
        }
        var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;
        var type = target.type, name = target.name, id2 = target.id, value = target.value, checked = target.checked, outerHTML = target.outerHTML, options = target.options, multiple = target.multiple;
        field = maybePath ? maybePath : name ? name : id2;
        if (!field && false) {
          warnAboutMissingIdentifier({
            htmlContent: outerHTML,
            documentationAnchorLink: "handlechange-e-reactchangeeventany--void",
            handlerName: "handleChange"
          });
        }
        val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? "" : parsed) : /checkbox/.test(type) ? getValueForCheckbox(getIn(state.values, field), checked, value) : options && multiple ? getSelectedValues(options) : value;
      }
      if (field) {
        setFieldValue(field, val);
      }
    }, [setFieldValue, state.values]);
    var handleChange = useEventCallback(function(eventOrPath) {
      if (isString(eventOrPath)) {
        return function(event) {
          return executeChange(event, eventOrPath);
        };
      } else {
        executeChange(eventOrPath);
      }
    });
    var setFieldTouched = useEventCallback(function(field, touched, shouldValidate) {
      if (touched === void 0) {
        touched = true;
      }
      dispatch({
        type: "SET_FIELD_TOUCHED",
        payload: {
          field,
          value: touched
        }
      });
      var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
      return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
    });
    var executeBlur = reactExports.useCallback(function(e2, path) {
      if (e2.persist) {
        e2.persist();
      }
      var _e$target = e2.target, name = _e$target.name, id2 = _e$target.id, outerHTML = _e$target.outerHTML;
      var field = path ? path : name ? name : id2;
      if (!field && false) {
        warnAboutMissingIdentifier({
          htmlContent: outerHTML,
          documentationAnchorLink: "handleblur-e-any--void",
          handlerName: "handleBlur"
        });
      }
      setFieldTouched(field, true);
    }, [setFieldTouched]);
    var handleBlur = useEventCallback(function(eventOrString) {
      if (isString(eventOrString)) {
        return function(event) {
          return executeBlur(event, eventOrString);
        };
      } else {
        executeBlur(eventOrString);
      }
    });
    var setFormikState = reactExports.useCallback(function(stateOrCb) {
      if (isFunction(stateOrCb)) {
        dispatch({
          type: "SET_FORMIK_STATE",
          payload: stateOrCb
        });
      } else {
        dispatch({
          type: "SET_FORMIK_STATE",
          payload: function payload() {
            return stateOrCb;
          }
        });
      }
    }, []);
    var setStatus2 = reactExports.useCallback(function(status) {
      dispatch({
        type: "SET_STATUS",
        payload: status
      });
    }, []);
    var setSubmitting = reactExports.useCallback(function(isSubmitting) {
      dispatch({
        type: "SET_ISSUBMITTING",
        payload: isSubmitting
      });
    }, []);
    var submitForm2 = useEventCallback(function() {
      dispatch({
        type: "SUBMIT_ATTEMPT"
      });
      return validateFormWithHighPriority().then(function(combinedErrors) {
        var isInstanceOfError = combinedErrors instanceof Error;
        var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;
        if (isActuallyValid) {
          var promiseOrUndefined;
          try {
            promiseOrUndefined = executeSubmit();
            if (promiseOrUndefined === void 0) {
              return;
            }
          } catch (error2) {
            throw error2;
          }
          return Promise.resolve(promiseOrUndefined).then(function(result2) {
            if (!!isMounted.current) {
              dispatch({
                type: "SUBMIT_SUCCESS"
              });
            }
            return result2;
          })["catch"](function(_errors) {
            if (!!isMounted.current) {
              dispatch({
                type: "SUBMIT_FAILURE"
              });
              throw _errors;
            }
          });
        } else if (!!isMounted.current) {
          dispatch({
            type: "SUBMIT_FAILURE"
          });
          if (isInstanceOfError) {
            throw combinedErrors;
          }
        }
        return;
      });
    });
    var handleSubmit = useEventCallback(function(e2) {
      if (e2 && e2.preventDefault && isFunction(e2.preventDefault)) {
        e2.preventDefault();
      }
      if (e2 && e2.stopPropagation && isFunction(e2.stopPropagation)) {
        e2.stopPropagation();
      }
      submitForm2()["catch"](function(reason) {
        console.warn("Warning: An unhandled error was caught from submitForm()", reason);
      });
    });
    var imperativeMethods = {
      resetForm,
      validateForm: validateFormWithHighPriority,
      validateField,
      setErrors,
      setFieldError,
      setFieldTouched,
      setFieldValue,
      setStatus: setStatus2,
      setSubmitting,
      setTouched,
      setValues,
      setFormikState,
      submitForm: submitForm2
    };
    var executeSubmit = useEventCallback(function() {
      return onSubmit(state.values, imperativeMethods);
    });
    var handleReset = useEventCallback(function(e2) {
      if (e2 && e2.preventDefault && isFunction(e2.preventDefault)) {
        e2.preventDefault();
      }
      if (e2 && e2.stopPropagation && isFunction(e2.stopPropagation)) {
        e2.stopPropagation();
      }
      resetForm();
    });
    var getFieldMeta = reactExports.useCallback(function(name) {
      return {
        value: getIn(state.values, name),
        error: getIn(state.errors, name),
        touched: !!getIn(state.touched, name),
        initialValue: getIn(initialValues.current, name),
        initialTouched: !!getIn(initialTouched.current, name),
        initialError: getIn(initialErrors.current, name)
      };
    }, [state.errors, state.touched, state.values]);
    var getFieldHelpers = reactExports.useCallback(function(name) {
      return {
        setValue: function setValue(value, shouldValidate) {
          return setFieldValue(name, value, shouldValidate);
        },
        setTouched: function setTouched2(value, shouldValidate) {
          return setFieldTouched(name, value, shouldValidate);
        },
        setError: function setError(value) {
          return setFieldError(name, value);
        }
      };
    }, [setFieldValue, setFieldTouched, setFieldError]);
    var getFieldProps = reactExports.useCallback(function(nameOrOptions) {
      var isAnObject = isObject(nameOrOptions);
      var name = isAnObject ? nameOrOptions.name : nameOrOptions;
      var valueState = getIn(state.values, name);
      var field = {
        name,
        value: valueState,
        onChange: handleChange,
        onBlur: handleBlur
      };
      if (isAnObject) {
        var type = nameOrOptions.type, valueProp = nameOrOptions.value, is2 = nameOrOptions.as, multiple = nameOrOptions.multiple;
        if (type === "checkbox") {
          if (valueProp === void 0) {
            field.checked = !!valueState;
          } else {
            field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
            field.value = valueProp;
          }
        } else if (type === "radio") {
          field.checked = valueState === valueProp;
          field.value = valueProp;
        } else if (is2 === "select" && multiple) {
          field.value = field.value || [];
          field.multiple = true;
        }
      }
      return field;
    }, [handleBlur, handleChange, state.values]);
    var dirty = reactExports.useMemo(function() {
      return !isEqual(initialValues.current, state.values);
    }, [initialValues.current, state.values]);
    var isValid2 = reactExports.useMemo(function() {
      return typeof isInitialValid !== "undefined" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;
    }, [isInitialValid, dirty, state.errors, props]);
    var ctx = _extends$1({}, state, {
      initialValues: initialValues.current,
      initialErrors: initialErrors.current,
      initialTouched: initialTouched.current,
      initialStatus: initialStatus.current,
      handleBlur,
      handleChange,
      handleReset,
      handleSubmit,
      resetForm,
      setErrors,
      setFormikState,
      setFieldTouched,
      setFieldValue,
      setFieldError,
      setStatus: setStatus2,
      setSubmitting,
      setTouched,
      setValues,
      submitForm: submitForm2,
      validateForm: validateFormWithHighPriority,
      validateField,
      isValid: isValid2,
      dirty,
      unregisterField,
      registerField,
      getFieldProps,
      getFieldMeta,
      getFieldHelpers,
      validateOnBlur,
      validateOnChange,
      validateOnMount
    });
    return ctx;
  }
  function Formik(props) {
    var formikbag = useFormik(props);
    var component = props.component, children = props.children, render = props.render, innerRef = props.innerRef;
    reactExports.useImperativeHandle(innerRef, function() {
      return formikbag;
    });
    return reactExports.createElement(FormikProvider, {
      value: formikbag
    }, component ? reactExports.createElement(component, formikbag) : render ? render(formikbag) : children ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? reactExports.Children.only(children) : null : null);
  }
  function warnAboutMissingIdentifier(_ref4) {
    var htmlContent = _ref4.htmlContent, documentationAnchorLink = _ref4.documentationAnchorLink, handlerName = _ref4.handlerName;
    console.warn("Warning: Formik called `" + handlerName + "`, but you forgot to pass an `id` or `name` attribute to your input:\n    " + htmlContent + "\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#" + documentationAnchorLink + "\n  ");
  }
  function yupToFormErrors(yupError) {
    var errors2 = {};
    if (yupError.inner) {
      if (yupError.inner.length === 0) {
        return setIn(errors2, yupError.path, yupError.message);
      }
      for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
        var _ref5;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref5 = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref5 = _i.value;
        }
        var err = _ref5;
        if (!getIn(errors2, err.path)) {
          errors2 = setIn(errors2, err.path, err.message);
        }
      }
    }
    return errors2;
  }
  function validateYupSchema(values2, schema, sync, context) {
    if (sync === void 0) {
      sync = false;
    }
    if (context === void 0) {
      context = {};
    }
    var validateData = prepareDataForValidation(values2);
    return schema[sync ? "validateSync" : "validate"](validateData, {
      abortEarly: false,
      context
    });
  }
  function prepareDataForValidation(values2) {
    var data = Array.isArray(values2) ? [] : {};
    for (var k2 in values2) {
      if (Object.prototype.hasOwnProperty.call(values2, k2)) {
        var key = String(k2);
        if (Array.isArray(values2[key]) === true) {
          data[key] = values2[key].map(function(value) {
            if (Array.isArray(value) === true || isPlainObject(value)) {
              return prepareDataForValidation(value);
            } else {
              return value !== "" ? value : void 0;
            }
          });
        } else if (isPlainObject(values2[key])) {
          data[key] = prepareDataForValidation(values2[key]);
        } else {
          data[key] = values2[key] !== "" ? values2[key] : void 0;
        }
      }
    }
    return data;
  }
  function arrayMerge(target, source, options) {
    var destination = target.slice();
    source.forEach(function merge2(e2, i2) {
      if (typeof destination[i2] === "undefined") {
        var cloneRequested = options.clone !== false;
        var shouldClone = cloneRequested && options.isMergeableObject(e2);
        destination[i2] = shouldClone ? deepmerge_1(Array.isArray(e2) ? [] : {}, e2, options) : e2;
      } else if (options.isMergeableObject(e2)) {
        destination[i2] = deepmerge_1(target[i2], e2, options);
      } else if (target.indexOf(e2) === -1) {
        destination.push(e2);
      }
    });
    return destination;
  }
  function getSelectedValues(options) {
    return Array.from(options).filter(function(el2) {
      return el2.selected;
    }).map(function(el2) {
      return el2.value;
    });
  }
  function getValueForCheckbox(currentValue, checked, valueProp) {
    if (typeof currentValue === "boolean") {
      return Boolean(checked);
    }
    var currentArrayOfValues = [];
    var isValueInArray = false;
    var index2 = -1;
    if (!Array.isArray(currentValue)) {
      if (!valueProp || valueProp == "true" || valueProp == "false") {
        return Boolean(checked);
      }
    } else {
      currentArrayOfValues = currentValue;
      index2 = currentValue.indexOf(valueProp);
      isValueInArray = index2 >= 0;
    }
    if (checked && valueProp && !isValueInArray) {
      return currentArrayOfValues.concat(valueProp);
    }
    if (!isValueInArray) {
      return currentArrayOfValues;
    }
    return currentArrayOfValues.slice(0, index2).concat(currentArrayOfValues.slice(index2 + 1));
  }
  var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  function useEventCallback(fn) {
    var ref = reactExports.useRef(fn);
    useIsomorphicLayoutEffect(function() {
      ref.current = fn;
    });
    return reactExports.useCallback(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return ref.current.apply(void 0, args);
    }, []);
  }
  var Form = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var action = props.action, rest = _objectWithoutPropertiesLoose$1(props, ["action"]);
    var _action = action != null ? action : "#";
    var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;
    return reactExports.createElement("form", Object.assign({
      onSubmit: handleSubmit,
      ref,
      onReset: handleReset,
      action: _action
    }, rest));
  });
  Form.displayName = "Form";
  function connect(Comp) {
    var C2 = function C3(props) {
      return reactExports.createElement(FormikConsumer, null, function(formik) {
        !!!formik ? warning(false) : void 0;
        return reactExports.createElement(Comp, Object.assign({}, props, {
          formik
        }));
      });
    };
    var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || "Component";
    C2.WrappedComponent = Comp;
    C2.displayName = "FormikConnect(" + componentDisplayName + ")";
    return hoistNonReactStatics$1(
      C2,
      Comp
      // cast type to ComponentClass (even if SFC)
    );
  }
  var move = function move2(array, from, to2) {
    var copy = copyArrayLike(array);
    var value = copy[from];
    copy.splice(from, 1);
    copy.splice(to2, 0, value);
    return copy;
  };
  var swap = function swap2(arrayLike, indexA, indexB) {
    var copy = copyArrayLike(arrayLike);
    var a = copy[indexA];
    copy[indexA] = copy[indexB];
    copy[indexB] = a;
    return copy;
  };
  var insert = function insert2(arrayLike, index2, value) {
    var copy = copyArrayLike(arrayLike);
    copy.splice(index2, 0, value);
    return copy;
  };
  var replace = function replace2(arrayLike, index2, value) {
    var copy = copyArrayLike(arrayLike);
    copy[index2] = value;
    return copy;
  };
  var copyArrayLike = function copyArrayLike2(arrayLike) {
    if (!arrayLike) {
      return [];
    } else if (Array.isArray(arrayLike)) {
      return [].concat(arrayLike);
    } else {
      var maxIndex = Object.keys(arrayLike).map(function(key) {
        return parseInt(key);
      }).reduce(function(max2, el2) {
        return el2 > max2 ? el2 : max2;
      }, 0);
      return Array.from(_extends$1({}, arrayLike, {
        length: maxIndex + 1
      }));
    }
  };
  var FieldArrayInner = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(FieldArrayInner2, _React$Component);
    function FieldArrayInner2(props) {
      var _this;
      _this = _React$Component.call(this, props) || this;
      _this.updateArrayField = function(fn, alterTouched, alterErrors) {
        var _this$props = _this.props, name = _this$props.name, setFormikState = _this$props.formik.setFormikState;
        setFormikState(function(prevState) {
          var updateErrors = typeof alterErrors === "function" ? alterErrors : fn;
          var updateTouched = typeof alterTouched === "function" ? alterTouched : fn;
          var values2 = setIn(prevState.values, name, fn(getIn(prevState.values, name)));
          var fieldError = alterErrors ? updateErrors(getIn(prevState.errors, name)) : void 0;
          var fieldTouched = alterTouched ? updateTouched(getIn(prevState.touched, name)) : void 0;
          if (isEmptyArray(fieldError)) {
            fieldError = void 0;
          }
          if (isEmptyArray(fieldTouched)) {
            fieldTouched = void 0;
          }
          return _extends$1({}, prevState, {
            values: values2,
            errors: alterErrors ? setIn(prevState.errors, name, fieldError) : prevState.errors,
            touched: alterTouched ? setIn(prevState.touched, name, fieldTouched) : prevState.touched
          });
        });
      };
      _this.push = function(value) {
        return _this.updateArrayField(function(arrayLike) {
          return [].concat(copyArrayLike(arrayLike), [cloneDeep(value)]);
        }, false, false);
      };
      _this.handlePush = function(value) {
        return function() {
          return _this.push(value);
        };
      };
      _this.swap = function(indexA, indexB) {
        return _this.updateArrayField(function(array) {
          return swap(array, indexA, indexB);
        }, true, true);
      };
      _this.handleSwap = function(indexA, indexB) {
        return function() {
          return _this.swap(indexA, indexB);
        };
      };
      _this.move = function(from, to2) {
        return _this.updateArrayField(function(array) {
          return move(array, from, to2);
        }, true, true);
      };
      _this.handleMove = function(from, to2) {
        return function() {
          return _this.move(from, to2);
        };
      };
      _this.insert = function(index2, value) {
        return _this.updateArrayField(function(array) {
          return insert(array, index2, value);
        }, function(array) {
          return insert(array, index2, null);
        }, function(array) {
          return insert(array, index2, null);
        });
      };
      _this.handleInsert = function(index2, value) {
        return function() {
          return _this.insert(index2, value);
        };
      };
      _this.replace = function(index2, value) {
        return _this.updateArrayField(function(array) {
          return replace(array, index2, value);
        }, false, false);
      };
      _this.handleReplace = function(index2, value) {
        return function() {
          return _this.replace(index2, value);
        };
      };
      _this.unshift = function(value) {
        var length = -1;
        _this.updateArrayField(function(array) {
          var arr = array ? [value].concat(array) : [value];
          if (length < 0) {
            length = arr.length;
          }
          return arr;
        }, function(array) {
          var arr = array ? [null].concat(array) : [null];
          if (length < 0) {
            length = arr.length;
          }
          return arr;
        }, function(array) {
          var arr = array ? [null].concat(array) : [null];
          if (length < 0) {
            length = arr.length;
          }
          return arr;
        });
        return length;
      };
      _this.handleUnshift = function(value) {
        return function() {
          return _this.unshift(value);
        };
      };
      _this.handleRemove = function(index2) {
        return function() {
          return _this.remove(index2);
        };
      };
      _this.handlePop = function() {
        return function() {
          return _this.pop();
        };
      };
      _this.remove = _this.remove.bind(_assertThisInitialized$1(_this));
      _this.pop = _this.pop.bind(_assertThisInitialized$1(_this));
      return _this;
    }
    var _proto = FieldArrayInner2.prototype;
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (this.props.validateOnChange && this.props.formik.validateOnChange && !isEqual(getIn(prevProps.formik.values, prevProps.name), getIn(this.props.formik.values, this.props.name))) {
        this.props.formik.validateForm(this.props.formik.values);
      }
    };
    _proto.remove = function remove(index2) {
      var result2;
      this.updateArrayField(
        // so this gets call 3 times
        function(array) {
          var copy = array ? copyArrayLike(array) : [];
          if (!result2) {
            result2 = copy[index2];
          }
          if (isFunction(copy.splice)) {
            copy.splice(index2, 1);
          }
          return copy;
        },
        true,
        true
      );
      return result2;
    };
    _proto.pop = function pop() {
      var result2;
      this.updateArrayField(
        // so this gets call 3 times
        function(array) {
          var tmp = array;
          if (!result2) {
            result2 = tmp && tmp.pop && tmp.pop();
          }
          return tmp;
        },
        true,
        true
      );
      return result2;
    };
    _proto.render = function render() {
      var arrayHelpers = {
        push: this.push,
        pop: this.pop,
        swap: this.swap,
        move: this.move,
        insert: this.insert,
        replace: this.replace,
        unshift: this.unshift,
        remove: this.remove,
        handlePush: this.handlePush,
        handlePop: this.handlePop,
        handleSwap: this.handleSwap,
        handleMove: this.handleMove,
        handleInsert: this.handleInsert,
        handleReplace: this.handleReplace,
        handleUnshift: this.handleUnshift,
        handleRemove: this.handleRemove
      };
      var _this$props2 = this.props, component = _this$props2.component, render2 = _this$props2.render, children = _this$props2.children, name = _this$props2.name, _this$props2$formik = _this$props2.formik, restOfFormik = _objectWithoutPropertiesLoose$1(_this$props2$formik, ["validate", "validationSchema"]);
      var props = _extends$1({}, arrayHelpers, {
        form: restOfFormik,
        name
      });
      return component ? reactExports.createElement(component, props) : render2 ? render2(props) : children ? typeof children === "function" ? children(props) : !isEmptyChildren(children) ? reactExports.Children.only(children) : null : null;
    };
    return FieldArrayInner2;
  }(reactExports.Component);
  FieldArrayInner.defaultProps = {
    validateOnChange: true
  };
  var FieldArray = /* @__PURE__ */ connect(FieldArrayInner);
  var defaultExitDuration = 250;
  var defaultEnterDuration = 250;
  var defaultTransitionDuration = 300;
  var defaultEasingEnter = "ease-out";
  var defaultEasingExit = "ease-in";
  var defaultTransitionEasing = "ease";
  var Variable;
  (function(Variable2) {
    Variable2["Width"] = "%WIDTH%";
    Variable2["Height"] = "%HEIGHT%";
    Variable2["Top"] = "%TOP%";
    Variable2["Bottom"] = "%BOTTOM%";
    Variable2["Left"] = "%LEFT%";
    Variable2["Right"] = "%RIGHT%";
  })(Variable || (Variable = {}));
  var fade = {
    enter: {
      keyframes: {
        opacity: [0, 1]
      },
      options: { duration: defaultEnterDuration, easing: defaultEasingEnter }
    },
    exit: {
      keyframes: {
        opacity: [1, 0]
      },
      options: { duration: defaultExitDuration, easing: defaultEasingExit }
    }
  };
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
  
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
  
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function __awaiter(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n2) {
      return function(v2) {
        return step([n2, v2]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  var TransitionFade = function(props) {
    return we$1.createElement(ComponentTransition, __assign({ animateContainer: true }, props, { enterAnimation: fade.enter, exitAnimation: fade.exit }), props.children);
  };
  var ComponentTransitionContext = reactExports.createContext(null);
  var TransitionState;
  (function(TransitionState2) {
    TransitionState2["Exit"] = "exit";
    TransitionState2["Container"] = "container";
    TransitionState2["Enter"] = "enter";
    TransitionState2["ContainerRect"] = "container-rect";
  })(TransitionState || (TransitionState = {}));
  var useContainerRectangle = function(props) {
    var prevClientRect = reactExports.useRef(null);
    var nextClientRect = reactExports.useRef(null);
    var transitionState = props.transitionState, getElement2 = props.getElement, onFinish = props.onFinish;
    if (getElement2() && transitionState === TransitionState.Exit) {
      prevClientRect.current = getElement2().getBoundingClientRect();
    }
    reactExports.useLayoutEffect(function() {
      if (getElement2() && transitionState === TransitionState.ContainerRect) {
        nextClientRect.current = getElement2().getBoundingClientRect();
        onFinish();
      }
    }, [transitionState]);
    return {
      prevClientRect: prevClientRect.current,
      nextClientRect: nextClientRect.current
    };
  };
  var animationDurationThreshold = 100;
  var animateContainer = function(element, prevClientRect, nextClientRect, duration, easing) {
    if (duration === void 0) {
      duration = defaultTransitionDuration;
    }
    if (easing === void 0) {
      easing = defaultTransitionEasing;
    }
    if (!element || !prevClientRect || !nextClientRect) {
      return null;
    }
    var newWidth = nextClientRect.width, newHeight = nextClientRect.height;
    var width = prevClientRect.width, height = prevClientRect.height;
    if (width === newWidth && height === newHeight) {
      return null;
    }
    var widthDelta = Math.abs(width - newWidth);
    var heightDelta = Math.abs(height - newHeight);
    var options = {
      duration,
      easing
    };
    if (typeof options.duration === "number" && widthDelta < animationDurationThreshold && heightDelta < animationDurationThreshold) {
      var max2 = Math.max(widthDelta, heightDelta);
      options.duration = max2 * options.duration / animationDurationThreshold;
    }
    var transition = {
      width: [width + "px", newWidth + "px"],
      height: [height + "px", newHeight + "px"]
    };
    return element.animate(transition, options);
  };
  var animateEnter = function(element, clientRect, settings) {
    return animateContent(element, clientRect, settings);
  };
  var animateExit = function(element, clientRect, settings) {
    var animationSettings = (Array.isArray(settings) ? settings : [settings]).filter(function(s2) {
      return s2;
    });
    for (var _i = 0, animationSettings_1 = animationSettings; _i < animationSettings_1.length; _i++) {
      var setting = animationSettings_1[_i];
      if (!setting.options) {
        setting.options = {
          fill: "forwards"
        };
        continue;
      }
      switch (setting.options.fill) {
        case "backwards":
        case "both":
          setting.options.fill = "both";
          break;
        default:
          setting.options.fill = "forwards";
      }
    }
    return animateContent(element, clientRect, animationSettings);
  };
  function finishAnimation(animation) {
    return __awaiter(this, void 0, void 0, function() {
      var animationCount, counter;
      return __generator(this, function(_a3) {
        animationCount = Array.isArray(animation) ? animation.filter(function(a) {
          return a;
        }).length : animation ? 1 : 0;
        counter = 0;
        return [2, new Promise(function(resolve) {
          if (!animationCount) {
            resolve();
          }
          var onFinish = function() {
            counter++;
            if (counter === animationCount) {
              resolve();
            }
          };
          animationCallback(animation, function(anim) {
            if (anim.playState === "finished") {
              onFinish();
            } else {
              anim.onfinish = onFinish;
            }
          });
        })];
      });
    });
  }
  var cancelAnimation = function(animation) {
    if (!animation) {
      return;
    }
    animationCallback(animation, function(anim) {
      anim.cancel();
    });
  };
  var animationCallback = function(animation, callback) {
    var animationArray = Array.isArray(animation) ? animation : [animation];
    for (var _i = 0, animationArray_1 = animationArray; _i < animationArray_1.length; _i++) {
      var anim = animationArray_1[_i];
      if (anim && callback) {
        callback(anim);
      }
    }
  };
  var animateContent = function(element, clientRect, settings) {
    if (!element || !settings) {
      return null;
    }
    var settingsArray = (Array.isArray(settings) ? settings : [settings]).filter(function(s2) {
      return s2;
    });
    var settingsKeyframes = [];
    for (var _i = 0, settingsArray_1 = settingsArray; _i < settingsArray_1.length; _i++) {
      var setting = settingsArray_1[_i];
      var keyframes = setting.keyframes;
      if (clientRect) {
        if (Array.isArray(setting.keyframes)) {
          for (var i2 = 0, len = setting.keyframes.length; i2 < len; i2++) {
            keyframes[i2] = replaceKeyframeVariable(setting.keyframes[i2], clientRect);
          }
        } else {
          keyframes = replaceKeyframeVariable(setting.keyframes, clientRect);
        }
      }
      settingsKeyframes.push(keyframes);
    }
    return settingsArray.map(function(setting2, index2) {
      return element.animate(settingsKeyframes[index2], setting2.options);
    });
  };
  var replaceKeyframeVariable = function(keyframe, clientRect) {
    if (!keyframe || !clientRect) {
      return keyframe;
    }
    var replacedKeyframe = __assign({}, keyframe);
    var applyReplace = function(value2) {
      var newValue = value2;
      newValue = replaceVariable(newValue, clientRect.width.toString(), Variable.Width);
      newValue = replaceVariable(newValue, clientRect.height.toString(), Variable.Height);
      newValue = replaceVariable(newValue, clientRect.top.toString(), Variable.Top);
      newValue = replaceVariable(newValue, clientRect.bottom.toString(), Variable.Bottom);
      newValue = replaceVariable(newValue, clientRect.left.toString(), Variable.Left);
      newValue = replaceVariable(newValue, clientRect.right.toString(), Variable.Right);
      return newValue;
    };
    for (var index2 in keyframe) {
      var value = keyframe[index2];
      if (typeof value === "string") {
        replacedKeyframe[index2] = applyReplace(value);
      }
      if (Array.isArray(value)) {
        var valueArray = [];
        for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
          var keyframeValue = value_1[_i];
          if (typeof keyframeValue !== "string") {
            valueArray.push(keyframeValue);
            continue;
          }
          var newKeyframeValue = applyReplace(keyframeValue);
          valueArray.push(newKeyframeValue);
        }
        replacedKeyframe[index2] = valueArray;
      }
    }
    return replacedKeyframe;
  };
  var replaceVariable = function(value, newValue, variable) {
    if (!value || !variable) {
      return value;
    }
    var regExp = new RegExp(variable);
    if (regExp.test(value)) {
      return value.replace(variable, newValue);
    }
    return value;
  };
  var useExitAnimation = function(props) {
    var exitAnimation = reactExports.useRef([]);
    var isRunning = reactExports.useRef(false);
    var prevChildren = props.prevChildren, onFinish = props.onFinish, transitionState = props.transitionState, getElement2 = props.getElement, settings = props.settings, prevClientRect = props.prevClientRect, disabled = props.disabled;
    reactExports.useEffect(function() {
      return function() {
        cancelAnimation(exitAnimation.current);
      };
    }, []);
    var finish = function() {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, finishAnimation(exitAnimation.current)];
            case 1:
              _a3.sent();
              cancelAnimation(exitAnimation.current);
              onFinish();
              isRunning.current = false;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    reactExports.useEffect(function() {
      if (transitionState !== TransitionState.Exit) {
        return;
      }
      if (!prevChildren || disabled) {
        onFinish();
        return;
      }
      if (isRunning.current) {
        return;
      }
      cancelAnimation(exitAnimation.current);
      isRunning.current = true;
      exitAnimation.current = animateExit(getElement2(), prevClientRect, settings);
      finish();
    });
  };
  var useContainerAnimation = function(props) {
    var transitionState = props.transitionState, prevClientRect = props.prevClientRect, nextClientRect = props.nextClientRect, animateContainer$1 = props.animateContainer, onFinish = props.onFinish, getElement2 = props.getElement, disabled = props.disabled;
    var transitionAnimation = reactExports.useRef(null);
    var isRunning = reactExports.useRef(false);
    reactExports.useEffect(function() {
      return function() {
        cancelAnimation(transitionAnimation.current);
      };
    }, []);
    var finish = function() {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, finishAnimation(transitionAnimation.current)];
            case 1:
              _a3.sent();
              onFinish();
              isRunning.current = false;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    reactExports.useLayoutEffect(function() {
      if (transitionState !== TransitionState.Container) {
        return;
      }
      if (!getElement2() || !animateContainer$1 || !prevClientRect || disabled) {
        onFinish();
        return;
      }
      if (isRunning.current) {
        return;
      }
      isRunning.current = true;
      transitionAnimation.current = animateContainer(getElement2(), prevClientRect, nextClientRect, props.animateContainerDuration, props.animateContainerEasing);
      finish();
    });
  };
  var useEnterAnimation = function(props) {
    var enterAnimation = reactExports.useRef([]);
    var isRunning = reactExports.useRef(false);
    var transitionState = props.transitionState, prevChildren = props.prevChildren, getElement2 = props.getElement, nextClientRect = props.nextClientRect, settings = props.settings, disabled = props.disabled, onFinish = props.onFinish;
    reactExports.useEffect(function() {
      return function() {
        cancelAnimation(enterAnimation.current);
      };
    }, []);
    var finish = function() {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, finishAnimation(enterAnimation.current)];
            case 1:
              _a3.sent();
              onFinish();
              isRunning.current = false;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    reactExports.useLayoutEffect(function() {
      if (transitionState !== TransitionState.Enter) {
        return;
      }
      if (!prevChildren || disabled) {
        onFinish();
        return;
      }
      if (isRunning.current) {
        return;
      }
      isRunning.current = true;
      enterAnimation.current = animateEnter(getElement2(), nextClientRect, settings);
      finish();
    });
  };
  var Transition = function(_a3) {
    var animateContainer2 = _a3.animateContainer, animateContainerDuration = _a3.animateContainerDuration, animateContainerEasing = _a3.animateContainerEasing, animateOnMount = _a3.animateOnMount, children = _a3.children, className = _a3.className, classNameEnter = _a3.classNameEnter, classNameExit = _a3.classNameExit, disabled = _a3.disabled, enterAnimation = _a3.enterAnimation, exitAnimation = _a3.exitAnimation, inViewRef = _a3.inViewRef, inViewEnabled = _a3.inViewEnabled, lazy = _a3.lazy, onEnterFinished = _a3.onEnterFinished, onExitFinished = _a3.onExitFinished, style = _a3.style;
    var _b = reactExports.useState(children && !lazy && animateOnMount && !animateContainer2 ? TransitionState.ContainerRect : null), transitionState = _b[0], setTransitionState = _b[1];
    var prevChildren = reactExports.useRef(animateOnMount && animateContainer2 ? null : children);
    var containerRef = reactExports.useRef(null);
    var unmounted = reactExports.useRef(false);
    var hasChildrenChanged = didChildrenChanged(prevChildren.current, children);
    if (!hasChildrenChanged && !transitionState) {
      prevChildren.current = children;
    }
    var udpatedState = function(state) {
      if (!unmounted.current) {
        setTransitionState(state);
      }
    };
    reactExports.useEffect(function() {
      return function() {
        return unmounted.current = true;
      };
    }, []);
    reactExports.useLayoutEffect(function() {
      if (inViewEnabled && animateOnMount && !animateContainer2) {
        udpatedState(TransitionState.ContainerRect);
      }
    }, [inViewEnabled]);
    reactExports.useEffect(function() {
      if (!hasChildrenChanged) {
        return;
      }
      if (!transitionState) {
        udpatedState(TransitionState.Exit);
      }
    });
    var animationHooks = {
      children,
      getElement: function() {
        return containerRef.current;
      },
      prevChildren: prevChildren.current,
      transitionState,
      disabled,
      onFinish: null
    };
    var _c2 = useContainerRectangle(__assign(__assign({}, animationHooks), { onFinish: function() {
      return udpatedState(TransitionState.Container);
    } })), nextClientRect = _c2.nextClientRect, prevClientRect = _c2.prevClientRect;
    var exitFinishedHandler = function() {
      onExitFinished && onExitFinished();
    };
    useExitAnimation(__assign(__assign({}, animationHooks), { prevClientRect, settings: exitAnimation, onFinish: function() {
      var hadPrevChildren = !!prevChildren.current;
      prevChildren.current = children;
      if (hadPrevChildren && !animateContainer2) {
        exitFinishedHandler();
      }
      udpatedState(TransitionState.ContainerRect);
    } }));
    useContainerAnimation(__assign(__assign({}, animationHooks), {
      prevClientRect,
      nextClientRect,
      animateContainer: animateContainer2,
      animateContainerDuration,
      animateContainerEasing,
      onFinish: function() {
        if (!prevChildren.current && animateContainer2) {
          exitFinishedHandler();
        }
        udpatedState(TransitionState.Enter);
      }
    }));
    useEnterAnimation(__assign(__assign({}, animationHooks), { nextClientRect, settings: enterAnimation, onFinish: function() {
      if (prevChildren.current) {
        onEnterFinished && onEnterFinished();
      }
      udpatedState(null);
    } }));
    var shouldRenderPrevChildren = hasChildrenChanged || transitionState === TransitionState.Exit;
    var hideContent = lazy && !inViewEnabled || transitionState === TransitionState.ContainerRect || transitionState === TransitionState.Container;
    var setRefs = reactExports.useCallback(function(element) {
      containerRef.current = element;
      inViewRef && inViewRef(element);
    }, [inViewRef]);
    if (!lazy && !hasChildrenChanged && !transitionState && !children) {
      return null;
    }
    return we$1.createElement("div", { ref: setRefs, className: f$1(className, transitionState === TransitionState.Enter && classNameEnter, transitionState === TransitionState.Exit && classNameExit) || null, style: __assign(__assign({}, style), { opacity: hideContent ? 0 : null }) }, shouldRenderPrevChildren ? prevChildren.current : children);
  };
  var didChildrenChanged = function(prevChildren, children) {
    var prevChildrenElement = prevChildren;
    var childrenElement = children;
    if (!prevChildren && !children) {
      return false;
    }
    if (!prevChildren && children) {
      return true;
    }
    if (prevChildren && !children) {
      return true;
    }
    if (prevChildrenElement.key === childrenElement.key && prevChildrenElement.type === childrenElement.type) {
      return false;
    }
    return true;
  };
  Transition.defaultProps = {
    animateContainer: false,
    animateContainerDuration: defaultTransitionDuration,
    animateContainerEasing: defaultTransitionEasing
  };
  Transition.displayName = "Transition";
  var ObserverMap = /* @__PURE__ */ new Map();
  var RootIds = /* @__PURE__ */ new WeakMap();
  var rootId = 0;
  function getRootId(root2) {
    if (!root2)
      return "0";
    if (RootIds.has(root2))
      return RootIds.get(root2);
    rootId += 1;
    RootIds.set(root2, rootId.toString());
    return RootIds.get(root2);
  }
  function optionsToId(options) {
    return Object.keys(options).sort().filter(function(key) {
      return options[key] !== void 0;
    }).map(function(key) {
      return key + "_" + (key === "root" ? getRootId(options.root) : options[key]);
    }).toString();
  }
  function createObserver(options) {
    var id2 = optionsToId(options);
    var instance = ObserverMap.get(id2);
    if (!instance) {
      var elements = /* @__PURE__ */ new Map();
      var thresholds;
      var observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
          var _elements$get;
          var inView = entry.isIntersecting && thresholds.some(function(threshold) {
            return entry.intersectionRatio >= threshold;
          });
          if (options.trackVisibility && typeof entry.isVisible === "undefined") {
            entry.isVisible = inView;
          }
          (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach(function(callback) {
            callback(inView, entry);
          });
        });
      }, options);
      thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
      instance = {
        id: id2,
        observer,
        elements
      };
      ObserverMap.set(id2, instance);
    }
    return instance;
  }
  function observe(element, callback, options) {
    if (options === void 0) {
      options = {};
    }
    if (!element)
      return function() {
      };
    var _createObserver = createObserver(options), id2 = _createObserver.id, observer = _createObserver.observer, elements = _createObserver.elements;
    var callbacks = elements.get(element) || [];
    if (!elements.has(element)) {
      elements.set(element, callbacks);
    }
    callbacks.push(callback);
    observer.observe(element);
    return function unobserve() {
      callbacks.splice(callbacks.indexOf(callback), 1);
      if (callbacks.length === 0) {
        elements["delete"](element);
        observer.unobserve(element);
      }
      if (elements.size === 0) {
        observer.disconnect();
        ObserverMap["delete"](id2);
      }
    };
  }
  function useInView(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, threshold = _ref.threshold, delay = _ref.delay, trackVisibility = _ref.trackVisibility, rootMargin = _ref.rootMargin, root2 = _ref.root, triggerOnce = _ref.triggerOnce, skip = _ref.skip, initialInView = _ref.initialInView;
    var unobserve = reactExports.useRef();
    var _React$useState = reactExports.useState({
      inView: !!initialInView
    }), state = _React$useState[0], setState = _React$useState[1];
    var setRef = reactExports.useCallback(
      function(node) {
        if (unobserve.current !== void 0) {
          unobserve.current();
          unobserve.current = void 0;
        }
        if (skip)
          return;
        if (node) {
          unobserve.current = observe(node, function(inView, entry) {
            setState({
              inView,
              entry
            });
            if (entry.isIntersecting && triggerOnce && unobserve.current) {
              unobserve.current();
              unobserve.current = void 0;
            }
          }, {
            root: root2,
            rootMargin,
            threshold,
            // @ts-ignore
            trackVisibility,
            // @ts-ignore
            delay
          });
        }
      },
      // We break the rule here, because we aren't including the actual `threshold` variable
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        // If the threshold is an array, convert it to a string so it won't change between renders.
        // eslint-disable-next-line react-hooks/exhaustive-deps
        Array.isArray(threshold) ? threshold.toString() : threshold,
        root2,
        rootMargin,
        triggerOnce,
        skip,
        trackVisibility,
        delay
      ]
    );
    reactExports.useEffect(function() {
      if (!unobserve.current && state.entry && !triggerOnce && !skip) {
        setState({
          inView: !!initialInView
        });
      }
    });
    var result2 = [setRef, state.inView, state.entry];
    result2.ref = result2[0];
    result2.inView = result2[1];
    result2.entry = result2[2];
    return result2;
  }
  var LazyTransition = function(props) {
    var animateOnMount = props.animateOnMount, animateContainer2 = props.animateContainer, children = props.children, disabled = props.disabled, inViewOptions = props.inViewOptions;
    var _a3 = useInView(inViewOptions), inViewRef = _a3[0], inView = _a3[1], entry = _a3[2];
    var observerWait = !entry && animateOnMount && animateContainer2;
    return we$1.createElement(Transition, __assign({}, props, { inViewRef, inViewEnabled: !!entry, disabled: disabled || !inView }), observerWait ? null : children);
  };
  LazyTransition.displayName = "LazyTransition";
  var ComponentTransition = function(props) {
    var context = reactExports.useContext(ComponentTransitionContext);
    var forceExit = (context === null || context === void 0 ? void 0 : context.exitKeys.indexOf(context.contextId)) > -1;
    var forceEnter = (context === null || context === void 0 ? void 0 : context.enterKeys.indexOf(context.contextId)) > -1;
    var animateOnMount = props.animateOnMount, children = props.children, lazy = props.lazy, onEnterFinished = props.onEnterFinished, onExitFinished = props.onExitFinished;
    var handleEnterFinished = function() {
      if (onEnterFinished) {
        onEnterFinished();
      }
      if ((context === null || context === void 0 ? void 0 : context.contextId) && (context === null || context === void 0 ? void 0 : context.onEnterFinished)) {
        context.onEnterFinished(context.contextId);
      }
    };
    var handleExitFinished = function() {
      if (onExitFinished) {
        onExitFinished();
      }
      if ((context === null || context === void 0 ? void 0 : context.contextId) && (context === null || context === void 0 ? void 0 : context.onExitFinished)) {
        context.onExitFinished(context.contextId);
      }
    };
    var Component = lazy ? LazyTransition : Transition;
    return (
      // Clear context for nested transitions
      we$1.createElement(
        ComponentTransitionContext.Provider,
        { value: null },
        we$1.createElement(Component, __assign({}, props, { animateOnMount: forceEnter || animateOnMount, onEnterFinished: handleEnterFinished, onExitFinished: handleExitFinished }), forceExit ? null : children)
      )
    );
  };
  ComponentTransition.displayName = "ComponentTransition";
  const Svg85901Eed410D7B8F = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: 9.1174364, height: 9.1174459, viewBox: "0 0 9.1174364 9.1174459", id: "svg22", ...props }, /* @__PURE__ */ reactExports.createElement("path", { id: "rect18", d: "M 0,7.7032211 7.7032211,0 9.1174351,1.4142136 1.4142136,9.1174351 Z M 1.4e-6,1.4142246 1.414215,1.11e-5 l 7.7032211,7.703221 -1.414213,1.414214 z" }));
  const SvgC707E009107B34Db = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 7", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M19.89.006A10.72 10.72 0 0 0 9.32 10.83v5.88H7.13a5.19 5.19 0 0 0-5.19 5.19v12.92A5.17 5.17 0 0 0 7.13 40H33a5.19 5.19 0 0 0 5.19-5.19V21.9A5.19 5.19 0 0 0 33 16.71h-2.24v-6.09A10.72 10.72 0 0 0 19.89.005zM20 3a7.53 7.53 0 0 1 5.44 2.21 7.71 7.71 0 0 1 2.32 5.44v6.06H12.32l.05-5.91A7.72 7.72 0 0 1 20 3zM7.13 19.71H33a2.21 2.21 0 0 1 1.55.64 2.18 2.18 0 0 1 .64 1.55v12.92A2.19 2.19 0 0 1 33 37H7.13a2.14 2.14 0 0 1-1.55-.65 2.17 2.17 0 0 1-.64-1.54V21.9a2.19 2.19 0 0 1 2.19-2.19z" }));
  const SvgC8F08Adbe83Afe3E = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 5", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M17.3 0A5.3 5.3 0 0 0 12 5.27v17.07a5.3 5.3 0 0 0 5.29 5.3h17.08a5.3 5.3 0 0 0 5.29-5.3V5.29A5.29 5.29 0 0 0 34.37 0H17.3zm0 3h17.07a2.3 2.3 0 0 1 2.29 2.27v17.07a2.3 2.3 0 0 1-2.29 2.3H17.29a2.3 2.3 0 0 1-2.29-2.3V5.27A2.3 2.3 0 0 1 17.3 3zm13.585 4.559a1.503 1.503 0 0 0-.033.002H20a1.5 1.5 0 0 0 0 3h7.309L19 18.869A1.5 1.5 0 0 0 19 21a1.48 1.48 0 0 0 1 .47 1.5 1.5 0 0 0 1.08-.47l8.35-8.32v7.29a1.5 1.5 0 0 0 1.5 1.5 1.5 1.5 0 0 0 1.5-1.47V9.201a1.503 1.503 0 0 0-1.545-1.642zM5.67 12.31A5.29 5.29 0 0 0 .38 17.6v17.08A5.29 5.29 0 0 0 5.67 40h17.08A5.29 5.29 0 0 0 28 34.68v-1.9a1.5 1.5 0 0 0-3 0v1.9A2.3 2.3 0 0 1 22.75 37H5.67a2.3 2.3 0 0 1-2.29-2.32V17.6a2.3 2.3 0 0 1 2.29-2.29h1.9a1.5 1.5 0 0 0 0-3h-1.9z" }));
  const SvgE29A75303Cd009Cd = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 6", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M16.29 0a5.2 5.2 0 0 0-5.2 5.19v2.2H3.34a1.5 1.5 0 0 0 0 3h2.2V34.8a5.2 5.2 0 0 0 5.2 5.2h18.49a5.2 5.2 0 0 0 5.2-5.22V10.39h2.2a1.5 1.5 0 0 0 0-3H28.882V5.2A5.2 5.2 0 0 0 23.68 0h-7.39zm0 3h7.39a2.2 2.2 0 0 1 2.2 2.19v2.2H14.09V5.2a2.21 2.21 0 0 1 2.2-2.2zm-7.75 7.39h3.884a1.5 1.5 0 0 0 .318 0H31.43v24.39a2.2 2.2 0 0 1-2.2 2.2H10.74a2.21 2.21 0 0 1-2.2-2.2V10.39z" }));
  const Svg92Beb0D5816827F1 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 240 240", width: 240, height: 240, ...props }, /* @__PURE__ */ reactExports.createElement("g", { "data-name": "Layer 2" }, /* @__PURE__ */ reactExports.createElement("g", { "data-name": "Layer 1" }, /* @__PURE__ */ reactExports.createElement("path", { d: "M120.037 214.988a94.486 94.486 0 0054.407-17.147l-36.933-44.088a37.84 37.84 0 01-31.657 1.488L68.5 199.76a94.58 94.58 0 0051.538 15.227z", fill: "#3e48f8" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M189.608 55.395l-37.366 44.573a37.893 37.893 0 01-14.773 53.817l36.986 44.087a94.971 94.971 0 0015.164-142.456z", fill: "#00c9ff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M158.025 120.017a37.788 37.788 0 00-5.783-20.05l-46.367 55.284a37.988 37.988 0 0052.15-35.234z", fill: "#00f500" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M68.478 199.761l37.345-44.51a37.988 37.988 0 1146.43-55.347l37.345-44.51a94.971 94.971 0 10-121.12 144.388z", fill: "#292748" }))));
  const Svg79403247197Ec9Cd = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 236 236", style: {
    enableBackground: "new 0 0 236 236"
  }, xmlSpace: "preserve", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M165.2 118.5c0-8.8-2.5-17.4-7.1-24.8l-57.3 68.4c7.1 2.9 14.8 3.9 22.5 3.1 7.6-.8 14.9-3.5 21.3-7.8s11.6-10.1 15.2-16.9c3.5-6.7 5.4-14.3 5.4-22z", style: {
    fill: "#999"
  } }), /* @__PURE__ */ reactExports.createElement("path", { d: "M118.5 229.9c61.5 0 111.4-49.9 111.4-111.4S180 7.1 118.5 7.1 7.1 57 7.1 118.5 57 229.9 118.5 229.9z", style: {
    fill: "#fff",
    stroke: "#fff",
    strokeWidth: 11
  } }), /* @__PURE__ */ reactExports.createElement("path", { d: "M118.3 222.9c21.4 0 42.2-6.6 59.7-18.9l-40.5-48.5c-5.3 2.8-11.2 4.4-17.2 4.6-6 .3-12-.7-17.6-3l-41 49c16.9 11 36.5 16.9 56.6 16.8z", style: {
    fill: "#3e48f8"
  } }), /* @__PURE__ */ reactExports.createElement("path", { d: "m194.7 47.4-41 49c3.1 4.9 5.1 10.4 5.9 16.1.8 5.7.5 11.5-1 17.1-1.5 5.6-4.2 10.8-7.8 15.2-3.6 4.5-8.1 8.2-13.3 10.8l40.6 48.5c12.2-8.6 22.5-19.6 30-32.5 7.6-12.9 12.3-27.2 13.9-42 1.6-14.8 0-29.9-4.7-44-4.8-14.2-12.5-27.2-22.6-38.2z", style: {
    fill: "#00c8ff"
  } }), /* @__PURE__ */ reactExports.createElement("path", { d: "M160 118.5c0-7.8-2.2-15.4-6.3-22l-50.9 60.8c6.3 2.5 13.2 3.5 20 2.8 6.8-.7 13.3-3.1 18.9-6.9 5.6-3.8 10.3-9 13.5-15 3.1-6.1 4.8-12.9 4.8-19.7z", style: {
    fill: "#00f500"
  } }), /* @__PURE__ */ reactExports.createElement("path", { d: "m61.7 206.2 41-48.9c-6.1-2.5-11.5-6.3-15.9-11.3-4.3-5-7.4-10.9-9-17.3-1.6-6.4-1.7-13.1-.2-19.5s4.5-12.4 8.7-17.5 9.6-9 15.7-11.6 12.6-3.7 19.2-3.2 12.9 2.5 18.6 5.9c5.6 3.4 10.4 8.1 13.9 13.7l41-48.9c-10.1-10.9-22.3-19.5-35.9-25.2-13.6-5.8-28.3-8.5-43.1-8.2S86.3 17.9 73 24.4c-13.3 6.4-25.1 15.6-34.6 27C28.9 62.7 21.9 76 17.9 90.3s-4.9 29.2-2.7 43.9c2.2 14.6 7.5 28.7 15.5 41.1 8 12.3 18.6 22.9 31 30.9z", style: {
    fill: "#282846"
  } }));
  var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
  var ReactPropTypesSecret = ReactPropTypesSecret_1;
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  var factoryWithThrowingShims = function() {
    function shim2(props, propName, componentName, location2, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim2.isRequired = shim2;
    function getShim() {
      return shim2;
    }
    var ReactPropTypes = {
      array: shim2,
      bool: shim2,
      func: shim2,
      number: shim2,
      object: shim2,
      string: shim2,
      symbol: shim2,
      any: shim2,
      arrayOf: getShim,
      element: shim2,
      elementType: shim2,
      instanceOf: getShim,
      node: shim2,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  {
    factoryWithThrowingShims();
  }
  var mode$1 = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3
  };
  var mode = mode$1;
  function QR8bitByte(data) {
    this.mode = mode.MODE_8BIT_BYTE;
    this.data = data;
  }
  QR8bitByte.prototype = {
    getLength: function(buffer) {
      return this.data.length;
    },
    write: function(buffer) {
      for (var i2 = 0; i2 < this.data.length; i2++) {
        buffer.put(this.data.charCodeAt(i2), 8);
      }
    }
  };
  var _8BitByte = QR8bitByte;
  var ErrorCorrectLevel$1 = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
  };
  var ECL = ErrorCorrectLevel$1;
  function QRRSBlock(totalCount, dataCount) {
    this.totalCount = totalCount;
    this.dataCount = dataCount;
  }
  QRRSBlock.RS_BLOCK_TABLE = [
    // L
    // M
    // Q
    // H
    // 1
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    // 2
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    // 3
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    // 4		
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    // 5
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    // 6
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    // 7		
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    // 8
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    // 9
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    // 10		
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    // 11
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    // 12
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    // 13
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    // 14
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    // 15
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12],
    // 16
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    // 17
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    // 18
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    // 19
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    // 20
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    // 21
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    // 22
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    // 23
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    // 24
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    // 25
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    // 26
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    // 27
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    // 28
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    // 29
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    // 30
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    // 31
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    // 32
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    // 33
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    // 34
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    // 35
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    // 36
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    // 37
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    // 38
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    // 39
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    // 40
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
  ];
  QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
    var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
    if (rsBlock == void 0) {
      throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
    }
    var length = rsBlock.length / 3;
    var list = new Array();
    for (var i2 = 0; i2 < length; i2++) {
      var count = rsBlock[i2 * 3 + 0];
      var totalCount = rsBlock[i2 * 3 + 1];
      var dataCount = rsBlock[i2 * 3 + 2];
      for (var j = 0; j < count; j++) {
        list.push(new QRRSBlock(totalCount, dataCount));
      }
    }
    return list;
  };
  QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
    switch (errorCorrectLevel) {
      case ECL.L:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case ECL.M:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case ECL.Q:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case ECL.H:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  var RSBlock$1 = QRRSBlock;
  function QRBitBuffer() {
    this.buffer = new Array();
    this.length = 0;
  }
  QRBitBuffer.prototype = {
    get: function(index2) {
      var bufIndex = Math.floor(index2 / 8);
      return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) == 1;
    },
    put: function(num, length) {
      for (var i2 = 0; i2 < length; i2++) {
        this.putBit((num >>> length - i2 - 1 & 1) == 1);
      }
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    }
  };
  var BitBuffer$1 = QRBitBuffer;
  var QRMath = {
    glog: function(n2) {
      if (n2 < 1) {
        throw new Error("glog(" + n2 + ")");
      }
      return QRMath.LOG_TABLE[n2];
    },
    gexp: function(n2) {
      while (n2 < 0) {
        n2 += 255;
      }
      while (n2 >= 256) {
        n2 -= 255;
      }
      return QRMath.EXP_TABLE[n2];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256)
  };
  for (var i = 0; i < 8; i++) {
    QRMath.EXP_TABLE[i] = 1 << i;
  }
  for (var i = 8; i < 256; i++) {
    QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
  }
  for (var i = 0; i < 255; i++) {
    QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
  }
  var math$2 = QRMath;
  var math$1 = math$2;
  function QRPolynomial(num, shift) {
    if (num.length == void 0) {
      throw new Error(num.length + "/" + shift);
    }
    var offset = 0;
    while (offset < num.length && num[offset] == 0) {
      offset++;
    }
    this.num = new Array(num.length - offset + shift);
    for (var i2 = 0; i2 < num.length - offset; i2++) {
      this.num[i2] = num[i2 + offset];
    }
  }
  QRPolynomial.prototype = {
    get: function(index2) {
      return this.num[index2];
    },
    getLength: function() {
      return this.num.length;
    },
    multiply: function(e2) {
      var num = new Array(this.getLength() + e2.getLength() - 1);
      for (var i2 = 0; i2 < this.getLength(); i2++) {
        for (var j = 0; j < e2.getLength(); j++) {
          num[i2 + j] ^= math$1.gexp(math$1.glog(this.get(i2)) + math$1.glog(e2.get(j)));
        }
      }
      return new QRPolynomial(num, 0);
    },
    mod: function(e2) {
      if (this.getLength() - e2.getLength() < 0) {
        return this;
      }
      var ratio = math$1.glog(this.get(0)) - math$1.glog(e2.get(0));
      var num = new Array(this.getLength());
      for (var i2 = 0; i2 < this.getLength(); i2++) {
        num[i2] = this.get(i2);
      }
      for (var i2 = 0; i2 < e2.getLength(); i2++) {
        num[i2] ^= math$1.gexp(math$1.glog(e2.get(i2)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e2);
    }
  };
  var Polynomial$2 = QRPolynomial;
  var Mode = mode$1;
  var Polynomial$1 = Polynomial$2;
  var math = math$2;
  var QRMaskPattern = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  var QRUtil = {
    PATTERN_POSITION_TABLE: [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ],
    G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
    G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
    G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
    getBCHTypeInfo: function(data) {
      var d2 = data << 10;
      while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d2 ^= QRUtil.G15 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data << 10 | d2) ^ QRUtil.G15_MASK;
    },
    getBCHTypeNumber: function(data) {
      var d2 = data << 12;
      while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d2 ^= QRUtil.G18 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data << 12 | d2;
    },
    getBCHDigit: function(data) {
      var digit = 0;
      while (data != 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    },
    getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },
    getMask: function(maskPattern, i2, j) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i2 + j) % 2 == 0;
        case QRMaskPattern.PATTERN001:
          return i2 % 2 == 0;
        case QRMaskPattern.PATTERN010:
          return j % 3 == 0;
        case QRMaskPattern.PATTERN011:
          return (i2 + j) % 3 == 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 == 0;
        case QRMaskPattern.PATTERN101:
          return i2 * j % 2 + i2 * j % 3 == 0;
        case QRMaskPattern.PATTERN110:
          return (i2 * j % 2 + i2 * j % 3) % 2 == 0;
        case QRMaskPattern.PATTERN111:
          return (i2 * j % 3 + (i2 + j) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    },
    getErrorCorrectPolynomial: function(errorCorrectLength) {
      var a = new Polynomial$1([1], 0);
      for (var i2 = 0; i2 < errorCorrectLength; i2++) {
        a = a.multiply(new Polynomial$1([1, math.gexp(i2)], 0));
      }
      return a;
    },
    getLengthInBits: function(mode2, type) {
      if (1 <= type && type < 10) {
        switch (mode2) {
          case Mode.MODE_NUMBER:
            return 10;
          case Mode.MODE_ALPHA_NUM:
            return 9;
          case Mode.MODE_8BIT_BYTE:
            return 8;
          case Mode.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + mode2);
        }
      } else if (type < 27) {
        switch (mode2) {
          case Mode.MODE_NUMBER:
            return 12;
          case Mode.MODE_ALPHA_NUM:
            return 11;
          case Mode.MODE_8BIT_BYTE:
            return 16;
          case Mode.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + mode2);
        }
      } else if (type < 41) {
        switch (mode2) {
          case Mode.MODE_NUMBER:
            return 14;
          case Mode.MODE_ALPHA_NUM:
            return 13;
          case Mode.MODE_8BIT_BYTE:
            return 16;
          case Mode.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + mode2);
        }
      } else {
        throw new Error("type:" + type);
      }
    },
    getLostPoint: function(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0;
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);
          for (var r2 = -1; r2 <= 1; r2++) {
            if (row + r2 < 0 || moduleCount <= row + r2) {
              continue;
            }
            for (var c2 = -1; c2 <= 1; c2++) {
              if (col + c2 < 0 || moduleCount <= col + c2) {
                continue;
              }
              if (r2 == 0 && c2 == 0) {
                continue;
              }
              if (dark == qrCode.isDark(row + r2, col + c2)) {
                sameCount++;
              }
            }
          }
          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      }
      for (var row = 0; row < moduleCount - 1; row++) {
        for (var col = 0; col < moduleCount - 1; col++) {
          var count = 0;
          if (qrCode.isDark(row, col))
            count++;
          if (qrCode.isDark(row + 1, col))
            count++;
          if (qrCode.isDark(row, col + 1))
            count++;
          if (qrCode.isDark(row + 1, col + 1))
            count++;
          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      }
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      }
      var darkCount = 0;
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    }
  };
  var util$1 = QRUtil;
  var BitByte = _8BitByte;
  var RSBlock = RSBlock$1;
  var BitBuffer = BitBuffer$1;
  var util = util$1;
  var Polynomial = Polynomial$2;
  function QRCode$1(typeNumber, errorCorrectLevel) {
    this.typeNumber = typeNumber;
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null;
    this.moduleCount = 0;
    this.dataCache = null;
    this.dataList = [];
  }
  var proto = QRCode$1.prototype;
  proto.addData = function(data) {
    var newData = new BitByte(data);
    this.dataList.push(newData);
    this.dataCache = null;
  };
  proto.isDark = function(row, col) {
    if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
      throw new Error(row + "," + col);
    }
    return this.modules[row][col];
  };
  proto.getModuleCount = function() {
    return this.moduleCount;
  };
  proto.make = function() {
    if (this.typeNumber < 1) {
      var typeNumber = 1;
      for (typeNumber = 1; typeNumber < 40; typeNumber++) {
        var rsBlocks = RSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
        var buffer = new BitBuffer();
        var totalDataCount = 0;
        for (var i2 = 0; i2 < rsBlocks.length; i2++) {
          totalDataCount += rsBlocks[i2].dataCount;
        }
        for (var i2 = 0; i2 < this.dataList.length; i2++) {
          var data = this.dataList[i2];
          buffer.put(data.mode, 4);
          buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
          data.write(buffer);
        }
        if (buffer.getLengthInBits() <= totalDataCount * 8)
          break;
      }
      this.typeNumber = typeNumber;
    }
    this.makeImpl(false, this.getBestMaskPattern());
  };
  proto.makeImpl = function(test, maskPattern) {
    this.moduleCount = this.typeNumber * 4 + 17;
    this.modules = new Array(this.moduleCount);
    for (var row = 0; row < this.moduleCount; row++) {
      this.modules[row] = new Array(this.moduleCount);
      for (var col = 0; col < this.moduleCount; col++) {
        this.modules[row][col] = null;
      }
    }
    this.setupPositionProbePattern(0, 0);
    this.setupPositionProbePattern(this.moduleCount - 7, 0);
    this.setupPositionProbePattern(0, this.moduleCount - 7);
    this.setupPositionAdjustPattern();
    this.setupTimingPattern();
    this.setupTypeInfo(test, maskPattern);
    if (this.typeNumber >= 7) {
      this.setupTypeNumber(test);
    }
    if (this.dataCache == null) {
      this.dataCache = QRCode$1.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
    }
    this.mapData(this.dataCache, maskPattern);
  };
  proto.setupPositionProbePattern = function(row, col) {
    for (var r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || this.moduleCount <= row + r2)
        continue;
      for (var c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || this.moduleCount <= col + c2)
          continue;
        if (0 <= r2 && r2 <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r2 == 0 || r2 == 6) || 2 <= r2 && r2 <= 4 && 2 <= c2 && c2 <= 4) {
          this.modules[row + r2][col + c2] = true;
        } else {
          this.modules[row + r2][col + c2] = false;
        }
      }
    }
  };
  proto.getBestMaskPattern = function() {
    var minLostPoint = 0;
    var pattern = 0;
    for (var i2 = 0; i2 < 8; i2++) {
      this.makeImpl(true, i2);
      var lostPoint = util.getLostPoint(this);
      if (i2 == 0 || minLostPoint > lostPoint) {
        minLostPoint = lostPoint;
        pattern = i2;
      }
    }
    return pattern;
  };
  proto.createMovieClip = function(target_mc, instance_name, depth) {
    var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
    var cs = 1;
    this.make();
    for (var row = 0; row < this.modules.length; row++) {
      var y2 = row * cs;
      for (var col = 0; col < this.modules[row].length; col++) {
        var x2 = col * cs;
        var dark = this.modules[row][col];
        if (dark) {
          qr_mc.beginFill(0, 100);
          qr_mc.moveTo(x2, y2);
          qr_mc.lineTo(x2 + cs, y2);
          qr_mc.lineTo(x2 + cs, y2 + cs);
          qr_mc.lineTo(x2, y2 + cs);
          qr_mc.endFill();
        }
      }
    }
    return qr_mc;
  };
  proto.setupTimingPattern = function() {
    for (var r2 = 8; r2 < this.moduleCount - 8; r2++) {
      if (this.modules[r2][6] != null) {
        continue;
      }
      this.modules[r2][6] = r2 % 2 == 0;
    }
    for (var c2 = 8; c2 < this.moduleCount - 8; c2++) {
      if (this.modules[6][c2] != null) {
        continue;
      }
      this.modules[6][c2] = c2 % 2 == 0;
    }
  };
  proto.setupPositionAdjustPattern = function() {
    var pos = util.getPatternPosition(this.typeNumber);
    for (var i2 = 0; i2 < pos.length; i2++) {
      for (var j = 0; j < pos.length; j++) {
        var row = pos[i2];
        var col = pos[j];
        if (this.modules[row][col] != null) {
          continue;
        }
        for (var r2 = -2; r2 <= 2; r2++) {
          for (var c2 = -2; c2 <= 2; c2++) {
            if (r2 == -2 || r2 == 2 || c2 == -2 || c2 == 2 || r2 == 0 && c2 == 0) {
              this.modules[row + r2][col + c2] = true;
            } else {
              this.modules[row + r2][col + c2] = false;
            }
          }
        }
      }
    }
  };
  proto.setupTypeNumber = function(test) {
    var bits = util.getBCHTypeNumber(this.typeNumber);
    for (var i2 = 0; i2 < 18; i2++) {
      var mod = !test && (bits >> i2 & 1) == 1;
      this.modules[Math.floor(i2 / 3)][i2 % 3 + this.moduleCount - 8 - 3] = mod;
    }
    for (var i2 = 0; i2 < 18; i2++) {
      var mod = !test && (bits >> i2 & 1) == 1;
      this.modules[i2 % 3 + this.moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;
    }
  };
  proto.setupTypeInfo = function(test, maskPattern) {
    var data = this.errorCorrectLevel << 3 | maskPattern;
    var bits = util.getBCHTypeInfo(data);
    for (var i2 = 0; i2 < 15; i2++) {
      var mod = !test && (bits >> i2 & 1) == 1;
      if (i2 < 6) {
        this.modules[i2][8] = mod;
      } else if (i2 < 8) {
        this.modules[i2 + 1][8] = mod;
      } else {
        this.modules[this.moduleCount - 15 + i2][8] = mod;
      }
    }
    for (var i2 = 0; i2 < 15; i2++) {
      var mod = !test && (bits >> i2 & 1) == 1;
      if (i2 < 8) {
        this.modules[8][this.moduleCount - i2 - 1] = mod;
      } else if (i2 < 9) {
        this.modules[8][15 - i2 - 1 + 1] = mod;
      } else {
        this.modules[8][15 - i2 - 1] = mod;
      }
    }
    this.modules[this.moduleCount - 8][8] = !test;
  };
  proto.mapData = function(data, maskPattern) {
    var inc = -1;
    var row = this.moduleCount - 1;
    var bitIndex = 7;
    var byteIndex = 0;
    for (var col = this.moduleCount - 1; col > 0; col -= 2) {
      if (col == 6)
        col--;
      while (true) {
        for (var c2 = 0; c2 < 2; c2++) {
          if (this.modules[row][col - c2] == null) {
            var dark = false;
            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) == 1;
            }
            var mask = util.getMask(maskPattern, row, col - c2);
            if (mask) {
              dark = !dark;
            }
            this.modules[row][col - c2] = dark;
            bitIndex--;
            if (bitIndex == -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc;
        if (row < 0 || this.moduleCount <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  };
  QRCode$1.PAD0 = 236;
  QRCode$1.PAD1 = 17;
  QRCode$1.createData = function(typeNumber, errorCorrectLevel, dataList) {
    var rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
    var buffer = new BitBuffer();
    for (var i2 = 0; i2 < dataList.length; i2++) {
      var data = dataList[i2];
      buffer.put(data.mode, 4);
      buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
      data.write(buffer);
    }
    var totalDataCount = 0;
    for (var i2 = 0; i2 < rsBlocks.length; i2++) {
      totalDataCount += rsBlocks[i2].dataCount;
    }
    if (buffer.getLengthInBits() > totalDataCount * 8) {
      throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
    }
    if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
      buffer.put(0, 4);
    }
    while (buffer.getLengthInBits() % 8 != 0) {
      buffer.putBit(false);
    }
    while (true) {
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCode$1.PAD0, 8);
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCode$1.PAD1, 8);
    }
    return QRCode$1.createBytes(buffer, rsBlocks);
  };
  QRCode$1.createBytes = function(buffer, rsBlocks) {
    var offset = 0;
    var maxDcCount = 0;
    var maxEcCount = 0;
    var dcdata = new Array(rsBlocks.length);
    var ecdata = new Array(rsBlocks.length);
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      var dcCount = rsBlocks[r2].dataCount;
      var ecCount = rsBlocks[r2].totalCount - dcCount;
      maxDcCount = Math.max(maxDcCount, dcCount);
      maxEcCount = Math.max(maxEcCount, ecCount);
      dcdata[r2] = new Array(dcCount);
      for (var i2 = 0; i2 < dcdata[r2].length; i2++) {
        dcdata[r2][i2] = 255 & buffer.buffer[i2 + offset];
      }
      offset += dcCount;
      var rsPoly = util.getErrorCorrectPolynomial(ecCount);
      var rawPoly = new Polynomial(dcdata[r2], rsPoly.getLength() - 1);
      var modPoly = rawPoly.mod(rsPoly);
      ecdata[r2] = new Array(rsPoly.getLength() - 1);
      for (var i2 = 0; i2 < ecdata[r2].length; i2++) {
        var modIndex = i2 + modPoly.getLength() - ecdata[r2].length;
        ecdata[r2][i2] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
      }
    }
    var totalCodeCount = 0;
    for (var i2 = 0; i2 < rsBlocks.length; i2++) {
      totalCodeCount += rsBlocks[i2].totalCount;
    }
    var data = new Array(totalCodeCount);
    var index2 = 0;
    for (var i2 = 0; i2 < maxDcCount; i2++) {
      for (var r2 = 0; r2 < rsBlocks.length; r2++) {
        if (i2 < dcdata[r2].length) {
          data[index2++] = dcdata[r2][i2];
        }
      }
    }
    for (var i2 = 0; i2 < maxEcCount; i2++) {
      for (var r2 = 0; r2 < rsBlocks.length; r2++) {
        if (i2 < ecdata[r2].length) {
          data[index2++] = ecdata[r2][i2];
        }
      }
    }
    return data;
  };
  var QRCode_1 = QRCode$1;
  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof2(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(source, true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized(self2);
  }
  function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf(o2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var React = reactExports;
  var QRCodeImpl = QRCode_1;
  var ErrorCorrectLevel = ErrorCorrectLevel$1;
  function convertStr(str) {
    var out = "";
    for (var i2 = 0; i2 < str.length; i2++) {
      var charcode = str.charCodeAt(i2);
      if (charcode < 128) {
        out += String.fromCharCode(charcode);
      } else if (charcode < 2048) {
        out += String.fromCharCode(192 | charcode >> 6);
        out += String.fromCharCode(128 | charcode & 63);
      } else if (charcode < 55296 || charcode >= 57344) {
        out += String.fromCharCode(224 | charcode >> 12);
        out += String.fromCharCode(128 | charcode >> 6 & 63);
        out += String.fromCharCode(128 | charcode & 63);
      } else {
        i2++;
        charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i2) & 1023);
        out += String.fromCharCode(240 | charcode >> 18);
        out += String.fromCharCode(128 | charcode >> 12 & 63);
        out += String.fromCharCode(128 | charcode >> 6 & 63);
        out += String.fromCharCode(128 | charcode & 63);
      }
    }
    return out;
  }
  var DEFAULT_PROPS = {
    size: 128,
    level: "L",
    bgColor: "#FFFFFF",
    fgColor: "#000000",
    includeMargin: false
  };
  var MARGIN_SIZE = 4;
  var DEFAULT_IMG_SCALE = 0.1;
  function generatePath(modules) {
    var margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var ops = [];
    modules.forEach(function(row, y2) {
      var start = null;
      row.forEach(function(cell, x2) {
        if (!cell && start !== null) {
          ops.push("M".concat(start + margin, " ").concat(y2 + margin, "h").concat(x2 - start, "v1H").concat(start + margin, "z"));
          start = null;
          return;
        }
        if (x2 === row.length - 1) {
          if (!cell) {
            return;
          }
          if (start === null) {
            ops.push("M".concat(x2 + margin, ",").concat(y2 + margin, " h1v1H").concat(x2 + margin, "z"));
          } else {
            ops.push("M".concat(start + margin, ",").concat(y2 + margin, " h").concat(x2 + 1 - start, "v1H").concat(start + margin, "z"));
          }
          return;
        }
        if (cell && start === null) {
          start = x2;
        }
      });
    });
    return ops.join("");
  }
  function excavateModules(modules, excavation) {
    return modules.slice().map(function(row, y2) {
      if (y2 < excavation.y || y2 >= excavation.y + excavation.h) {
        return row;
      }
      return row.map(function(cell, x2) {
        if (x2 < excavation.x || x2 >= excavation.x + excavation.w) {
          return cell;
        }
        return false;
      });
    });
  }
  function getImageSettings(props, cells) {
    var imageSettings = props.imageSettings, size = props.size, includeMargin = props.includeMargin;
    if (imageSettings == null) {
      return null;
    }
    var margin = includeMargin ? MARGIN_SIZE : 0;
    var numCells = cells.length + margin * 2;
    var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
    var scale = numCells / size;
    var w2 = (imageSettings.width || defaultSize) * scale;
    var h2 = (imageSettings.height || defaultSize) * scale;
    var x2 = imageSettings.x == null ? cells.length / 2 - w2 / 2 : imageSettings.x * scale;
    var y2 = imageSettings.y == null ? cells.length / 2 - h2 / 2 : imageSettings.y * scale;
    var excavation = null;
    if (imageSettings.excavate) {
      var floorX = Math.floor(x2);
      var floorY = Math.floor(y2);
      var ceilW = Math.ceil(w2 + x2 - floorX);
      var ceilH = Math.ceil(h2 + y2 - floorY);
      excavation = {
        x: floorX,
        y: floorY,
        w: ceilW,
        h: ceilH
      };
    }
    return {
      x: x2,
      y: y2,
      h: h2,
      w: w2,
      excavation
    };
  }
  var SUPPORTS_PATH2D = function() {
    try {
      new Path2D().addPath(new Path2D());
    } catch (e2) {
      return false;
    }
    return true;
  }();
  var QRCodeCanvas = /* @__PURE__ */ function(_React$PureComponent) {
    _inherits(QRCodeCanvas2, _React$PureComponent);
    function QRCodeCanvas2() {
      var _getPrototypeOf2;
      var _this;
      _classCallCheck(this, QRCodeCanvas2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(QRCodeCanvas2)).call.apply(_getPrototypeOf2, [this].concat(args)));
      _defineProperty(_assertThisInitialized(_this), "_canvas", void 0);
      _defineProperty(_assertThisInitialized(_this), "_image", void 0);
      _defineProperty(_assertThisInitialized(_this), "state", {
        imgLoaded: false
      });
      _defineProperty(_assertThisInitialized(_this), "handleImageLoad", function() {
        _this.setState({
          imgLoaded: true
        });
      });
      return _this;
    }
    _createClass(QRCodeCanvas2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this._image && this._image.complete) {
          this.handleImageLoad();
        }
        this.update();
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        var _this$props$imageSett, _nextProps$imageSetti;
        var currentSrc = (_this$props$imageSett = this.props.imageSettings) === null || _this$props$imageSett === void 0 ? void 0 : _this$props$imageSett.src;
        var nextSrc = (_nextProps$imageSetti = nextProps.imageSettings) === null || _nextProps$imageSetti === void 0 ? void 0 : _nextProps$imageSetti.src;
        if (currentSrc !== nextSrc) {
          this.setState({
            imgLoaded: false
          });
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.update();
      }
    }, {
      key: "update",
      value: function update() {
        var _this$props = this.props, value = _this$props.value, size = _this$props.size, level = _this$props.level, bgColor = _this$props.bgColor, fgColor = _this$props.fgColor, includeMargin = _this$props.includeMargin, imageSettings = _this$props.imageSettings;
        var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
        qrcode.addData(convertStr(value));
        qrcode.make();
        if (this._canvas != null) {
          var canvas = this._canvas;
          var ctx = canvas.getContext("2d");
          if (!ctx) {
            return;
          }
          var cells = qrcode.modules;
          if (cells === null) {
            return;
          }
          var margin = includeMargin ? MARGIN_SIZE : 0;
          var numCells = cells.length + margin * 2;
          var calculatedImageSettings = getImageSettings(this.props, cells);
          if (imageSettings != null && calculatedImageSettings != null) {
            if (calculatedImageSettings.excavation != null) {
              cells = excavateModules(cells, calculatedImageSettings.excavation);
            }
          }
          var pixelRatio = window.devicePixelRatio || 1;
          canvas.height = canvas.width = size * pixelRatio;
          var scale = size / numCells * pixelRatio;
          ctx.scale(scale, scale);
          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, numCells, numCells);
          ctx.fillStyle = fgColor;
          if (SUPPORTS_PATH2D) {
            ctx.fill(new Path2D(generatePath(cells, margin)));
          } else {
            cells.forEach(function(row, rdx) {
              row.forEach(function(cell, cdx) {
                if (cell) {
                  ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
                }
              });
            });
          }
          if (this.state.imgLoaded && this._image && calculatedImageSettings != null) {
            ctx.drawImage(this._image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$props2 = this.props;
        _this$props2.value;
        var size = _this$props2.size;
        _this$props2.level;
        _this$props2.bgColor;
        _this$props2.fgColor;
        var style = _this$props2.style;
        _this$props2.includeMargin;
        var imageSettings = _this$props2.imageSettings, otherProps = _objectWithoutProperties(_this$props2, ["value", "size", "level", "bgColor", "fgColor", "style", "includeMargin", "imageSettings"]);
        var canvasStyle = _objectSpread({
          height: size,
          width: size
        }, style);
        var img = null;
        var imgSrc = imageSettings && imageSettings.src;
        if (imageSettings != null && imgSrc != null) {
          img = React.createElement("img", {
            src: imgSrc,
            style: {
              display: "none"
            },
            onLoad: this.handleImageLoad,
            ref: function ref(_ref) {
              return _this2._image = _ref;
            }
          });
        }
        return React.createElement(React.Fragment, null, React.createElement("canvas", _extends({
          style: canvasStyle,
          height: size,
          width: size,
          ref: function ref(_ref2) {
            return _this2._canvas = _ref2;
          }
        }, otherProps)), img);
      }
    }]);
    return QRCodeCanvas2;
  }(React.PureComponent);
  _defineProperty(QRCodeCanvas, "defaultProps", DEFAULT_PROPS);
  var QRCodeSVG = /* @__PURE__ */ function(_React$PureComponent2) {
    _inherits(QRCodeSVG2, _React$PureComponent2);
    function QRCodeSVG2() {
      _classCallCheck(this, QRCodeSVG2);
      return _possibleConstructorReturn(this, _getPrototypeOf(QRCodeSVG2).apply(this, arguments));
    }
    _createClass(QRCodeSVG2, [{
      key: "render",
      value: function render() {
        var _this$props3 = this.props, value = _this$props3.value, size = _this$props3.size, level = _this$props3.level, bgColor = _this$props3.bgColor, fgColor = _this$props3.fgColor, includeMargin = _this$props3.includeMargin, imageSettings = _this$props3.imageSettings, otherProps = _objectWithoutProperties(_this$props3, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]);
        var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
        qrcode.addData(convertStr(value));
        qrcode.make();
        var cells = qrcode.modules;
        if (cells === null) {
          return null;
        }
        var margin = includeMargin ? MARGIN_SIZE : 0;
        var numCells = cells.length + margin * 2;
        var calculatedImageSettings = getImageSettings(this.props, cells);
        var image = null;
        if (imageSettings != null && calculatedImageSettings != null) {
          if (calculatedImageSettings.excavation != null) {
            cells = excavateModules(cells, calculatedImageSettings.excavation);
          }
          image = React.createElement("image", {
            xlinkHref: imageSettings.src,
            height: calculatedImageSettings.h,
            width: calculatedImageSettings.w,
            x: calculatedImageSettings.x + margin,
            y: calculatedImageSettings.y + margin,
            preserveAspectRatio: "none"
          });
        }
        var fgPath = generatePath(cells, margin);
        return React.createElement("svg", _extends({
          shapeRendering: "crispEdges",
          height: size,
          width: size,
          viewBox: "0 0 ".concat(numCells, " ").concat(numCells)
        }, otherProps), React.createElement("path", {
          fill: bgColor,
          d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z")
        }), React.createElement("path", {
          fill: fgColor,
          d: fgPath
        }), image);
      }
    }]);
    return QRCodeSVG2;
  }(React.PureComponent);
  _defineProperty(QRCodeSVG, "defaultProps", DEFAULT_PROPS);
  var QRCode = function QRCode2(props) {
    var renderAs = props.renderAs, otherProps = _objectWithoutProperties(props, ["renderAs"]);
    var Component = renderAs === "svg" ? QRCodeSVG : QRCodeCanvas;
    return React.createElement(Component, otherProps);
  };
  QRCode.defaultProps = _objectSpread({
    renderAs: "canvas"
  }, DEFAULT_PROPS);
  var lib = QRCode;
  const Mr = /* @__PURE__ */ getDefaultExportFromCjs(lib);
  const SvgEa285Cf2Cf54Ed10 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 .001h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#2557d6" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m.253 235.69h37.441l8.442-19.51h18.9l8.42 19.51h73.668v-14.915l6.576 14.98h38.243l6.576-15.202v15.138h183.08l-.085-32.026h3.542c2.479.083 3.204.302 3.204 4.226v27.8h94.689v-7.455c7.639 3.92 19.518 7.455 35.148 7.455h39.836l8.525-19.51h18.9l8.337 19.51h76.765v-18.532l11.626 18.532h61.515v-122.51h-60.88v14.468l-8.522-14.468h-62.471v14.468l-7.828-14.468h-84.38c-14.123 0-26.539 1.889-36.569 7.153v-7.153h-58.229v7.153c-6.383-5.426-15.079-7.153-24.75-7.153h-212.74l-14.274 31.641-14.659-31.641h-67.005v14.468l-7.362-14.468h-57.145l-26.539 58.246v64.261h.003zm236.34-17.67h-22.464l-.083-68.794-31.775 68.793h-19.24l-31.858-68.854v68.854h-44.57l-8.42-19.592h-45.627l-8.505 19.592h-23.801l39.241-87.837h32.559l37.269 83.164v-83.164h35.766l28.678 59.587 26.344-59.587h36.485zm-165.9-37.823-14.998-35.017-14.915 35.017zm255.3 37.821h-73.203v-87.837h73.203v18.291h-51.289v15.833h50.06v18.005h-50.061v17.542h51.289zm103.16-64.18c0 14.004-9.755 21.24-15.439 23.412 4.794 1.748 8.891 4.838 10.84 7.397 3.094 4.369 3.628 8.271 3.628 16.116v17.255h-22.104l-.083-11.077c0-5.285.528-12.886-3.458-17.112-3.202-3.09-8.083-3.76-15.973-3.76h-23.523v31.95h-21.914v-87.838h50.401c11.199 0 19.451.283 26.535 4.207 6.933 3.924 11.09 9.652 11.09 19.45zm-27.699 13.042c-3.013 1.752-6.573 1.81-10.841 1.81h-26.62v-19.51h26.982c3.818 0 7.804.164 10.393 1.584 2.842 1.28 4.601 4.003 4.601 7.765 0 3.84-1.674 6.929-4.515 8.351zm62.844 51.138h-22.358v-87.837h22.358zm259.56 0h-31.053l-41.535-65.927v65.927h-44.628l-8.527-19.592h-45.521l-8.271 19.592h-25.648c-10.649 0-24.138-2.257-31.773-9.715-7.701-7.458-11.708-17.56-11.708-33.533 0-13.027 2.395-24.936 11.812-34.347 7.085-7.01 18.18-10.242 33.28-10.242h21.215v18.821h-20.771c-7.997 0-12.514 1.14-16.862 5.203-3.735 3.699-6.298 10.69-6.298 19.897 0 9.41 1.951 16.196 6.023 20.628 3.373 3.476 9.506 4.53 15.272 4.53h9.842l30.884-69.076h32.835l37.102 83.081v-83.08h33.366l38.519 61.174v-61.174h22.445zm-133.2-37.82-15.165-35.017-15.081 35.017zm189.04 178.08c-5.322 7.457-15.694 11.238-29.736 11.238h-42.319v-18.84h42.147c4.181 0 7.106-.527 8.868-2.175 1.665-1.474 2.605-3.554 2.591-5.729 0-2.561-1.064-4.593-2.677-5.811-1.59-1.342-3.904-1.95-7.722-1.95-20.574-.67-46.244.608-46.244-27.194 0-12.742 8.443-26.156 31.439-26.156h43.649v-17.479h-40.557c-12.237 0-21.129 2.81-27.425 7.174v-7.175h-59.985c-9.595 0-20.854 2.279-26.179 7.175v-7.175h-107.12v7.175c-8.524-5.892-22.908-7.175-29.549-7.175h-70.656v7.175c-6.745-6.258-21.742-7.175-30.886-7.175h-79.077l-18.094 18.764-16.949-18.764h-118.13v122.59h115.9l18.646-19.062 17.565 19.062 71.442.061v-28.838h7.021c9.479.14 20.66-.228 30.523-4.312v33.085h58.928v-31.952h2.842c3.628 0 3.985.144 3.985 3.615v28.333h179.01c11.364 0 23.244-2.786 29.824-7.845v7.845h56.78c11.815 0 23.354-1.587 32.134-5.649l.002-22.84zm-354.94-47.155c0 24.406-19.005 29.445-38.159 29.445h-27.343v29.469h-42.591l-26.984-29.086-28.042 29.086h-86.802v-87.859h88.135l26.961 28.799 27.875-28.799h70.021c17.389 0 36.929 4.613 36.929 28.945zm-174.22 40.434h-53.878v-17.48h48.11v-17.926h-48.11v-15.974h54.939l23.969 25.604zm86.81 10.06-33.644-35.789 33.644-34.65zm49.757-39.066h-28.318v-22.374h28.572c7.912 0 13.404 3.09 13.404 10.772 0 7.599-5.238 11.602-13.658 11.602zm148.36-40.373h73.138v18.17h-51.315v15.973h50.062v17.926h-50.062v17.48l51.314.08v18.23h-73.139zm-28.119 47.029c4.878 1.725 8.865 4.816 10.734 7.375 3.095 4.291 3.542 8.294 3.631 16.037v17.418h-22.002v-10.992c0-5.286.531-13.112-3.542-17.198-3.201-3.147-8.083-3.899-16.076-3.899h-23.42v32.09h-22.02v-87.859h50.594c11.093 0 19.173.47 26.366 4.146 6.915 4.004 11.266 9.487 11.266 19.511-.001 14.022-9.764 21.178-15.531 23.371zm-12.385-11.107c-2.932 1.667-6.556 1.811-10.818 1.811h-26.622v-19.732h26.982c3.902 0 7.807.08 10.458 1.587 2.84 1.423 4.538 4.146 4.538 7.903 0 3.758-1.699 6.786-4.538 8.431zm197.82 5.597c4.27 4.229 6.554 9.571 6.554 18.613 0 18.9-12.322 27.723-34.425 27.723h-42.68v-18.84h42.51c4.157 0 7.104-.525 8.95-2.175 1.508-1.358 2.589-3.333 2.589-5.729 0-2.561-1.17-4.592-2.675-5.811-1.675-1.34-3.986-1.949-7.803-1.949-20.493-.67-46.157.609-46.157-27.192 0-12.744 8.355-26.158 31.33-26.158h43.932v18.7h-40.198c-3.984 0-6.575.145-8.779 1.587-2.4 1.422-3.29 3.534-3.29 6.319 0 3.314 2.037 5.57 4.795 6.546 2.311.77 4.795.995 8.526.995l11.797.306c11.895.276 20.061 2.248 25.024 7.065zm86.955-23.52h-39.938c-3.986 0-6.638.144-8.867 1.587-2.312 1.423-3.202 3.534-3.202 6.322 0 3.314 1.951 5.568 4.791 6.544 2.312.771 4.795.996 8.444.996l11.878.304c11.983.284 19.982 2.258 24.86 7.072.891.67 1.422 1.422 2.033 2.175v-25z", fill: "#fff" }));
  const Svg4Bda20Dc465Fd5E8 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#0079be" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m599.93 251.45c0-99.415-82.98-168.13-173.9-168.1h-78.242c-92.003-.033-167.73 68.705-167.73 168.1 0 90.93 75.727 165.64 167.73 165.2h78.242c90.914.436 173.9-74.294 173.9-165.2z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m348.28 97.43c-84.07.027-152.19 68.308-152.21 152.58.02 84.258 68.144 152.53 152.21 152.56 84.09-.027 152.23-68.303 152.24-152.56-.011-84.272-68.149-152.55-152.24-152.58z", fill: "#0079be" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m252.07 249.6c.08-41.181 25.746-76.297 61.94-90.25v180.48c-36.194-13.948-61.861-49.045-61.94-90.23zm131 90.274v-180.53c36.207 13.92 61.914 49.057 61.979 90.257-.065 41.212-25.772 76.322-61.979 90.269z", fill: "#fff" }));
  const Svg96E6C7C43A915C12 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("g", { fillRule: "evenodd" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m54.992 0c-30.365 0-54.992 24.63-54.992 55.004v390.992c0 30.38 24.619 55.004 54.992 55.004h670.016c30.365 0 54.992-24.63 54.992-55.004v-390.992c0-30.38-24.619-55.004-54.992-55.004z", fill: "#4d4d4d" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m327.152 161.893c8.837 0 16.248 1.784 25.268 6.09v22.751c-8.544-7.863-15.955-11.154-25.756-11.154-19.264 0-34.414 15.015-34.414 34.05 0 20.075 14.681 34.196 35.37 34.196 9.312 0 16.586-3.12 24.8-10.857v22.763c-9.341 4.14-16.911 5.776-25.756 5.776-31.278 0-55.582-22.596-55.582-51.737 0-28.826 24.951-51.878 56.07-51.878zm-97.113.627c11.546 0 22.11 3.72 30.943 10.994l-10.748 13.248c-5.35-5.646-10.41-8.028-16.564-8.028-8.853 0-15.3 4.745-15.3 10.989 0 5.354 3.619 8.188 15.944 12.482 23.365 8.044 30.29 15.176 30.29 30.926 0 19.193-14.976 32.553-36.32 32.553-15.63 0-26.994-5.795-36.458-18.872l13.268-12.03c4.73 8.61 12.622 13.222 22.42 13.222 9.163 0 15.947-5.952 15.947-13.984 0-4.164-2.055-7.734-6.158-10.258-2.066-1.195-6.158-2.977-14.2-5.647-19.291-6.538-25.91-13.527-25.91-27.185 0-16.225 14.214-28.41 32.846-28.41zm234.723 1.728h22.437l28.084 66.592 28.446-66.592h22.267l-45.494 101.686h-11.053zm-397.348.152h30.15c33.312 0 56.534 20.382 56.534 49.641 0 14.59-7.104 28.696-19.118 38.057-10.108 7.901-21.626 11.445-37.574 11.445h-29.992zm96.135 0h20.54v99.143h-20.54zm411.734 0h58.252v16.8h-37.725v22.005h36.336v16.791h-36.336v26.762h37.726v16.785h-58.252v-99.143zm71.858 0h30.455c23.69 0 37.265 10.71 37.265 29.272 0 15.18-8.514 25.14-23.986 28.105l33.148 41.766h-25.26l-28.429-39.828h-2.678v39.828h-20.515zm20.515 15.616v30.025h6.002c13.117 0 20.069-5.362 20.069-15.328 0-9.648-6.954-14.697-19.745-14.697zm-579.716 1.183v65.559h5.512c13.273 0 21.656-2.394 28.11-7.88 7.103-5.955 11.376-15.465 11.376-24.98 0-9.499-4.273-18.725-11.376-24.681-6.785-5.78-14.837-8.018-28.11-8.018z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m415.13 161.21c30.941 0 56.022 23.58 56.022 52.709v.033c0 29.13-25.081 52.742-56.021 52.742s-56.022-23.613-56.022-52.742v-.033c0-29.13 25.082-52.71 56.022-52.71zm364.85 127.15c-26.05 18.33-221.08 149.34-558.75 212.62h503.76c30.365 0 54.992-24.63 54.992-55.004v-157.62z", fill: "#f47216" })));
  const Svg4Cd29C4C3E16Daa4 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m41.68 0h698.14c23.027 0 41.68 18.983 41.68 42.42v414.66c0 23.437-18.652 42.42-41.68 42.42h-698.14c-23.028 0-41.68-18.983-41.68-42.42v-414.66c0-23.437 18.652-42.42 41.68-42.42z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m167.25 181.4c6.8-2.3 14.1-3.5 21.7-3.5 33.2 0 60.9 23.601 67.2 54.9l47-9.6c-10.8-53.2-57.8-93.301-114.2-93.301-12.9 0-25.3 2.101-36.9 6z", fill: "#fff100" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m111.75 333.8 31.8-36c-14.2-12.6-23.1-30.9-23.1-51.4 0-20.399 8.9-38.8 23.1-51.3l-31.8-35.899c-24.1 21.399-39.3 52.5-39.3 87.3 0 34.699 15.2 65.898 39.3 87.299z", fill: "#00a3df" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m256.15 260.2c-6.4 31.3-34 54.8-67.2 54.8-7.6 0-14.9-1.2-21.8-3.5l-15.2 45.5c11.6 3.899 24.1 6 37 6 56.4 0 103.4-40 114.2-93.2z", fill: "#ee4023" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m459.75 292.4c-7.8 7.601-18.3 12.2-29.9 12-8-.1-15.399-2.5-21.6-6.5l-15.601 24.801c10.7 6.699 23.2 10.699 36.801 10.899 19.699.3 37.699-7.5 50.8-20.2zm-28.2-101.1c-39.2-.6-71.6 30.8-72.2 70-.2 14.7 4 28.5 11.5 39.9l128.8-55.101c-7.2-30.899-34.8-54.2-68.1-54.799m-42.7 75.599c-.2-1.6-.3-3.3-.3-5 .4-23.1 19.4-41.6 42.5-41.199 12.6.199 23.8 5.899 31.3 14.899zm151.3-107.6v137.3l23.801 9.9-11.301 27.1-23.6-9.8c-5.3-2.3-8.9-5.8-11.6-9.8-2.601-4-4.601-9.601-4.601-17v-137.7zm85.901 63.5c4.2-1.4 8.6-2.1 13.3-2.1 20.3 0 37.101 14.399 41 33.5l28.7-5.9c-6.6-32.5-35.3-56.9-69.7-56.9-7.899 0-15.5 1.301-22.5 3.601zm-33.901 92.9 19.4-21.9c-8.7-7.7-14.1-18.9-14.1-31.4s5.5-23.699 14.1-31.3l-19.4-21.899c-14.699 13-24 32.1-24 53.3s9.301 40.199 24 53.199zm88.201-44.801c-3.899 19.101-20.8 33.5-41 33.5-4.6 0-9.1-.8-13.3-2.199l-9.3 27.8c7.1 2.399 14.7 3.7 22.6 3.7 34.4 0 63.101-24.4 69.7-56.9z", fill: "#fff" }));
  const SvgAcb05338A032C728 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M39.756-14C10.72-14-13.5 9.393-13.5 38.31v391.756c0 28.917 24.22 52.311 53.256 52.311H709.24c29.037 0 53.26-23.394 53.26-52.31V38.31C762.5 9.394 738.277-14 709.24-14H39.756zm0 30H709.24c13.227 0 23.26 10.018 23.26 22.31v11.188h-716V38.311C16.5 26.018 26.534 16 39.756 16zM16.5 144.64h716v285.426c0 12.293-10.033 22.311-23.26 22.311H39.756c-13.221 0-23.256-10.02-23.256-22.31V144.64z", transform: "translate(15 15)" }));
  const SvgDf6706Eae6F7E6B2 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", viewBox: "0 0 780 500", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m724.3 0h-668.6c-30.3 0-54.9 24.6-54.9 54.9v390.2c0 30.3 24.6 54.9 54.9 54.9h668.7c30.3 0 54.9-24.6 54.9-54.9v-390.2c-.1-30.3-24.7-54.9-55-54.9z", fill: "#f37421" }), /* @__PURE__ */ reactExports.createElement("g", { fill: "#fff" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m100 139.9v175h39.7v-73.2h65.2v73.2h39.5v-175h-39.5v67.3h-65.2v-67.3z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m586.2 264c.5-2.9 1.3-8.8 1.3-15.6 0-31.4-15.6-63.4-56.6-63.4-44.1 0-64.1 35.6-64.1 67.8 0 39.7 24.7 64.7 67.8 64.7 17.1 0 33-2.6 46-7.8l-5.2-26.7c-10.6 3.4-21.6 5.2-35.1 5.2-18.4 0-34.5-7.8-35.8-24.1h81.7zm-82.1-27c1-10.6 7.8-25.7 24.4-25.7 18.2 0 22.3 16.1 22.3 25.7z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m600.1 314.9h39.5v-64.4c0-3.1.3-6.2.8-8.8 2.6-12.2 12.5-20 27-20 4.4 0 7.8.5 10.6 1v-37.1c-2.9-.5-4.7-.5-8.3-.5-12.2 0-27.8 7.8-34.3 26.2h-1l-1.3-23.4h-34c.5 10.9 1 23.1 1 41.8z" })), /* @__PURE__ */ reactExports.createElement("path", { clipRule: "evenodd", d: "m284.5 132.9c11.2 0 20.3 9.1 20.3 20.3s-9.1 20.3-20.3 20.3-20.3-9.1-20.3-20.3 9.1-20.3 20.3-20.3z", fill: "#ffe700", fillRule: "evenodd" }), /* @__PURE__ */ reactExports.createElement("path", { clipRule: "evenodd", d: "m367.9 285.3h19.8c19.9 0 28.9-12.7 28.9-26s-1-43.3-25.5-43.3c-28.2 0-23.7 37.3-23.5 56.8-.1 4.2.2 8.4.3 12.5zm-103.7-97.5h40.6v71.6c0 13.3 7.4 26 23.7 26 .1-32.2 0-65.4-1.1-97.6h33.9c.7 6.2 1.4 12.4 2 18.6 16-32 66.5-25 83.5 2.1 17.5 27.9 23.5 107.9-59.1 107.9h-19.2c.2 16.2.2 32.5.2 48.8h-40.6c0-15.6.1-32 .2-48.8-43.9-.2-64.1-28-64.1-57z", fill: "#fff", fillRule: "evenodd" }));
  const SvgC919F85Dd32Ab2Ca = (props) => /* @__PURE__ */ reactExports.createElement("svg", { height: 471, viewBox: "0 0 750 471", width: 750, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("g", { fill: "none" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m697.115385 0h-644.2307696c-29.1605769 0-52.8846154 23.1955749-52.8846154 51.7065868v367.5868262c0 28.511012 23.7240385 51.706587 52.8846154 51.706587h644.2307696c29.158653 0 52.884615-23.195575 52.884615-51.706587v-367.5868262c0-28.5110119-23.725962-51.7065868-52.884615-51.7065868z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m321.004048 378.440089-274.004048.098495v-.659826c0-.362427.4370157-2.713896.9706147-5.226019.5345553-2.511167 1.3645982-6.506466 1.8465586-8.877061.4800478-2.371551 1.3024406-6.400319 1.8255206-8.954518.5240363-2.552286 1.3951988-6.805778 1.9354918-9.450822.5393366-2.644089 1.3846798-6.822991 1.8790717-9.284432.4943919-2.463353 1.317741-6.493077 1.8322146-8.954518.5135173-2.462397 1.3904175-6.714932 1.9479232-9.450823.5565495-2.73589 1.402849-6.914793 1.8809844-9.286344.4781353-2.371551 1.2374141-6.027373 1.6878176-8.123519.4494472-2.098057 1.0241659-4.9334 1.2747088-6.301823.2514991-1.367467 1.0652854-5.397192 1.8083077-8.953562s1.56159-7.586095 1.8216956-8.953562c.2591493-1.368423 1.0824983-5.398148 1.8303019-8.954518.7468474-3.555414 1.5673276-7.585139 1.8236081-8.953562.2562806-1.367467 1.0815421-5.397191 1.8331708-8.953562.7535413-3.557327 1.5663713-7.511506 1.805439-8.788127.2409802-1.276621.8988944-4.559498 1.463094-7.295389.5632434-2.73589 1.6304415-7.884451 2.3705949-11.440821.7411098-3.557327 2.0072121-9.750136 2.8133482-13.763603.8080487-4.012512 1.7729258-8.787171 2.144915-10.610779.371033-1.823608 1.0432913-5.107442 1.4936947-7.296345.4504035-2.188904 1.2670586-6.143083 1.815958-8.787171.5488993-2.646001 1.4410998-6.973125 1.9833053-9.61817.5431617-2.644088 1.3789422-6.748402 1.8580338-9.118997.4790916-2.371551 1.296703-6.32573 1.8169142-8.788127s1.4152805-6.790478 1.9890429-9.617213c.5737624-2.827693 1.5348143-7.154817 2.1353523-9.617214.6005379-2.462397 1.4497063-5.446918 1.8876782-6.631737.4370157-1.186732 1.6447854-3.755275 2.6832954-5.711804l1.888634-3.554458 1.716506-2.249149c.942883-1.235502 2.628788-3.189162 3.744756-4.340512s2.997908-2.884112 4.18464-3.849946c1.18482-.966789 2.901325-2.271143 3.812651-2.898456.912282-.627314 2.703377-1.726069 3.979999-2.441359 1.276621-.71529 3.068672-1.651479 3.979998-2.080845.912282-.429365 2.777966-1.2144636 4.145433-1.7432813 1.367467-.5278613 3.979042-1.4143242 5.80265-1.9680049 1.823608-.554637 5.248014-1.3904175 7.609046-1.8561213 2.361032-.4666601 6.090487-1.0901485 8.290866-1.3856361l3.998168-.5374241 274.169483-.1032773 274.168526-.106146v.6598267c0 .3624266-.439884 2.7138961-.976352 5.2250627-.53838 2.5111666-1.436319 6.8048216-1.996693 9.5407126-.561331 2.73589-1.377986 6.691025-1.817871 8.788127-.438928 2.098057-1.270883 6.126825-1.848471 8.953561-.576631 2.827693-1.465006 7.155774-1.972786 9.617214-.50778 2.462397-1.331129 6.492121-1.82839 8.953562-.49726 2.463353-1.325391 6.492121-1.838908 8.954518-.51543 2.462397-1.311047 6.342943-1.771969 8.622692-.460923 2.27975-1.293835 6.383107-1.85134 9.118997-.558462 2.73589-1.454488 7.063971-1.991912 9.617214-.53838 2.553242-1.355992 6.508378-1.818827 8.788127-.464747 2.279749-1.297659 6.383106-1.853252 9.118997-.55655 2.73589-1.450663 7.063971-1.988087 9.61817-.537424 2.553242-1.337823 6.432832-1.77962 8.621736-.44084 2.187947-1.271839 6.29226-1.845602 9.118996-.574719 2.826736-1.409543 6.93105-1.85899 9.12091-.449447 2.187947-1.249846 6.068493-1.77962 8.620779-.531686 2.554199-1.439187 6.956869-2.015818 9.783605-.5795 2.827692-1.406674 6.855504-1.838908 8.954518-.434147 2.096145-1.244109 6.051281-1.802571 8.786215-.557505 2.737803-1.444925 7.063971-1.972786 9.61817-.526905 2.553242-1.353123 6.582967-1.836996 8.954518-.48196 2.370595-1.322522 6.474908-1.864728 9.118997-.544118 2.644088-1.431537 6.972169-1.972786 9.616257-.541249 2.645045-1.352167 6.60018-1.80257 8.789083-.450403 2.187948-1.272796 6.217672-1.828389 8.953562-.555594 2.735891-1.460226 7.047715-2.009125 9.580876l-.998347 4.606355-1.1896 3.186294c-.654089 1.752844-1.638092 4.082319-2.186991 5.177249-.546987 1.093018-1.662955 3.024684-2.478654 4.290787-.816655 1.265146-1.954617 2.886024-2.528379 3.602271-.573763.716247-2.301744 2.565674-3.841339 4.111007l-2.795179 2.806655-2.691902 1.912541c-1.480307 1.051898-3.075366 2.121965-3.542983 2.377289-.468572.255324-2.252017 1.16665-3.963742 2.022512-1.710768.857775-4.129176 1.947923-5.371372 2.42319-1.243151.477179-3.705548 1.28714-5.47178 1.800658-1.766232.515429-3.659648 1.022253-4.206635 1.126486-.547943.10519-2.44614.497261-4.220978.874032-1.773882.375814-5.355116.937145-7.958084 1.246977l-4.73354.563243zm-97.486053-70.873998h7.129954l.200817-.524993c.111884-.288793.201773-.966789.201773-1.507082 0-.541249.235243-2.505429.52308-4.366332.286881-1.862815.960096-6.145951 1.49752-9.519674.536468-3.374679 1.339735-8.448651 1.785357-11.275387.445622-2.827692.98974-6.44622 1.209682-8.042236.218986-1.596016.485786-2.901325.593844-2.901325.107103 0 .568025.704772 1.024166 1.567328l.828131 1.566371 1.837952 1.853252 1.838908 1.85134 2.262537.906545 2.263492.905588 2.696683.349995 2.69764.349039 3.422492-.209423 3.423449-.21038 3.706505-.959139 3.707461-.960096 1.989043-.906545c1.09493-.500129 3.034247-1.589321 4.310868-2.421277l2.321825-1.511864 2.164041-2.16404c1.190557-1.187688 2.869768-3.096404 3.730411-4.239148.862557-1.141787 1.567328-2.159259 1.567328-2.260624 0-.10232.423628-.809004.94097-1.572108.517343-.762148 1.574978-2.879331 2.35147-4.702939.777448-1.823608 1.989999-5.106486 2.697639-7.295389l1.285228-3.979998.664608-3.4464c.365295-1.895328.835781-5.029027 1.045204-6.964519l.379639-3.516207-.219942-2.98452-.218986-2.984521-.69234-2.985477-.691384-2.984521-1.120749-2.233848-1.119793-2.234804-2.16404-2.294093-2.163084-2.294094-2.559937-1.322522-2.559936-1.322522-2.819086-.676084-2.819086-.67417-2.819086-.206555-2.818129-.206554-3.139437.360514-3.141349.360514-2.561849.655045-2.562805.653133-2.227154 1.031816c-1.224027.565156-3.006515 1.52812-3.958961 2.138221-.953401.610101-1.937404 1.311047-2.186034 1.558721-.247674.247674-.843431.707641-1.321566 1.019385l-.871163.570893.608188-2.913756c.335651-1.601754.614882-3.098317.622533-3.327822l.013387-.414065h-6.080925-6.079012l-1.065285 6.715888c-.587151 3.694074-1.512821 9.401097-2.057895 12.68493-.545074 3.282877-1.368423 8.206715-1.827433 10.942605s-1.278534 7.586095-1.821696 10.778126c-.542205 3.191075-1.438231 8.266004-1.991911 11.275387-.553681 3.009384-1.363642 7.412054-1.801614 9.783605-.437016 2.370595-1.261321 6.846898-1.829346 9.947127-.568025 3.102142-1.482219 8.02598-2.031119 10.944517-.548899 2.917582-1.4411 7.544019-1.983305 10.27991-.543162 2.73589-1.067198 5.311127-1.167606 5.720411l-.180736.746847zm30.696287-38.341671-2.768403.166391-1.809264-.32035-1.81022-.319395-1.837953-.838649-1.838908-.839606-1.283315-1.226895-1.284272-1.224983-.741109-1.658173c-.408328-.912282-.931408-2.461441-1.163782-3.44353l-.422671-1.784401.16926-2.858293.170216-2.857337.853949-4.477259c.469529-2.462397 1.31296-7.088834 1.874291-10.279909.561331-3.192032 1.412412-7.870108 1.889591-10.393706l.867337-4.590099 1.901066-1.581671c1.04616-.86925 2.702421-2.035901 3.681642-2.590538l1.778663-1.009821 2.320869-.71816 2.321825-.719115 2.984521-.174998 2.984521-.174997 2.430839.518299 2.429884.517342 1.71555.789879 1.714593.78988 1.438231 1.445881 1.439187 1.445881.774579 1.53099c.427453.842474 1.027035 2.490128 1.332085 3.662516l.555594 2.131527-.170217 6.301824-.170216 6.300867-.851081 3.724674c-.468572 2.048332-1.359816 5.182031-1.981392 6.963563l-1.129356 3.239845-1.38468 2.622094c-.761191 1.443012-1.934535 3.391892-2.60775 4.331906-.673214.939057-1.747106 2.158303-2.385895 2.705289-.636876.5489-1.706943 1.406674-2.375376 1.904891l-1.21542.907501-2.814305.957227-2.814304.957227zm68.862005 9.116128 3.648172.042076 3.647216-.332782c2.007212-.182648 5.290089-.5642 7.295389-.847256 2.007212-.2821 5.472737-.915151 7.70276-1.404762l4.053631-.8922.202729-1.495607c.110928-.821437.566113-3.267577 1.011735-5.436399l.809961-3.944616-.179779-.177867-.177866-.177866-1.239327.597669c-.681821.328957-2.805698 1.115012-4.718239 1.745194l-3.478913 1.145612-3.651041.708597-3.651041.706684-5.803607.012431-5.803606.009563-1.99-.634964c-1.093973-.349038-2.703377-.987827-3.576452-1.421018l-1.586453-.785098-1.31009-1.183863-1.310091-1.183863-1.022253-1.785357-1.022254-1.78727-.640701-2.239586-.640701-2.240542-.003825-4.146389-.004782-4.147346.568025-3.697899.569937-3.699811 4.98982-.23333 4.98982-.23333 18.447417.119534 18.446461.117621.556549-2.361988c.306963-1.299572.775536-3.985736 1.041379-5.969041l.483873-3.607053.010519-3.033291.010519-3.034246-.524993-2.265405-.525949-2.264449-.86925-1.499433c-.476222-.824305-1.318697-2.019643-1.869509-2.656519-.550812-.63592-1.534814-1.532902-2.186034-1.992868-.652177-.459967-1.930711-1.233589-2.842993-1.718419l-1.658173-.881681-2.896544-.698078-2.8975-.697121-3.568802-.341389-3.570715-.341388-3.31539.216117-3.316346.215161-3.979999.76406-3.979042.765017-2.488216.993565c-1.367467.54603-3.456918 1.544377-4.641738 2.216635-1.185775.672258-2.826736 1.766232-3.647216 2.43084-.822392.665564-2.243411 1.958442-3.158562 2.873593-.916107.916107-2.272099 2.55898-3.011296 3.65391-.740153 1.09493-1.87429 3.034247-2.521685 4.310868-.646439 1.277578-1.488914 3.067716-1.872378 3.979999-.382509.911326-1.07963 2.77701-1.547246 4.144477-.468573 1.368423-1.203945 3.979998-1.634267 5.804562-.431278 1.823608-1.021297 4.825342-1.312959 6.670944l-.528818 3.35651.005738 4.934356.004781 4.934357.503955 2.15639c.276362 1.184819.807092 2.976871 1.177169 3.979042.370076 1.003128 1.056679 2.495867 1.523339 3.316347s1.465006 2.142046 2.216635 2.936707 2.113358 2.000518 3.02564 2.678514c.911326.678952 2.535074 1.634266 3.607053 2.121964l1.949836.88742 2.718677.657914c1.494651.360514 3.75145.788923 5.014684.951489 1.262277.16161 3.936966.313657 5.943222.335651zm6.245403-46.716689c-9.180198 0-16.691704-.065026-16.691704-.146309 0-.079371.392071-1.236458.871163-2.570456.478135-1.333041 1.319653-3.316346 1.867596-4.408407l.999303-1.986174 2.192729-2.181254 2.193684-2.183166 2.156391-1.029903c1.184819-.567069 2.752147-1.184819 3.480825-1.372248.730591-.18743 2.819086-.43606 4.642694-.551769l3.317303-.213248 2.547505.328001 2.545592.327044 1.850384.847256 1.85134.847256 1.015559 1.09493c.557506.601494 1.22307 1.487957 1.478394 1.968961l.462835.875944.306007 1.943142.306963 1.943142-.350952 3.233151-.349995 3.234107zm99.213078 46.718602 3.650085.040163 4.142564-.490567c2.278793-.270624 5.312083-.717203 6.741708-.995478 1.427712-.276362 3.740931-.826217 5.139955-1.220201 1.398067-.395896 2.663213-.823349 2.811435-.949577.148222-.127184.542206-1.632354.877857-3.345034.334694-1.711725.757366-4.008687.938101-5.10266.179779-1.09493.273494-2.048332.207511-2.120052-.066939-.071721-.310788.021038-.543162.204642-.23333.185516-1.859946.870206-3.616615 1.522382l-3.192988 1.185776-4.547067.880725-4.548023.880725-3.865246-.131009-3.866202-.131965-2.196554-.762148-2.196553-.762147-1.696424-1.483176-1.696424-1.485088-1.126487-2.050245-1.124574-2.049288-.537425-2.74354-.535511-2.742584.003825-3.557327.002869-3.558283.65122-4.310868.652177-4.311824.688515-2.321825c.379639-1.276622.809004-2.768404.953401-3.315391.14631-.547943.753542-2.114314 1.352167-3.482737.597669-1.367467 1.664867-3.481781 2.370595-4.698158l1.283315-2.209941 1.57689-1.634267 1.576891-1.634266 1.668692-1.034685 1.670605-1.035641 2.143958-.660783c1.179082-.363383 3.263752-.834824 4.631219-1.047116l2.48726-.388246 3.647216.183604 3.648173.182647 4.310868.863513 4.311824.8616 1.752844.654089c.963921.359557 1.79492.655045 1.847515.655045.050682 0 .2821-1.231676.513517-2.736846.231418-1.504214.642614-3.979999.914195-5.500469.272537-1.522383.429365-2.832474.348082-2.911844-.07937-.080327-1.375117-.285925-2.878374-.457098-1.504214-.171172-5.591315-.475266-9.082659-.677039l-6.34868-.364339-4.477259.343301-4.476303.344257-3.317303.696165-3.31539.697122-2.136309.853949c-1.1743.469529-2.894631 1.317741-3.82317 1.883853-.928539.567069-2.108577 1.32826-2.624963 1.692599-.516386.365296-2.080845 1.788227-3.478912 3.163344l-2.538899 2.499691-1.419105 2.07702c-.779361 1.142743-2.127703 3.523857-2.996953 5.293914l-1.579759 3.216895-1.211595 3.480825c-.665564 1.91541-1.596015 5.049109-2.065544 6.964519l-.855862 3.482737-.310788 3.149956-.309832 3.150911.002869 4.145434.003825 4.144476.3127 2.411715.312701 2.411714.993565 2.480567.992609 2.480566 1.148481 1.793007 1.146568 1.793007 1.823609 1.795877 1.82552 1.79492 1.928798 1.021297 1.93071 1.019384 2.535074.704772c1.393286.386333 3.408148.830999 4.476303.986871 1.068154.155872 3.584102.302181 5.59227.324176zm54.549501-.122403 4.476303-.129097 2.819086-.721028 2.819086-.721984 1.824564-.8616c1.003128-.473354 2.644088-1.409543 3.647216-2.079888 1.003128-.670346 2.557068-1.944099 3.451181-2.830561.894113-.88742 2.22046-2.40024 2.947226-3.362248.726766-.962965 1.365555-1.706943 1.419106-1.652436.054507.053551-.113796 1.586453-.37199 3.407193-.257236 1.821695-.471441 4.243929-.475266 5.383803l-.005738 2.072239h6.085707 6.086662l.186473-4.724933.185516-4.72589.868294-6.135432c.478136-3.374679 1.249846-8.374062 1.71555-11.108996.464747-2.73589 1.272796-7.361371 1.796832-10.280866.52308-2.918538 1.352167-7.46943 1.840821-10.114474l.891244-4.808129.030601-4.153083.028688-4.15404-.938101-1.919235-.940014-1.920191-1.272797-1.222114-1.274708-1.22307-2.089452-1.058592-2.091363-1.060504-3.116486-.693296-3.116486-.693296-4.28983-.326089-4.290787-.326088-5.526288.342345c-3.04094.187429-7.317383.558462-9.506286.825261l-3.979998.481961-2.711984.010519-2.711983.010519-.39494 1.90776c-.217074 1.048072-.82048 3.539157-1.339735 5.536807-.521168 1.996693-.897938 3.677816-.83865 3.737105.058333.059289 1.508995-.270624 3.222632-.731547 1.713637-.461879 5.355116-1.219245 8.091962-1.685905l4.973564-.847256 4.476303-.183604 4.477259-.185516 2.884112.505867 2.884112.505867 1.924017.949577 1.924973.950533 1.077717 1.606535 1.078673 1.605578-.015301 2.532205-.016256 2.53316-.570894 2.778923-.57185 2.779879-11.932344.043032-11.932345.042076-3.904453 1.071023c-2.147784.589062-4.526029 1.371292-5.285308 1.737544-.759279.367207-1.518558.667476-1.687818.667476-.168303 0-1.445881.707641-2.839167 1.574978l-2.532205 1.573065-1.993824 1.990956c-1.097799 1.09493-2.498735 2.736846-3.114574 3.649128-.615838.911326-1.617053 2.816217-2.223329 4.233411l-1.103536 2.575236-.506823 2.895588-.506824 2.896544v3.038071 3.039028l.482917 2.530292.484829 2.529336.896982 1.649567c.494392.906545 1.401893 2.236717 2.014862 2.95392l1.116924 1.304353 1.982349 1.204901 1.983305 1.204901 2.271143.641658c1.24889.352864 3.148999.781273 4.223848.951489l1.952704.307919 4.477259-.12814zm4.145434-9.273913-2.653651.139616-1.75667-.448491c-.965833-.245762-2.432752-.794661-3.25897-1.219245l-1.500388-.77171-.820481-.97444c-.450403-.536468-1.138918-1.588366-1.530033-2.339038l-.710509-1.365555-.138659-3.18725-.140572-3.188206.562287-1.933579c.308876-1.063373 1.034685-2.909932 1.612273-4.101445l1.049985-2.167865 2.011037-1.995737 2.010081-1.996693 2.134396-1.027991 2.134396-1.027035 2.652695-.631138 2.653651-.630183h8.290866 8.290866l.524037.217074.524036.216117-.440841 2.602968c-.242893 1.430581-.821436 4.019206-1.28714 5.751968-.464748 1.733719-1.285228 4.280268-1.823608 5.660166-.538381 1.380855-.979221 2.601056-.979221 2.711984 0 .111883-.545075 1.116924-1.211595 2.234804l-1.210639 2.033988-1.988086 1.970873c-1.093018 1.082499-2.109534 1.968962-2.256799 1.968962-.14631 0-.816655.373902-1.488914.830043l-1.222113.82813-2.68999.851081-2.689033.850124zm107.942872 9.391534 3.149955.040164 2.985477-.48483c1.641917-.265843 3.730412-.695208 4.642694-.953401.911326-.258193 2.554199-.927583 3.647216-1.487958l1.990956-1.019384 1.711724-1.507083 1.710768-1.507082 1.803527-2.403108c.991652-1.322522 1.888634-2.627832 1.99478-2.902281l.192211-.498217-.167348 1.659129c-.091802.911326-.2974 2.404064-.45901 3.316347-.160653.912282-.389202 2.665126-.509692 3.896802l-.219942 2.237674h6.506465 6.504553v-2.237674-2.238629l.990696-8.457258c.545075-4.6513 1.351211-10.843152 1.791095-13.76169.439885-2.919494 1.119793-7.096485 1.510908-9.285388.389202-2.188903 1.080586-6.144039 1.533858-8.788127.455185-2.644088 1.275665-7.271482 1.824564-10.279909.547943-3.01034 1.426756-7.784999 1.951749-10.611735.524036-2.827693 1.340691-7.230363 1.812132-9.783605.471442-2.553243 1.316785-7.030502 1.878116-9.948084.563243-2.918538 1.381811-7.022851 1.822652-9.120909.441797-2.096145.802311-3.925491.801355-4.061281l.000002-.249587h-7.097443-7.097441l-.209423 2.073195c-.114752 1.139874-.65887 4.907581-1.206813 8.374062-.5489 3.464568-1.443969 8.986075-1.989043 12.268952-.545075 3.282877-1.069111 6.467258-1.165694 7.075446l-.177867 1.105449-.559418-.238111c-.307919-.131009-1.978524-.594801-3.71033-1.029904l-3.149955-.790836-4.310868-.33565-4.311825-.335651-3.648172.339476-3.647216.340432-3.316347.838649-3.316346.837693-3.149956 1.536727-3.151868 1.536727-2.320869 1.717462-2.320868 1.718419-2.0053 2.150652c-1.10258 1.181951-2.69477 3.137524-3.540114 4.345294l-1.533858 2.195597-1.803526 3.750494c-.990697 2.063632-2.19751 4.795697-2.680427 6.072318-.483873 1.277578-1.334954 4.107182-1.894372 6.289392l-1.014603 3.968523-.50013 5.152386-.500129 5.150474.374858 4.145433.376771 4.145433.442753 1.491782c.245761.821437.759279 2.283575 1.144656 3.249408l.69999 1.758582 1.276621 1.727024 1.277578 1.728938 1.457356 1.193426 1.457357 1.194382 1.989999.988783c1.09493.542206 2.930013 1.245065 4.07945 1.559678 1.148481.314613 3.014165.693296 4.145434.839605 1.130311.147266 3.472218.285925 5.205937.306963zm5.654428-9.406834-2.504473.131009-1.688774-.304094c-.929495-.166391-2.416496-.615838-3.305827-.996434l-1.615141-.691384-1.359817-1.115011-1.358861-1.113099-1.009822-1.934536-1.009821-1.934535-.461879-2.155434-.45901-2.15639.039207-4.310868.038251-4.310868.534555-3.814564.534556-3.812651.830999-2.652695c.457097-1.459269.833868-2.836298.83578-3.060066.003825-.222811.453273-1.416236 1.003128-2.651738.5489-1.236458 1.465007-3.142305 2.036857-4.237235.571849-1.09493 1.64096-2.799961 2.37442-3.790657.735372-.990696 2.044506-2.483435 2.908975-3.317303.864468-.831955 2.238629-1.925929 3.056241-2.427971l1.484132-.913238 2.60775-.90272 2.606794-.902719 5.47178-.002869h5.471781l3.149955.874987c1.733719.480048 3.573583 1.037554 4.089013 1.238371l.938102.364339-.182648.91037c-.100408.501086-.495348 2.701464-.875944 4.889411-.380596 2.188904-1.132224 6.367807-1.668692 9.286344-.536468 2.918538-1.360773 7.321208-1.832215 9.782649-.470485 2.462397-1.152306 5.596096-1.515689 6.963563-.362426 1.368423-.874987 3.262795-1.137962 4.210459-.262974.947665-.888375 2.590537-1.390417 3.648173-.502042 1.058591-1.380855 2.596275-1.952705 3.416755s-1.537683 1.958442-2.147784 2.526467c-.611057.569937-1.93071 1.579759-2.933838 2.246279l-1.823608 1.212552-2.636438.836736-2.636438.836737zm-488.066184 7.793606h8.05658l.578543-3.564021c.317482-1.961311.939058-5.729974 1.379899-8.374062s1.262277-7.569838 1.823608-10.943561c.562287-3.374679 1.405718-8.374062 1.873334-11.108996.467616-2.73589 1.211595-6.979819 1.651479-9.430741.440841-2.452834.885507-4.541329.986872-4.64365l.186473-.185516h21.666223 21.665267l.240981.240024.24098.24098-.376771 1.914454c-.205598 1.05381-.816655 4.302261-1.356948 7.220799s-1.44875 7.843332-2.019643 10.944517c-.568981 3.10023-1.393287 7.5029-1.830302 9.782649-.437972 2.279749-1.323479 7.054408-1.968005 10.611735-.64357 3.556371-1.169519 6.652775-1.167607 6.881323l.003825.414066h8.09005 8.091006l.357645-2.072239c.197948-1.139874.513517-3.192031.704771-4.559498.189342-1.368423.649308-4.279311 1.019385-6.467258.370077-2.187948 1.109274-6.516985 1.643829-9.617214.533599-3.100229 1.428668-8.397969 1.98713-11.772648s1.386593-8.298516 1.841778-10.942605c.453272-2.646 1.263233-7.122303 1.797788-9.949039.534556-2.827692 1.4258-7.602352 1.980437-10.612692.554637-3.008427 1.383723-7.560275 1.844646-10.114474.460922-2.553243 1.300528-7.17968 1.86664-10.279909.566112-3.10023 1.280447-6.718758 1.587409-8.042236l.558462-2.404065h-8.191414-8.19237l-.222811 1.575934c-.121447.865425-.517343 3.291484-.878813 5.388585-.362427 2.098058-1.018428 5.827514-1.460225 8.28991-.441797 2.463354-1.24889 7.163424-1.793964 10.447257-.545074 3.281921-1.239327 7.628171-1.543421 9.657377l-.552724 3.688336-12.025103.243849-12.02606.242893-10.071442-.239068c-5.539676-.131009-10.102999-.265843-10.14125-.296444-.037294-.032513.151091-1.32061.418847-2.86403.268712-1.543421.775535-4.224804 1.127443-5.95661.351907-1.732763 1.019384-5.164818 1.482219-7.628171.463791-2.461441.987828-5.52055 1.16665-6.797172.177867-1.276621.551768-3.403367.830043-4.726845.278275-1.321566.806136-4.107183 1.173344-6.188984.366252-2.081801.757367-4.022074.86925-4.310868l.200817-.525949h-8.125431-8.126388l-.519255 2.902282c-.286881 1.596015-.668433 3.870983-.848212 5.056759-.180735 1.185775-.786055 4.990776-1.345473 8.456301s-1.385636 8.614086-1.83604 11.440822c-.450403 2.827692-1.268971 7.976253-1.819783 11.440822-.552724 3.466481-1.462137 8.837853-2.023468 11.938082-.560375 3.102142-1.372249 7.503856-1.804483 9.783605-.431278 2.279749-1.252714 6.60783-1.826477 9.617214-.572806 3.010339-1.411455 7.262875-1.859946 9.451778-.449447 2.187948-.945752 4.724934-1.10258 5.63626-.158741.912282-.671302 3.542982-1.141787 5.845682-.469529 2.3027-.85395 4.428489-.85395 4.725889v.538381zm89.199011 0h7.132823l.200817-.524037c.111883-.28975.201773-1.04616.201773-1.681123 0-.636877.449447-3.945573.996434-7.352765.548899-3.407192 1.454487-8.954518 2.013906-12.329197.558462-3.373723 1.383723-8.298517 1.834127-10.943562.450403-2.644088 1.249845-7.045802 1.777707-9.783604.527861-2.734934 1.338779-6.988426 1.801614-9.449867.461878-2.462397 1.372248-7.147166 2.021556-10.410918s1.261321-6.063712 1.359817-6.223409l.180735-.291663-7.21315.088933-7.213149.088934-.60245 4.311824c-.328957 2.371551-1.051898 7.072577-1.604623 10.445344-.551768 3.374679-1.387548 8.524196-1.857077 11.440822-.469529 2.919494-1.286184 7.619564-1.816914 10.447256-.53073 2.826736-1.343561 7.153861-1.807352 9.616258-.462835 2.463353-1.293834 6.790477-1.846558 9.617213-.552725 2.827693-1.293834 6.558104-1.647655 8.290867-.354776 1.733718-.734415 3.486562-.845343 3.896803l-.19986.745891zm166.830974 0h7.080228l.212292-2.995996c.117621-1.646698.517342-4.967826.890288-7.378584.372945-2.410759 1.137005-7.217931 1.696424-10.6825.560374-3.466481 1.600797-9.234705 2.312262-12.819764.713378-3.584102 1.517602-7.147166 1.789183-7.916964.272537-.770754.494391-1.604622.494391-1.854209 0-.250543.532643-1.612272 1.182907-3.026596.650264-1.414325 1.862815-3.579321 2.694771-4.811954l1.511864-2.241499 2.022512-1.87429 2.023469-1.872378 2.49491-1.191513 2.49491-1.19247 3.814563.021038 3.812651.020082 1.875247.559418c1.03086.30792 1.963224.560375 2.072239.560375.109014 0 .197948-.351908.197948-.783186 0-.430321.372945-2.614444.829086-4.854029.455185-2.23863.829087-4.164559.829087-4.280268 0-.115708-1.081542-.539336-2.404065-.94097-1.322522-.401634-3.150911-.822393-4.062237-.936189l-1.658173-.204642-2.155434.381552c-1.185776.209423-2.948183.672258-3.916885 1.028947-.969658.355733-2.569499 1.162825-3.55637 1.793964-.985915.632095-2.52073 1.861859-3.409105 2.733021-.890288.872119-2.385895 2.630701-3.323997 3.907322-.939058 1.276622-1.920191 2.620182-2.181253 2.984521l-.47431.662695.287837-1.325391c.158741-.73059.600538-3.118398.981134-5.306345.380595-2.188904.773623-4.242017.86925-4.559499l.17691-.581412h-6.322862-6.323817v.799442c0 .439884-.373902 3.087798-.829087 5.885846-.456141 2.799004-1.208726 7.475167-1.671561 10.393705s-1.285228 7.99251-1.826477 11.275387-1.363642 7.983904-1.827433 10.445344c-.463791 2.462397-1.286184 6.790478-1.829346 9.61817-.541249 2.82578-1.443012 7.453173-2.000518 10.279909-.558462 2.827693-1.226895 6.165077-1.484132 7.419704-.259149 1.252715-.469529 2.408846-.469529 2.568543v.291663zm168.073169 0h7.238969v-2.214723-2.216635l.833868-5.494731c.459966-3.020859 1.216376-7.80795 1.683036-10.63373.46666-2.827692 1.047117-6.408926 1.290966-7.959997.244805-1.550114.891244-4.90758 1.437274-7.460823.547943-2.554199 1.229764-5.313996 1.517602-6.135432.287837-.820481.524992-1.68208.527861-1.913498.003825-.231417.62062-1.721287 1.371292-3.310609l1.366511-2.890806 1.803526-2.395458 1.802571-2.394501 1.972786-1.483176c1.084411-.816655 2.829605-1.898197 3.877677-2.405977l1.904891-.922801 4.144477.028688 4.145433.029644 1.632354.52308 1.631398.524037.275406-.170217.27445-.170216.0153-1.057635c.006694-.582369.36147-2.747366.787967-4.81291l.775535-3.754319-.872118-.341388c-.479092-.187429-1.617054-.575675-2.529336-.862556l-1.658173-.52308-2.984521.008606-2.984521.006694-2.432752.856818-2.432753.854906-1.826477 1.101624-1.82552 1.101624-2.375376 2.48726-2.37442 2.486303-1.275665 1.929755c-.700947 1.06146-1.318698 1.88194-1.372249 1.823608-.053551-.057377.328001-2.269231.847256-4.913319.519255-2.645044.951489-5.144736.959139-5.554976l.014345-.746847h-6.135433-6.134476v.212292c0 .115709-.306006 2.242454-.679908 4.724933-.373902 2.483435-1.125531 7.275307-1.667736 10.649986-.544118 3.373723-1.435363 8.82064-1.982349 12.104474-.546031 3.282877-1.370336 7.983903-1.831259 10.4463-.459966 2.461441-1.277577 6.789521-1.816914 9.616257-.539336 2.827693-1.424843 7.379541-1.968005 10.115431-.543161 2.734934-1.264189 6.354418-1.59984 8.04128l-.612014 3.06676zm-320.877565-80.92249 2.011993.006694 1.600797-.545074 1.601753-.545074 1.416237-1.437275 1.417193-1.436319.744935-1.91541.746848-1.914453.025819-2.819086.026775-2.817173-.662695-1.101624-.663652-1.100668-1.154219-.714334-1.155174-.71529h-2.492998-2.492998l-1.69738.760235-1.69738.759279-.984959 1.055722-.984959 1.05668-.774579 1.823608-.773623 1.823608-.146309 2.84108-.145353 2.84108.719115 1.412411.721028 1.411456 1.390418.631139 1.389461.630182z", fill: "#b3131b" })));
  const SvgBc16C58Eb1De638B = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...props }, /* @__PURE__ */ reactExports.createElement("linearGradient", { id: "a", gradientTransform: "matrix(132.87 0 0 -323.02 -10686 208760)", gradientUnits: "userSpaceOnUse", x1: 83.977, x2: 84.977, y1: 645.5, y2: 645.5 }, /* @__PURE__ */ reactExports.createElement("stop", { offset: 0, stopColor: "#007b40" }), /* @__PURE__ */ reactExports.createElement("stop", { offset: 1, stopColor: "#55b330" })), /* @__PURE__ */ reactExports.createElement("linearGradient", { id: "b", gradientTransform: "matrix(133.43 0 0 -323.02 -11031 208760)", gradientUnits: "userSpaceOnUse", x1: 83.984, x2: 84.979, y1: 645.5, y2: 645.5 }, /* @__PURE__ */ reactExports.createElement("stop", { offset: 0, stopColor: "#1d2970" }), /* @__PURE__ */ reactExports.createElement("stop", { offset: 1, stopColor: "#006dba" })), /* @__PURE__ */ reactExports.createElement("linearGradient", { id: "c", gradientTransform: "matrix(132.96 0 0 -323.03 -10842 208770)", gradientUnits: "userSpaceOnUse", x1: 83.978, x2: 84.977, y1: 645.5, y2: 645.5 }, /* @__PURE__ */ reactExports.createElement("stop", { offset: 0, stopColor: "#6e2b2f" }), /* @__PURE__ */ reactExports.createElement("stop", { offset: 1, stopColor: "#e30138" })), /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#0e4c96" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m632.24 361.27c0 41.615-33.729 75.36-75.36 75.36h-409.13v-297.88c0-41.626 33.733-75.37 75.365-75.37l409.12-.001.001 297.89z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m498.86 256.54c11.684.253 23.437-.516 35.076.4 11.787 2.199 14.629 20.043 4.156 25.888-7.141 3.851-15.633 1.433-23.379 2.113h-15.852zm41.833-32.145c2.596 9.164-6.238 17.392-15.066 16.13h-26.767c.185-8.642-.368-18.021.271-26.208 10.725.301 21.549-.616 32.21.479 4.581 1.151 8.414 4.917 9.352 9.599zm64.428-135.9c.498 17.501.071 35.927.214 53.783-.035 72.596.072 145.19-.055 217.79-.47 27.207-24.582 50.844-51.601 51.387-27.046.111-54.095.016-81.142.047v-109.75c29.47-.154 58.959.307 88.417-.232 13.667-.859 28.632-9.875 29.27-24.914 1.61-15.103-12.632-25.551-26.152-27.201-5.198-.135-5.044-1.516 0-2.117 12.892-2.787 23.02-16.133 19.226-29.499-3.236-14.058-18.772-19.499-31.697-19.472-26.351-.18-52.709-.026-79.062-.077.172-20.489-.354-41 .286-61.474 2.087-26.716 26.806-48.747 53.447-48.27h78.849z", fill: "url(#a)" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m174.74 139.54c.674-27.163 24.889-50.611 51.875-51.007 26.944-.083 53.891-.012 80.837-.036-.074 90.885.148 181.78-.112 272.66-1.038 26.835-24.99 49.835-51.679 50.308-26.996.099-53.995.014-80.992.042v-113.45c26.223 6.194 53.722 8.832 80.473 4.721 15.993-2.574 33.488-10.424 38.902-27.014 3.986-14.191 1.742-29.126 2.334-43.691v-33.824h-46.297c-.208 22.369.426 44.779-.335 67.125-1.248 13.734-14.846 22.46-27.8 21.994-16.066.17-47.898-11.639-47.898-11.639-.08-41.918.466-94.409.692-136.18z", fill: "url(#b)" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m324.72 211.89c-2.434.517-.489-8.301-1.113-11.646.165-21.15-.347-42.323.283-63.458 2.083-26.829 26.991-48.916 53.739-48.288h78.766c-.073 90.884.147 181.78-.111 272.66-1.039 26.834-24.992 49.833-51.681 50.308-26.997.1-53.997.015-80.997.043v-124.3c18.44 15.128 43.5 17.483 66.473 17.524 17.316-.006 34.534-2.674 51.35-6.67v-22.772c-18.953 9.446-41.232 15.446-62.243 10.019-14.655-3.65-25.294-17.812-25.056-32.937-1.699-15.728 7.524-32.335 22.981-37.011 19.189-6.008 40.107-1.413 58.096 6.397 3.854 2.019 7.765 4.521 6.222-1.921v-17.9c-30.084-7.156-62.101-9.792-92.329-2.004-8.749 2.469-17.271 6.212-24.38 11.958z", fill: "url(#c)" }));
  const Svg75Bb17D442A9Aa5E = (props) => /* @__PURE__ */ reactExports.createElement("svg", { height: 471, viewBox: "0 0 750 471", width: 750, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("g", { fill: "none" }, /* @__PURE__ */ reactExports.createElement("rect", { fill: "#000", height: 471, rx: 40, width: 750 }), /* @__PURE__ */ reactExports.createElement("g", { transform: "translate(133 48)" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m146.8 373.77v-24.77c0-9.35-6-15.64-15.55-15.72-5-.08-10.26 1.49-13.9 7-2.73-4.38-7-7-13.07-7-4.6271851-.232271-9.0320026 2.000568-11.58 5.87v-4.88h-8.61v39.55h8.69v-21.97c0-6.87 3.81-10.51 9.68-10.51 5.71 0 8.61 3.72 8.61 10.42v22h8.69v-21.91c0-6.87 4-10.51 9.68-10.51 5.87 0 8.69 3.72 8.69 10.42v22zm48.48-19.77v-19.77h-8.61v4.77c-2.73-3.56-6.87-5.79-12.49-5.79-11.09 0-19.77 8.69-19.77 20.77s8.69 20.77 19.77 20.77c5.63 0 9.76-2.23 12.49-5.79v4.8h8.61zm-32 0c0-6.95 4.55-12.66 12-12.66 7.12 0 11.91 5.46 11.91 12.66s-4.8 12.66-11.91 12.66c-7.47 0-12.02-5.71-12.02-12.66zm216.12-20.81c2.906602-.028642 5.790743.511498 8.49 1.59 2.514719 1.004654 4.807997 2.492736 6.75 4.38 1.913063 1.875758 3.429744 4.116773 4.46 6.59 2.146003 5.297587 2.146003 11.222413 0 16.52-1.030256 2.473227-2.546937 4.714242-4.46 6.59-1.941678 1.887671-4.235042 3.375809-6.75 4.38-5.466835 2.128264-11.533165 2.128264-17 0-2.510499-1.00137-4.797832-2.490006-6.73-4.38-1.901515-1.881202-3.410681-4.121157-4.44-6.59-2.146003-5.297587-2.146003-11.222413 0-16.52 1.029788-2.46859 2.538895-4.708458 4.44-6.59 1.932334-1.889787 4.219623-3.378394 6.73-4.38 2.705493-1.08107 5.596681-1.621257 8.51-1.59zm0 8.14c-1.681779-.014559-3.350036.301425-4.91.93-1.470254.590363-2.804249 1.475156-3.92 2.6-1.122908 1.148077-2.006664 2.507702-2.6 4-1.265729 3.309784-1.265729 6.970216 0 10.28.592861 1.492544 1.476675 2.852258 2.6 4 1.115751 1.124844 2.449746 2.009637 3.92 2.6 3.159488 1.239283 6.670512 1.239283 9.83 0 1.474284-.593902 2.814154-1.47808 3.94-2.6 1.132829-1.144071 2.023848-2.504406 2.62-4 1.265729-3.309784 1.265729-6.970216 0-10.28-.596152-1.495594-1.487171-2.855929-2.62-4-1.125846-1.12192-2.465716-2.006098-3.94-2.6-1.562387-.633286-3.234193-.952696-4.92-.94zm-137.3 12.67c-.08-12.33-7.69-20.77-18.78-20.77-11.58 0-19.69 8.44-19.69 20.77 0 12.58 8.44 20.77 20.27 20.77 6 0 11.42-1.49 16.22-5.54l-4.22-6.37c-3.266738 2.619648-7.313106 4.076341-11.5 4.14-5.54 0-10.59-2.56-11.83-9.68h29.37c.06-1.09.16-2.16.16-3.32zm-29.45-3.47c.91-5.71 4.38-9.6 10.51-9.6 5.54 0 9.1 3.47 10 9.6zm65.69-6.2c-3.757197-2.164453-8.004435-3.334681-12.34-3.4-4.72 0-7.53 1.74-7.53 4.63 0 2.65 3 3.39 6.7 3.89l4.05.58c8.61 1.24 13.82 4.88 13.82 11.83 0 7.53-6.62 12.91-18 12.91-6.45 0-12.41-1.66-17.13-5.13l4.05-6.7c3.797785 2.817702 8.43304 4.275905 13.16 4.14 5.87 0 9-1.74 9-4.8 0-2.23-2.23-3.47-6.95-4.14l-4.05-.58c-8.85-1.24-13.65-5.21-13.65-11.67 0-7.86 6.45-12.66 16.46-12.66 6.29 0 12 1.41 16.13 4.14zm41.35-2.23h-14.07v17.9c0 4 1.41 6.62 5.71 6.62 2.684365-.088246 5.302562-.85547 7.61-2.23l2.48 7.36c-3.227525 2.011602-6.956934 3.072196-10.76 3.06-10.18 0-13.73-5.46-13.73-14.65v-18h-8v-7.86h8v-12h8.69v12h14.06zm29.78-8.85c2.086514.010012 4.15609.375232 6.12 1.08l-2.65 8.11c-1.710096-.683978-3.538347-1.023802-5.38-1-5.63 0-8.44 3.64-8.44 10.18v22.17h-8.6v-39.56h8.48v4.77c2.149726-3.693802 6.148028-5.915508 10.42-5.79z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m176.95 32.39h130.5v234.51h-130.5z", fill: "#7673c0" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m185.24 149.64c-.03486-45.77046 20.985386-89.0131626 57-117.26-61.147032-48.0618249-148.9622811-41.06578574-201.7283628 16.0712353-52.7660817 57.1370207-52.7660817 145.2305087 0 202.3675297s140.5813308 64.13306 201.7283628 16.071235c-36.011849-28.244672-57.031785-71.483049-57-117.25z", fill: "#eb001b" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m483.5 149.64c.001034 57.09874-32.59844 109.186356-83.954442 134.142862s-112.453215 18.400897-157.345558-16.882862c35.966584-28.279813 56.964715-71.501935 56.964715-117.255s-20.998131-88.975187-56.964715-117.255c44.890924-35.28264477 105.985845-41.83904288 157.341061-16.8850475 51.355216 24.9539954 83.956145 77.0381115 83.958939 134.1350475z", fill: "#00a1df" }))));
  const SvgF1A233802Cf96Ae4 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#16366f" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m449.01 250c0 99.143-80.37 179.5-179.51 179.5s-179.5-80.361-179.5-179.5c0-99.133 80.362-179.5 179.5-179.5 99.137 0 179.51 80.37 179.51 179.5", fill: "#d9222a" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m510.49 70.496c-46.38 0-88.643 17.596-120.5 46.466-6.49 5.889-12.548 12.237-18.125 18.996h36.266c4.966 6.037 9.536 12.388 13.685 19.013h-63.635c-3.827 6.121-7.28 12.469-10.341 19.008h84.312c2.893 6.185 5.431 12.53 7.6 19.004h-99.512c-2.091 6.235-3.832 12.581-5.217 19.009h109.94c2.689 12.49 4.044 25.231 4.041 38.008 0 19.934-3.254 39.113-9.254 57.02h-99.512c2.164 6.479 4.7 12.825 7.595 19.01h84.317c-3.064 6.54-6.52 12.889-10.347 19.013h-63.625c4.154 6.629 8.73 12.979 13.685 18.996h36.258c-5.57 6.772-11.63 13.126-18.13 19.012 31.86 28.867 74.118 46.454 120.5 46.454 99.138-.001 179.51-80.362 179.51-179.5 0-99.13-80.37-179.5-179.51-179.5", fill: "#ee9f2d" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m666.08 350.06c0-3.201 2.592-5.801 5.796-5.801s5.796 2.6 5.796 5.801c0 3.199-2.592 5.799-5.796 5.799-3.202-.001-5.797-2.598-5.796-5.799zm5.796 4.408c2.435-.001 4.407-1.975 4.408-4.408 0-2.433-1.972-4.404-4.404-4.404h-.004c-2.429-.004-4.4 1.963-4.404 4.392v.013c-.003 2.432 1.967 4.406 4.399 4.408.001-.001.003-.001.005-.001zm-.783-1.86h-1.188v-5.094h2.149c.45 0 .908 0 1.305.254.413.278.646.77.646 1.278 0 .57-.337 1.104-.883 1.312l.937 2.25h-1.315l-.78-2.016h-.87v2.016zm0-2.89h.658c.246 0 .504.02.725-.1.196-.125.296-.359.296-.584 0-.195-.12-.42-.288-.516-.207-.131-.536-.101-.758-.101h-.633zm-443.5-80.063c-2.045-.237-2.945-.301-4.35-.301-11.045 0-16.637 3.789-16.637 11.268 0 4.611 2.73 7.546 6.987 7.546 7.938 0 13.659-7.56 14-18.513zm14.171 32.996h-16.146l.371-7.676c-4.925 6.067-11.496 8.95-20.425 8.95-10.562 0-17.804-8.25-17.804-20.229 0-18.024 12.596-28.54 34.217-28.54 2.208 0 5.041.2 7.941.569.605-2.441.763-3.486.763-4.8 0-4.908-3.396-6.738-12.5-6.738-9.533-.108-17.396 2.271-20.625 3.334.204-1.23 2.7-16.658 2.7-16.658 9.712-2.846 16.117-3.917 23.325-3.917 16.733 0 25.596 7.512 25.58 21.712.032 3.805-.597 8.5-1.58 14.671-1.692 10.731-5.32 33.718-5.817 39.322zm-62.158 0h-19.488l11.163-69.997-24.925 69.997h-13.28l-1.64-69.597-11.734 69.597h-18.242l15.238-91.054h28.02l1.7 50.966 17.092-50.966h31.167zm354.98-32.996c-2.037-.237-2.942-.301-4.342-.301-11.041 0-16.634 3.789-16.634 11.268 0 4.611 2.726 7.546 6.983 7.546 7.939 0 13.664-7.56 13.993-18.513zm14.183 32.996h-16.145l.365-7.676c-4.925 6.067-11.5 8.95-20.42 8.95-10.566 0-17.8-8.25-17.8-20.229 0-18.024 12.587-28.54 34.212-28.54 2.208 0 5.037.2 7.934.569.604-2.441.763-3.486.763-4.8 0-4.908-3.392-6.738-12.496-6.738-9.533-.108-17.388 2.271-20.63 3.334.205-1.23 2.709-16.658 2.709-16.658 9.713-2.846 16.113-3.917 23.312-3.917 16.741 0 25.604 7.512 25.588 21.712.032 3.805-.597 8.5-1.58 14.671-1.682 10.731-5.32 33.718-5.812 39.322zm-220.39-1.125c-5.334 1.68-9.492 2.399-14 2.399-9.963 0-15.4-5.725-15.4-16.267-.142-3.27 1.433-11.879 2.67-19.737 1.125-6.917 8.45-50.53 8.45-50.53h19.371l-2.262 11.209h11.7l-2.643 17.796h-11.742c-2.25 14.083-5.454 31.625-5.491 33.95 0 3.817 2.037 5.483 6.67 5.483 2.221 0 3.941-.226 5.255-.7zm59.391-.6c-6.654 2.033-13.075 3.017-19.879 3-21.683-.021-32.987-11.346-32.987-33.032 0-25.313 14.38-43.947 33.9-43.947 15.97 0 26.17 10.433 26.17 26.796 0 5.429-.7 10.729-2.387 18.212h-38.575c-1.304 10.742 5.57 15.217 16.837 15.217 6.935 0 13.188-1.43 20.142-4.663zm-10.887-43.9c.107-1.543 2.054-13.217-9.013-13.217-6.171 0-10.583 4.704-12.38 13.217zm-123.42-5.017c0 9.367 4.541 15.825 14.841 20.676 7.892 3.709 9.113 4.809 9.113 8.17 0 4.617-3.48 6.7-11.192 6.7-5.812 0-11.22-.907-17.458-2.92 0 0-2.563 16.32-2.68 17.101 4.43.966 8.38 1.861 20.28 2.19 20.562 0 30.058-7.829 30.058-24.75 0-10.175-3.975-16.146-13.737-20.633-8.171-3.75-9.109-4.588-9.109-8.046 0-4.004 3.238-6.046 9.538-6.046 3.825 0 9.05.408 14 1.113l2.775-17.175c-5.046-.8-12.696-1.442-17.15-1.442-21.8 0-29.346 11.387-29.279 25.062m229.09-23.116c5.413 0 10.459 1.42 17.413 4.92l3.187-19.762c-2.854-1.12-12.904-7.7-21.416-7.7-13.042 0-24.066 6.47-31.82 17.15-11.31-3.746-15.959 3.825-21.659 11.367l-5.062 1.179c.383-2.483.73-4.95.613-7.446h-17.896c-2.445 22.917-6.779 46.13-10.171 69.075l-.884 4.976h19.496c3.254-21.143 5.038-34.681 6.121-43.842l7.342-4.084c1.096-4.08 4.529-5.458 11.416-5.292-.926 5.008-1.389 10.09-1.383 15.184 0 24.225 13.071 39.308 34.05 39.308 5.404 0 10.042-.712 17.221-2.657l3.431-20.76c-6.46 3.18-11.761 4.676-16.561 4.676-11.328 0-18.183-8.362-18.183-22.184-.001-20.05 10.195-34.108 24.745-34.108" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m185.21 297.24h-19.491l11.17-69.988-24.925 69.988h-13.282l-1.642-69.588-11.733 69.588h-18.243l15.238-91.042h28.02l.788 56.362 18.904-56.362h30.267z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m647.52 211.6-4.319 26.308c-5.33-7.012-11.054-12.087-18.612-12.087-9.834 0-18.784 7.454-24.642 18.425-8.158-1.692-16.597-4.563-16.597-4.563l-.004.067c.658-6.133.92-9.875.862-11.146h-17.9c-2.437 22.917-6.77 46.13-10.157 69.075l-.893 4.976h19.492c2.633-17.097 4.65-31.293 6.133-42.551 6.659-6.017 9.992-11.267 16.721-10.917-2.979 7.206-4.725 15.504-4.725 24.017 0 18.513 9.367 30.725 23.534 30.725 7.141 0 12.62-2.462 17.966-8.17l-.912 6.884h18.433l14.842-91.043zm-24.37 73.942c-6.634 0-9.983-4.909-9.983-14.597 0-14.553 6.271-24.875 15.112-24.875 6.695 0 10.32 5.104 10.32 14.508.001 14.681-6.369 24.964-15.449 24.964z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m233.19 264.26c-2.042-.236-2.946-.3-4.346-.3-11.046 0-16.634 3.788-16.634 11.267 0 4.604 2.73 7.547 6.98 7.547 7.945-.001 13.666-7.559 14-18.514zm14.179 32.984h-16.146l.367-7.663c-4.921 6.054-11.5 8.95-20.421 8.95-10.567 0-17.804-8.25-17.804-20.229 0-18.032 12.591-28.542 34.216-28.542 2.209 0 5.042.2 7.938.571.604-2.442.762-3.487.762-4.808 0-4.908-3.391-6.73-12.496-6.73-9.537-.108-17.395 2.272-20.629 3.322.204-1.226 2.7-16.638 2.7-16.638 9.709-2.858 16.121-3.93 23.321-3.93 16.738 0 25.604 7.518 25.588 21.705.029 3.82-.605 8.512-1.584 14.675-1.687 10.725-5.32 33.725-5.812 39.317zm261.38-88.592-3.192 19.767c-6.95-3.496-12-4.921-17.407-4.921-14.551 0-24.75 14.058-24.75 34.107 0 13.821 6.857 22.181 18.183 22.181 4.8 0 10.096-1.492 16.554-4.677l-3.42 20.75c-7.184 1.959-11.816 2.672-17.226 2.672-20.976 0-34.05-15.084-34.05-39.309 0-32.55 18.059-55.3 43.888-55.3 8.507.001 18.562 3.609 21.42 4.73m31.442 55.608c-2.041-.236-2.941-.3-4.346-.3-11.042 0-16.634 3.788-16.634 11.267 0 4.604 2.729 7.547 6.984 7.547 7.937-.001 13.662-7.559 13.996-18.514zm14.179 32.984h-16.15l.37-7.663c-4.924 6.054-11.5 8.95-20.42 8.95-10.563 0-17.804-8.25-17.804-20.229 0-18.032 12.595-28.542 34.212-28.542 2.213 0 5.042.2 7.941.571.601-2.442.763-3.487.763-4.808 0-4.908-3.392-6.73-12.496-6.73-9.533-.108-17.396 2.272-20.629 3.322.204-1.226 2.704-16.638 2.704-16.638 9.709-2.858 16.116-3.93 23.316-3.93 16.742 0 25.604 7.518 25.583 21.705.034 3.82-.595 8.512-1.579 14.675-1.682 10.725-5.324 33.725-5.811 39.317zm-220.39-1.122c-5.338 1.68-9.496 2.409-14 2.409-9.963 0-15.4-5.726-15.4-16.266-.138-3.281 1.437-11.881 2.675-19.738 1.12-6.926 8.446-50.533 8.446-50.533h19.367l-2.259 11.212h9.942l-2.646 17.788h-9.975c-2.25 14.091-5.463 31.619-5.496 33.949 0 3.83 2.042 5.483 6.671 5.483 2.22 0 3.938-.217 5.254-.692zm59.392-.591c-6.65 2.033-13.08 3.013-19.88 3-21.684-.021-32.987-11.346-32.987-33.033 0-25.321 14.38-43.95 33.9-43.95 15.97 0 26.17 10.429 26.17 26.8 0 5.433-.7 10.733-2.382 18.212h-38.575c-1.306 10.741 5.569 15.221 16.837 15.221 6.93 0 13.188-1.434 20.137-4.676zm-10.892-43.912c.117-1.538 2.059-13.217-9.013-13.217-6.166 0-10.579 4.717-12.375 13.217zm-123.42-5.004c0 9.365 4.542 15.816 14.842 20.675 7.891 3.708 9.112 4.812 9.112 8.17 0 4.617-3.483 6.7-11.187 6.7-5.817 0-11.225-.908-17.467-2.92 0 0-2.554 16.32-2.67 17.1 4.42.967 8.374 1.85 20.274 2.191 20.567 0 30.059-7.829 30.059-24.746 0-10.18-3.971-16.15-13.738-20.637-8.167-3.758-9.112-4.583-9.112-8.046 0-4 3.245-6.058 9.541-6.058 3.821 0 9.046.42 14.004 1.125l2.771-17.18c-5.041-.8-12.691-1.441-17.146-1.441-21.804 0-29.345 11.379-29.283 25.067m398.45 50.629h-18.437l.917-6.893c-5.347 5.717-10.825 8.18-17.967 8.18-14.168 0-23.53-12.213-23.53-30.725 0-24.63 14.521-45.393 31.709-45.393 7.558 0 13.28 3.088 18.604 10.096l4.325-26.308h19.221zm-28.745-17.109c9.075 0 15.45-10.283 15.45-24.953 0-9.405-3.63-14.509-10.325-14.509-8.838 0-15.116 10.317-15.116 24.875-.001 9.686 3.357 14.587 9.991 14.587zm-56.843-56.929c-2.439 22.917-6.773 46.13-10.162 69.063l-.891 4.975h19.491c6.971-45.275 8.658-54.117 19.588-53.009 1.742-9.266 4.982-17.383 7.399-21.479-8.163-1.7-12.721 2.913-18.688 11.675.471-3.787 1.334-7.466 1.163-11.225zm-160.42 0c-2.446 22.917-6.78 46.13-10.167 69.063l-.887 4.975h19.5c6.962-45.275 8.646-54.117 19.569-53.009 1.75-9.266 4.992-17.383 7.4-21.479-8.154-1.7-12.716 2.913-18.678 11.675.47-3.787 1.325-7.466 1.162-11.225zm254.57 68.242c0-3.214 2.596-5.8 5.796-5.8 3.197-.003 5.792 2.587 5.795 5.785v.015c-.001 3.2-2.595 5.794-5.795 5.796-3.2-.002-5.794-2.596-5.796-5.796zm5.796 4.404c2.432.001 4.403-1.97 4.403-4.401v-.002c.003-2.433-1.968-4.406-4.399-4.408h-.004c-2.435.001-4.408 1.974-4.409 4.408.003 2.432 1.976 4.403 4.409 4.403zm-.784-1.87h-1.188v-5.084h2.154c.446 0 .908.008 1.296.254.416.283.654.767.654 1.274 0 .575-.338 1.113-.888 1.317l.941 2.236h-1.319l-.78-2.008h-.87v2.008zm0-2.88h.654c.245 0 .513.018.729-.1.195-.125.295-.361.295-.587-.009-.21-.115-.404-.287-.524-.204-.117-.542-.085-.763-.085h-.629v1.296z", fill: "#fff" }));
  const SvgD40Fa15A82Ff4Ca7 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m216.4 69.791h142.39c19.87 0 32.287 16.406 27.63 36.47l-66.333 287.48c-4.656 20.063-24.629 36.47-44.498 36.47h-142.39c-19.87 0-32.287-16.406-27.63-36.47l66.331-287.48c4.657-20.168 24.526-36.47 44.395-36.47h.104z", fill: "#d10429" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m346.34 69.791h163.82c19.868 0 10.865 16.406 6.209 36.47l-66.334 287.48c-4.657 20.063-3.208 36.47-23.077 36.47h-163.81c-19.972 0-32.287-16.406-27.527-36.47l66.334-287.48c4.656-20.168 24.524-36.47 44.498-36.47h-.104z", fill: "#022e64" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m504.41 69.791h142.4c19.869 0 32.287 16.406 27.629 36.47l-66.332 287.48c-4.658 20.063-24.631 36.47-44.499 36.47h-142.39c-19.973 0-32.287-16.406-27.63-36.47l66.333-287.48c4.656-20.168 24.525-36.47 44.394-36.47h.104z", fill: "#076f74" }), /* @__PURE__ */ reactExports.createElement("g", { fill: "#fefefe" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m480.5 340.81h13.453l3.829-13.063h-13.351zm10.762-35.95-4.657 15.467s5.071-2.613 7.865-3.449c2.794-.627 6.933-1.15 6.933-1.15l3.208-10.763h-13.451zm6.726-22.153-4.449 14.839s4.967-2.3 7.761-3.029c2.794-.732 6.933-.941 6.933-.941l3.208-10.764h-13.349zm29.701 0-17.386 57.997h4.657l-3.622 12.018h-4.657l-1.138 3.657h-16.559l1.14-3.657h-33.529l3.311-11.076h3.415l17.594-58.938 3.518-11.913h16.868l-1.76 5.956s4.449-3.239 8.797-4.39c4.243-1.148 28.665-1.566 28.665-1.566l-3.622 11.809h-5.795z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m534.59 270.79h18.006l.207 6.792c-.103 1.149.828 1.672 3.001 1.672h3.622l-3.311 11.183h-9.729c-8.382.627-11.59-3.03-11.383-7.106l-.311-12.437zm2.216 53.2h-17.178l2.896-9.927h19.662l2.794-9.092h-19.351l3.311-11.182h53.812l-3.312 11.182h-18.109l-2.794 9.092h18.109l-3.002 9.927h-19.558l-3.518 4.18h7.968l1.966 12.54c.207 1.254.207 2.09.62 2.613.415.418 2.795.627 4.14.627h2.38l-3.725 12.227h-6.106c-.93 0-2.38-.104-4.346-.104-1.863-.21-3.104-1.255-4.346-1.882-1.139-.522-2.794-1.881-3.208-4.284l-1.863-12.54-8.899 12.331c-2.795 3.866-6.622 6.897-13.143 6.897h-12.418l3.311-10.869h4.761c1.346 0 2.588-.521 3.52-1.045.931-.418 1.758-.836 2.586-2.193zm-187.9-27.2h45.429l-3.312 10.973h-18.109l-2.793 9.299h18.627l-3.415 11.287h-18.524l-4.553 15.152c-.517 1.672 4.45 1.881 6.209 1.881l9.313-1.254-3.726 12.54h-20.904c-1.654 0-2.896-.209-4.76-.627-1.76-.418-2.587-1.254-3.311-2.403-.726-1.254-1.968-2.195-1.14-4.912l6.002-20.063h-10.348l3.415-11.495h10.348l2.794-9.3h-10.347l3.312-10.974zm31.387-19.835h18.627l-3.415 11.39h-25.457l-2.794 2.404c-1.242 1.15-1.552.732-3.105 1.568-1.447.73-4.449 2.193-8.382 2.193h-8.175l3.311-10.972h2.484c2.07 0 3.52-.21 4.243-.627.828-.522 1.76-1.672 2.69-3.554l4.656-8.568h18.525l-3.208 6.27zm35.107 18.81s5.07-4.701 13.764-6.164c1.966-.418 14.384-.211 14.384-.211l1.863-6.27h-26.182l-3.83 12.75zm24.629 4.807h-25.975l-1.552 5.329h22.56c2.69-.313 3.208.104 3.415-.104l1.655-5.225zm-33.735-29.678h15.833l-2.276 8.047s4.967-4.075 8.485-5.539c3.519-1.254 11.383-2.508 11.383-2.508l25.664-.104-8.796 29.469c-1.449 5.016-3.208 8.256-4.243 9.823-.93 1.463-2.07 2.821-4.346 4.075-2.173 1.15-4.141 1.881-6.002 1.986-1.656.104-4.347.209-7.865.209h-24.732l-6.934 23.303c-.62 2.299-.931 3.447-.517 4.074.31.523 1.241 1.15 2.38 1.15l10.865-1.045-3.726 12.749h-12.21c-3.933 0-6.727-.104-8.693-.21-1.862-.208-3.83 0-5.175-1.044-1.138-1.045-2.896-2.403-2.794-3.763.104-1.254.621-3.344 1.45-6.27z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m452.43 317.79-1.449 7.105c-.619 2.194-1.138 3.867-2.794 5.33-1.759 1.463-3.725 3.03-8.484 3.03l-8.796.418-.104 7.942c-.103 2.193.519 1.984.828 2.402.414.418.724.523 1.138.732l2.794-.21 8.384-.417-3.52 11.704h-9.624c-6.726 0-11.797-.21-13.35-1.463-1.655-1.046-1.862-2.3-1.862-4.599l.62-31.141h15.42l-.207 6.374h3.725c1.242 0 2.175-.104 2.691-.418s.828-.836 1.035-1.567l1.552-5.016h12.108zm-219.37-156c-.517 2.508-10.451 48.592-10.451 48.592-2.174 9.3-3.726 15.989-8.9 20.273-3.001 2.508-6.52 3.657-10.555 3.657-6.52 0-10.245-3.239-10.866-9.404l-.104-2.09s1.966-12.436 1.966-12.54c0 0 10.349-42.009 12.212-47.548.103-.313.103-.522.103-.627-20.18.21-23.801 0-24.008-.313-.104.418-.621 3.03-.621 3.03l-10.556 47.34-.932 3.97-1.758 13.168c0 3.866.724 7.105 2.277 9.718 4.863 8.569 18.627 9.823 26.388 9.823 10.038 0 19.455-2.195 25.767-6.061 11.073-6.584 13.97-16.929 16.454-26.02l1.242-4.703s10.659-43.576 12.522-49.219c.103-.314.103-.523.207-.627-14.695.104-18.938 0-20.387-.314zm59.03 86.623c-7.141-.105-9.728-.105-18.11.313l-.311-.627c.724-3.24 1.552-6.374 2.173-9.614l1.035-4.389c1.552-6.792 3.001-14.839 3.208-17.242.207-1.463.62-5.12-3.519-5.12-1.759 0-3.518.835-5.38 1.671-1.036 3.658-3.002 13.899-4.037 18.497-2.07 9.823-2.173 10.972-3.104 15.78l-.621.626c-7.347-.104-9.934-.104-18.42.314l-.414-.732c1.449-5.852 2.794-11.704 4.14-17.556 3.518-15.78 4.45-21.84 5.38-29.887l.725-.418c8.279-1.149 10.245-1.463 19.248-3.239l.724.836-1.345 5.016c1.552-.94 3.001-1.881 4.553-2.613 4.243-2.09 8.9-2.717 11.487-2.717 3.932 0 8.279 1.15 10.038 5.748 1.656 4.075.62 9.091-1.656 19.019l-1.138 5.016c-2.277 11.077-2.69 13.062-3.933 20.586l-.827.627zm29.057.027c-4.346 0-7.14-.104-9.83 0-2.691 0-5.278.21-9.314.314l-.207-.314-.207-.418c1.138-4.18 1.656-5.643 2.277-7.106.517-1.463 1.034-2.926 2.07-7.21 1.241-5.539 2.069-9.405 2.586-12.854.621-3.24.932-6.06 1.346-9.3l.31-.209.31-.313c4.347-.627 7.038-1.045 9.832-1.463s5.691-.94 10.141-1.776l.207.418.103.418-2.482 10.345c-.828 3.449-1.656 6.897-2.38 10.346-1.554 7.315-2.277 10.032-2.587 12.017-.414 1.881-.519 2.822-1.14 6.584l-.414.313-.414.314zm45.942-25.675c-.31 1.881-1.966 8.883-4.139 11.809-1.553 2.194-3.312 3.553-5.382 3.553-.62 0-4.14 0-4.242-5.33 0-2.612.517-5.33 1.138-8.255 1.863-8.465 4.14-15.466 9.831-15.466 4.45 0 4.76 5.225 2.794 13.689zm18.73.836c2.483-11.077.518-16.302-1.862-19.437-3.726-4.807-10.348-6.374-17.178-6.374-4.141 0-13.867.418-21.525 7.524-5.484 5.12-8.071 12.122-9.52 18.81-1.554 6.792-3.312 19.019 7.864 23.617 3.414 1.463 8.382 1.88 11.59 1.88 8.176 0 16.558-2.298 22.87-8.986 4.863-5.434 7.036-13.585 7.864-17.034zm174.43 26.08c-8.693-.104-11.176-.104-19.146.314l-.517-.627c2.173-8.256 4.346-16.616 6.312-24.976 2.483-10.868 3.104-15.466 3.933-21.84l.62-.522c8.59-1.254 10.97-1.567 19.973-3.239l.207.731c-1.656 6.897-3.208 13.69-4.864 20.482-3.311 14.317-4.45 21.632-5.69 29.156l-.828.627z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m547.75 224.16c-.414 1.776-2.07 8.882-4.243 11.808-1.449 2.09-4.967 3.449-6.933 3.449-.621 0-4.036 0-4.243-5.225 0-2.613.517-5.33 1.138-8.256 1.863-8.255 4.141-15.257 9.831-15.257 4.45 0 6.416 5.12 4.45 13.585zm17.075.836c2.482-11.077-7.658-.94-9.21-4.598-2.484-5.748-.933-17.243-10.866-21.109-3.829-1.568-12.832.418-20.49 7.524-5.381 5.016-8.072 12.017-9.52 18.705-1.554 6.688-3.312 19.02 7.76 23.304 3.52 1.567 6.727 1.985 9.935 1.776 11.178-.627 19.662-17.661 25.976-24.349 4.861-5.329 5.69 1.986 6.415-1.253zm-129.94 23.413c-7.14-.105-9.624-.105-18.006.313l-.311-.627c.725-3.24 1.553-6.374 2.276-9.614l.931-4.389c1.554-6.792 3.105-14.839 3.208-17.242.207-1.463.621-5.12-3.415-5.12-1.759 0-3.62.835-5.38 1.671-.932 3.658-3.002 13.899-4.037 18.497-1.966 9.823-2.173 10.972-3.104 15.78l-.621.626c-7.347-.104-9.934-.104-18.42.314l-.414-.732c1.449-5.852 2.794-11.704 4.14-17.556 3.519-15.78 4.347-21.84 5.38-29.887l.621-.418c8.28-1.149 10.35-1.463 19.248-3.239l.726.836-1.242 5.016c1.449-.94 3.001-1.881 4.45-2.613 4.243-2.09 8.899-2.717 11.485-2.717 3.934 0 8.177 1.15 10.038 5.748 1.656 4.075.519 9.091-1.759 19.019l-1.138 5.016c-2.38 11.077-2.69 13.062-3.934 20.586l-.826.627zm62.001-86.519-6.002.105c-15.523.209-21.732.104-24.215-.209-.207 1.15-.621 3.135-.621 3.135s-5.588 25.916-5.588 26.02c0 0-13.246 55.176-13.867 57.788 13.556-.209 19.041-.209 21.421.105.519-2.613 3.622-17.974 3.726-17.974 0 0 2.69-11.286 2.795-11.704 0 0 .826-1.15 1.654-1.672h1.242c11.694 0 24.836 0 35.186-7.628 7.036-5.225 11.797-13.063 13.97-22.468.517-2.299.931-5.016.931-7.837 0-3.658-.724-7.21-2.794-10.032-5.279-7.42-15.731-7.524-27.838-7.629zm7.761 27.066c-1.241 5.747-4.967 10.659-9.727 12.958-3.933 1.985-8.693 2.194-13.66 2.194h-3.208l.207-1.254s5.899-25.916 5.899-25.811l.206-1.359.104-1.045 2.38.21s12.211 1.044 12.418 1.044c4.759 1.881 6.83 6.688 5.381 13.063zm127.21 8.666-.723-.836c-8.797 1.776-10.453 2.09-18.525 3.24l-.619.626c0 .105-.104.21-.104.418v-.104c-6.002 14.107-5.9 11.077-10.762 22.154 0-.523 0-.836-.105-1.359l-1.242-24.035-.723-.836c-9.314 1.777-9.521 2.09-18.007 3.24l-.621.627c-.104.313-.104.627-.104.94l.104.105c1.035 5.538.828 4.284 1.863 12.958.517 4.284 1.138 8.569 1.655 12.749.828 7.106 1.346 10.554 2.381 21.318-5.797 9.613-7.142 13.271-12.729 21.734l.31.836c8.384-.312 10.246-.312 16.455-.312l1.346-1.568c4.656-10.135 40.256-71.79 40.256-71.79zm-302.72 6.922c4.76-3.344 5.38-7.942 1.345-10.345-4.036-2.404-11.176-1.672-15.937 1.672-4.76 3.24-5.277 7.837-1.241 10.345 3.932 2.3 11.072 1.672 15.833-1.672z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m590.33 270.9-6.935 12.019c-2.173 4.075-6.312 7.21-12.728 7.21l-11.073-.209 3.208-10.868h2.173c1.138 0 1.966-.104 2.587-.418.621-.209.933-.627 1.449-1.254l4.14-6.583h17.282z" })));
  const Svg223Ca525897C672A = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#0e4595" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m293.2 348.73 33.361-195.76h53.36l-33.385 195.76zm246.11-191.54c-10.57-3.966-27.137-8.222-47.822-8.222-52.725 0-89.865 26.55-90.18 64.603-.299 28.13 26.514 43.822 46.752 53.186 20.771 9.595 27.752 15.714 27.654 24.283-.131 13.121-16.586 19.116-31.922 19.116-21.357 0-32.703-2.967-50.227-10.276l-6.876-3.11-7.489 43.823c12.463 5.464 35.51 10.198 59.438 10.443 56.09 0 92.5-26.246 92.916-66.882.199-22.269-14.016-39.216-44.801-53.188-18.65-9.055-30.072-15.099-29.951-24.268 0-8.137 9.668-16.839 30.557-16.839 17.449-.27 30.09 3.535 39.938 7.5l4.781 2.26zm137.31-4.223h-41.232c-12.773 0-22.332 3.487-27.941 16.234l-79.244 179.4h56.031s9.16-24.123 11.232-29.418c6.125 0 60.555.084 68.338.084 1.596 6.853 6.49 29.334 6.49 29.334h49.514l-43.188-195.64zm-65.418 126.41c4.412-11.279 21.26-54.723 21.26-54.723-.316.522 4.379-11.334 7.074-18.684l3.605 16.879s10.219 46.729 12.354 56.528zm-363.3-126.41-52.24 133.5-5.567-27.13c-9.725-31.273-40.025-65.155-73.898-82.118l47.766 171.2 56.456-.064 84.004-195.39h-56.521", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m146.92 152.96h-86.041l-.681 4.073c66.938 16.204 111.23 55.363 129.62 102.41l-18.71-89.96c-3.23-12.395-12.597-16.094-24.186-16.527", fill: "#f2ae14" }));
  const SvgC4E2C2A224B8321A = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 19.251, height: 20.644, viewBox: "0 0 19.251 20.644", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M9.625 1.697a1.92 1.92 0 0 0-1.916 1.917c0 1.054.862 1.916 1.917 1.916a1.92 1.92 0 0 0 1.916-1.916 1.92 1.92 0 0 0-1.915-1.917zm0 13.417a1.92 1.92 0 0 0-1.916 1.916c0 1.055.862 1.917 1.917 1.917a1.92 1.92 0 0 0 1.916-1.917 1.92 1.92 0 0 0-1.917-1.916m0-6.709a1.92 1.92 0 0 0-1.916 1.917c0 1.054.862 1.917 1.917 1.917a1.92 1.92 0 0 0 1.916-1.917 1.92 1.92 0 0 0-1.915-1.917z" }));
  const Svg3714337086137Eb1 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 19.251, height: 20.644, viewBox: "0 0 19.251 20.644", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m11.227 3.172-3.201.002c-1.508 0-2.657-.006-3.612.123s-1.768.423-2.38 1.033c-.61.61-.907 1.426-1.036 2.383-.128.955-.123 2.1-.123 3.61 0 1.508-.005 2.654.123 3.61.13.956.425 1.771 1.036 2.381.61.61 1.424.905 2.38 1.034.956.128 2.104.125 3.612.125h3.199c1.508 0 2.656.003 3.611-.125.957-.13 1.77-.424 2.381-1.034s.906-1.425 1.035-2.38c.13-.958.123-2.103.123-3.612s.006-2.654-.123-3.61c-.129-.954-.423-1.771-1.033-2.382s-1.427-.906-2.383-1.035c-.956-.13-2.102-.123-3.61-.123M8.026 4.674h3.199c1.508 0 2.625.005 3.412.11.786.106 1.193.28 1.52.606v.002h.001c.327.326.5.733.606 1.52l.03.26H2.456q.014-.136.03-.26c.106-.786.28-1.195.605-1.522h.002c.326-.327.733-.499 1.52-.605.786-.105 1.904-.111 3.412-.111M2.389 8.672h14.475c.008.492.011 1.03.011 1.65 0 1.51-.005 2.625-.109 3.41-.107.788-.28 1.198-.607 1.524h-.002c-.326.326-.733.5-1.52.605-.786.106-1.903.113-3.41.113H8.026c-1.51 0-2.625-.007-3.412-.113-.786-.105-1.193-.278-1.52-.605-.328-.326-.5-.736-.607-1.522-.105-.787-.11-1.902-.11-3.41 0-.62.004-1.16.012-1.652m2.436 3.302a.75.75 0 1 0 0 1.5h3.2a.75.75 0 0 0 0-1.5zm5.2 0a.75.75 0 1 0 0 1.5h1.2a.75.75 0 0 0 0-1.5z" }));
  const Svg071A4A0C17B97D20 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 19.251, height: 20.644, viewBox: "0 0 19.251 20.644", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M1.75 15.452a.85.85 0 0 1-.624-.252.84.84 0 0 1-.25-.623q0-.372.251-.624a.84.84 0 0 1 .623-.251H17.5q.372 0 .624.252a.84.84 0 0 1 .251.623.85.85 0 0 1-.252.623.84.84 0 0 1-.623.252zM1.312 9.83a.6.6 0 0 1-.306-.394.68.68 0 0 1 .066-.503l.415-.744h-.83A.637.637 0 0 1 0 7.533a.635.635 0 0 1 .656-.656h.831l-.415-.7a.68.68 0 0 1-.066-.504.6.6 0 0 1 .306-.393.68.68 0 0 1 .504-.066.6.6 0 0 1 .393.306l.416.7.416-.7a.6.6 0 0 1 .393-.306.68.68 0 0 1 .503.066q.24.13.307.393a.68.68 0 0 1-.066.504l-.415.7h.83a.635.635 0 0 1 .657.656.64.64 0 0 1-.656.656h-.832l.416.744a.67.67 0 0 1 .066.503.6.6 0 0 1-.306.394.68.68 0 0 1-.504.065.6.6 0 0 1-.393-.306l-.416-.744-.416.744a.6.6 0 0 1-.393.306.68.68 0 0 1-.503-.065zm7 0a.6.6 0 0 1-.306-.394.68.68 0 0 1 .066-.503l.416-.744h-.833A.637.637 0 0 1 7 7.533a.635.635 0 0 1 .656-.656h.832l-.416-.7a.68.68 0 0 1-.066-.504.6.6 0 0 1 .306-.393.68.68 0 0 1 .504-.066.6.6 0 0 1 .393.306l.416.7.416-.7a.6.6 0 0 1 .393-.306.68.68 0 0 1 .504.066q.24.13.306.393a.68.68 0 0 1-.066.504l-.416.7h.832a.635.635 0 0 1 .656.656.64.64 0 0 1-.656.656h-.832l.416.744a.67.67 0 0 1 .066.503.6.6 0 0 1-.306.394.68.68 0 0 1-.504.065.6.6 0 0 1-.393-.306l-.416-.744-.416.744a.6.6 0 0 1-.393.306.68.68 0 0 1-.504-.065m7 0a.6.6 0 0 1-.306-.394.68.68 0 0 1 .066-.503l.416-.744h-.832A.637.637 0 0 1 14 7.533a.635.635 0 0 1 .656-.656h.832l-.416-.7a.68.68 0 0 1-.066-.504.6.6 0 0 1 .306-.393.68.68 0 0 1 .504-.066.6.6 0 0 1 .393.306l.416.7.416-.7a.6.6 0 0 1 .393-.306.68.68 0 0 1 .503.066q.24.13.307.393a.67.67 0 0 1-.066.504l-.416.7h.832a.635.635 0 0 1 .656.656.64.64 0 0 1-.656.656h-.832l.416.744a.67.67 0 0 1 .066.503.6.6 0 0 1-.306.394.68.68 0 0 1-.504.065.6.6 0 0 1-.393-.306l-.416-.744-.416.744a.6.6 0 0 1-.393.306.68.68 0 0 1-.503-.065z" }));
  const Svg6018Ebb68Aec24Ff = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 19.251, height: 20.644, viewBox: "0 0 19.251 20.644", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M7.98 0a.75.75 0 0 0-.75.75v.916H4.644A2.417 2.417 0 0 0 2.23 4.082v12.5a2.417 2.417 0 0 0 2.416 2.416h10a2.42 2.42 0 0 0 2.418-2.416v-12.5a2.42 2.42 0 0 0-2.418-2.416H11.73a.75.75 0 0 0-.75.75.75.75 0 0 0 .75.75h2.916a.915.915 0 0 1 .918.916v12.5a.917.917 0 0 1-.918.916h-10a.916.916 0 0 1-.916-.916v-12.5a.915.915 0 0 1 .916-.916H7.23v.916a.75.75 0 0 0 .75.75.75.75 0 0 0 .75-.75V.75A.75.75 0 0 0 7.98 0M6.313 7.5a.75.75 0 0 0-.75.75.75.75 0 0 0 .75.75H7.98a.75.75 0 0 0 .75-.75.75.75 0 0 0-.75-.75zm0 3.332a.75.75 0 0 0-.75.75.75.75 0 0 0 .75.75h6.666a.75.75 0 0 0 .75-.75.75.75 0 0 0-.75-.75zm0 3.334a.75.75 0 0 0-.75.75.75.75 0 0 0 .75.75h3.332a.75.75 0 0 0 .75-.75.75.75 0 0 0-.75-.75z" }));
  const SvgB1D9C11A519C251C = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 21, height: 21, viewBox: "0 0 21 21", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M11.088 3.654q-.638-.027-1.275.01A12.5 12.5 0 0 0 5.578 4.67a12.5 12.5 0 0 0-3.617 2.383.9.9 0 0 0-.375.63.9.9 0 0 0 .227.698.9.9 0 0 0 .672.29.9.9 0 0 0 .662-.312l-.01.012c.385-.367-.023.005.379-.344.402-.348-.026.003.392-.326s-.023.004.41-.304c.434-.309-.025 0 .422-.288.448-.287-.025 0 .436-.265.46-.266-.024 0 .45-.244.472-.244-.026-.002.458-.223s-.025-.003.469-.201-.024-.006.478-.18c.503-.174-.024-.004.487-.154.51-.15-.023-.008.494-.133s-.025-.007.498-.107c.522-.101-.023-.01.504-.086s-.022-.01.508-.06c.53-.051-.022-.01.51-.036.53-.025-.023-.014.51-.014.531 0-.023-.011.509.014.531.025-.02-.015.51.035s-.02-.015.508.06c.526.076-.019-.014.503.087.523.1-.019-.018.499.107.517.125-.017-.017.494.133.51.15-.017-.02.486.154s-.015-.018.478.18c.494.198-.015-.02.47.201.483.221-.015-.021.458.223.473.243-.011-.022.45.244.46.266-.013-.022.435.265s-.012-.021.422.288c.433.308-.008-.025.41.304.418.33-.01-.022.393.326.402.349-.007-.023.379.344l.002.002c.162.15.382.234.603.234h.004a.91.91 0 0 0 .81-.574.91.91 0 0 0-.23-.967A12.5 12.5 0 0 0 14.826 4.4a12.5 12.5 0 0 0-3.738-.746m-.508 3.922a8.93 8.93 0 0 0-5.912 2.27.9.9 0 0 0-.295.61.9.9 0 0 0 .213.642l.002.004a.9.9 0 0 0 .613.295.9.9 0 0 0 .643-.225c.266-.238-.03.015.246-.211s-.03.014.256-.2c.286-.212-.032.013.264-.187.295-.2-.031.012.273-.174.305-.185-.033.01.28-.162.312-.171-.032.007.288-.15s-.034.006.293-.137c.327-.142-.032.007.301-.12.333-.128-.034.002.305-.11s-.033 0 .31-.096c.344-.096-.035 0 .313-.08.347-.08-.033-.002.318-.066.351-.065-.033-.003.32-.051.354-.049-.032-.005.323-.037.355-.033-.034-.006.322-.022s-.032-.008.324-.008c.357 0-.032-.008.324.008.357.016-.032-.01.323.022s-.031-.012.322.037c.353.048-.03-.014.32.05.351.065-.029-.014.319.067.347.08-.031-.016.312.08.344.097-.028-.016.31.096.34.112-.028-.018.305.11.334.127-.026-.022.301.12.327.143-.027-.02.293.137s-.023-.021.29.15c.312.172-.026-.023.279.162.304.186-.023-.025.273.174.296.2-.023-.025.264.188.286.213-.02-.027.256.199s-.02-.027.246.21c.157.146.37.227.584.226h.002a.94.94 0 0 0 .67-.293l.003-.006a.9.9 0 0 0 .213-.643.9.9 0 0 0-.295-.61 8.93 8.93 0 0 0-5.914-2.269m-.51 4.024a5.23 5.23 0 0 0-2.67 1.045.9.9 0 0 0-.354.587.9.9 0 0 0 .174.66.9.9 0 0 0 .713.356h.002a.92.92 0 0 0 .53-.176l.001-.002c.143-.108-.033.019.113-.084.147-.102-.033.019.118-.078.15-.096-.036.018.119-.072.154-.09-.035.016.123-.068s-.037.015.125-.063c.161-.077-.036.012.129-.058.164-.071-.039.01.129-.053.167-.064-.037.008.132-.049.17-.057-.039.01.133-.041.172-.05-.037.006.137-.037s-.039.005.137-.031c.175-.037-.04.003.136-.026s-.039.002.139-.02-.038.002.14-.013c.18-.015-.038-.003.141-.01.18-.007-.038-.002.14-.002.18 0-.04-.005.14.002.178.007-.038-.005.14.01s-.037-.008.14.014-.037-.01.14.02c.176.028-.04-.012.136.025.176.036-.037-.012.137.03.174.044-.035-.012.137.038.171.05-.037-.016.132.041.17.057-.034-.015.133.049s-.035-.018.13.053c.164.07-.033-.02.128.058s-.033-.021.125.063-.032-.022.123.068-.032-.024.12.072c.15.097-.03-.024.116.078s-.029-.024.114.084l.002.002a.9.9 0 0 0 .658.164.9.9 0 0 0 .586-.341v-.002a.9.9 0 0 0 .17-.66.9.9 0 0 0-.348-.586 5.26 5.26 0 0 0-3.644-1.047m.481 3.98a.9.9 0 0 0-.629.26.9.9 0 0 0-.26.629.9.9 0 0 0 .26.629.9.9 0 0 0 .629.26.9.9 0 0 0 .629-.26.9.9 0 0 0 .26-.63.9.9 0 0 0-.26-.628.9.9 0 0 0-.629-.26" }));
  const Svg12F2Ab3739Adfbea = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: 22, height: 22, viewBox: "0 0 22 22", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M11 0A11 11 0 0 0 0 11a11 11 0 0 0 11 11 11 11 0 0 0 11-11A11 11 0 0 0 11 0zM6.523 5.271a1.25 1.25 0 0 1 .887.37L11 9.23l3.59-3.59a1.25 1.25 0 0 1 1.771 0 1.25 1.25 0 0 1-.002 1.77L12.77 11l3.592 3.592a1.25 1.25 0 0 1-.002 1.77 1.25 1.25 0 0 1-1.767 0L11 12.77l-3.592 3.59a1.25 1.25 0 0 1-1.767 0 1.25 1.25 0 0 1-.002-1.77L9.23 11 5.64 7.41a1.25 1.25 0 0 1-.001-1.77 1.25 1.25 0 0 1 .884-.369z" }));
  const Svg78Cd0901269Cea25 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16.018, height: 16.018, viewBox: "0 0 16.018 16.018", ...props }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("style", null, ".search_svg__a{fill:none;stroke:#8e8e8e;stroke-linecap:round;stroke-linejoin:round;stroke-width:2.5px}")), /* @__PURE__ */ reactExports.createElement("path", { className: "search_svg__a", d: "M12.806 7.028A5.778 5.778 0 1 1 7.028 1.25a5.778 5.778 0 0 1 5.778 5.778zM14.25 14.25l-3.142-3.142" }));
  const Svg4Be4720676Aebafd = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 12.5, height: 12.5, viewBox: "0 0 12.5 12.5", ...props }, /* @__PURE__ */ reactExports.createElement("path", { "data-name": "Icon ionic-ios-checkmark-circle", d: "M6.25 0a6.25 6.25 0 106.25 6.25A6.249 6.249 0 006.25 0zm3.2 4.522L5.433 8.558a.543.543 0 01-.349.165.526.526 0 01-.352-.171L3.047 6.869a.12.12 0 010-.171l.535-.535a.116.116 0 01.168 0l1.334 1.334L8.75 3.804a.119.119 0 01.084-.036.109.109 0 01.084.036l.526.544a.118.118 0 01.006.177z" }));
  const Svg639E0321C796A6Fd = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 12.5, height: 12.5, viewBox: "0 0 12.5 12.5", ...props }, /* @__PURE__ */ reactExports.createElement("path", { "data-name": "Icon ionic-ios-warning", d: "M5.435.518L.114 11.038A.99.99 0 00.925 12.5h10.648a.992.992 0 00.814-1.462L7.063.518a.9.9 0 00-1.628 0zm1.343 4.365L6.67 8.854h-.845l-.1-3.971zm-.529 6.133a.6.6 0 11.574-.6.581.581 0 01-.574.6z" }));
  var en = ((e2) => (e2[e2.Undefined = 0] = "Undefined", e2[e2.NoCharacterClass = ErrorGroup$1.ClientWebSdk + 400] = "NoCharacterClass", e2[e2.PasswordTooShort = ErrorGroup$1.ClientWebSdk + 410] = "PasswordTooShort", e2))(en || {});
  class to extends DomainError$1 {
    constructor(t2, n2, r2, i2) {
      super(t2, n2, r2 ?? n2, i2 ?? pleaseUpdate$3);
    }
  }
  class bi extends to {
    constructor() {
      super(en.NoCharacterClass, "no character class", "at least one type of chars must be selected", `Select at least one of the types (numbers, upper-case, lower-case, special).${pleaseUpdate$3}`);
    }
  }
  class Ii extends to {
    constructor() {
      super(en.PasswordTooShort, "password to short", "the requested password length is too short", `The password length must be at least on for each character type.${pleaseUpdate$3}`);
    }
  }
  const Cn = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", wn = "abcdefghijklmnopqrstuvwxyz", bn = "0123456789", In = "!#$@&%*^+_?()\\;:.=~{}<>-,\"'/`|".slice(0, 10);
  function kt(e2) {
    const t2 = new Uint32Array(1);
    return window.crypto.getRandomValues(t2), t2[0] >= Math.floor(4294967295 / e2) * e2 ? kt(e2) : t2[0] % e2;
  }
  function ot(e2, t2) {
    const n2 = kt(e2.value.length), r2 = t2[kt(t2.length)];
    return {
      value: e2.value.slice(0, n2) + r2 + e2.value.slice(n2, e2.value.length),
      /* TODO: entropy calculation is not exact here as distribution of char groups is not considered
       * actual entropy is a little bit higher
       */
      entropy: e2.entropy + Math.log2(t2.length)
    };
  }
  function tn(e2, t2, n2, r2, i2) {
    const s2 = (t2 ? 1 : 0) + (n2 ? 1 : 0) + (r2 ? 1 : 0) + (i2 ? 1 : 0);
    if (s2 === 0)
      throw new bi();
    if (e2 < s2)
      throw new Ii();
    const c2 = (t2 ? Cn : "") + (n2 ? wn : "") + (r2 ? bn : "") + (i2 ? In : "");
    let a = {
      value: "",
      entropy: 0
    };
    for (t2 && (a = ot(a, Cn)), n2 && (a = ot(a, wn)), r2 && (a = ot(a, bn)), i2 && (a = ot(a, In)); a.value.length < e2; )
      a = ot(a, c2);
    return a;
  }
  const no = we$1.createContext("default");
  function Si({
    children: e2,
    uiStyle: t2
  }) {
    return /* @__PURE__ */ jsx(no.Provider, { value: t2, children: e2 });
  }
  reactExports.forwardRef(({
    children: e2,
    uiStyle: t2,
    element: n2,
    className: r2,
    ...i2
  }, s2) => /* @__PURE__ */ jsx(Si, { uiStyle: t2, children: /* @__PURE__ */ jsx(n2 ?? "div", { className: f$1(r2, {
    [d$1.defaultStyle]: t2 === "default",
    [d$1.highlightStyle]: t2 === "highlight"
  }), ref: s2, ...i2, children: e2 }) }));
  function Ye() {
    return reactExports.useContext(no);
  }
  const oo = we$1.createContext("light");
  function Z() {
    return reactExports.useContext(oo);
  }
  const ro = reactExports.createContext(false);
  function nn() {
    return reactExports.useContext(ro);
  }
  reactExports.createContext({
    openLogin: void 0,
    setOpenLogin: () => {
    }
  });
  reactExports.createContext({
    writeAuditlogEvent: () => {
      trackError(new Error("AuditlogWriteContext used without being set up!"));
    }
  });
  function Li(e2, t2, n2, r2) {
    const [i2, s2] = reactExports.useState(), [c2, a] = reactExports.useState(), [l2, d2] = reactExports.useState(), u2 = n2 ?? DEFAULT_TOTP_DIGITS;
    return reactExports.useEffect(() => {
      if (!e2) {
        s2(void 0), a(void 0), d2(void 0);
        return;
      }
      let m2;
      const h2 = () => {
        const {
          totp: g2,
          epochLeftMs: v2,
          epochStart: L2,
          epochEnd: N2
        } = calculateTotp(e2.toUpperCase().trim(), t2 ?? DEFAULT_TOTP_ALGORITHM, u2, r2 ?? DEFAULT_TOTP_PERIOD);
        s2(g2), a([L2, N2]), m2 = setTimeout(h2, v2);
      };
      try {
        h2();
      } catch (g2) {
        if (g2 instanceof InvalidTotpSecretError || g2 instanceof UnknownTotpAlgorithmError) {
          s2(void 0), a(void 0), d2(void 0);
          return;
        }
        throw g2;
      }
      return () => {
        clearTimeout(m2), a(void 0);
      };
    }, [e2, t2, u2, r2]), reactExports.useEffect(() => {
      if (c2 === void 0)
        return;
      const [m2, h2] = c2, g2 = h2 - m2, v2 = () => {
        const N2 = Date.now() - m2;
        d2(N2 * 100 / g2);
      };
      v2();
      const L2 = setInterval(v2, 250);
      return () => {
        clearInterval(L2);
      };
    }, [c2]), {
      totp: i2,
      totpPercent: l2,
      totpDigits: (i2 == null ? void 0 : i2.length) ?? u2
    };
  }
  function he() {
    const [e2, t2] = reactExports.useState({
      width: 0,
      height: 0
    }), [n2, r2] = reactExports.useState(null), i2 = reactExports.useCallback((c2) => {
      r2(c2), t2(Sn(c2));
    }, []), s2 = reactExports.useCallback(() => {
      t2(Sn(n2));
    }, [n2]);
    return reactExports.useEffect(() => {
      if (!n2)
        return;
      const c2 = new ResizeObserver(s2);
      return c2.observe(n2, {
        box: "border-box"
      }), () => c2.disconnect();
    }, [n2, s2]), [i2, e2];
  }
  function Sn(e2) {
    return e2 ? {
      width: e2.offsetWidth,
      height: e2.offsetHeight
    } : {
      width: 0,
      height: 0
    };
  }
  function on(e2, t2) {
    const n2 = Array.isArray(e2) ? e2 : [e2], r2 = reactExports.useMemo(() => n2, n2);
    reactExports.useEffect(() => {
      const i2 = (s2) => {
        Nn(s2, r2) || t2();
      };
      return window.addEventListener("click", i2), () => window.removeEventListener("click", i2);
    }, [t2, r2]), reactExports.useEffect(() => {
      const i2 = (s2) => {
        s2.key === "Escape" && Nn(s2, r2) && t2();
      };
      return window.addEventListener("keydown", i2), () => window.removeEventListener("keydown", i2);
    }, [t2, r2]);
  }
  function Nn(e2, t2) {
    return t2.flatMap((r2) => r2.current ? r2.current : []).some((r2) => r2.contains(e2.target));
  }
  function Ke({
    isEmpty: e2,
    onShow: t2
  }) {
    const [n2, r2] = reactExports.useState(e2);
    reactExports.useEffect(() => {
      e2 && r2(true);
    }, [e2]);
    const i2 = reactExports.useRef(n2);
    return reactExports.useEffect(() => {
      n2 !== i2.current && (i2.current = n2, t2 && n2 && t2());
    }, [t2, n2]), {
      show: n2,
      setShow: r2,
      action: {
        key: "show/hide",
        icon: Svg5D0Be631Bf7D3947,
        label: i18n._(
          /*i18n*/
          {
            id: "8vETh9"
          }
        ),
        activeIcon: SvgE05728E87Cd1Ca23,
        activeLabel: i18n._(
          /*i18n*/
          {
            id: "vLyv1R"
          }
        ),
        active: n2,
        element: {
          type: "button",
          props: {
            onClick: (s2) => {
              r2((c2) => !c2), s2.preventDefault();
            },
            type: "button",
            disabled: e2
          }
        }
      }
    };
  }
  function Ti({
    visible: e2,
    anchor: t2,
    innerAnchor: n2 = {
      top: 0,
      left: 0
    },
    rootStyle: r2
  }) {
    const i2 = reactExports.useRef(null), s2 = reactExports.useRef(null), c2 = reactExports.useCallback((d2) => {
      i2.current = d2;
      let u2 = d2;
      for (; u2 && u2.scrollHeight <= u2.clientHeight; )
        u2 = u2.parentElement;
      s2.current = u2;
    }, []), a = reactExports.useRef(document.createElement("div"));
    return reactExports.useEffect(() => {
      if (!e2)
        return;
      const d2 = a.current;
      return document.body.appendChild(d2), () => {
        document.body.removeChild(d2);
      };
    }, [e2]), $i({
      visible: e2,
      positionElementScrollParentRef: s2,
      portalRootRef: a
    }), Ei({
      visible: e2,
      anchor: t2,
      innerAnchor: n2,
      rootStyle: r2,
      positioningElementRef: i2,
      portalRootRef: a
    }), {
      PositionedPortal: reactExports.useCallback(({
        children: d2
      }) => _r.createPortal(d2, a.current), []),
      updatePositioningElement: c2
    };
  }
  function $i({
    visible: e2,
    positionElementScrollParentRef: t2,
    portalRootRef: n2
  }) {
    reactExports.useEffect(() => {
      if (!e2)
        return;
      function r2(s2) {
        var c2;
        (c2 = t2.current) == null || c2.scrollBy({
          top: s2.deltaY,
          left: s2.deltaX
        });
      }
      const i2 = n2.current;
      return i2.addEventListener("wheel", r2), () => {
        i2.removeEventListener("wheel", r2);
      };
    }, [n2, t2, e2]);
  }
  function Ei({
    visible: e2,
    anchor: t2,
    innerAnchor: n2,
    rootStyle: r2,
    positioningElementRef: i2,
    portalRootRef: s2
  }) {
    const c2 = reactExports.useCallback(() => {
      i2.current && Object.assign(s2.current.style, Pi({
        posEl: i2.current,
        posAnchor: t2,
        innerAnchor: n2,
        rootStyle: r2
      }));
    }, [t2, n2, s2, i2, r2]), a = reactExports.useCallback(() => {
      requestAnimationFrame(c2);
    }, [c2]);
    reactExports.useEffect(() => {
      if (e2)
        return a(), document.addEventListener("scroll", a, true), window.addEventListener("resize", a), () => {
          document.removeEventListener("scroll", a, true), window.addEventListener("resize", a);
        };
    }, [a, e2]);
  }
  function Pi({
    posEl: e2,
    posAnchor: t2,
    innerAnchor: n2,
    rootStyle: r2
  }) {
    const i2 = {
      position: "fixed",
      ...r2
    }, s2 = e2.getBoundingClientRect();
    "top" in t2 ? i2.top = `${s2.top + s2.height * t2.top}px` : i2.bottom = `${document.documentElement.clientHeight - s2.bottom + s2.height * t2.bottom}px`, "left" in t2 ? i2.left = `${s2.left + s2.width * t2.left}px` : i2.right = `${document.documentElement.clientWidth - s2.right + s2.width * t2.right}px`;
    const c2 = "top" in n2 ? -n2.top : -(1 - n2.bottom), a = "left" in n2 ? -n2.left : -(1 - n2.right);
    return i2.transform = `translate(${a * 100}%, ${c2 * 100}%)`, i2;
  }
  function de(e2, t2) {
    const [n2, r2] = reactExports.useState(false), i2 = reactExports.useCallback(() => {
      if (!t2)
        return;
      e2(t2), r2(true);
      const s2 = window.setTimeout(() => r2(false), 1e3);
      return () => window.clearTimeout(s2);
    }, [e2, t2]);
    return {
      action: {
        key: "copy",
        icon: Svg32192847008Cf9Fc,
        label: i18n._(
          /*i18n*/
          {
            id: "he3ygx"
          }
        ),
        activeIcon: SvgB1C9Ac3221E94B98,
        active: n2,
        activeLabel: i18n._(
          /*i18n*/
          {
            id: "6V3Ea3"
          }
        ),
        element: {
          type: "button",
          props: {
            onClick: i2,
            type: "button",
            disabled: !t2
          }
        }
      }
    };
  }
  const Qi = "_Button_1jnoy_1 _UnstyledButton_14p2i_205", Yi = "_medium_1jnoy_31", Ji = "_small_1jnoy_35", Xi = "_PillButton_1jnoy_40 _Button_1jnoy_1 _UnstyledButton_14p2i_205", Zi = "_primary_1jnoy_62 _PillButton_1jnoy_40 _Button_1jnoy_1 _UnstyledButton_14p2i_205", es = "_secondary_1jnoy_77 _PillButton_1jnoy_40 _Button_1jnoy_1 _UnstyledButton_14p2i_205", ts = "_userConfirmation_1jnoy_92 _PillButton_1jnoy_40 _Button_1jnoy_1 _UnstyledButton_14p2i_205", ns = "_dark_1jnoy_109", os = "_highlight_1jnoy_110", rs = "_tertiary_1jnoy_122 _Button_1jnoy_1 _UnstyledButton_14p2i_205", rt = {
    Button: Qi,
    medium: Yi,
    small: Ji,
    PillButton: Xi,
    primary: Zi,
    secondary: es,
    userConfirmation: ts,
    dark: ns,
    highlight: os,
    tertiary: rs,
    default: "_default_1jnoy_141"
  };
  function be({
    element: e2,
    buttonStyle: t2,
    className: n2,
    children: r2,
    size: i2,
    buttonRef: s2,
    overrideColor: c2,
    style: a,
    ...l2
  }) {
    const d2 = e2 ?? "button", u2 = Ye(), m2 = Z();
    return /* @__PURE__ */ jsx(d2, { className: f$1(rt.Button, rt[t2], rt[u2], rt[m2], rt[i2 ?? "medium"], n2), style: {
      ...a,
      "--color-override": c2
    }, ...l2, ref: s2, children: r2 });
  }
  const ys = "_Button_1s6un_1 _UnstyledButton_14p2i_205", Ln = {
    Button: ys
  };
  function co({
    element: e2,
    className: t2,
    children: n2,
    ...r2
  }) {
    const i2 = e2 ?? "button", s2 = Ye();
    return /* @__PURE__ */ jsx(i2, { className: f$1(Ln.Button, Ln[s2], t2), ...r2, children: n2 });
  }
  const vs = "_Switch_lac3f_1", Cs = {
    Switch: vs
  };
  function at({
    className: e2,
    ...t2
  }) {
    return /* @__PURE__ */ jsx("input", { type: "checkbox", className: f$1(Cs.Switch, e2), ...t2 });
  }
  const xs = "_InputContainer_17zv7_1", Rs = "_hasIcon_17zv7_20", Bs = "_labelInside_17zv7_23", Ts = "_relaxedLabelInsideSpacing_17zv7_27", $s = "_hasRightInlineUi_17zv7_31", Es = "_hasBottomInlineUi_17zv7_34", Ps = "_disabled_17zv7_37", As = "_readOnly_17zv7_38", Ms = "_lightMode_17zv7_41", Os = "_error_17zv7_45", Fs = "_warning_17zv7_48", Ws = "_darkMode_17zv7_51", zs = "_InputFieldWrapper_17zv7_63", Ds = "_InputLabel_17zv7_67", Us = "_Input_17zv7_1", Vs = "_InputPlaceholder_17zv7_73", ks = "_InputBackgroundText_17zv7_74", Hs = "_raisedLabel_17zv7_130", qs = "_colorize_17zv7_145", js = "_autosize_17zv7_177", Ks = "_focus_17zv7_184", Gs = "_suggestions_17zv7_188", Qs = "_monospace_17zv7_195", Ys = "_Icon_17zv7_208", Js = "_InlineUi_17zv7_224", Xs = "_Prefix_17zv7_253", Zs = "_Message_17zv7_266", V = {
    InputContainer: xs,
    hasIcon: Rs,
    labelInside: Bs,
    relaxedLabelInsideSpacing: Ts,
    hasRightInlineUi: $s,
    hasBottomInlineUi: Es,
    disabled: Ps,
    readOnly: As,
    lightMode: Ms,
    error: Os,
    warning: Fs,
    darkMode: Ws,
    InputFieldWrapper: zs,
    InputLabel: Ds,
    Input: Us,
    InputPlaceholder: Vs,
    InputBackgroundText: ks,
    raisedLabel: Hs,
    colorize: qs,
    autosize: js,
    focus: Ks,
    suggestions: Gs,
    monospace: Qs,
    Icon: Ys,
    InlineUi: Js,
    Prefix: Xs,
    Message: Zs
  };
  function J({
    style: e2,
    className: t2,
    element: n2,
    label: r2,
    icon: i2,
    error: s2,
    reserveSpaceForMessage: c2,
    warning: a,
    inlineUi: l2,
    labelInside: d2,
    placeholder: u2,
    monospace: m2,
    info: h2,
    prefix: g2
  }) {
    var E2, b2, B2, I2, A2;
    const v2 = typeof ((E2 = n2 == null ? void 0 : n2.props) == null ? void 0 : E2.value) == "string" ? (b2 = n2 == null ? void 0 : n2.props) == null ? void 0 : b2.value : "", [L2, N2] = reactExports.useState(false);
    return reactExports.useEffect(() => {
      var w2;
      (w2 = n2 == null ? void 0 : n2.props) != null && w2.disabled && N2(false);
    }, [(B2 = n2 == null ? void 0 : n2.props) == null ? void 0 : B2.disabled]), /* @__PURE__ */ jsx(Tt, { value: v2, style: e2, className: t2, icon: i2, label: r2, placeholder: u2, error: s2, reserveSpaceForMessage: c2, warning: a, focus: L2, disabled: !!((I2 = n2 == null ? void 0 : n2.props) != null && I2.disabled), readOnly: !!((A2 = n2 == null ? void 0 : n2.props) != null && A2.readOnly), labelInside: d2, relaxedLabelInsideSpacing: (n2 == null ? void 0 : n2.type) === "textarea" || (n2 == null ? void 0 : n2.type) === "autosizeTextarea", monospace: m2, info: h2, prefix: g2, renderInputElement: (w2, R2, T2) => {
      if ((n2 == null ? void 0 : n2.type) === "textarea") {
        const {
          className: S2,
          onFocus: $,
          onBlur: U2,
          onChange: F2,
          ...K2
        } = n2.props ?? {};
        return /* @__PURE__ */ jsx("textarea", { ...K2, value: w2, className: f$1(R2, S2), onFocus: We(() => N2(true), $), onBlur: We(() => N2(false), U2), onChange: F2, id: T2 });
      }
      if ((n2 == null ? void 0 : n2.type) === "autosizeTextarea") {
        const {
          className: S2,
          onFocus: $,
          onBlur: U2,
          onChange: F2,
          ...K2
        } = n2.props ?? {};
        return /* @__PURE__ */ jsx(index, { ...K2, value: w2, className: f$1(R2, S2, V.autosize), onFocus: We(() => N2(true), $), onBlur: We(() => N2(false), U2), onChange: F2, id: T2 });
      }
      if (!n2 || n2.type === "input") {
        const {
          className: S2,
          onFocus: $,
          onBlur: U2,
          onChange: F2,
          ...K2
        } = (n2 == null ? void 0 : n2.props) ?? {};
        return /* @__PURE__ */ jsx("input", { ...K2, value: w2, className: f$1(R2, S2), onFocus: We(() => N2(true), $), onBlur: We(() => N2(false), U2), onChange: F2, id: T2, "data-lpignore": "true" });
      }
    }, inlineUi: l2 });
  }
  function We(e2, t2) {
    return t2 ? (n2) => {
      e2(n2), t2(n2);
    } : e2;
  }
  function Tt({
    className: e2,
    error: t2,
    reserveSpaceForMessage: n2,
    focus: r2,
    disabled: i2,
    readOnly: s2,
    icon: c2,
    inlineUi: a,
    label: l2,
    placeholder: d2,
    backgroundText: u2,
    style: m2,
    suggestions: h2,
    suggestionsVisible: g2,
    value: v2,
    warning: L2,
    renderInputElement: N2,
    labelInside: E2,
    relaxedLabelInsideSpacing: b2,
    monospace: B2,
    inputWrapperProps: I2,
    info: A2,
    prefix: w2
  }) {
    const R2 = reactExports.useRef(newUuid$1()), T2 = f$1(V.Input, {
      [V.focus]: r2,
      [V.monospace]: B2
    }), [S2, {
      width: $
    }] = he(), U2 = {
      ...m2,
      "--inline-ui-width": a != null && a.bottom ? "0px" : (a == null ? void 0 : a.width) ?? "0px",
      "--inline-ui-height": a != null && a.bottom ? (a == null ? void 0 : a.height) ?? "0px" : "0px",
      "--prefix-width": `${$}px`
    }, F2 = !r2 && !v2 && !u2 && d2, K2 = r2 && !s2 || v2 || d2 || u2 || w2, j = Z();
    return /* @__PURE__ */ jsxs("div", { className: f$1(V.InputContainer, e2, {
      [V.hasRightInlineUi]: a && !a.bottom,
      [V.hasBottomInlineUi]: a && a.bottom,
      [V.raisedLabel]: K2,
      [V.disabled]: i2,
      [V.readOnly]: s2,
      [V.error]: t2,
      [V.warning]: L2,
      [V.hasIcon]: c2,
      [V.colorize]: L2 || t2,
      [V.suggestions]: g2,
      [V.labelInside]: E2 || j === "dark" && l2,
      [V.relaxedLabelInsideSpacing]: b2,
      [V.lightMode]: j === "light",
      [V.darkMode]: j === "dark"
    }), style: U2, children: [
      /* @__PURE__ */ jsxs("div", { className: V.InputFieldWrapper, ...I2, children: [
        l2 && /* @__PURE__ */ jsx("label", { htmlFor: R2.current, className: V.InputLabel, children: l2 }),
        F2 && /* @__PURE__ */ jsx("span", { className: V.InputPlaceholder, children: d2 }),
        u2 && /* @__PURE__ */ jsx("span", { className: V.InputBackgroundText, children: u2 }),
        c2 && /* @__PURE__ */ jsx("div", { className: V.Icon, children: c2 }),
        N2 ? N2(v2, T2, R2.current) : /* @__PURE__ */ jsx("input", { className: T2, type: "text", value: v2, id: R2.current, "data-lpignore": "true" }),
        a && /* @__PURE__ */ jsx("div", { className: V.InlineUi, children: a.node })
      ] }),
      w2 && /* @__PURE__ */ jsx("div", { className: V.Prefix, ref: S2, children: w2 }),
      h2,
      (typeof t2 == "string" || typeof L2 == "string" || A2 || n2) && /* @__PURE__ */ jsx("div", { className: V.Message, children: t2 || L2 || A2 })
    ] });
  }
  const ea = "_Dropdown_4ya18_1", ta = {
    Dropdown: ea
  }, rn = we$1.forwardRef(({
    element: e2,
    className: t2,
    children: n2,
    ...r2
  }, i2) => /* @__PURE__ */ jsx(e2 ?? "div", { className: f$1(ta.Dropdown, t2), ref: i2, ...r2, children: n2 })), na = "_fadeEnter_1q1f0_1", oa = "_fadeExit_1q1f0_5", ra = "_fadeEnterActive_1q1f0_9", ia = "_fadeExitActive_1q1f0_14", ft = {
    fadeEnter: na,
    fadeExit: oa,
    fadeEnterActive: ra,
    fadeExitActive: ia
  }, xn = {
    enter: ft.fadeEnter,
    exit: ft.fadeExit,
    enterActive: ft.fadeEnterActive,
    exitActive: ft.fadeExitActive
  };
  function sn({
    children: e2,
    active: t2,
    className: n2
  }) {
    return /* @__PURE__ */ jsx(hr, { className: n2, children: t2 ? /* @__PURE__ */ jsx(Ut, { classNames: xn, addEndListener: () => {
    }, children: e2.active }, t2 ? "b" : "a") : /* @__PURE__ */ jsx(Ut, { classNames: xn, addEndListener: () => {
    }, children: e2.default }, t2 ? "b" : "a") });
  }
  const sa = "_Wrapper_11r2k_1", aa = "_Action_11r2k_6 _UnstyledButton_14p2i_205", ca = "_inline_11r2k_21", la = "_ActionIcon_11r2k_32", da = "_OpenActionWrapper_11r2k_46", ua = "_Menu_11r2k_52", pa = "_dropdown_11r2k_67", fe = {
    Wrapper: sa,
    Action: aa,
    inline: ca,
    ActionIcon: la,
    OpenActionWrapper: da,
    Menu: ua,
    dropdown: pa
  }, _a = "_HoverOverlay_te52q_1", ma = {
    HoverOverlay: _a
  };
  function lo({
    children: e2,
    downwards: t2,
    element: n2,
    overlay: r2,
    ariaLabel: i2,
    ...s2
  }) {
    const c2 = n2, [a, l2] = reactExports.useState(false), {
      PositionedPortal: d2,
      updatePositioningElement: u2
    } = Ti({
      visible: a,
      anchor: t2 ? {
        top: 1,
        left: 0.5
      } : {
        bottom: 1,
        left: 0.5
      },
      innerAnchor: {
        top: 0,
        left: 0.5
      },
      rootStyle: {
        zIndex: "100",
        pointerEvents: "none"
      }
    }), m2 = reactExports.useRef(), h2 = nn();
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(c2, { "aria-label": i2, ...s2, ref: u2, onMouseEnter: () => {
        m2.current = window.setTimeout(() => l2(true), 50);
      }, onMouseLeave: (g2) => {
        h2 && g2.altKey || (clearTimeout(m2.current), l2(false));
      }, children: e2 }),
      /* @__PURE__ */ jsx(d2, { children: /* @__PURE__ */ jsx("div", { "aria-hidden": true, className: f$1(ma.HoverOverlay), children: r2 }) })
    ] });
  }
  function uo({
    tooltip: e2,
    element: t2,
    ...n2
  }) {
    return /* @__PURE__ */ jsx(lo, { ...n2, element: t2, overlay: e2, ariaLabel: e2 });
  }
  function po({
    actions: e2,
    maxInlineActions: t2,
    downwardsTooltips: n2
  }) {
    let r2 = e2, i2 = [];
    return t2 && e2.length > t2 && (r2 = e2.slice(0, t2 - 1), i2 = e2.slice(t2 - 1)), /* @__PURE__ */ jsxs("div", { className: f$1(fe.Wrapper), children: [
      r2.map((s2) => /* @__PURE__ */ jsx(_o, { ...s2, downwardsTooltip: n2 })),
      i2.length > 0 && /* @__PURE__ */ jsx(ha, { children: i2.map((s2) => /* @__PURE__ */ jsx(fa, { ...s2 })) })
    ] });
  }
  function an(e2) {
    let t2 = e2.actions.length;
    return e2.maxInlineActions && e2.maxInlineActions < t2 && (t2 = e2.maxInlineActions), {
      node: /* @__PURE__ */ jsx(po, { ...e2 }),
      width: `${1.75 * t2 - 0.25}rem`,
      height: "1.5rem",
      bottom: e2.bottom
    };
  }
  function oe(e2) {
    const [t2, {
      width: n2
    }] = he();
    let r2;
    return n2 < 300 ? r2 = 1 : n2 < 400 && (r2 = 2), {
      ref: t2,
      inlineUi: an({
        actions: e2,
        maxInlineActions: r2
      })
    };
  }
  function _o({
    icon: e2,
    active: t2,
    activeIcon: n2,
    className: r2,
    activeClassName: i2,
    element: s2,
    label: c2,
    activeLabel: a,
    downwardsTooltip: l2
  }) {
    var m2;
    const d2 = n2 ?? e2, u2 = t2 && a ? a : c2;
    return /* @__PURE__ */ jsx(uo, { element: s2.type, tooltip: u2, downwards: l2, ...s2.props, className: f$1(fe.Action, fe.inline, (m2 = s2.props) == null ? void 0 : m2.className), children: /* @__PURE__ */ jsx(sn, { active: t2, children: {
      default: /* @__PURE__ */ jsx(e2, { className: f$1(fe.ActionIcon, r2) }),
      active: /* @__PURE__ */ jsx(d2, { className: f$1(fe.ActionIcon, r2, i2) })
    } }) });
  }
  function ha({
    children: e2
  }) {
    const [t2, n2] = reactExports.useState(false), r2 = reactExports.useCallback(() => n2(false), []), i2 = reactExports.useRef(null);
    return on(i2, r2), /* @__PURE__ */ jsxs("div", { className: fe.OpenActionWrapper, ref: i2, children: [
      /* @__PURE__ */ jsx(_o, { element: {
        type: "button",
        props: {
          type: "button",
          onClick: () => n2(!t2)
        }
      }, label: i18n._(
        /*i18n*/
        {
          id: "2FYpfJ"
        }
      ), icon: SvgE7A3F077F365818E }, "more"),
      t2 && /* @__PURE__ */ jsx(rn, { element: "ul", className: fe.Menu, onClick: r2, children: e2 })
    ] });
  }
  function fa({
    icon: e2,
    element: t2,
    active: n2,
    activeIcon: r2,
    className: i2,
    activeClassName: s2,
    label: c2,
    activeLabel: a
  }) {
    var m2;
    const l2 = n2 && r2 ? r2 : e2, d2 = n2 && a ? a : c2, u2 = t2.type;
    return /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs(u2, { ...t2.props, className: f$1(fe.Action, fe.dropdown, (m2 = t2.props) == null ? void 0 : m2.className), children: [
      /* @__PURE__ */ jsx(l2, { className: f$1(fe.ActionIcon, i2, n2 && s2) }),
      d2
    ] }) });
  }
  const ga = "_Options_uim5e_1", ya = "_open_uim5e_14", va = "_darkMode_uim5e_18", Ca = "_colorize_uim5e_21", wa = "_overlay_uim5e_24", ba = "_Option_uim5e_1", Ia = "_OptionButton_uim5e_54 _Option_uim5e_1", Sa = "_highlighted_uim5e_58", Na = "_selected_uim5e_62", La = "_OptionInfo_uim5e_79 _Option_uim5e_1", ve = {
    Options: ga,
    open: ya,
    darkMode: va,
    colorize: Ca,
    overlay: wa,
    Option: ba,
    OptionButton: Ia,
    highlighted: Sa,
    selected: Na,
    OptionInfo: La
  };
  function mo({
    isOpen: e2,
    value: t2,
    colorize: n2,
    filteredOptions: r2,
    highlightedIndex: i2,
    noMatchingOptionsText: s2,
    optionsOverlay: c2,
    getMenuProps: a,
    getItemProps: l2,
    renderValueLabel: d2,
    valuesEqual: u2
  }) {
    const m2 = Z();
    return /* @__PURE__ */ jsx("ul", { ...a({
      className: f$1(ve.Options, {
        [ve.open]: e2,
        [ve.colorize]: n2,
        [ve.overlay]: c2,
        [ve.darkMode]: m2 === "dark"
      })
    }), children: e2 && (r2.length ? r2.map((h2, g2) => /* @__PURE__ */ jsx("li", { className: f$1(ve.OptionButton, {
      [ve.selected]: t2 && u2(h2, t2),
      [ve.highlighted]: i2 === g2
    }), ...l2({
      item: h2,
      index: g2
    }), children: d2(h2) }, g2)) : s2 && /* @__PURE__ */ jsx("li", { className: ve.OptionInfo, children: s2 }, "empty")) });
  }
  const xa = "_ClearButton_m0igx_1 _UnstyledButton_14p2i_205", Ra = "_Container_m0igx_11", Rn = {
    ClearButton: xa,
    Container: Ra
  };
  function Ba({
    value: e2,
    options: t2,
    noMatchingOptionsText: n2,
    getValueLabel: r2,
    getValueIconNode: i2,
    valuesEqual: s2,
    onFocus: c2,
    onBlur: a,
    autoFocus: l2,
    className: d2,
    style: u2,
    error: m2,
    warning: h2,
    disabled: g2,
    readOnly: v2,
    label: L2,
    labelInside: N2,
    optionsOverlay: E2,
    inlineUi: b2,
    // keep these props together since they form a correlated union with clearable
    ...B2
  }) {
    const [I2, A2] = reactExports.useState(""), w2 = reactExports.useRef(null), [R2, T2] = reactExports.useState(t2), {
      isOpen: S2,
      getMenuProps: $,
      getInputProps: U2,
      getComboboxProps: F2,
      highlightedIndex: K2,
      getItemProps: j,
      openMenu: ie2
    } = useCombobox({
      items: R2,
      inputValue: I2,
      selectedItem: e2 ?? null,
      itemToString: (k2) => k2 ? r2(k2) : "",
      onSelectedItemChange: ({
        selectedItem: k2
      }) => {
        B2.clearable ? (B2.onChange(k2 ?? void 0), A2("")) : k2 && (B2.onChange(k2), A2(""));
      },
      onStateChange: (k2) => {
        k2.type === useCombobox.stateChangeTypes.InputChange && A2(k2.inputValue ?? "");
      }
    });
    reactExports.useEffect(() => {
      const k2 = I2.toLowerCase().trim();
      if (!k2) {
        T2(t2);
        return;
      }
      T2(t2.filter((Ie2) => r2(Ie2).toLowerCase().includes(k2)));
    }, [r2, I2, t2]);
    const [ue2, Pe2] = reactExports.useState(false);
    return /* @__PURE__ */ jsx(Tt, { focus: ue2, disabled: !!g2, readOnly: !!v2, className: f$1(Rn.Container, d2), style: u2, error: S2 ? void 0 : m2, warning: S2 ? void 0 : h2, label: L2, labelInside: N2, value: I2, icon: e2 ? i2 == null ? void 0 : i2(e2) : void 0, backgroundText: !I2 && e2 ? r2(e2) : void 0, inputWrapperProps: F2(), renderInputElement: (k2, Ie2, Je2) => /* @__PURE__ */ jsx("input", { ...U2({
      id: Je2,
      onFocus: () => {
        !S2 && !v2 && !g2 && ie2(), c2 == null || c2(), Pe2(true);
      },
      onBlur: () => {
        a == null || a(), Pe2(false);
      },
      onKeyDown: (W2) => {
        (W2.key === "ArrowDown" || W2.key === "ArrowUp") && !S2 && (W2.preventDownshiftDefault = true), W2.key === "Enter" && !g2 && !v2 && (S2 ? R2.length && (W2.preventDefault(), B2.onChange(R2[0])) : (W2.preventDefault(), ie2()));
      },
      onClick: () => {
        !S2 && !g2 && !v2 && ie2();
      },
      type: "text",
      disabled: g2,
      readOnly: v2,
      autoFocus: l2,
      className: Ie2,
      ref: w2
    }), "data-lpignore": "true" }), suggestionsVisible: S2, suggestions: /* @__PURE__ */ jsx(mo, { isOpen: S2, value: e2, colorize: !!(h2 || m2), filteredOptions: R2, highlightedIndex: K2, noMatchingOptionsText: n2, optionsOverlay: E2, getMenuProps: $, getItemProps: j, valuesEqual: s2, renderValueLabel: (k2) => /* @__PURE__ */ jsx(Ta, { option: k2, getValueLabel: r2, getValueIconNode: i2 }) }), inlineUi: I2 || e2 !== void 0 && B2.clearable ? {
      node: /* @__PURE__ */ jsx("button", { type: "button", className: Rn.ClearButton, onClick: () => {
        var k2;
        A2(""), ie2(), B2.clearable && B2.onChange(void 0), (k2 = w2.current) == null || k2.focus();
      }, children: /* @__PURE__ */ jsx(Svg1Bcfd951Ee5Cd05C, { title: i18n._(
        /*i18n*/
        {
          id: "xCJdfg"
        }
      ) }) }),
      width: "1rem"
    } : b2 });
  }
  function Ta({
    option: e2,
    getValueLabel: t2,
    getValueIconNode: n2
  }) {
    return n2 ? /* @__PURE__ */ jsxs(Fragment, { children: [
      n2(e2),
      " ",
      t2(e2)
    ] }) : /* @__PURE__ */ jsx(Fragment, { children: t2(e2) });
  }
  const Pa = "_Spinner_1gk9j_1", Aa = {
    Spinner: Pa,
    "lds-spinner": "_lds-spinner_1gk9j_1"
  };
  function $t({
    size: e2,
    armCount: t2 = 12,
    animationDurationMs: n2 = 1e3,
    armWidth: r2 = 0.075,
    armHeight: i2 = 0.25,
    armCornerRadius: s2 = 0.03
  }) {
    return /* @__PURE__ */ jsx("div", { className: Aa.Spinner, style: {
      // @ts-ignore
      "--size": e2,
      "--animation-duration": `${n2}ms`,
      "--arm-width": r2,
      "--arm-height": i2,
      "--arm-corner-radius": s2
    }, children: Array(t2).fill(void 0).map((c2, a) => /* @__PURE__ */ jsx("div", { style: {
      // @ts-ignore
      "--rotate": `${a / t2}turn`,
      animationDelay: `${-n2 + (a + 1) * n2 / t2}ms`
    } }, `${t2}-${a}`)) });
  }
  const Ma = "_TotpCountdown_1qwcq_1", Oa = "_hidden_1qwcq_11", Fa = "_darkMode_1qwcq_21", Wa = "_finishing_1qwcq_35", za = "_starting_1qwcq_49", it = {
    TotpCountdown: Ma,
    hidden: Oa,
    darkMode: Fa,
    finishing: Wa,
    "flicker-animation": "_flicker-animation_1qwcq_1",
    starting: za
  };
  function Da({
    percent: e2,
    hidden: t2
  }) {
    const n2 = Z();
    return /* @__PURE__ */ jsx(CircularProgressbar, { value: 100 - e2, strokeWidth: 50, className: f$1(it.TotpCountdown, {
      [it.finishing]: e2 >= 84,
      [it.starting]: e2 < 2,
      [it.darkMode]: n2 === "dark",
      [it.hidden]: !!t2
    }), counterClockwise: true });
  }
  const Ua = "_CopyButton_x6l9h_1", Va = "_success_x6l9h_27", ka = "_Icon_x6l9h_35", Ha = "_Content_x6l9h_52", ze = {
    CopyButton: Ua,
    success: Va,
    Icon: ka,
    Content: Ha
  };
  function qa({
    onClick: e2,
    className: t2,
    success: n2,
    defaultIcon: r2,
    defaultText: i2,
    successText: s2,
    successIcon: c2,
    disabled: a
  }) {
    const l2 = r2, d2 = c2 ?? r2;
    return /* @__PURE__ */ jsx("button", { className: f$1(ze.CopyButton, t2), onClick: e2, type: "button", disabled: a, children: /* @__PURE__ */ jsx(sn, { active: n2, children: {
      active: /* @__PURE__ */ jsxs("div", { className: f$1(ze.Content, ze.success), children: [
        /* @__PURE__ */ jsx("div", { className: ze.Icon, children: /* @__PURE__ */ jsx(d2, {}) }),
        /* @__PURE__ */ jsx("p", { children: s2 ?? i2 })
      ] }),
      default: /* @__PURE__ */ jsxs("div", { className: ze.Content, children: [
        /* @__PURE__ */ jsx("div", { className: ze.Icon, children: /* @__PURE__ */ jsx(l2, {}) }),
        /* @__PURE__ */ jsx("p", { children: i2 })
      ] })
    } }) });
  }
  function ja({
    onClick: e2,
    className: t2,
    copied: n2,
    disabled: r2
  }) {
    return /* @__PURE__ */ jsx(qa, { className: t2, success: n2, defaultText: i18n._(
      /*i18n*/
      {
        id: "he3ygx"
      }
    ), defaultIcon: Svg32192847008Cf9Fc, successText: i18n._(
      /*i18n*/
      {
        id: "6V3Ea3"
      }
    ), successIcon: SvgB1C9Ac3221E94B98, onClick: e2, disabled: r2 });
  }
  const Ka = "_ArrowIcon_xe8or_1", gt = {
    ArrowIcon: Ka
  }, cn = we$1.forwardRef(({
    direction: e2,
    className: t2,
    ...n2
  }, r2) => e2 === "up" ? /* @__PURE__ */ jsx(SvgEd18499E3448Aad6, { ref: r2, className: f$1(gt.ArrowIcon, t2), ...n2 }) : e2 === "right" ? /* @__PURE__ */ jsx(Svg1B8Acf1Cc5Bb7E55, { ref: r2, className: f$1(gt.ArrowIcon, t2), ...n2 }) : e2 === "down" ? /* @__PURE__ */ jsx(Svg46Dde8092160Efa1, { ref: r2, className: f$1(gt.ArrowIcon, t2), ...n2 }) : /* @__PURE__ */ jsx(SvgFca912Dd1Ab82474, { ref: r2, className: f$1(gt.ArrowIcon, t2), ...n2 }));
  const Xa = "_LinkButton_1w1ip_1 _UnstyledButton_14p2i_205", Za = {
    LinkButton: Xa
  };
  function Ge({
    className: e2,
    children: t2,
    ...n2
  }) {
    return /* @__PURE__ */ jsx("button", { className: f$1(Za.LinkButton, e2), ...n2, children: t2 });
  }
  const ec = "_MessageBox_1pt86_1", tc = "_large_1pt86_21", nc = "_hasClose_1pt86_24", oc = "_success_1pt86_27", rc = "_warning_1pt86_31", ic = "_error_1pt86_35", sc = "_dark_1pt86_39", ac = "_light_1pt86_40", cc = "_highlight_1pt86_40", lc = "_hidden_1pt86_43", dc = "_Content_1pt86_57", uc = "_SmallIcon_1pt86_61", pc = "_SmallContent_1pt86_72", _c = "_LargeIcon_1pt86_83", mc = "_LargeText_1pt86_93", hc = "_LargeHeadline_1pt86_99", fc = "_LargeContent_1pt86_109", gc = "_Close_1pt86_127 _UnstyledButton_14p2i_205", Y = {
    MessageBox: ec,
    large: tc,
    hasClose: nc,
    success: oc,
    warning: rc,
    error: ic,
    dark: sc,
    light: ac,
    highlight: cc,
    hidden: lc,
    Content: dc,
    SmallIcon: uc,
    SmallContent: pc,
    LargeIcon: _c,
    LargeText: mc,
    LargeHeadline: hc,
    LargeContent: fc,
    Close: gc
  };
  function ct(e2) {
    const {
      sizeProps: t2,
      restProps: n2
    } = yc(e2), {
      hidden: r2,
      type: i2,
      onClose: s2,
      className: c2,
      children: a,
      style: l2,
      contentClassName: d2,
      ...u2
    } = n2, m2 = Z(), h2 = Ye(), [g2, v2] = he();
    return /* @__PURE__ */ jsxs("div", { className: f$1(Y.MessageBox, i2 && Y[i2], Y[m2], Y[h2], c2, {
      [Y.hidden]: r2,
      [Y.large]: t2.large,
      [Y.hasClose]: !!s2
    }), "aria-hidden": r2, style: {
      ...l2,
      "--content-height": v2.height > 0 ? `${v2.height}px` : "auto"
    }, ...u2, children: [
      /* @__PURE__ */ jsx("div", { className: Y.Content, ref: g2, children: t2.large ? /* @__PURE__ */ jsx(Cc, { headline: t2.headline, icon: t2.icon, contentClassName: d2, children: a }) : /* @__PURE__ */ jsx(vc, { type: i2, noDefaultIcon: t2.noDefaultIcon, contentClassName: d2, children: a }) }),
      s2 && /* @__PURE__ */ jsx("button", { type: "button", onClick: s2, className: Y.Close, children: /* @__PURE__ */ jsx(Svg85901Eed410D7B8F, { "aria-label": i18n._(
        /*i18n*/
        {
          id: "yz7wBu"
        }
      ) }) })
    ] });
  }
  function yc(e2) {
    if (e2.large) {
      const {
        large: i2,
        headline: s2,
        icon: c2,
        ...a
      } = e2;
      return {
        sizeProps: {
          large: i2,
          headline: s2,
          icon: c2
        },
        restProps: a
      };
    }
    const {
      large: t2,
      noDefaultIcon: n2,
      ...r2
    } = e2;
    return {
      sizeProps: {
        large: t2,
        noDefaultIcon: n2
      },
      restProps: r2
    };
  }
  function vc({
    type: e2,
    noDefaultIcon: t2,
    children: n2,
    contentClassName: r2
  }) {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      !t2 && (e2 === "success" ? /* @__PURE__ */ jsx(Svg4Be4720676Aebafd, { className: Y.SmallIcon }) : e2 === "warning" || e2 === "error" ? /* @__PURE__ */ jsx(Svg639E0321C796A6Fd, { className: Y.SmallIcon }) : e2 === "progress" ? /* @__PURE__ */ jsx("div", { className: Y.SmallIcon, children: /* @__PURE__ */ jsx($t, { size: "1rem", armCount: 10, armWidth: 0.15, armHeight: 0.3 }) }) : null),
      /* @__PURE__ */ jsx("div", { className: f$1(Y.SmallContent, r2), children: n2 })
    ] });
  }
  function Cc({
    headline: e2,
    icon: t2,
    children: n2,
    contentClassName: r2
  }) {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      t2 && /* @__PURE__ */ jsx(t2, { className: Y.LargeIcon }),
      /* @__PURE__ */ jsxs("div", { className: Y.LargeText, children: [
        /* @__PURE__ */ jsx("p", { className: Y.LargeHeadline, children: /* @__PURE__ */ jsx("strong", { children: e2 }) }),
        /* @__PURE__ */ jsx("p", { className: f$1(Y.LargeContent, r2), children: n2 })
      ] })
    ] });
  }
  function wc({
    children: e2,
    message: t2,
    recheck: n2,
    hidden: r2,
    onRecheckSuccess: i2,
    ...s2
  }) {
    const [c2, a] = reactExports.useState(), l2 = reactExports.useCallback(async () => {
      if (n2)
        try {
          a("inProgress"), await Promise.all([n2(), sleep(2e3)]), a("done");
        } catch {
          a(void 0);
        }
    }, [n2]);
    return reactExports.useEffect(() => {
      if (c2 === "done")
        a(r2 ? "showSuccess" : void 0);
      else if (c2 === "showSuccess") {
        const d2 = window.setTimeout(() => a("hideSuccess"), 2e3);
        return () => window.clearTimeout(d2);
      }
    }, [r2, i2, c2]), c2 === "inProgress" ? /* @__PURE__ */ jsx(ct, { type: "progress", ...s2, children: /* @__PURE__ */ jsx(Trans, { id: "2SqvU5" }) }) : c2 === "showSuccess" || c2 === "hideSuccess" ? /* @__PURE__ */ jsx(ct, { ...s2, type: "success", hidden: c2 === "hideSuccess", onTransitionEnd: () => {
      a(void 0), i2 == null || i2();
    }, children: /* @__PURE__ */ jsx(Trans, { id: "J8XjuC" }) }) : /* @__PURE__ */ jsxs(ct, { ...s2, type: "warning", hidden: r2, children: [
      t2,
      " ",
      n2 && /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Ge, { type: "button", onClick: () => {
          l2().catch(trackError);
        }, children: /* @__PURE__ */ jsx(Trans, { id: "3WxAes" }) }),
        " "
      ] }),
      e2
    ] });
  }
  function ho(e2) {
    return /* @__PURE__ */ jsx(wc, { message: i18n._(
      /*i18n*/
      {
        id: "HqgpzW"
      }
    ), ...e2 });
  }
  function Bn(e2) {
    return e2 = e2.replaceAll("\\", "\\\\"), e2 = e2.replaceAll(":", "\\:"), e2 = e2.replaceAll(";", "\\;"), e2 = e2.replaceAll(",", "\\,"), e2;
  }
  function bc(e2, t2) {
    return reactExports.useMemo(() => {
      let n2 = "WIFI:";
      return n2 += "T:WPA;", n2 += `S:${Bn(e2)};`, n2 += `P:${Bn(t2)};`, n2 += ";", n2;
    }, [e2, t2]);
  }
  function ut(e2, t2) {
    return {
      action: {
        icon: SvgE29A75303Cd009Cd,
        label: i18n._(
          /*i18n*/
          {
            id: "cnGeoo"
          }
        ),
        key: "delete",
        element: {
          type: "button",
          props: {
            type: "button",
            onClick: e2,
            ...t2
          }
        }
      }
    };
  }
  const Ic = "_FormInputPlaceholder_aibmw_1", Sc = "_ButtonWrapper_aibmw_8", Nc = "_hasInlineUi_aibmw_19", Lc = "_HiddenValuePill_aibmw_23 _UnstyledButton_14p2i_205", xc = "_dark_aibmw_40", Rc = "_HeyloginIcon_aibmw_43", Bc = "_PillText_aibmw_54", Tc = "_InlineUi_aibmw_64", Se = {
    FormInputPlaceholder: Ic,
    ButtonWrapper: Sc,
    hasInlineUi: Nc,
    HiddenValuePill: Lc,
    dark: xc,
    HeyloginIcon: Rc,
    PillText: Bc,
    InlineUi: Tc
  }, Qe = we$1.forwardRef(({
    inlineUi: e2,
    onButtonClick: t2,
    changed: n2,
    children: r2,
    className: i2,
    style: s2,
    ...c2
  }, a) => {
    const l2 = Z(), d2 = l2 === "light" ? Svg92Beb0D5816827F1 : Svg79403247197Ec9Cd;
    return /* @__PURE__ */ jsxs("div", { className: f$1(Se.FormInputPlaceholder, Se[l2], {
      [Se.hasInlineUi]: e2
    }, i2), style: {
      "--inline-ui-width": (e2 == null ? void 0 : e2.width) ?? 0,
      ...s2
    }, ...c2, children: [
      /* @__PURE__ */ jsx("div", { className: Se.ButtonWrapper, ref: a, children: /* @__PURE__ */ jsxs("button", { type: "button", className: Se.HiddenValuePill, onClick: t2, children: [
        /* @__PURE__ */ jsx(d2, { className: Se.HeyloginIcon }),
        /* @__PURE__ */ jsxs("span", { className: Se.PillText, children: [
          r2,
          n2 && /* @__PURE__ */ jsxs(Fragment, { children: [
            " ",
            /* @__PURE__ */ jsx(Trans, { id: "d/ZbMk" })
          ] })
        ] })
      ] }) }),
      e2 && /* @__PURE__ */ jsx("div", { className: Se.InlineUi, children: e2.node })
    ] });
  });
  function fo({
    suggestions: e2,
    applySuggestion: t2,
    inputProps: n2,
    inlineUi: r2,
    optionsOverlay: i2,
    onInputEnter: s2,
    renderSuggestionValueLabel: c2,
    ...a
  }) {
    const l2 = reactExports.useRef(null), d2 = typeof n2.value == "string" ? n2.value : "", [u2, m2] = reactExports.useState(e2), {
      isOpen: h2,
      getMenuProps: g2,
      getInputProps: v2,
      getComboboxProps: L2,
      highlightedIndex: N2,
      getItemProps: E2,
      openMenu: b2,
      closeMenu: B2
    } = useCombobox({
      items: u2,
      inputValue: d2,
      selectedItem: d2,
      itemToString: (R2) => R2 ?? "",
      onSelectedItemChange: ({
        selectedItem: R2
      }) => {
        R2 && t2(R2);
      }
    }), I2 = h2 && u2.length > 0;
    reactExports.useEffect(() => {
      const R2 = d2.toLowerCase().trim();
      if (!R2) {
        m2(e2);
        return;
      }
      m2(e2.filter((T2) => T2.toLowerCase().includes(R2)));
    }, [e2, d2]);
    const [A2, w2] = reactExports.useState(false);
    return /* @__PURE__ */ jsx(Tt, { ...a, focus: A2, disabled: !!(n2 != null && n2.disabled), readOnly: !!(n2 != null && n2.readOnly), value: d2, inputWrapperProps: L2(), renderInputElement: (R2, T2, S2) => /* @__PURE__ */ jsx("input", { ...v2({
      ...n2,
      id: S2,
      onFocus: ($) => {
        var U2;
        (U2 = n2 == null ? void 0 : n2.onFocus) == null || U2.call(n2, $), !$.defaultPrevented && (!h2 && !n2.readOnly && !n2.disabled && b2(), w2(true));
      },
      onBlur: ($) => {
        var U2;
        (U2 = n2 == null ? void 0 : n2.onBlur) == null || U2.call(n2, $), !$.defaultPrevented && w2(false);
      },
      onKeyDown: ($) => {
        var U2;
        if ($.key === "Enter" && s2 && (!I2 || N2 === -1)) {
          const F2 = s2();
          if (F2 != null && F2.closeMenu && B2(), F2 != null && F2.preventDefault) {
            $.preventDefault();
            return;
          }
        }
        (U2 = n2 == null ? void 0 : n2.onKeyDown) == null || U2.call(n2, $), !$.defaultPrevented && (($.key === "ArrowDown" || $.key === "ArrowUp" || $.key === "Home" || $.key === "End") && !I2 && ($.preventDownshiftDefault = true), $.key === "Enter" && !n2.readOnly && !n2.disabled && (h2 ? u2.length && N2 === -1 && ($.preventDefault(), t2(u2[0]), B2()) : ($.preventDefault(), b2())));
      },
      onClick: () => {
        !h2 && !n2.readOnly && !n2.disabled && b2();
      },
      className: T2,
      ref: l2
    }), "data-lpignore": "true" }), suggestionsVisible: I2, suggestions: /* @__PURE__ */ jsx(mo, { isOpen: I2, value: d2, colorize: !!(a.warning || a.error), filteredOptions: u2, highlightedIndex: N2, optionsOverlay: i2, getMenuProps: g2, getItemProps: E2, valuesEqual: (R2, T2) => R2 === T2, renderValueLabel: c2 ?? ((R2) => /* @__PURE__ */ jsx(Fragment, { children: R2 })) }), inlineUi: r2 });
  }
  const $c = "_QrCodeWrapper_7qr4w_1", Ec = "_QrCode_7qr4w_1", $n = {
    QrCodeWrapper: $c,
    QrCode: Ec
  };
  function Pc({
    data: e2,
    inlineUi: t2,
    className: n2
  }) {
    return /* @__PURE__ */ jsx(Tt, { value: e2, readOnly: true, disabled: false, focus: false, inlineUi: t2, className: n2, renderInputElement: (r2, i2, s2) => /* @__PURE__ */ jsx("div", { className: f$1(i2, $n.QrCodeWrapper), children: /* @__PURE__ */ jsx(Mr, { className: $n.QrCode, value: r2, renderAs: "svg", bgColor: "transparent", fgColor: "currentColor", id: s2 }) }) });
  }
  const Ac = "_Button_m6o5o_1 _UnstyledButton_14p2i_205", Mc = "_TextWrapper_m6o5o_12", Oc = "_Text_m6o5o_12", yt = {
    Button: Ac,
    TextWrapper: Mc,
    Text: Oc
  };
  function Fc({
    onClick: e2,
    visible: t2,
    label: n2,
    successLabel: r2,
    className: i2
  }) {
    const [s2, c2] = reactExports.useState(false), a = reactExports.useRef(), l2 = reactExports.useCallback((d2) => {
      window.clearTimeout(a.current), e2(d2), c2(true), a.current = window.setTimeout(() => c2(false), 2e3);
    }, [e2]);
    return !s2 && !t2 ? null : /* @__PURE__ */ jsx("button", { type: "button", className: f$1(yt.Button, i2), onClick: l2, children: /* @__PURE__ */ jsx(sn, { active: s2, className: yt.TextWrapper, children: {
      active: /* @__PURE__ */ jsxs("span", { className: yt.Text, children: [
        /* @__PURE__ */ jsx(SvgB1C9Ac3221E94B98, {}),
        r2
      ] }),
      default: /* @__PURE__ */ jsx("span", { className: yt.Text, children: n2 })
    } }) });
  }
  const Wc = "_PasswordGenerator_fvzwp_1", zc = "_leaked_fvzwp_15", Dc = "_darkMode_fvzwp_19", Uc = "_PasswordInput_fvzwp_27", Vc = "_OptionsGroup_fvzwp_31", kc = "_SwitchGroup_fvzwp_35", Hc = "_OptionSwitch_fvzwp_44", qc = "_Switch_fvzwp_35", jc = "_PasswordInfo_fvzwp_64", Kc = "_StrengthIndication_fvzwp_76", Gc = "_NumberOfCharacters_fvzwp_81", Qc = "_NumberOfCharactersInternal_fvzwp_87", Yc = "_SubmitButton_fvzwp_98", Jc = "_CancelButton_fvzwp_102", G = {
    PasswordGenerator: Wc,
    leaked: zc,
    darkMode: Dc,
    PasswordInput: Uc,
    OptionsGroup: Vc,
    SwitchGroup: kc,
    OptionSwitch: Hc,
    Switch: qc,
    PasswordInfo: jc,
    StrengthIndication: Kc,
    NumberOfCharacters: Gc,
    NumberOfCharactersInternal: Qc,
    SubmitButton: Yc,
    CancelButton: Jc
  };
  function qt({
    close: e2,
    writeToClipboard: t2,
    apply: n2,
    changeSettings: r2,
    editPassword: i2,
    className: s2,
    oldPassword: c2,
    hideButtons: a,
    hideNewPasswordLabel: l2,
    newPasswordLabel: d2,
    oldPasswordLabel: u2,
    settings: m2,
    password: h2,
    strengthIndication: g2,
    error: v2,
    saveSettings: L2,
    savedSettings: N2,
    onNewPasswordBlur: E2,
    leakedPasswordCheckStatus: b2
  }) {
    const B2 = reactExports.useMemo(() => {
      const w2 = N2 ?? ln;
      return w2.length !== m2.length || w2.letters !== m2.letters || w2.numbers !== m2.numbers || w2.special !== m2.special;
    }, [N2, m2]), I2 = Z(), A2 = (b2 == null ? void 0 : b2.status) === "checked" && b2.leakCount > 0;
    return /* @__PURE__ */ jsxs("div", { className: f$1(G.PasswordGenerator, {
      [G.darkMode]: I2 === "dark",
      [G.leaked]: !!A2
    }, s2), children: [
      c2 && /* @__PURE__ */ jsx(En, { element: {
        type: "input",
        props: {
          value: c2,
          disabled: true,
          autoComplete: "off",
          autoCapitalize: "off",
          autoCorrect: "off"
        }
      }, labelInside: true, label: u2 ?? i18n._(
        /*i18n*/
        {
          id: "CqOvzI"
        }
      ), className: G.PasswordInput, writeToClipboard: (w2) => t2(w2, true), monospace: true }),
      /* @__PURE__ */ jsx(En, { element: {
        type: "input",
        props: {
          value: h2,
          onChange: (w2) => i2(w2.target.value),
          autoComplete: "off",
          autoCapitalize: "off",
          autoCorrect: "off",
          onKeyDown: (w2) => {
            !a && w2.key === "Enter" && (n2 == null || n2());
          },
          onBlur: (w2) => E2 == null ? void 0 : E2(w2.currentTarget.value)
        }
      }, labelInside: !l2, label: l2 ? void 0 : d2 ?? i18n._(
        /*i18n*/
        {
          id: "/nT6AE"
        }
      ), className: G.PasswordInput, writeToClipboard: (w2) => t2(w2, true), error: v2 ?? A2, monospace: true }),
      /* @__PURE__ */ jsxs("div", { className: G.PasswordInfo, children: [
        /* @__PURE__ */ jsx(TransitionFade, { children: g2 !== null && /* @__PURE__ */ jsx("span", { className: G.StrengthIndication, children: g2 }) }),
        /* @__PURE__ */ jsx(Fc, { label: i18n._(
          /*i18n*/
          {
            id: "/zWqH6"
          }
        ), successLabel: i18n._(
          /*i18n*/
          {
            id: "idD8Ev"
          }
        ), onClick: () => L2(m2), visible: B2 && vo(m2) })
      ] }),
      /* @__PURE__ */ jsx(Xc, { value: m2, onChange: r2 }),
      !a && /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(co, { element: "button", type: "button", onClick: n2, className: G.SubmitButton, children: /* @__PURE__ */ jsx(Trans, { id: "DB8zMK" }) }),
        /* @__PURE__ */ jsx(be, { type: "button", buttonStyle: "tertiary", size: "small", className: G.CancelButton, onClick: e2, children: /* @__PURE__ */ jsx(Trans, { id: "dEgA5A" }) })
      ] })
    ] });
  }
  const ln = {
    length: 16,
    letters: true,
    numbers: true,
    special: true
  };
  function dn(e2) {
    const t2 = e2 ?? ln;
    return tn(t2.length, t2.letters, t2.letters, t2.numbers, t2.special).value;
  }
  function go({
    password: e2,
    setPassword: t2,
    initialSettings: n2,
    initialGeneratedPassword: r2,
    onSettingsChange: i2
  }) {
    const [s2, c2] = reactExports.useState(n2 ?? ln), [a, l2] = reactExports.useState(r2), u2 = Zc(e2 !== a, s2, e2), m2 = reactExports.useCallback((g2) => {
      if (!Ee$1(s2, g2))
        if (c2(g2), un(g2)) {
          const v2 = tn(g2.length, g2.letters, g2.letters, g2.numbers, g2.special);
          t2(v2.value), l2(v2.value), i2 == null || i2(v2.value);
        } else
          t2(""), l2(void 0), i2 == null || i2("");
    }, [i2, t2, s2]), h2 = reactExports.useCallback((g2, v2) => {
      t2(g2), v2 && l2(g2);
    }, [t2]);
    return {
      changeSettings: m2,
      editPassword: h2,
      password: e2,
      strengthIndication: u2,
      settings: s2
    };
  }
  function yo({
    initialValue: e2,
    initialSettings: t2,
    onChange: n2,
    onSettingsChange: r2
  }) {
    const [i2] = reactExports.useState(() => e2 || dn(t2)), [s2, c2] = reactExports.useState(() => i2), a = reactExports.useCallback((l2) => {
      c2(l2), n2 == null || n2(l2);
    }, [n2]);
    return go({
      password: s2,
      setPassword: a,
      initialSettings: t2,
      initialGeneratedPassword: i2,
      onSettingsChange: r2
    });
  }
  function Xc({
    value: e2,
    onChange: t2
  }) {
    const [r2, i2] = reactExports.useState(`${e2.length}`), s2 = reactExports.useCallback((d2) => {
      const u2 = parseInt(d2, 10), m2 = un({
        ...e2,
        length: u2
      }) && u2 <= 999;
      i2(d2), t2({
        ...e2,
        length: m2 ? u2 : e2.length
      });
    }, [e2, t2]), c2 = reactExports.useCallback(() => {
      const d2 = parseInt(r2, 10), u2 = Math.min(Math.max(bt(e2), isNaN(d2) ? 0 : d2), 999);
      i2(`${u2}`), t2({
        ...e2,
        length: u2
      });
    }, [r2, t2, e2]), a = reactExports.useCallback((d2) => {
      const u2 = (N2, E2) => N2 !== E2, m2 = u2(d2 === "letters", e2.letters), h2 = u2(d2 === "numbers", e2.numbers), g2 = u2(d2 === "special", e2.special), v2 = parseInt(r2, 10), L2 = Math.max(bt({
        ...e2,
        letters: m2,
        numbers: h2,
        special: g2
      }), v2);
      i2(`${L2}`), t2({
        ...e2,
        letters: m2,
        numbers: h2,
        special: g2,
        length: L2
      });
    }, [r2, t2, e2]), l2 = /* @__PURE__ */ jsx(Fragment, { children: "" });
    return /* @__PURE__ */ jsxs("div", { className: G.OptionsGroup, children: [
      /* @__PURE__ */ jsxs("div", { className: G.SwitchGroup, children: [
        /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsxs("label", { className: G.OptionSwitch, children: [
          /* @__PURE__ */ jsx(at, { checked: e2.numbers, onChange: () => a("numbers"), className: G.Switch }),
          "0",
          l2,
          "9"
        ] }) }),
        /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsxs("label", { className: G.OptionSwitch, children: [
          /* @__PURE__ */ jsx(at, { checked: e2.letters, onChange: () => a("letters"), className: G.Switch }),
          "A",
          l2,
          "Z a",
          l2,
          "z"
        ] }) }),
        /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsxs("label", { className: G.OptionSwitch, children: [
          /* @__PURE__ */ jsx(at, { checked: e2.special, onChange: () => a("special"), className: G.Switch }),
          "#@$"
        ] }) })
      ] }),
      /* @__PURE__ */ jsx(J, { element: {
        type: "input",
        props: {
          type: "number",
          value: r2,
          min: bt(e2),
          max: 999,
          onChange: (d2) => s2(d2.target.value),
          onBlur: c2,
          className: G.NumberOfCharactersInternal,
          // show numeric keypad on ios: https://stackoverflow.com/a/27538989
          pattern: "[0-9]*"
        }
      }, label: i18n._(
        /*i18n*/
        {
          id: "NC2AI2"
        }
      ), labelInside: true, className: G.NumberOfCharacters })
    ] });
  }
  function En({
    writeToClipboard: e2,
    labelInside: t2,
    ...n2
  }) {
    const [r2, i2] = reactExports.useState(false), s2 = reactExports.useCallback(() => {
      e2(n2.element.props.value), i2(true);
      const c2 = window.setTimeout(() => i2(false), 1e3);
      return () => window.clearTimeout(c2);
    }, [e2, n2.element.props.value]);
    return /* @__PURE__ */ jsx(J, { ...n2, labelInside: t2, inlineUi: {
      node: /* @__PURE__ */ jsx(ja, { copied: r2, onClick: s2 }),
      width: "3.25rem"
    } });
  }
  function bt(e2) {
    return (e2.numbers ? 1 : 0) + (e2.letters ? 2 : 0) + (e2.special ? 1 : 0);
  }
  function vo(e2) {
    return un(e2) && e2.length >= 12 && e2.letters;
  }
  function un(e2) {
    return e2.length >= bt(e2) && (e2.letters || e2.numbers || e2.special);
  }
  function Zc(e2, t2, n2) {
    return reactExports.useMemo(() => pn(n2) ? i18n._(
      /*i18n*/
      {
        id: "sXULwc"
      }
    ) : !e2 && vo(t2) ? i18n._(
      /*i18n*/
      {
        id: "FLkaGY"
      }
    ) : "", [e2, n2, t2]);
  }
  function pn(e2) {
    return /^\d+$/.exec(e2) !== null;
  }
  const el = "_LoginEdit_yxwvf_1", tl = "_MovedLoginHint_yxwvf_7", nl = "_movedLogin_yxwvf_15", ol = "_Main_yxwvf_15", rl = "_Preform_yxwvf_20", il = "_FormElement_yxwvf_28", sl = "_FormGroup_yxwvf_33", al = "_TotpCustomField_yxwvf_52", cl = "_TotpLabel_yxwvf_58", ll = "_TotpInput_yxwvf_63", dl = "_TotpCodeContainer_yxwvf_68", ul = "_TotpValue_yxwvf_80", pl = "_AndroidAppIcon_yxwvf_93", _l = "_FormElementInfoLine_yxwvf_100", ml = "_RelatedDomains_yxwvf_111", hl = "_AddElement_yxwvf_116 _UnstyledButton_14p2i_205", fl = "_NoteTextarea_yxwvf_132", gl = "_large_yxwvf_135", yl = "_SubmitContainer_yxwvf_139", vl = "_darkMode_yxwvf_159", Cl = "_UnsavedChangesWarning_yxwvf_169", wl = "_SubmitButton_yxwvf_174", bl = "_saved_yxwvf_183", Il = "_danger_yxwvf_191", Sl = "_Info_yxwvf_195", Nl = "_DropdownButton_yxwvf_201", Ll = "_Dropdown_yxwvf_201", xl = "_LabeledSwitch_yxwvf_219", Rl = "_Switch_yxwvf_226", Bl = "_Tags_yxwvf_230", Tl = "_TagsLabel_yxwvf_239", $l = "_TagChip_yxwvf_243", El = "_TagText_yxwvf_254 _UnstyledButton_14p2i_205", Pl = "_readOnly_yxwvf_270", Al = "_TagChipRemove_yxwvf_274 _UnstyledButton_14p2i_205", Ml = "_TagAddButton_yxwvf_294", Ol = "_CreditCardIcon_yxwvf_299", Fl = "_CreditCardExpirationSecurityCode_yxwvf_306", Wl = "_CreditCardSecurityCode_yxwvf_312", zl = "_CreditCardExpiration_yxwvf_306", y = {
    LoginEdit: el,
    MovedLoginHint: tl,
    movedLogin: nl,
    Main: ol,
    Preform: rl,
    FormElement: il,
    FormGroup: sl,
    TotpCustomField: al,
    TotpLabel: cl,
    TotpInput: ll,
    TotpCodeContainer: dl,
    TotpValue: ul,
    AndroidAppIcon: pl,
    FormElementInfoLine: _l,
    RelatedDomains: ml,
    AddElement: hl,
    NoteTextarea: fl,
    large: gl,
    SubmitContainer: yl,
    darkMode: vl,
    UnsavedChangesWarning: Cl,
    SubmitButton: wl,
    saved: bl,
    danger: Il,
    Info: Sl,
    DropdownButton: Nl,
    Dropdown: Ll,
    LabeledSwitch: xl,
    Switch: Rl,
    Tags: Bl,
    TagsLabel: Tl,
    TagChip: $l,
    TagText: El,
    readOnly: Pl,
    TagChipRemove: Al,
    TagAddButton: Ml,
    CreditCardIcon: Ol,
    CreditCardExpirationSecurityCode: Fl,
    CreditCardSecurityCode: Wl,
    CreditCardExpiration: zl
  };
  const Bd = {
    [LoginUiType.creditCard]: Svg3714337086137Eb1,
    [LoginUiType.note]: Svg6018Ebb68Aec24Ff,
    [LoginUiType.login]: Svg071A4A0C17B97D20,
    [LoginUiType.wifi]: SvgB1D9C11A519C251C
  };
  function Io({
    uiType: e2,
    ...t2
  }) {
    const n2 = Bd[e2];
    return n2 ? /* @__PURE__ */ jsx(n2, { ...t2 }) : null;
  }
  const Td = "_UiTypeSelect_11w16_1", $d = "_Button_11w16_8 _UnstyledButton_14p2i_205", Ed = "_active_11w16_24", Pd = "_OverflowDropdownWrapper_11w16_43", Ad = "_dark_11w16_53", Md = "_OverflowDropdown_11w16_43", Od = "_OverflowButton_11w16_64 _UnstyledButton_14p2i_205", xe = {
    UiTypeSelect: Td,
    Button: $d,
    active: Ed,
    OverflowDropdownWrapper: Pd,
    dark: Ad,
    OverflowDropdown: Md,
    OverflowButton: Od
  }, Fn = Object.values(LoginUiType);
  function Fd({
    uiType: e2,
    setUiType: t2
  }) {
    const [n2, {
      width: r2
    }] = he(), [i2, s2] = reactExports.useState(Fn), c2 = Math.max(Math.floor((r2 - 20) / 120), 1);
    reactExports.useEffect(() => {
      i2.indexOf(e2) >= c2 && s2([e2, ...Fn.filter((m2) => m2 !== e2)]);
    }, [i2, e2, c2]);
    const a = i2.slice(0, c2), l2 = i2.slice(c2), d2 = Z();
    return /* @__PURE__ */ jsxs("div", { ref: n2, className: f$1(xe.UiTypeSelect, xe[d2]), role: "listbox", "aria-label": i18n._(
      /*i18n*/
      {
        id: "nNWuY1"
      }
    ), children: [
      a.map((u2) => {
        const m2 = u2 === e2;
        return /* @__PURE__ */ jsxs("button", { type: "button", onClick: () => t2(u2), className: f$1(xe.Button, m2 && xe.active), role: "option", "aria-selected": m2, children: [
          /* @__PURE__ */ jsx(Io, { uiType: u2 }),
          /* @__PURE__ */ jsx("span", { children: U$1(u2) })
        ] }, u2);
      }),
      !!l2.length && /* @__PURE__ */ jsx(Wd, { overflowOptions: l2, setUiType: t2 })
    ] });
  }
  function Wd({
    overflowOptions: e2,
    setUiType: t2
  }) {
    const [n2, r2] = reactExports.useState(false), i2 = reactExports.useCallback(() => r2(false), []), s2 = reactExports.useRef(null);
    return on(s2, i2), /* @__PURE__ */ jsxs("div", { ref: s2, className: xe.OverflowDropdownWrapper, children: [
      /* @__PURE__ */ jsx("button", { type: "button", onClick: () => r2((c2) => !c2), className: xe.Button, children: /* @__PURE__ */ jsx(SvgC4E2C2A224B8321A, { title: i18n._(
        /*i18n*/
        {
          id: "2FYpfJ"
        }
      ) }) }),
      n2 && /* @__PURE__ */ jsx(rn, { className: xe.OverflowDropdown, children: e2.map((c2) => /* @__PURE__ */ jsxs("button", { type: "button", onClick: () => {
        t2(c2), i2();
      }, className: xe.OverflowButton, role: "option", "aria-selected": false, children: [
        /* @__PURE__ */ jsx(Io, { uiType: c2 }),
        /* @__PURE__ */ jsx("span", { children: U$1(c2) })
      ] }, c2)) })
    ] });
  }
  function xt(e2) {
    return Array.isArray(e2) ? e2.length > 0 && e2.some(xt) : typeof e2 == "object" && e2 !== null ? Object.values(e2).some(xt) : !!e2;
  }
  function Le({
    children: e2,
    className: t2,
    ...n2
  }) {
    return we$1.Children.toArray(e2).some((i2) => we$1.isValidElement(i2)) ? /* @__PURE__ */ jsx("fieldset", { className: f$1(y.FormGroup, t2), ...n2, children: e2 }) : null;
  }
  ee(["uiType", "password"])(({
    formik: e2,
    initialPassword: t2,
    newLogin: n2,
    resetNonEmptyFields: r2
  }) => /* @__PURE__ */ jsx(Fd, { uiType: getValueWithPlaceholder(e2.values.uiType), setUiType: (i2) => {
    e2.values.uiType !== i2 && (e2.setFieldValue("uiType", i2), r2(), n2 && (i2 === LoginUiType.login && e2.values.password === "" ? e2.setFieldValue("password", t2) : i2 !== LoginUiType.login && e2.values.password === t2 && e2.setFieldValue("password", "")));
  } }));
  ee(["username"])(({
    formik: e2,
    writeToClipboard: t2,
    readOnly: n2,
    usernameSuggestions: r2
  }) => {
    const {
      action: i2
    } = de(t2, e2.values.username), {
      ref: s2,
      inlineUi: c2
    } = oe([i2]);
    return n2 && !e2.values.username ? null : /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(fo, { inputProps: {
      type: "text",
      ...e2.getFieldProps("username"),
      readOnly: n2,
      ref: s2,
      inputMode: "email",
      autoComplete: "off",
      autoCapitalize: "off",
      autoCorrect: "off"
    }, label: i18n._(
      /*i18n*/
      {
        id: "d3ZUIN"
      }
    ), error: e2.touched.username ? e2.errors.username : void 0, inlineUi: c2, suggestions: r2 ?? [], applySuggestion: (a) => e2.setFieldValue("username", a), optionsOverlay: true }) });
  });
  ee(["wifiSsid"])(({
    formik: e2,
    writeToClipboard: t2,
    readOnly: n2
  }) => {
    const {
      action: r2
    } = de(t2, e2.values.wifiSsid), {
      ref: i2,
      inlineUi: s2
    } = oe([r2]);
    return n2 && !e2.values.wifiSsid ? null : /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { element: {
      type: "input",
      props: {
        type: "text",
        ...e2.getFieldProps("wifiSsid"),
        readOnly: n2,
        ref: i2,
        autoComplete: "off",
        autoCapitalize: "off",
        autoCorrect: "off"
      }
    }, label: i18n._(
      /*i18n*/
      {
        id: "MKYFuo"
      }
    ), error: e2.touched.wifiSsid ? e2.errors.wifiSsid : void 0, inlineUi: s2 }) });
  });
  ee(["uiType", "password"])(({
    formik: e2,
    newLogin: t2,
    writeToClipboard: n2,
    openPasswordGenerator: r2,
    setOpenPasswordGenerator: i2,
    savePasswordGeneratorSettings: s2,
    passwordGeneratorSettings: c2,
    writeAuditlogEvent: a,
    updateLoginStatusChecks: l2,
    enqueueUpdateLoginStatusChecks: d2,
    leakedPasswordCheckStatus: u2,
    permissions: m2,
    passwordNonEmpty: h2
  }) => {
    const g2 = e2.values.uiType, v2 = !m2.editLogin, L2 = reactExports.useMemo(() => !m2.viewSecrets || !(g2 === LoginUiType.login || g2 === LoginUiType.wifi || t2 && xt(e2.values.password) || !t2 && h2) || v2 && !e2.values.password ? "notShown" : t2 && !v2 && e2.values.uiType === LoginUiType.login ? "initialPasswordGenerator" : r2 === "password" && !v2 ? "editPasswordGenerator" : "edit", [e2.values.password, e2.values.uiType, t2, r2, h2, m2.viewSecrets, v2, g2]), N2 = yo({
      initialValue: void 0,
      initialSettings: c2,
      onSettingsChange: l2,
      onChange: d2
    }), E2 = reactExports.useCallback((F2) => {
      e2.setFieldValue("password", F2, true), d2(F2);
    }, [e2, d2]), b2 = go({
      password: e2.values.password,
      setPassword: E2,
      initialSettings: c2,
      initialGeneratedPassword: e2.initialValues.password,
      onSettingsChange: l2
    }), {
      action: B2,
      show: I2,
      setShow: A2
    } = Ke({
      isEmpty: !e2.values.password,
      onShow: () => {
        a == null || a({
          type: AuditlogEventType.LOGIN_R_PASSWORD_SHOW
        });
      }
    }), {
      action: w2
    } = de((F2) => {
      n2(F2, true), a == null || a({
        type: AuditlogEventType.LOGIN_R_PASSWORD_COPY
      });
    }, e2.values.password), R2 = reactExports.useMemo(() => ({
      icon: SvgC707E009107B34Db,
      element: {
        type: "button",
        props: {
          type: "button",
          disabled: r2 !== void 0,
          onClick: () => {
            i2("password"), N2.editPassword(dn(c2), true), a == null || a({
              type: AuditlogEventType.LOGIN_R_PASSWORD_SHOW
            });
          }
        }
      },
      key: "generate",
      label: i18n._(
        /*i18n*/
        {
          id: "19BWU3"
        }
      )
    }), [r2, N2, c2, i2, a]), T2 = reactExports.useMemo(() => v2 ? [w2, B2] : [w2, B2, R2], [w2, R2, v2, B2]), {
      ref: S2,
      inlineUi: $
    } = oe(T2), U2 = reactExports.useRef(false);
    if (reactExports.useEffect(() => {
      U2.current || (U2.current = true, L2 === "edit" ? l2(e2.values.password) : L2 === "initialPasswordGenerator" ? l2(b2.password) : L2 === "editPasswordGenerator" && l2(N2.password));
    }, [e2.values.password, u2, L2, b2.password, N2.password, l2]), L2 === "notShown")
      return null;
    if (L2 === "initialPasswordGenerator")
      return /* @__PURE__ */ jsx(qt, { ...b2, className: y.FormElement, hideButtons: true, writeToClipboard: n2, error: e2.touched.password ? e2.errors.password : void 0, saveSettings: s2, savedSettings: c2, onNewPasswordBlur: l2, leakedPasswordCheckStatus: u2 });
    if (L2 === "editPasswordGenerator")
      return /* @__PURE__ */ jsx(qt, { ...N2, oldPassword: e2.values.password, className: y.FormElement, close: () => {
        i2(void 0), l2(e2.values.password);
      }, apply: () => {
        e2.setFieldValue("password", N2.password), i2(void 0);
      }, writeToClipboard: n2, saveSettings: s2, savedSettings: c2, onNewPasswordBlur: l2, leakedPasswordCheckStatus: u2 });
    if (L2 === "edit") {
      const F2 = (u2 == null ? void 0 : u2.status) === "checked" && u2.leakCount > 0, K2 = e2.getFieldProps("password");
      return /* @__PURE__ */ jsx("div", { className: y.FormElement, children: I2 ? /* @__PURE__ */ jsx(J, { element: {
        type: "input",
        props: {
          type: "text",
          autoComplete: "off",
          autoCapitalize: "off",
          autoCorrect: "off",
          ...K2,
          onBlur: (j) => {
            K2.onBlur(j), l2(j.currentTarget.value);
          },
          onChange: (j) => {
            K2.onChange(j), d2(j.currentTarget.value);
          },
          readOnly: v2,
          ref: S2
        }
      }, label: i18n._(
        /*i18n*/
        {
          id: "8ZsakT"
        }
      ), error: e2.touched.password && e2.errors.password ? e2.errors.password : F2 ? true : void 0, inlineUi: $, monospace: true }) : /* @__PURE__ */ jsx(Qe, { inlineUi: $, ref: S2, onButtonClick: () => A2(true), changed: e2.initialValues.password !== e2.values.password, children: /* @__PURE__ */ jsx(Trans, { id: "7C+Jn5" }) }) });
    }
    assertExhaustive();
  });
  ee(["totp", "totpDigits", "totpAlgorithm", "totpPeriod"])(({
    formik: e2,
    writeToClipboard: t2,
    showTotpTimeOffsetWarning: n2,
    checkTotpTimeOffset: r2,
    writeAuditlogEvent: i2,
    permissions: s2
  }) => {
    const [c2, a] = reactExports.useState(false), l2 = !!e2.values.totp || c2, d2 = reactExports.useMemo(() => !l2 && (!s2.viewSecrets || !s2.editLogin) ? "notShown" : l2 ? s2.viewSecrets ? "edit" : "codeOnly" : "addButton", [s2.editLogin, s2.viewSecrets, l2]), [u2, m2] = reactExports.useState(false), {
      action: h2,
      show: g2,
      setShow: v2
    } = Ke({
      isEmpty: !e2.values.totp,
      onShow: () => {
        i2 == null || i2({
          type: AuditlogEventType.LOGIN_R_TOTP_SECRET_SHOW
        });
      }
    }), {
      action: L2
    } = ut(() => {
      e2.setFieldValue("totp", ""), e2.setFieldValue("totpAlgorithm", void 0), e2.setFieldValue("totpDigits", void 0), e2.setFieldValue("totpPeriod", void 0), a(false);
    }), N2 = reactExports.useMemo(() => {
      const w2 = getValueWithPlaceholder(e2.values.totpAlgorithm);
      return !!(w2 && w2 !== DEFAULT_TOTP_ALGORITHM || e2.values.totpDigits && e2.values.totpDigits !== DEFAULT_TOTP_DIGITS || e2.values.totpPeriod && e2.values.totpPeriod !== DEFAULT_TOTP_PERIOD);
    }, [e2.values.totpAlgorithm, e2.values.totpDigits, e2.values.totpPeriod]), {
      ref: E2,
      inlineUi: b2
    } = oe([h2, L2]), {
      onBlur: B2,
      ...I2
    } = e2.getFieldProps("totp");
    if (d2 === "notShown")
      return null;
    if (d2 === "addButton")
      return /* @__PURE__ */ jsx("div", { className: y.FormElementInfoLine, children: /* @__PURE__ */ jsx("button", { className: y.AddElement, type: "button", onClick: (w2) => {
        w2.stopPropagation(), a(true), m2(true);
      }, children: /* @__PURE__ */ jsx(Trans, { id: "648VR4" }) }) });
    const A2 = /* @__PURE__ */ jsx(ho, { hidden: !n2, className: y.FormElement, recheck: r2 });
    if (d2 === "codeOnly")
      return e2.values.totp && s2.useLogin ? /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsxs("div", { className: f$1(y.FormElement, y.TotpCustomField), children: [
          /* @__PURE__ */ jsx("div", { className: y.TotpLabel, children: /* @__PURE__ */ jsx(Trans, { id: "dME5Kz" }) }),
          /* @__PURE__ */ jsx(Kt, { writeToClipboard: t2, totpSecret: e2.values.totp ?? "", totpAlgorithm: getValueWithPlaceholder(e2.values.totpAlgorithm), totpDigits: e2.values.totpDigits, totpPeriod: e2.values.totpPeriod })
        ] }),
        A2
      ] }) : null;
    if (d2 === "edit")
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsxs("div", { className: f$1(y.FormElement, y.TotpCustomField), children: [
          g2 ? /* @__PURE__ */ jsx(J, { className: y.TotpInput, element: {
            type: "input",
            props: {
              type: "text",
              autoComplete: "off",
              autoFocus: u2,
              ...I2,
              readOnly: !s2.editLogin,
              ref: E2,
              onBlur: (w2) => {
                if (B2(w2), !s2.editLogin)
                  return;
                const R2 = getTotpParametersFromOtpauthUrl(w2.currentTarget.value);
                if (R2) {
                  const T2 = normalizeTotpSecret(R2.secret);
                  e2.setFieldValue("totp", T2), e2.setFieldValue("totpAlgorithm", R2.algorithm), e2.setFieldValue("totpDigits", R2.digits), e2.setFieldValue("totpPeriod", R2.period);
                } else {
                  const T2 = normalizeTotpSecret(w2.currentTarget.value);
                  e2.setFieldValue("totp", T2);
                }
                m2(false);
              }
            }
          }, label: i18n._(
            /*i18n*/
            {
              id: "g4uCmi"
            }
          ), error: e2.touched.totp ? e2.errors.totp : void 0, inlineUi: b2, monospace: true }) : /* @__PURE__ */ jsx(Qe, { className: y.TotpInput, inlineUi: b2, ref: E2, onButtonClick: () => v2(true), changed: e2.initialValues.totp !== e2.values.totp, children: /* @__PURE__ */ jsx(Trans, { id: "nld5XV" }) }),
          /* @__PURE__ */ jsx(Kt, { writeToClipboard: t2, totpSecret: e2.values.totp ?? "", totpAlgorithm: getValueWithPlaceholder(e2.values.totpAlgorithm), totpDigits: e2.values.totpDigits, totpPeriod: e2.values.totpPeriod })
        ] }),
        N2 && /* @__PURE__ */ jsx("div", { className: y.FormElementInfoLine, children: /* @__PURE__ */ jsx(Trans, { id: "ESK+7k" }) }),
        A2
      ] });
    assertExhaustive();
  });
  ee(["title"])(({
    formik: e2,
    readOnly: t2
  }) => t2 && !e2.values.title ? null : /* @__PURE__ */ jsx(J, { className: y.FormElement, label: i18n._(
    /*i18n*/
    {
      id: "pfa8F0"
    }
  ), error: e2.touched.title ? e2.errors.title : void 0, element: {
    type: "input",
    props: {
      type: "text",
      autoComplete: "off",
      ...e2.getFieldProps("title"),
      onBlur: (n2) => {
        e2.getFieldProps("title").onBlur(n2), e2.setFieldValue("title", n2.currentTarget.value.trim());
      },
      readOnly: t2
    }
  } }));
  ee(["tags"])(({
    formik: e2,
    tagSuggestions: t2,
    readOnly: n2,
    onTagClick: r2
  }) => {
    const i2 = e2.values.tags, [s2, c2] = reactExports.useState(""), a = reactExports.useMemo(() => (t2 ?? []).filter((u2) => !(i2 != null && i2.includes(u2))), [i2, t2]), [l2, d2] = reactExports.useState();
    return /* @__PURE__ */ jsx(FieldArray, { name: "tags", render: (u2) => {
      function m2(h2) {
        const g2 = normalizeTag(h2);
        if (!g2.length) {
          d2("noTagEntered");
          return;
        }
        if (i2 != null && i2.includes(g2)) {
          d2("alreadyExists");
          return;
        }
        u2.push(g2), c2("");
      }
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        !!(i2 != null && i2.length) && /* @__PURE__ */ jsxs("div", { className: f$1(y.FormElement, y.Tags), children: [
          /* @__PURE__ */ jsx("strong", { className: y.TagsLabel, children: /* @__PURE__ */ jsx(Trans, { id: "hko/4A" }) }),
          i2.map((h2, g2) => (
            // Using key as index here to avoid glitch rendering for duplicated tags. We
            // usually prevent duplicated tags, but they can slip through anyways (e.g. from
            // imports) and lead to very glitchy behavior when their name is used as key.
            /* @__PURE__ */ jsxs("span", { className: f$1(y.TagChip, n2 && y.readOnly), title: h2, children: [
              r2 ? /* @__PURE__ */ jsx("button", { type: "button", onClick: () => r2(h2), className: y.TagText, children: h2 }) : /* @__PURE__ */ jsx("span", { className: y.TagText, children: h2 }),
              !n2 && /* @__PURE__ */ jsx(uo, { element: "button", tooltip: i18n._(
                /*i18n*/
                {
                  id: "/7FPnu"
                }
              ), type: "button", onClick: () => u2.remove(g2), className: y.TagChipRemove, children: /* @__PURE__ */ jsx(Svg85901Eed410D7B8F, {}) })
            ] }, g2)
          ))
        ] }),
        !n2 && /* @__PURE__ */ jsx(fo, { className: y.FormElement, inputProps: {
          type: "text",
          value: s2,
          onChange: (h2) => {
            c2(h2.currentTarget.value), d2(void 0);
          },
          onBlur: () => d2(void 0)
        }, suggestions: a, label: i18n._(
          /*i18n*/
          {
            id: "lyqwgn"
          }
        ), applySuggestion: m2, onInputEnter: () => s2 ? (m2(s2), {
          preventDefault: true,
          closeMenu: true
        }) : {
          preventDefault: true
        }, inlineUi: s2 ? {
          node: /* @__PURE__ */ jsx(Ge, { type: "button", onClick: () => m2(s2), className: y.TagAddButton, children: /* @__PURE__ */ jsx(Trans, { id: "m16xKo" }) }),
          width: "6rem"
        } : void 0, error: l2 === "alreadyExists" ? i18n._(
          /*i18n*/
          {
            id: "oYNiCo"
          }
        ) : l2 === "noTagEntered" ? i18n._(
          /*i18n*/
          {
            id: "XdSz+P"
          }
        ) : void 0, optionsOverlay: true })
      ] });
    } });
  });
  ee(["note", "uiType"])(({
    formik: e2,
    readOnly: t2
  }) => t2 && !e2.values.note ? null : /* @__PURE__ */ jsx(J, { className: y.FormElement, element: {
    type: "autosizeTextarea",
    props: {
      ...e2.getFieldProps("note"),
      readOnly: t2,
      className: f$1(y.NoteTextarea, e2.values.uiType === LoginUiType.note && y.large)
    }
  }, label: i18n._(
    /*i18n*/
    {
      id: "KiJn9B"
    }
  ), error: e2.touched.note ? e2.errors.note : void 0 }));
  ee(["androidApps"])(({
    formik: e2,
    availableAndroidApps: t2,
    readOnly: n2
  }) => t2 && !n2 ? /* @__PURE__ */ jsx(tu, { formik: e2, availableAndroidApps: t2 }) : /* @__PURE__ */ jsx(FieldArray, { name: "androidApps", render: (r2) => (e2.values.androidApps ?? []).filter((i2) => i2 !== null).map(({
    displayName: i2,
    iconDataUri: s2
  }, c2) => /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { element: {
    type: "input",
    props: {
      type: "text",
      readOnly: true,
      value: i2
    }
  }, label: i18n._(
    /*i18n*/
    {
      id: "zVJj0U"
    }
  ), icon: So(s2), inlineUi: an({
    actions: n2 ? [] : [ut(() => r2.remove(c2)).action]
  }) }) }, c2)) }));
  function tu({
    formik: e2,
    availableAndroidApps: t2
  }) {
    const n2 = e2.values.androidApps ?? [];
    let r2;
    n2.length ? r2 = n2 : r2 = [null];
    const [i2, s2] = reactExports.useState(), c2 = r2.length === 1 && r2[0] === null;
    return /* @__PURE__ */ jsx(FieldArray, { name: "androidApps", render: (a) => /* @__PURE__ */ jsxs(Fragment, { children: [
      r2.map((l2, d2) => {
        const u2 = `androidApps.${d2}`, m2 = e2.getFieldProps(u2).value;
        return /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(Ba, { clearable: false, options: t2, label: i18n._(
          /*i18n*/
          {
            id: "zVJj0U"
          }
        ), getValueLabel: ({
          displayName: h2
        }) => h2, getValueIconNode: ({
          iconDataUri: h2
        }) => So(h2), valuesEqual: ({
          appId: h2
        }, {
          appId: g2
        }) => h2 === g2, noMatchingOptionsText: i18n._(
          /*i18n*/
          {
            id: "nr1I0W"
          }
        ), value: m2, onChange: (h2) => {
          d2 >= n2.length ? a.push(h2) : e2.setFieldValue(u2, h2 ?? null, false), s2(void 0);
        }, autoFocus: d2 === i2, inlineUi: an({
          actions: c2 ? [] : [ut(() => a.remove(d2)).action]
        }) }, "select") }, d2);
      }),
      /* @__PURE__ */ jsx("div", { className: f$1(y.FormElementInfoLine), children: /* @__PURE__ */ jsx("button", { className: y.AddElement, type: "button", onClick: () => {
        s2(r2.length ?? 0), n2.length === 0 && a.push(null), a.push(null);
      }, children: /* @__PURE__ */ jsx(Trans, { id: "iOiHwJ" }) }) })
    ] }) });
  }
  function So(e2) {
    return e2 != null && e2.startsWith("data:") ? /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx("img", { src: e2, alt: "", className: y.AndroidAppIcon }) }) : void 0;
  }
  ee(["websites", "websiteAttributes"])(({
    formik: e2,
    writeToClipboard: t2,
    readOnly: n2,
    focusedWebsiteInputRef: r2
  }) => {
    const i2 = e2.values.websites ?? [];
    let s2;
    i2.length ? s2 = i2 : s2 = [null];
    const c2 = s2.length === 1 && (s2[0] === null || normalizeWebsitePattern(s2[0]) === ""), [a, l2] = reactExports.useState();
    return n2 && !s2.some((d2) => !!d2) ? null : /* @__PURE__ */ jsx(FieldArray, { name: "websites", render: (d2) => /* @__PURE__ */ jsx(Fragment, { children: s2.map((u2, m2) => /* @__PURE__ */ jsx(ou, { formik: e2, index: m2, readOnly: n2, autoFocus: a === m2, writeToClipboard: t2, hideDelete: c2, deleteWebsite: () => {
      d2.remove(m2);
    }, clearAutoFocus: () => l2(void 0), focusedWebsiteInputRef: r2, infoLineButton: !n2 && m2 === s2.length - 1 ? /* @__PURE__ */ jsx("button", { className: y.AddElement, type: "button", onClick: () => {
      l2(e2.values.websites.length), i2.length === 0 && d2.push(null), d2.push(null);
    }, children: /* @__PURE__ */ jsx(Trans, { id: "iOiHwJ" }) }) : void 0 }, m2)) }) });
  });
  function ou({
    formik: e2,
    index: t2,
    writeToClipboard: n2,
    deleteWebsite: r2,
    readOnly: i2,
    hideDelete: s2,
    autoFocus: c2,
    clearAutoFocus: a,
    focusedWebsiteInputRef: l2,
    infoLineButton: d2
  }) {
    var A2;
    const u2 = `websites.${t2}`, {
      onBlur: m2,
      ...h2
    } = e2.getFieldProps(u2), {
      action: g2
    } = de(n2, (h2 == null ? void 0 : h2.value) ?? ""), v2 = (A2 = e2.values.websiteAttributes) == null ? void 0 : A2[h2.value], L2 = h2.value ? {
      icon: SvgC8F08Adbe83Afe3E,
      key: "openinbrowser",
      label: i18n._(
        /*i18n*/
        {
          id: "yxTdsJ"
        }
      ),
      element: {
        type: "a",
        props: {
          href: `${getValueWithPlaceholder(v2 == null ? void 0 : v2.protocol) ?? "http"}://${h2.value}`,
          target: "_blank",
          rel: "noopener noreferrer"
        }
      }
    } : void 0, {
      ref: N2,
      inlineUi: E2
    } = oe([L2 ?? [], g2, !i2 && !s2 ? ut(r2).action : []].flat()), [b2, B2] = reactExports.useState(), I2 = reactExports.useMemo(() => {
      let w2 = h2.value;
      /^([a-z]+:)?\/\//.exec(w2) || (w2 = `https://${w2}`);
      const T2 = f$3(w2);
      return T2 ? getRelatedDomains(T2.psl.domain ?? T2.url.hostname) : void 0;
    }, [h2.value]);
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { label: i18n._(
        /*i18n*/
        {
          id: "On0aF2"
        }
      ), element: {
        type: "input",
        props: {
          type: "text",
          ...h2,
          autoFocus: c2,
          readOnly: i2,
          inputMode: "url",
          autoCapitalize: "off",
          autoCorrect: "off",
          onFocus: () => {
            l2.current = {
              index: t2,
              oldNormalizedValue: h2.value
            };
          },
          onBlur: (w2) => {
            if (m2(w2), i2)
              return;
            a();
            const {
              websites: R2,
              websiteAttributes: T2
            } = Lo(e2.values, l2.current);
            l2.current = void 0, e2.setFieldValue("websites", R2), e2.setFieldValue("websiteAttributes", T2);
          },
          ref: N2
        }
      }, inlineUi: E2 }) }),
      (I2 || d2) && /* @__PURE__ */ jsxs("div", { className: y.FormElementInfoLine, children: [
        I2 && /* @__PURE__ */ jsx("span", { className: y.RelatedDomains, children: b2 === h2.value || I2.length < 4 ? I2.length === 1 ? /* @__PURE__ */ jsx(Trans, { id: "ai680t", values: {
          0: I2[0]
        } }) : /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Trans, { id: "y4UGV2", values: {
            0: I2.slice(0, I2.length - 1).join(", "),
            1: I2[I2.length - 1]
          } }),
          I2.length >= 4 && /* @__PURE__ */ jsxs(Fragment, { children: [
            " ",
            /* @__PURE__ */ jsx(Ge, { type: "button", onClick: () => {
              B2(void 0);
            }, children: /* @__PURE__ */ jsx(Trans, { id: "vLyv1R" }) })
          ] })
        ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Trans, { id: "czBEzZ", values: {
            0: I2.length
          } }),
          " ",
          /* @__PURE__ */ jsx(Ge, { type: "button", onClick: () => {
            B2(h2.value);
          }, children: /* @__PURE__ */ jsx(Trans, { id: "8vETh9" }) })
        ] }) }),
        d2
      ] })
    ] });
  }
  ee(["customFields", "totp"])(({
    formik: e2,
    writeToClipboard: t2,
    readOnly: n2,
    hideSecrets: r2,
    savePasswordGeneratorSettings: i2,
    passwordGeneratorSettings: s2,
    openPasswordGenerator: c2,
    setOpenPasswordGenerator: a,
    showTotpTimeOffsetWarning: l2,
    checkTotpTimeOffset: d2,
    writeAuditlogEvent: u2
  }) => {
    const [m2, h2] = reactExports.useState(false), [g2, v2] = reactExports.useState(), {
      customFields: L2
    } = e2.values, N2 = e2.values.totp ? void 0 : filterUnprotectedCustomFields(L2).totpField;
    return /* @__PURE__ */ jsx(FieldArray, { name: "customFields", render: (E2) => /* @__PURE__ */ jsxs(Fragment, { children: [
      L2.map((b2, B2) => {
        if (b2.protected && r2)
          return null;
        const I2 = `customFields.${B2}.value`, {
          onBlur: A2,
          ...w2
        } = e2.getFieldProps(I2), R2 = {
          ...w2,
          onBlur: (S2) => {
            v2(void 0), A2(S2);
          },
          autoFocus: B2 === g2,
          readOnly: n2
        }, T2 = e2.initialValues.customFields[B2];
        return N2 && b2 === N2 ? /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsxs("div", { className: f$1(y.FormElement, y.TotpCustomField), children: [
            /* @__PURE__ */ jsx(Wn, { className: y.TotpInput, element: {
              type: "input",
              props: {
                type: "text",
                ...R2,
                onBlur: (S2) => {
                  if (R2.onBlur(S2), n2)
                    return;
                  const $ = normalizeTotpSecret(S2.currentTarget.value);
                  e2.setFieldValue(R2.name, $);
                }
              }
            }, id: b2.id, label: b2.name, fieldName: b2.name, deleteCustomField: () => E2.remove(B2), writeToClipboard: t2, protected: b2.protected, readOnly: n2, initialValue: T2 == null ? void 0 : T2.value, writeAuditlogEvent: u2 }),
            /* @__PURE__ */ jsx(Kt, { writeToClipboard: t2, totpSecret: b2.value })
          ] }, B2),
          /* @__PURE__ */ jsx(ho, { hidden: !l2, className: y.FormElement, recheck: d2 })
        ] }) : /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(Wn, { element: {
          type: "input",
          props: {
            type: "text",
            ...R2
          }
        }, id: b2.id, label: b2.name, fieldName: b2.name, deleteCustomField: () => E2.remove(B2), writeToClipboard: t2, protected: b2.protected, readOnly: n2, passwordGenerator: {
          savePasswordGeneratorSettings: i2,
          passwordGeneratorSettings: s2,
          setFieldValue: (S2) => {
            e2.setFieldValue(I2, S2, true);
          },
          openPasswordGenerator: c2,
          setOpenPasswordGenerator: a
        }, initialValue: T2 == null ? void 0 : T2.value, writeAuditlogEvent: u2 }) }, B2);
      }),
      !n2 && /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("div", { className: y.FormElementInfoLine, children: /* @__PURE__ */ jsxs("button", { className: y.AddElement, type: "button", onClick: (b2) => {
          b2.stopPropagation(), h2(!m2);
        }, children: [
          /* @__PURE__ */ jsx(Trans, { id: "CgUQh7" }),
          " ",
          /* @__PURE__ */ jsx(cn, { direction: "down" })
        ] }) }),
        /* @__PURE__ */ jsx("div", { className: y.DropdownButton, children: /* @__PURE__ */ jsx(su, { visible: m2, add: (b2) => {
          v2(e2.values.customFields.length), E2.push(b2), h2(false);
        }, close: () => h2(false) }) })
      ] })
    ] }) });
  });
  function Wn({
    writeToClipboard: e2,
    deleteCustomField: t2,
    protected: n2,
    readOnly: r2,
    passwordGenerator: i2,
    id: s2,
    fieldName: c2,
    writeAuditlogEvent: a,
    element: l2,
    initialValue: d2,
    ...u2
  }) {
    var A2;
    const m2 = ((A2 = l2 == null ? void 0 : l2.props) == null ? void 0 : A2.value) ?? "", {
      action: h2
    } = de((w2) => {
      e2(w2, n2), a == null || a({
        type: AuditlogEventType.LOGIN_R_CUSTOM_FIELD_COPY,
        customFieldId: s2
      });
    }, m2), {
      action: g2
    } = ut(t2), {
      action: v2,
      show: L2,
      setShow: N2
    } = Ke({
      isEmpty: !m2,
      onShow: () => {
        a == null || a({
          type: AuditlogEventType.LOGIN_R_CUSTOM_FIELD_SHOW,
          customFieldId: s2
        });
      }
    }), E2 = {
      icon: SvgC707E009107B34Db,
      element: {
        type: "button",
        props: {
          type: "button",
          disabled: (i2 == null ? void 0 : i2.openPasswordGenerator) !== void 0,
          onClick: () => {
            a == null || a({
              type: AuditlogEventType.LOGIN_R_PASSWORD_SHOW,
              customFieldId: s2
            }), i2 == null || i2.setOpenPasswordGenerator(s2);
          }
        }
      },
      key: "generate",
      label: i18n._(
        /*i18n*/
        {
          id: "19BWU3"
        }
      )
    };
    let b2 = [h2];
    n2 && (b2 = [...b2, v2], i2 && !r2 && (b2 = [...b2, E2])), r2 || (b2 = [...b2, g2]);
    const {
      ref: B2,
      inlineUi: I2
    } = oe(b2);
    return !r2 && i2 && i2.openPasswordGenerator === s2 ? /* @__PURE__ */ jsx(iu, { oldPassword: m2, writeToClipboard: e2, fieldName: c2, ...i2 }) : n2 && !L2 ? /* @__PURE__ */ jsx(Qe, { inlineUi: I2, ref: B2, onButtonClick: () => N2(true), className: u2.className, changed: d2 !== m2, children: /* @__PURE__ */ jsx(Trans, { id: "h8lzfw", values: {
      0: u2.label
    } }) }) : /* @__PURE__ */ jsx(J, { ...u2, element: {
      ...l2,
      props: {
        ...l2.props,
        type: "text",
        ref: B2
      }
    }, inlineUi: I2, monospace: n2 });
  }
  function iu({
    oldPassword: e2,
    setOpenPasswordGenerator: t2,
    writeToClipboard: n2,
    savePasswordGeneratorSettings: r2,
    passwordGeneratorSettings: i2,
    setFieldValue: s2,
    fieldName: c2
  }) {
    const a = yo({
      initialValue: void 0,
      initialSettings: i2 ?? null,
      onChange: void 0
    });
    return /* @__PURE__ */ jsx(qt, { ...a, oldPassword: e2, className: y.FormElement, close: () => t2(void 0), apply: () => {
      s2(a.password), t2(void 0);
    }, writeToClipboard: n2, saveSettings: r2, savedSettings: i2, oldPasswordLabel: i18n._(
      /*i18n*/
      {
        id: "Gv57aB",
        values: {
          fieldName: c2
        }
      }
    ), newPasswordLabel: c2 });
  }
  function Kt({
    writeToClipboard: e2,
    totpSecret: t2,
    totpAlgorithm: n2,
    totpDigits: r2,
    totpPeriod: i2
  }) {
    const {
      totp: s2,
      totpPercent: c2,
      totpDigits: a
    } = Li(t2, n2, r2, i2), {
      action: l2
    } = de(e2, s2);
    return /* @__PURE__ */ jsxs("div", { className: y.TotpCodeContainer, children: [
      /* @__PURE__ */ jsx("div", { className: y.TotpValue, children: s2 ? /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("span", { children: s2.substring(0, a / 2) }),
        /* @__PURE__ */ jsx("span", { children: s2.substring(a / 2) })
      ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("span", { children: "???" }),
        /* @__PURE__ */ jsx("span", { children: "???" })
      ] }) }),
      c2 && /* @__PURE__ */ jsx(Da, { percent: c2 }),
      /* @__PURE__ */ jsx(po, { actions: [l2] })
    ] });
  }
  function su({
    visible: e2,
    add: t2,
    close: n2
  }) {
    const r2 = reactExports.useRef(null);
    return on(r2, n2), e2 ? /* @__PURE__ */ jsx(Formik, { initialValues: {
      name: "",
      protected: false,
      value: ""
    }, onSubmit: (s2) => {
      s2.protected ? t2({
        ...s2,
        protected: true,
        id: newUuid$1()
      }) : t2({
        ...s2,
        protected: false,
        id: newUuid$1()
      });
    }, validate: (s2) => {
      let c2 = {};
      return s2.name || (c2 = {
        ...c2,
        name: i18n._(
          /*i18n*/
          {
            id: "1xTnZJ"
          }
        )
      }), c2;
    }, children: (s2) => {
      const {
        onBlur: c2,
        ...a
      } = s2.getFieldProps("name");
      return /* @__PURE__ */ jsxs(rn, { element: "div", className: y.Dropdown, ref: r2, onKeyDown: (l2) => {
        l2.key === "Enter" && (l2.preventDefault(), s2.handleSubmit());
      }, children: [
        /* @__PURE__ */ jsx(J, { label: i18n._(
          /*i18n*/
          {
            id: "6YtxFj"
          }
        ), element: {
          type: "input",
          props: {
            type: "text",
            autoComplete: "off",
            ...a,
            onKeyDown: () => s2.setFieldTouched("name"),
            autoFocus: true
          }
        }, className: y.FormElement, error: s2.touched.name ? s2.errors.name : void 0 }),
        /* @__PURE__ */ jsxs("label", { className: f$1(y.FormElement, y.LabeledSwitch), children: [
          /* @__PURE__ */ jsx(at, { className: y.Switch, ...s2.getFieldProps({
            name: "protected",
            type: "checkbox"
          }) }),
          /* @__PURE__ */ jsx(Trans, { id: "g9eOjA" })
        ] }),
        /* @__PURE__ */ jsx(be, { buttonStyle: "primary", element: "button", type: "button", onClick: () => {
          s2.submitForm().catch(trackError);
        }, className: f$1(y.FormElement), children: /* @__PURE__ */ jsx(Trans, { id: "m16xKo" }) })
      ] });
    } }) : /* @__PURE__ */ jsx(Fragment, {});
  }
  const au = {
    [dist.creditCardType.types.AMERICAN_EXPRESS]: SvgEa285Cf2Cf54Ed10,
    [dist.creditCardType.types.DINERS_CLUB]: Svg4Bda20Dc465Fd5E8,
    [dist.creditCardType.types.DISCOVER]: Svg96E6C7C43A915C12,
    [dist.creditCardType.types.ELO]: Svg4Cd29C4C3E16Daa4,
    [dist.creditCardType.types.HIPERCARD]: SvgC919F85Dd32Ab2Ca,
    [dist.creditCardType.types.HIPER]: SvgDf6706Eae6F7E6B2,
    [dist.creditCardType.types.JCB]: SvgBc16C58Eb1De638B,
    [dist.creditCardType.types.MAESTRO]: Svg75Bb17D442A9Aa5E,
    [dist.creditCardType.types.MASTERCARD]: SvgF1A233802Cf96Ae4,
    [dist.creditCardType.types.UNIONPAY]: SvgD40Fa15A82Ff4Ca7,
    [dist.creditCardType.types.VISA]: Svg223Ca525897C672A
  };
  ee(["creditCard", "uiType"])(({
    formik: e2,
    readOnly: t2,
    writeToClipboard: n2,
    hideSecrets: r2,
    writeAuditlogEvent: i2,
    nonEmptyFields: s2
  }) => {
    var k2, Ie2, Je2, W2, Re2, Ae2, Xe2, pe2, pt, _t, Ze2, mt, Me2, et, tt, Oe2, ge2, te2, Fe2, nt, _e, mn, hn;
    const {
      warnings: c2,
      card: a
    } = lu(e2), l2 = reactExports.useMemo(() => a ? au[a == null ? void 0 : a.type] ?? SvgAcb05338A032C728 : SvgAcb05338A032C728, [a]), {
      action: d2
    } = de(n2, (Ie2 = (k2 = e2.values.creditCard) == null ? void 0 : k2.number) == null ? void 0 : Ie2.replaceAll(" ", "")), {
      ref: u2,
      inlineUi: m2
    } = oe([d2]), {
      action: h2
    } = de(n2, (Je2 = e2.values.creditCard) == null ? void 0 : Je2.cardHolder), {
      ref: g2,
      inlineUi: v2
    } = oe([h2]), {
      action: L2
    } = de(n2, (W2 = e2.values.creditCard) == null ? void 0 : W2.expiration), {
      ref: N2,
      inlineUi: E2
    } = oe([L2]), {
      action: b2,
      show: B2,
      setShow: I2
    } = Ke({
      isEmpty: !((Re2 = e2.values.creditCard) != null && Re2.securityCode),
      onShow: () => i2 == null ? void 0 : i2({
        type: AuditlogEventType.CREDIT_CARD_R_SECURITY_CODE_SHOW
      })
    }), {
      action: A2
    } = de((Q2) => {
      n2(Q2, true), i2 == null || i2({
        type: AuditlogEventType.CREDIT_CARD_R_SECURITY_CODE_COPY
      });
    }, (Ae2 = e2.values.creditCard) == null ? void 0 : Ae2.securityCode), {
      ref: w2,
      inlineUi: R2
    } = oe([A2, b2]), {
      action: T2,
      show: S2,
      setShow: $
    } = Ke({
      isEmpty: !((Xe2 = e2.values.creditCard) != null && Xe2.pin),
      onShow: () => i2 == null ? void 0 : i2({
        type: AuditlogEventType.CREDIT_CARD_R_PIN_SHOW
      })
    }), {
      action: U2
    } = de((Q2) => {
      n2(Q2, true), i2 == null || i2({
        type: AuditlogEventType.CREDIT_CARD_R_PIN_COPY
      });
    }, (pe2 = e2.values.creditCard) == null ? void 0 : pe2.pin), F2 = reactExports.useMemo(() => ({
      icon: SvgC707E009107B34Db,
      element: {
        type: "button",
        props: {
          type: "button",
          disabled: !S2,
          onClick: () => {
            const {
              value: Q2
            } = tn(4, false, false, true, false);
            e2.setFieldValue("creditCard.pin", Q2);
          }
        }
      },
      key: "generate",
      label: i18n._(
        /*i18n*/
        {
          id: "YU1MkM"
        }
      )
    }), [e2, S2]), K2 = reactExports.useMemo(() => {
      var Q2;
      return (Q2 = e2.values.creditCard) != null && Q2.pin ? [U2, T2] : [U2, T2, F2];
    }, [U2, (pt = e2.values.creditCard) == null ? void 0 : pt.pin, F2, T2]), {
      ref: j,
      inlineUi: ie2
    } = oe(K2), ue2 = e2.values.uiType === "creditCard", Pe2 = a == null ? void 0 : a.code.name;
    return /* @__PURE__ */ jsxs(Le, { children: [
      (ue2 || s2.number) && /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { className: y.FormElement, label: i18n._(
        /*i18n*/
        {
          id: "xHIEQ5"
        }
      ), icon: /* @__PURE__ */ jsx(l2, { title: (a == null ? void 0 : a.niceType) ?? i18n._(
        /*i18n*/
        {
          id: "ooW934"
        }
      ), className: y.CreditCardIcon }), error: (_t = e2.touched.creditCard) != null && _t.number ? (Ze2 = e2.errors.creditCard) == null ? void 0 : Ze2.number : void 0, warning: c2.number, element: {
        type: "input",
        props: {
          type: "text",
          autoComplete: "off",
          ...e2.getFieldProps("creditCard.number"),
          onBlur: (Q2) => {
            if (e2.getFieldProps("creditCard.number").onBlur(Q2), t2)
              return;
            const Et = normalizeCreditCardNumber(Q2.currentTarget.value);
            e2.setFieldValue("creditCard.number", Et.number), e2.setFieldValue("creditCard.displayMaskedNumber", Et.displayMaskedNumber), e2.setFieldValue("creditCard.displayType", Et.displayType);
          },
          readOnly: t2,
          ref: u2
        }
      }, inlineUi: m2 }) }),
      (ue2 || s2.cardHolder) && /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { className: y.FormElement, label: i18n._(
        /*i18n*/
        {
          id: "bMFXRG"
        }
      ), error: (mt = e2.touched.creditCard) != null && mt.cardHolder ? (Me2 = e2.errors.creditCard) == null ? void 0 : Me2.cardHolder : void 0, element: {
        type: "input",
        props: {
          type: "text",
          autoComplete: "off",
          ...e2.getFieldProps("creditCard.cardHolder"),
          onBlur: (Q2) => {
            e2.getFieldProps("creditCard.cardHolder").onBlur(Q2), !t2 && e2.setFieldValue("creditCard.cardHolder", Q2.currentTarget.value.trim());
          },
          readOnly: t2,
          ref: g2
        }
      }, inlineUi: v2 }) }),
      (ue2 || s2.expiration || s2.securityCode) && /* @__PURE__ */ jsxs("div", { className: f$1(y.FormElement, y.CreditCardExpirationSecurityCode), children: [
        (ue2 || s2.expiration) && /* @__PURE__ */ jsx(J, { label: i18n._(
          /*i18n*/
          {
            id: "2Pjc5z"
          }
        ), className: y.CreditCardExpiration, error: (et = e2.touched.creditCard) != null && et.expiration ? (tt = e2.errors.creditCard) == null ? void 0 : tt.expiration : void 0, warning: c2.expiration, element: {
          type: "input",
          props: {
            type: "text",
            autoComplete: "off",
            ...e2.getFieldProps("creditCard.expiration"),
            onBlur: (Q2) => {
              e2.getFieldProps("creditCard.expiration").onBlur(Q2), !t2 && e2.setFieldValue("creditCard.expiration", normalizeCreditCardExpiration(Q2.currentTarget.value));
            },
            readOnly: t2,
            ref: N2
          }
        }, inlineUi: E2 }),
        !r2 && (ue2 || s2.securityCode) && (B2 ? /* @__PURE__ */ jsx(J, { label: a ? i18n._(
          /*i18n*/
          {
            id: "rmoyE2",
            values: {
              0: a.code.size,
              cardCodeName: Pe2
            }
          }
        ) : i18n._(
          /*i18n*/
          {
            id: "wLmRnI"
          }
        ), className: y.CreditCardSecurityCode, error: (Oe2 = e2.touched.creditCard) != null && Oe2.securityCode ? (ge2 = e2.errors.creditCard) == null ? void 0 : ge2.securityCode : void 0, warning: c2.securityCode, element: {
          type: "input",
          props: {
            type: "text",
            autoComplete: "off",
            ...e2.getFieldProps("creditCard.securityCode"),
            readOnly: t2,
            ref: w2
          }
        }, inlineUi: R2, monospace: true }) : /* @__PURE__ */ jsx(Qe, { inlineUi: R2, ref: w2, onButtonClick: () => I2(true), className: y.CreditCardSecurityCode, changed: ((te2 = e2.initialValues.creditCard) == null ? void 0 : te2.securityCode) !== ((Fe2 = e2.values.creditCard) == null ? void 0 : Fe2.securityCode), children: /* @__PURE__ */ jsx(Trans, { id: "BqrHbB" }) }))
      ] }),
      !r2 && (ue2 || s2.pin) && /* @__PURE__ */ jsx("div", { className: y.FormElement, children: S2 ? /* @__PURE__ */ jsx(J, { label: i18n._(
        /*i18n*/
        {
          id: "sXULwc"
        }
      ), error: (nt = e2.touched.creditCard) != null && nt.pin ? (_e = e2.errors.creditCard) == null ? void 0 : _e.pin : void 0, element: {
        type: "input",
        props: {
          type: "text",
          autoComplete: "off",
          ...e2.getFieldProps("creditCard.pin"),
          readOnly: t2,
          ref: j
        }
      }, inlineUi: ie2, monospace: true }) : /* @__PURE__ */ jsx(Qe, { inlineUi: ie2, ref: j, onButtonClick: () => $(true), changed: ((mn = e2.initialValues.creditCard) == null ? void 0 : mn.pin) !== ((hn = e2.values.creditCard) == null ? void 0 : hn.pin), children: /* @__PURE__ */ jsx(Trans, { id: "2cIs6V" }) }) })
    ] });
  });
  function lu(e2) {
    const {
      card: t2,
      cardNumberWarning: n2,
      cardValid: r2
    } = reactExports.useMemo(() => {
      var l2;
      const a = At.number((l2 = e2.values.creditCard) == null ? void 0 : l2.number);
      return {
        cardValid: a.isValid,
        card: a.card,
        cardNumberWarning: Ft(e2, "number", a)
      };
    }, [e2]), i2 = reactExports.useMemo(() => {
      var l2;
      const a = At.expirationDate((l2 = e2.values.creditCard) == null ? void 0 : l2.expiration);
      return Ft(e2, "expiration", a);
    }, [e2]), s2 = reactExports.useMemo(() => {
      var l2;
      if (!r2 || !t2)
        return false;
      const a = At.cvv((l2 = e2.values.creditCard) == null ? void 0 : l2.securityCode, t2.code.size);
      return Ft(e2, "securityCode", a);
    }, [t2, r2, e2]);
    return {
      warnings: {
        number: n2 ? i18n._(
          /*i18n*/
          {
            id: "0FSRiz"
          }
        ) : void 0,
        expiration: i2 ? i18n._(
          /*i18n*/
          {
            id: "Lyd22+"
          }
        ) : void 0,
        securityCode: s2 ? i18n._(
          /*i18n*/
          {
            id: "7xaBoY"
          }
        ) : void 0
      },
      card: t2
    };
  }
  function Ft(e2, t2, n2) {
    var r2, i2;
    return (r2 = e2.values.creditCard) != null && r2[t2] ? (i2 = e2.touched.creditCard) != null && i2[t2] ? !n2.isValid : !n2.isPotentiallyValid : false;
  }
  ee(["wifiSsid", "password"])(({
    formik: e2,
    writeAuditlogEvent: t2
  }) => {
    const {
      action: n2,
      show: r2,
      setShow: i2
    } = Ke({
      isEmpty: false,
      onShow: () => {
        t2 == null || t2({
          type: AuditlogEventType.WIFI_R_QR_SHOW
        });
      }
    }), s2 = reactExports.useMemo(() => [n2], [n2]), {
      ref: c2,
      inlineUi: a
    } = oe(s2), l2 = bc(e2.values.wifiSsid ?? "", e2.values.password);
    return !e2.values.wifiSsid || !e2.values.password ? null : /* @__PURE__ */ jsx("div", { className: y.FormElement, children: r2 ? /* @__PURE__ */ jsx(Pc, { data: l2, inlineUi: a }) : /* @__PURE__ */ jsx(Qe, { inlineUi: a, ref: c2, onButtonClick: () => i2(true), changed: false, children: /* @__PURE__ */ jsx(Trans, { id: "vHxqT2" }) }) });
  });
  function Lo(e2, t2) {
    const n2 = [...e2.websites], r2 = {
      ...e2.websiteAttributes
    };
    let i2;
    if (t2) {
      const s2 = n2[t2.index];
      if (s2) {
        const c2 = t2.oldNormalizedValue;
        i2 = normalizeWebsitePattern(s2);
        const a = getWebsiteAttributesEntry(s2);
        n2[t2.index] = i2, r2[i2] = {
          ...r2[i2],
          ...r2 == null ? void 0 : r2[c2],
          ...a
        };
      }
    }
    for (const s2 of Object.keys(r2))
      n2.includes(s2) || delete r2[s2];
    return e2.websiteAttributes === void 0 && Object.keys(r2).length === 0 ? {
      websites: n2,
      websiteAttributes: void 0,
      newFocusedWebsiteValue: i2
    } : {
      websites: n2,
      websiteAttributes: r2,
      newFocusedWebsiteValue: i2
    };
  }
  function ee(e2) {
    return function(n2) {
      return we$1.memo(n2, ({
        formik: r2,
        ...i2
      }, {
        formik: s2,
        ...c2
      }) => {
        for (const a of e2)
          if (
            // Match formik FastField: https://github.com/jaredpalmer/formik/blob/958d67ca2c3e006031c31150ea0a42248b28ffc7/packages/formik/src/FastField.tsx#L79-L87
            r2.values[a] !== s2.values[a] || r2.touched[a] !== s2.touched[a] || r2.errors[a] !== s2.errors[a] || r2.isSubmitting !== s2.isSubmitting
          )
            return false;
        for (const a of Object.keys(i2))
          if (vt(i2, a) && vt(c2, a) && i2[a] !== c2[a] || vt(i2, a) !== vt(c2, a))
            return false;
        return true;
      });
    };
  }
  function vt(e2, t2) {
    return t2 in e2;
  }
  const Op = "_SearchInputWrapper_1f8f1_1", Fp = "_small_1f8f1_8", Wp = "_dark_1f8f1_11", zp = "_SearchInput_1f8f1_1", Dp = "_SearchOverlay_1f8f1_49", Up = "_SearchOverlayIcon_1f8f1_61", Vp = "_PlaceholderText_1f8f1_73", kp = "_InlineUi_1f8f1_84", Hp = "_ClearButton_1f8f1_90 _UnstyledButton_14p2i_205", Ce = {
    SearchInputWrapper: Op,
    small: Fp,
    dark: Wp,
    SearchInput: zp,
    SearchOverlay: Dp,
    SearchOverlayIcon: Up,
    PlaceholderText: Vp,
    InlineUi: kp,
    ClearButton: Hp
  };
  we$1.forwardRef(({
    value: e2,
    suggestions: t2,
    onKeyDown: n2,
    placeholder: r2,
    className: i2,
    size: s2,
    inlineUi: c2,
    clear: a,
    ...l2
  }, d2) => {
    const u2 = reactExports.useRef(null), m2 = Z(), [h2, {
      width: g2
    }] = he();
    return /* @__PURE__ */ jsxs("div", { className: f$1(Ce.SearchInputWrapper, i2, Ce[m2], Ce[s2 ?? "medium"]), style: {
      "--inline-ui-width": `${g2}px`
    }, children: [
      /* @__PURE__ */ jsx("input", { ...l2, type: "search", value: e2, className: f$1(Ce.SearchInput), autoCapitalize: "off", autoCorrect: "off", onKeyDown: a ? (v2) => {
        n2 == null || n2(v2), !v2.defaultPrevented && v2.key === "Escape" && e2 && (a(), v2.preventDefault());
      } : n2, ref: qp(d2, u2) }),
      !!e2 && !!a && /* @__PURE__ */ jsx("button", { type: "button", onClick: () => {
        var v2;
        (v2 = u2.current) == null || v2.focus(), a();
      }, className: Ce.ClearButton, children: /* @__PURE__ */ jsx(Svg12F2Ab3739Adfbea, { title: i18n._(
        /*i18n*/
        {
          id: "xCJdfg"
        }
      ) }) }),
      /* @__PURE__ */ jsxs("div", { className: Ce.SearchOverlay, children: [
        /* @__PURE__ */ jsx("div", { className: Ce.SearchOverlayIcon, children: /* @__PURE__ */ jsx(Svg78Cd0901269Cea25, {}) }),
        /* @__PURE__ */ jsx("div", { className: Ce.PlaceholderText, children: !e2 && r2 }),
        c2 && /* @__PURE__ */ jsx("div", { className: Ce.InlineUi, ref: h2, children: c2 })
      ] }),
      t2
    ] });
  });
  function qp(...e2) {
    return (t2) => {
      for (const n2 of e2)
        typeof n2 == "function" ? n2(t2) : n2 !== null && (n2.current = t2);
    };
  }
  Bo.shim();
  class WebauthnUnlockConnector {
    constructor() {
      __publicField(this, "port");
      __publicField(this, "onMessage", (msg) => {
        if (msg.type === "TriggerWebauthnUnlockInIframe") {
          this.triggerWebauthnUnlock(msg.requestOptionsJSON).catch(trackError);
        }
      });
    }
    async init() {
      const webauthnUnlockId = new URLSearchParams(window.location.search).get("webauthnUnlockId");
      if (!webauthnUnlockId) {
        return;
      }
      this.port = openConnection("WebauthnUnlock");
      this.port.onMessage.addListener(this.onMessage);
      this.port.postMessage({
        type: "SetWebauthnUnlockId",
        id: webauthnUnlockId
      });
    }
    close() {
      var _a3;
      (_a3 = this.port) == null ? void 0 : _a3.onMessage.removeListener(this.onMessage);
    }
    async triggerWebauthnUnlock(requestOptionsJSON) {
      var _a3;
      const options = jsonParseThaw(requestOptionsJSON);
      const navigatorCredentials = h$3();
      if (!navigatorCredentials) {
        return;
      }
      let cred;
      try {
        cred = await navigatorCredentials.get(options);
      } catch (e2) {
        if (e2 instanceof DOMException) {
          if (e2.name === "AbortError") {
            return void 0;
          }
          if (e2.name === "NotAllowedError") {
            return void 0;
          }
        }
        trackError(e2);
        return void 0;
      }
      if (!cred) {
        return void 0;
      }
      const result2 = E$2(cred);
      const stringifiedGetResult = jsonStringifyFreeze(result2);
      (_a3 = this.port) == null ? void 0 : _a3.postMessage({
        type: "ReturnWebauthnResult",
        credentialGetResultJSON: stringifiedGetResult
      });
    }
  }
  content;
  class ContentScriptMain {
    constructor() {
      __publicField(this, "mutationObserver", new MutationObserver(this.handleMutations.bind(this)));
      __publicField(this, "isDisabled");
      __publicField(this, "loggedOut");
      __publicField(this, "clientOutdated");
      __publicField(this, "contentScriptMode");
      __publicField(this, "heyloginWebappConnector");
      __publicField(this, "webauthnUnlockConnector");
      __publicField(this, "activeFieldFiller");
      __publicField(this, "globalListenersRemoved");
      __publicField(this, "heyloginComConnector");
      __publicField(this, "stateRestorationClient");
      __publicField(this, "formTracker");
      __publicField(this, "pageLogins");
      __publicField(this, "formDetectionDebug");
      __publicField(this, "autoSnatch");
      __publicField(this, "loginFormFiller");
      __publicField(this, "totpQrSaver");
      __publicField(this, "userActivityTracker");
      __publicField(this, "registrationPasswordGeneration");
      __publicField(this, "totpQrDetector");
      __publicField(this, "debugTrigger");
      __publicField(this, "overrideCreatorDebugTrigger");
      __publicField(this, "autosnatchNotificationOverlayManager");
      __publicField(this, "contentScriptModeMutex", new Mutex$1());
      __publicField(this, "initializedPromise");
      __publicField(this, "setInitialized");
      __publicField(this, "handleMessage", makeMessageListener({
        DataUpdate: () => {
          Promise.all([this.updateDisabled(), this.updateLoggedOut(), this.updateClientOutdated()]).then(this.updateContentScriptMode).catch(trackError);
        },
        GetContentScriptMode: () => this.contentScriptMode,
        GetIsAutosnatchActive: (msg) => this.handleGetIsAutosnatchActive(msg),
        ClearValueFromClipboard: async ({
          value
        }) => {
          const clipboardContent = await window.navigator.clipboard.readText();
          if (clipboardContent !== value) {
            debugConsole.log("[ContentScriptMain]", "skip clearing clipboard as value has changed");
            return;
          }
          debugConsole.log("[ContentScriptMain]", "clearing clipboard");
          await window.navigator.clipboard.writeText("");
        }
      }));
      __publicField(this, "updateContentScriptMode", async () => {
        await this.contentScriptModeMutex.runExclusive(async () => {
          var _a3, _b;
          const oldContentScriptMode = this.contentScriptMode;
          const newContentScriptMode = this.getContentScriptMode();
          if (oldContentScriptMode === newContentScriptMode) {
            return;
          }
          await sendMessage({
            type: "ContentScriptModeChanged",
            mode: newContentScriptMode
          });
          this.contentScriptMode = newContentScriptMode;
          debugConsole.log("[ContentScriptMain]", "updating mode", {
            oldContentScriptMode,
            newContentScriptMode
          });
          if (this.contentScriptMode === "default") {
            await this.createAllForDefault();
          } else {
            await this.closeAllForDefault();
          }
          if (this.contentScriptMode === "heyloginWebapp") {
            this.heyloginWebappConnector = new HeyloginWebappConnector();
            await this.heyloginWebappConnector.init();
          } else {
            (_a3 = this.heyloginWebappConnector) == null ? void 0 : _a3.close();
            this.heyloginWebappConnector = void 0;
          }
          if (this.contentScriptMode === "heyloginWebappBlank") {
            this.webauthnUnlockConnector = new WebauthnUnlockConnector();
            await this.webauthnUnlockConnector.init();
          } else {
            (_b = this.webauthnUnlockConnector) == null ? void 0 : _b.close();
            this.webauthnUnlockConnector = void 0;
          }
        });
      });
      __publicField(this, "handleGlobalListenersRemoved", () => {
        this.contentScriptModeMutex.runExclusive(async () => {
          debugConsole.log("[ContentScriptMain]", "detected global listeners removed, reattaching");
          await this.closeAllForDefault();
          await this.createAllForDefault();
        }).catch(trackError);
      });
      ({
        promise: this.initializedPromise,
        resolve: this.setInitialized
      } = promiseWithResolvers());
    }
    async init() {
      this.mutationObserver.observe(document.getRootNode(), {
        subtree: true,
        attributes: true,
        attributeFilter: ["name", "content"],
        childList: true
      });
      browser$1.runtime.onMessage.addListener(this.handleMessage);
      await Promise.all([this.updateDisabled(), this.updateLoggedOut(), this.updateClientOutdated()]);
      await this.updateContentScriptMode();
      this.activeFieldFiller = new LoginFormFiller();
      this.activeFieldFiller.init();
      this.setInitialized();
    }
    handleMutations(mutations) {
      const changedNodes = mutations.flatMap((m2) => [m2.target, ...m2.addedNodes]);
      if (
        // too many changed nodes to check all of them individually, so we just do the update
        changedNodes.length > 100 || // one of the nodes changed or their children is an element related to the application name
        // meta tag
        changedNodes.some((n2) => n2 instanceof HTMLMetaElement && n2.name === "application-name")
      ) {
        this.updateContentScriptMode().catch(trackError);
      }
    }
    async handleGetIsAutosnatchActive(msg) {
      var _a3, _b;
      await this.initializedPromise;
      return !!((_a3 = this.registrationPasswordGeneration) == null ? void 0 : _a3.isAutosnatchActive(msg.autosnatchId)) || !!((_b = this.autosnatchNotificationOverlayManager) == null ? void 0 : _b.isAutosnatchActive(msg.autosnatchId));
    }
    async updateDisabled() {
      const disabledSiteSettingResult = await sendMessage({
        type: "GetDisabledSiteSettingForUrl",
        url: window.location.href
      });
      if (disabledSiteSettingResult === messageError) {
        return;
      }
      this.isDisabled = disabledSiteSettingResult.disabled;
    }
    async updateLoggedOut() {
      const userResponse = await sendMessage({
        type: "GetUser"
      });
      if (userResponse === messageError) {
        return;
      }
      this.loggedOut = !userResponse.userId;
    }
    async updateClientOutdated() {
      var _a3;
      const clientOutdatedResponse = await sendMessage({
        type: "IsClientOutdated"
      });
      if (clientOutdatedResponse === messageError) {
        return;
      }
      this.clientOutdated = !!clientOutdatedResponse;
      (_a3 = this.loginFormFiller) == null ? void 0 : _a3.setClientOutdated(!!clientOutdatedResponse);
    }
    getContentScriptMode() {
      var _a3, _b;
      const hasHeyloginMetaTag = ((_a3 = document.querySelector("meta[name=application-name]")) == null ? void 0 : _a3.content) === "heylogin";
      if (hasHeyloginMetaTag) {
        const {
          host
        } = window.location;
        if (host === getFrontendServerHost()) {
          const isBlank = ((_b = document.querySelector("meta[name=mode]")) == null ? void 0 : _b.content) === "blank";
          return isBlank ? "heyloginWebappBlank" : "heyloginWebapp";
        }
        if (isHeyloginWebappHost(host)) {
          return "disabled";
        }
      }
      if (this.isDisabled || this.loggedOut && !this.clientOutdated) {
        return "disabled";
      }
      return "default";
    }
    async createAllForDefault() {
      this.globalListenersRemoved = new GlobalListenersRemoved(this.handleGlobalListenersRemoved);
      this.globalListenersRemoved.init();
      const incognito = browser$1.extension.inIncognitoContext;
      this.heyloginComConnector = new HeyloginComConnector();
      this.heyloginComConnector.init();
      this.stateRestorationClient = new StateRestorationClient();
      await this.stateRestorationClient.init();
      this.formTracker = new FormTracker();
      this.formTracker.init();
      this.pageLogins = new PageLogins();
      await this.pageLogins.init();
      this.totpQrDetector = new TotpQrDetector();
      this.totpQrDetector.init();
      this.formDetectionDebug = new FormDetectionDebug(this.formTracker, this.totpQrDetector);
      this.formDetectionDebug.init();
      if (!incognito) {
        this.autoSnatch = new FormAutosnatch(this.formTracker, this.stateRestorationClient);
        this.autoSnatch.init();
        this.autosnatchNotificationOverlayManager = new AutosnatchNotificationOverlayManager(this.pageLogins, this.stateRestorationClient, this.autoSnatch);
        await this.autosnatchNotificationOverlayManager.init();
        this.registrationPasswordGeneration = new RegistrationPasswordGeneration(this.formTracker, this.autoSnatch);
        await this.registrationPasswordGeneration.init();
      } else {
        this.autoSnatch = void 0;
        this.registrationPasswordGeneration = void 0;
      }
      this.loginFormFiller = new LoginFormFiller$1(this.pageLogins, this.formTracker, this.totpQrDetector, this.autoSnatch, this.stateRestorationClient, !!this.clientOutdated);
      await this.loginFormFiller.init();
      this.totpQrSaver = new TotpQrSaver(this.pageLogins, this.totpQrDetector);
      this.totpQrSaver.init();
      this.userActivityTracker = new UserActivityTracker();
      this.userActivityTracker.init();
      this.debugTrigger = new P$1(() => {
        debugMode.localDebugOverride = !debugMode.localDebugOverride;
      }, "HEYDBG");
      this.debugTrigger.init();
      this.overrideCreatorDebugTrigger = new P$1(() => {
        var _a3, _b;
        debugMode.localDebugOverride = !debugMode.localDebugOverride;
        if (debugMode.debug) {
          (_a3 = this.formDetectionDebug) == null ? void 0 : _a3.openOverrideCreator().catch(trackError);
        } else {
          (_b = this.formDetectionDebug) == null ? void 0 : _b.closeOverrideCreator().catch(trackError);
        }
      }, "HEYFRM");
      this.overrideCreatorDebugTrigger.init();
    }
    async closeAllForDefault() {
      var _a3, _b, _c2, _d, _e, _f, _g, _h, _i, _j, _k, _l2, _m, _n, _o2;
      (_a3 = this.globalListenersRemoved) == null ? void 0 : _a3.close();
      this.globalListenersRemoved = void 0;
      (_b = this.heyloginComConnector) == null ? void 0 : _b.close();
      this.heyloginComConnector = void 0;
      (_c2 = this.stateRestorationClient) == null ? void 0 : _c2.close();
      this.stateRestorationClient = void 0;
      (_d = this.autosnatchNotificationOverlayManager) == null ? void 0 : _d.close();
      this.autosnatchNotificationOverlayManager = void 0;
      (_e = this.formTracker) == null ? void 0 : _e.close();
      this.formTracker = void 0;
      (_f = this.pageLogins) == null ? void 0 : _f.close();
      this.pageLogins = void 0;
      (_g = this.totpQrDetector) == null ? void 0 : _g.close();
      this.totpQrDetector = void 0;
      (_h = this.formDetectionDebug) == null ? void 0 : _h.close();
      this.formDetectionDebug = void 0;
      (_i = this.autoSnatch) == null ? void 0 : _i.close();
      this.autoSnatch = void 0;
      (_j = this.loginFormFiller) == null ? void 0 : _j.close();
      this.loginFormFiller = void 0;
      (_k = this.totpQrSaver) == null ? void 0 : _k.close();
      this.totpQrSaver = void 0;
      (_l2 = this.userActivityTracker) == null ? void 0 : _l2.close();
      this.userActivityTracker = void 0;
      (_m = this.registrationPasswordGeneration) == null ? void 0 : _m.close();
      this.registrationPasswordGeneration = void 0;
      (_n = this.debugTrigger) == null ? void 0 : _n.close();
      this.debugTrigger = void 0;
      (_o2 = this.overrideCreatorDebugTrigger) == null ? void 0 : _o2.close();
      this.overrideCreatorDebugTrigger = void 0;
    }
  }
  content;
  initSentry({
    entryPoint: "content",
    contentScript: true
  });
  async function init() {
    if (document.contentType !== "text/html" && document.contentType !== "application/xhtml+xml") {
      return;
    }
    await new ContentScriptMain().init();
  }
  init().catch(trackError);
  content;
  const wrappedIndex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null
  }, Symbol.toStringTag, { value: "Module" }));
  return result;
}();
content;
//# sourceMappingURL=content.js.map
