class TimeEntry extends ClockifyService{static get doAlert(){return this._doAlert}static set doAlert(t){this._doAlert=t}static get timeEntryIdTemp(){return Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)}static async getUrlTimeEntries(){return`${await this.apiEndpoint}/workspaces/${await this.workspaceId}/timeEntries`}get timeEntryIdTemp(){return Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)}static async getEntryInProgress(t=!0){const e=await this.apiEndpoint,r=await this.userId,a=`${e}/v1/workspaces/${await this.workspaceId}/user/${r}/time-entries?in-progress=true${t?"&hydrated=true":""}`,{data:s,error:i,status:n}=await this.apiCall(a);return{entry:s&&s.length>0?s[0]:null,error:i}}static async takeTimeEntryInProgress(){if(await TokenService.isLoggedIn()){const{entry:t,error:e}=await this.getEntryInProgress();null===t||e?(setTimeEntryInProgress(null),aBrowser.action.setIcon({path:iconPathEnded})):(setTimeEntryInProgress(t),aBrowser.action.setIcon({path:iconPathStarted}))}}static async getLastPomodoroEntry(){try{const[t,e,r]=await Promise.all([this.apiEndpoint,this.userId,this.workspaceId]),a=`${t}/v1/workspaces/${r}/user/${e}/time-entries?page-size=10`,{data:s,error:i}=await this.apiCall(a);if(i)return console.error("oh no, failed",i),{error:i};const n=JSON.parse(await localStorage.getItem("timeEntriesOffline"))||[],o=t=>t.find((t=>"Pomodoro break"!==t.description&&"Pomodoro long break"!==t.description)),l=o(s),c=o(n);let d;if(l&&c){const t=new Date(l.timeInterval?.start);d=new Date(c.timeInterval?.start)>t?c:l}else d=l||c;return{entry:d}}catch(t){return console.error("An error occurred:",t),{error:t}}}static async getTimeEntries(t,e=50){const r=`${await this.getUrlTimeEntries()}/user/${await this.userId}/full?page=${t}&limit=${e}`,{data:a,error:s}=await this.apiCall(r);return s&&console.error("oh no, failed",s),{data:a,error:s}}static async deleteTimeEntry(t){const e=`${await this.getUrlTimeEntries()}/${t}`,{data:r,error:a}=await this.apiCall(e,"DELETE");return a&&console.error("oh no, failed",a),{data:r,error:a}}static async deleteTimeEntries(t){const e=`${await this.apiEndpoint}/v1/workspaces/${await this.workspaceId}/user/${await this.userId}/time-entries?time-entry-ids=${t.join(",")}`,{data:r,error:a}=await this.apiCall(e,"DELETE");return a&&console.error("oh no, failed",a),{data:r,error:a}}static async continueEntry(t){const e=`${await this.apiEndpoint}/workspaces/${await this.workspaceId}/time-entries/${t}/continue`,{data:r,error:a}=await this.apiCall(e,"POST",{});return a?console.error("oh no, failed",a):await AnalyticsService.storeAnalyticsEvents([AnalyticsService.events.entryContinued]),{data:r,error:a}}static async updateTimeEntryValues(t,e){const r=`${await this.apiEndpoint}/workspaces/${await this.workspaceId}/timeEntries/${t}`;return await this.apiCall(r,"PUT",e)}static async duplicateTimeEntry(t){const e=`${await this.apiEndpoint}/v1/workspaces/${await this.workspaceId}/user/${await this.userId}/time-entries/${t}/duplicate`,{data:r,error:a}=await this.apiCall(e,"POST");return a&&console.error("failed",a),{data:r,error:a}}static async searchEntries(t){const e=`${await this.getUrlTimeEntries()}?searchValue=${t}`,{data:r,error:a}=await this.apiCall(e);return a&&console.error("oh no, failed",a),{data:r,error:a}}static async getRecentTimeEntries(){const t=`${await this.getUrlTimeEntries()}/recent?limit=8`,{data:e,error:r}=await this.apiCall(t);return r&&console.error("oh no, failed",r),{data:e,error:r}}static async endInProgress({timeEntry:t=null,end:e=moment(),endedFromIntegration:r=null,integrationName:a,endEntryInProgressToContinueOtherEntry:s}={}){const i=await this.getEntryInProgress();let n=i.entry;if(i.error)return{error:{status:404,message:"no entry in progress"}};if(t){const{projectId:e,taskId:r}=t,{forceProjects:a,forceTasks:s}=await this.getForces();if(a&&!e||s&&!r){const{projectDB:e,taskDB:r,msg:a,msgId:s}=await DefaultProject.getProjectTaskFromDB();e&&(n=await this.updateProjectTask(t,e,r))}}if(!n)return{error:{status:404,message:"no entry in progress"}};const{id:o,projectId:l,task:c,billable:d,description:m,timeInterval:p,customFieldValues:g,tags:u}=n,{start:h}=p,w={projectId:l,taskId:c?c.id:void 0,tagIds:u&&u.length?u.map((({id:t})=>t)):void 0,description:m,start:h,end:e,billable:d,customFields:g},y=`${await this.getUrlTimeEntries()}/${o}/full`,T=await this.apiCall(y,"PUT",w);if(T.error){if(400===T.error.status)return T}else{let t,e;aBrowser.action.setIcon({path:iconPathEnded}),setTimeEntryInProgress(null),aBrowser.runtime.sendMessage({eventName:"TIME_ENTRY_STOPPED"}),r||a?(t="entry_mode_integration",e={integrationName:a,timer_end:!0,browser:"chrome"}):(t="entry_mode",e={timer_end:!0,browser:"chrome"});const i={analyticsEventName:t,eventParameters:e};await AnalyticsService.sendAnalyticsEvent(i),s||await AnalyticsService.storeAnalyticsEvents([AnalyticsService.events.trackerStopped])}return T}static async endInProgressAndStartNew(t,e){const{error:r}=await this.endInProgress({timeEntry:t});r||this.startTimer(e)}static async startTimerWithDescription(t){const e=t&&t.selectionText?t.selectionText:"",{entry:r,error:a}=await this.getEntryInProgress();if(r){const{error:t}=await this.endInProgress({timeEntry:r});t?400===t.status&&localStorage.setItem("integrationAlert",t.message+"startTimerWithDescription"):this.startTimer(e)}else this.startTimer(e)}static async startTimer(t,e={projectId:null,task:null,billable:null,tags:[],start:null,end:null,isSubmitTime:!1,customFields:[]},r=!1){const{forceTasks:a}=await this.getForces();let{projectId:s,task:i,billable:n,tags:o,start:l,end:c,isSubmitTime:d,customFields:m}=e;if(!r&&(!s||a&&!i)){const t=await localStorage.getItem("workspaceSettings"),e=JSON.parse(t),{projectDB:r,taskDB:a,msg:o,msgId:l}=await DefaultProject.getProjectTaskFromDB();r?(s=r.id,null===n&&(n=e?.taskBillableEnabled?a?.billable:r.billable),a&&(i=a)):(s=null,i=null)}const p=`${await this.getUrlTimeEntries()}/full`,g={start:l??new Date,end:c??null,description:t,billable:n,projectId:s,tagIds:o?o.map((t=>t.id)):[],taskId:i?i.id:null,customFields:m},{data:u,error:h,status:w}=await this.apiCall(p,"POST",g);return h?console.error("oh no, failed",h):!u||u.message||c||c||(aBrowser.action.setIcon({path:iconPathStarted}),setTimeEntryInProgress(u),aBrowser.runtime.sendMessage({eventName:"TIME_ENTRY_STARTED"}),afterStartTimer()),{data:u,error:h,status:w}}static async startTimerOnStartingBrowser(){const t=await this.userId,e=await localStorage.getItem("permanent_autoStartOnBrowserStart");if(e&&JSON.parse(e).find((e=>e.userId===t&&e.enabled))){const{entry:t,error:e}=await this.getEntryInProgress();t||e||this.startTimer("")}}static async endInProgressOnClosingBrowser(){const t=await this.userId,e=await localStorage.getItem("permanent_autoStopOnBrowserClose");if((e?JSON.parse(e):[]).find((e=>e.userId===t&&e.enabled))){const{entry:t,error:e,status:r}=await this.getEntryInProgress();e||t&&this.endTimeEntryInProgress(t)}}static async endTimeEntryInProgress(t){const{error:e}=await this.endInProgress({timeEntry:t});if(e&&400===e.status){const e=new Date;this.saveEntryOfflineAndStopItByDeletingIt(t,e)}}static async updateProjectTask(t,e,r){if(await isNavigatorOffline())return null;if(r){const a=`${await this.getUrlTimeEntries()}/${t.id}/projectAndTask`,s={projectId:e.id,taskId:r.id},{data:i,error:n}=await this.apiCall(a,"PUT",s);return n?(console.error("oh no, failed",n),null):(this.updateBillable(i.id,e.billable),Object.assign(i,{billable:e.billable,project:i.project?i.project:e,task:i.task?i.task:r}))}{const r=`${await this.getUrlTimeEntries()}/${t.id}/project`,a={projectId:e.id},{data:s,error:i}=await this.apiCall(r,"PUT",a);return i?(console.error("oh no, failed",i),null):(this.updateBillable(s.id,e.billable),Object.assign(s,{project:s.project?s.project:e,billable:e.billable}))}}static async updateBillable(t,e){const r=`${await this.getUrlTimeEntries()}/${t}/billable`,a={billable:e},{data:s,error:i,status:n}=await this.apiCall(r,"PUT",a);return i&&console.error("oh no, failed",i),{entry:s,error:i,status:n}}static async deleteEntry(t,e){const r=`${await this.getUrlTimeEntries()}/${t}`,{data:a,error:s}=await this.apiCall(r,"DELETE");return s||setTimeEntryInProgress(null),{entry:a,error:s}}static async saveEntryOfflineAndStopItByDeletingIt(t,e,r){const a={workspaceId:t.workspaceId,id:this.timeEntryIdTemp,description:t.description,projectId:t.projectId,taskId:t.task?t.task.id:null,billabe:t.billable,timeInterval:{start:t.timeInterval.start,end:new Date(e)}},s=await localStorage.getItem("timeEntriesOffline")?JSON.parse(await localStorage.getItem("timeEntriesOffline")):[];s.push(a),localStorage.setItem("timeEntriesOffline",JSON.stringify(s)),aBrowser.runtime.sendMessage({eventName:"offlineEntryAdded"});const{error:i}=await this.deleteEntry(t.id,r);return{timeEntry:a}}static async(t){getEntryInProgress().then((e=>e&&e.id?this.stopTimerAndStartNewEntry(t,sendResponse):this.startTimer(t,sendResponse))).catch((t=>{sendResponse(t)}))}static async setDescription(t,e){const r=`${await this.getUrlTimeEntries()}/${t}/description`,a={description:e};return await this.apiCall(r,"PUT",a)}static async updateProject(t,e){const r=`${await this.getUrlTimeEntries()}/${t}/project`,a={projectId:e};return await this.apiCall(r,"PUT",a)}static async removeProject(t){const e=`${await this.getUrlTimeEntries()}/${t}/project/remove`;return await this.apiCall(e,"DELETE")}static async updateTask(t,e,r){const a=`${await this.getUrlTimeEntries()}/${r}/projectAndTask`,s={projectId:e,taskId:t};return await this.apiCall(a,"PUT",s)}static async removeTask(t){const e=`${await this.getUrlTimeEntries()}/${t}/task/remove`;return await this.apiCall(e,"DELETE")}static async updateTags(t,e){const r=`${await this.getUrlTimeEntries()}/${e}/tags`,a={tagIds:t};return await this.apiCall(r,"PUT",a)}static async integrationStartTimerWithDescription(t,e){let{projectName:r,projectId:a=null,taskName:s,taskId:i,tagNames:n,tagIds:o=null,billable:l,start:c=null,end:d=null,isSubmitTime:m=!1,customFields:p=[]}=e,g={id:a,name:r},u={id:i??null,name:s??null};const{forceDescription:h,forceProjects:w,forceTasks:y,forceTags:T}=await this.getForces();if(g.name){const t=await this.getCreateObjects();let{projectDB:e,taskDB:r,message:a}=await ProjectTaskService.getOrCreateProjectAndTask(g.name,u);e?g=e:(w||y&&!r)&&!t&&(a+="\n Integrations can't create projects/tasks. "),u=r,l||(l=!!e&&e.billable),u&&(l=null)}let E=null;if(n&&n.length>0){const{tagovi:t,message:e}=await TagService.getOrCreateTags(n.map((t=>t.trim())));t&&(E=t)}return await this.startTimer(t,{projectId:g.id,task:u,billable:l,tags:o?o.map((t=>({id:t}))):E,start:c,end:d,isSubmitTime:m,customFields:p})}static async changeStart(t,e){const r=`${await this.getUrlTimeEntries()}/${e}/start`,a={start:t};return super.apiCall(r,"PUT",a)}static async editTimeInterval(t,e){if(!t)return;const r=`${await this.getUrlTimeEntries()}/${t}/timeInterval`;let{start:a,end:s}=e;moment(a).date()!==moment(s).date()&&(a=moment(a).add(1,"day"),s=moment(s).add(1,"day"));const i={start:a,end:s};return super.apiCall(r,"PUT",i)}}TimeEntry._doAlert=!0;