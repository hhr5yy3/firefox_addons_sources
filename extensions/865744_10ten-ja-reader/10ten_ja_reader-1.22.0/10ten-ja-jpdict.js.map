{"version":3,"file":"10ten-ja-jpdict.js","sources":["webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+json-equalish@1.1.2/node_modules/@birchill/json-equalish/src/index.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/superstruct@2.0.2/node_modules/superstruct/dist/index.mjs","webpack://10ten-ja-reader/./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+normal-jp@1.5.2/node_modules/@birchill/normal-jp/src/kana-to-hiragana.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+normal-jp@1.5.2/node_modules/@birchill/normal-jp/src/to-normalized.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/abort-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/data-series.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/is-object.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/error-parsing.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/fetch.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/validation-helpers.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download-version-info.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/ljson-stream.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/utils.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/version-number.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/quota-exceeded-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/japanese.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/store-types.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/store.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-state-reducer.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download-types.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/database.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/offline-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/words.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/word-result-sorting.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-error-state.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/request-idle-callback.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/uuid.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-key.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-with-retry.ts","webpack://10ten-ja-reader/./src/utils/request-idle-callback.ts","webpack://10ten-ja-reader/./src/utils/serialize-error.ts","webpack://10ten-ja-reader/./src/background/jpdict-events.ts","webpack://10ten-ja-reader/./src/background/jpdict-backend.ts","webpack://10ten-ja-reader/./src/worker/jpdict-worker.ts"],"sourcesContent":["export function jsonEqualish(actual: any, expected: any) {\n  if (Object.is(actual, expected)) {\n    return true;\n  }\n\n  // For non-objects, use Object.is. This will cause 'undefined' and 'null' to\n  // be different, as desired.\n  if (\n    !actual ||\n    !expected ||\n    (typeof actual !== 'object' && typeof expected !== 'object')\n  ) {\n    // Except for numbers, since we want '-0' and '+0' to be equivalent\n    //\n    // (We should really just use JSON.stringify here. Might be slower but would\n    // it matter?)\n    return typeof actual === 'number'\n      ? actual === expected\n      : Object.is(actual, expected);\n  }\n\n  return objEquiv(actual, expected);\n}\n\nfunction objEquiv(a: any, b: any) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a instanceof Date) {\n    return b instanceof Date && a.getTime() == b.getTime();\n  }\n\n  if (Array.isArray(a) !== Array.isArray(b)) {\n    return false;\n  }\n\n  // We only deal with POD at the moment.\n  if (\n    (a.constructor && a.constructor !== Object && a.constructor !== Array) ||\n    (b.constructor && b.constructor !== Object && b.constructor !== Array)\n  ) {\n    throw new Error('Trying to compare something fancy');\n  }\n\n  const aKeys = definedKeys(a);\n  const bKeys = definedKeys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  aKeys.sort();\n  bKeys.sort();\n\n  // Compare keys first\n  for (let i = 0; i < aKeys.length; ++i) {\n    if (aKeys[i] != bKeys[i]) {\n      return false;\n    }\n  }\n\n  // Compare values\n  for (const key of aKeys) {\n    if (!jsonEqualish(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction definedKeys(a: any) {\n  return Object.keys(a).filter(key => typeof a[key] !== 'undefined');\n}\n\nexport default jsonEqualish;\n","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */\nfunction isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch, mask };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = { ...value };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for (const key in coerced) {\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value, ctx) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask,\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","export function kanaToHiragana(input: string): string {\n  let result = '';\n\n  for (const char of input) {\n    let c = char.codePointAt(0)!;\n\n    if ((c >= 0x30a1 && c <= 0x30f6) || c === 0x30fd || c === 0x30fe) {\n      c -= 0x60;\n    }\n\n    result += String.fromCodePoint(c);\n  }\n\n  return result;\n}\n","// prettier-ignore\nconst HANKAKU_KATAKANA_TO_ZENKAKU = [\n 0x3002, 0x300c, 0x300d, 0x3001, 0x30fb, 0x30f2, 0x30a1, 0x30a3, 0x30a5,\n 0x30a7, 0x30a9, 0x30e3, 0x30e5, 0x30e7, 0x30c3, 0x30fc, 0x30a2, 0x30a4,\n 0x30a6, 0x30a8, 0x30aa, 0x30ab, 0x30ad, 0x30af, 0x30b1, 0x30b3, 0x30b5,\n 0x30b7, 0x30b9, 0x30bb, 0x30bd, 0x30bf, 0x30c1, 0x30c4, 0x30c6, 0x30c8,\n 0x30ca, 0x30cb, 0x30cc, 0x30cd, 0x30ce, 0x30cf, 0x30d2, 0x30d5, 0x30d8,\n 0x30db, 0x30de, 0x30df, 0x30e0, 0x30e1, 0x30e2, 0x30e4, 0x30e6, 0x30e8,\n 0x30e9, 0x30ea, 0x30eb, 0x30ec, 0x30ed, 0x30ef, 0x30f3, 0x3099, 0x309a,\n];\n\n// prettier-ignore\nconst VOICED_TO_COMPOSED = new Map([\n  [0x3046, 0x3094], [0x304b, 0x304c], [0x304d, 0x304e], [0x304f, 0x3050],\n  [0x3051, 0x3052], [0x3053, 0x3054], [0x3055, 0x3056], [0x3057, 0x3058],\n  [0x3059, 0x305a], [0x305b, 0x305c], [0x305d, 0x305e], [0x305f, 0x3060],\n  [0x3061, 0x3062], [0x3064, 0x3065], [0x3066, 0x3067], [0x3068, 0x3069],\n  [0x306f, 0x3070], [0x3072, 0x3073], [0x3075, 0x3076], [0x3078, 0x3079],\n  [0x307b, 0x307c], [0x309d, 0x309e], [0x30ab, 0x30ac], [0x30ad, 0x30ae],\n  [0x30a6, 0x30f4], [0x30af, 0x30b0], [0x30b1, 0x30b2], [0x30b3, 0x30b4],\n  [0x30b5, 0x30b6], [0x30b7, 0x30b8], [0x30b9, 0x30ba], [0x30bb, 0x30bc],\n  [0x30bd, 0x30be], [0x30bf, 0x30c0], [0x30c1, 0x30c2], [0x30c4, 0x30c5],\n  [0x30c6, 0x30c7], [0x30c8, 0x30c9], [0x30cf, 0x30d0], [0x30d2, 0x30d3],\n  [0x30d5, 0x30d6], [0x30d8, 0x30d9], [0x30db, 0x30dc], [0x30ef, 0x30f7],\n  [0x30f0, 0x30f8], [0x30f1, 0x30f9], [0x30f2, 0x30fa], [0x30fd, 0x30fe]\n]);\n\n// prettier-ignore\nconst SEMIVOICED_TO_COMPOSED = new Map([\n  [0x306f, 0x3071], [0x3072, 0x3074], [0x3075, 0x3077], [0x3078, 0x307a],\n  [0x307b, 0x307d], [0x30cf, 0x30d1], [0x30d2, 0x30d4], [0x30d5, 0x30d7],\n  [0x30d8, 0x30da], [0x30db, 0x30dd]\n]);\n\n// First part of the CJK Compatibility block: 0x3300-0x3370\n// prettier-ignore\nconst COMBINED_CHARS_A = [\n 'アパート', 'アルファ', 'アンペア', 'アール', 'イニング', 'インチ', 'ウォン',\n  'エスクード', 'エーカー', 'オンス', 'オーム', 'カイリ', 'カラット',\n  'カロリー', 'ガロン', 'ガンマ', 'ギガ', 'ギニー', 'キュリー', 'ギルダー',\n  'キロ', 'キログラム', 'キロメートル', 'キロワット', 'グラム', 'グラムトン',\n  'クルゼイロ', 'クローネ', 'ケース', 'コルナ', 'コーポ', 'サイクル',\n  'サンチーム', 'シリング', 'センチ', 'セント', 'ダース', 'デシ', 'ドル',\n  'トン', 'ナノ', 'ノット', 'ハイツ', 'パーセント', 'パーツ', 'バーレル',\n  'ピアストル', 'ピクル', 'ピコ', 'ビル', 'ファラッド', 'フィート',\n  'ブッシェル', 'フラン', 'ヘクタール', 'ペソ', 'ペニヒ', 'ヘルツ', 'ペンス',\n  'ページ', 'ベータ', 'ポイント', 'ボルト', 'ホン', 'ポンド', 'ホール',\n  'ホーン', 'マイクロ', 'マイル', 'マッハ', 'マルク', 'マンション', 'ミクロン',\n  'ミリ', 'ミリバール', 'メガ', 'メガトン', 'メートル', 'ヤード', 'ヤール',\n  'ユアン', 'リットル', 'リラ', 'ルピー', 'ルーブル', 'レム', 'レントゲン',\n  'ワット', '0点', '1点', '2点', '3点', '4点', '5点', '6点', '7点', '8点',\n  '9点', '10点', '11点', '12点', '13点', '14点', '15点', '16点', '17点', '18点',\n  '19点', '20点', '21点', '22点', '23点', '24点'\n];\n\n// Second part of the CJK Compatibility block: 0x337b-0x337f\n// prettier-ignore\nconst COMBINED_CHARS_B = ['平成', '昭和', '大正', '明治', '株式会社'];\n\n// First part of Enclosed CJK letters and motnhs block: 0x3220-0x3247\n// prettier-ignore\nconst ENCLOSED_CHARS_A = [\n  '一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '月', '火', '水',\n  '木', '金', '土', '日', '株', '有', '社', '名', '特', '財', '祝', '労', '代',\n  '呼', '学', '監', '企', '資', '協', '祭', '休', '自', '至', '問', '幼', '文',\n  '箏'\n];\n\n// Second part of Enclosed CJK letters and motnhs block: 0x3280-0x32b0\n// prettier-ignore\nconst ENCLOSED_CHARS_B = [\n  '一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '月', '火', '水',\n  '木', '金', '土', '日', '株', '有', '社', '名', '特', '財', '祝', '労', '秘',\n  '男', '女', '適', '優', '印', '注', '頂', '休', '写', '正', '上', '中', '下',\n  '左', '右', '医', '宗', '学', '監', '企', '資', '協', '夜'\n];\n\n// Third part of Enclosed CJK letters and motnhs block: 0x32c0-0x32cb\n// prettier-ignore\nconst ENCLOSED_CHARS_C = [\n  '1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月',\n  '12月'\n];\n\n// Fourth part of Enclosed CJK letters and motnhs block: 0x32d0-0x32ff\n// prettier-ignore\nconst ENCLOSED_CHARS_D = [\n  'ア', 'イ', 'ウ', 'エ', 'オ', 'カ', 'キ', 'ク', 'ケ', 'コ', 'サ', 'シ', 'ス',\n  'セ', 'ソ', 'タ', 'チ', 'ツ', 'テ', 'ト', 'ナ', 'ニ', 'ヌ', 'ネ', 'ノ', 'ハ',\n  'ヒ', 'フ', 'ヘ', 'ホ', 'マ', 'ミ', 'ム', 'メ', 'モ', 'ヤ', 'ユ', 'ヨ', 'ラ',\n  'リ', 'ル', 'レ', 'ロ', 'ワ', 'ヰ', 'ヱ', 'ヲ', '令和'\n];\n\n// We should handle the Enclosed Ideographic Supplement too\n// (https://en.wikipedia.org/wiki/Enclosed_Ideographic_Supplement)\n// but it's in the SMP so it makes processing more complicated.\n//\n// We'll wait until it's actually needed.\n\n// The following is a mapping from radical characters in the Kangxi Radicals\n// and _some_ of the radicals in the CJK Radicals Supplement block.\n//\n// The purpose of this mapping is to help in looking up mis-encoded characters.\n// Therefore, we have deliberately _not_ included some characters where even\n// where there's a possible mapping because the characters don't necessarily\n// look similar or are ambiguous (e.g. the different variants on しんにょう).\n//\n// We've also avoided using equivalents that are not in the BMP even if they're\n// better because it seems unlikely someone would have wanted to encode a\n// non-BMP character and used a radical character instead.\nconst RADICAL_TO_KANJI_CHARS: ReadonlyArray<[number, number]> = [\n  // ⼀ → 一\n  [0x2f00, 0x4e00],\n  // ⼁ → 丨\n  [0x2f01, 0x4e28],\n  // ⼂ → 丶\n  [0x2f02, 0x4e36],\n  // ⼃ → 丿\n  [0x2f03, 0x4e3f],\n  // ⼄ → 乙\n  [0x2f04, 0x4e59],\n  // ⼅ → 亅\n  [0x2f05, 0x4e85],\n  // ⼆ → 二\n  [0x2f06, 0x4e8c],\n  // ⼇ → 亠\n  [0x2f07, 0x4ea0],\n  // ⼈ → 人\n  [0x2f08, 0x4eba],\n  // ⼉ → 儿\n  [0x2f09, 0x513f],\n  // ⼊ → 入\n  [0x2f0a, 0x5165],\n  // ⼋ → 八\n  [0x2f0b, 0x516b],\n  // ⼌ → 冂\n  [0x2f0c, 0x5182],\n  // ⼍ → 冖\n  [0x2f0d, 0x5196],\n  // ⼎ → 冫\n  [0x2f0e, 0x51ab],\n  // ⼏ → 几\n  [0x2f0f, 0x51e0],\n  // ⼐ → 凵\n  [0x2f10, 0x51f5],\n  // ⼑ → 刀\n  [0x2f11, 0x5200],\n  // ⼒ → 力\n  [0x2f12, 0x529b],\n  // ⼓ → 勹\n  [0x2f13, 0x52f9],\n  // ⼔ → 匕\n  [0x2f14, 0x5315],\n  // ⼕ → 匚\n  [0x2f15, 0x531a],\n  // ⼖ → 匸\n  [0x2f16, 0x5338],\n  // ⼗ → 十\n  [0x2f17, 0x5341],\n  // ⼘ → 卜\n  [0x2f18, 0x535c],\n  // ⼙ → 卩\n  [0x2f19, 0x5369],\n  // ⼚ → 厂\n  [0x2f1a, 0x5382],\n  // ⼛ → 厶\n  [0x2f1b, 0x53b6],\n  // ⼜ → 又\n  [0x2f1c, 0x53c8],\n  // ⼝ → 口\n  [0x2f1d, 0x53e3],\n  // ⼞ → 囗\n  [0x2f1e, 0x56d7],\n  // ⼟ → 土\n  [0x2f1f, 0x571f],\n  // ⼠ → 士\n  [0x2f20, 0x58eb],\n  // ⼡ → 夂\n  [0x2f21, 0x5902],\n  // ⼢ → 夊\n  [0x2f22, 0x590a],\n  // ⼣ → 夕\n  [0x2f23, 0x5915],\n  // ⼤ → 大\n  [0x2f24, 0x5927],\n  // ⼥ → 女\n  [0x2f25, 0x5973],\n  // ⼦ → 子\n  [0x2f26, 0x5b50],\n  // ⼧ → 宀\n  [0x2f27, 0x5b80],\n  // ⼨ → 寸\n  [0x2f28, 0x5bf8],\n  // ⼩ → 小\n  [0x2f29, 0x5c0f],\n  // ⼪ → 尢\n  [0x2f2a, 0x5c22],\n  // ⼫ → 尸\n  [0x2f2b, 0x5c38],\n  // ⼬ → 屮\n  [0x2f2c, 0x5c6e],\n  // ⼭ → 山\n  [0x2f2d, 0x5c71],\n  // ⼮ → 巛\n  [0x2f2e, 0x5ddb],\n  // ⼯ → 工\n  [0x2f2f, 0x5de5],\n  // ⼰ → 己\n  [0x2f30, 0x5df1],\n  // ⼱ → 巾\n  [0x2f31, 0x5dfe],\n  // ⼲ → 干\n  [0x2f32, 0x5e72],\n  // ⼳ → 幺\n  [0x2f33, 0x5e7a],\n  // ⼴ → 广\n  [0x2f34, 0x5e7f],\n  // ⼵ → 廴\n  [0x2f35, 0x5ef4],\n  // ⼶ → 廾\n  [0x2f36, 0x5efe],\n  // ⼷ → 弋\n  [0x2f37, 0x5f0b],\n  // ⼸ → 弓\n  [0x2f38, 0x5f13],\n  // ⼹ → 彐\n  [0x2f39, 0x5f50],\n  // ⼺ → 彡\n  [0x2f3a, 0x5f61],\n  // ⼻ → 彳\n  [0x2f3b, 0x5f73],\n  // ⼼ → 心\n  [0x2f3c, 0x5fc3],\n  // ⼽ → 戈\n  [0x2f3d, 0x6208],\n  // ⼾ → 戶\n  [0x2f3e, 0x6236],\n  // ⼿ → 手\n  [0x2f3f, 0x624b],\n  // ⽀ → 支\n  [0x2f40, 0x652f],\n  // ⽁ → 攴\n  [0x2f41, 0x6534],\n  // ⽂ → 文\n  [0x2f42, 0x6587],\n  // ⽃ → 斗\n  [0x2f43, 0x6597],\n  // ⽄ → 斤\n  [0x2f44, 0x65a4],\n  // ⽅ → 方\n  [0x2f45, 0x65b9],\n  // ⽆ → 无\n  [0x2f46, 0x65e0],\n  // ⽇ → 日\n  [0x2f47, 0x65e5],\n  // ⽈ → 曰\n  [0x2f48, 0x66f0],\n  // ⽉ → 月\n  [0x2f49, 0x6708],\n  // ⽊ → 木\n  [0x2f4a, 0x6728],\n  // ⽋ → 欠\n  [0x2f4b, 0x6b20],\n  // ⽌ → 止\n  [0x2f4c, 0x6b62],\n  // ⽍ → 歹\n  [0x2f4d, 0x6b79],\n  // ⽎ → 殳\n  [0x2f4e, 0x6bb3],\n  // ⽏ → 毋\n  [0x2f4f, 0x6bcb],\n  // ⽐ → 比\n  [0x2f50, 0x6bd4],\n  // ⽑ → 毛\n  [0x2f51, 0x6bdb],\n  // ⽒ → 氏\n  [0x2f52, 0x6c0f],\n  // ⽓ → 气\n  [0x2f53, 0x6c14],\n  // ⽔ → 水\n  [0x2f54, 0x6c34],\n  // ⽕ → 火\n  [0x2f55, 0x706b],\n  // ⽖ → 爪\n  [0x2f56, 0x722a],\n  // ⽗ → 父\n  [0x2f57, 0x7236],\n  // ⽘ → 爻\n  [0x2f58, 0x723b],\n  // ⽙ → 爿\n  [0x2f59, 0x723f],\n  // ⽚ → 片\n  [0x2f5a, 0x7247],\n  // ⽛ → 牙\n  [0x2f5b, 0x7259],\n  // ⽜ → 牛\n  [0x2f5c, 0x725b],\n  // ⽝ → 犬\n  [0x2f5d, 0x72ac],\n  // ⽞ → 玄\n  [0x2f5e, 0x7384],\n  // ⽟ → 玉\n  [0x2f5f, 0x7389],\n  // ⽠ → 瓜\n  [0x2f60, 0x74dc],\n  // ⽡ → 瓦\n  [0x2f61, 0x74e6],\n  // ⽢ → 甘\n  [0x2f62, 0x7518],\n  // ⽣ → 生\n  [0x2f63, 0x751f],\n  // ⽤ → 用\n  [0x2f64, 0x7528],\n  // ⽥ → 田\n  [0x2f65, 0x7530],\n  // ⽦ → 疋\n  [0x2f66, 0x758b],\n  // ⽧ → 疒\n  [0x2f67, 0x7592],\n  // ⽨ → 癶\n  [0x2f68, 0x7676],\n  // ⽩ → 白\n  [0x2f69, 0x767d],\n  // ⽪ → 皮\n  [0x2f6a, 0x76ae],\n  // ⽫ → 皿\n  [0x2f6b, 0x76bf],\n  // ⽬ → 目\n  [0x2f6c, 0x76ee],\n  // ⽭ → 矛\n  [0x2f6d, 0x77db],\n  // ⽮ → 矢\n  [0x2f6e, 0x77e2],\n  // ⽯ → 石\n  [0x2f6f, 0x77f3],\n  // ⽰ → 示\n  [0x2f70, 0x793a],\n  // ⽱ → 禸\n  [0x2f71, 0x79b8],\n  // ⽲ → 禾\n  [0x2f72, 0x79be],\n  // ⽳ → 穴\n  [0x2f73, 0x7a74],\n  // ⽴ → 立\n  [0x2f74, 0x7acb],\n  // ⽵ → 竹\n  [0x2f75, 0x7af9],\n  // ⽶ → 米\n  [0x2f76, 0x7c73],\n  // ⽷ → 糸\n  [0x2f77, 0x7cf8],\n  // ⽸ → 缶\n  [0x2f78, 0x7f36],\n  // ⽹ → 网\n  [0x2f79, 0x7f51],\n  // ⽺ → 羊\n  [0x2f7a, 0x7f8a],\n  // ⽻ → 羽\n  [0x2f7b, 0x7fbd],\n  // ⽼ → 老\n  [0x2f7c, 0x8001],\n  // ⽽ → 而\n  [0x2f7d, 0x800c],\n  // ⽾ → 耒\n  [0x2f7e, 0x8012],\n  // ⽿ → 耳\n  [0x2f7f, 0x8033],\n  // ⾀ → 聿\n  [0x2f80, 0x807f],\n  // ⾁ → 肉\n  [0x2f81, 0x8089],\n  // ⾂ → 臣\n  [0x2f82, 0x81e3],\n  // ⾃ → 自\n  [0x2f83, 0x81ea],\n  // ⾄ → 至\n  [0x2f84, 0x81f3],\n  // ⾅ → 臼\n  [0x2f85, 0x81fc],\n  // ⾆ → 舌\n  [0x2f86, 0x820c],\n  // ⾇ → 舛\n  [0x2f87, 0x821b],\n  // ⾈ → 舟\n  [0x2f88, 0x821f],\n  // ⾉ → 艮\n  [0x2f89, 0x826e],\n  // ⾊ → 色\n  [0x2f8a, 0x8272],\n  // ⾋ → 艸\n  [0x2f8b, 0x8278],\n  // ⾌ → 虍\n  [0x2f8c, 0x864d],\n  // ⾍ → 虫\n  [0x2f8d, 0x866b],\n  // ⾎ → 血\n  [0x2f8e, 0x8840],\n  // ⾏ → 行\n  [0x2f8f, 0x884c],\n  // ⾐ → 衣\n  [0x2f90, 0x8863],\n  // ⾑ → 襾\n  [0x2f91, 0x897e],\n  // ⾒ → 見\n  [0x2f92, 0x898b],\n  // ⾓ → 角\n  [0x2f93, 0x89d2],\n  // ⾔ → 言\n  [0x2f94, 0x8a00],\n  // ⾕ → 谷\n  [0x2f95, 0x8c37],\n  // ⾖ → 豆\n  [0x2f96, 0x8c46],\n  // ⾗ → 豕\n  [0x2f97, 0x8c55],\n  // ⾘ → 豸\n  [0x2f98, 0x8c78],\n  // ⾙ → 貝\n  [0x2f99, 0x8c9d],\n  // ⾚ → 赤\n  [0x2f9a, 0x8d64],\n  // ⾛ → 走\n  [0x2f9b, 0x8d70],\n  // ⾜ → 足\n  [0x2f9c, 0x8db3],\n  // ⾝ → 身\n  [0x2f9d, 0x8eab],\n  // ⾞ → 車\n  [0x2f9e, 0x8eca],\n  // ⾟ → 辛\n  [0x2f9f, 0x8f9b],\n  // ⾠ → 辰\n  [0x2fa0, 0x8fb0],\n  // ⾡ → 辵\n  [0x2fa1, 0x8fb5],\n  // ⾢ → 邑\n  [0x2fa2, 0x9091],\n  // ⾣ → 酉\n  [0x2fa3, 0x9149],\n  // ⾤ → 釆\n  [0x2fa4, 0x91c6],\n  // ⾥ → 里\n  [0x2fa5, 0x91cc],\n  // ⾦ → 金\n  [0x2fa6, 0x91d1],\n  // ⾧ → 長\n  [0x2fa7, 0x9577],\n  // ⾨ → 門\n  [0x2fa8, 0x9580],\n  // ⾩ → 阜\n  [0x2fa9, 0x961c],\n  // ⾪ → 隶\n  [0x2faa, 0x96b6],\n  // ⾫ → 隹\n  [0x2fab, 0x96b9],\n  // ⾬ → 雨\n  [0x2fac, 0x96e8],\n  // ⾭ → 靑\n  [0x2fad, 0x9751],\n  // ⾮ → 非\n  [0x2fae, 0x975e],\n  // ⾯ → 面\n  [0x2faf, 0x9762],\n  // ⾰ → 革\n  [0x2fb0, 0x9769],\n  // ⾱ → 韋\n  [0x2fb1, 0x97cb],\n  // ⾲ → 韭\n  [0x2fb2, 0x97ed],\n  // ⾳ → 音\n  [0x2fb3, 0x97f3],\n  // ⾴ → 頁\n  [0x2fb4, 0x9801],\n  // ⾵ → 風\n  [0x2fb5, 0x98a8],\n  // ⾶ → 飛\n  [0x2fb6, 0x98db],\n  // ⾷ → 食\n  [0x2fb7, 0x98df],\n  // ⾸ → 首\n  [0x2fb8, 0x9996],\n  // ⾹ → 香\n  [0x2fb9, 0x9999],\n  // ⾺ → 馬\n  [0x2fba, 0x99ac],\n  // ⾻ → 骨\n  [0x2fbb, 0x9aa8],\n  // ⾼ → 高\n  [0x2fbc, 0x9ad8],\n  // ⾽ → 髟\n  [0x2fbd, 0x9adf],\n  // ⾾ → 鬥\n  [0x2fbe, 0x9b25],\n  // ⾿ → 鬯\n  [0x2fbf, 0x9b2f],\n  // ⿀ → 鬲\n  [0x2fc0, 0x9b32],\n  // ⿁ → 鬼\n  [0x2fc1, 0x9b3c],\n  // ⿂ → 魚\n  [0x2fc2, 0x9b5a],\n  // ⿃ → 鳥\n  [0x2fc3, 0x9ce5],\n  // ⿄ → 鹵\n  [0x2fc4, 0x9e75],\n  // ⿅ → 鹿\n  [0x2fc5, 0x9e7f],\n  // ⿆ → 麥\n  [0x2fc6, 0x9ea5],\n  // ⿇ → 麻\n  [0x2fc7, 0x9ebb],\n  // ⿈ → 黃\n  [0x2fc8, 0x9ec3],\n  // ⿉ → 黍\n  [0x2fc9, 0x9ecd],\n  // ⿊ → 黑\n  [0x2fca, 0x9ed1],\n  // ⿋ → 黹\n  [0x2fcb, 0x9ef9],\n  // ⿌ → 黽\n  [0x2fcc, 0x9efd],\n  // ⿍ → 鼎\n  [0x2fcd, 0x9f0e],\n  // ⿎ → 鼓\n  [0x2fce, 0x9f13],\n  // ⿏ → 鼠\n  [0x2fcf, 0x9f20],\n  // ⿐ → 鼻\n  [0x2fd0, 0x9f3b],\n  // ⿑ → 齊\n  [0x2fd1, 0x9f4a],\n  // ⿒ → 齒\n  [0x2fd2, 0x9f52],\n  // ⿓ → 龍\n  [0x2fd3, 0x9f8d],\n  // ⿔ → 龜\n  [0x2fd4, 0x9f9c],\n  // ⿕ → 龠\n  [0x2fd5, 0x9fa0],\n  // ⺁ → 厂\n  [0x2e81, 0x5382],\n  // ⺃ → 乚\n  [0x2e83, 0x4e5a],\n  // ⺅ → 亻\n  [0x2e85, 0x4ebb],\n  // ⺆ → 冂\n  [0x2e86, 0x5182],\n  // ⺇ → 几\n  [0x2e87, 0x51e0],\n  // ⺉ → 刂\n  [0x2e89, 0x5202],\n  // ⺎ → 兀\n  [0x2e8e, 0x5140],\n  // ⺏ → 尣\n  [0x2e8f, 0x5c23],\n  // ⺐ → 尢\n  [0x2e90, 0x5c22],\n  // ⺑ → 尣\n  [0x2e91, 0x5c23],\n  // ⺒ → 巳\n  [0x2e92, 0x5df3],\n  // ⺓ → 幺\n  [0x2e93, 0x5e7a],\n  // ⺔ → 彑\n  [0x2e94, 0x5f51],\n  // ⺕ → 彐\n  [0x2e95, 0x5f50],\n  // ⺖ → 忄\n  [0x2e96, 0x5fc4],\n  // ⺘ → 扌\n  [0x2e98, 0x624c],\n  // ⺙ → 攵\n  [0x2e99, 0x6535],\n  // ⺛ → 旡\n  [0x2e9b, 0x65e1],\n  // ⺝ → 月\n  [0x2e9d, 0x6708],\n  // ⺞ → 歺\n  [0x2e9e, 0x6b7a],\n  // ⺟ → 母\n  [0x2e9f, 0x6bcd],\n  // ⺠ → 民\n  [0x2ea0, 0x6c11],\n  // ⺡ → 氵\n  [0x2ea1, 0x6c35],\n  // ⺢ → 氺\n  [0x2ea2, 0x6c3a],\n  // ⺣ → 灬\n  [0x2ea3, 0x706c],\n  // ⺤ → 爫\n  [0x2ea4, 0x722b],\n  // ⺥ → 爫\n  [0x2ea5, 0x722b],\n  // ⺦ → 丬\n  [0x2ea6, 0x4e2c],\n  // ⺨ → 犭\n  [0x2ea8, 0x72ad],\n  // ⺫ → 罒\n  [0x2eab, 0x7f52],\n  // ⺯ → 糹\n  [0x2eaf, 0x7cf9],\n  // ⺰ → 纟\n  [0x2eb0, 0x7e9f],\n  // ⺱ → 罓\n  [0x2eb1, 0x7f53],\n  // ⺴ → 㓁\n  [0x2eb4, 0x34c1],\n  // ⺸ → 羋\n  [0x2eb8, 0x7f8b],\n  // ⺹ → 耂\n  [0x2eb9, 0x8002],\n  // ⺺ → 肀\n  [0x2eba, 0x8080],\n  // ⺽ → 臼\n  [0x2ebd, 0x81fc],\n  // ⺾ → 艹\n  [0x2ebe, 0x8279],\n  // ⻁ → 虎\n  [0x2ec1, 0x864e],\n  // ⻂ → 衤\n  [0x2ec2, 0x8864],\n  // ⻃ → 覀\n  [0x2ec3, 0x8980],\n  // ⻄ → 西\n  [0x2ec4, 0x897f],\n  // ⻅ → 见\n  [0x2ec5, 0x89c1],\n  // ⻆ → 角\n  [0x2ec6, 0x89d2],\n  // ⻈ → 讠\n  [0x2ec8, 0x8ba0],\n  // ⻉ → 贝\n  [0x2ec9, 0x8d1d],\n  // ⻋ → 车\n  [0x2ecb, 0x8f66],\n  // ⻐ → 钅\n  [0x2ed0, 0x9485],\n  // ⻑ → 長\n  [0x2ed1, 0x9577],\n  // ⻒ → 镸\n  [0x2ed2, 0x9578],\n  // ⻓ → 长\n  [0x2ed3, 0x957f],\n  // ⻔ → 门\n  [0x2ed4, 0x95e8],\n  // ⻖ → 阝\n  [0x2ed6, 0x961d],\n  // ⻘ → 青\n  [0x2ed8, 0x9752],\n  // ⻙ → 韦\n  [0x2ed9, 0x97e6],\n  // ⻚ → 页\n  [0x2eda, 0x9875],\n  // ⻛ → 风\n  [0x2edb, 0x98ce],\n  // ⻜ → 飞\n  [0x2edc, 0x98de],\n  // ⻝ → 食\n  [0x2edd, 0x98df],\n  // ⻟ → 飠\n  [0x2edf, 0x98e0],\n  // ⻠ → 饣\n  [0x2ee0, 0x9963],\n  // ⻢ → 马\n  [0x2ee2, 0x9a6c],\n  // ⻣ → 骨\n  [0x2ee3, 0x9aa8],\n  // ⻤ → 鬼\n  [0x2ee4, 0x9b3c],\n  // ⻥ → 鱼\n  [0x2ee5, 0x9c7c],\n  // ⻦ → 鸟\n  [0x2ee6, 0x9e1f],\n  // ⻧ → 卤\n  [0x2ee7, 0x5364],\n  // ⻨ → 麦\n  [0x2ee8, 0x9ea6],\n  // ⻩ → 黄\n  [0x2ee9, 0x9ec4],\n  // ⻪ → 黾\n  [0x2eea, 0x9efe],\n  // ⻫ → 斉\n  [0x2eeb, 0x6589],\n  // ⻬ → 齐\n  [0x2eec, 0x9f50],\n  // ⻭ → 歯\n  [0x2eed, 0x6b6f],\n  // ⻮ → 齿\n  [0x2eee, 0x9f7f],\n  // ⻯ → 竜\n  [0x2eef, 0x7adc],\n  // ⻰ → 龙\n  [0x2ef0, 0x9f99],\n  // ⻱ → 龜\n  [0x2ef1, 0x9f9c],\n  // ⻲ → 亀\n  [0x2ef2, 0x4e80],\n  // ⻳ → 龟\n  [0x2ef3, 0x9f9f],\n];\n\nlet RADICAL_TO_KANJI: Map<number, number> | undefined;\n\n// Converts:\n//\n// - half-width katakana to full-width katakana (e.g. ｶﾞｰﾃﾞﾝ → ガーデン)\n// - decomposed characters to their composed equivalents\n//   (e.g. ダイエット → ダイエット)\n// - various enclosed characters into their plain form\n//   (e.g. ㋕ → カ)\n// - various combined characters into their expanded form\n//   (e.g. ㌀ → アパート, ㋿ → 令和)\n// - characters with variation selectors into the base character only\n// - radicals into the equivalent kanji character\n//\n// while maintaining a mapping from output character offsets to input\n// offsets.\nexport function toNormalized(input: string): [string, number[]] {\n  // Lazily create the radical map to that RADICAL_TO_KANJI_CHARS can be\n  // tree-shaken when this function is not being used (unlike arrays, Maps()\n  // always seem to be included because presumably the ctor could have\n  // side-effects).\n  if (!RADICAL_TO_KANJI) {\n    RADICAL_TO_KANJI = new Map(RADICAL_TO_KANJI_CHARS);\n  }\n\n  let inputLengths = [0];\n  let result = '';\n\n  for (let i = 0; i < input.length; ++i) {\n    let c = input.charCodeAt(i);\n\n    // Drop Unicode variation selectors\n    if ((c >= 0xfe00 && c <= 0xfe0f) || (c >= 0xe0100 && c <= 0xe011f)) {\n      inputLengths[result.length] = i + 1;\n      continue;\n    }\n\n    // Half-width to full-width katakana\n    if (c >= 0xff61 && c <= 0xff9f) {\n      c = HANKAKU_KATAKANA_TO_ZENKAKU[c - 0xff61]!;\n    }\n\n    // Decomposed characters (including any half-width katakana which we just\n    // converted since half-width katakana is always decomposed).\n    const prevChar = result.length ? result.charCodeAt(result.length - 1) : 0;\n    if (c === 0x3099) {\n      const composed = VOICED_TO_COMPOSED.get(prevChar);\n      if (composed) {\n        result = result.slice(0, -1);\n        c = composed;\n      }\n    } else if (c === 0x309a) {\n      // Decomposed semi-voiced mark (full-width or half-width)\n      const composed = SEMIVOICED_TO_COMPOSED.get(prevChar);\n      if (composed) {\n        result = result.slice(0, -1);\n        c = composed;\n      }\n    }\n\n    // Look for an expanded character\n    let expanded: string | undefined;\n    if (c >= 0x3300 && c <= 0x3370) {\n      expanded = COMBINED_CHARS_A[c - 0x3300];\n    } else if (c >= 0x337b && c <= 0x337f) {\n      expanded = COMBINED_CHARS_B[c - 0x337b];\n    } else if (c >= 0x3220 && c <= 0x3247) {\n      expanded = ENCLOSED_CHARS_A[c - 0x3220];\n    } else if (c >= 0x3280 && c <= 0x32b0) {\n      expanded = ENCLOSED_CHARS_B[c - 0x3280];\n    } else if (c >= 0x32c0 && c <= 0x32cb) {\n      expanded = ENCLOSED_CHARS_C[c - 0x32c0];\n    } else if (c >= 0x32d0 && c <= 0x32ff) {\n      expanded = ENCLOSED_CHARS_D[c - 0x32d0];\n    }\n\n    // Look for radical characters to map to kanji\n    const radical = !expanded ? RADICAL_TO_KANJI.get(c) : undefined;\n    if (radical) {\n      expanded = String.fromCodePoint(radical);\n    }\n\n    if (expanded) {\n      result += expanded;\n      inputLengths.push(...Array(expanded.length - 1).fill(i));\n    } else {\n      result += String.fromCharCode(c);\n    }\n    inputLengths[result.length] = i + 1;\n  }\n\n  return [result, inputLengths];\n}\n","export class AbortError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, AbortError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n","export type DataSeries = 'words' | 'kanji' | 'radicals' | 'names';\n\nexport const allDataSeries: ReadonlyArray<DataSeries> = [\n  'words',\n  'kanji',\n  'radicals',\n  'names',\n];\n\nexport function isDataSeries(a: unknown): a is DataSeries {\n  return typeof a === 'string' && allDataSeries.includes(a as DataSeries);\n}\n\n// For certain interface actions we lump kanji and radicals together.\n// e.g. If you want to update the kanji data set, you need to update the\n// radicals too since we cross-reference the two.\n//\n// We call the combined set a \"major\" data series.\nexport type MajorDataSeries = 'words' | 'kanji' | 'names';\n\nexport const allMajorDataSeries: ReadonlyArray<MajorDataSeries> = [\n  'words',\n  'kanji',\n  'names',\n];\n\nexport function isMajorDataSeries(a: unknown): a is MajorDataSeries {\n  return (\n    typeof a === 'string' && allMajorDataSeries.includes(a as MajorDataSeries)\n  );\n}\n","export type DownloadErrorCode =\n  | 'VersionFileNotFound'\n  | 'VersionFileNotAccessible'\n  | 'VersionFileInvalid'\n  | 'MajorVersionNotFound'\n  | 'DatabaseFileNotFound'\n  | 'DatabaseFileNotAccessible'\n  | 'DatabaseFileHeaderMissing'\n  | 'DatabaseFileHeaderDuplicate'\n  | 'DatabaseFileVersionMismatch'\n  | 'DatabaseFileInvalidJSON'\n  | 'DatabaseFileInvalidRecord'\n  | 'DatabaseTooOld'\n  | 'Timeout';\n\ntype DownloadErrorOptions = {\n  code: DownloadErrorCode;\n  url?: string;\n};\n\nexport class DownloadError extends Error {\n  code: DownloadErrorCode;\n  url?: string;\n\n  constructor({ code, url }: DownloadErrorOptions, ...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, DownloadError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, DownloadError);\n    }\n\n    this.name = 'DownloadError';\n    this.code = code;\n    this.url = url;\n  }\n}\n","export function isObject(a: unknown): a is Record<string, any> {\n  return typeof a === 'object' && a !== null && !Array.isArray(a);\n}\n","import { AbortError } from './abort-error';\nimport { DownloadError } from './download-error';\nimport { isObject } from './is-object';\n\nexport function isAbortError(e: unknown): e is AbortError {\n  return isObject(e) && 'name' in e && e.name === 'AbortError';\n}\n\nexport function isDownloadError(e: unknown): e is DownloadError {\n  return isObject(e) && 'name' in e && e.name === 'DownloadError';\n}\n\nexport function getErrorMessage(e: unknown): string {\n  return isObject(e) && typeof e.message === 'string' ? e.message : String(e);\n}\n","import { DownloadError } from './download-error';\nimport { isAbortError } from './error-parsing';\n\n// Utility function for fetch that allows setting a timeout as well as taking an\n// AbortController so that the callee can abort the request before that point\n// too.\n//\n// If it times out the `response` Promise will reject with a TimeoutError\n// so that a timeout can be distinguished from a deliberate abort.\nexport async function fetchWithTimeout(\n  resource: RequestInfo,\n  options: {\n    timeout: number | null;\n  } & RequestInit\n): Promise<Response> {\n  // Set up abort controller\n  const controller = new AbortController();\n  const onAbort = () => controller.abort();\n  options?.signal?.addEventListener('abort', onAbort);\n\n  // Set up timeout callback\n  const { timeout } = options;\n  let didTimeout = false;\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  if (timeout && timeout !== Infinity) {\n    timeoutId = setTimeout(() => {\n      didTimeout = true;\n      controller.abort();\n    }, timeout);\n  }\n\n  try {\n    const response = await fetch(resource, {\n      ...options,\n      signal: controller.signal,\n    });\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    return response;\n  } catch (e) {\n    // Check for a timeout\n    if (didTimeout && isAbortError(e)) {\n      throw new DownloadError(\n        {\n          code: 'Timeout',\n          url: typeof resource === 'string' ? resource : resource.url,\n        },\n        `Download timed out after ${timeout! / 1000} second(s).`\n      );\n    }\n\n    throw e;\n  } finally {\n    options?.signal?.removeEventListener('abort', onAbort);\n  }\n}\n","import * as s from 'superstruct';\n\nexport const safeInteger = (): s.Struct<number, null> =>\n  s.refine(s.integer(), 'safeInteger', (value) => Number.isSafeInteger(value));\n","import * as s from 'superstruct';\n\nimport { AbortError } from './abort-error';\nimport { DownloadError } from './download-error';\nimport {\n  getErrorMessage,\n  isAbortError,\n  isDownloadError,\n} from './error-parsing';\nimport { fetchWithTimeout } from './fetch';\nimport { safeInteger } from './validation-helpers';\n\nexport type VersionInfo = s.Infer<typeof VersionInfoStruct>;\n\nexport async function getVersionInfo({\n  baseUrl,\n  series,\n  lang,\n  majorVersion,\n  timeout,\n  signal,\n}: {\n  baseUrl: string;\n  series: string;\n  lang: string;\n  majorVersion: number;\n  timeout: number;\n  signal?: AbortSignal;\n}): Promise<VersionInfo> {\n  const versionInfoFile = await getVersionInfoFile({\n    baseUrl,\n    lang,\n    timeout,\n    signal,\n  });\n\n  // Extract the appropriate database version information\n  const dbVersionInfo = getCurrentVersionInfo(\n    versionInfoFile,\n    series,\n    majorVersion\n  );\n  if (!dbVersionInfo) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid' },\n      `Invalid version object: the requested series, ${series} was not available in this language ('${lang}')`\n    );\n  }\n\n  return dbVersionInfo;\n}\n\nexport function clearCachedVersionInfo() {\n  cachedVersionInfo = undefined;\n}\n\nconst CACHE_TIMEOUT = 3_000 * 60; // Cache version file contents for 3 minutes\n\nlet cachedVersionInfo:\n  | { lang: string; versionInfoFile: VersionInfoFile; accessTime: number }\n  | undefined;\n\nasync function getVersionInfoFile({\n  baseUrl,\n  lang,\n  timeout,\n  signal,\n}: {\n  baseUrl: string;\n  lang: string;\n  timeout: number;\n  signal?: AbortSignal;\n}): Promise<VersionInfoFile> {\n  if (\n    cachedVersionInfo?.lang === lang &&\n    cachedVersionInfo.accessTime > Date.now() - CACHE_TIMEOUT\n  ) {\n    return cachedVersionInfo.versionInfoFile;\n  }\n  cachedVersionInfo = undefined;\n  const accessTime = Date.now();\n\n  let rawVersionInfoFile;\n\n  const url = `${baseUrl}jpdict/reader/version-${lang}.json`;\n\n  let response;\n  try {\n    response = await fetchWithTimeout(url, { signal, timeout });\n  } catch (e) {\n    if (isAbortError(e) || isDownloadError(e)) {\n      throw e;\n    }\n\n    throw new DownloadError(\n      { code: 'VersionFileNotAccessible', url },\n      `Version file ${url} not accessible (${getErrorMessage(e)})`\n    );\n  }\n\n  // Fetch rejects the promise for network errors, but not for HTTP errors :(\n  if (!response.ok) {\n    const code =\n      response.status === 404\n        ? 'VersionFileNotFound'\n        : 'VersionFileNotAccessible';\n    throw new DownloadError(\n      { code, url },\n      `Version file ${url} not accessible (status: ${response.status})`\n    );\n  }\n\n  // Try to parse it\n  try {\n    rawVersionInfoFile = await response.json();\n  } catch (e) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid', url },\n      `Invalid version object: ${\n        getErrorMessage(e) || '(No detailed error message)'\n      }`\n    );\n  }\n\n  if (signal?.aborted) {\n    throw new AbortError();\n  }\n\n  const versionInfoFile = parseVersionInfoFile(rawVersionInfoFile);\n\n  cachedVersionInfo = { lang, versionInfoFile, accessTime };\n\n  return versionInfoFile;\n}\n\nconst VersionInfoStruct = s.type({\n  major: s.min(safeInteger(), 1),\n  minor: s.min(safeInteger(), 0),\n  patch: s.min(safeInteger(), 0),\n  parts: s.optional(s.min(safeInteger(), 1)),\n  databaseVersion: s.optional(s.string()),\n  dateOfCreation: s.nonempty(s.string()),\n});\n\nconst VersionInfoFileStruct = s.record(\n  s.string(),\n  s.record(s.string(), VersionInfoStruct)\n);\n\ntype VersionInfoFile = s.Infer<typeof VersionInfoFileStruct>;\n\nfunction parseVersionInfoFile(rawVersionInfoFile: unknown): VersionInfoFile {\n  if (!rawVersionInfoFile) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid' },\n      'Empty version info file'\n    );\n  }\n\n  const [error, versionInfoFile] = s.validate(\n    rawVersionInfoFile,\n    VersionInfoFileStruct\n  );\n\n  if (error) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid' },\n      `Version file was invalid: ${error}`\n    );\n  }\n\n  return versionInfoFile;\n}\n\nfunction getCurrentVersionInfo(\n  versionInfoFile: VersionInfoFile,\n  series: string,\n  majorVersion: number\n): VersionInfo | null {\n  if (!(series in versionInfoFile)) {\n    return null;\n  }\n\n  if (!(majorVersion in versionInfoFile[series])) {\n    throw new DownloadError(\n      { code: 'MajorVersionNotFound' },\n      `No ${majorVersion}.x version information for ${series} data`\n    );\n  }\n\n  return versionInfoFile[series][majorVersion];\n}\n","import { AbortError } from './abort-error';\nimport { DownloadError } from './download-error';\nimport {\n  getErrorMessage,\n  isAbortError,\n  isDownloadError,\n} from './error-parsing';\n\nexport async function* ljsonStreamIterator({\n  stream,\n  signal,\n  timeout,\n  url,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  signal: AbortSignal;\n  timeout: number;\n  url: string;\n}): AsyncIterableIterator<object> {\n  const reader = stream.getReader();\n  const lineEnd = /\\n|\\r|\\r\\n/m;\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n\n  const parseLine = (line: string): any => {\n    try {\n      return JSON.parse(line);\n    } catch {\n      try {\n        reader.releaseLock();\n      } catch {\n        // Ignore\n      }\n      throw new DownloadError(\n        { code: 'DatabaseFileInvalidJSON', url },\n        `Could not parse JSON in database file: ${line}`\n      );\n    }\n  };\n\n  while (true) {\n    let readResult: ReadableStreamReadResult<Uint8Array>;\n    try {\n      readResult = await waitWithTimeout({\n        promise: reader.read(),\n        timeout,\n        url,\n      });\n    } catch (e) {\n      try {\n        reader.releaseLock();\n      } catch {\n        // Ignore\n      }\n\n      if (isAbortError(e) || isDownloadError(e)) {\n        throw e;\n      }\n\n      throw new DownloadError(\n        { code: 'DatabaseFileNotAccessible', url },\n        `Could not read database file (${getErrorMessage(e)})`\n      );\n    }\n\n    const { done, value } = readResult;\n\n    if (done) {\n      buffer += decoder.decode();\n      if (buffer) {\n        yield parseLine(buffer);\n        buffer = '';\n      }\n\n      return;\n    }\n\n    buffer += decoder.decode(value, { stream: true });\n    const lines = buffer.split(lineEnd);\n\n    // We don't know if the last line is actually the last line of the\n    // input or not until we get done: true so we just assume it is\n    // a partial line for now.\n    buffer = lines.length ? lines.splice(lines.length - 1, 1)[0] : '';\n\n    for (const line of lines) {\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n\n      if (!line) {\n        continue;\n      }\n\n      yield parseLine(line);\n    }\n  }\n}\n\nfunction waitWithTimeout<T>({\n  promise,\n  timeout,\n  url,\n}: {\n  promise: Promise<T>;\n  timeout: number;\n  url?: string;\n}): Promise<T> {\n  let timeoutId: number;\n\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    timeoutId = self.setTimeout(() => {\n      clearTimeout(timeoutId);\n      reject(\n        new DownloadError(\n          { code: 'Timeout', url },\n          `Download timed out after ${timeout / 1000} seconds.`\n        )\n      );\n    }, timeout);\n  });\n\n  return Promise.race([promise, timeoutPromise]).then((val: T) => {\n    clearTimeout(timeoutId);\n    return val;\n  });\n}\n","/**\n * A helper to remove certain fields from an object.\n */\nexport function stripFields<T extends object, K extends keyof T>(\n  o: T,\n  fields: K[]\n): Omit<T, K> {\n  const result: Partial<T> = { ...(<object>o) };\n  for (const field of fields) {\n    delete result[field];\n  }\n  return <Omit<T, K>>result;\n}\n","export type VersionNumber = {\n  major: number;\n  minor: number;\n  patch: number;\n};\n\nexport function compareVersions(\n  a: Readonly<VersionNumber>,\n  b: Readonly<VersionNumber>\n): number {\n  if (a.major < b.major) {\n    return -1;\n  }\n  if (a.major > b.major) {\n    return 1;\n  }\n  if (a.minor < b.minor) {\n    return -1;\n  }\n  if (a.minor > b.minor) {\n    return 1;\n  }\n  if (a.patch < b.patch) {\n    return -1;\n  }\n  if (a.patch > b.patch) {\n    return 1;\n  }\n  return 0;\n}\n","import * as s from 'superstruct';\n\nimport { DataSeries } from './data-series';\nimport { DataVersion } from './data-version';\nimport { DownloadError } from './download-error';\nimport { getVersionInfo } from './download-version-info';\nimport {\n  getErrorMessage,\n  isAbortError,\n  isDownloadError,\n} from './error-parsing';\nimport { fetchWithTimeout } from './fetch';\nimport { isObject } from './is-object';\nimport { ljsonStreamIterator } from './ljson-stream';\nimport { PartInfo } from './part-info';\nimport { stripFields } from './utils';\nimport { safeInteger } from './validation-helpers';\nimport { compareVersions, VersionNumber } from './version-number';\n\n// Produces an async interator of DownloadEvents\n\n//\n// Event types\n//\n\nexport type DownloadEvent =\n  | ResetEvent\n  | DownloadStartEvent\n  | DownloadEndEvent\n  | FileStartEvent\n  | FileEndEvent\n  | RecordEvent;\n\nexport type ResetEvent = { type: 'reset' };\nexport type DownloadStartEvent = { type: 'downloadstart'; files: number };\nexport type DownloadEndEvent = { type: 'downloadend' };\nexport type FileStartEvent = {\n  type: 'filestart';\n  version: DataVersion;\n  totalRecords: number;\n};\nexport type FileEndEvent = { type: 'fileend' };\nexport type RecordEvent = {\n  type: 'record';\n  mode: 'add' | 'change' | 'delete';\n  record: Record<string, unknown>;\n};\n\n//\n// Helper types\n//\n\nexport type CurrentVersion = VersionNumber & {\n  partInfo?: PartInfo;\n};\n\n//\n// Configuration constants\n//\n\nconst BASE_URL = 'https://data.10ten.life/';\n\nconst DOWNLOAD_TIMEOUT = 20_000;\n\nexport type DownloadOptions = {\n  series: DataSeries;\n  majorVersion: number;\n  currentVersion?: CurrentVersion;\n  lang: string;\n  signal: AbortSignal;\n};\n\nexport async function hasLanguage({\n  series,\n  majorVersion,\n  lang,\n  signal,\n}: {\n  baseUrl?: string;\n  series: DataSeries;\n  majorVersion: number;\n  lang: string;\n  signal?: AbortSignal;\n}): Promise<boolean> {\n  try {\n    const result = await getVersionInfo({\n      baseUrl: BASE_URL,\n      series,\n      lang,\n      majorVersion,\n      timeout: DOWNLOAD_TIMEOUT,\n      signal,\n    });\n    return !!result;\n  } catch {\n    return false;\n  }\n}\n\nexport async function* download({\n  series,\n  majorVersion,\n  currentVersion,\n  lang,\n  signal,\n}: DownloadOptions): AsyncIterableIterator<DownloadEvent> {\n  const versionInfo = await getVersionInfo({\n    baseUrl: BASE_URL,\n    series,\n    lang,\n    majorVersion,\n    timeout: DOWNLOAD_TIMEOUT,\n    signal,\n  });\n\n  const { files, type } = getDownloadList({\n    currentVersion,\n    latestVersion: versionInfo,\n  });\n\n  if (type === 'reset' && currentVersion) {\n    yield { type: 'reset' };\n  }\n\n  yield { type: 'downloadstart', files: files.length };\n\n  for (const file of files) {\n    yield* getEvents({\n      baseUrl: BASE_URL,\n      series,\n      lang,\n      version: file.version,\n      signal,\n      format: file.format,\n      partInfo: file.partInfo,\n    });\n  }\n\n  yield { type: 'downloadend' };\n}\n\ntype DownloadFileSpec =\n  | {\n      format: 'full';\n      version: VersionNumber;\n      partInfo?: PartInfo;\n    }\n  | {\n      format: 'patch';\n      version: VersionNumber;\n      partInfo?: never;\n    };\n\nfunction getDownloadList({\n  currentVersion,\n  latestVersion,\n}: {\n  currentVersion?: CurrentVersion;\n  latestVersion: {\n    major: number;\n    minor: number;\n    patch: number;\n    parts?: number;\n  };\n}): {\n  type: 'reset' | 'update';\n  files: Array<DownloadFileSpec>;\n} {\n  // Check the local database is not ahead of what we're about to download\n  //\n  // This can happen when the version file gets cached because we can\n  // download a more recent version (e.g. we have DevTools open with \"skip\n  // cache\" ticked) and then try again to fetch the file but get the older\n  // version.\n  if (currentVersion && compareVersions(currentVersion, latestVersion) > 0) {\n    const versionToString = ({ major, minor, patch }: VersionNumber) =>\n      `${major}.${minor}.${patch}`;\n    throw new DownloadError(\n      { code: 'DatabaseTooOld' },\n      `Database version (${versionToString(\n        latestVersion\n      )}) is older than the current version (${versionToString(\n        currentVersion\n      )})`\n    );\n  }\n\n  // If there's no current version or if there's been a change in major/minor\n  // version, reset any existing data.\n  let downloadType =\n    !currentVersion ||\n    compareVersions(currentVersion, { ...latestVersion, patch: 0 }) < 0\n      ? ('reset' as const)\n      : ('update' as const);\n\n  // Furthermore, if we're resuming a multi-part initial download but there have\n  // since been more than 10 new patches to that minor version, we should just\n  // start over.\n  //\n  // This will probably be faster and, more importantly, it means we can archive\n  // the full (i.e. non-patch) version files of any minor version that is more\n  // than 10 patches old without having to worry about really out-of-date\n  // clients later requesting those parts.\n  if (\n    downloadType === 'update' &&\n    currentVersion?.partInfo &&\n    latestVersion.patch - currentVersion.patch > 10\n  ) {\n    downloadType = 'reset';\n  }\n\n  // There are four cases to consider:\n  //\n  // 1. We are doing a full download of a partitioned data series\n  //    i.e. we need to download all the parts from 0 to `parts - 1`.\n  //\n  // 2. We are doing a full download of an unpartitioned data series\n  //    i.e. we simply need to download the data file for the current patch\n  //    level.\n  //\n  // 3. We are resuming a full download\n  //    i.e. we need to download all the remaining parts _and_ any\n  //    subsequent patches.\n  //\n  // 4. We are patching an existing series\n  //    i.e. we need to download each patch from the one after the current\n  //    version up to and including the latest patch.\n\n  // Case 1: Partitioned series\n  if (downloadType === 'reset' && latestVersion.parts) {\n    const files: Array<DownloadFileSpec> = [];\n    let nextPart = 1;\n\n    while (nextPart <= latestVersion.parts) {\n      files.push({\n        format: 'full',\n        version: {\n          major: latestVersion.major,\n          minor: latestVersion.minor,\n          patch: latestVersion.patch,\n        },\n        partInfo: {\n          part: nextPart,\n          parts: latestVersion.parts,\n        },\n      });\n      nextPart++;\n    }\n\n    return { type: downloadType, files };\n  }\n\n  // Case 2: Unpartitioned series\n  if (downloadType === 'reset') {\n    return {\n      type: downloadType,\n      files: [\n        {\n          format: 'full',\n          version: {\n            major: latestVersion.major,\n            minor: latestVersion.minor,\n            patch: latestVersion.patch,\n          },\n        },\n      ],\n    };\n  }\n\n  // The following is just to help TypeScript realise that `currentVersion` must\n  // be defined if `downloadType` is 'update'.\n  if (!currentVersion) {\n    throw new Error(\n      'We should have already dealt with the initial download case'\n    );\n  }\n\n  // Case 3 (part 1): Resumed partitioned series\n  const files: Array<DownloadFileSpec> = [];\n  if (currentVersion.partInfo) {\n    let nextPart = currentVersion.partInfo.part + 1;\n\n    while (nextPart <= currentVersion.partInfo.parts) {\n      files.push({\n        format: 'full',\n        version: {\n          major: currentVersion.major,\n          minor: currentVersion.minor,\n          patch: currentVersion.patch,\n        },\n        partInfo: {\n          part: nextPart,\n          parts: currentVersion.partInfo.parts,\n        },\n      });\n      nextPart++;\n    }\n  }\n\n  // Case 3 (part 2) and case 4: Updating a series\n  let nextPatch = currentVersion.patch + 1;\n  while (nextPatch <= latestVersion.patch) {\n    files.push({\n      format: 'patch',\n      version: {\n        major: latestVersion.major,\n        minor: latestVersion.minor,\n        patch: nextPatch,\n      },\n    });\n    nextPatch++;\n  }\n\n  return { type: downloadType, files };\n}\n\ntype GetEventsOptions = {\n  baseUrl: string;\n  series: DataSeries;\n  lang: string;\n  version: VersionNumber;\n  signal: AbortSignal;\n  format: 'full' | 'patch';\n  partInfo?: PartInfo;\n};\n\nconst HeaderLineStruct = s.type({\n  type: s.literal('header'),\n  version: s.type({\n    major: s.min(safeInteger(), 1),\n    minor: s.min(safeInteger(), 0),\n    patch: s.min(safeInteger(), 0),\n    databaseVersion: s.optional(s.string()),\n    dateOfCreation: s.nonempty(s.string()),\n  }),\n  records: s.min(safeInteger(), 0),\n  part: s.optional(s.min(safeInteger(), 0)),\n  format: s.enums(['patch', 'full']),\n});\n\nconst PatchLineStruct = s.type({\n  _: s.enums(['+', '-', '~']),\n});\n\nasync function* getEvents({\n  baseUrl,\n  series,\n  lang,\n  version,\n  signal,\n  format,\n  partInfo,\n}: GetEventsOptions): AsyncIterableIterator<DownloadEvent> {\n  const dottedVersion = `${version.major}.${version.minor}.${version.patch}`;\n  const commonUrlStart = `${baseUrl}jpdict/reader/${series}/${lang}/${dottedVersion}`;\n  const url =\n    format === 'patch'\n      ? `${commonUrlStart}-patch.jsonl`\n      : partInfo\n        ? `${commonUrlStart}-${partInfo.part}.jsonl`\n        : `${commonUrlStart}.jsonl`;\n\n  let response;\n  try {\n    response = await fetchWithTimeout(url, {\n      signal,\n      timeout: DOWNLOAD_TIMEOUT,\n    });\n  } catch (e) {\n    if (isAbortError(e) || isDownloadError(e)) {\n      throw e;\n    }\n\n    throw new DownloadError(\n      { code: 'DatabaseFileNotFound', url },\n      `Database file ${url} not accessible (${getErrorMessage(e)})`\n    );\n  }\n\n  if (!response.ok) {\n    const code =\n      response.status === 404\n        ? 'DatabaseFileNotFound'\n        : 'DatabaseFileNotAccessible';\n    throw new DownloadError(\n      { code, url },\n      `Database file ${url} not accessible (status: ${response.status})`\n    );\n  }\n\n  if (response.body === null) {\n    throw new DownloadError(\n      { code: 'DatabaseFileNotAccessible', url },\n      'Body is null'\n    );\n  }\n\n  let headerRead = false;\n\n  for await (const line of ljsonStreamIterator({\n    stream: response.body,\n    signal,\n    timeout: DOWNLOAD_TIMEOUT,\n    url,\n  })) {\n    if (s.is(line, HeaderLineStruct)) {\n      if (headerRead) {\n        throw new DownloadError(\n          { code: 'DatabaseFileHeaderDuplicate', url },\n          `Got duplicate database header: ${JSON.stringify(line)}`\n        );\n      }\n\n      if (compareVersions(line.version, version) !== 0) {\n        throw new DownloadError(\n          { code: 'DatabaseFileVersionMismatch', url },\n          `Got mismatched database versions (Expected: ${JSON.stringify(\n            version\n          )} got: ${JSON.stringify(line.version)})`\n        );\n      }\n\n      if (line.part !== partInfo?.part) {\n        throw new DownloadError(\n          { code: 'DatabaseFileVersionMismatch', url },\n          `Got mismatched database part number (Expected: ${partInfo?.part}, got: ${line.part})`\n        );\n      }\n\n      if (line.format !== format) {\n        throw new DownloadError(\n          { code: 'DatabaseFileVersionMismatch', url },\n          `Expected to get a data file in ${format} format but got '${line.format}' format instead`\n        );\n      }\n\n      let fileStartEvent: FileStartEvent;\n      if (line.part !== undefined) {\n        fileStartEvent = {\n          type: 'filestart',\n          totalRecords: line.records,\n          version: {\n            ...line.version,\n            partInfo: {\n              part: line.part,\n              parts: partInfo!.parts,\n            },\n            lang,\n          },\n        };\n      } else {\n        fileStartEvent = {\n          type: 'filestart',\n          totalRecords: line.records,\n          version: {\n            ...line.version,\n            lang,\n          },\n        };\n      }\n\n      yield fileStartEvent;\n\n      headerRead = true;\n    } else if (format === 'patch' && s.is(line, PatchLineStruct)) {\n      if (!headerRead) {\n        throw new DownloadError(\n          { code: 'DatabaseFileHeaderMissing', url },\n          `Expected database version but got ${JSON.stringify(line)}`\n        );\n      }\n\n      const mode =\n        line._ === '+' ? 'add' : line._ === '-' ? 'delete' : 'change';\n      yield { type: 'record', mode, record: stripFields(line, ['_']) };\n    } else if (format === 'full' && isObject(line)) {\n      if (!headerRead) {\n        throw new DownloadError(\n          { code: 'DatabaseFileHeaderMissing', url },\n          `Expected database version but got ${JSON.stringify(line)}`\n        );\n      }\n\n      if ('_' in line) {\n        throw new DownloadError(\n          { code: 'DatabaseFileInvalidRecord', url },\n          `Got patch-like '_' field in non-patch record: ${JSON.stringify(\n            line\n          )}`\n        );\n      }\n\n      yield { type: 'record', mode: 'add', record: line };\n    } else {\n      // If we encounter anything unexpected we should fail.\n      //\n      // It might be tempting to make this \"robust\" by ignoring unrecognized\n      // inputs but that could effectively leave us in an invalid state where\n      // we claim to be update-to-date with database version X but are\n      // actually missing some of the records.\n      //\n      // If anything unexpected shows up we should fail so we can debug\n      // exactly what happenned.\n      throw new DownloadError(\n        { code: 'DatabaseFileInvalidRecord', url },\n        `Got unexpected record: ${JSON.stringify(line)}`\n      );\n    }\n  }\n\n  yield { type: 'fileend' };\n}\n","export class QuotaExceededError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, QuotaExceededError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, QuotaExceededError);\n    }\n\n    this.name = 'QuotaExceededError';\n    this.message = 'The current transaction exceeded its quota limitations.';\n  }\n}\n","export function isKanji(str: string): boolean {\n  const c = str.codePointAt(0) || 0;\n  return (\n    (c >= 0x4e00 && c <= 0x9fea) ||\n    /* Ideographs extension A */\n    (c >= 0x3400 && c <= 0x4dbf) ||\n    /* Ideographs extension B&C&D&E */\n    (c >= 0x20000 && c <= 0x2ebef)\n  );\n}\n\nexport function hasHiragana(str: string): boolean {\n  return [...str]\n    .map((c) => c.codePointAt(0)!)\n    .some((c) => c >= 0x3041 && c <= 0x309f);\n}\n","import { kanaToHiragana } from '@birchill/normal-jp';\n\nimport {\n  KanjiDownloadDeleteRecord,\n  KanjiDownloadRecord,\n  NameDownloadDeleteRecord,\n  NameDownloadRecord,\n  RadicalDownloadDeleteRecord,\n  RadicalDownloadRecord,\n  WordDownloadDeleteRecord,\n  WordDownloadRecord,\n} from './download-types';\nimport { hasHiragana } from './japanese';\nimport { Overwrite } from './type-helpers';\nimport { KanjiMeta, ReadingMeta } from './words';\n\n// ----------------------------------------------------------------------------\n//\n// Words\n//\n// ----------------------------------------------------------------------------\n\nexport type WordStoreRecord = Overwrite<\n  WordDownloadRecord,\n  {\n    // When transporting via JSON we replace nulls with 0s but we store them as\n    // nulls.\n    rm?: Array<null | ReadingMeta>;\n    km?: Array<null | KanjiMeta>;\n\n    // r and k strings with all kana converted to hiragana\n    h: Array<string>;\n    // Individual from k split out into separate strings\n    kc: Array<string>;\n    // Gloss tokens (English and localized)\n    gt_en: Array<string>;\n    gt_l: Array<string>;\n  }\n>;\n\nexport function toWordStoreRecord(record: WordDownloadRecord): WordStoreRecord {\n  const result = {\n    ...record,\n    rm: record.rm\n      ? record.rm.map((elem) => (elem === 0 ? null : elem))\n      : undefined,\n    km: record.km\n      ? record.km.map((elem) => (elem === 0 ? null : elem))\n      : undefined,\n    h: keysToHiragana([...(record.k || []), ...record.r]),\n    kc: [],\n    gt_en: [],\n    gt_l: [],\n  };\n\n  // I'm not sure if IndexedDB preserves properties with undefined values\n  // (I think it does, although JSON does not) but just to be sure we don't\n  // end up storing unnecessary values, drop any undefined properties we may\n  // have just added.\n  if (!result.rm) {\n    delete result.rm;\n  }\n  if (!result.km) {\n    delete result.km;\n  }\n\n  return result;\n}\n\nexport function getStoreIdForWordRecord(\n  record: WordDownloadRecord | WordDownloadDeleteRecord\n): number {\n  return record.id;\n}\n\n// ----------------------------------------------------------------------------\n//\n// Names\n//\n// ----------------------------------------------------------------------------\n\nexport type NameStoreRecord = NameDownloadRecord & {\n  // r and k strings with all kana converted to hiragana\n  h: Array<string>;\n};\n\nexport function toNameStoreRecord(entry: NameDownloadRecord): NameStoreRecord {\n  return {\n    ...entry,\n    h: keysToHiragana([...(entry.k || []), ...entry.r]),\n  };\n}\n\nexport function getStoreIdForNameRecord(\n  record: NameDownloadRecord | NameDownloadDeleteRecord\n): number {\n  return record.id;\n}\n\n// ----------------------------------------------------------------------------\n//\n// Kanji\n//\n// ----------------------------------------------------------------------------\n\nexport type KanjiStoreRecord = Overwrite<\n  KanjiDownloadRecord,\n  {\n    // Define a variant on KanjiEntryLine that turns 'c' into a number\n    c: number;\n  }\n>;\n\nexport function toKanjiStoreRecord(\n  record: KanjiDownloadRecord\n): KanjiStoreRecord {\n  return {\n    ...record,\n    c: record.c.codePointAt(0) as number,\n  };\n}\n\nexport function getStoreIdForKanjiRecord(\n  record: KanjiDownloadRecord | KanjiDownloadDeleteRecord\n): number {\n  return record.c.codePointAt(0) as number;\n}\n\n// ----------------------------------------------------------------------------\n//\n// Radicals\n//\n// ----------------------------------------------------------------------------\n\nexport type RadicalStoreRecord = RadicalDownloadRecord;\n\nexport function toRadicalStoreRecord(\n  record: RadicalDownloadRecord\n): RadicalStoreRecord {\n  return record;\n}\n\nexport function getStoreIdForRadicalRecord(\n  record: RadicalDownloadRecord | RadicalDownloadDeleteRecord\n): string {\n  return record.id;\n}\n\n// ---------------------------------------------------------------------------\n//\n// Common\n//\n// ---------------------------------------------------------------------------\n\nfunction keysToHiragana(values: Array<string>): Array<string> {\n  // We only add hiragana keys for words that actually have some hiragana in\n  // them. Any purely kanji keys should match on the 'k' index and won't benefit\n  // from converting the input and source to hiragana so we can match them.\n  return Array.from(\n    new Set(values.map((value) => kanaToHiragana(value)).filter(hasHiragana))\n  );\n}\n","import {\n  DBSchema,\n  deleteDB,\n  IDBPDatabase,\n  IDBPTransaction,\n  openDB,\n  StoreNames,\n} from 'idb';\n\nimport { DataSeries } from './data-series';\nimport { DataVersion } from './data-version';\nimport { DownloadDeleteRecord, DownloadRecord } from './download-types';\nimport { QuotaExceededError } from './quota-exceeded-error';\nimport {\n  getStoreIdForKanjiRecord,\n  getStoreIdForNameRecord,\n  getStoreIdForRadicalRecord,\n  getStoreIdForWordRecord,\n  KanjiStoreRecord,\n  NameStoreRecord,\n  RadicalStoreRecord,\n  toKanjiStoreRecord,\n  toNameStoreRecord,\n  toRadicalStoreRecord,\n  toWordStoreRecord,\n  WordStoreRecord,\n} from './store-types';\nimport { stripFields } from './utils';\n\ninterface DataVersionRecord extends DataVersion {\n  id: 1 | 2 | 3 | 4;\n}\n\nfunction getVersionKey(series: DataSeries): 1 | 2 | 3 | 4 {\n  switch (series) {\n    case 'words':\n      return 4;\n\n    case 'kanji':\n      return 1;\n\n    case 'radicals':\n      return 2;\n\n    case 'names':\n      return 3;\n  }\n}\n\nexport interface JpdictSchema extends DBSchema {\n  words: {\n    key: number;\n    value: WordStoreRecord;\n    indexes: {\n      k: Array<string>;\n      r: Array<string>;\n      h: Array<string>;\n      kc: Array<string>;\n      gt_en: Array<string>;\n      gt_l: Array<string>;\n    };\n  };\n  kanji: {\n    key: number;\n    value: KanjiStoreRecord;\n    indexes: {\n      'r.on': Array<string>;\n      'r.kun': Array<string>;\n      'r.na': Array<string>;\n    };\n  };\n  radicals: {\n    key: string;\n    value: RadicalStoreRecord;\n    indexes: {\n      r: number;\n      b: string;\n      k: string;\n    };\n  };\n  names: {\n    key: number;\n    value: NameStoreRecord;\n    indexes: {\n      k: Array<string>;\n      r: Array<string>;\n      h: Array<string>;\n    };\n  };\n  version: {\n    key: number;\n    value: DataVersionRecord;\n  };\n}\n\nexport type RecordUpdate<T extends DataSeries> =\n  | {\n      mode: 'add';\n      record: DownloadRecord<T>;\n    }\n  | {\n      mode: 'change';\n      record: DownloadRecord<T>;\n    }\n  | {\n      mode: 'delete';\n      record: DownloadDeleteRecord<T>;\n    };\n\nexport class JpdictStore {\n  private state: 'idle' | 'opening' | 'open' | 'error' | 'deleting' = 'idle';\n  private db: IDBPDatabase<JpdictSchema> | undefined;\n  private openPromise: Promise<IDBPDatabase<JpdictSchema>> | undefined;\n  private deletePromise: Promise<void> | undefined;\n\n  protected toStoreRecord: {\n    [series in DataSeries]: (\n      record: DownloadRecord<series>\n    ) => JpdictSchema[series]['value'];\n  } = {\n    words: toWordStoreRecord,\n    names: toNameStoreRecord,\n    kanji: toKanjiStoreRecord,\n    radicals: toRadicalStoreRecord,\n  };\n\n  protected getStoreId: {\n    [series in DataSeries]: (\n      record: DownloadDeleteRecord<series>\n    ) => JpdictSchema[series]['key'];\n  } = {\n    words: getStoreIdForWordRecord,\n    names: getStoreIdForNameRecord,\n    kanji: getStoreIdForKanjiRecord,\n    radicals: getStoreIdForRadicalRecord,\n  };\n\n  async open(): Promise<IDBPDatabase<JpdictSchema>> {\n    if (this.state === 'open') {\n      return this.db!;\n    }\n\n    if (this.state === 'opening') {\n      return this.openPromise!;\n    }\n\n    if (this.state === 'deleting') {\n      await this.deletePromise!;\n    }\n\n    this.state = 'opening';\n\n    /* eslint @typescript-eslint/no-this-alias: 0 */\n    const self = this;\n\n    this.openPromise = openDB<JpdictSchema>('jpdict', 4, {\n      upgrade(\n        db: IDBPDatabase<JpdictSchema>,\n        oldVersion: number,\n        _newVersion: number | null,\n        transaction: IDBPTransaction<\n          JpdictSchema,\n          StoreNames<JpdictSchema>[],\n          'versionchange'\n        >\n      ) {\n        if (oldVersion < 1) {\n          const kanjiTable = db.createObjectStore<'kanji'>('kanji', {\n            keyPath: 'c',\n          });\n          kanjiTable.createIndex('r.on', 'r.on', { multiEntry: true });\n          kanjiTable.createIndex('r.kun', 'r.kun', { multiEntry: true });\n          kanjiTable.createIndex('r.na', 'r.na', { multiEntry: true });\n\n          const radicalsTable = db.createObjectStore<'radicals'>('radicals', {\n            keyPath: 'id',\n          });\n          radicalsTable.createIndex('r', 'r');\n          radicalsTable.createIndex('b', 'b');\n          radicalsTable.createIndex('k', 'k');\n\n          db.createObjectStore<'version'>('version', {\n            keyPath: 'id',\n          });\n        }\n        if (oldVersion < 2) {\n          const namesTable = db.createObjectStore<'names'>('names', {\n            keyPath: 'id',\n          });\n          namesTable.createIndex('k', 'k', { multiEntry: true });\n          namesTable.createIndex('r', 'r', { multiEntry: true });\n        }\n        if (oldVersion < 3) {\n          const namesTable = transaction.objectStore('names');\n          namesTable.createIndex('h', 'h', { multiEntry: true });\n        }\n        if (oldVersion < 4) {\n          const wordsTable = db.createObjectStore<'words'>('words', {\n            keyPath: 'id',\n          });\n          wordsTable.createIndex('k', 'k', { multiEntry: true });\n          wordsTable.createIndex('r', 'r', { multiEntry: true });\n\n          wordsTable.createIndex('h', 'h', { multiEntry: true });\n\n          wordsTable.createIndex('kc', 'kc', { multiEntry: true });\n          wordsTable.createIndex('gt_en', 'gt_en', { multiEntry: true });\n          wordsTable.createIndex('gt_l', 'gt_l', { multiEntry: true });\n        }\n      },\n      blocked() {\n        console.log('Opening blocked');\n      },\n      blocking() {\n        if (self.db) {\n          try {\n            self.db.close();\n          } catch {\n            // Ignore\n          }\n          self.db = undefined;\n          self.state = 'idle';\n        }\n      },\n    }).then((db) => {\n      self.db = db;\n      self.state = 'open';\n      return db;\n    });\n\n    try {\n      await this.openPromise;\n    } catch (e) {\n      this.state = 'error';\n      throw e;\n    } finally {\n      // This is not strictly necessary, but it doesn't hurt.\n      this.openPromise = undefined;\n    }\n\n    // IndexedDB doesn't provide a way to check if a database exists\n    // so we just unconditionally try to delete the old database, in case it\n    // exists, _every_ _single_ _time_.\n    //\n    // We don't bother waiting on it or reporting errors, however.\n    deleteDB('KanjiStore').catch(() => {});\n\n    return this.db!;\n  }\n\n  async close() {\n    if (this.state === 'idle') {\n      return;\n    }\n\n    if (this.state === 'deleting') {\n      return this.deletePromise;\n    }\n\n    if (this.state === 'opening') {\n      await this.openPromise;\n    }\n\n    this.db?.close();\n    this.db = undefined;\n    this.state = 'idle';\n  }\n\n  async destroy() {\n    if (this.state !== 'idle') {\n      await this.close();\n    }\n\n    this.state = 'deleting';\n\n    this.deletePromise = deleteDB('jpdict', {\n      blocked() {\n        console.log('Deletion blocked');\n      },\n    });\n\n    await this.deletePromise;\n\n    this.deletePromise = undefined;\n    this.state = 'idle';\n  }\n\n  async clearSeries(series: DataSeries) {\n    const db = await this.open();\n\n    const tx = db.transaction([series, 'version'], 'readwrite');\n\n    try {\n      // Drop the table\n      const targetTable = tx.objectStore(series);\n      await targetTable.clear();\n\n      // Drop the version record\n      const versionTable = tx.objectStore('version');\n      const id = getVersionKey(series);\n      void versionTable.delete(id);\n    } catch (e) {\n      console.error(`Error deleting data series '${series}'`, e);\n\n      // Ignore the abort from the transaction\n      tx.done.catch(() => {});\n      try {\n        tx.abort();\n      } catch {\n        // Ignore exceptions from aborting the transaction.\n        // This can happen is the transaction has already been aborted by this\n        // point.\n      }\n\n      throw e;\n    }\n\n    await tx.done;\n  }\n\n  async getDataVersion(series: DataSeries): Promise<DataVersion | null> {\n    await this.open();\n\n    const key = getVersionKey(series);\n    const versionDoc = await this.db!.get('version', key);\n    if (!versionDoc) {\n      return null;\n    }\n\n    return stripFields(versionDoc, ['id']);\n  }\n\n  async updateDataVersion({\n    series,\n    version,\n  }: {\n    series: DataSeries;\n    version: DataVersion;\n  }) {\n    await this.open();\n\n    try {\n      const id = getVersionKey(series);\n      await this.db!.put('version', { ...version, id });\n    } catch (e) {\n      console.error(\n        `Error updating version of '${series}' to ${JSON.stringify(version)}`,\n        e\n      );\n\n      throw e;\n    }\n  }\n\n  async updateSeries<T extends DataSeries>({\n    series,\n    updates,\n  }: {\n    series: T;\n    updates: Array<RecordUpdate<T>>;\n  }) {\n    await this.open();\n\n    const tx = this.db!.transaction(series, 'readwrite', {\n      durability: 'relaxed',\n    });\n    const table = tx.store;\n\n    try {\n      // The important thing here is NOT to wait on the result of each\n      // put/delete. This speeds up the operation by an order of magnitude or\n      // two and is Dexie's secret sauce.\n      //\n      // See: https://jsfiddle.net/birtles/vx4urLkw/17/\n      for (const update of updates) {\n        if (update.mode === 'delete') {\n          void table.delete(this.getStoreId[series](update.record));\n        } else {\n          void table.put(this.toStoreRecord[series](update.record));\n        }\n      }\n\n      await tx.done;\n    } catch (e) {\n      console.error(`Error updating series ${series}`, e);\n\n      // Ignore the abort from the transaction\n      tx.done.catch(() => {});\n      try {\n        tx.abort();\n      } catch {\n        // As above, ignore exceptions from aborting the transaction.\n      }\n\n      // We sometimes encounter a situation where Firefox throws an Error with\n      // an undefined message. All we have to go by is a user's screenshot that\n      // shows the following in the browser console:\n      //\n      //   Error: undefined\n      //\n      // We _think_ this happens in some cases where the disk space quota is\n      // exceeded so we try to detect that case and throw an actual\n      // QuotaExceededError instead.\n      if (isVeryGenericError(e) && (await atOrNearQuota())) {\n        console.info(\n          'Detected generic error masking a quota exceeded situation'\n        );\n        throw new QuotaExceededError();\n      }\n\n      throw e;\n    }\n  }\n\n  // Test API\n  async _getKanji(kanji: Array<number>): Promise<Array<KanjiStoreRecord>> {\n    await this.open();\n\n    const result: Array<KanjiStoreRecord> = [];\n    {\n      const tx = this.db!.transaction('kanji');\n      for (const c of kanji) {\n        const record = await tx.store.get(c);\n        if (record) {\n          result.push(record);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n\n// We occasionally get these obscure errors when running IndexedDB in an\n// extension context where the error returned serializes as simply:\n//\n//   Error: undefined\n//\n// Our current theory is that it occurs when we hit an out-of-quota situation.\nfunction isVeryGenericError(e: any): boolean {\n  if (typeof e === 'undefined') {\n    return true;\n  }\n\n  // Look for an Error without a name or an object with name 'Error' but no\n  // message\n  return (\n    (e instanceof Error && !e?.name) || (e?.name === 'Error' && !e?.message)\n  );\n}\n\nasync function atOrNearQuota(): Promise<boolean> {\n  try {\n    const estimate = await self.navigator.storage.estimate();\n    return (\n      typeof estimate.usage !== 'undefined' &&\n      typeof estimate.quota !== 'undefined' &&\n      estimate.usage / estimate.quota > 0.9\n    );\n  } catch {\n    return false;\n  }\n}\n","import { DataSeries } from './data-series';\nimport { UpdateEvent } from './update-events';\nimport { UpdateState } from './update-state';\n\nexport type UpdateAction =\n  | UpdateEvent\n  | { type: 'start'; series: DataSeries }\n  | { type: 'end'; checkDate: Date }\n  | { type: 'error'; checkDate: Date | null };\n\nexport function reducer(state: UpdateState, action: UpdateAction): UpdateState {\n  switch (action.type) {\n    case 'start':\n      return {\n        type: 'checking',\n        series: action.series,\n        lastCheck: state.lastCheck,\n      };\n\n    case 'end':\n      return {\n        type: 'idle',\n        lastCheck: action.checkDate,\n      };\n\n    case 'error':\n      return { type: 'idle', lastCheck: action.checkDate || state.lastCheck };\n\n    case 'updatestart':\n    case 'updateend':\n      // Nothing to do here since the 'start' and 'end' events take care of\n      // initialization and returning to the 'idle' state.\n      //\n      // (Furthermore, the 'start' event comes before the 'updatestart'\n      // event--which only comes after we've fetched the version file and\n      // confirmed there is something to update--so it's a more suitable queue\n      // for transitioning to the 'checking' state.)\n      return state;\n\n    case 'filestart':\n      if (state.type === 'idle') {\n        console.error('Should not get filestart event in the idle state');\n        return state;\n      }\n\n      return {\n        type: 'updating',\n        series: state.series,\n        version: action.version,\n        fileProgress: 0,\n        totalProgress: state.type === 'updating' ? state.totalProgress : 0,\n        lastCheck: state.lastCheck,\n      };\n\n    case 'fileend':\n      // Nothing to do here -- the 'progress' action will take care of updating\n      // the progress and the 'end' action will take care returning to the\n      // 'idle' state once all is complete.\n      return state;\n\n    case 'progress':\n      if (state.type !== 'updating') {\n        console.error(`Should not get progress event in '${state.type}' state`);\n        return state;\n      }\n\n      return {\n        ...state,\n        fileProgress: action.fileProgress,\n        totalProgress: action.totalProgress,\n      };\n\n    case 'parseerror':\n      // Nothing to do here\n      return state;\n  }\n}\n","import * as s from 'superstruct';\n\nimport { DataSeries } from './data-series';\nimport { KanjiMiscInfo, KanjiReading, KanjiRecord, Radical } from './kanji';\nimport { NameRecord, NameTranslation } from './names';\nimport { RadicalRecord } from './radicals';\nimport { Overwrite } from './type-helpers';\nimport { safeInteger } from './validation-helpers';\nimport {\n  Accent,\n  CrossReference,\n  KanjiMeta,\n  LangSource,\n  ReadingMeta,\n  WordRecord,\n  WordSense,\n} from './words';\n\n// ----------------------------------------------------------------------------\n//\n// Words\n//\n// ----------------------------------------------------------------------------\n\nconst KanjiMetaSchema: s.Describe<KanjiMeta> = s.type({\n  i: s.optional(s.array(s.string())),\n  p: s.optional(s.array(s.string())),\n  bv: s.optional(s.string()),\n  bg: s.optional(s.string()),\n});\n\nconst AccentSchema: s.Describe<Accent> = s.type({\n  i: s.min(safeInteger(), 0),\n  pos: s.optional(s.array(s.string())),\n});\n\nconst ReadingMetaSchema: s.Describe<ReadingMeta> = s.type({\n  i: s.optional(s.array(s.string())),\n  p: s.optional(s.array(s.string())),\n  app: s.optional(s.min(safeInteger(), 0)),\n  a: s.optional(s.union([s.min(safeInteger(), 0), s.array(AccentSchema)])),\n  bv: s.optional(s.string()),\n  bg: s.optional(s.string()),\n});\n\n// The following typing is because Describe struggles with union types\nconst CrossReferenceSchema: s.Struct<s.Describe<CrossReference>['TYPE'], null> =\n  s.union([\n    s.type({\n      k: s.nonempty(s.string()),\n      sense: s.optional(s.min(safeInteger(), 0)),\n    }),\n    s.type({\n      r: s.nonempty(s.string()),\n      sense: s.optional(s.min(safeInteger(), 0)),\n    }),\n    s.type({\n      k: s.nonempty(s.string()),\n      r: s.string(),\n      sense: s.optional(s.min(safeInteger(), 0)),\n    }),\n  ]);\n\nconst LangSourceSchema: s.Describe<LangSource> = s.type({\n  lang: s.optional(s.nonempty(s.string())),\n  src: s.optional(s.string()),\n  // The following should be:\n  //\n  //   part: s.optional(s.literal(true)),\n  //   wasei: s.optional(s.literal(true)),\n  //\n  // But Describe doesn't seem to handle optional boolean literals so we try\n  // this way for now.\n  part: s.union([s.literal(true), s.literal(undefined)]),\n  wasei: s.union([s.literal(true), s.literal(undefined)]),\n});\n\nconst WordSenseSchema: s.Describe<WordSense> = s.type({\n  g: s.nonempty(s.array(s.nonempty(s.string()))),\n  gt: s.optional(s.min(safeInteger(), 1)),\n  lang: s.optional(s.nonempty(s.string())),\n  kapp: s.optional(s.min(safeInteger(), 0)),\n  rapp: s.optional(s.min(safeInteger(), 0)),\n  pos: s.optional(s.array(s.string())),\n  field: s.optional(s.array(s.string())),\n  misc: s.optional(s.array(s.string())),\n  dial: s.optional(s.array(s.string())),\n  inf: s.optional(s.nonempty(s.string())),\n  xref: s.optional(s.nonempty(s.array(CrossReferenceSchema))),\n  ant: s.optional(s.nonempty(s.array(CrossReferenceSchema))),\n  lsrc: s.optional(s.nonempty(s.array(LangSourceSchema))),\n});\n\nconst WordIdSchema = s.min(safeInteger(), 1);\n\nexport type WordDownloadRecord = Overwrite<\n  WordRecord,\n  {\n    km?: Array<0 | KanjiMeta>;\n    rm?: Array<0 | ReadingMeta>;\n    s: Array<WordSense>;\n  }\n>;\n\nconst WordDownloadRecordSchema: s.Describe<WordDownloadRecord> = s.type({\n  id: WordIdSchema,\n  k: s.optional(s.nonempty(s.array(s.string()))),\n  km: s.optional(s.nonempty(s.array(s.union([s.literal(0), KanjiMetaSchema])))),\n  r: s.array(s.nonempty(s.nonempty(s.string()))),\n  rm: s.optional(\n    s.nonempty(s.array(s.union([s.literal(0), ReadingMetaSchema])))\n  ),\n  s: s.array(WordSenseSchema),\n});\n\nexport function validateWordDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, WordDownloadRecord] {\n  return s.validate(record, WordDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type WordDownloadDeleteRecord = Pick<WordDownloadRecord, 'id'>;\n\nconst WordDownloadDeleteRecordSchema: s.Describe<WordDownloadDeleteRecord> =\n  s.type({\n    id: WordIdSchema,\n  });\n\nexport function validateWordDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, WordDownloadDeleteRecord] {\n  return s.validate(record, WordDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Names\n//\n// ----------------------------------------------------------------------------\n\nconst NameTranslationSchema: s.Describe<NameTranslation> = s.type({\n  type: s.optional(s.array(s.string())),\n  det: s.array(s.nonempty(s.string())),\n  cf: s.optional(s.array(s.nonempty(s.string()))),\n});\n\nconst NameIdSchema = s.min(safeInteger(), 1);\n\nexport type NameDownloadRecord = NameRecord;\n\nconst NameDownloadRecordSchema: s.Describe<NameDownloadRecord> = s.type({\n  id: NameIdSchema,\n  k: s.optional(s.array(s.nonempty(s.string()))),\n  r: s.nonempty(s.array(s.nonempty(s.string()))),\n  tr: s.array(NameTranslationSchema),\n});\n\nexport function validateNameDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, NameDownloadRecord] {\n  return s.validate(record, NameDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type NameDownloadDeleteRecord = Pick<NameDownloadRecord, 'id'>;\n\nconst NameDownloadDeleteRecordSchema: s.Describe<NameDownloadDeleteRecord> =\n  s.type({\n    id: NameIdSchema,\n  });\n\nexport function validateNameDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, NameDownloadDeleteRecord] {\n  return s.validate(record, NameDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Kanji\n//\n// ----------------------------------------------------------------------------\n\nconst ReadingsStruct: s.Describe<KanjiReading> = s.type({\n  on: s.optional(s.array(s.string())),\n  kun: s.optional(s.array(s.string())),\n  na: s.optional(s.array(s.string())),\n  py: s.optional(s.array(s.string())),\n});\n\nconst RadicalStruct: s.Describe<Radical> = s.type({\n  x: s.min(safeInteger(), 0),\n  nelson: s.optional(s.min(safeInteger(), 0)),\n  name: s.optional(s.array(s.string())),\n  var: s.optional(s.string()),\n});\n\nconst MiscSchema: s.Describe<KanjiMiscInfo> = s.type({\n  gr: s.optional(safeInteger()),\n  sc: s.min(safeInteger(), 1),\n  freq: s.optional(s.min(safeInteger(), 0)),\n  // The following three items should really have a minimum value of 1, but in\n  // the interests of being (a bit) forgiving in what we accept, we allow 0 too.\n  jlpt: s.optional(s.min(safeInteger(), 0)),\n  jlptn: s.optional(s.min(safeInteger(), 0)),\n  kk: s.optional(s.min(safeInteger(), 0)),\n  // As with jlpt(n), we allow 0 here even though we expect WaniKani levels to\n  // be between 1 and 60.\n  wk: s.optional(s.min(safeInteger(), 0)),\n  meta: s.optional(s.array(s.string())),\n});\n\nconst KanjiIdSchema = s.nonempty(s.string());\n\nexport type KanjiDownloadRecord = KanjiRecord;\n\nconst KanjiDownloadRecordSchema: s.Describe<KanjiDownloadRecord> = s.type({\n  c: KanjiIdSchema,\n  r: ReadingsStruct,\n  m: s.array(s.string()),\n  m_lang: s.optional(s.string()),\n  rad: RadicalStruct,\n  refs: s.record(s.string(), s.union([s.string(), s.number()])),\n  misc: MiscSchema,\n  st: s.optional(s.string()),\n  comp: s.optional(s.string()),\n  var: s.optional(s.array(s.string())),\n  cf: s.optional(s.union([s.string(), s.array(s.string())])),\n});\n\nexport function validateKanjiDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, KanjiDownloadRecord] {\n  return s.validate(record, KanjiDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type KanjiDownloadDeleteRecord = Pick<KanjiDownloadRecord, 'c'>;\n\nconst KanjiDownloadDeleteRecordSchema: s.Describe<KanjiDownloadDeleteRecord> =\n  s.type({\n    c: KanjiIdSchema,\n  });\n\nexport function validateKanjiDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, KanjiDownloadDeleteRecord] {\n  return s.validate(record, KanjiDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Radicals\n//\n// ----------------------------------------------------------------------------\n\nconst RadicalIdSchema = s.nonempty(s.string());\n\nexport type RadicalDownloadRecord = Overwrite<\n  RadicalRecord,\n  {\n    // We don't validate the posn field for downloaded records because we don't\n    // want to force a major version bump every time we add a posn field.\n    posn?: string;\n  }\n>;\n\nconst RadicalDownloadRecordSchema: s.Describe<RadicalDownloadRecord> = s.type({\n  id: RadicalIdSchema,\n  r: s.min(safeInteger(), 1),\n  b: s.optional(s.nonempty(s.string())),\n  k: s.optional(s.nonempty(s.string())),\n  pua: s.optional(safeInteger()),\n  s: safeInteger(),\n  na: s.array(s.nonempty(s.string())),\n  posn: s.optional(s.nonempty(s.string())),\n  m: s.array(s.nonempty(s.string())),\n  m_lang: s.optional(s.nonempty(s.string())),\n});\n\nexport function validateRadicalDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, RadicalDownloadRecord] {\n  return s.validate(record, RadicalDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type RadicalDownloadDeleteRecord = Pick<RadicalDownloadRecord, 'id'>;\n\nconst RadicalDownloadDeleteRecordSchema: s.Describe<RadicalDownloadDeleteRecord> =\n  s.type({\n    id: RadicalIdSchema,\n  });\n\nexport function validateRadicalDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, RadicalDownloadDeleteRecord] {\n  return s.validate(record, RadicalDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Combined types\n//\n// ----------------------------------------------------------------------------\n\ntype DownloadRecordMapping = {\n  words: WordDownloadRecord;\n  names: NameDownloadRecord;\n  kanji: KanjiDownloadRecord;\n  radicals: RadicalDownloadRecord;\n};\n\nexport type DownloadRecord<T extends DataSeries> = DownloadRecordMapping[T];\n\nconst validateDownloadRecordMapping: {\n  [Series in DataSeries]: (\n    record: unknown\n  ) => [Error, undefined] | [undefined, DownloadRecord<Series>];\n} = {\n  words: validateWordDownloadRecord,\n  names: validateNameDownloadRecord,\n  kanji: validateKanjiDownloadRecord,\n  radicals: validateRadicalDownloadRecord,\n};\n\nexport function validateDownloadRecord<Series extends DataSeries>({\n  series,\n  record,\n}: {\n  series: Series;\n  record: unknown;\n}) {\n  return validateDownloadRecordMapping[series](record);\n}\n\n// -- Delete variant --\n\ntype DownloadDeleteRecordMapping = {\n  words: WordDownloadDeleteRecord;\n  names: NameDownloadDeleteRecord;\n  kanji: KanjiDownloadDeleteRecord;\n  radicals: RadicalDownloadDeleteRecord;\n};\n\nexport type DownloadDeleteRecord<T extends DataSeries> =\n  DownloadDeleteRecordMapping[T];\n\nconst validateDownloadDeleteRecordMapping: {\n  [Series in DataSeries]: (\n    record: unknown\n  ) => [Error, undefined] | [undefined, DownloadDeleteRecord<Series>];\n} = {\n  words: validateWordDownloadDeleteRecord,\n  names: validateNameDownloadDeleteRecord,\n  kanji: validateKanjiDownloadDeleteRecord,\n  radicals: validateRadicalDownloadDeleteRecord,\n};\n\nexport function validateDownloadDeleteRecord<Series extends DataSeries>({\n  series,\n  record,\n}: {\n  series: Series;\n  record: unknown;\n}) {\n  return validateDownloadDeleteRecordMapping[series](record);\n}\n","import { AbortError } from './abort-error';\nimport { DataSeries } from './data-series';\nimport { DataVersion } from './data-version';\nimport {\n  validateDownloadDeleteRecord,\n  validateDownloadRecord,\n} from './download-types';\nimport { CurrentVersion, download, RecordEvent } from './download';\nimport { JpdictStore, RecordUpdate } from './store';\nimport { UpdateEvent } from './update-events';\n\nexport type UpdateCallback = (action: UpdateEvent) => void;\n\n// The number of records to queue up before updating the store.\n//\n// For IndexedDB, bigger batches are faster since we can just wait on the\n// transaction to complete rather than each individual put or delete and that\n// tends to be dramatically faster.\n//\n// However, making the batches too big introduces janky progress because\n// typically the download speed is faster than the update speed so we try to\n// make sure the batches aren't _too_ big.\n//\n// (In case that doesn't make sense, suppose we use a batch size of 10,000.\n// Often, downloading 10,000 records takes a fraction of a second while on many\n// systems putting 10,000 records into IndexedDB takes a second or two. If we\n// dispatch progress events based on the 'record' events we get from the\n// download and then do a big database update we'll get a series of quick\n// progress events and then a big pause while we update.\n//\n// We could try to dispatch progress events while we're updating too--in fact,\n// we used to do just that--but it's simpler if we can just have one type of\n// progress event and dispatch it fairly consistently.)\nconst BATCH_SIZE = 4000;\n\n// Don't update the progress until it has changed by at least 1%.\nconst MAX_PROGRESS_RESOLUTION = 0.01;\n\nexport async function update({\n  callback,\n  currentVersion,\n  lang,\n  majorVersion,\n  series,\n  signal,\n  store,\n}: {\n  callback: UpdateCallback;\n  currentVersion?: CurrentVersion;\n  lang: string;\n  majorVersion: number;\n  signal: AbortSignal;\n  series: DataSeries;\n  store: JpdictStore;\n}): Promise<void> {\n  return doUpdate({\n    callback,\n    currentVersion,\n    lang,\n    majorVersion,\n    series,\n    signal,\n    store,\n  });\n}\n\nasync function doUpdate<Series extends DataSeries>({\n  callback,\n  currentVersion,\n  lang,\n  majorVersion,\n  series,\n  signal,\n  store,\n}: {\n  callback: UpdateCallback;\n  currentVersion?: CurrentVersion;\n  lang: string;\n  majorVersion: number;\n  signal: AbortSignal;\n  series: Series;\n  store: JpdictStore;\n}) {\n  // Clear the database if the current version is empty in case we have records\n  // lying around from an incomplete initial download.\n  if (!currentVersion) {\n    await store.clearSeries(series);\n  }\n\n  let currentFile = 0;\n  let currentFileVersion: DataVersion | undefined;\n  let totalFiles = 0;\n\n  let currentRecord = 0;\n  let totalRecords = 0;\n  let updates: Array<RecordUpdate<Series>> = [];\n\n  let lastReportedTotalProgress: number | undefined;\n\n  for await (const event of download({\n    series,\n    majorVersion,\n    currentVersion,\n    lang,\n    signal,\n  })) {\n    if (signal.aborted) {\n      throw new AbortError();\n    }\n\n    switch (event.type) {\n      case 'reset':\n        await store.clearSeries(series);\n        break;\n\n      case 'downloadstart':\n        totalFiles = event.files;\n        callback({ type: 'updatestart' });\n        break;\n\n      case 'downloadend':\n        callback({ type: 'updateend' });\n        break;\n\n      case 'filestart':\n        currentFile++;\n        currentRecord = 0;\n        totalRecords = event.totalRecords;\n        currentFileVersion = event.version;\n        callback({ type: 'filestart', version: event.version });\n        if (currentFile === 1) {\n          callback({ type: 'progress', fileProgress: 0, totalProgress: 0 });\n          lastReportedTotalProgress = 0;\n        }\n        break;\n\n      case 'fileend':\n        {\n          // Save remaining batched items\n          if (updates.length) {\n            await store.updateSeries({ series, updates });\n            updates = [];\n          }\n\n          // Commit version info\n          //\n          // If this is the last part in a multi-part series, however, don't\n          // write the part info.\n          const versionToWrite = currentFileVersion!;\n          if (\n            versionToWrite.partInfo &&\n            versionToWrite.partInfo.part === versionToWrite.partInfo.parts\n          ) {\n            delete versionToWrite.partInfo;\n          }\n          await store.updateDataVersion({\n            series,\n            version: versionToWrite,\n          });\n\n          // Final progress event\n          const totalProgress = currentFile / totalFiles;\n          callback({\n            type: 'progress',\n            fileProgress: 1,\n            totalProgress,\n          });\n          lastReportedTotalProgress = totalProgress;\n\n          callback({ type: 'fileend', version: versionToWrite });\n        }\n        break;\n\n      case 'record':\n        {\n          const [error, update] = parseRecordEvent({ series, event });\n          if (error) {\n            callback({\n              type: 'parseerror',\n              message: error.message,\n              record: event.record,\n            });\n          } else {\n            updates.push(update);\n            if (updates.length >= BATCH_SIZE) {\n              await store.updateSeries({ series, updates });\n              updates = [];\n            }\n          }\n\n          // We update the total number of records even if we failed to validate\n          // the incoming record because the progress should continue even if\n          // all the records are bad.\n          currentRecord++;\n\n          // If we have processed enough records to pass the progress event\n          // threshold, dispatch a progress event.\n          const fileProgress = currentRecord / totalRecords;\n          const totalProgress = (currentFile - 1 + fileProgress) / totalFiles;\n          if (\n            // Don't dispatch a 100% file progress event until after we've\n            // updated the version database (as part of processing the 'fileend'\n            // event.)\n            fileProgress < 1 &&\n            (lastReportedTotalProgress === undefined ||\n              totalProgress - lastReportedTotalProgress >\n                MAX_PROGRESS_RESOLUTION)\n          ) {\n            callback({ type: 'progress', fileProgress, totalProgress });\n            lastReportedTotalProgress = totalProgress;\n          }\n        }\n        break;\n    }\n  }\n}\n\nfunction parseRecordEvent<Series extends DataSeries>({\n  series,\n  event,\n}: {\n  series: Series;\n  event: RecordEvent;\n}): [Error, undefined] | [undefined, RecordUpdate<Series>] {\n  const { mode, record: unvalidatedRecord } = event;\n  if (mode === 'delete') {\n    const [err, record] = validateDownloadDeleteRecord({\n      series,\n      record: unvalidatedRecord,\n    });\n    return err ? [err, undefined] : [undefined, { mode, record }];\n  }\n\n  const [err, record] = validateDownloadRecord({\n    series,\n    record: unvalidatedRecord,\n  });\n  return err ? [err, undefined] : [undefined, { mode, record }];\n}\n","import { jsonEqualish } from '@birchill/json-equalish';\n\nimport { AbortError } from './abort-error';\nimport {\n  allDataSeries,\n  allMajorDataSeries,\n  DataSeries,\n  MajorDataSeries,\n} from './data-series';\nimport { DataSeriesState } from './data-series-state';\nimport { DataVersion } from './data-version';\nimport { hasLanguage } from './download';\nimport { JpdictStore } from './store';\nimport { UpdateAction, reducer as updateReducer } from './update-state-reducer';\nimport { UpdateState } from './update-state';\nimport { update } from './update';\n\nconst MAJOR_VERSION: { [series in DataSeries]: number } = {\n  kanji: 4,\n  radicals: 4,\n  names: 3,\n  words: 2,\n};\n\nexport type ChangeTopic = 'stateupdated' | 'deleted';\nexport type ChangeCallback = (topic: ChangeTopic) => void;\n\ntype DataSeriesInfo = {\n  state: DataSeriesState;\n  version: DataVersion | null;\n  updateState: UpdateState;\n};\n\ntype InProgressUpdate = {\n  promise: Promise<void>;\n  controller: AbortController;\n  lang: string;\n};\n\nexport class JpdictIdb {\n  kanji: DataSeriesInfo = {\n    state: 'init',\n    version: null,\n    updateState: { type: 'idle', lastCheck: null },\n  };\n  radicals: DataSeriesInfo = {\n    state: 'init',\n    version: null,\n    updateState: { type: 'idle', lastCheck: null },\n  };\n  names: DataSeriesInfo = {\n    state: 'init',\n    version: null,\n    updateState: { type: 'idle', lastCheck: null },\n  };\n  words: DataSeriesInfo = {\n    state: 'init',\n    version: null,\n    updateState: { type: 'idle', lastCheck: null },\n  };\n\n  // This is currently only public so we can stub it in unit tests\n  store: JpdictStore;\n\n  private verbose = false;\n  private readyPromise: Promise<any>;\n  private changeListeners: ChangeCallback[] = [];\n  private inProgressUpdates: {\n    [series in MajorDataSeries]: InProgressUpdate | undefined;\n  } = { words: undefined, kanji: undefined, names: undefined };\n\n  // -------------------------------------------------------------------------\n  //\n  // Initialization\n  //\n  // -------------------------------------------------------------------------\n\n  constructor({ verbose = false }: { verbose?: boolean } = {}) {\n    this.store = new JpdictStore();\n    this.verbose = verbose;\n\n    // Fetch initial state\n    this.readyPromise = (async () => {\n      try {\n        for (const series of allDataSeries) {\n          // (2022-04-20 w/ TS 4.6.3) The following cast is needed to convince\n          // TS that `store` has been initialized.\n          //\n          // See https://stackoverflow.com/questions/51675833/typescript-error-property-is-used-before-being-assigned\n          const dataVersion = await (this as this).store.getDataVersion(series);\n          this.updateDataVersion(series, dataVersion);\n        }\n      } catch (e) {\n        console.error('Failed to open IndexedDB');\n        console.error(e);\n\n        // Reset state and version information\n        for (const series of allDataSeries) {\n          this[series] = {\n            ...this[series],\n            state: 'unavailable',\n            version: null,\n          };\n        }\n\n        throw e;\n      } finally {\n        this.notifyChanged('stateupdated');\n      }\n    })();\n  }\n\n  get ready() {\n    return this.readyPromise;\n  }\n\n  // -------------------------------------------------------------------------\n  //\n  // Destruction\n  //\n  // -------------------------------------------------------------------------\n\n  async destroy() {\n    try {\n      await this.ready;\n    } catch {\n      // Ignore, we're going to destroy anyway\n    }\n\n    const hasData = allDataSeries.some(\n      (key: DataSeries) => this[key].state !== 'unavailable'\n    );\n    if (hasData) {\n      await this.store.destroy();\n    }\n\n    const hasInProgressUpdate = allMajorDataSeries.some(\n      (s) => typeof this.inProgressUpdates[s] !== 'undefined'\n    );\n    if (this.verbose && hasInProgressUpdate) {\n      console.info('Destroying database while there is an in-progress update');\n    }\n\n    this.store = new JpdictStore();\n    for (const series of allDataSeries) {\n      this[series] = {\n        state: 'empty',\n        version: null,\n        updateState: { type: 'idle', lastCheck: null },\n      };\n    }\n    this.notifyChanged('deleted');\n  }\n\n  async deleteSeries(series: MajorDataSeries) {\n    if (this.inProgressUpdates[series]) {\n      this.cancelUpdate(series);\n    }\n\n    await this.store.clearSeries(series);\n    this.updateDataVersion(series, null);\n\n    if (series === 'kanji') {\n      await this.store.clearSeries('radicals');\n      this.updateDataVersion('radicals', null);\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  //\n  // Change listeners\n  //\n  // -------------------------------------------------------------------------\n\n  addChangeListener(callback: ChangeCallback) {\n    if (this.changeListeners.indexOf(callback) !== -1) {\n      return;\n    }\n    this.changeListeners.push(callback);\n  }\n\n  removeChangeListener(callback: ChangeCallback) {\n    const index = this.changeListeners.indexOf(callback);\n    if (index === -1) {\n      return;\n    }\n    this.changeListeners.splice(index, 1);\n  }\n\n  private notifyChanged(topic: ChangeTopic) {\n    const changeListeners = this.changeListeners.slice();\n    for (const callback of changeListeners) {\n      callback(topic);\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  //\n  // Updating\n  //\n  // -------------------------------------------------------------------------\n\n  async update({ series, lang }: { series: MajorDataSeries; lang: string }) {\n    // Check for an existing update\n    const existingUpdate = this.inProgressUpdates[series];\n    if (existingUpdate && existingUpdate.lang === lang) {\n      if (this.verbose) {\n        console.info(\n          `Detected overlapping update for '${series}' series. Re-using existing update.`\n        );\n      }\n\n      return existingUpdate.promise;\n    }\n\n    // Cancel the existing update since the language doesn't match\n    if (existingUpdate) {\n      if (this.verbose) {\n        console.info(\n          `Cancelling existing update for '${series}' series since the requested language (${lang}) doesn't match that of the existing update(${existingUpdate.lang})`\n        );\n      }\n\n      this.cancelUpdate(series);\n    }\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n    const updatePromise = (async () => {\n      await this.ready;\n\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n\n      switch (series) {\n        case 'words':\n          await this.doUpdate({ series: 'words', signal, lang });\n          break;\n\n        case 'kanji':\n          await this.doUpdate({ series: 'kanji', signal, lang });\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n          await this.doUpdate({ series: 'radicals', signal, lang });\n          break;\n\n        case 'names':\n          await this.doUpdate({ series: 'names', signal, lang });\n          break;\n      }\n\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n    })();\n\n    this.inProgressUpdates[series] = {\n      lang,\n      controller,\n      promise: updatePromise\n        .catch(() => {}) // Ignore errors from this Promise chain\n        .finally(() => {\n          // Reset the in-progress update but only if the language wasn't\n          // changed (since we don't want to clobber a new request).\n          if (\n            this.inProgressUpdates[series] &&\n            this.inProgressUpdates[series]!.lang === lang\n          ) {\n            this.inProgressUpdates[series] = undefined;\n          }\n          this.notifyChanged('stateupdated');\n        }),\n    };\n\n    return updatePromise;\n  }\n\n  private async doUpdate({\n    series,\n    signal,\n    lang: requestedLang,\n  }: {\n    series: DataSeries;\n    signal: AbortSignal;\n    lang: string;\n  }) {\n    let wroteSomething = false;\n\n    const reducer = (action: UpdateAction) => {\n      this[series].updateState = updateReducer(\n        this[series].updateState,\n        action\n      );\n\n      if (action.type === 'fileend') {\n        wroteSomething = true;\n        this.updateDataVersion(series, action.version);\n      }\n\n      if (action.type === 'parseerror' && this.verbose) {\n        console.warn('Encountered parse error', action.message, action.record);\n      }\n\n      this.notifyChanged('stateupdated');\n    };\n\n    // Check if we have been canceled while waiting to become ready\n    if (signal.aborted) {\n      reducer({ type: 'error', checkDate: null });\n      throw new AbortError();\n    }\n\n    const checkDate = new Date();\n\n    try {\n      reducer({ type: 'start', series });\n\n      // Check if the requested language is available for this series, and\n      // fallback to English if not.\n      const lang =\n        requestedLang !== 'en' &&\n        (await hasLanguage({\n          series,\n          lang: requestedLang,\n          majorVersion: MAJOR_VERSION[series],\n          signal,\n        }))\n          ? requestedLang\n          : 'en';\n\n      // If the language we have stored (if any) differs from the language we\n      // are about to update to, clobber the existing data for this series.\n      const currentLang: string | undefined =\n        this[series].state === 'ok' ? this[series].version?.lang : undefined;\n      if (currentLang && currentLang !== lang) {\n        if (this.verbose) {\n          console.info(\n            `Clobbering '${series}' data to change lang to '${lang}'`\n          );\n        }\n        await this.store.clearSeries(series);\n        this.updateDataVersion(series, null);\n      }\n\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n\n      if (this.verbose) {\n        console.info(\n          `Requesting download for '${series}' series with current version ${JSON.stringify(\n            this[series].version || undefined\n          )}`\n        );\n      }\n\n      await update({\n        callback: reducer,\n        currentVersion: this[series].version || undefined,\n        lang,\n        majorVersion: MAJOR_VERSION[series],\n        signal,\n        series,\n        store: this.store,\n      });\n\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n\n      reducer({ type: 'end', checkDate });\n    } catch (e) {\n      // We should only update the last-check date if we actually made some\n      // sort of update.\n      reducer({\n        type: 'error',\n        checkDate: wroteSomething ? checkDate : null,\n      });\n      throw e;\n    }\n  }\n\n  private updateDataVersion(series: DataSeries, version: DataVersion | null) {\n    if (\n      this[series].state !== 'init' &&\n      this[series].state !== 'unavailable' &&\n      jsonEqualish(this[series].version, version)\n    ) {\n      return;\n    }\n\n    this[series].version = version;\n    this[series].state = version ? 'ok' : 'empty';\n\n    this.notifyChanged('stateupdated');\n  }\n\n  cancelUpdate(series: MajorDataSeries): boolean {\n    const inProgressUpdate = this.inProgressUpdates[series];\n    if (!inProgressUpdate) {\n      return false;\n    }\n\n    inProgressUpdate.controller.abort();\n\n    return true;\n  }\n\n  // -------------------------------------------------------------------------\n  //\n  // Misc\n  //\n  // -------------------------------------------------------------------------\n\n  get isVerbose() {\n    return this.verbose;\n  }\n}\n","export class OfflineError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, OfflineError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, OfflineError);\n    }\n\n    this.name = 'OfflineError';\n  }\n}\n","export type WordRecord = {\n  id: number;\n\n  // Kanji readings for the entry\n  k?: Array<string>;\n  km?: Array<null | KanjiMeta>;\n\n  // Kana readings for the entry\n  r: Array<string>;\n  rm?: Array<null | ReadingMeta>;\n\n  // Sense information\n  s: Array<WordSense>;\n};\n\nexport type KanjiMeta = {\n  // Information about a kanji headword\n  //\n  // Typically this should be of type KanjiInfo but we allow it to be any string\n  // in case new types are introduced in future and the client has yet to be\n  // updated.\n  i?: Array<string>;\n\n  // Priority information\n  p?: Array<string>;\n\n  // Bunpro vocab fuzzy match source text\n  bv?: string;\n\n  // Bunpro grammar fuzzy match source text\n  bg?: string;\n};\n\nexport type ReadingMeta = {\n  // Information about the reading\n  //\n  // Typically this should be of type ReadingInfo but we allow it to be any\n  // string in case new types are introduced in future and the client has yet to\n  // be updated.\n  i?: Array<string>;\n\n  // Priority information\n  p?: Array<string>;\n\n  // Bitfield representing which kanji entries (based on their order in the k\n  // array) the reading applies to. 0 means it applies to none of them. If the\n  // field is absent, it means the reading applies to all of the kanji entries.\n  app?: number;\n\n  // Pitch accent information.\n  a?: number | Array<Accent>;\n\n  // Bunpro vocab fuzzy match source text\n  bv?: string;\n\n  // Bunpro grammar fuzzy match source text\n  bg?: string;\n};\n\nexport type Accent = {\n  // Syllable number of the accent (after which the drop occurs).\n  // 0 = 平板\n  i: number;\n\n  // This should typically be a PartOfSpeech value.\n  pos?: Array<string>;\n};\n\nexport type WordSense = {\n  g: Array<string>;\n  // A bitfield representing the type of the glosses in `g`. Two bits are used\n  // to represent the type of each item in `g`, where each two-bit value is one\n  // of the GlossType values below.\n  //\n  // Undefined if the value is 0 (i.e. no glosses have a type, the most common\n  // case).\n  gt?: number;\n  // undefined = 'en'\n  lang?: string;\n\n  // Bit field representing the kanji / kana entries this sense applies to.\n  // If the sense applies to all entries the field will be undefined.\n  kapp?: number;\n  rapp?: number;\n\n  // Extra information about the sense.\n\n  // Typically a PartOfSpeech value\n  pos?: Array<string>;\n  // Typically a FieldType value\n  field?: Array<string>;\n  // Typically a MiscType value\n  misc?: Array<string>;\n  // Typically a Dialect value\n  dial?: Array<string>;\n  inf?: string;\n  xref?: Array<CrossReference>;\n  ant?: Array<CrossReference>;\n\n  // Language source information.\n  lsrc?: Array<LangSource>;\n};\n\nexport const GlossTypes = ['none', 'expl', 'lit', 'fig', 'tm'] as const;\nexport type GlossType = (typeof GlossTypes)[number];\nexport const GLOSS_TYPE_MAX = GlossTypes.length;\nexport const BITS_PER_GLOSS_TYPE = Math.floor(Math.log2(GLOSS_TYPE_MAX)) + 1;\n\nexport type CrossReference =\n  | {\n      k: string;\n      sense?: number;\n    }\n  | {\n      r: string;\n      sense?: number;\n    }\n  | {\n      k: string;\n      r: string;\n      sense?: number;\n    };\n\nexport type LangSource = {\n  // undefined = 'en'\n  lang?: string;\n\n  // The term in the source language\n  //\n  // This may be empty in some cases.\n  src?: string;\n\n  // Partial source (i.e. this only represents part of the string)\n  // absent = false\n  part?: true;\n\n  // The Japanese word is made from words from another language but doesn't\n  // actually represent the meaning of those words literally.\n  wasei?: true;\n};\n\n// ----------------------------------------------------------------------------\n//\n// Supplemental types that may be used to further refine the fields above\n//\n// ----------------------------------------------------------------------------\n\n// KanjiInfo\n\nexport type KanjiInfo = (typeof kanjiInfoValues)[number];\n\nconst kanjiInfoValues = [\n  // ateji (phonetic) reading\n  'ateji',\n  // irregular okurigana usage\n  'io',\n  // word containing irregular kanji usage\n  'iK',\n  // word containing irregular kana usage\n  'ik',\n  // word containing out-dated kanji or kanji usage\n  'oK',\n  // rarely-used kanji form\n  'rK',\n  // search-only kanji form\n  'sK',\n] as const;\n\nexport function isKanjiInfo(a: unknown): a is KanjiInfo {\n  return typeof a === 'string' && kanjiInfoValues.includes(a as KanjiInfo);\n}\n\nexport function asKanjiInfo(a: unknown): KanjiInfo | undefined {\n  return isKanjiInfo(a) ? a : undefined;\n}\n\n// ReadingInfo\n\nexport type ReadingInfo = (typeof allReadingInfo)[number];\n\nconst allReadingInfo = [\n  // gikun (meaning as reading) or jukujikun (special kanji reading)\n  'gikun',\n  // word containing irregular kana usage\n  'ik',\n  // out-dated or obsolete kana usage\n  'ok',\n  // rarely-used kana form\n  'rk',\n  // search-only kana form\n  'sk',\n] as const;\n\nexport function isReadingInfo(a: unknown): a is ReadingInfo {\n  return typeof a === 'string' && allReadingInfo.includes(a as ReadingInfo);\n}\n\nexport function asReadingInfo(a: unknown): ReadingInfo | undefined {\n  return isReadingInfo(a) ? a : undefined;\n}\n\n// Part of speech\n\nexport type PartOfSpeech = (typeof allPartsOfSpeech)[number];\n\n// prettier-ignore\nconst allPartsOfSpeech = [\n  'adj-f', 'adj-i', 'adj-ix', 'adj-kari', 'adj-ku', 'adj-na', 'adj-nari',\n  'adj-no', 'adj-pn', 'adj-shiku', 'adj-t', 'adv', 'adv-to', 'aux', 'aux-adj',\n  'aux-v', 'conj', 'cop', 'ctr', 'exp', 'int', 'n', 'n-adv', 'n-pr', 'n-pref',\n  'n-suf', 'n-t', 'num', 'pn', 'pref', 'prt', 'suf', 'unc', 'v-unspec', 'v1',\n  'v1-s', 'v2a-s', 'v2b-k', 'v2b-s', 'v2d-k', 'v2d-s', 'v2g-k', 'v2g-s',\n  'v2h-k', 'v2h-s', 'v2k-k', 'v2k-s', 'v2m-k', 'v2m-s', 'v2n-s', 'v2r-k',\n  'v2r-s', 'v2s-s', 'v2t-k', 'v2t-s', 'v2w-s', 'v2y-k', 'v2y-s', 'v2z-s', 'v4b',\n  'v4g', 'v4h', 'v4k', 'v4m', 'v4n', 'v4r', 'v4s', 'v4t', 'v5aru', 'v5b', 'v5g',\n  'v5k', 'v5k-s', 'v5m', 'v5n', 'v5r', 'v5r-i', 'v5s', 'v5t', 'v5u', 'v5u-s',\n  'v5uru', 'vi', 'vk', 'vn', 'vr', 'vs', 'vs-c', 'vs-i', 'vs-s', 'vt', 'vz',\n] as const;\n\nexport function isPartOfSpeech(a: unknown): a is PartOfSpeech {\n  return typeof a === 'string' && allPartsOfSpeech.includes(a as PartOfSpeech);\n}\n\nexport function asPartOfSpeech(a: unknown): PartOfSpeech | undefined {\n  return isPartOfSpeech(a) ? a : undefined;\n}\n\n// Field\n\nexport type FieldType = (typeof allFieldTypes)[number];\n\n// prettier-ignore\nconst allFieldTypes = [\n  'agric', 'anat', 'archeol', 'archit', 'art', 'astron', 'audvid', 'aviat',\n  'baseb', 'biochem', 'biol', 'bot', 'boxing', 'Buddh', 'bus', 'cards', 'chem',\n  'chmyth', 'Christn', 'civeng', 'cloth', 'comp', 'cryst', 'dent', 'ecol',\n  'econ', 'elec', 'electr', 'embryo', 'engr', 'ent', 'figskt', 'film', 'finc',\n  'fish', 'food', 'gardn', 'genet', 'geogr', 'geol', 'geom', 'go', 'golf',\n  'gramm', 'grmyth', 'hanaf', 'horse', 'internet', 'jpmyth', 'kabuki', 'law',\n  'ling', 'logic', 'MA', 'mahj', 'manga', 'math', 'mech', 'med', 'met', 'mil',\n  'min', 'mining', 'motor', 'music', 'noh', 'ornith', 'paleo', 'pathol',\n  'pharm', 'phil', 'photo', 'physics', 'physiol', 'politics', 'print',\n  'prowres', 'psy', 'psyanal', 'psych', 'rail', 'rommyth', 'Shinto', 'shogi',\n  'ski', 'sports', 'stat', 'stockm', 'sumo', 'surg', 'telec', 'tradem', 'tv',\n  'vet', 'vidg', 'zool',\n] as const;\n\nexport function isFieldType(a: unknown): a is FieldType {\n  return typeof a === 'string' && allFieldTypes.includes(a as FieldType);\n}\n\nexport function asFieldType(a: unknown): FieldType | undefined {\n  return isFieldType(a) ? a : undefined;\n}\n\n// Misc types. A few of these are not used (e.g. male-sl, uK) but they have\n// entity definitions in the upstream XML file so we include them here.\n\nexport type MiscType = (typeof allMiscTypes)[number];\n\n// prettier-ignore\nconst allMiscTypes = [\n  'abbr', 'aphorism', 'arch', 'char', 'chn', 'col', 'company', 'creat', 'dated',\n  'dei', 'derog', 'doc', 'ev', 'euph', 'fam', 'fem', 'fict', 'form', 'given',\n  'group', 'hist', 'hon', 'hum', 'id', 'joc', 'leg', 'm-sl', 'male', 'myth',\n  'net-sl', 'obj', 'obs', 'obsc', 'on-mim', 'organization', 'oth', 'person',\n  'place', 'poet', 'pol', 'product', 'proverb', 'quote', 'rare', 'relig',\n  'sens', 'serv', 'ship', 'sl', 'station', 'surname', 'uk', 'unclass', 'vulg',\n  'work', 'X', 'yoji',\n] as const;\n\nexport function isMiscType(a: unknown): a is MiscType {\n  return typeof a === 'string' && allMiscTypes.includes(a as MiscType);\n}\n\nexport function asMiscType(a: unknown): MiscType | undefined {\n  return isMiscType(a) ? a : undefined;\n}\n\n// Dialects\n\nexport type Dialect = (typeof allDialects)[number];\n\nconst allDialects = [\n  'bra', // Brazilian\n  'ho', // Hokkaido\n  'tsug', // Tsugaru\n  'th', // Tohoku\n  'na', // Nagano\n  'kt', // Kanto\n  'ks', // Kansai\n  'ky', // Kyoto\n  'os', // Osaka\n  'ts', // Tosa\n  '9s', // Kyushu\n  'ok', // Ryuukyuu\n] as const;\n\nexport function isDialect(a: unknown): a is Dialect {\n  return typeof a === 'string' && allDialects.includes(a as Dialect);\n}\n\nexport function asDialect(a: unknown): Dialect | undefined {\n  return isDialect(a) ? a : undefined;\n}\n","import type { ExtendedKanaEntry, WordResult } from './result-types';\n\n// As with Array.prototype.sort, sorts `results` in-place, but returns the\n// result to support chaining.\nexport function sortWordResults(\n  results: Array<WordResult>,\n  { searchLength }: { searchLength?: number } = {}\n): Array<WordResult> {\n  const sortMeta: Map<\n    number,\n    { excessChars: number | undefined; priority: number; type: number }\n  > = new Map();\n\n  for (const result of results) {\n    // Calculate the number of excess characters in the matching headword\n    const matchingHeadword =\n      result.k.find((k) => k.matchRange) || result.r.find((r) => r.matchRange);\n    const excessChars =\n      searchLength && matchingHeadword\n        ? matchingHeadword.ent.length - searchLength\n        : undefined;\n\n    // Determine the headword match type\n    //\n    // 1 = match on a kanji, or kana which is not just the reading for a kanji\n    // 2 = match on a kana reading for a kanji\n    //\n    // TODO: Don't bother doing this unless the input is all kana\n    const kanaReading = result.r.find((r) => !!r.matchRange);\n    const rt = kanaReading ? getKanaHeadwordType(kanaReading, result) : 1;\n\n    // Priority\n    const priority = getPriority(result);\n\n    sortMeta.set(result.id, { excessChars, priority, type: rt });\n  }\n\n  results.sort((a, b) => {\n    const metaA = sortMeta.get(a.id)!;\n    const metaB = sortMeta.get(b.id)!;\n\n    if (\n      metaA.excessChars !== undefined &&\n      metaB.excessChars !== undefined &&\n      metaA.excessChars !== metaB.excessChars\n    ) {\n      return metaA.excessChars - metaB.excessChars;\n    }\n\n    if (metaA.type !== metaB.type) {\n      return metaA.type - metaB.type;\n    }\n\n    return metaB.priority - metaA.priority;\n  });\n\n  return results;\n}\n\nfunction getKanaHeadwordType(r: ExtendedKanaEntry, result: WordResult): 1 | 2 {\n  // We don't want to prioritize readings marked as `ok` etc. or else we'll end\n  // up prioritizing words like `檜` and `羆` being prioritized when searching\n  // for `ひ`.\n  const isReadingObscure =\n    r.i?.includes('ok') ||\n    r.i?.includes('rk') ||\n    r.i?.includes('sk') ||\n    r.i?.includes('ik');\n\n  if (isReadingObscure) {\n    return 2;\n  }\n\n  // Kana headwords are type 1 (i.e. they are a primary headword, not just a\n  // reading for a kanji headword) if:\n  //\n  // (a) the entry has no kanji headwords or all the kanji headwords are marked\n  //     as `rK`, `sK`, or `iK`.\n  if (\n    !result.k.length ||\n    result.k.every(\n      (k) => k.i?.includes('rK') || k.i?.includes('sK') || k.i?.includes('iK')\n    )\n  ) {\n    return 1;\n  }\n\n  // (b) most of the English senses for the entry have a `uk` (usually kana)\n  //     `misc` field and the reading is not marked as `ok` (old kana usage).\n  //\n  // We wanted to make the condition here be just one sense being marked as `uk`\n  // but then you get words like `梓` being prioritized when searching for `し`\n  // because of one sense out of many being usually kana.\n  //\n  // Furthermore, we don't want to require _all_ senses to be marked as `uk` or\n  // else that will mean that 成る fails to be prioritized when searching for\n  // `なる` because one sense out of 11 is not marked as `uk`.\n  if (mostMatchedEnSensesAreUk(result.s)) {\n    return 1;\n  }\n\n  // (c) the headword is marked as `nokanji`\n  return r.app === 0 ? 1 : 2;\n}\n\nfunction mostMatchedEnSensesAreUk(senses: WordResult['s']): boolean {\n  const matchedEnSenses = senses.filter(\n    (s) => s.match && (s.lang === undefined || s.lang === 'en')\n  );\n  if (matchedEnSenses.length === 0) {\n    return false;\n  }\n\n  const ukEnSenseCount = matchedEnSenses.filter((s) =>\n    s.misc?.includes('uk')\n  ).length;\n  return ukEnSenseCount >= matchedEnSenses.length / 2;\n}\n\nexport function getPriority(result: WordResult): number {\n  // Go through each _matching_ kanji / reading and look for priority\n  // information and return the highest score.\n  const scores: Array<number> = [0];\n  const isHeadwordSearch =\n    result.k.some((k) => !!k.matchRange) ||\n    result.r.some((r) => !!r.matchRange);\n\n  // Scores from kanji readings\n  for (const k of result.k) {\n    if ((isHeadwordSearch ? !k.matchRange : !k.match) || !k.p) {\n      continue;\n    }\n\n    scores.push(getPrioritySum(k.p));\n  }\n\n  // Scores from kana readings\n  for (const r of result.r) {\n    if ((isHeadwordSearch ? !r.matchRange : !r.match) || !r.p) {\n      continue;\n    }\n\n    scores.push(getPrioritySum(r.p));\n  }\n\n  // Return top score\n  return Math.max(...scores);\n}\n\n// Produce an overall priority from a series of priority strings.\n//\n// This should produce a value somewhere in the range 0~67.\n//\n// In general we report the highest priority, but if we have several priority\n// scores we add a decreasing fraction (10%) of the lesser scores as an\n// indication that several sources have attested to the priority.\n//\n// That should typically produce a maximum attainable score of 66.8.\n// Having a bounded range like this makes it easier to combine this value with\n// other metrics when sorting.\nfunction getPrioritySum(priorities: Array<string>): number {\n  const scores = priorities.map(getPriorityScore).sort().reverse();\n  return scores.length\n    ? scores[0] +\n        scores\n          .slice(1)\n          .reduce(\n            (total, score, index) => total + score / Math.pow(10, index + 1),\n            0\n          )\n    : 0;\n}\n\n// This assignment is pretty arbitrary however it's mostly used for sorting\n// entries where all we need to do is distinguish between the really common ones\n// and the obscure academic ones.\n//\n// Entries with (P) are those ones that are marked with (P) in Edict.\nconst PRIORITY_ASSIGNMENTS: Map<string, number> = new Map([\n  ['i1', 50], // Top 10,000 words minus i2 (from 1998) (P)\n  ['i2', 20],\n  ['n1', 40], // Top 12,000 words in newspapers (from 2003?) (P)\n  ['n2', 20], // Next 12,000\n  ['s1', 32], // \"Speculative\" annotations? Seem pretty common to me. (P)\n  ['s2', 20], // (P)\n  ['g1', 30], // (P)\n  ['g2', 15],\n]);\n\nexport function getPriorityScore(p: string): number {\n  if (PRIORITY_ASSIGNMENTS.has(p)) {\n    return PRIORITY_ASSIGNMENTS.get(p)!;\n  }\n\n  if (p.startsWith('nf')) {\n    // The wordfreq scores are groups of 500 words.\n    // e.g. nf01 is the top 500 words, and nf48 is the 23,501 ~ 24,000\n    // most popular words.\n    const wordfreq = parseInt(p.substring(2), 10);\n    if (wordfreq > 0 && wordfreq < 48) {\n      return 48 - wordfreq / 2;\n    }\n  }\n\n  return 0;\n}\n","import { DownloadError } from './download-error';\n\n// A flattened representation of error information suitable for postMessaging.\n//\n// For convenience, it includes retry information for when it is used in\n// automatic retry scenarios.\n\nexport interface UpdateErrorState {\n  name: string;\n  message: string;\n  code?: string;\n  url?: string;\n  nextRetry?: Date;\n  retryCount?: number;\n}\n\nexport function toUpdateErrorState({\n  error,\n  nextRetry,\n  retryCount,\n}: {\n  error: Error;\n  nextRetry?: Date;\n  retryCount?: number;\n}): UpdateErrorState {\n  return {\n    name: error.name,\n    message: error.message,\n    code: error instanceof DownloadError ? error.code : undefined,\n    url: error instanceof DownloadError ? error.url : undefined,\n    nextRetry,\n    retryCount,\n  };\n}\n","// This is in part:\n//\n// - Missing typings for requestIdleCallback\n// - Polyfill for browsers that don't support requestIdleCallback\n// - Polyfill for non-Window contexts (e.g. workers)\n\ninterface IdleDeadline {\n  timeRemaining: () => number;\n  readonly didTimeout: boolean;\n}\n\ninterface IdleRequestOptions {\n  timeout: number;\n}\n\ntype IdleCallbackHandle = number;\n\ntype IdleRequestCallback = (deadline: IdleDeadline) => void;\n\nexport let requestIdleCallback: (\n  callback: IdleRequestCallback,\n  options?: IdleRequestOptions\n) => IdleCallbackHandle;\nexport let cancelIdleCallback: (handle: IdleCallbackHandle) => void;\n\nif (\n  typeof self === 'object' &&\n  typeof self.requestIdleCallback === 'function' &&\n  typeof self.cancelIdleCallback === 'function'\n) {\n  requestIdleCallback = (self as any).requestIdleCallback;\n  cancelIdleCallback = (self as any).cancelIdleCallback;\n} else {\n  requestIdleCallback = (\n    callback: IdleRequestCallback,\n    options?: IdleRequestOptions\n  ): IdleCallbackHandle => {\n    // Use half the specified timeout since it probably represents a worst-case\n    // scenario.\n    const timeout = options ? options.timeout / 2 : 0;\n    return self.setTimeout(() => {\n      callback({ timeRemaining: () => 0, didTimeout: true });\n    }, timeout);\n  };\n\n  cancelIdleCallback = (handle: IdleCallbackHandle) => {\n    clearTimeout(handle);\n  };\n}\n","export function uuid(): string {\n  return ((1e7).toString() + -1e3 + -4e3 + -8e3 + -1e11).replace(\n    /[018]/g,\n    (c) =>\n      (\n        Number(c) ^\n        (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (Number(c) / 4)))\n      ).toString(16)\n  );\n}\n","import { DataSeries } from './data-series';\nimport { JpdictIdb } from './database';\nimport { uuid } from './uuid';\n\nconst dbToUuid: Map<JpdictIdb, string> = new Map();\n\nexport function getUpdateKey(obj: JpdictIdb, series: DataSeries): string {\n  if (!dbToUuid.has(obj)) {\n    dbToUuid.set(obj, uuid());\n  }\n  const baseId = dbToUuid.get(obj);\n\n  return `${baseId}-${series}`;\n}\n","import { DataSeries, MajorDataSeries } from './data-series';\nimport { ChangeCallback, ChangeTopic, JpdictIdb } from './database';\nimport { DownloadError } from './download-error';\nimport { OfflineError } from './offline-error';\nimport {\n  cancelIdleCallback,\n  requestIdleCallback,\n} from './request-idle-callback';\nimport { getUpdateKey } from './update-key';\nimport { UpdatingUpdateState } from './update-state';\n\nexport type UpdateCompleteCallback = () => void;\nexport type UpdateErrorCallback = (params: {\n  error: Error;\n  nextRetry?: Date;\n  retryCount?: number;\n}) => void;\n\n// We allow passing in a custom setTimeout implementation so that unit tests\n// can mock it, because overriding the global definition interferes with\n// playwright, and sinon can't mock ES6 dependencies:\n//\n// https://github.com/hugomrdias/playwright-test/issues/426\n// https://github.com/microsoft/playwright/issues/9123\n// https://github.com/sinonjs/sinon/issues/1711\ntype SetTimeoutFn = (cb: () => void, duration: number) => number;\n\n// Updates the passed-in database and retries in the case of failure due to\n// network failures or being offline.\n//\n// Note that if there is an existing call to this function in motion\n// (including waiting to retry) the existing call will be re-used.\n// As a result, if the passed-in callback functions differ between invocations,\n// only the originally passed-in callback functions will be called.\n//\n// (This is fixable but it introduces complexity and currently all clients\n// have a single point where they call into this so it is not necessary to try\n// and store a list of callback functions.)\n//\n// If the `updateNow` parameter is set then an existing call to this function\n// will be canceled first UNLESS it is already running or blocked due to being\n// offline. That is, the `updateNow` flag is meant to say, \"Update now if you\n// are not already.\"\n//\n// Furthermore, note that if an invocation is canceled there is no abort\n// callback or AbortError or anything of the sort. (Again, this is fixable but\n// it requires us to store the callbacks passed-in, and currently no client\n// needs this.)\nexport function updateWithRetry({\n  db,\n  lang,\n  series,\n  onUpdateComplete,\n  onUpdateError,\n  setTimeout = self.setTimeout,\n  updateNow = false,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout?: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n  updateNow?: boolean;\n}) {\n  startUpdate({\n    db,\n    lang,\n    series,\n    setTimeout,\n    onUpdateComplete,\n    onUpdateError,\n    updateNow,\n  });\n}\n\nfunction runUpdate({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n}) {\n  // If we are offline, wait until we are online.\n  if (!navigator.onLine) {\n    const onlineCallback = async () => {\n      runUpdate({\n        db,\n        lang,\n        series,\n        setTimeout,\n        onUpdateComplete,\n        onUpdateError,\n      });\n    };\n\n    addEventListener('online', onlineCallback, { once: true });\n    goOffline({ db, series, lang, onlineCallback });\n    onUpdateError?.({ error: new OfflineError() });\n    return;\n  }\n\n  // Transition to updating state.\n  beginUpdating({ db, series, lang });\n\n  // Actually run the update and handle any errors\n  void (async () => {\n    try {\n      await db.update({ series, lang });\n\n      resetUpdate({ db, series });\n\n      if (db.isVerbose) {\n        console.log('Successfully completed update.');\n      }\n\n      onUpdateComplete?.();\n    } catch (e) {\n      if (db.isVerbose) {\n        console.error('Got error while updating', e);\n      }\n\n      let retryCount: number | undefined;\n      let nextRetry: Date | undefined;\n      let suppressError = false;\n\n      // Retry network errors at decreasing intervals\n      const isNetworkError = e instanceof DownloadError;\n      if (isNetworkError) {\n        const scheduleResult = maybeScheduleRetry({\n          db,\n          lang,\n          series,\n          setTimeout,\n          onUpdateComplete,\n          onUpdateError,\n        });\n        if (scheduleResult) {\n          ({ nextRetry, retryCount } = scheduleResult);\n        }\n      } else if (e && e instanceof Error && e.name === 'ConstraintError') {\n        const scheduleResult = maybeScheduleIdleRetry({\n          db,\n          lang,\n          series,\n          setTimeout,\n          onUpdateComplete,\n          onUpdateError,\n        });\n        if (scheduleResult) {\n          ({ retryCount } = scheduleResult);\n        }\n\n        suppressError = !!scheduleResult;\n      } else {\n        resetUpdate({ db, series });\n      }\n\n      if (!suppressError && onUpdateError) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        onUpdateError({ error, nextRetry, retryCount });\n      }\n    }\n  })();\n}\n\nfunction onDatabaseChange({\n  db,\n  series,\n  topic,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n  topic: ChangeTopic;\n}) {\n  // If the database was deleted, cancel any scheduled retries.\n  if (topic === 'deleted') {\n    resetUpdate({ db, series });\n    return;\n  }\n\n  // topic === 'stateupdated'\n  //\n  // If we successfully downloaded *something*, reset the retry interval.\n  //\n  // We should only do this when we have a retry interval set since we DON'T\n  // want to reset the retry count if we are retrying due to a database error.\n  const seriesHasProgress = (series: DataSeries) =>\n    db[series].updateState.type === 'updating' &&\n    (db[series].updateState as UpdatingUpdateState).fileProgress > 0;\n  const downloadedSomething =\n    series === 'kanji'\n      ? seriesHasProgress('kanji') || seriesHasProgress('radicals')\n      : seriesHasProgress(series);\n\n  if (downloadedSomething) {\n    clearRetryInterval({ db, series });\n  }\n}\n\nexport function cancelUpdateWithRetry({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}) {\n  resetUpdate({ db, series });\n}\n\n// ---------------------------------------------------------------------------\n//\n// State management\n//\n// ---------------------------------------------------------------------------\n\ntype RetryState =\n  | {\n      type: 'offline';\n      lang: string;\n      changeCallback: ChangeCallback;\n      onlineCallback: () => any;\n    }\n  | {\n      type: 'updating';\n      lang: string;\n      changeCallback: ChangeCallback;\n      retryIntervalMs?: number;\n      retryCount?: number;\n    }\n  | {\n      type: 'waiting-for-timeout';\n      lang: string;\n      changeCallback: ChangeCallback;\n      setTimeoutHandle: number;\n      retryIntervalMs: number;\n      retryCount: number;\n    }\n  | {\n      type: 'waiting-for-idle';\n      lang: string;\n      changeCallback: ChangeCallback;\n      requestIdleCallbackHandle: number;\n      retryCount: number;\n    };\n\nconst inProgressUpdates: Map<string, RetryState> = new Map();\n\n// ---------------------------------------------------------------------------\n//\n// State transitions\n//\n// ---------------------------------------------------------------------------\n\nfunction startUpdate({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n  updateNow,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n  updateNow: boolean;\n}) {\n  // Check if we have an in-progress update.\n  const updateKey = getUpdateKey(db, series);\n  let retryState = inProgressUpdates.get(updateKey);\n\n  // If the languages differ, we should cancel the existing update.\n  if (retryState && retryState.lang !== lang) {\n    if (db.isVerbose) {\n      console.info(\n        'Canceling existing call to updateWithRetry because the requested language has changed.'\n      );\n    }\n    resetUpdate({ db, series });\n  }\n\n  // Re-fetch the retry status since we may have canceled it.\n  retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    // If we are not trying to force an update then use the existing in-progress\n    // update.\n    if (!updateNow) {\n      if (db.isVerbose) {\n        console.info(\n          'Overlapping calls to updateWithRetry. Re-using existing invocation. This could be problematic if different callback functions were passed on each invocation.'\n        );\n      }\n      return;\n    }\n\n    // If we're offline, then we're not even going to try updating until we\n    // are online (at which point we will retry immediately).\n    if (retryState.type === 'offline') {\n      if (db.isVerbose) {\n        console.info('Deferring forced update. Currently offline.');\n      }\n      return;\n    }\n\n    // Even if we are trying to force the update, if we just started an update\n    // (or are retrying rapidly) then use the existing update.\n    if (retryState.type === 'updating') {\n      if (db.isVerbose) {\n        console.info('Skipping forced update. Already updating presently.');\n      }\n      return;\n    }\n\n    // Otherwise, cancel the in-progress update.\n    if (db.isVerbose) {\n      console.log('Canceling existing queued retry.');\n    }\n    resetUpdate({ db, series });\n  }\n\n  // If we _still_ have an in-progress update here, it means we got an\n  // overlapping call to this method while we were waiting to cancel the\n  // previous in-progress update.\n  retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    if (db.isVerbose) {\n      console.log('Skipping overlapping auto-retry request.');\n    }\n    return;\n  }\n\n  runUpdate({ db, lang, series, setTimeout, onUpdateComplete, onUpdateError });\n}\n\nfunction resetUpdate({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n  if (!retryState) {\n    return;\n  }\n\n  switch (retryState.type) {\n    case 'offline':\n      removeEventListener('online', retryState.onlineCallback);\n      break;\n\n    case 'waiting-for-timeout':\n      clearTimeout(retryState.setTimeoutHandle);\n      break;\n\n    case 'waiting-for-idle':\n      cancelIdleCallback(retryState.requestIdleCallbackHandle);\n      break;\n  }\n\n  db.removeChangeListener(retryState.changeCallback);\n  inProgressUpdates.delete(updateKey);\n\n  db.cancelUpdate(series);\n}\n\nfunction goOffline({\n  db,\n  lang,\n  onlineCallback,\n  series,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  onlineCallback: () => any;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    resetUpdate({ db, series });\n  }\n\n  inProgressUpdates.set(updateKey, {\n    type: 'offline',\n    lang,\n    onlineCallback,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n  });\n}\n\nfunction beginUpdating({\n  db,\n  lang,\n  series,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  inProgressUpdates.set(updateKey, {\n    type: 'updating',\n    lang,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n    retryCount: getRetryCount(retryState),\n    retryIntervalMs: getRetryIntervalMs(retryState),\n  });\n}\n\nfunction maybeScheduleRetry({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n}): { retryCount: number; nextRetry: Date } | undefined {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  // If we are not updating to begin with, don't schedule a retry since it\n  // probably means we were canceled.\n  if (retryState?.type !== 'updating') {\n    return undefined;\n  }\n\n  let retryIntervalMs = retryState.retryIntervalMs;\n  if (retryIntervalMs) {\n    // Don't let the interval become longer than 12 hours\n    retryIntervalMs = Math.min(retryIntervalMs * 2, 12 * 60 * 60 * 1000);\n  } else {\n    // Randomize the initial interval to somewhere between 3s ~ 6s.\n    retryIntervalMs = 3000 + Math.random() * 3000;\n  }\n\n  let retryCount = retryState.retryCount;\n  retryCount = typeof retryCount === 'number' ? retryCount + 1 : 0;\n\n  if (db.isVerbose) {\n    console.log(`Scheduling retry of update in ${retryIntervalMs}ms`);\n  }\n\n  const setTimeoutHandle = setTimeout(() => {\n    if (db.isVerbose) {\n      console.log('Running automatic retry of update...');\n    }\n\n    runUpdate({\n      db,\n      lang,\n      series,\n      setTimeout,\n      onUpdateComplete,\n      onUpdateError,\n    });\n  }, retryIntervalMs) as unknown as number;\n\n  const nextRetry = new Date(Date.now() + retryIntervalMs);\n\n  inProgressUpdates.set(updateKey, {\n    type: 'waiting-for-timeout',\n    lang,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n    retryCount,\n    retryIntervalMs,\n    setTimeoutHandle,\n  });\n\n  return { nextRetry, retryCount };\n}\n\nfunction clearRetryInterval({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  // The check here for `retryIntervalMs` being set ensures we don't clear the\n  // interval when we call this as a result of an idle callback running.\n  if (retryState?.type !== 'updating' || !retryState.retryIntervalMs) {\n    return;\n  }\n\n  inProgressUpdates.set(updateKey, {\n    ...retryState,\n    retryIntervalMs: undefined,\n    retryCount: undefined,\n  });\n}\n\nfunction maybeScheduleIdleRetry({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n}): { retryCount: number } | undefined {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  // If we are not updating to begin with, don't schedule a retry since it\n  // probably means we were canceled.\n  if (retryState?.type !== 'updating') {\n    return undefined;\n  }\n\n  // We only want to do this kind of rapid retry a few times (it's for database\n  // errors).\n  let retryCount = retryState.retryCount;\n  if (retryCount && retryCount >= 2) {\n    return undefined;\n  }\n\n  retryCount = typeof retryCount === 'number' ? retryCount + 1 : 0;\n\n  if (db.isVerbose) {\n    console.log('Retrying update momentarily');\n  }\n\n  const requestIdleCallbackHandle = requestIdleCallback(\n    () => {\n      if (db.isVerbose) {\n        console.log('Running automatic retry of update...');\n      }\n\n      runUpdate({\n        db,\n        lang,\n        series,\n        setTimeout,\n        onUpdateComplete,\n        onUpdateError,\n      });\n    },\n    { timeout: 2000 }\n  );\n\n  inProgressUpdates.set(updateKey, {\n    type: 'waiting-for-idle',\n    lang,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n    requestIdleCallbackHandle,\n    retryCount,\n  });\n\n  return { retryCount };\n}\n\n// ----------------------------------------------------------------------------\n//\n// State helpers\n//\n// ----------------------------------------------------------------------------\n\nfunction getOrRegisterChangeCallback({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}): ChangeCallback {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    return retryState.changeCallback;\n  }\n\n  const changeCallback = (topic: ChangeTopic) =>\n    onDatabaseChange({ db, series, topic });\n  db.addChangeListener(changeCallback);\n\n  return changeCallback;\n}\n\nfunction getRetryCount(retryState: RetryState | undefined): number | undefined {\n  return retryState?.type !== 'offline' ? retryState?.retryCount : undefined;\n}\n\nfunction getRetryIntervalMs(\n  retryState: RetryState | undefined\n): number | undefined {\n  return retryState?.type === 'waiting-for-timeout' ||\n    retryState?.type === 'updating'\n    ? retryState?.retryIntervalMs\n    : undefined;\n}\n","// This is in part:\n//\n// - Missing typings for requestIdleCallback\n// - Polyfill for browsers that don't support requestIdleCallback\n// - Polyfill for non-Window contexts (e.g. workers)\n\ninterface IdleDeadline {\n  timeRemaining: () => number;\n  readonly didTimeout: boolean;\n}\n\ninterface IdleRequestOptions {\n  timeout: number;\n}\n\ntype IdleCallbackHandle = number;\n\ntype IdleRequestCallback = (deadline: IdleDeadline) => void;\n\n/** @public */\nexport let requestIdleCallback: (\n  callback: IdleRequestCallback,\n  options?: IdleRequestOptions\n) => IdleCallbackHandle;\n\n/** @public */\nexport let cancelIdleCallback: (handle: IdleCallbackHandle) => void;\n\nif ((self as any).requestIdleCallback && (self as any).cancelIdleCallback) {\n  requestIdleCallback = (self as any).requestIdleCallback.bind(self);\n  cancelIdleCallback = (self as any).cancelIdleCallback.bind(self);\n} else {\n  requestIdleCallback = (\n    callback: IdleRequestCallback,\n    options: IdleRequestOptions\n  ): IdleCallbackHandle => {\n    // Use half the specified timeout since it probably represents a worst-case\n    // scenario.\n    const timeout = options ? options.timeout / 2 : 0;\n    return self.setTimeout(() => {\n      callback({ timeRemaining: () => 0, didTimeout: true });\n    }, timeout);\n  };\n\n  cancelIdleCallback = (handle: IdleCallbackHandle) => {\n    self.clearTimeout(handle);\n  };\n}\n\n/** @public */\nexport function requestIdleCallbackPromise(\n  options?: IdleRequestOptions\n): Promise<void> {\n  return new Promise((resolve) =>\n    requestIdleCallback(() => {\n      resolve();\n    }, options)\n  );\n}\n","// Convert an error into a form that able to sent with postMessage and that\n// is also compatible with Bugsnag's NotifiableError type.\nexport function serializeError(error: Error): {\n  name: string;\n  message: string;\n} {\n  let name: string;\n\n  // Occasionally we get an undefined error object. We saw this at least once\n  // on Firefox 68. Note sure where it's coming from.\n  if (!error) {\n    // Generate a stack in the hope of getting some clue where this is coming\n    // from.\n    let stack: string | undefined;\n    try {\n      throw new Error('(Unknown error)');\n    } catch (e) {\n      stack = (e as Error).stack;\n    }\n    return { name: '(Unknown error)', message: stack || '' };\n  }\n\n  // We need to be careful not to read the 'code' field unless it's a string\n  // because DOMExceptions, for example, have a code field that is a number\n  // but what we really want from them is their 'name' field.\n  if (typeof (error as any).code === 'string') {\n    name = (error as any).code;\n  } else {\n    name = (error as any).name || (error as any).message;\n  }\n\n  // Also, if we get a generic \"Error\" with a more specific message field, we\n  // should use that.\n  if (\n    name === 'Error' &&\n    typeof (error as any).message === 'string' &&\n    (error as any).message.length\n  ) {\n    name = (error as any).message;\n  }\n\n  // Common conversions to more specific/useful error classes.\n  if (error instanceof TypeError && error.message.startsWith('NetworkError')) {\n    name = 'NetworkError';\n  }\n  if (name === 'NetworkError' && !self.navigator.onLine) {\n    name = 'OfflineError';\n  }\n\n  // Set the message to the message field, unless we're already using that as\n  // the name.\n  let message = (error as any).message || '';\n  if (message === name) {\n    message = '';\n  }\n\n  return { name, message };\n}\n","import { JpdictState } from '../background/jpdict';\nimport { serializeError } from '../utils/serialize-error';\n\nexport const queryState = () => ({ type: 'querystate' as const });\n\nexport const updateDb = ({\n  lang,\n  force,\n}: {\n  lang: string;\n  force: boolean;\n}) => ({\n  type: 'update' as const,\n  lang,\n  force,\n});\n\nexport const cancelUpdateDb = () => ({ type: 'cancelupdate' as const });\n\nexport const deleteDb = () => ({ type: 'delete' as const });\n\nexport const notifyDbStateUpdated = (state: JpdictState) => ({\n  type: 'dbstateupdated' as const,\n  state,\n});\n\nexport const notifyDbUpdateComplete = (lastCheck: Date | null) => ({\n  type: 'dbupdatecomplete' as const,\n  lastCheck,\n});\n\nexport const leaveBreadcrumb = ({ message }: { message: string }) => ({\n  type: 'breadcrumb' as const,\n  message,\n});\n\nexport const notifyError = ({\n  error,\n  severity = 'error',\n}: {\n  error: Error;\n  severity?: 'error' | 'warning';\n}) => ({\n  type: 'error' as const,\n  severity,\n  ...serializeError(error),\n  stack: error.stack,\n});\n\nexport type JpdictEvent =\n  | ReturnType<typeof queryState>\n  | ReturnType<typeof updateDb>\n  | ReturnType<typeof cancelUpdateDb>\n  | ReturnType<typeof deleteDb>\n  | ReturnType<typeof notifyDbStateUpdated>\n  | ReturnType<typeof notifyDbUpdateComplete>\n  | ReturnType<typeof leaveBreadcrumb>\n  | ReturnType<typeof notifyError>;\n","import {\n  DataSeries,\n  JpdictIdb,\n  MajorDataSeries,\n  UpdateErrorState,\n  allMajorDataSeries,\n  cancelUpdateWithRetry,\n  clearCachedVersionInfo,\n  toUpdateErrorState,\n  updateWithRetry,\n} from '@birchill/jpdict-idb';\n\nimport { requestIdleCallbackPromise } from '../utils/request-idle-callback';\n\nimport { JpdictState } from './jpdict';\nimport {\n  JpdictEvent,\n  leaveBreadcrumb,\n  notifyDbStateUpdated,\n  notifyDbUpdateComplete,\n  notifyError,\n} from './jpdict-events';\n\nexport type JpdictListener = (event: JpdictEvent) => void;\n\nexport interface JpdictBackend {\n  addEventListener(listener: JpdictListener): void;\n  removeEventListener(listener: JpdictListener): void;\n\n  updateDb(params: { lang: string; force: boolean }): void;\n  cancelUpdateDb(): void;\n  deleteDb(): void;\n  queryState(): void;\n}\n\nexport class JpdictLocalBackend implements JpdictBackend {\n  private db: JpdictIdb | undefined;\n  private dbIsInitialized: Promise<boolean>;\n  private currentUpdate:\n    | {\n        lang: string;\n        series: MajorDataSeries;\n        forceUpdate: boolean;\n      }\n    | undefined;\n\n  private lastUpdateError: UpdateErrorState | undefined;\n  private listeners: Array<JpdictListener> = [];\n\n  constructor() {\n    this.doDbStateNotification = this.doDbStateNotification.bind(this);\n    this.dbIsInitialized = this.initDb()\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  addEventListener(listener: JpdictListener) {\n    if (!this.listeners.includes(listener)) {\n      this.listeners.push(listener);\n    }\n  }\n\n  removeEventListener(listener: JpdictListener) {\n    this.listeners = this.listeners.filter((l) => l !== listener);\n  }\n\n  async updateDb({ lang, force }: { lang: string; force: boolean }) {\n    try {\n      await this.updateAllSeries({ lang, forceUpdate: force });\n    } catch (error) {\n      this.notifyListeners(notifyError({ error }));\n    }\n  }\n\n  cancelUpdateDb() {\n    if (!this.currentUpdate) {\n      return;\n    }\n\n    cancelUpdateWithRetry({ db: this.db!, series: this.currentUpdate.series });\n    this.currentUpdate = undefined;\n  }\n\n  async deleteDb() {\n    if (this.db) {\n      try {\n        await this.db.destroy();\n      } catch (error) {\n        this.notifyListeners(notifyError({ error }));\n      }\n    }\n  }\n\n  async queryState() {\n    if (await this.dbIsInitialized) {\n      this.doDbStateNotification();\n    }\n  }\n\n  //\n  // Implementation helpers\n  //\n\n  private async initDb(): Promise<JpdictIdb> {\n    let retryCount = 0;\n    while (true) {\n      if (this.db) {\n        try {\n          await this.db.destroy();\n        } catch {\n          console.log('Failed to destroy previous database');\n        }\n      }\n\n      try {\n        this.db = new JpdictIdb({ verbose: true });\n        this.db.addChangeListener(this.doDbStateNotification);\n\n        await this.db.ready;\n        return this.db;\n      } catch (e) {\n        if (retryCount >= 3) {\n          console.log(\n            'Giving up opening database. Likely in permanent private browsing mode.'\n          );\n          throw e;\n        }\n        retryCount++;\n        console.log(\n          `Failed to open database. Retrying shortly (attempt: ${retryCount})...`\n        );\n        await requestIdleCallbackPromise({ timeout: 1000 });\n      }\n    }\n  }\n\n  private async updateAllSeries({\n    lang,\n    forceUpdate,\n  }: {\n    lang: string;\n    forceUpdate: boolean;\n  }) {\n    if (!(await this.dbIsInitialized)) {\n      return;\n    }\n\n    // Check for a current update\n    let wasForcedUpdate = false;\n    if (this.currentUpdate) {\n      // If the language matches and we're not (newly) forcing an update, then\n      // just let the current update run.\n      if (\n        this.currentUpdate.lang === lang &&\n        (this.currentUpdate.forceUpdate || !forceUpdate)\n      ) {\n        return;\n      }\n\n      // Otherwise, cancel the current update but make sure to propagate the\n      // forced flag if we were forced.\n      wasForcedUpdate = this.currentUpdate.forceUpdate;\n      this.cancelUpdateDb();\n      this.currentUpdate = undefined;\n    }\n\n    // Firefox 112+ (and presumably Thunderbird 112+) has an unfortunate bug\n    // where, when we try to clear an objectStore, it just hangs:\n    //\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1860486\n    //\n    // Until that bug is fixed (or we replace our database storage entirely), we\n    // need to detect when we are likely to want to clear an object store and\n    // simply blow away the whole database and replace it.\n    //\n    // That's quite unfortunate because it means we'll need to download all the\n    // names data again which is massive but it's better than having the user be\n    // stuck.\n    if (hasBuggyObjectStoreClear()) {\n      // Check if we need to replace the data, i.e. if running an update is\n      // likely to try and clear a data series' object store.\n      //\n      // There are basically two cases where this happens:\n      //\n      // 1. We are changing the language\n      //\n      // 2. The major/minor version of a data series has changed\n      //\n      // Working out if the language is changed is hard. Not all series have all\n      // languages so a mismatch between the passed-in `lang` and the series'\n      // language doesn't necessarily mean that the language has changed.\n      //\n      // Instead, if there are _no_ series that match the language we can assume\n      // it has changed.\n      const langChanged =\n        this.db &&\n        this.db.kanji.state === 'ok' &&\n        this.db.kanji.version?.lang !== lang &&\n        this.db.radicals.state === 'ok' &&\n        this.db.radicals.version?.lang !== lang &&\n        this.db.words.state === 'ok' &&\n        this.db.words.version?.lang !== lang;\n\n      // Working out if the major/minor version has changed is impossible\n      // without either:\n      //\n      // 1. Duplicating the logic to download the version info metadata here and\n      //    comparing it, or\n      //\n      // 2. Passing some sort of flag into `updateWithRetry` to indicate that\n      //    if the version has changed we should replace the database.\n      //\n      // Both are very invasive so we'll just have to commit to not updating the\n      // major/minor version until either the bug is fixed in Firefox or we\n      // replace our database storage.\n\n      if (langChanged) {\n        try {\n          this.notifyListeners(\n            leaveBreadcrumb({\n              message:\n                'Detected language change on buggy version of Firefox. Replacing database.',\n            })\n          );\n          await this.initDb();\n        } catch (error) {\n          this.notifyListeners(notifyError({ error }));\n        }\n      }\n    }\n\n    const onUpdateError =\n      (series: DataSeries) =>\n      (params: { error: Error; nextRetry?: Date; retryCount?: number }) => {\n        const { error, nextRetry, retryCount } = params;\n        if (nextRetry) {\n          const diffInMs = nextRetry.getTime() - Date.now();\n          this.notifyListeners(\n            leaveBreadcrumb({\n              message: `Encountered ${error.name} error updating ${series} database. Retrying in ${diffInMs}ms.`,\n            })\n          );\n\n          // We don't want to report all download errors since the auto-retry\n          // behavior will mean we get too many. Also, we don't care about\n          // intermittent failures for users on flaky network connections.\n          //\n          // However, if a lot of clients are failing multiple times to fetch\n          // a particular resource, we want to know.\n          if (retryCount === 5) {\n            this.notifyListeners(notifyError({ error, severity: 'warning' }));\n          }\n        } else if (\n          error.name !== 'AbortError' &&\n          error.name !== 'OfflineError'\n        ) {\n          this.notifyListeners(notifyError({ error }));\n        } else {\n          this.notifyListeners(\n            leaveBreadcrumb({\n              message: `Database update for ${series} database encountered ${error.name} error`,\n            })\n          );\n        }\n\n        this.lastUpdateError = toUpdateErrorState(params);\n        this.doDbStateNotification();\n      };\n\n    const runNextUpdate = () => {\n      // Check if we successfully updated a series\n      if (this.currentUpdate) {\n        this.lastUpdateError = undefined;\n        this.notifyListeners(\n          leaveBreadcrumb({\n            message: `Successfully updated ${this.currentUpdate.series} database`,\n          })\n        );\n        this.doDbStateNotification();\n      }\n\n      // Cycle through data series\n      //\n      // We use the following order:\n      //\n      // 1. Kanji\n      // 2. Names\n      // 3. Words\n      //\n      // Although the words dictionary is the most important one, we already have\n      // the flat-file version available for words so, if we're going to run out\n      // of disk space, it would be good to try and get as much of the other data\n      // in first.\n      if (!this.currentUpdate) {\n        this.currentUpdate = {\n          lang,\n          series: 'kanji',\n          forceUpdate: forceUpdate || wasForcedUpdate,\n        };\n      } else if (this.currentUpdate.series === 'kanji') {\n        this.currentUpdate.series = 'names';\n      } else if (this.currentUpdate.series === 'names') {\n        this.currentUpdate.series = 'words';\n      } else {\n        this.currentUpdate = undefined;\n        this.notifyListeners(\n          notifyDbUpdateComplete(getLatestCheckTime(this.db!))\n        );\n        return;\n      }\n\n      if (forceUpdate || wasForcedUpdate) {\n        clearCachedVersionInfo();\n      }\n      void updateWithRetry({\n        db: this.db!,\n        series: this.currentUpdate.series,\n        lang,\n        onUpdateComplete: runNextUpdate,\n        onUpdateError: onUpdateError(this.currentUpdate.series),\n      });\n    };\n\n    runNextUpdate();\n  }\n\n  private doDbStateNotification() {\n    // Wait until we have finished resolving the database versions before\n    // reporting anything.\n    if (\n      !this.db ||\n      this.db.words.state === 'init' ||\n      this.db.kanji.state === 'init' ||\n      this.db.radicals.state === 'init' ||\n      this.db.names.state === 'init'\n    ) {\n      return;\n    }\n\n    // Merge update states to show the current / latest update\n    const lastCheck = getLatestCheckTime(this.db);\n    const updateState = this.currentUpdate\n      ? this.db[this.currentUpdate.series].updateState\n      : { type: 'idle' as const, lastCheck };\n\n    const state: JpdictState = {\n      words: {\n        state: this.db.words.state,\n        version: this.db.words.version,\n      },\n      kanji: {\n        state: this.db.kanji.state,\n        version: this.db.kanji.version,\n      },\n      radicals: {\n        state: this.db.radicals.state,\n        version: this.db.radicals.version,\n      },\n      names: {\n        state: this.db.names.state,\n        version: this.db.names.version,\n      },\n      updateState,\n      updateError: this.lastUpdateError,\n    };\n\n    this.notifyListeners(notifyDbStateUpdated(state));\n  }\n\n  private notifyListeners(message: JpdictEvent) {\n    const listenersCopy = this.listeners.slice();\n    for (const listener of listenersCopy) {\n      listener(message);\n    }\n  }\n}\n\nfunction getLatestCheckTime(db: JpdictIdb): Date | null {\n  const latestCheckAsNumber = Math.max.apply(\n    null,\n    allMajorDataSeries.map((series) => db[series].updateState.lastCheck)\n  );\n\n  return latestCheckAsNumber !== 0 ? new Date(latestCheckAsNumber) : null;\n}\n\nfunction hasBuggyObjectStoreClear() {\n  const userAgent = navigator.userAgent;\n  const firefoxOrThunderbird = /(Firefox|Thunderbird)\\/(\\d+)/.exec(userAgent);\n  if (firefoxOrThunderbird && firefoxOrThunderbird[2]) {\n    const version = parseInt(firefoxOrThunderbird[2], 10);\n    // The bug has been fixed in Firefox 123.\n    return (\n      version >= 112 && (firefoxOrThunderbird[1] !== 'Firefox' || version < 123)\n    );\n  }\n  return false;\n}\n","import { JpdictLocalBackend } from '../background/jpdict-backend';\nimport { JpdictEvent, notifyError } from '../background/jpdict-events';\n\ndeclare let self: DedicatedWorkerGlobalScope;\n\nconst backend = new JpdictLocalBackend();\n\nbackend.addEventListener((event: JpdictEvent) => {\n  try {\n    self.postMessage(event);\n  } catch (e) {\n    console.log('Error posting message');\n    console.log(e);\n  }\n});\n\nself.onmessage = async (event: MessageEvent) => {\n  // We seem to get random events here occasionally. Not sure where they come\n  // from.\n  if (!event.data) {\n    return;\n  }\n\n  switch ((event.data as JpdictEvent).type) {\n    case 'querystate':\n      void backend.queryState();\n      break;\n\n    case 'update':\n      void backend.updateDb({ lang: event.data.lang, force: event.data.force });\n      break;\n\n    case 'cancelupdate':\n      void backend.cancelUpdateDb();\n      break;\n\n    case 'delete':\n      void backend.deleteDb();\n      break;\n  }\n};\n\nself.onerror = (e) => {\n  self.postMessage(notifyError({ error: e.error || e }));\n};\n"],"names":["jsonEqualish","actual","expected","Object","is","objEquiv","a","b","Date","getTime","Array","isArray","constructor","Error","aKeys","definedKeys","bKeys","length","sort","i","key","keys","filter","StructError","TypeError","failure","failures","cached","rest","msg","path","message","join","super","explanation","this","cause","assign","name","isIterable","x","isObject","Symbol","iterator","isNonArrayObject","print","value","toString","JSON","stringify","shiftIterator","input","next","done","undefined","toFailure","result","context","struct","type","refinement","branch","toFailures","r","run","options","ctx","mask","coerce","coercer","status","validator","k","v","s","entries","ts","t","Map","set","Set","add","refiner","Struct","props","schema","assert","create","validate","tuples","tuple","error","array","Element","slice","enums","values","description","map","includes","integer","isNaN","Number","isInteger","literal","constant","number","optional","record","Key","Value","string","union","Structs","S","coerced","first","push","getSize","size","threshold","refine","exclusive","nonempty","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","transactionDoneMap","WeakMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","wrap","addEventListener","cacheDonePromiseForTransaction","tx","has","complete","DOMException","idbProxyTraps","get","target","prop","receiver","objectStoreNames","objectStore","replaceTraps","callback","wrapFunction","func","args","apply","unwrap","transformCachableValue","Proxy","IDBRequest","newValue","openDB","version","indexedDB","open","openPromise","upgrade","event","oldVersion","newVersion","transaction","blocked","then","db","terminated","blocking","catch","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","all","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","delete","isIteratorProp","asyncIterator","kanaToHiragana","char","codePointAt","String","fromCodePoint","AbortError","params","setPrototypeOf","captureStackTrace","allDataSeries","allMajorDataSeries","DownloadError","code","url","isAbortError","e","isDownloadError","getErrorMessage","fetchWithTimeout","resource","controller","AbortController","onAbort","abort","signal","didTimeout","timeoutId","timeout","Infinity","setTimeout","response","fetch","clearTimeout","safeInteger","isSafeInteger","getVersionInfo","versionInfoFile","getVersionInfoFile","baseUrl","lang","dbVersionInfo","getCurrentVersionInfo","series","majorVersion","clearCachedVersionInfo","cachedVersionInfo","CACHE_TIMEOUT","accessTime","now","rawVersionInfoFile","ok","json","aborted","parseVersionInfoFile","VersionInfoStruct","major","minor","patch","parts","databaseVersion","dateOfCreation","VersionInfoFileStruct","ljsonStreamIterator","reader","stream","getReader","lineEnd","decoder","TextDecoder","buffer","parseLine","line","parse","releaseLock","readResult","waitWithTimeout","read","decode","lines","split","splice","timeoutPromise","_","self","race","val","stripFields","o","fields","field","compareVersions","BASE_URL","DOWNLOAD_TIMEOUT","hasLanguage","download","versionInfo","getDownloadList","currentVersion","latestVersion","files","file","getEvents","format","partInfo","versionToString","downloadType","nextPart","part","nextPatch","HeaderLineStruct","records","PatchLineStruct","dottedVersion","commonUrlStart","body","headerRead","fileStartEvent","totalRecords","mode","QuotaExceededError","hasHiragana","str","toWordStoreRecord","rm","elem","km","h","keysToHiragana","kc","gt_en","gt_l","getStoreIdForWordRecord","id","toNameStoreRecord","entry","getStoreIdForNameRecord","toKanjiStoreRecord","getStoreIdForKanjiRecord","toRadicalStoreRecord","getStoreIdForRadicalRecord","from","getVersionKey","JpdictStore","state","toStoreRecord","words","names","kanji","radicals","getStoreId","deletePromise","_newVersion","kanjiTable","createObjectStore","keyPath","createIndex","multiEntry","radicalsTable","namesTable","wordsTable","console","log","close","destroy","clearSeries","targetTable","clear","versionTable","getDataVersion","versionDoc","updateDataVersion","put","updateSeries","durability","table","update","updates","isVeryGenericError","atOrNearQuota","info","_getKanji","estimate","navigator","storage","usage","quota","reducer","action","lastCheck","checkDate","fileProgress","totalProgress","KanjiMetaSchema","p","bv","bg","AccentSchema","pos","ReadingMetaSchema","app","CrossReferenceSchema","sense","LangSourceSchema","src","wasei","WordSenseSchema","g","gt","kapp","rapp","misc","dial","inf","xref","ant","lsrc","WordIdSchema","WordDownloadRecordSchema","validateWordDownloadRecord","WordDownloadDeleteRecordSchema","validateWordDownloadDeleteRecord","NameTranslationSchema","det","cf","NameIdSchema","NameDownloadRecordSchema","tr","validateNameDownloadRecord","NameDownloadDeleteRecordSchema","validateNameDownloadDeleteRecord","ReadingsStruct","on","kun","na","py","RadicalStruct","nelson","var","MiscSchema","gr","sc","freq","jlpt","jlptn","kk","wk","meta","KanjiIdSchema","KanjiDownloadRecordSchema","m","m_lang","rad","refs","st","comp","validateKanjiDownloadRecord","KanjiDownloadDeleteRecordSchema","validateKanjiDownloadDeleteRecord","RadicalIdSchema","RadicalDownloadRecordSchema","pua","posn","validateRadicalDownloadRecord","RadicalDownloadDeleteRecordSchema","validateRadicalDownloadDeleteRecord","validateDownloadRecordMapping","validateDownloadRecord","validateDownloadDeleteRecordMapping","validateDownloadDeleteRecord","BATCH_SIZE","MAX_PROGRESS_RESOLUTION","doUpdate","currentFile","currentFileVersion","totalFiles","currentRecord","lastReportedTotalProgress","versionToWrite","parseRecordEvent","unvalidatedRecord","err","MAJOR_VERSION","JpdictIdb","updateState","verbose","changeListeners","inProgressUpdates","readyPromise","dataVersion","notifyChanged","ready","hasData","hasInProgressUpdate","deleteSeries","cancelUpdate","addChangeListener","indexOf","removeChangeListener","topic","existingUpdate","updatePromise","finally","requestedLang","wroteSomething","warn","currentLang","inProgressUpdate","isVerbose","OfflineError","GlossTypes","GLOSS_TYPE_MAX","Math","floor","log2","toUpdateErrorState","nextRetry","retryCount","requestIdleCallback","cancelIdleCallback","timeRemaining","handle","uuid","crypto","getRandomValues","Uint8Array","dbToUuid","getUpdateKey","obj","baseId","updateWithRetry","startUpdate","onUpdateComplete","onUpdateError","updateNow","runUpdate","onLine","onlineCallback","once","goOffline","beginUpdating","resetUpdate","suppressError","isNetworkError","scheduleResult","maybeScheduleRetry","maybeScheduleIdleRetry","onDatabaseChange","seriesHasProgress","downloadedSomething","clearRetryInterval","cancelUpdateWithRetry","updateKey","retryState","setTimeoutHandle","requestIdleCallbackHandle","changeCallback","getOrRegisterChangeCallback","getRetryCount","retryIntervalMs","getRetryIntervalMs","min","random","serializeError","stack","notifyDbStateUpdated","notifyDbUpdateComplete","leaveBreadcrumb","notifyError","severity","JpdictLocalBackend","listener","listeners","l","updateDb","updateAllSeries","forceUpdate","force","notifyListeners","cancelUpdateDb","currentUpdate","deleteDb","queryState","dbIsInitialized","doDbStateNotification","initDb","requestIdleCallbackPromise","wasForcedUpdate","hasBuggyObjectStoreClear","langChanged","diffInMs","lastUpdateError","runNextUpdate","getLatestCheckTime","updateError","listenersCopy","bind","latestCheckAsNumber","max","userAgent","firefoxOrThunderbird","exec","parseInt","backend","postMessage","onmessage","data"],"mappings":"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"}