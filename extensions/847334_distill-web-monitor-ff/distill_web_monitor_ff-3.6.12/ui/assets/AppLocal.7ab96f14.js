var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, a as space, t as text, b as attr, c as src_url_equal, u as urlCfg, d as Supports, f as set_style, g as insert, h as append, l as listen, p as prevent_default, n as noop, j as detach, k as destroy_each, m as component_subscribe, o as params, q as getContext, A as Api, r as set_data, v as create_slot, w as update_slot_base, x as get_all_dirty_from_scope, y as get_slot_changes, z as transition_in, B as group_outros, C as transition_out, D as check_outros, E as compute_rest_props, F as compute_slots, G as assign$1, H as exclude_internal_props, I as create_component, J as mount_component, K as destroy_component, L as directive, N as NodePart, M as createMarker, O as reparentNodes, P as removeNodes, V as View, Q as Editor, R as Model$2, T as C$2, U as Msg, W as subscribe, X as run_all, Y as createEventDispatcher, Z as set_attributes, _ as toggle_class, $ as action_destroyer, a0 as get_spread_update, a1 as bubble, a2 as createFieldStore, a3 as handle_promise, a4 as update_await_block_branch, a5 as empty, a6 as binding_callbacks, a7 as bind$2, a8 as add_flush_callback, a9 as FormModel, aa as onMount, ab as TYPES, ac as FieldList, ad as get_binding_group_value, ae as init_binding_group, af as get_spread_object, ag as register, ah as derived, ai as ModelClient, aj as construct_svelte_component, ak as set_input_value, al as tick, am as onDestroy, an as add_render_callback, ao as select_option, ap as update_keyed_each, aq as destroy_block, ar as select_value, as as outro_and_destroy_block, at as Router, au as afterUpdate, av as base, aw as globals, ax as setContext, ay as is_function, az as svg_element, aA as get_store_value, aB as writable, aC as flush, aD as null_to_empty, aE as querystring, aF as location$1, aG as push$1, aH as set_store_value, aI as to_number, aJ as Base$2, aK as html, aL as getDef, aM as defs, aN as And, aO as Or, aP as SingleRule, aQ as set_svg_attributes, aR as hasNumeric, aS as RuleToTypeMap, aT as Macros, aU as render, aV as AttrModel, aW as stop_propagation, aX as JSONEdit, aY as V1$1, aZ as V2$1, a_ as parse$3, a$ as Crawlers, b0 as CrawlerJobs, b1 as Crawler$2, b2 as CrawlerJob, b3 as JobStates, b4 as replace$1, b5 as Self, b6 as Core$1, b7 as loadLang } from "./sieve.0422c872.js";
import { S as SPRINTF, a as SearchForm, b as Selector$2, g as getBasePath, r as route, c as checkSieveConstraint, i as instance$4s, d as getCurrentRoute, M as ModelLabel, u as updateTeam, e as updateRoute } from "./label.d933b3ec.js";
import { T, s as serviceProxy, f as formatTime, t as toISOString, _ as __vitePreload, a as formatTimeV2, g as getShortDisplayText, b as formatInterval, c as getInterval$1, i as i18n, d as format, e as getDuration } from "./service.04921d45.js";
import { F as FieldWrapper, M as Menu$1, I as InputEdit, a as MultiSelectMenu, c as clickOutside$1, C as Cross$1, b as MenuItem$1, A as Accordion } from "./Accordion.3fd5a551.js";
var inbox = "";
var langs = [{
  locale: "en-US",
  label: "English (US)"
}, {
  locale: "de",
  label: "Deutsch"
}, {
  locale: "fr",
  label: "Fran\xE7ais"
}, {
  locale: "ru",
  label: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439"
}, {
  locale: "ja",
  label: "\u65E5\u672C\u8A9E"
}, {
  locale: "zh",
  label: "\u7B80\u4F53\u4E2D\u6587"
}, {
  locale: "es",
  label: "Espa\xF1ol"
}, {
  locale: "it",
  label: "Italiano"
}, {
  locale: "pl",
  label: "Polskie"
}, {
  locale: "pt",
  label: "Portugu\xEAs do Brasil"
}, {
  locale: "sr",
  label: "\u0421\u0440\u043F\u0441\u043A\u0438"
}];
function get_each_context$18(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function get_each_context_2$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  return child_ctx;
}
function create_else_block_1$i(ctx) {
  let div;
  let a;
  let t0;
  let ul;
  let li;
  let t2;
  let each_value_2 = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$5(get_each_context_2$5(ctx, each_value_2, i2));
  }
  return {
    c() {
      div = element("div");
      a = element("a");
      a.innerHTML = `<i class="fa fa-list" aria-hidden="true"></i>`;
      t0 = space();
      ul = element("ul");
      li = element("li");
      li.textContent = "Watchlists";
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(a, "data-bs-toggle", "dropdown");
      attr(a, "href", "#");
      attr(li, "class", "dropdown-header uppercase");
      attr(ul, "class", "dropdown-menu");
      attr(ul, "role", "menu");
      attr(div, "class", "dropend");
      attr(div, "title", "Watchlist");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(div, t0);
      append(div, ul);
      append(ul, li);
      append(ul, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        each_value_2 = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$5(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2$5(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ul, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_4$s(ctx) {
  let a;
  let i2;
  return {
    c() {
      a = element("a");
      i2 = element("i");
      attr(i2, "class", "fa fa-list");
      attr(i2, "aria-hidden", "true");
      attr(a, "title", "Watchlist");
      attr(a, "href", urlCfg.watchlist);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i2);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_each_block_2$5(ctx) {
  let li;
  let a;
  let t0_value = ctx[19].name + "";
  let t0;
  let a_href_value;
  let t1;
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", "dropdown-item");
      attr(a, "href", a_href_value = ctx[19].href);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[19].name + ""))
        set_data(t0, t0_value);
      if (dirty & 4 && a_href_value !== (a_href_value = ctx2[19].href)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_each_block$18(ctx) {
  let li;
  let a;
  let t0_value = ctx[13].label + "";
  let t0;
  let a_class_value;
  let t1;
  let mounted;
  let dispose;
  function click_handler_1(...args) {
    return ctx[10](ctx[13], ...args);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", a_class_value = "dropdown-item " + (ctx[0].locale == ctx[13].locale ? "active" : ""));
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
      if (!mounted) {
        dispose = listen(a, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && a_class_value !== (a_class_value = "dropdown-item " + (ctx[0].locale == ctx[13].locale ? "active" : ""))) {
        attr(a, "class", a_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$1g(ctx) {
  let a;
  let t;
  return {
    c() {
      a = element("a");
      t = text("Sign In");
      attr(a, "role", "menuitem");
      attr(a, "class", "dropdown-item");
      attr(a, "href", urlCfg.login);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_2$_(ctx) {
  let a;
  let t0;
  let em;
  let t1_value = ctx[0].name + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t0 = text("Sign Out (");
      em = element("em");
      t1 = text(t1_value);
      t2 = text(")");
      attr(a, "role", "menuitem");
      attr(a, "class", "dropdown-item");
      attr(a, "href", urlCfg.logout);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, em);
      append(em, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1r(ctx) {
  let li;
  let a;
  let t_value = T("l_billing") + "";
  let t;
  return {
    c() {
      li = element("li");
      a = element("a");
      t = text(t_value);
      attr(a, "href", urlCfg.billing);
      attr(a, "class", "dropdown-item");
      attr(a, "target", "_blank");
      attr(a, "role", "menuitem");
      attr(li, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_if_block$2m(ctx) {
  let li;
  let a;
  let t_value = T("l_admin") + "";
  let t;
  return {
    c() {
      li = element("li");
      a = element("a");
      t = text(t_value);
      attr(a, "href", urlCfg.admin);
      attr(a, "class", "dropdown-item");
      attr(a, "role", "menuitem");
      attr(a, "target", "_blank");
      attr(li, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_fragment$4C(ctx) {
  let div4;
  let a0;
  let img;
  let img_src_value;
  let t0;
  let t1;
  let a1;
  let i0;
  let a1_href_value;
  let a1_data_team_id_value;
  let t2;
  let a2;
  let i1;
  let t3;
  let a3;
  let i2;
  let t4;
  let i3;
  let t5;
  let a4;
  let t6;
  let div1;
  let a5;
  let i5;
  let t7;
  let div0;
  let t8;
  let t9;
  let div2;
  let a6;
  let t10;
  let ul0;
  let t11;
  let div3;
  let a7;
  let t12;
  let ul1;
  let li0;
  let t13;
  let li1;
  let t14;
  let li2;
  let a8;
  let t16;
  let li3;
  let a9;
  let t17_value = T("l_settings") + "";
  let t17;
  let t18;
  let t19;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].length == 1)
      return create_if_block_4$s;
    return create_else_block_1$i;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let each_value = langs;
  let each_blocks = [];
  for (let i4 = 0; i4 < each_value.length; i4 += 1) {
    each_blocks[i4] = create_each_block$18(get_each_context$18(ctx, each_value, i4));
  }
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[4].isLoggedIn())
      return create_if_block_2$_;
    return create_else_block$1g;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block2 = current_block_type_1(ctx);
  let if_block3 = !ctx[0].account_id && create_if_block_1$1r();
  let if_block4 = ctx[0].role == "admin" && create_if_block$2m();
  return {
    c() {
      var _a, _b;
      div4 = element("div");
      a0 = element("a");
      img = element("img");
      t0 = space();
      if_block0.c();
      t1 = space();
      a1 = element("a");
      i0 = element("i");
      t2 = space();
      a2 = element("a");
      i1 = element("i");
      t3 = space();
      a3 = element("a");
      i2 = element("i");
      t4 = space();
      i3 = element("i");
      t5 = space();
      a4 = element("a");
      a4.innerHTML = `<i class="fa fa-rocket" aria-hidden="true"></i>`;
      t6 = space();
      div1 = element("div");
      a5 = element("a");
      i5 = element("i");
      t7 = space();
      div0 = element("div");
      t8 = space();
      t9 = space();
      div2 = element("div");
      a6 = element("a");
      a6.innerHTML = `<i class="fa fa-language" aria-hidden="true"></i>`;
      t10 = space();
      ul0 = element("ul");
      for (let i4 = 0; i4 < each_blocks.length; i4 += 1) {
        each_blocks[i4].c();
      }
      t11 = space();
      div3 = element("div");
      a7 = element("a");
      a7.innerHTML = `<i class="fa fa-cog" aria-hidden="true"></i>`;
      t12 = space();
      ul1 = element("ul");
      li0 = element("li");
      if_block2.c();
      t13 = space();
      li1 = element("li");
      t14 = space();
      li2 = element("li");
      a8 = element("a");
      a8.textContent = `${T("l_support")}`;
      t16 = space();
      li3 = element("li");
      a9 = element("a");
      t17 = text(t17_value);
      t18 = space();
      if (if_block3)
        if_block3.c();
      t19 = space();
      if (if_block4)
        if_block4.c();
      attr(img, "height", "38");
      attr(img, "alt", "distill-logo");
      if (!src_url_equal(img.src, img_src_value = "./img/distill_logo_inverted.svg"))
        attr(img, "src", img_src_value);
      attr(a0, "class", "xside-logo");
      attr(a0, "target", "_blank");
      attr(a0, "rel", "noopener");
      attr(a0, "title", "Distill.io");
      attr(a0, "href", urlCfg.website);
      attr(i0, "class", "fa fa-bar-chart-o");
      attr(i0, "aria-hidden", "true");
      attr(a1, "title", "Usage");
      attr(a1, "href", a1_href_value = urlCfg.usageAvailabilityForTeam(((_a = ctx[3]) == null ? void 0 : _a.team) || 0));
      attr(a1, "data-team-id", a1_data_team_id_value = ((_b = ctx[3]) == null ? void 0 : _b.team) || 0);
      attr(i1, "class", "fa fa-users");
      attr(i1, "aria-hidden", "true");
      attr(a2, "href", urlCfg.groups);
      attr(a2, "title", "Manage Teams");
      attr(i2, "class", "fa fa-book");
      attr(i2, "aria-hidden", "true");
      attr(a3, "href", urlCfg.website + "/changelog/" + (Supports.agents.local ? `#${serviceProxy.CFG.VERSION}` : ""));
      attr(a3, "title", "Changelog");
      attr(a3, "target", "_blank");
      set_style(i3, "flex", "1");
      attr(a4, "class", "dropdown-toggle");
      attr(a4, "href", "#");
      attr(a4, "data-toggle", "dropdown");
      attr(a4, "title", "What's new");
      a4.hidden = true;
      attr(i5, "class", "fa fa-comment");
      attr(i5, "aria-hidden", "true");
      attr(a5, "class", "ripple");
      attr(a5, "href", urlCfg.forums);
      attr(a5, "title", "Forums");
      attr(a5, "target", "_blank");
      attr(div0, "id", "feedPop");
      attr(a6, "class", "");
      attr(a6, "data-bs-toggle", "dropdown");
      attr(a6, "href", "#");
      attr(ul0, "class", "dropdown-menu");
      attr(ul0, "role", "menu");
      attr(div2, "class", "dropend");
      attr(div2, "title", "Language");
      attr(a7, "data-bs-toggle", "dropdown");
      attr(a7, "href", "#");
      attr(li0, "role", "presentation");
      attr(li1, "class", "divider");
      attr(a8, "target", "_blank");
      attr(a8, "rel", "noopener");
      attr(a8, "class", "dropdown-item");
      attr(a8, "href", "https://distill.io/docs/web-monitor/");
      attr(a9, "class", "dropdown-item");
      attr(a9, "role", "menuitem");
      attr(a9, "href", urlCfg.settings);
      attr(li3, "role", "presentation");
      attr(ul1, "class", "dropdown-menu");
      attr(ul1, "role", "menu");
      attr(div3, "class", "dropend");
      attr(div3, "title", "Settings");
      attr(div4, "class", "vbar h-full");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, a0);
      append(a0, img);
      append(div4, t0);
      if_block0.m(div4, null);
      append(div4, t1);
      append(div4, a1);
      append(a1, i0);
      append(div4, t2);
      append(div4, a2);
      append(a2, i1);
      append(div4, t3);
      append(div4, a3);
      append(a3, i2);
      append(div4, t4);
      append(div4, i3);
      append(div4, t5);
      append(div4, a4);
      append(div4, t6);
      append(div4, div1);
      append(div1, a5);
      append(a5, i5);
      append(div1, t7);
      append(div1, div0);
      append(div4, t8);
      append(div4, t9);
      append(div4, div2);
      append(div2, a6);
      append(div2, t10);
      append(div2, ul0);
      for (let i4 = 0; i4 < each_blocks.length; i4 += 1) {
        if (each_blocks[i4]) {
          each_blocks[i4].m(ul0, null);
        }
      }
      append(div4, t11);
      append(div4, div3);
      append(div3, a7);
      append(div3, t12);
      append(div3, ul1);
      append(ul1, li0);
      if_block2.m(li0, null);
      append(ul1, t13);
      append(ul1, li1);
      append(ul1, t14);
      append(ul1, li2);
      append(li2, a8);
      append(ul1, t16);
      append(ul1, li3);
      append(li3, a9);
      append(a9, t17);
      append(ul1, t18);
      if (if_block3)
        if_block3.m(ul1, null);
      append(ul1, t19);
      if (if_block4)
        if_block4.m(ul1, null);
      if (!mounted) {
        dispose = listen(a4, "click", prevent_default(ctx[5]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a, _b;
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div4, t1);
        }
      }
      if (dirty & 8 && a1_href_value !== (a1_href_value = urlCfg.usageAvailabilityForTeam(((_a = ctx2[3]) == null ? void 0 : _a.team) || 0))) {
        attr(a1, "href", a1_href_value);
      }
      if (dirty & 8 && a1_data_team_id_value !== (a1_data_team_id_value = ((_b = ctx2[3]) == null ? void 0 : _b.team) || 0)) {
        attr(a1, "data-team-id", a1_data_team_id_value);
      }
      if (dirty & 129) {
        each_value = langs;
        let i4;
        for (i4 = 0; i4 < each_value.length; i4 += 1) {
          const child_ctx = get_each_context$18(ctx2, each_value, i4);
          if (each_blocks[i4]) {
            each_blocks[i4].p(child_ctx, dirty);
          } else {
            each_blocks[i4] = create_each_block$18(child_ctx);
            each_blocks[i4].c();
            each_blocks[i4].m(ul0, null);
          }
        }
        for (; i4 < each_blocks.length; i4 += 1) {
          each_blocks[i4].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if_block2.p(ctx2, dirty);
      if (!ctx2[0].account_id) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_1$1r();
          if_block3.c();
          if_block3.m(ul1, t19);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (ctx2[0].role == "admin") {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block$2m();
          if_block4.c();
          if_block4.m(ul1, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      if_block0.d();
      destroy_each(each_blocks, detaching);
      if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$4r($$self, $$props, $$invalidate) {
  let $user;
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(3, $params = $$value));
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(0, $user = value));
  let currentTheme = window.App.store.get("theme");
  let groups = $user.groups || [];
  let watchlists = [];
  function openReleaseMenu() {
  }
  async function onSignOut(e) {
    if (Supports.agents.local) {
      e.preventDefault();
      await serviceProxy.auth.logout();
      location.href = urlCfg.logout;
    }
  }
  async function setLocale(locale) {
    if (Supports.agents.local) {
      const id2 = await serviceProxy.auth.getId();
      await serviceProxy.store.Prefs.set("locale", locale);
      if (id2) {
        Api.api("/users", "PUT", { id: id2, locale }, async function() {
          await serviceProxy.SyncMan._syncStore(serviceProxy.store.UserStore);
          location.reload();
        });
      } else {
        location.reload();
      }
    } else {
      if (USER) {
        Api.api("/users", "PUT", { locale }, function() {
          location.reload();
        });
      }
    }
  }
  function setTheme(theme) {
    if (theme != "light" && theme != "dark") {
      return;
    }
    document.documentElement.setAttribute("data-bs-theme", theme);
    window.App.store.set("theme", theme);
    $$invalidate(1, currentTheme = theme);
  }
  const click_handler = (theme) => {
    setTheme(theme.name);
  };
  const click_handler_1 = async (l, e) => {
    e.preventDefault();
    await setLocale(l.locale);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        $$invalidate(2, watchlists = [
          {
            name: `${$user.name} (personal)`,
            href: "#/w/0/list/all/"
          },
          ...groups.map((g) => ({
            name: g.name,
            href: `#/w/${g.id}/list/all/`
          }))
        ]);
      }
    }
  };
  return [
    $user,
    currentTheme,
    watchlists,
    $params,
    user,
    openReleaseMenu,
    onSignOut,
    setLocale,
    setTheme,
    click_handler,
    click_handler_1
  ];
}
class VBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4r, create_fragment$4C, safe_not_equal, {});
  }
}
var Layout_svelte_svelte_type_style_lang = "";
const get_topbar_slot_changes = (dirty) => ({});
const get_topbar_slot_context = (ctx) => ({});
const get_sidebar_slot_changes = (dirty) => ({});
const get_sidebar_slot_context = (ctx) => ({});
function fallback_block$b(ctx) {
  let div;
  let vbar;
  let current;
  vbar = new VBar({ props: { class: "h-100" } });
  return {
    c() {
      div = element("div");
      create_component(vbar.$$.fragment);
      attr(div, "class", "xsidebar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(vbar, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(vbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(vbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(vbar);
    }
  };
}
function create_if_block$2l(ctx) {
  let div;
  let current;
  const topbar_slot_template = ctx[3].topbar;
  const topbar_slot = create_slot(topbar_slot_template, ctx, ctx[2], get_topbar_slot_context);
  return {
    c() {
      div = element("div");
      if (topbar_slot)
        topbar_slot.c();
      attr(div, "class", "xheader");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (topbar_slot) {
        topbar_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (topbar_slot) {
        if (topbar_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            topbar_slot,
            topbar_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(topbar_slot_template, ctx2[2], dirty, get_topbar_slot_changes),
            get_topbar_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar_slot, local);
      current = true;
    },
    o(local) {
      transition_out(topbar_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (topbar_slot)
        topbar_slot.d(detaching);
    }
  };
}
function create_fragment$4B(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let div1_style_value;
  let current;
  const sidebar_slot_template = ctx[3].sidebar;
  const sidebar_slot = create_slot(sidebar_slot_template, ctx, ctx[2], get_sidebar_slot_context);
  const sidebar_slot_or_fallback = sidebar_slot || fallback_block$b();
  let if_block = ctx[1].topbar && create_if_block$2l(ctx);
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      div1 = element("div");
      if (sidebar_slot_or_fallback)
        sidebar_slot_or_fallback.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "xcontent");
      attr(div1, "class", "xgrid h-screen w-screen min-w-[750px]");
      attr(div1, "style", div1_style_value = "grid-template-rows: auto minmax(1px,1fr);grid-template-columns: auto 1fr; " + (ctx[0].style || ""));
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (sidebar_slot_or_fallback) {
        sidebar_slot_or_fallback.m(div1, null);
      }
      append(div1, t0);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (sidebar_slot) {
        if (sidebar_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            sidebar_slot,
            sidebar_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(sidebar_slot_template, ctx2[2], dirty, get_sidebar_slot_changes),
            get_sidebar_slot_context
          );
        }
      }
      if (ctx2[1].topbar) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2l(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && div1_style_value !== (div1_style_value = "grid-template-rows: auto minmax(1px,1fr);grid-template-columns: auto 1fr; " + (ctx2[0].style || ""))) {
        attr(div1, "style", div1_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar_slot_or_fallback, local);
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar_slot_or_fallback, local);
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (sidebar_slot_or_fallback)
        sidebar_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$4q($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  return [$$restProps, $$slots, $$scope, slots];
}
class Layout$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4q, create_fragment$4B, safe_not_equal, {});
  }
}
function create_if_block_1$1q(ctx) {
  let div;
  let t_value = ctx[1].account.name + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "pr-8 fw4 f4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].account.name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block$1f(ctx) {
  let a;
  let t;
  return {
    c() {
      a = element("a");
      t = text("Sign In");
      attr(a, "href", urlCfg.login);
      attr(a, "class", "xnav-a");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block$2k(ctx) {
  let a;
  let t_value = ctx[1].name + "";
  let t;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "href", "#/settings/profile/");
      attr(a, "class", "fw3 xnav-a");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_fragment$4A(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let a;
  let t4;
  let t5;
  let if_block0 = ctx[1].account && create_if_block_1$1q(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].id)
      return create_if_block$2k;
    return create_else_block$1f;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      div1 = element("div");
      t2 = space();
      a = element("a");
      a.textContent = "Get Help";
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if_block1.c();
      attr(div0, "class", "title-header ttu fw4 f3");
      attr(div1, "class", "flex-grow");
      attr(a, "class", "btn btn-primary btn-sm xbtn-default mr-2");
      attr(a, "href", "https://distill.io/docs/contact-us/");
      attr(a, "target", "_blank");
      attr(div2, "id", "topbar");
      attr(div2, "class", "flex items-center mt1 bb b--light-gray");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div2, t2);
      append(div2, a);
      append(div2, t4);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t5);
      if_block1.m(div2, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (ctx2[1].account) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$1q(ctx2);
          if_block0.c();
          if_block0.m(div2, t5);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div2, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
}
function instance$4p($$self, $$props, $$invalidate) {
  let $user;
  let { title = "Distill" } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(1, $user = value));
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
  };
  return [title, $user, user];
}
class Topbar$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4p, create_fragment$4A, safe_not_equal, { title: 0 });
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const createAndInsertPart = (containerPart, beforePart) => {
  const container = containerPart.startNode.parentNode;
  const beforeNode = beforePart === void 0 ? containerPart.endNode : beforePart.startNode;
  const startNode = container.insertBefore(createMarker(), beforeNode);
  container.insertBefore(createMarker(), beforeNode);
  const newPart = new NodePart(containerPart.options);
  newPart.insertAfterNode(startNode);
  return newPart;
};
const updatePart = (part, value) => {
  part.setValue(value);
  part.commit();
  return part;
};
const insertPartBefore = (containerPart, part, ref) => {
  const container = containerPart.startNode.parentNode;
  const beforeNode = ref ? ref.startNode : containerPart.endNode;
  const endNode = part.endNode.nextSibling;
  if (endNode !== beforeNode) {
    reparentNodes(container, part.startNode, endNode, beforeNode);
  }
};
const removePart = (part) => {
  removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);
};
const generateMap = (list, start, end) => {
  const map = /* @__PURE__ */ new Map();
  for (let i2 = start; i2 <= end; i2++) {
    map.set(list[i2], i2);
  }
  return map;
};
const partListCache = /* @__PURE__ */ new WeakMap();
const keyListCache = /* @__PURE__ */ new WeakMap();
const repeat = directive((items, keyFnOrTemplate, template) => {
  let keyFn;
  if (template === void 0) {
    template = keyFnOrTemplate;
  } else if (keyFnOrTemplate !== void 0) {
    keyFn = keyFnOrTemplate;
  }
  return (containerPart) => {
    if (!(containerPart instanceof NodePart)) {
      throw new Error("repeat can only be used in text bindings");
    }
    const oldParts = partListCache.get(containerPart) || [];
    const oldKeys = keyListCache.get(containerPart) || [];
    const newParts = [];
    const newValues = [];
    const newKeys = [];
    let index2 = 0;
    for (const item of items) {
      newKeys[index2] = keyFn ? keyFn(item, index2) : index2;
      newValues[index2] = template(item, index2);
      index2++;
    }
    let newKeyToIndexMap;
    let oldKeyToIndexMap;
    let oldHead = 0;
    let oldTail = oldParts.length - 1;
    let newHead = 0;
    let newTail = newValues.length - 1;
    while (oldHead <= oldTail && newHead <= newTail) {
      if (oldParts[oldHead] === null) {
        oldHead++;
      } else if (oldParts[oldTail] === null) {
        oldTail--;
      } else if (oldKeys[oldHead] === newKeys[newHead]) {
        newParts[newHead] = updatePart(oldParts[oldHead], newValues[newHead]);
        oldHead++;
        newHead++;
      } else if (oldKeys[oldTail] === newKeys[newTail]) {
        newParts[newTail] = updatePart(oldParts[oldTail], newValues[newTail]);
        oldTail--;
        newTail--;
      } else if (oldKeys[oldHead] === newKeys[newTail]) {
        newParts[newTail] = updatePart(oldParts[oldHead], newValues[newTail]);
        insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);
        oldHead++;
        newTail--;
      } else if (oldKeys[oldTail] === newKeys[newHead]) {
        newParts[newHead] = updatePart(oldParts[oldTail], newValues[newHead]);
        insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);
        oldTail--;
        newHead++;
      } else {
        if (newKeyToIndexMap === void 0) {
          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
        }
        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
          removePart(oldParts[oldHead]);
          oldHead++;
        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
          removePart(oldParts[oldTail]);
          oldTail--;
        } else {
          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
          const oldPart = oldIndex !== void 0 ? oldParts[oldIndex] : null;
          if (oldPart === null) {
            const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);
            updatePart(newPart, newValues[newHead]);
            newParts[newHead] = newPart;
          } else {
            newParts[newHead] = updatePart(oldPart, newValues[newHead]);
            insertPartBefore(containerPart, oldPart, oldParts[oldHead]);
            oldParts[oldIndex] = null;
          }
          newHead++;
        }
      }
    }
    while (newHead <= newTail) {
      const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);
      updatePart(newPart, newValues[newHead]);
      newParts[newHead++] = newPart;
    }
    while (oldHead <= oldTail) {
      const oldPart = oldParts[oldHead++];
      if (oldPart !== null) {
        removePart(oldPart);
      }
    }
    partListCache.set(containerPart, newParts);
    keyListCache.set(containerPart, newKeys);
  };
});
let KVStore = serviceProxy.store.KVStore;
const $$4 = window.jQuery;
if (!$$4) {
  throw new Error("ADD jQuery");
}
const _$5 = window._;
if (!_$5) {
  throw new Error("ADD _");
}
const domo$4 = window.domo;
if (!domo$4) {
  throw new Error("ADD domo");
}
const Backbone$7 = window.Backbone;
if (!Backbone$7) {
  throw new Error("ADD Backbone");
}
const Common = View.Base.extend({
  name: "actions$Common",
  events: {
    "change": "event_change"
  },
  event_change: function() {
    this.saveValues();
  },
  render: function() {
    this.$el.attr({
      "id": "common",
      "class": "card panel-default"
    }).append(
      HEADER(
        { "class": "card-header" },
        H3(T("l_actions"))
      ),
      DIV(
        { "class": "card-body" },
        DIV(
          { "class": "checkbox" },
          LABEL(
            INPUT({ type: "checkbox", name: "actions.popup" }),
            T("l_action_local_popup")
          )
        ),
        DIV(
          { "class": "checkbox" },
          LABEL(
            INPUT({ type: "checkbox", name: "actions.audio" }),
            T("l_action_local_audio")
          )
        ),
        DIV(
          { "class": "form-group" },
          T("m_firefox_only"),
          " - ",
          T("m_autohide_popup"),
          ": ",
          SELECT(
            { "name": "actions.popup.autohide", "style": "width:auto" },
            OPTION({ value: 0 }, T("l_never")),
            OPTION({ value: 5 }, "5s"),
            OPTION({ value: 10 }, "10s"),
            OPTION({ value: 20 }, "20s"),
            OPTION({ value: 60 }, "1m"),
            OPTION({ value: 120 }, "2m"),
            OPTION({ value: 300 }, "5m")
          )
        ),
        DIV(
          { "class": "alert alert-info" },
          A({ href: "https://distill.io/settings/actions" }, T("Change email action settings from web app!"))
        )
      )
    );
    this.setValues();
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(function() {
      const el = this;
      if (el.type == "checkbox") {
        serviceProxy.store.Prefs.set(el.name, el.checked);
      } else {
        serviceProxy.store.Prefs.set(el.name, el.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        el.checked = await serviceProxy.store.Prefs.get(el.name);
      } else {
        el.value = await serviceProxy.store.Prefs.get(el.name);
      }
    });
  }
});
const Tone = View.Base.extend({
  name: "Tone",
  className: "form-group",
  events: {
    "click button.xdel": "event_del",
    "click button.xplay": "event_play"
  },
  event_del: function() {
    this.model.collection.remove(this.model);
  },
  event_play: function() {
    if (this.model.get("type") == "file") {
      this.playFile();
    } else {
      this.playSrc(this.input.getValue());
    }
  },
  getDefaultName: function(path) {
    const parts = path.split(/(\/|\\)/);
    return parts.pop() || "New File";
  },
  onInputChange: function() {
    const value = this.input.getValue();
    if (_$5.isEmpty(this.label.getValue())) {
      this.label.setValue(this.getDefaultName(value));
    }
  },
  playFile: function() {
    if (this.input.field.files) {
      this.playSelectedFile();
    } else {
      this.playSavedFile();
    }
  },
  playSavedFile: async function() {
    const ref = this.model.get("value");
    try {
      let doc = await KVStore.findOne(ref);
      this.playSrc(doc.value);
    } catch (err) {
      console.error("Error while playing saved file", err);
    }
  },
  async playSelectedFile() {
    const file = this.input.field.files[0];
    if (file) {
      this.playSrc(await readFile$2(file));
    } else {
      alert("Please select an audio file before playing it.");
    }
  },
  playSrc(src2) {
    AUDIO({ src: src2 }).play();
  },
  postInit: function() {
    this.label = Editor.create({
      model: this.model,
      param: {
        label: "l_name",
        name: "label",
        type: "text"
      },
      parent: this
    });
    this.input = Editor.create({
      model: this.model,
      param: this.model.get("type") == "url" ? {
        label: "l_url",
        type: "url",
        name: "value"
      } : this.model.get("value") != null ? {
        type: "static",
        name: "value"
      } : {
        label: "l_file",
        type: "file",
        name: "value"
      },
      parent: this
    });
    this.listenTo(this.input, "change", this.onInputChange);
  },
  render: function() {
    this.$el.append(
      DIV(
        { "class": "col-md-3" },
        this.label.render().el
      ),
      DIV(
        { "class": "col-md-6" },
        this.input.render().el
      ),
      DIV(
        { "class": "col-md-3" },
        BUTTON({ "class": "btn btn-default xplay" }, T("a_play")),
        " ",
        BUTTON({ "class": "btn btn-default xdel" }, I({ "class": "fa fa-times" }))
      )
    );
    if (this.model.get("type") == "file" && this.model.get("value") == null) {
      this.input.field.click();
    }
    return this;
  }
});
const ErrorSect = View.Base.extend({
  name: "actions$errorSect",
  events: {
    "change": "event_change"
  },
  event_change: function() {
    this.saveValues();
  },
  render: function() {
    const sounds = _$5.findWhere(Model$2.SieveActionDescList, { type: C$2.ACTION_LOCAL_AUDIO })["params"][0].list;
    this.$el.attr({
      "id": "errorSect",
      "class": "card panel-default"
    }).append(
      HEADER(
        { "class": "card-header" },
        H3(T("Error Actions"))
      ),
      DIV(
        { "class": "card-body" },
        DIV(
          { "class": "checkbox" },
          LABEL(
            INPUT({ type: "checkbox", name: "errorAction.enabled" }),
            T("Trigger notifications")
          )
        ),
        DIV(
          { "class": "form-group" },
          T("l_notification_sound"),
          ": ",
          SELECT(
            { "name": "errorAction.sound", "style": "width:auto" },
            sounds.map(function(sound, index2) {
              return OPTION({ value: sound.value }, T(sound.label));
            })
          )
        ),
        DIV(
          { "class": "form-group" },
          T("Minimum time interval between notifications (in minutes): "),
          INPUT({ "type": "number", "style": "width: 60px;", "name": "errorAction.interval", "min": "1" })
        ),
        DIV(
          { "class": "form-group" },
          T("No. of consecutive errors to trigger notifications"),
          ": ",
          SELECT(
            { "name": "errorAction.minCount", "style": "width:auto" },
            OPTION({ value: 1 }, "1"),
            OPTION({ value: 2 }, "2"),
            OPTION({ value: 3 }, "3"),
            OPTION({ value: 4 }, "4"),
            OPTION({ value: 5 }, "5"),
            OPTION({ value: 6 }, "6"),
            OPTION({ value: 7 }, "7"),
            OPTION({ value: 8 }, "8"),
            OPTION({ value: 9 }, "9"),
            OPTION({ value: 10 }, "10")
          )
        ),
        DIV(
          { "class": "alert alert-info" },
          T("h_error_notif_desc")
        )
      )
    );
    this.setValues();
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(function() {
      const el = this;
      if (el.type == "checkbox") {
        serviceProxy.store.Prefs.set(el.name, el.checked);
      } else {
        serviceProxy.store.Prefs.set(el.name, el.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        el.checked = await serviceProxy.store.Prefs.get(el.name);
      } else {
        el.value = await serviceProxy.store.Prefs.get(el.name);
      }
    });
  }
});
const Tones$1 = View.Collection.extend({
  name: "actions$Tones",
  actions: {
    "tones add file": { fn: "action_add_file" },
    "tones add url": { fn: "action_add_url" },
    "tones save": { fn: "action_save" }
  },
  action_add_file: function() {
    const model = new Backbone$7.Model({ type: "file" });
    this.collection.add(model);
  },
  action_add_url: function() {
    const model = new Backbone$7.Model({ type: "url" });
    this.collection.add(model);
  },
  async action_save() {
    let file;
    Msg.start("save", "l_loading");
    let tones = [];
    for (let view of _$5.values(this.views)) {
      const files2 = view.input.field.files;
      const model = view.model;
      const json = model.toJSON();
      const isNewFile = !!files2;
      if (isNewFile && (file = files2[0])) {
        let dataURI = await readFile$2(file);
        const id2 = "tone:" + await sha1$1(dataURI);
        await KVStore.create({ id: id2, value: dataURI });
        json.value = id2;
      }
      tones.push(json);
    }
    const value = JSON.stringify(tones);
    let res = await KVStore.update("tones", { value });
    if (res._count === 0) {
      await KVStore.create({ id: "tones", value });
    }
    const oldFileRefs = files(this.oldTones);
    const savedFileRefs = files(tones);
    const removedFiles = _$5.difference(oldFileRefs, savedFileRefs);
    for (let file2 of removedFiles) {
      await KVStore.destroy(file2);
    }
    Msg.reset();
    this.load();
    function files(tones2) {
      return tones2.filter((tone) => tone.type == "file").map((tone) => tone.value);
    }
  },
  addOne: function(model) {
    const view = new Tone({ parent: this, model }).render();
    this.$list.append(view.el);
    return view;
  },
  initCollection: function() {
    this.oldTones = [];
    this.collection = new Backbone$7.Collection();
  },
  load: async function() {
    let doc = await KVStore.findOne("tones");
    if (doc) {
      this.oldTones = JSON.parse(doc.value);
      this.collection.reset(this.oldTones);
    }
  },
  renderBase: function() {
    this.$el.attr({
      "id": "tones",
      "class": "card panel-default"
    }).append(
      HEADER(
        { "class": "card-header clearfix" },
        H3({ "class": "pull-left" }, "Tones"),
        DIV(
          { "class": "right" },
          BUTTON(
            { "class": "btn btn-default btn-sm", "data-action": "tones add file" },
            T("a_add_file")
          ),
          BUTTON(
            { "class": "btn btn-default btn-sm", "data-action": "tones add url" },
            T("a_add_url")
          )
        )
      ),
      DIV(
        { "class": "card-body" },
        DIV({ "class": "xlist" })
      ),
      DIV(
        { "class": "card-footer" },
        BUTTON(
          { "class": "btn btn-primary", "data-action": "tones save" },
          T("a_save")
        )
      )
    );
    this.$list = this.$el.find(".xlist");
  }
});
View.ActionProvider.extend({
  name: "SettingsActions",
  load: function(callback) {
    this.tones.load(callback);
  },
  postInit: function() {
    this.common = new Common({ parent: this });
    this.errorSect = new ErrorSect({ parent: this });
    this.tones = new Tones$1({ parent: this });
  },
  render: function() {
    this.$el.append(
      this.common.render().el,
      this.errorSect.render().el,
      this.tones.render().el
    );
    return this;
  }
});
async function sha1$1(dataURI) {
  let encoder = new TextEncoder();
  let hashBuf = await crypto.subtle.digest("SHA-1", encoder.encode(dataURI));
  let hashArrBuf = Array.from(new Uint8Array(hashBuf));
  let hashHex = hashArrBuf.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
function readFile$2(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = function(e) {
      resolve(e.target.result);
    };
    reader.readAsDataURL(file);
  });
}
function create_fragment$4z(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[1];
      if (!mounted) {
        dispose = listen(input, "change", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        input.checked = ctx2[1];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function instance$4o($$self, $$props, $$invalidate) {
  let $field, $$unsubscribe_field = noop, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(1, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { field } = $$props;
  $$subscribe_field();
  function input_change_handler() {
    $field = this.checked;
    field.set($field);
  }
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$subscribe_field($$invalidate(0, field = $$props2.field));
  };
  return [field, $field, input_change_handler];
}
class Checkbox$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4o, create_fragment$4z, safe_not_equal, { field: 0 });
  }
}
function create_else_block$1e(ctx) {
  let div;
  let t_value = ctx[0].value + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "flex align-items-center h-100");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].value + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$2j(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "file");
      attr(input, "placeholder", "File");
      attr(input, "class", "form-control form-control-sm");
      attr(div, "class", "xtext xeditor control-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      if (!mounted) {
        dispose = listen(input, "change", ctx[3]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4y(ctx) {
  let div4;
  let div1;
  let div0;
  let input;
  let input_value_value;
  let t0;
  let div2;
  let t1;
  let div3;
  let button0;
  let t3;
  let button1;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].new)
      return create_if_block$2j;
    return create_else_block$1e;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div2 = element("div");
      if_block.c();
      t1 = space();
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Play";
      t3 = space();
      button1 = element("button");
      button1.innerHTML = `<i class="fa fa-times"></i>`;
      input.value = input_value_value = ctx[0].label;
      attr(input, "placeholder", "Name");
      attr(input, "type", "text");
      attr(input, "class", "form-control xform-control-sm inline");
      attr(div0, "class", "xtext xeditor control-group");
      attr(div1, "class", "col-md-3");
      attr(div2, "class", "col-md-6");
      attr(button0, "class", "btn btn-default xplay");
      attr(button1, "class", "btn btn-default xdel");
      attr(div3, "class", "col-md-3");
      attr(div4, "class", "row form-group m-2");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      append(div0, input);
      append(div4, t0);
      append(div4, div2);
      if_block.m(div2, null);
      append(div4, t1);
      append(div4, div3);
      append(div3, button0);
      append(div3, t3);
      append(div3, button1);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[2]),
          listen(button0, "click", ctx[4]),
          listen(button1, "click", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input_value_value !== (input_value_value = ctx2[0].label) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function readFile$1(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = function(e) {
      resolve(e.target.result);
    };
    reader.readAsDataURL(file);
  });
}
function getDefaultName$1(path) {
  const parts = path.split(/(\/|\\)/);
  return parts.pop() || "New File";
}
function instance$4n($$self, $$props, $$invalidate) {
  let { tone } = $$props;
  let { id: id2 } = $$props;
  const KVStore2 = serviceProxy.store.KVStore;
  const dispatch = createEventDispatcher();
  let audioSrc;
  let audioPlayer;
  function onDelete() {
    if (audioPlayer && !audioPlayer.paused) {
      audioPlayer.pause();
    }
    dispatch("delete", { id: id2 });
  }
  function updateLabel(e) {
    $$invalidate(0, tone.label = e.target.value, tone);
  }
  function onFileChange(e) {
    $$invalidate(0, tone.value = e.target.files[0], tone);
    if (!tone.label) {
      $$invalidate(0, tone.label = getDefaultName$1(e.target.value), tone);
    }
  }
  async function onPlay() {
    const file = tone.value;
    if (!file) {
      alert("Please select an audio file before playing it.");
      return;
    }
    if (!audioPlayer) {
      audioPlayer = new Audio();
    }
    if (tone.new) {
      audioSrc = await readFile$1(file);
    } else {
      try {
        let doc = await KVStore2.findOne(file);
        audioSrc = doc.value;
      } catch (e) {
        console.error("Error while playing saved file", e);
      }
    }
    audioPlayer.src = audioSrc;
    audioPlayer.load();
    audioPlayer.play();
  }
  $$self.$$set = ($$props2) => {
    if ("tone" in $$props2)
      $$invalidate(0, tone = $$props2.tone);
    if ("id" in $$props2)
      $$invalidate(5, id2 = $$props2.id);
  };
  return [tone, onDelete, updateLabel, onFileChange, onPlay, id2];
}
class ToneFile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4n, create_fragment$4y, safe_not_equal, { tone: 0, id: 5 });
  }
}
function create_default_slot$1q(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "text" },
    {
      class: input_class_value = "form-control " + ctx[1]
    },
    ctx[2]
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign$1(input_data, input_levels[i2]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
      toggle_class(input, "is-invalid", ctx[5]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          action_destroyer(ctx[4].call(null, input)),
          listen(input, "input", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        dirty & 2 && input_class_value !== (input_class_value = "form-control " + ctx2[1]) && { class: input_class_value },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(input, "is-invalid", ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$4x(ctx) {
  let fieldwrapper;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[0],
      $$slots: {
        default: [
          create_default_slot$1q,
          ({ action, showError }) => ({ 4: action, 5: showError }),
          ({ action, showError }) => (action ? 16 : 0) | (showError ? 32 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 1)
        fieldwrapper_changes.field = ctx2[0];
      if (dirty & 102) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
    }
  };
}
function instance$4m($$self, $$props, $$invalidate) {
  const omit_props_names = ["field", "classes"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { field } = $$props;
  let { classes: classes2 } = $$props;
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(0, field = $$new_props.field);
    if ("classes" in $$new_props)
      $$invalidate(1, classes2 = $$new_props.classes);
  };
  return [field, classes2, $$restProps, input_handler];
}
class UrlEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4m, create_fragment$4x, safe_not_equal, { field: 0, classes: 1 });
  }
}
function create_fragment$4w(ctx) {
  let div5;
  let div1;
  let div0;
  let input;
  let input_value_value;
  let t0;
  let div3;
  let div2;
  let urledit;
  let t1;
  let div4;
  let button0;
  let t3;
  let button1;
  let current;
  let mounted;
  let dispose;
  urledit = new UrlEdit({ props: { field: ctx[1] } });
  return {
    c() {
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(urledit.$$.fragment);
      t1 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "Play";
      t3 = space();
      button1 = element("button");
      button1.innerHTML = `<i class="fa fa-times"></i>`;
      input.value = input_value_value = ctx[0].label;
      attr(input, "placeholder", "Name");
      attr(input, "type", "text");
      attr(input, "class", "form-control xform-control-sm inline");
      attr(div0, "class", "xtext xeditor control-group");
      attr(div1, "class", "col-md-3");
      attr(div2, "class", "xurl flex items-stretch xeditor control-group");
      attr(div3, "class", "col-md-6");
      attr(button0, "class", "btn btn-default xplay");
      attr(button1, "class", "btn btn-default xdel");
      attr(div4, "class", "col-md-3");
      attr(div5, "class", "row form-group");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div1);
      append(div1, div0);
      append(div0, input);
      append(div5, t0);
      append(div5, div3);
      append(div3, div2);
      mount_component(urledit, div2, null);
      append(div5, t1);
      append(div5, div4);
      append(div4, button0);
      append(div4, t3);
      append(div4, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[4]),
          listen(button0, "click", ctx[2]),
          listen(button1, "click", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1 && input_value_value !== (input_value_value = ctx2[0].label) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(urledit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urledit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(urledit);
      mounted = false;
      run_all(dispose);
    }
  };
}
function getDefaultName(path) {
  const parts = path.split(/(\/|\\)/);
  return parts.pop() || "New URL";
}
function instance$4l($$self, $$props, $$invalidate) {
  let $url;
  let { id: id2 } = $$props;
  let { tone } = $$props;
  const dispatch = createEventDispatcher();
  const url = createFieldStore({ type: "url" }, tone.value);
  component_subscribe($$self, url, (value) => $$invalidate(6, $url = value));
  let audioPlayer;
  async function onPlay() {
    if (!audioPlayer) {
      audioPlayer = new Audio();
    }
    audioPlayer.src = $url;
    audioPlayer.load();
    audioPlayer.play();
  }
  function onDelete() {
    if (audioPlayer && !audioPlayer.paused) {
      audioPlayer.pause();
    }
    dispatch("delete", { id: id2 });
  }
  function updateLabel(e) {
    $$invalidate(0, tone.label = e.target.value, tone);
  }
  function onUrlChange() {
    $$invalidate(0, tone.value = $url, tone);
    if (!tone.label) {
      $$invalidate(0, tone.label = getDefaultName(url.toJSON()), tone);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(5, id2 = $$props2.id);
    if ("tone" in $$props2)
      $$invalidate(0, tone = $$props2.tone);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      if ($url) {
        onUrlChange();
      }
    }
  };
  return [tone, url, onPlay, onDelete, updateLabel, id2, $url];
}
class ToneUrl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4l, create_fragment$4w, safe_not_equal, { id: 5, tone: 0 });
  }
}
function get_each_context$17(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function create_catch_block$w(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$w(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$17(get_each_context$17(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 33) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$17(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$17(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_else_block$1d(ctx) {
  let toneurl;
  let current;
  toneurl = new ToneUrl({
    props: {
      id: ctx[13],
      tone: ctx[11]
    }
  });
  toneurl.$on("delete", ctx[5]);
  return {
    c() {
      create_component(toneurl.$$.fragment);
    },
    m(target, anchor) {
      mount_component(toneurl, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toneurl_changes = {};
      if (dirty & 1)
        toneurl_changes.tone = ctx2[11];
      toneurl.$set(toneurl_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toneurl.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toneurl.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toneurl, detaching);
    }
  };
}
function create_if_block$2i(ctx) {
  let tonefile;
  let current;
  tonefile = new ToneFile({
    props: {
      id: ctx[13],
      tone: ctx[11]
    }
  });
  tonefile.$on("delete", ctx[5]);
  return {
    c() {
      create_component(tonefile.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tonefile, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tonefile_changes = {};
      if (dirty & 1)
        tonefile_changes.tone = ctx2[11];
      tonefile.$set(tonefile_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tonefile.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tonefile.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tonefile, detaching);
    }
  };
}
function create_each_block$17(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$2i, create_else_block$1d];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[11].type === "file")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$w(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$4v(ctx) {
  let div3;
  let header;
  let h3;
  let t1;
  let div0;
  let button0;
  let t3;
  let button1;
  let t5;
  let t6;
  let div1;
  let t7;
  let div2;
  let button2;
  let current;
  let mounted;
  let dispose;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$w,
    then: create_then_block$w,
    catch: create_catch_block$w,
    value: 10,
    blocks: [, , ,]
  };
  handle_promise(ctx[1], info);
  return {
    c() {
      div3 = element("div");
      header = element("header");
      h3 = element("h3");
      h3.textContent = "Tones";
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Add file";
      t3 = space();
      button1 = element("button");
      button1.textContent = "Add url";
      t5 = space();
      info.block.c();
      t6 = space();
      div1 = element("div");
      t7 = space();
      div2 = element("div");
      button2 = element("button");
      button2.textContent = "Save";
      attr(h3, "class", "pull-left");
      attr(button0, "class", "btn btn-default btn-sm");
      attr(button1, "class", "btn btn-default btn-sm");
      attr(div0, "class", "right");
      attr(header, "class", "card-header clearfix");
      attr(div1, "class", "card-body");
      attr(button2, "class", "btn btn-primary");
      attr(div2, "class", "card-footer");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, header);
      append(header, h3);
      append(header, t1);
      append(header, div0);
      append(div0, button0);
      append(div0, t3);
      append(div0, button1);
      append(div3, t5);
      info.block.m(div3, info.anchor = null);
      info.mount = () => div3;
      info.anchor = t6;
      append(div3, t6);
      append(div3, div1);
      append(div3, t7);
      append(div3, div2);
      append(div2, button2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[2]),
          listen(button1, "click", ctx[3]),
          listen(button2, "click", ctx[4])
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      info.block.d();
      info.token = null;
      info = null;
      mounted = false;
      run_all(dispose);
    }
  };
}
function readFile(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = function(e) {
      resolve(e.target.result);
    };
    reader.readAsDataURL(file);
  });
}
async function sha1(dataURI) {
  let encoder = new TextEncoder();
  let hashBuf = await crypto.subtle.digest("SHA-1", encoder.encode(dataURI));
  let hashArrBuf = Array.from(new Uint8Array(hashBuf));
  let hashHex = hashArrBuf.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
function instance$4k($$self, $$props, $$invalidate) {
  const KVStore2 = serviceProxy.store.KVStore;
  const DEFAULTS = {
    FILE: {
      type: "file",
      value: "",
      label: "",
      new: true
    },
    URL: { type: "url", value: "", label: "" }
  };
  let tones = [];
  let removedTones = [];
  let loadPromise = loadTones();
  function addFileInput() {
    $$invalidate(0, tones = [...tones, structuredClone(DEFAULTS.FILE)]);
  }
  function addURLInput() {
    $$invalidate(0, tones = [...tones, structuredClone(DEFAULTS.URL)]);
  }
  async function saveTones() {
    Msg.start("save", "l_loading");
    for (let tone of tones) {
      if (tone.type === "file" && tone.new) {
        let dataURI = await readFile(tone.value);
        const id2 = "tone:" + await sha1(dataURI);
        await KVStore2.create({ id: id2, value: dataURI });
        tone.value = id2;
        delete tone.new;
      }
    }
    const saveTones2 = tones.filter((tone) => tone.value);
    const value = JSON.stringify(saveTones2);
    let res = await KVStore2.update("tones", { value });
    if (res._count === 0) {
      await KVStore2.create({ id: "tones", value });
    }
    if (removedTones.length) {
      const removedFiles = removedTones.filter((tone) => tone.type === "file" && !tone.new).map((file) => file.value);
      for (let file of removedFiles) {
        await KVStore2.destroy(file);
      }
      removedTones = [];
    }
    Msg.reset();
    await loadTones();
  }
  function onDelete(e) {
    let delIdx = e.detail.id;
    removedTones.push(tones[delIdx]);
    $$invalidate(0, tones = tones.filter((_2, index2) => index2 !== delIdx));
  }
  async function loadTones() {
    let doc = await KVStore2.findOne("tones");
    if (doc) {
      $$invalidate(0, tones = JSON.parse(doc.value));
    }
  }
  return [tones, loadPromise, addFileInput, addURLInput, saveTones, onDelete];
}
class Tones extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4k, create_fragment$4v, safe_not_equal, {});
  }
}
function create_fragment$4u(ctx) {
  let div17;
  let div6;
  let header0;
  let h30;
  let t1;
  let div5;
  let div4;
  let div0;
  let checkbox0;
  let t2;
  let t3_value = T("l_action_local_popup") + "";
  let t3;
  let t4;
  let div1;
  let checkbox1;
  let t5;
  let t6_value = T("l_action_local_audio") + "";
  let t6;
  let t7;
  let div2;
  let span0;
  let t12;
  let menu0;
  let updating_id;
  let t13;
  let div3;
  let a;
  let t14;
  let t15;
  let div16;
  let header1;
  let t17;
  let div15;
  let div14;
  let div7;
  let checkbox2;
  let t18;
  let t19;
  let div8;
  let span1;
  let t22;
  let menu1;
  let updating_id_1;
  let t23;
  let div10;
  let span2;
  let t25;
  let div9;
  let inputedit0;
  let t26;
  let div12;
  let span3;
  let t28;
  let div11;
  let inputedit1;
  let t29;
  let div13;
  let t31;
  let tones;
  let current;
  checkbox0 = new Checkbox$1({
    props: {
      field: ctx[3].fields.popup
    }
  });
  checkbox1 = new Checkbox$1({
    props: {
      field: ctx[3].fields.audio
    }
  });
  function menu0_id_binding(value) {
    ctx[8](value);
  }
  let menu0_props = {
    actionClass: "btn btn-default btn-sm",
    allowNull: false,
    items: ctx[2].autohide.options
  };
  if (ctx[0] !== void 0) {
    menu0_props.id = ctx[0];
  }
  menu0 = new Menu$1({ props: menu0_props });
  binding_callbacks.push(() => bind$2(menu0, "id", menu0_id_binding));
  checkbox2 = new Checkbox$1({
    props: {
      field: ctx[6].fields.trigger
    }
  });
  function menu1_id_binding(value) {
    ctx[9](value);
  }
  let menu1_props = {
    items: ctx[5].sound.options,
    allowNull: false,
    actionClass: "btn btn-default btn-sm"
  };
  if (ctx[1] !== void 0) {
    menu1_props.id = ctx[1];
  }
  menu1 = new Menu$1({ props: menu1_props });
  binding_callbacks.push(() => bind$2(menu1, "id", menu1_id_binding));
  inputedit0 = new InputEdit({
    props: {
      field: ctx[6].fields.interval,
      classes: "text-end flex-grow-0 w-50"
    }
  });
  inputedit1 = new InputEdit({
    props: {
      field: ctx[6].fields.count,
      classes: "text-end flex-grow-0 w-50"
    }
  });
  tones = new Tones({});
  return {
    c() {
      div17 = element("div");
      div6 = element("div");
      header0 = element("header");
      h30 = element("h3");
      h30.textContent = `${T("l_actions")}`;
      t1 = space();
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      create_component(checkbox0.$$.fragment);
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      div1 = element("div");
      create_component(checkbox1.$$.fragment);
      t5 = space();
      t6 = text(t6_value);
      t7 = space();
      div2 = element("div");
      span0 = element("span");
      span0.textContent = `${T("m_firefox_only")} - ${T("m_autohide_popup")}:\xA0`;
      t12 = space();
      create_component(menu0.$$.fragment);
      t13 = space();
      div3 = element("div");
      a = element("a");
      t14 = text("Change email action settings from web app!");
      t15 = space();
      div16 = element("div");
      header1 = element("header");
      header1.innerHTML = `<h3>Error Actions</h3>`;
      t17 = space();
      div15 = element("div");
      div14 = element("div");
      div7 = element("div");
      create_component(checkbox2.$$.fragment);
      t18 = text("\n          Trigger notifications");
      t19 = space();
      div8 = element("div");
      span1 = element("span");
      span1.textContent = `${T("l_notification_sound")}:\xA0`;
      t22 = space();
      create_component(menu1.$$.fragment);
      t23 = space();
      div10 = element("div");
      span2 = element("span");
      span2.textContent = "Minimum time interval between notifications (in minutes):\xA0";
      t25 = space();
      div9 = element("div");
      create_component(inputedit0.$$.fragment);
      t26 = space();
      div12 = element("div");
      span3 = element("span");
      span3.textContent = "No. of consecutive errors to trigger notifications:\xA0";
      t28 = space();
      div11 = element("div");
      create_component(inputedit1.$$.fragment);
      t29 = space();
      div13 = element("div");
      div13.textContent = `${T("h_error_notif_desc")}`;
      t31 = space();
      create_component(tones.$$.fragment);
      attr(header0, "class", "card-header");
      attr(div0, "class", "d-flex align-items-center gap-2");
      attr(div1, "class", "d-flex align-items-center gap-2");
      attr(div2, "class", "d-flex align-items-center gap-2");
      attr(a, "href", urlCfg.app + "/#/settings/actions");
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener");
      attr(div3, "class", "alert alert-info");
      attr(div4, "class", "d-flex flex-column gap-1");
      attr(div5, "class", "card-body");
      attr(div6, "class", "card panel-default");
      attr(header1, "class", "card-header");
      attr(div7, "class", "d-flex align-items-center gap-2 mb-2");
      attr(div8, "class", "d-flex align-items-center gap-2");
      attr(div9, "class", "d-inline-flex");
      attr(div10, "class", "d-flex align-items-center gap-2");
      attr(div11, "class", "d-inline-flex");
      attr(div12, "class", "d-flex align-items-center gap-2");
      attr(div13, "class", "alert alert-info");
      attr(div14, "class", "d-flex flex-column gap-1");
      attr(div15, "class", "card-body");
      attr(div16, "class", "card panel-default");
      attr(div17, "class", "d-flex flex-column gap-3");
    },
    m(target, anchor) {
      insert(target, div17, anchor);
      append(div17, div6);
      append(div6, header0);
      append(header0, h30);
      append(div6, t1);
      append(div6, div5);
      append(div5, div4);
      append(div4, div0);
      mount_component(checkbox0, div0, null);
      append(div0, t2);
      append(div0, t3);
      append(div4, t4);
      append(div4, div1);
      mount_component(checkbox1, div1, null);
      append(div1, t5);
      append(div1, t6);
      append(div4, t7);
      append(div4, div2);
      append(div2, span0);
      append(div2, t12);
      mount_component(menu0, div2, null);
      append(div4, t13);
      append(div4, div3);
      append(div3, a);
      append(a, t14);
      append(div17, t15);
      append(div17, div16);
      append(div16, header1);
      append(div16, t17);
      append(div16, div15);
      append(div15, div14);
      append(div14, div7);
      mount_component(checkbox2, div7, null);
      append(div7, t18);
      append(div14, t19);
      append(div14, div8);
      append(div8, span1);
      append(div8, t22);
      mount_component(menu1, div8, null);
      append(div14, t23);
      append(div14, div10);
      append(div10, span2);
      append(div10, t25);
      append(div10, div9);
      mount_component(inputedit0, div9, null);
      append(div14, t26);
      append(div14, div12);
      append(div12, span3);
      append(div12, t28);
      append(div12, div11);
      mount_component(inputedit1, div11, null);
      append(div14, t29);
      append(div14, div13);
      append(div17, t31);
      mount_component(tones, div17, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu0_changes = {};
      if (!updating_id && dirty & 1) {
        updating_id = true;
        menu0_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      menu0.$set(menu0_changes);
      const menu1_changes = {};
      if (!updating_id_1 && dirty & 2) {
        updating_id_1 = true;
        menu1_changes.id = ctx2[1];
        add_flush_callback(() => updating_id_1 = false);
      }
      menu1.$set(menu1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox0.$$.fragment, local);
      transition_in(checkbox1.$$.fragment, local);
      transition_in(menu0.$$.fragment, local);
      transition_in(checkbox2.$$.fragment, local);
      transition_in(menu1.$$.fragment, local);
      transition_in(inputedit0.$$.fragment, local);
      transition_in(inputedit1.$$.fragment, local);
      transition_in(tones.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox0.$$.fragment, local);
      transition_out(checkbox1.$$.fragment, local);
      transition_out(menu0.$$.fragment, local);
      transition_out(checkbox2.$$.fragment, local);
      transition_out(menu1.$$.fragment, local);
      transition_out(inputedit0.$$.fragment, local);
      transition_out(inputedit1.$$.fragment, local);
      transition_out(tones.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div17);
      destroy_component(checkbox0);
      destroy_component(checkbox1);
      destroy_component(menu0);
      destroy_component(checkbox2);
      destroy_component(menu1);
      destroy_component(inputedit0);
      destroy_component(inputedit1);
      destroy_component(tones);
    }
  };
}
function instance$4j($$self, $$props, $$invalidate) {
  let $autohideField;
  let $errorSoundField;
  const commonActionsDef = {
    popup: {
      pref_id: "actions.popup",
      required: false,
      type: "bool",
      default: false
    },
    audio: {
      pref_id: "actions.audio",
      required: false,
      type: "bool",
      default: false
    },
    autohide: {
      pref_id: "actions.popup.autohide",
      required: false,
      type: "enum",
      multi: false,
      options: [0, 5, 10, 20, 60, 120, 300].map((v) => {
        const option = {};
        if (!v) {
          option.name = "never";
        } else if (v < 60) {
          option.name = `${v}s`;
        } else if (v >= 60 && v <= 3600) {
          option.name = `${v / 60}m`;
        } else {
          option.name = `${v / 3600}h`;
        }
        option.id = v;
        return option;
      })
    }
  };
  const commonActionsModel = new FormModel(commonActionsDef);
  const autohideField = commonActionsModel.fields.autohide;
  component_subscribe($$self, autohideField, (value) => $$invalidate(0, $autohideField = value));
  const errorActionsDef = {
    trigger: {
      pref_id: "errorAction.enabled",
      required: false,
      type: "bool",
      default: false
    },
    sound: {
      pref_id: "errorAction.sound",
      required: false,
      type: "enum",
      multi: false,
      options: [
        {
          id: "/skin/media/bell_strike.ogg",
          name: T("l_bell_strike")
        },
        {
          id: "/skin/media/asian_koel.ogg",
          name: T("l_asian_koel")
        },
        {
          id: "/skin/media/ding_dong.ogg",
          name: T("l_ding_dong")
        },
        {
          id: "/skin/media/buzzer.ogg",
          name: T("l_buzzer")
        }
      ]
    },
    interval: {
      pref_id: "errorAction.interval",
      required: false,
      type: "int",
      default: 15
    },
    count: {
      pref_id: "errorAction.minCount",
      required: false,
      type: "int",
      default: 5
    }
  };
  const errorActionsModel = new FormModel(errorActionsDef);
  const errorSoundField = errorActionsModel.fields.sound;
  component_subscribe($$self, errorSoundField, (value) => $$invalidate(1, $errorSoundField = value));
  onMount(async () => {
    const init2 = async (formDef, formModel) => {
      for (let key in formDef) {
        const pref = await serviceProxy.store.Prefs.get(formDef[key].pref_id);
        formModel.fields[key].set(pref);
        formModel.fields[key].subscribe((change) => {
          serviceProxy.store.Prefs.set(formDef[key].pref_id, change);
        });
      }
    };
    await init2(commonActionsDef, commonActionsModel);
    await init2(errorActionsDef, errorActionsModel);
  });
  function menu0_id_binding(value) {
    $autohideField = value;
    autohideField.set($autohideField);
  }
  function menu1_id_binding(value) {
    $errorSoundField = value;
    errorSoundField.set($errorSoundField);
  }
  return [
    $autohideField,
    $errorSoundField,
    commonActionsDef,
    commonActionsModel,
    autohideField,
    errorActionsDef,
    errorActionsModel,
    errorSoundField,
    menu0_id_binding,
    menu1_id_binding
  ];
}
class ActionsExt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4j, create_fragment$4u, safe_not_equal, {});
  }
}
function verifyRangedInt(value, def) {
  const min = def.range[0];
  const max = def.range[1];
  if (value < min || value > max) {
    return `Must be between ${min} and ${max}`;
  }
}
function verifyTime(value) {
  if (!/^([01]\d|2[0-3]):([0-5]\d)$/.test(value)) {
    return "Invalid time";
  }
}
class RangedInt extends TYPES.int {
}
__publicField(RangedInt, "validators", [verifyRangedInt]);
class time extends TYPES.base {
}
__publicField(time, "validators", [verifyTime]);
function create_default_slot$1p(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "time" },
    {
      class: input_class_value = ctx[1] + " " + ctx[5]
    },
    ctx[3]
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign$1(input_data, input_levels[i2]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
      toggle_class(input, "is-invalid", ctx[7]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          action_destroyer(ctx[6].call(null, input)),
          listen(input, "input", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "time" },
        dirty & 34 && input_class_value !== (input_class_value = ctx2[1] + " " + ctx2[5]) && { class: input_class_value },
        dirty & 8 && ctx2[3]
      ]));
      toggle_class(input, "is-invalid", ctx2[7]);
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$2h(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text(ctx[2]);
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_fragment$4t(ctx) {
  let fieldwrapper;
  let t;
  let if_block_anchor;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[0],
      $$slots: {
        default: [
          create_default_slot$1p,
          ({ inputClasses, action, showError }) => ({ 5: inputClasses, 6: action, 7: showError }),
          ({ inputClasses, action, showError }) => (inputClasses ? 32 : 0) | (action ? 64 : 0) | (showError ? 128 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = !!ctx[2] && create_if_block$2h(ctx);
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 1)
        fieldwrapper_changes.field = ctx2[0];
      if (dirty & 426) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
      if (!!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2h(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$4i($$self, $$props, $$invalidate) {
  const omit_props_names = ["field", "classes", "help"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { field } = $$props;
  let { classes: classes2 } = $$props;
  let { help = "" } = $$props;
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(0, field = $$new_props.field);
    if ("classes" in $$new_props)
      $$invalidate(1, classes2 = $$new_props.classes);
    if ("help" in $$new_props)
      $$invalidate(2, help = $$new_props.help);
  };
  return [field, classes2, help, $$restProps, input_handler];
}
class TimeEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4i, create_fragment$4t, safe_not_equal, { field: 0, classes: 1, help: 2 });
  }
}
function create_label_slot$4(ctx) {
  let div;
  let t_value = (ctx[0].length > 0 ? ctx[0].map(ctx[2]).join(",") : "None") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "truncate mw5-m mr1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = (ctx2[0].length > 0 ? ctx2[0].map(ctx2[2]).join(",") : "None") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$4s(ctx) {
  let multiselectmenu;
  let updating_items;
  let updating_ids;
  let current;
  function multiselectmenu_items_binding(value) {
    ctx[4](value);
  }
  function multiselectmenu_ids_binding(value) {
    ctx[5](value);
  }
  let multiselectmenu_props = {
    $$slots: { label: [create_label_slot$4] },
    $$scope: { ctx }
  };
  if (ctx[1].fields !== void 0) {
    multiselectmenu_props.items = ctx[1].fields;
  }
  if (ctx[0] !== void 0) {
    multiselectmenu_props.ids = ctx[0];
  }
  multiselectmenu = new MultiSelectMenu({ props: multiselectmenu_props });
  binding_callbacks.push(() => bind$2(multiselectmenu, "items", multiselectmenu_items_binding));
  binding_callbacks.push(() => bind$2(multiselectmenu, "ids", multiselectmenu_ids_binding));
  multiselectmenu.$on("change", ctx[6]);
  return {
    c() {
      create_component(multiselectmenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(multiselectmenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const multiselectmenu_changes = {};
      if (dirty & 513) {
        multiselectmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_items && dirty & 2) {
        updating_items = true;
        multiselectmenu_changes.items = ctx2[1].fields;
        add_flush_callback(() => updating_items = false);
      }
      if (!updating_ids && dirty & 1) {
        updating_ids = true;
        multiselectmenu_changes.ids = ctx2[0];
        add_flush_callback(() => updating_ids = false);
      }
      multiselectmenu.$set(multiselectmenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(multiselectmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(multiselectmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(multiselectmenu, detaching);
    }
  };
}
function instance$4h($$self, $$props, $$invalidate) {
  createEventDispatcher();
  class SelectableList extends FieldList {
    constructor(values) {
      super({ type: "json" }, values);
    }
  }
  let { items } = $$props;
  let { ids = [] } = $$props;
  let listItems = new SelectableList(items);
  function getLabel(id2) {
    const item = items.find((item2) => item2.id == id2);
    return item ? item.label || item.name : "NA";
  }
  function multiselectmenu_items_binding(value) {
    if ($$self.$$.not_equal(listItems.fields, value)) {
      listItems.fields = value;
      $$invalidate(1, listItems);
    }
  }
  function multiselectmenu_ids_binding(value) {
    ids = value;
    $$invalidate(0, ids);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(3, items = $$props2.items);
    if ("ids" in $$props2)
      $$invalidate(0, ids = $$props2.ids);
  };
  return [
    ids,
    listItems,
    getLabel,
    items,
    multiselectmenu_items_binding,
    multiselectmenu_ids_binding,
    change_handler
  ];
}
class SelectableMenuWrapper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4h, create_fragment$4s, safe_not_equal, { items: 3, ids: 0 });
  }
}
function get_each_context_2$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2].id;
  child_ctx[11] = list[i2].label;
  return child_ctx;
}
function get_each_context_1$a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2].id;
  child_ctx[11] = list[i2].label;
  return child_ctx;
}
function get_each_context$16(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2].id;
  child_ctx[11] = list[i2].label;
  return child_ctx;
}
function create_else_block_1$h(ctx) {
  let each_1_anchor;
  let each_value_2 = ctx[0].options;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value_2 = ctx2[0].options;
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$4(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2$4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2$Z(ctx) {
  let select;
  let mounted;
  let dispose;
  let each_value_1 = ctx[0].options;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$a(get_each_context_1$a(ctx, each_value_1, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(select, "name", "module");
      attr(select, "id", "module");
      attr(select, "class", "form-select");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      if (!mounted) {
        dispose = listen(select, "change", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value_1 = ctx2[0].options;
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$a(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$a(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$2g(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$1p, create_else_block$1c];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0].dropdown)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_each_block_2$4(ctx) {
  let div;
  let label;
  let input;
  let input_id_value;
  let input_name_value;
  let input_value_value;
  let value_has_changed = false;
  let t0;
  let t1_value = ctx[11] + "";
  let t1;
  let label_for_value;
  let t2;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(ctx[7][0]);
  return {
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "radio");
      attr(input, "id", input_id_value = ctx[10]);
      attr(input, "name", input_name_value = ctx[0].name);
      input.__value = input_value_value = ctx[10];
      input.value = input.__value;
      attr(label, "class", "font-normal");
      attr(label, "for", label_for_value = ctx[10]);
      attr(div, "class", "flex items-center");
      binding_group.p(input);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      input.checked = input.__value === ctx[2];
      append(label, t0);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "change", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input_id_value !== (input_id_value = ctx2[10])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & 1 && input_name_value !== (input_name_value = ctx2[0].name)) {
        attr(input, "name", input_name_value);
      }
      if (dirty & 1 && input_value_value !== (input_value_value = ctx2[10])) {
        input.__value = input_value_value;
        input.value = input.__value;
        value_has_changed = true;
      }
      if (value_has_changed || dirty & 5) {
        input.checked = input.__value === ctx2[2];
      }
      if (dirty & 1 && t1_value !== (t1_value = ctx2[11] + ""))
        set_data(t1, t1_value);
      if (dirty & 1 && label_for_value !== (label_for_value = ctx2[10])) {
        attr(label, "for", label_for_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      binding_group.r();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$a(ctx) {
  let option;
  let t_value = ctx[11] + "";
  let t;
  let option_id_value;
  let option_value_value;
  let option_selected_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      attr(option, "id", option_id_value = ctx[10]);
      option.__value = option_value_value = ctx[10];
      option.value = option.__value;
      option.selected = option_selected_value = ctx[2].includes(ctx[10]);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[11] + ""))
        set_data(t, t_value);
      if (dirty & 1 && option_id_value !== (option_id_value = ctx2[10])) {
        attr(option, "id", option_id_value);
      }
      if (dirty & 1 && option_value_value !== (option_value_value = ctx2[10])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
      if (dirty & 5 && option_selected_value !== (option_selected_value = ctx2[2].includes(ctx2[10]))) {
        option.selected = option_selected_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_else_block$1c(ctx) {
  let each_1_anchor;
  let each_value = ctx[0].options;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$16(get_each_context$16(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[0].options;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$16(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$16(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$1p(ctx) {
  let selectablemenuwrapper;
  let current;
  const selectablemenuwrapper_spread_levels = [{ items: ctx[0].options }, ctx[4]];
  let selectablemenuwrapper_props = {};
  for (let i2 = 0; i2 < selectablemenuwrapper_spread_levels.length; i2 += 1) {
    selectablemenuwrapper_props = assign$1(selectablemenuwrapper_props, selectablemenuwrapper_spread_levels[i2]);
  }
  selectablemenuwrapper = new SelectableMenuWrapper({ props: selectablemenuwrapper_props });
  selectablemenuwrapper.$on("change", ctx[5]);
  return {
    c() {
      create_component(selectablemenuwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectablemenuwrapper, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectablemenuwrapper_changes = dirty & 17 ? get_spread_update(selectablemenuwrapper_spread_levels, [
        dirty & 1 && { items: ctx2[0].options },
        dirty & 16 && get_spread_object(ctx2[4])
      ]) : {};
      selectablemenuwrapper.$set(selectablemenuwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectablemenuwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectablemenuwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectablemenuwrapper, detaching);
    }
  };
}
function create_each_block$16(ctx) {
  let div;
  let label;
  let input;
  let input_name_value;
  let input_value_value;
  let value_has_changed = false;
  let input_id_value;
  let t0;
  let t1_value = ctx[11] + "";
  let t1;
  let label_for_value;
  let t2;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(ctx[7][0]);
  return {
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      attr(input, "name", input_name_value = ctx[0].name);
      input.__value = input_value_value = ctx[10];
      input.value = input.__value;
      attr(input, "id", input_id_value = ctx[10]);
      attr(label, "class", "font-normal");
      attr(label, "for", label_for_value = ctx[10]);
      attr(div, "class", "flex");
      binding_group.p(input);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      input.checked = ~(ctx[2] || []).indexOf(input.__value);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "change", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input_name_value !== (input_name_value = ctx2[0].name)) {
        attr(input, "name", input_name_value);
      }
      if (dirty & 1 && input_value_value !== (input_value_value = ctx2[10])) {
        input.__value = input_value_value;
        input.value = input.__value;
        value_has_changed = true;
      }
      if (dirty & 1 && input_id_value !== (input_id_value = ctx2[10])) {
        attr(input, "id", input_id_value);
      }
      if (value_has_changed || dirty & 5) {
        input.checked = ~(ctx2[2] || []).indexOf(input.__value);
      }
      if (dirty & 1 && t1_value !== (t1_value = ctx2[11] + ""))
        set_data(t1, t1_value);
      if (dirty & 1 && label_for_value !== (label_for_value = ctx2[10])) {
        attr(label, "for", label_for_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      binding_group.r();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4r(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$2g, create_if_block_2$Z, create_else_block_1$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].multi)
      return 0;
    if (ctx2[0].dropdown)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$4g($$self, $$props, $$invalidate) {
  const omit_props_names = ["def", "field"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $field, $$unsubscribe_field = noop, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(2, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { def } = $$props;
  let { field } = $$props;
  $$subscribe_field();
  function setEnum(value) {
    field.set(value);
  }
  const $$binding_groups = [[]];
  const change_handler = (e) => setEnum(e.detail);
  function input_change_handler() {
    $field = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    field.set($field);
  }
  const change_handler_1 = (e) => setEnum(e.target.value);
  function input_change_handler_1() {
    $field = this.__value;
    field.set($field);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("def" in $$new_props)
      $$invalidate(0, def = $$new_props.def);
    if ("field" in $$new_props)
      $$subscribe_field($$invalidate(1, field = $$new_props.field));
  };
  return [
    def,
    field,
    $field,
    setEnum,
    $$restProps,
    change_handler,
    input_change_handler,
    $$binding_groups,
    change_handler_1,
    input_change_handler_1
  ];
}
class EnumGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4g, create_fragment$4r, safe_not_equal, { def: 0, field: 1 });
  }
}
function create_if_block$2f(ctx) {
  var _a;
  let div5;
  let div1;
  let span0;
  let t2;
  let div0;
  let timeedit0;
  let t3;
  let div3;
  let span1;
  let t6;
  let div2;
  let timeedit1;
  let t7;
  let div4;
  let span2;
  let t10;
  let enumgroup;
  let current;
  timeedit0 = new TimeEdit({
    props: {
      field: ctx[8].fields.start
    }
  });
  timeedit1 = new TimeEdit({
    props: {
      field: ctx[8].fields.end
    }
  });
  enumgroup = new EnumGroup({
    props: {
      def: ctx[7].days,
      field: ctx[8].fields.days,
      ids: (_a = ctx[3]) != null ? _a : []
    }
  });
  return {
    c() {
      div5 = element("div");
      div1 = element("div");
      span0 = element("span");
      span0.textContent = `${T("l_time_slots_start")}:`;
      t2 = space();
      div0 = element("div");
      create_component(timeedit0.$$.fragment);
      t3 = space();
      div3 = element("div");
      span1 = element("span");
      span1.textContent = `${T("l_time_slots_end")}:`;
      t6 = space();
      div2 = element("div");
      create_component(timeedit1.$$.fragment);
      t7 = space();
      div4 = element("div");
      span2 = element("span");
      span2.textContent = `${T("l_time_slots_day")}:`;
      t10 = space();
      create_component(enumgroup.$$.fragment);
      attr(div0, "class", "d-inline-flex");
      attr(div1, "class", "d-flex align-items-center gap-2");
      attr(div2, "class", "d-inline-flex");
      attr(div3, "class", "d-flex align-items-center gap-2");
      attr(div4, "class", "d-flex align-items-center gap-2");
      attr(div5, "class", "d-flex gap-4");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div1);
      append(div1, span0);
      append(div1, t2);
      append(div1, div0);
      mount_component(timeedit0, div0, null);
      append(div5, t3);
      append(div5, div3);
      append(div3, span1);
      append(div3, t6);
      append(div3, div2);
      mount_component(timeedit1, div2, null);
      append(div5, t7);
      append(div5, div4);
      append(div4, span2);
      append(div4, t10);
      mount_component(enumgroup, div4, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const enumgroup_changes = {};
      if (dirty & 8)
        enumgroup_changes.ids = (_a2 = ctx2[3]) != null ? _a2 : [];
      enumgroup.$set(enumgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(timeedit0.$$.fragment, local);
      transition_in(timeedit1.$$.fragment, local);
      transition_in(enumgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(timeedit0.$$.fragment, local);
      transition_out(timeedit1.$$.fragment, local);
      transition_out(enumgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(timeedit0);
      destroy_component(timeedit1);
      destroy_component(enumgroup);
    }
  };
}
function create_fragment$4q(ctx) {
  let div14;
  let div8;
  let header0;
  let h30;
  let t1;
  let div7;
  let div6;
  let div1;
  let span0;
  let t4;
  let div0;
  let inputedit0;
  let t5;
  let div2;
  let span1;
  let t8;
  let menu;
  let updating_id;
  let t9;
  let div4;
  let span2;
  let t12;
  let div3;
  let inputedit1;
  let t13;
  let div5;
  let t15;
  let div13;
  let header1;
  let h31;
  let t17;
  let div12;
  let div10;
  let div9;
  let checkbox;
  let t18;
  let span3;
  let t21;
  let t22;
  let div11;
  let current;
  inputedit0 = new InputEdit({
    props: {
      field: ctx[5].fields.workers,
      classes: "text-end flex-grow-0 w-50"
    }
  });
  function menu_id_binding(value) {
    ctx[12](value);
  }
  let menu_props = {
    items: ctx[4].frameload.options,
    allowNull: false,
    actionClass: "btn btn-default"
  };
  if (ctx[1] !== void 0) {
    menu_props.id = ctx[1];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "id", menu_id_binding));
  inputedit1 = new InputEdit({
    props: {
      field: ctx[5].fields.timeout,
      classes: "text-end flex-grow-0 w-50"
    }
  });
  checkbox = new Checkbox$1({
    props: {
      field: ctx[8].fields.enable
    }
  });
  let if_block = ctx[2] && create_if_block$2f(ctx);
  return {
    c() {
      div14 = element("div");
      div8 = element("div");
      header0 = element("header");
      h30 = element("h3");
      h30.textContent = `${T("l_advanced")}`;
      t1 = space();
      div7 = element("div");
      div6 = element("div");
      div1 = element("div");
      span0 = element("span");
      span0.textContent = `${T("m_max_workers")}:\xA0`;
      t4 = space();
      div0 = element("div");
      create_component(inputedit0.$$.fragment);
      t5 = space();
      div2 = element("div");
      span1 = element("span");
      span1.textContent = `${T("m_load_page_options")}:\xA0`;
      t8 = space();
      create_component(menu.$$.fragment);
      t9 = space();
      div4 = element("div");
      span2 = element("span");
      span2.textContent = `${T("m_sticky_window_timeout")}:\xA0`;
      t12 = space();
      div3 = element("div");
      create_component(inputedit1.$$.fragment);
      t13 = space();
      div5 = element("div");
      div5.textContent = `${T("m_sticky_window_warning")}`;
      t15 = space();
      div13 = element("div");
      header1 = element("header");
      h31 = element("h3");
      h31.textContent = `${T("l_time_slots")}`;
      t17 = space();
      div12 = element("div");
      div10 = element("div");
      div9 = element("div");
      create_component(checkbox.$$.fragment);
      t18 = space();
      span3 = element("span");
      span3.textContent = `${T("l_time_slots_enabled")}\xA0`;
      t21 = space();
      if (if_block)
        if_block.c();
      t22 = space();
      div11 = element("div");
      div11.textContent = `${T("m_premium_only")}`;
      attr(header0, "class", "card-header");
      attr(div0, "class", "d-inline-flex");
      attr(div1, "class", "d-flex align-items-center gap-2");
      attr(div2, "class", "d-flex align-items-center gap-2");
      attr(div3, "class", "d-inline-flex");
      attr(div4, "class", "d-flex align-items-center gap-2");
      attr(div5, "class", "alert alert-info");
      attr(div6, "class", "d-flex flex-column gap-1");
      attr(div7, "class", "card-body");
      attr(div8, "class", "card panel-default");
      attr(header1, "class", "card-header");
      attr(div9, "class", "d-flex align-items-center gap-2 mb-2");
      attr(div10, "class", "d-flex flex-column gap-1");
      attr(div11, "class", "alert alert-info");
      attr(div12, "class", "card-body");
      attr(div13, "class", "card panel-default");
      attr(div14, "class", "d-flex flex-column gap-3");
    },
    m(target, anchor) {
      insert(target, div14, anchor);
      append(div14, div8);
      append(div8, header0);
      append(header0, h30);
      append(div8, t1);
      append(div8, div7);
      append(div7, div6);
      append(div6, div1);
      append(div1, span0);
      append(div1, t4);
      append(div1, div0);
      mount_component(inputedit0, div0, null);
      append(div6, t5);
      append(div6, div2);
      append(div2, span1);
      append(div2, t8);
      mount_component(menu, div2, null);
      append(div6, t9);
      append(div6, div4);
      append(div4, span2);
      append(div4, t12);
      append(div4, div3);
      mount_component(inputedit1, div3, null);
      append(div6, t13);
      append(div6, div5);
      append(div14, t15);
      append(div14, div13);
      append(div13, header1);
      append(header1, h31);
      append(div13, t17);
      append(div13, div12);
      append(div12, div10);
      append(div10, div9);
      mount_component(checkbox, div9, null);
      append(div9, t18);
      append(div9, span3);
      append(div10, t21);
      if (if_block)
        if_block.m(div10, null);
      append(div12, t22);
      append(div12, div11);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (!updating_id && dirty & 2) {
        updating_id = true;
        menu_changes.id = ctx2[1];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2f(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div10, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit0.$$.fragment, local);
      transition_in(menu.$$.fragment, local);
      transition_in(inputedit1.$$.fragment, local);
      transition_in(checkbox.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(inputedit0.$$.fragment, local);
      transition_out(menu.$$.fragment, local);
      transition_out(inputedit1.$$.fragment, local);
      transition_out(checkbox.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div14);
      destroy_component(inputedit0);
      destroy_component(menu);
      destroy_component(inputedit1);
      destroy_component(checkbox);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4f($$self, $$props, $$invalidate) {
  let $derivedStore, $$unsubscribe_derivedStore = noop, $$subscribe_derivedStore = () => ($$unsubscribe_derivedStore(), $$unsubscribe_derivedStore = subscribe(derivedStore, ($$value) => $$invalidate(11, $derivedStore = $$value)), derivedStore);
  let $frameloadField;
  let $timeSlotsEnabled;
  let $daysField;
  $$self.$$.on_destroy.push(() => $$unsubscribe_derivedStore());
  if (!TYPES["ranged:int"]) {
    register("ranged:int", RangedInt);
  }
  if (!TYPES["time"]) {
    register("time", time);
  }
  const advancedActionsDef = {
    workers: {
      pref_id: "nworkers",
      required: false,
      type: "ranged:int",
      range: [1, 10]
    },
    frameload: {
      pref_id: "x-frame-load-in",
      required: false,
      type: "enum",
      multi: false,
      options: [
        { id: "tab", name: T("l_opt_bgtab") },
        {
          id: "window",
          name: T("l_opt_bgwindow")
        },
        { id: "bg", name: T("l_opt_force_bg") },
        {
          id: "sticky_window",
          name: T("l_opt_sticky_window")
        }
      ]
    },
    timeout: {
      pref_id: "sticky-window-timeout",
      required: false,
      type: "ranged:int",
      range: [1, 1e4]
    }
  };
  const advancedActionsModel = new FormModel(advancedActionsDef);
  const frameloadField = advancedActionsModel.fields.frameload;
  component_subscribe($$self, frameloadField, (value) => $$invalidate(1, $frameloadField = value));
  const timeSlotsDef = {
    enable: {
      pref_id: "sieve-slot.enabled",
      required: false,
      type: "bool"
    },
    start: {
      pref_id: "sieve-slot.start",
      required: false,
      type: "time"
    },
    end: {
      pref_id: "sieve-slot.end",
      required: false,
      type: "time"
    },
    days: {
      pref_id: "time-slot-map",
      required: false,
      type: "enum",
      multi: true,
      dropdown: true,
      options: [
        { id: 1, name: T("l_monday") },
        { id: 2, name: T("l_tuesday") },
        { id: 3, name: T("l_wednesday") },
        { id: 4, name: T("l_thursday") },
        { id: 5, name: T("l_friday") },
        { id: 6, name: T("l_saturday") },
        { id: 0, name: T("l_sunday") }
      ]
    }
  };
  const timeSlotsModel = new FormModel(timeSlotsDef);
  const daysField = timeSlotsModel.fields.days;
  component_subscribe($$self, daysField, (value) => $$invalidate(3, $daysField = value));
  const timeSlotsEnabled = timeSlotsModel.fields.enable;
  component_subscribe($$self, timeSlotsEnabled, (value) => $$invalidate(2, $timeSlotsEnabled = value));
  let derivedStore;
  onMount(async () => {
    const init2 = async (formDef, formModel) => {
      for (let key in formDef) {
        let pref2 = await serviceProxy.store.Prefs.get(formDef[key].pref_id);
        formModel.fields[key].set(pref2);
        formModel.fields[key].subscribe((change) => {
          serviceProxy.store.Prefs.set(formDef[key].pref_id, change);
        });
      }
    };
    await init2(advancedActionsDef, advancedActionsModel);
    await init2(_.omit(timeSlotsDef, "days"), timeSlotsModel);
    let pref = await serviceProxy.store.Prefs.get(timeSlotsDef.days.pref_id);
    pref = Object.keys(pref).map((id2) => parseInt(id2));
    daysField.set(pref);
    $$subscribe_derivedStore($$invalidate(0, derivedStore = derived(Object.values(_.pick(timeSlotsModel.fields, "start", "end", "days")), (...a) => a)));
    const response = await Api.api("/subscriptions", "GET", { "state.in": [40, 45] });
    const activePlan = response.data[0].plan_id;
    activePlan[0] == "0";
  });
  function updateTimeSlotMap() {
    var _a;
    const value = (_a = timeSlotsModel.fields.days.get()) == null ? void 0 : _a.reduce(
      (acc, id2) => {
        acc[id2] = [
          {
            start: timeSlotsModel.fields.start.get(),
            end: timeSlotsModel.fields.end.get()
          }
        ];
        return acc;
      },
      {}
    );
    serviceProxy.store.Prefs.set(timeSlotsDef.days.pref_id, value);
  }
  function menu_id_binding(value) {
    $frameloadField = value;
    frameloadField.set($frameloadField);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2049) {
      if (derivedStore && $derivedStore) {
        updateTimeSlotMap();
      }
    }
  };
  return [
    derivedStore,
    $frameloadField,
    $timeSlotsEnabled,
    $daysField,
    advancedActionsDef,
    advancedActionsModel,
    frameloadField,
    timeSlotsDef,
    timeSlotsModel,
    daysField,
    timeSlotsEnabled,
    $derivedStore,
    menu_id_binding
  ];
}
class AdvancedExt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4f, create_fragment$4q, safe_not_equal, {});
  }
}
var ConfirmBtn_svelte_svelte_type_style_lang = "";
function create_if_block$2e(ctx) {
  let t0;
  let li0;
  let a0;
  let t1;
  let t2;
  let li1;
  let a1;
  let t3;
  let mounted;
  let dispose;
  let if_block = ctx[2] && create_if_block_1$1o(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      li0 = element("li");
      a0 = element("a");
      t1 = text("No");
      t2 = space();
      li1 = element("li");
      a1 = element("a");
      t3 = text("Yes");
      attr(a0, "class", "dropdown-item");
      attr(a0, "href", href$3);
      attr(a1, "class", "dropdown-item del svelte-wvb0dh");
      attr(a1, "href", href$3);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, li0, anchor);
      append(li0, a0);
      append(a0, t1);
      insert(target, t2, anchor);
      insert(target, li1, anchor);
      append(li1, a1);
      append(a1, t3);
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[6]),
          listen(a1, "click", ctx[11]),
          listen(a1, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1o(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(li1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$1o(ctx) {
  let li;
  let t;
  return {
    c() {
      li = element("li");
      t = text(ctx[2]);
      attr(li, "class", "dropdown-header");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_fragment$4p(ctx) {
  let div;
  let button;
  let button_class_value;
  let t;
  let ul;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let if_block = ctx[4] && create_if_block$2e(ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      if (default_slot)
        default_slot.c();
      t = space();
      ul = element("ul");
      if (if_block)
        if_block.c();
      attr(button, "class", button_class_value = "btn btn-default " + ctx[1] + " svelte-wvb0dh");
      attr(button, "data-bs-toggle", "dropdown");
      button.disabled = ctx[4];
      attr(ul, "class", "dropdown-menu");
      toggle_class(ul, "dropdown-menu-right", ctx[0]);
      attr(div, "class", "dropdown open inline");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (default_slot) {
        default_slot.m(button, null);
      }
      append(div, t);
      append(div, ul);
      if (if_block)
        if_block.m(ul, null);
      ctx[12](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[7]),
          listen(window, "mousedown", ctx[8]),
          listen(button, "click", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && button_class_value !== (button_class_value = "btn btn-default " + ctx2[1] + " svelte-wvb0dh")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & 16) {
        button.disabled = ctx2[4];
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2e(ctx2);
          if_block.c();
          if_block.m(ul, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 1) {
        toggle_class(ul, "dropdown-menu-right", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
let href$3 = "#";
function instance$4e($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { alignRight = false } = $$props;
  let { class: clazz = "" } = $$props;
  let { msg = "" } = $$props;
  let el;
  let confirm2 = false;
  function onConfirm(e) {
    $$invalidate(4, confirm2 = true);
    e.preventDefault();
  }
  function onAClick(e) {
    e.preventDefault();
    $$invalidate(4, confirm2 = false);
  }
  function onKeydown(e) {
    if (e.key === "Escape") {
      $$invalidate(4, confirm2 = false);
    }
  }
  function onMouseDown(e) {
    if (!el.contains(e.target)) {
      $$invalidate(4, confirm2 = false);
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("alignRight" in $$props2)
      $$invalidate(0, alignRight = $$props2.alignRight);
    if ("class" in $$props2)
      $$invalidate(1, clazz = $$props2.class);
    if ("msg" in $$props2)
      $$invalidate(2, msg = $$props2.msg);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    alignRight,
    clazz,
    msg,
    el,
    confirm2,
    onConfirm,
    onAClick,
    onKeydown,
    onMouseDown,
    $$scope,
    slots,
    click_handler,
    div_binding
  ];
}
class ConfirmBtn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4e, create_fragment$4p, safe_not_equal, { alignRight: 0, class: 1, msg: 2 });
  }
}
function create_else_block$1b(ctx) {
  let div1;
  let div0;
  let t0_value = ctx[6].info + "";
  let t0;
  let t1_value = ctx[10](ctx[0].id) ? " (" + T("l_device_this") + ")" : "";
  let t1;
  let t2;
  let div0_class_value;
  let t3;
  let small0;
  let t4_value = moment(ctx[6].ts).format(" (YYYY-MM-DD)") + "";
  let t4;
  let t5;
  let small1;
  let t6;
  let t7_value = ctx[6].name + "";
  let t7;
  let if_block = ctx[5] && create_if_block_2$Y(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      small0 = element("small");
      t4 = text(t4_value);
      t5 = space();
      small1 = element("small");
      t6 = text("- ");
      t7 = text(t7_value);
      attr(div0, "class", div0_class_value = ctx[10](ctx[0].id) ? "fw-bold" : "");
      attr(small1, "class", "help");
      attr(div1, "class", "ms-2 me-auto");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      append(div0, t2);
      if (if_block)
        if_block.m(div0, null);
      append(div1, t3);
      append(div1, small0);
      append(small0, t4);
      append(small0, t5);
      append(div1, small1);
      append(small1, t6);
      append(small1, t7);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t0_value !== (t0_value = ctx2[6].info + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t1_value !== (t1_value = ctx2[10](ctx2[0].id) ? " (" + T("l_device_this") + ")" : ""))
        set_data(t1, t1_value);
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$Y(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 1 && div0_class_value !== (div0_class_value = ctx2[10](ctx2[0].id) ? "fw-bold" : "")) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & 64 && t4_value !== (t4_value = moment(ctx2[6].ts).format(" (YYYY-MM-DD)") + ""))
        set_data(t4, t4_value);
      if (dirty & 64 && t7_value !== (t7_value = ctx2[6].name + ""))
        set_data(t7, t7_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$1n(ctx) {
  let div;
  let inputedit;
  let t0;
  let button0;
  let i0;
  let t1;
  let button1;
  let current;
  let mounted;
  let dispose;
  inputedit = new InputEdit({ props: { field: ctx[2] } });
  return {
    c() {
      div = element("div");
      create_component(inputedit.$$.fragment);
      t0 = space();
      button0 = element("button");
      i0 = element("i");
      t1 = space();
      button1 = element("button");
      button1.innerHTML = `<i class="fa fa-times"></i>`;
      attr(i0, "class", "fa fa-check");
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-default btn-sm");
      button0.disabled = ctx[7];
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-default btn-sm");
      attr(div, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inputedit, div, null);
      append(div, t0);
      append(div, button0);
      append(button0, i0);
      append(div, t1);
      append(div, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", prevent_default(ctx[12])),
          listen(button1, "click", prevent_default(ctx[13]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const inputedit_changes = {};
      if (dirty & 4)
        inputedit_changes.field = ctx2[2];
      inputedit.$set(inputedit_changes);
      if (!current || dirty & 128) {
        button0.disabled = ctx2[7];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inputedit);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$Y(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.innerHTML = `<i class="fa fa-pencil"></i>`;
      attr(a, "href", "#");
      attr(a, "class", "text-decoration-none");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[14]));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$2d(ctx) {
  let div;
  let confirmbtn;
  let current;
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot$1o] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[15]);
  return {
    c() {
      div = element("div");
      create_component(confirmbtn.$$.fragment);
      attr(div, "class", "flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(confirmbtn, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const confirmbtn_changes = {};
      if (dirty & 524288) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(confirmbtn);
    }
  };
}
function create_default_slot$1o(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-trash-o red");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_fragment$4o(ctx) {
  let li;
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let show_if = !(ctx[0].id === ctx[1]) && !ctx[0].isWeb();
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$1n, create_else_block$1b];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = show_if && create_if_block$2d(ctx);
  return {
    c() {
      li = element("li");
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(li, "class", "list-group-item list-group-item-action d-flex justify-content-between align-items-start align-items-center");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      if_blocks[current_block_type_index].m(div, null);
      append(li, t);
      if (if_block1)
        if_block1.m(li, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(li, "mouseenter", ctx[16]),
          listen(li, "mouseleave", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, null);
      }
      if (dirty & 3)
        show_if = !(ctx2[0].id === ctx2[1]) && !ctx2[0].isWeb();
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 3) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2d(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(li, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4d($$self, $$props, $$invalidate) {
  let $client, $$unsubscribe_client = noop, $$subscribe_client = () => ($$unsubscribe_client(), $$unsubscribe_client = subscribe(client, ($$value) => $$invalidate(6, $client = $$value)), client);
  let $error, $$unsubscribe_error = noop, $$subscribe_error = () => ($$unsubscribe_error(), $$unsubscribe_error = subscribe(error, ($$value) => $$invalidate(7, $error = $$value)), error);
  $$self.$$.on_destroy.push(() => $$unsubscribe_client());
  $$self.$$.on_destroy.push(() => $$unsubscribe_error());
  let { client } = $$props;
  $$subscribe_client();
  let { defaultId } = $$props;
  const dispatch = createEventDispatcher();
  let field;
  let error;
  let showEditInput = false;
  let showEditButton = false;
  function onEditName() {
    $$invalidate(4, showEditInput = !showEditInput);
    if (showEditInput) {
      $$invalidate(2, field = createFieldStore({ type: "text", required: true }, $client.info));
      $$subscribe_error($$invalidate(3, error = field.error));
    }
  }
  function onSaveName() {
    client.save({ info: field.toJSON() }, { patch: true });
    $$invalidate(4, showEditInput = false);
  }
  function isThisClient(id2) {
    return defaultId === id2;
  }
  function onRemoveClient(id2) {
    dispatch("remove", id2);
  }
  const click_handler = () => onSaveName();
  const click_handler_1 = () => $$invalidate(4, showEditInput = false);
  const click_handler_2 = () => onEditName();
  const click_handler_3 = () => onRemoveClient(client);
  const mouseenter_handler = () => $$invalidate(5, showEditButton = true);
  const mouseleave_handler = () => $$invalidate(5, showEditButton = false);
  $$self.$$set = ($$props2) => {
    if ("client" in $$props2)
      $$subscribe_client($$invalidate(0, client = $$props2.client));
    if ("defaultId" in $$props2)
      $$invalidate(1, defaultId = $$props2.defaultId);
  };
  return [
    client,
    defaultId,
    field,
    error,
    showEditInput,
    showEditButton,
    $client,
    $error,
    onEditName,
    onSaveName,
    isThisClient,
    onRemoveClient,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    mouseenter_handler,
    mouseleave_handler
  ];
}
class ClientInfo extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4d, create_fragment$4o, safe_not_equal, { client: 0, defaultId: 1 });
  }
}
function get_each_context$15(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_if_block$2c(ctx) {
  let clientinfo;
  let current;
  clientinfo = new ClientInfo({
    props: {
      client: ctx[4],
      defaultId: ctx[0].defaultId
    }
  });
  clientinfo.$on("remove", ctx[2]);
  return {
    c() {
      create_component(clientinfo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientinfo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const clientinfo_changes = {};
      if (dirty & 2)
        clientinfo_changes.client = ctx2[4];
      if (dirty & 1)
        clientinfo_changes.defaultId = ctx2[0].defaultId;
      clientinfo.$set(clientinfo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(clientinfo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientinfo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientinfo, detaching);
    }
  };
}
function create_each_block$15(ctx) {
  let show_if = ctx[4].toJSON().type > 3;
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block$2c(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        show_if = ctx2[4].toJSON().type > 3;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$4n(ctx) {
  let ul;
  let current;
  let each_value = ctx[1].models;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$15(get_each_context$15(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "list-group list-group-flush");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[1].models;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$15(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$15(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(ul, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$4c($$self, $$props, $$invalidate) {
  let $clients, $$unsubscribe_clients = noop, $$subscribe_clients = () => ($$unsubscribe_clients(), $$unsubscribe_clients = subscribe(clients, ($$value) => $$invalidate(1, $clients = $$value)), clients);
  $$self.$$.on_destroy.push(() => $$unsubscribe_clients());
  let { clients } = $$props;
  $$subscribe_clients();
  const dispatch = createEventDispatcher();
  async function removeClient(e) {
    let id2 = e.detail;
    let client = clients.get(id2);
    await client.save({ state: 90 });
    clients.remove(client);
    dispatch("remove", id2);
  }
  $$self.$$set = ($$props2) => {
    if ("clients" in $$props2)
      $$subscribe_clients($$invalidate(0, clients = $$props2.clients));
  };
  return [clients, $clients, removeClient];
}
class ClientList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4c, create_fragment$4n, safe_not_equal, { clients: 0 });
  }
}
const get_message_slot_changes = (dirty) => ({});
const get_message_slot_context = (ctx) => ({});
const get_action_slot_changes$2 = (dirty) => ({});
const get_action_slot_context$2 = (ctx) => ({});
function create_fragment$4m(ctx) {
  let div2;
  let div1;
  let div0;
  let h3;
  let t1;
  let t2;
  let small;
  let t4;
  let t5;
  let clientlist;
  let current;
  const action_slot_template = ctx[2].action;
  const action_slot = create_slot(action_slot_template, ctx, ctx[1], get_action_slot_context$2);
  const message_slot_template = ctx[2].message;
  const message_slot = create_slot(message_slot_template, ctx, ctx[1], get_message_slot_context);
  clientlist = new ClientList({ props: { clients: ctx[0] } });
  clientlist.$on("remove", ctx[3]);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = "Manage Devices";
      t1 = space();
      if (action_slot)
        action_slot.c();
      t2 = space();
      small = element("small");
      small.textContent = "Rename devices or remove unused ones";
      t4 = space();
      if (message_slot)
        message_slot.c();
      t5 = space();
      create_component(clientlist.$$.fragment);
      attr(h3, "class", "card-title");
      attr(div0, "class", "d-flex justify-content-between mt-2");
      attr(small, "class", "fs-6 text");
      attr(div1, "class", "card-header");
      attr(div2, "class", "card");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, h3);
      append(div0, t1);
      if (action_slot) {
        action_slot.m(div0, null);
      }
      append(div1, t2);
      append(div1, small);
      append(div1, t4);
      if (message_slot) {
        message_slot.m(div1, null);
      }
      append(div2, t5);
      mount_component(clientlist, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(action_slot_template, ctx2[1], dirty, get_action_slot_changes$2),
            get_action_slot_context$2
          );
        }
      }
      if (message_slot) {
        if (message_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            message_slot,
            message_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(message_slot_template, ctx2[1], dirty, get_message_slot_changes),
            get_message_slot_context
          );
        }
      }
      const clientlist_changes = {};
      if (dirty & 1)
        clientlist_changes.clients = ctx2[0];
      clientlist.$set(clientlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(action_slot, local);
      transition_in(message_slot, local);
      transition_in(clientlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action_slot, local);
      transition_out(message_slot, local);
      transition_out(clientlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (action_slot)
        action_slot.d(detaching);
      if (message_slot)
        message_slot.d(detaching);
      destroy_component(clientlist);
    }
  };
}
function instance$4b($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { clients = new ModelClient.Clients() } = $$props;
  onMount(async () => {
    await clients.fetch({
      data: {
        "state.in": [0, 30],
        "_opt": { order: ["ts"] }
      }
    });
  });
  function remove_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("clients" in $$props2)
      $$invalidate(0, clients = $$props2.clients);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [clients, $$scope, slots, remove_handler];
}
class Devices extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4b, create_fragment$4m, safe_not_equal, { clients: 0 });
  }
}
const $$3 = window.jQuery;
if (!$$3) {
  throw new Error("ADD jQuery");
}
const _$4 = window._;
if (!_$4) {
  throw new Error("ADD _");
}
const Backbone$6 = window.Backbone;
if (!Backbone$6) {
  throw new Error("ADD Backbone");
}
var General = View.ActionProvider.extend({
  name: "SettingsGeneral",
  actions: {
    "settings signout": { fn: "action_signout" },
    "settings close": { fn: "closeLoginForm" }
  },
  events: {
    "change": "event_change",
    "click .xclose": "closeLoginForm"
  },
  closeLoginForm: function() {
    this.loginView.remove();
    $$3(this.elLoginCt).remove();
    this.updateUser();
  },
  action_signout: async function() {
    await serviceProxy.auth.logout();
    location.href = serviceProxy.CFG.URL.ROOT + "/logout";
  },
  event_change: function() {
    this.saveValues();
  },
  load: function() {
    this.setValues();
  },
  render: function() {
    this.$el.append(
      DIV(
        { "class": "card panel-default" },
        HEADER({ "class": "card-header" }, H3("General")),
        DIV(
          { "class": "card-body" },
          DIV(
            { "class": "form-group" },
            H4(T("l_account")),
            A({ "class": "btn btn-primary", "href": `${serviceProxy.CFG.URL.ROOT}/service-login?redirect=app://ui/inbox.html#inbox`, "data-action": "settings signin" }),
            BUTTON({ "class": "btn btn-default", "style": "margin-left: 20px;", "data-action": "settings signout" }, T("a_signout"))
          ),
          DIV(T("m_ext_signin"))
        )
      )
    );
    this.elSignIn = this.$('[data-action="settings signin"]');
    this.elSyncInfo = this.$(".alert");
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        await serviceProxy.store.Prefs.set(el.name, el.checked);
      } else {
        await serviceProxy.store.Prefs.set(el.name, el.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        el.checked = await serviceProxy.store.Prefs.get(el.name);
      } else {
        el.value = await serviceProxy.store.Prefs.get(el.name);
      }
    });
    this.showCred();
  },
  showCred: function() {
    if (USER.name) {
      this.elSignIn.text(SPRINTF("l_signed_in_as", `${USER.name} (${USER.email})`));
    } else {
      this.elSignIn.text(T("a_signin"));
    }
  },
  updateUser: async function() {
    let user = await serviceProxy.auth.getUser();
    _$4.extend(USER, user);
    this.showCred();
  }
});
function create_else_block$1a(ctx) {
  let div;
  let small;
  return {
    c() {
      div = element("div");
      small = element("small");
      small.textContent = `${T("m_ext_signin")}`;
      attr(small, "class", "help");
      attr(div, "class", "mt-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, small);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$2b(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${T("a_signout")}`;
      attr(button, "class", "btn btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[3]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4l(ctx) {
  let div3;
  let div0;
  let t1;
  let div2;
  let div1;
  let h4;
  let t3;
  let a;
  let t4_value = (ctx[0].name ? SPRINTF("l_signed_in_as", `${ctx[0].name} (${ctx[0].email})`) : T("a_signin")) + "";
  let t4;
  let t5;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block$2b;
    return create_else_block$1a;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>General</h3>`;
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      h4 = element("h4");
      h4.textContent = `${T("l_account")}`;
      t3 = space();
      a = element("a");
      t4 = text(t4_value);
      t5 = space();
      if_block.c();
      attr(div0, "class", "card-header");
      attr(a, "class", "btn btn-primary");
      attr(a, "href", serviceProxy.CFG.URL.ROOT + "/service-login?redirect=app://ui/inbox.html#inbox");
      attr(div1, "class", "form-group");
      attr(div2, "class", "card-body");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t1);
      append(div3, div2);
      append(div2, div1);
      append(div1, h4);
      append(div1, t3);
      append(div1, a);
      append(a, t4);
      append(div1, t5);
      if_block.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t4_value !== (t4_value = (ctx2[0].name ? SPRINTF("l_signed_in_as", `${ctx2[0].name} (${ctx2[0].email})`) : T("a_signin")) + ""))
        set_data(t4, t4_value);
      if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block.d();
    }
  };
}
function instance$4a($$self, $$props, $$invalidate) {
  let $user;
  const parent2 = getContext("view:root");
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(0, $user = value));
  let isSignedIn = $user.name ? true : false;
  let view = new General({ parent: parent2 }).render();
  view.load();
  async function signOut() {
    await serviceProxy.auth.logout();
    location.href = serviceProxy.CFG.URL.ROOT + "/logout";
  }
  return [$user, user, isSignedIn, signOut];
}
class GeneralExt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4a, create_fragment$4l, safe_not_equal, {});
  }
}
const get_hiddenLabel_slot_changes = (dirty) => ({});
const get_hiddenLabel_slot_context = (ctx) => ({});
const get_label_slot_changes$2 = (dirty) => ({});
const get_label_slot_context$2 = (ctx) => ({});
const get_action_slot_changes$1 = (dirty) => ({});
const get_action_slot_context$1 = (ctx) => ({});
function create_else_block$19(ctx) {
  let button;
  let span;
  let t;
  let div;
  let button_data_bs_target_value;
  let button_class_value;
  let current;
  const label_slot_template = ctx[8].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[7], get_label_slot_context$2);
  const label_slot_or_fallback = label_slot || fallback_block_1$3(ctx);
  const hiddenLabel_slot_template = ctx[8].hiddenLabel;
  const hiddenLabel_slot = create_slot(hiddenLabel_slot_template, ctx, ctx[7], get_hiddenLabel_slot_context);
  const hiddenLabel_slot_or_fallback = hiddenLabel_slot || fallback_block$a(ctx);
  return {
    c() {
      button = element("button");
      span = element("span");
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      t = space();
      div = element("div");
      if (hiddenLabel_slot_or_fallback)
        hiddenLabel_slot_or_fallback.c();
      attr(button, "type", "button");
      attr(button, "data-bs-toggle", "collapse");
      attr(button, "data-bs-target", button_data_bs_target_value = "." + ctx[2]);
      attr(button, "class", button_class_value = "btn btn-primary btn-text collapsed " + ctx[3]);
      toggle_class(button, "collapsed", ctx[5]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(span, null);
      }
      append(button, t);
      append(button, div);
      if (hiddenLabel_slot_or_fallback) {
        hiddenLabel_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(label_slot_template, ctx2[7], dirty, get_label_slot_changes$2),
            get_label_slot_context$2
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & 1)) {
          label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (hiddenLabel_slot) {
        if (hiddenLabel_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            hiddenLabel_slot,
            hiddenLabel_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(hiddenLabel_slot_template, ctx2[7], dirty, get_hiddenLabel_slot_changes),
            get_hiddenLabel_slot_context
          );
        }
      } else {
        if (hiddenLabel_slot_or_fallback && hiddenLabel_slot_or_fallback.p && (!current || dirty & 2)) {
          hiddenLabel_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 4 && button_data_bs_target_value !== (button_data_bs_target_value = "." + ctx2[2])) {
        attr(button, "data-bs-target", button_data_bs_target_value);
      }
      if (!current || dirty & 8 && button_class_value !== (button_class_value = "btn btn-primary btn-text collapsed " + ctx2[3])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & 40) {
        toggle_class(button, "collapsed", ctx2[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      transition_in(hiddenLabel_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot_or_fallback, local);
      transition_out(hiddenLabel_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
      if (hiddenLabel_slot_or_fallback)
        hiddenLabel_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block$2a(ctx) {
  let current;
  const action_slot_template = ctx[8].action;
  const action_slot = create_slot(action_slot_template, ctx, ctx[7], get_action_slot_context$1);
  return {
    c() {
      if (action_slot)
        action_slot.c();
    },
    m(target, anchor) {
      if (action_slot) {
        action_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(action_slot_template, ctx2[7], dirty, get_action_slot_changes$1),
            get_action_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(action_slot, local);
      current = true;
    },
    o(local) {
      transition_out(action_slot, local);
      current = false;
    },
    d(detaching) {
      if (action_slot)
        action_slot.d(detaching);
    }
  };
}
function fallback_block_1$3(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function fallback_block$a(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$4k(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let div;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block$2a, create_else_block$19];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6].action)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  return {
    c() {
      if_block.c();
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = "collapse " + ctx[4] + " " + ctx[2]);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 20 && div_class_value !== (div_class_value = "collapse " + ctx2[4] + " " + ctx2[2])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$49($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { label = "Show Navigation" } = $$props;
  let { hiddenLabel = "Hide Navigation" } = $$props;
  let { targetClass = `collapse-${Date.now()}` } = $$props;
  let { actionClass = "" } = $$props;
  let { collapseClass = "" } = $$props;
  let { collapsed = true } = $$props;
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("hiddenLabel" in $$props2)
      $$invalidate(1, hiddenLabel = $$props2.hiddenLabel);
    if ("targetClass" in $$props2)
      $$invalidate(2, targetClass = $$props2.targetClass);
    if ("actionClass" in $$props2)
      $$invalidate(3, actionClass = $$props2.actionClass);
    if ("collapseClass" in $$props2)
      $$invalidate(4, collapseClass = $$props2.collapseClass);
    if ("collapsed" in $$props2)
      $$invalidate(5, collapsed = $$props2.collapsed);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [
    label,
    hiddenLabel,
    targetClass,
    actionClass,
    collapseClass,
    collapsed,
    $$slots,
    $$scope,
    slots
  ];
}
class Collapse extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$49, create_fragment$4k, safe_not_equal, {
      label: 0,
      hiddenLabel: 1,
      targetClass: 2,
      actionClass: 3,
      collapseClass: 4,
      collapsed: 5
    });
  }
}
function create_default_slot_1$u(ctx) {
  let a0;
  let t1;
  let a1;
  let t3;
  let a2;
  let t5;
  let a3;
  return {
    c() {
      a0 = element("a");
      a0.innerHTML = `General<i class="fa fa-chevron-right right"></i>`;
      t1 = space();
      a1 = element("a");
      a1.innerHTML = `Actions<i class="fa fa-chevron-right right"></i>`;
      t3 = space();
      a2 = element("a");
      a2.innerHTML = `Devices<i class="fa fa-chevron-right right"></i>`;
      t5 = space();
      a3 = element("a");
      a3.innerHTML = `Advanced<i class="fa fa-chevron-right right"></i>`;
      attr(a0, "href", "#/settings/general/");
      attr(a0, "class", "list-group-item d-flex align-items-center justify-content-between");
      toggle_class(a0, "active", ctx[0].module == "general");
      attr(a1, "href", "#/settings/actions/");
      attr(a1, "class", "list-group-item d-flex align-items-center justify-content-between");
      toggle_class(a1, "active", ctx[0].module == "actions");
      attr(a2, "href", "#/settings/devices/");
      attr(a2, "class", "list-group-item d-flex align-items-center justify-content-between");
      toggle_class(a2, "active", ctx[0].module == "devices");
      attr(a3, "href", "#/settings/advanced/");
      attr(a3, "class", "list-group-item d-flex align-items-center justify-content-between");
      toggle_class(a3, "active", ctx[0].module == "advanced");
    },
    m(target, anchor) {
      insert(target, a0, anchor);
      insert(target, t1, anchor);
      insert(target, a1, anchor);
      insert(target, t3, anchor);
      insert(target, a2, anchor);
      insert(target, t5, anchor);
      insert(target, a3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        toggle_class(a0, "active", ctx2[0].module == "general");
      }
      if (dirty & 1) {
        toggle_class(a1, "active", ctx2[0].module == "actions");
      }
      if (dirty & 1) {
        toggle_class(a2, "active", ctx2[0].module == "devices");
      }
      if (dirty & 1) {
        toggle_class(a3, "active", ctx2[0].module == "advanced");
      }
    },
    d(detaching) {
      if (detaching)
        detach(a0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(a1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(a2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(a3);
    }
  };
}
function create_default_slot$1n(ctx) {
  let div6;
  let div5;
  let div3;
  let collapse;
  let t0;
  let div0;
  let a0;
  let t1;
  let i0;
  let t2;
  let a1;
  let t3;
  let i1;
  let t4;
  let a2;
  let t5;
  let i2;
  let t6;
  let a3;
  let t7;
  let i3;
  let t8;
  let a4;
  let t9;
  let i4;
  let t10;
  let div1;
  let span0;
  let t13;
  let div2;
  let span1;
  let t16;
  let div4;
  let switch_instance;
  let current;
  collapse = new Collapse({
    props: {
      actionClass: "visible-xs",
      collapseClass: "dont-collapse-sm list-group mt-2",
      $$slots: { default: [create_default_slot_1$u] },
      $$scope: { ctx }
    }
  });
  var switch_value = ctx[1][ctx[0].module];
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div6 = element("div");
      div5 = element("div");
      div3 = element("div");
      create_component(collapse.$$.fragment);
      t0 = space();
      div0 = element("div");
      a0 = element("a");
      t1 = text("Account");
      i0 = element("i");
      t2 = space();
      a1 = element("a");
      t3 = text("Alert Format");
      i1 = element("i");
      t4 = space();
      a2 = element("a");
      t5 = text("Billing");
      i2 = element("i");
      t6 = space();
      a3 = element("a");
      t7 = text("Emails and Phones");
      i3 = element("i");
      t8 = space();
      a4 = element("a");
      t9 = text("Profile");
      i4 = element("i");
      t10 = space();
      div1 = element("div");
      span0 = element("span");
      span0.textContent = `Version: ${serviceProxy.CFG.VERSION}`;
      t13 = space();
      div2 = element("div");
      span1 = element("span");
      span1.textContent = `Device: ${serviceProxy.CFG.CLIENT.INFO}`;
      t16 = space();
      div4 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(i0, "class", "fa fa-external-link right");
      attr(a0, "href", URL_ROOT + "#/settings/account/");
      attr(a0, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a0, "target", "_blank");
      attr(i1, "class", "fa fa-external-link right");
      attr(a1, "href", URL_ROOT + "#/settings/actions/");
      attr(a1, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a1, "target", "_blank");
      attr(i2, "class", "fa fa-external-link right");
      attr(a2, "href", URL_ROOT + "#/settings/billing/");
      attr(a2, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a2, "target", "_blank");
      attr(i3, "class", "fa fa-external-link right");
      attr(a3, "href", URL_ROOT + "#/settings/emails_phones/");
      attr(a3, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a3, "target", "_blank");
      attr(i4, "class", "fa fa-external-link right");
      attr(a4, "href", URL_ROOT + "#/settings/profile/");
      attr(a4, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a4, "target", "_blank");
      attr(div0, "class", "list-group collapse dont-collapse-sm mt-4");
      attr(span0, "class", "pl-4 ml-2 font-sans font-extralight text-base");
      attr(div1, "class", "mt-2");
      attr(span1, "class", "pl-4 ml-2 font-sans font-extralight text-base");
      attr(div3, "class", "col-sm-3");
      attr(div4, "class", "col-sm-9");
      attr(div5, "class", "row");
      attr(div6, "class", "container pt4");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div3);
      mount_component(collapse, div3, null);
      append(div3, t0);
      append(div3, div0);
      append(div0, a0);
      append(a0, t1);
      append(a0, i0);
      append(div0, t2);
      append(div0, a1);
      append(a1, t3);
      append(a1, i1);
      append(div0, t4);
      append(div0, a2);
      append(a2, t5);
      append(a2, i2);
      append(div0, t6);
      append(div0, a3);
      append(a3, t7);
      append(a3, i3);
      append(div0, t8);
      append(div0, a4);
      append(a4, t9);
      append(a4, i4);
      append(div3, t10);
      append(div3, div1);
      append(div1, span0);
      append(div3, t13);
      append(div3, div2);
      append(div2, span1);
      append(div5, t16);
      append(div5, div4);
      if (switch_instance)
        mount_component(switch_instance, div4, null);
      current = true;
    },
    p(ctx2, dirty) {
      const collapse_changes = {};
      if (dirty & 5) {
        collapse_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapse.$set(collapse_changes);
      if (dirty & 1 && switch_value !== (switch_value = ctx2[1][ctx2[0].module])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div4, null);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(collapse.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(collapse.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component(collapse);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_topbar_slot$b(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Settings" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$4j(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$b],
        default: [create_default_slot$1n]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 5) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$48($$self, $$props, $$invalidate) {
  let { params: params2 } = $$props;
  const components = {
    actions: ActionsExt,
    advanced: AdvancedExt,
    devices: Devices,
    general: GeneralExt
  };
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, components];
}
class Index_ext extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$48, create_fragment$4j, safe_not_equal, { params: 0 });
  }
}
function create_fragment$4i(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "This account is not subscribed to an Enterprise plan. If your company has an Enterprise account with us or need to get one, please contact support.";
      attr(div, "class", "alert alert-info ma4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class EnterpriseOnly extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4i, safe_not_equal, {});
  }
}
function create_else_block$18(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `404 - Path Not Found - ${location.hash.slice(1)}`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$29(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: { default: [create_default_slot$1m] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const layout_changes = {};
      if (dirty & 4) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function create_default_slot$1m(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `404 - Path Not Found - ${location.hash.slice(1)}`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$4h(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$29, create_else_block$18];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$47($$self, $$props, $$invalidate) {
  let { params: params2 } = $$props;
  let { useLayout = true } = $$props;
  console.error("404", params2);
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(1, params2 = $$props2.params);
    if ("useLayout" in $$props2)
      $$invalidate(0, useLayout = $$props2.useLayout);
  };
  return [useLayout, params2];
}
class Error404 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$47, create_fragment$4h, safe_not_equal, { params: 1, useLayout: 0 });
  }
}
var Account_svelte_svelte_type_style_lang = "";
function create_fragment$4g(ctx) {
  let div1;
  let t1;
  let form;
  let div2;
  let label0;
  let t3;
  let input0;
  let t4;
  let div3;
  let label1;
  let t6;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="col-md-3"><h4>Account</h4></div>`;
      t1 = space();
      form = element("form");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Name";
      t3 = space();
      input0 = element("input");
      t4 = space();
      div3 = element("div");
      label1 = element("label");
      label1.textContent = "Company Icon URL";
      t6 = space();
      input1 = element("input");
      attr(div1, "class", "row");
      set_style(div1, "margin-bottom", "15px");
      set_style(div1, "border-bottom", "1px solid #ccc");
      set_style(div1, "padding-bottom", "10px");
      attr(label0, "class", "svelte-gjmi4x");
      attr(input0, "id", "name");
      attr(input0, "type", "text");
      attr(input0, "name", "name");
      attr(input0, "placeholder", "Name");
      attr(input0, "class", "form-control");
      attr(div2, "class", "form-group");
      attr(label1, "class", "svelte-gjmi4x");
      attr(input1, "id", "name");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control");
      attr(input1, "placeholder", "Enter 48x48 or bigger icon url. e.g. https://www.example.com/company-icon.png");
      attr(div3, "class", "form-group");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, form, anchor);
      append(form, div2);
      append(div2, label0);
      append(div2, t3);
      append(div2, input0);
      set_input_value(input0, ctx[0].name);
      append(form, t4);
      append(form, div3);
      append(div3, label1);
      append(div3, t6);
      append(div3, input1);
      set_input_value(input1, ctx[1].icon);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[4]),
          listen(input0, "input", ctx[2]),
          listen(input1, "input", ctx[5]),
          listen(input1, "input", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input0.value !== ctx2[0].name) {
        set_input_value(input0, ctx2[0].name);
      }
      if (dirty & 2 && input1.value !== ctx2[1].icon) {
        set_input_value(input1, ctx2[1].icon);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(form);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$46($$self, $$props, $$invalidate) {
  let account = {};
  let prefs = {};
  onMount(async () => {
    $$invalidate(0, account = await Api.api("/admin/account"));
    $$invalidate(1, prefs = account.prefs || {});
  });
  async function saveName() {
    await Api.api("/admin/account", "PATCH", { name: account.name });
  }
  async function saveIcon() {
    await Api.api("/admin/account", "PATCH", { prefs });
  }
  function input0_input_handler() {
    account.name = this.value;
    $$invalidate(0, account);
  }
  function input1_input_handler() {
    prefs.icon = this.value;
    $$invalidate(1, prefs);
  }
  return [account, prefs, saveName, saveIcon, input0_input_handler, input1_input_handler];
}
class Account extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$46, create_fragment$4g, safe_not_equal, {});
  }
}
function portal(el, target = "body") {
  let targetEl;
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetEl = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetEl.appendChild(el);
    el.hidden = false;
  }
  function destroy() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update(target);
  return { update, destroy };
}
var Modal_svelte_svelte_type_style_lang$1 = "";
const get_links_slot_changes$1 = (dirty) => ({});
const get_links_slot_context$1 = (ctx) => ({});
const get_buttons_slot_changes$3 = (dirty) => ({});
const get_buttons_slot_context$3 = (ctx) => ({});
const get_sub_header_slot_changes$1 = (dirty) => ({});
const get_sub_header_slot_context$1 = (ctx) => ({});
const get_header_slot_changes$8 = (dirty) => ({});
const get_header_slot_context$8 = (ctx) => ({});
const get_content_slot_changes$1 = (dirty) => ({});
const get_content_slot_context$1 = (ctx) => ({});
function fallback_block_2$1(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function fallback_block$9(ctx) {
  let div5;
  let div4;
  let div1;
  let div0;
  let h4;
  let t0;
  let t1;
  let button0;
  let t2;
  let div2;
  let t3;
  let div3;
  let t4;
  let button1;
  let t5;
  let t6;
  let div5_class_value;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = ctx[11].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[10], get_header_slot_context$8);
  const header_slot_or_fallback = header_slot || fallback_block_2$1(ctx);
  const sub_header_slot_template = ctx[11]["sub-header"];
  const sub_header_slot = create_slot(sub_header_slot_template, ctx, ctx[10], get_sub_header_slot_context$1);
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  const buttons_slot_template = ctx[11].buttons;
  const buttons_slot = create_slot(buttons_slot_template, ctx, ctx[10], get_buttons_slot_context$3);
  const links_slot_template = ctx[11].links;
  const links_slot = create_slot(links_slot_template, ctx, ctx[10], get_links_slot_context$1);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      h4 = element("h4");
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
      t0 = space();
      if (sub_header_slot)
        sub_header_slot.c();
      t1 = space();
      button0 = element("button");
      t2 = space();
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div3 = element("div");
      if (buttons_slot)
        buttons_slot.c();
      t4 = space();
      button1 = element("button");
      t5 = text(ctx[3]);
      t6 = space();
      if (links_slot)
        links_slot.c();
      attr(h4, "class", "mb-0");
      attr(div0, "class", "modal-title");
      attr(button0, "type", "button");
      attr(button0, "class", "btn-close");
      attr(button0, "data-dismiss", "modal");
      attr(button0, "aria-label", "Close");
      attr(div1, "class", "modal-header");
      attr(div2, "class", "modal-body");
      attr(div2, "style", ctx[1]);
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-secondary");
      button1.autofocus = true;
      attr(div3, "class", "modal-footer justify-content-start");
      attr(div4, "class", "modal-content");
      attr(div5, "class", div5_class_value = "modal-dialog " + (!ctx[0] ? "modal-lg" : ""));
      attr(div5, "role", "document");
      toggle_class(div5, "modal-dialog-scrollable", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div1);
      append(div1, div0);
      append(div0, h4);
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(h4, null);
      }
      append(div0, t0);
      if (sub_header_slot) {
        sub_header_slot.m(div0, null);
      }
      append(div1, t1);
      append(div1, button0);
      append(div4, t2);
      append(div4, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append(div4, t3);
      append(div4, div3);
      if (buttons_slot) {
        buttons_slot.m(div3, null);
      }
      append(div3, t4);
      append(div3, button1);
      append(button1, t5);
      append(div3, t6);
      if (links_slot) {
        links_slot.m(div3, null);
      }
      current = true;
      button1.focus();
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[6]),
          listen(button1, "click", ctx[6]),
          action_destroyer(clickOutside$1.call(null, div5)),
          listen(div5, "outclick", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(header_slot_template, ctx2[10], dirty, get_header_slot_changes$8),
            get_header_slot_context$8
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & 4)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (sub_header_slot) {
        if (sub_header_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            sub_header_slot,
            sub_header_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(sub_header_slot_template, ctx2[10], dirty, get_sub_header_slot_changes$1),
            get_sub_header_slot_context$1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2) {
        attr(div2, "style", ctx2[1]);
      }
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(buttons_slot_template, ctx2[10], dirty, get_buttons_slot_changes$3),
            get_buttons_slot_context$3
          );
        }
      }
      if (!current || dirty & 8)
        set_data(t5, ctx2[3]);
      if (links_slot) {
        if (links_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            links_slot,
            links_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(links_slot_template, ctx2[10], dirty, get_links_slot_changes$1),
            get_links_slot_context$1
          );
        }
      }
      if (!current || dirty & 1 && div5_class_value !== (div5_class_value = "modal-dialog " + (!ctx2[0] ? "modal-lg" : ""))) {
        attr(div5, "class", div5_class_value);
      }
      if (!current || dirty & 17) {
        toggle_class(div5, "modal-dialog-scrollable", ctx2[4]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      transition_in(sub_header_slot, local);
      transition_in(default_slot, local);
      transition_in(buttons_slot, local);
      transition_in(links_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot_or_fallback, local);
      transition_out(sub_header_slot, local);
      transition_out(default_slot, local);
      transition_out(buttons_slot, local);
      transition_out(links_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
      if (sub_header_slot)
        sub_header_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (buttons_slot)
        buttons_slot.d(detaching);
      if (links_slot)
        links_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$4f(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const content_slot_template = ctx[11].content;
  const content_slot = create_slot(content_slot_template, ctx, ctx[10], get_content_slot_context$1);
  const content_slot_or_fallback = content_slot || fallback_block$9(ctx);
  return {
    c() {
      div = element("div");
      if (content_slot_or_fallback)
        content_slot_or_fallback.c();
      attr(div, "class", "modal fade show svelte-wa9pri");
      attr(div, "tabindex", "-1");
      attr(div, "role", "dialog");
      set_style(div, "display", "block");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (content_slot_or_fallback) {
        content_slot_or_fallback.m(div, null);
      }
      ctx[12](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[7]),
          action_destroyer(portal.call(null, div))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (content_slot) {
        if (content_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(content_slot_template, ctx2[10], dirty, get_content_slot_changes$1),
            get_content_slot_context$1
          );
        }
      } else {
        if (content_slot_or_fallback && content_slot_or_fallback.p && (!current || dirty & 1055)) {
          content_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(content_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(content_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (content_slot_or_fallback)
        content_slot_or_fallback.d(detaching);
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { closeOnClickOut = false } = $$props;
  let { isDialog = true } = $$props;
  let { bodyStyle = "" } = $$props;
  let { title = "" } = $$props;
  let { labelClose = T("a_cancel") } = $$props;
  let { scrollable = false } = $$props;
  const dispatch = createEventDispatcher();
  const onClose = () => dispatch("close");
  let modal;
  const onKeydown = (e) => {
    if (e.key === "Escape") {
      onClose();
      return;
    }
    if (e.key === "Tab") {
      const nodes = modal.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((n) => n.tabIndex >= 0);
      let index2 = tabbable.indexOf(document.activeElement);
      if (index2 === -1 && e.shiftKey)
        index2 = 0;
      index2 += tabbable.length + (e.shiftKey ? -1 : 1);
      index2 %= tabbable.length;
      tabbable[index2].focus();
      e.preventDefault();
    }
  };
  const lastFocused = document.activeElement;
  if (lastFocused) {
    onDestroy(() => {
      lastFocused.focus();
    });
  }
  function outClickClose() {
    if (closeOnClickOut) {
      onClose();
    }
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modal = $$value;
      $$invalidate(5, modal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("closeOnClickOut" in $$props2)
      $$invalidate(9, closeOnClickOut = $$props2.closeOnClickOut);
    if ("isDialog" in $$props2)
      $$invalidate(0, isDialog = $$props2.isDialog);
    if ("bodyStyle" in $$props2)
      $$invalidate(1, bodyStyle = $$props2.bodyStyle);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("labelClose" in $$props2)
      $$invalidate(3, labelClose = $$props2.labelClose);
    if ("scrollable" in $$props2)
      $$invalidate(4, scrollable = $$props2.scrollable);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    isDialog,
    bodyStyle,
    title,
    labelClose,
    scrollable,
    modal,
    onClose,
    onKeydown,
    outClickClose,
    closeOnClickOut,
    $$scope,
    slots,
    div_binding
  ];
}
class Modal$3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$45, create_fragment$4f, safe_not_equal, {
      closeOnClickOut: 9,
      isDialog: 0,
      bodyStyle: 1,
      title: 2,
      labelClose: 3,
      scrollable: 4
    });
  }
}
function download(text2, filename) {
  const element2 = document.createElement("a");
  const urlObj = new Blob([text2], { type: "text/plain" });
  element2.setAttribute("href", URL.createObjectURL(urlObj));
  element2.setAttribute("download", filename);
  element2.style.display = "none";
  document.body.appendChild(element2);
  element2.click();
  document.body.removeChild(element2);
  URL.revokeObjectURL(urlObj);
}
function get_each_context$14(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  return child_ctx;
}
function create_default_slot_1$t(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$28(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      $$slots: {
        header: [create_header_slot$o],
        default: [create_default_slot$1l]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[6]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 4097) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_each_block$14(ctx) {
  let div;
  let t_value = ctx[9].full_name + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "pa2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[9].full_name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$1l(ctx) {
  let each_1_anchor;
  let each_value = ctx[0].users;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$14(get_each_context$14(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = ctx2[0].users;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$14(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$14(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_header_slot$o(ctx) {
  let div;
  let t0;
  let a;
  let t1;
  let a_href_value;
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text("Members\n      (");
      a = element("a");
      t1 = text("Manage");
      t2 = text(")");
      attr(a, "class", "f5");
      attr(a, "href", a_href_value = "#/teams/" + ctx[0].id);
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, a);
      append(a, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && a_href_value !== (a_href_value = "#/teams/" + ctx2[0].id)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$4e(ctx) {
  let div5;
  let div0;
  let t0_value = ctx[0].name + "";
  let t0;
  let t1;
  let div1;
  let a;
  let t2_value = ctx[0].users.length + "";
  let t2;
  let t3;
  let t4_value = ctx[0].users.length > 1 ? "s" : "";
  let t4;
  let a_data_content_value;
  let t5;
  let div3;
  let div2;
  let button;
  let t6;
  let t7;
  let div4;
  let confirmbtn;
  let t8;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot_1$t] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[4]);
  let if_block = ctx[2] && create_if_block$28(ctx);
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      a = element("a");
      t2 = text(t2_value);
      t3 = text(" Member");
      t4 = text(t4_value);
      t5 = space();
      div3 = element("div");
      div2 = element("div");
      button = element("button");
      t6 = text("Export");
      t7 = space();
      div4 = element("div");
      create_component(confirmbtn.$$.fragment);
      t8 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "col-md-3");
      attr(a, "href", "#");
      attr(a, "tabindex", "0");
      attr(a, "role", "button");
      set_style(a, "border", "none");
      set_style(a, "cursor", "pointer");
      attr(a, "title", "Group Members");
      attr(a, "data-content", a_data_content_value = ctx[0].users.map(func).join("<br/>"));
      attr(div1, "class", "text-center col-md-3");
      attr(button, "class", "btn btn-default");
      button.disabled = ctx[1];
      attr(div2, "class", "text-center");
      attr(div3, "class", "col-md-3");
      attr(div4, "class", "text-center col-md-3");
      attr(div5, "class", "row flex items-center pt2 pb2 bb b--black-20");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, t0);
      append(div5, t1);
      append(div5, div1);
      append(div1, a);
      append(a, t2);
      append(a, t3);
      append(a, t4);
      append(div5, t5);
      append(div5, div3);
      append(div3, div2);
      append(div2, button);
      append(button, t6);
      append(div5, t7);
      append(div5, div4);
      mount_component(confirmbtn, div4, null);
      insert(target, t8, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", prevent_default(ctx[5])),
          listen(button, "click", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].users.length + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 1) && t4_value !== (t4_value = ctx2[0].users.length > 1 ? "s" : ""))
        set_data(t4, t4_value);
      if (!current || dirty & 1 && a_data_content_value !== (a_data_content_value = ctx2[0].users.map(func).join("<br/>"))) {
        attr(a, "data-content", a_data_content_value);
      }
      if (!current || dirty & 2) {
        button.disabled = ctx2[1];
      }
      const confirmbtn_changes = {};
      if (dirty & 4096) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(confirmbtn);
      if (detaching)
        detach(t8);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
const func = (u) => u.full_name;
function instance$44($$self, $$props, $$invalidate) {
  let { group } = $$props;
  let loading2 = false;
  let showUsers = false;
  async function exportMonitors() {
    try {
      $$invalidate(1, loading2 = true);
      await load([], 0, group.id);
    } catch (e) {
      console.error(e);
    } finally {
      $$invalidate(1, loading2 = false);
    }
  }
  async function load(list, offset, id2) {
    const res = await Api.api(`/admin/users/${id2}/sieves`, "GET", _.extend(
      {
        _opt: {
          offset,
          only: [
            "name",
            "uri",
            "config",
            "tags",
            "content_type",
            "state",
            "schedule",
            "ts"
          ]
        }
      },
      { "state.in": [40, 45] }
    ));
    list = list.concat(res.data);
    offset += res.count;
    if (offset < res.total_count) {
      await load(list, offset, id2);
    } else {
      onLoadListDone(id2, list);
    }
  }
  async function onLoadListDone(id2, list) {
    const res = await Api.api(`/admin/users/${id2}/tags`, "GET");
    const tags = res.data.reduce(
      (memo, item) => {
        memo[item.id] = item;
        return memo;
      },
      {}
    );
    list.forEach((x) => {
      x.tags = _.compact((x.tags || "").split(",").map(function(id3) {
        const tag = tags[id3];
        return tag ? tag.name : void 0;
      }));
      delete x.id;
      delete x.rule_id;
      delete x.ts;
      delete x.ts_mod;
      delete x._state;
    });
    const json = JSON.stringify({ client: Supports.agents, data: list });
    download(json, `${group.name}-sieves.json`);
  }
  async function removeGroup() {
    try {
      const response = await Api.api(`/admin/groups/${group.id}`, "DELETE");
    } catch (e) {
      alert("Something went wrong");
      console.error(e);
    }
  }
  function onShowUsers(e) {
    e.preventDefault();
    $$invalidate(2, showUsers = true);
  }
  const close_handler = (e) => $$invalidate(2, showUsers = false);
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(0, group = $$props2.group);
  };
  return [
    group,
    loading2,
    showUsers,
    exportMonitors,
    removeGroup,
    onShowUsers,
    close_handler
  ];
}
class Group extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$44, create_fragment$4e, safe_not_equal, { group: 0 });
  }
}
function get_each_context$13(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_each_block$13(ctx) {
  let group;
  let current;
  group = new Group({
    props: {
      group: ctx[0][ctx[3]],
      users: ctx[1]
    }
  });
  return {
    c() {
      create_component(group.$$.fragment);
    },
    m(target, anchor) {
      mount_component(group, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const group_changes = {};
      if (dirty & 1)
        group_changes.group = ctx2[0][ctx2[3]];
      if (dirty & 2)
        group_changes.users = ctx2[1];
      group.$set(group_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(group, detaching);
    }
  };
}
function create_fragment$4d(ctx) {
  let div4;
  let t4;
  let div9;
  let t12;
  let each_1_anchor;
  let current;
  let each_value = Object.keys(ctx[0]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$13(get_each_context$13(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div4 = element("div");
      div4.innerHTML = `<div class="col-md-12"><a href="#/teams/" class="btn btn-primary right">+ Add New Team</a></div> 
  <div style="text-align: left;" class="col-md-2"></div> 
  <div class="col-md-3"></div> 
  <div class="col-md-3"></div>`;
      t4 = space();
      div9 = element("div");
      div9.innerHTML = `<div class="col-md-3"><h5>Name</h5></div> 
  <div class="text-center col-md-3"><h5>Members</h5></div> 
  <div class="text-center col-md-3"><h5>Export Watchlist</h5></div> 
  <div class="text-center col-md-3"><h5>Delete</h5></div>`;
      t12 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div4, "class", "row mb3");
      attr(div9, "class", "row pb2 bb");
      set_style(div9, "border-color", "#ccc");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      insert(target, t4, anchor);
      insert(target, div9, anchor);
      insert(target, t12, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = Object.keys(ctx2[0]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$13(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$13(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div9);
      if (detaching)
        detach(t12);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance$43($$self, $$props, $$invalidate) {
  let groups = {};
  let users = [];
  onMount(() => {
    refreshGroups();
  });
  async function refreshGroups() {
    $$invalidate(1, users = (await Api.api("/accounts/users")).data);
    const response = await Api.api("/admin/groups/users");
    const groupUsers = response.data;
    $$invalidate(0, groups = {});
    for (let guser of groupUsers) {
      let { id: id2, name } = guser;
      let group = { id: id2, name, users: [guser] };
      if (groups[id2]) {
        groups[id2].users.push(guser);
      } else {
        $$invalidate(0, groups[id2] = group, groups);
      }
    }
  }
  return [groups, users];
}
class Groups extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$43, create_fragment$4d, safe_not_equal, {});
  }
}
function create_default_slot$1k(ctx) {
  let t;
  return {
    c() {
      t = text("Remove");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$4c(ctx) {
  let div5;
  let div0;
  let t0_value = ctx[0].full_name + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ctx[0].email + "";
  let t2;
  let t3;
  let div2;
  let input;
  let input_checked_value;
  let input_disabled_value;
  let t4;
  let div3;
  let button;
  let t5;
  let t6;
  let div4;
  let confirmbtn;
  let current;
  let mounted;
  let dispose;
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot$1k] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[4]);
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      input = element("input");
      t4 = space();
      div3 = element("div");
      button = element("button");
      t5 = text("Export");
      t6 = space();
      div4 = element("div");
      create_component(confirmbtn.$$.fragment);
      attr(div0, "class", "col-md-3");
      attr(div1, "class", "col-md-3");
      attr(input, "type", "checkbox");
      input.checked = input_checked_value = ctx[0].role == "admin";
      input.disabled = input_disabled_value = ctx[0].id == USER.id;
      attr(div2, "class", "text-center col-md-2");
      attr(button, "class", "btn btn-default btn-slim");
      button.disabled = ctx[1];
      attr(div3, "class", "text-center col-md-2");
      attr(div4, "class", "text-center col-md-2");
      toggle_class(div4, "hide", ctx[2].id == ctx[0].id);
      attr(div5, "class", "row flex items-center pt2 pb2 bb b--black-20");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, t0);
      append(div5, t1);
      append(div5, div1);
      append(div1, t2);
      append(div5, t3);
      append(div5, div2);
      append(div2, input);
      append(div5, t4);
      append(div5, div3);
      append(div3, button);
      append(button, t5);
      append(div5, t6);
      append(div5, div4);
      mount_component(confirmbtn, div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "click", ctx[5]),
          listen(button, "click", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].full_name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].email + ""))
        set_data(t2, t2_value);
      if (!current || dirty & 1 && input_checked_value !== (input_checked_value = ctx2[0].role == "admin")) {
        input.checked = input_checked_value;
      }
      if (!current || dirty & 1 && input_disabled_value !== (input_disabled_value = ctx2[0].id == USER.id)) {
        input.disabled = input_disabled_value;
      }
      if (!current || dirty & 2) {
        button.disabled = ctx2[1];
      }
      const confirmbtn_changes = {};
      if (dirty & 512) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
      if (!current || dirty & 5) {
        toggle_class(div4, "hide", ctx2[2].id == ctx2[0].id);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(confirmbtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$42($$self, $$props, $$invalidate) {
  let { user } = $$props;
  let dispatch = createEventDispatcher();
  let thisUser = getContext("user");
  let loading2 = false;
  async function exportMonitors() {
    try {
      $$invalidate(1, loading2 = true);
      await load([], 0, user.id);
    } catch (e) {
      console.error(e);
    } finally {
      $$invalidate(1, loading2 = false);
    }
  }
  async function load(list, offset, id2) {
    const res = await Api.api(`/admin/users/${id2}/sieves`, "GET", _.extend(
      {
        _opt: {
          offset,
          only: [
            "name",
            "uri",
            "config",
            "tags",
            "content_type",
            "state",
            "schedule",
            "ts"
          ]
        }
      },
      { "state.in": [40, 45] }
    ));
    list = list.concat(res.data);
    offset += res.count;
    if (offset < res.total_count) {
      await load(list, offset, id2);
    } else {
      onLoadListDone(id2, list);
    }
  }
  async function onLoadListDone(id2, list) {
    const res = await Api.api(`/admin/users/${id2}/tags`, "GET");
    const tags = res.data.reduce(
      (memo, item) => {
        memo[item.id] = item;
        return memo;
      },
      {}
    );
    list.forEach((x) => {
      x.tags = _.compact((x.tags || "").split(",").map(function(id3) {
        const tag = tags[id3];
        return tag ? tag.name : void 0;
      }));
      delete x.id;
      delete x.rule_id;
      delete x.ts;
      delete x.ts_mod;
      delete x._state;
    });
    const json = JSON.stringify({ client: Supports.agents, data: list });
    download(json, `${user.name}-sieves.json`);
  }
  async function removeUser() {
    try {
      const response = await Api.api(`/admin/users/${user.id}`, "DELETE");
      if (response.msg == "ok") {
        dispatch("change");
      } else {
        alert("Please try again later, something went wrong");
        console.error(response);
      }
    } catch (e) {
      alert("Please try again later, something went wrong");
      console.error(e);
    }
  }
  async function modifyAdminStatus(e) {
    const params2 = {};
    if (e.target.checked) {
      params2.role = "admin";
    } else {
      params2.role = "user";
    }
    try {
      const response = await Api.api(`/admin/users/${user.id}`, "PUT", params2);
      if (response && response.msg == "ok") {
        dispatch("change");
      } else {
        alert("Something went wrong");
        console.error(response);
      }
    } catch (e2) {
      alert("Something went wrong");
      console.error(e2);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("user" in $$props2)
      $$invalidate(0, user = $$props2.user);
  };
  return [user, loading2, thisUser, exportMonitors, removeUser, modifyAdminStatus];
}
class User extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$42, create_fragment$4c, safe_not_equal, { user: 0 });
  }
}
function get_each_context$12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  return child_ctx;
}
function create_if_block_3$H(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Please enter employee name";
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_2$X(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Please enter employee email";
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_1$1m(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Please enter different email, entered email already exists";
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block$27(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `Email should belong to the following domains: ${ctx[5].domains.join(", ")}`;
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_each_block$12(key_1, ctx) {
  let div;
  let label;
  let input;
  let t0;
  let t1_value = ctx[17].name + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[11](ctx[17], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && t1_value !== (t1_value = ctx[17].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4b(ctx) {
  let div4;
  let form;
  let div0;
  let label0;
  let t1;
  let input0;
  let t2;
  let t3;
  let div1;
  let label1;
  let t5;
  let input1;
  let t6;
  let t7;
  let t8;
  let t9;
  let div2;
  let label2;
  let t11;
  let select;
  let option0;
  let option1;
  let t14;
  let label3;
  let t16;
  let div3;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let if_block0 = ctx[4].name_presence && create_if_block_3$H();
  let if_block1 = ctx[4].email_presence && create_if_block_2$X();
  let if_block2 = ctx[4].duplicate_email && create_if_block_1$1m();
  let if_block3 = ctx[4].email_domain && create_if_block$27(ctx);
  let each_value = ctx[3];
  const get_key = (ctx2) => ctx2[17].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$12(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$12(key, child_ctx));
  }
  return {
    c() {
      div4 = element("div");
      form = element("form");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Full Name";
      t1 = space();
      input0 = element("input");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Email ID";
      t5 = space();
      input1 = element("input");
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      if (if_block2)
        if_block2.c();
      t8 = space();
      if (if_block3)
        if_block3.c();
      t9 = space();
      div2 = element("div");
      label2 = element("label");
      label2.textContent = "Role";
      t11 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = "User";
      option1 = element("option");
      option1.textContent = "Admin";
      t14 = space();
      label3 = element("label");
      label3.textContent = "Add to Team";
      t16 = space();
      div3 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(label0, "for", "groupName");
      attr(input0, "class", "form-control");
      attr(input0, "type", "text");
      attr(input0, "name", "full_name");
      attr(input0, "placeholder", "Full Name");
      attr(div0, "class", "form-group");
      attr(label1, "for", "groupName");
      attr(input1, "class", "form-control");
      attr(input1, "type", "text");
      attr(input1, "name", "email");
      attr(input1, "placeholder", "Email ID");
      attr(div1, "class", "form-group");
      attr(label2, "for", "employeeRole");
      option0.__value = "user";
      option0.value = option0.__value;
      option1.__value = "admin";
      option1.value = option1.__value;
      attr(select, "class", "form-control");
      attr(select, "id", "employeeRole");
      if (ctx[2] === void 0)
        add_render_callback(() => ctx[10].call(select));
      attr(div2, "class", "form-group");
      attr(div3, "class", "p-4 max-h-[32rem] border border-solid border-gray-300");
      set_style(div3, "overflow", "scroll");
      attr(div4, "class", "row p-8");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, form);
      append(form, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(input0, ctx[1]);
      append(form, t2);
      if (if_block0)
        if_block0.m(form, null);
      append(form, t3);
      append(form, div1);
      append(div1, label1);
      append(div1, t5);
      append(div1, input1);
      set_input_value(input1, ctx[0]);
      append(form, t6);
      if (if_block1)
        if_block1.m(form, null);
      append(form, t7);
      if (if_block2)
        if_block2.m(form, null);
      append(form, t8);
      if (if_block3)
        if_block3.m(form, null);
      append(form, t9);
      append(form, div2);
      append(div2, label2);
      append(div2, t11);
      append(div2, select);
      append(select, option0);
      append(select, option1);
      select_option(select, ctx[2], true);
      append(form, t14);
      append(form, label3);
      append(form, t16);
      append(form, div3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div3, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[8]),
          listen(input1, "input", ctx[9]),
          listen(select, "change", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && input0.value !== ctx2[1]) {
        set_input_value(input0, ctx2[1]);
      }
      if (ctx2[4].name_presence) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_3$H();
          if_block0.c();
          if_block0.m(form, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 1 && input1.value !== ctx2[0]) {
        set_input_value(input1, ctx2[0]);
      }
      if (ctx2[4].email_presence) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_2$X();
          if_block1.c();
          if_block1.m(form, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[4].duplicate_email) {
        if (if_block2)
          ;
        else {
          if_block2 = create_if_block_1$1m();
          if_block2.c();
          if_block2.m(form, t8);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[4].email_domain) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block$27(ctx2);
          if_block3.c();
          if_block3.m(form, t9);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (dirty & 4) {
        select_option(select, ctx2[2]);
      }
      if (dirty & 72) {
        each_value = ctx2[3];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div3, destroy_block, create_each_block$12, null, get_each_context$12);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$41($$self, $$props, $$invalidate) {
  let user = getContext("user");
  let account = user.get("account");
  let email = "";
  let full_name = "";
  let role = "user";
  let groups = [];
  let selectedGroups = [];
  let errors = {
    name_presence: false,
    email_presence: false,
    email_domain: false,
    duplicate_email: false
  };
  onMount(async () => {
    fetchGroups();
  });
  function addGroup(id2, e) {
    if (e.target.checked) {
      selectedGroups.push({ id: id2, admin: false, edit: true });
    } else {
      selectedGroups = _.filter(selectedGroups, (group) => group.id != id2);
    }
  }
  async function isDuplicate(email2) {
    const emailList = (await Api.api(`/admin/users`)).data.map((item) => {
      return item["email"];
    });
    return emailList.includes(email2);
  }
  async function validate() {
    $$invalidate(4, errors = {
      name_presence: false,
      email_presence: false,
      email_domain: false,
      duplicate_email: false
    });
    let valid = true;
    if (!full_name) {
      valid = false;
      $$invalidate(4, errors = { ...errors, name_presence: true });
    }
    if (await isDuplicate(email)) {
      valid = false;
      $$invalidate(4, errors = { ...errors, duplicate_email: true });
    }
    if (!email || email == "") {
      valid = false;
      $$invalidate(4, errors = { ...errors, email_presence: true });
    } else {
      const emailParts = email.split("@");
      let domain = emailParts[emailParts.length - 1];
      const domains = account.domains.map((domain2) => domain2.toLowerCase());
      domain = domain.toLowerCase();
      if (domains.indexOf(domain) == -1) {
        valid = false;
        $$invalidate(4, errors = { ...errors, email_domain: true });
      }
    }
    return valid;
  }
  async function fetchGroups() {
    const response = await Api.api("/admin/groups");
    $$invalidate(3, groups = response.data);
  }
  async function save() {
    if (!await validate()) {
      return false;
    }
    return await Api.api(`/admin/users`, "POST", {
      user: { role, full_name, email },
      groups: selectedGroups
    });
  }
  function input0_input_handler() {
    full_name = this.value;
    $$invalidate(1, full_name);
  }
  function input1_input_handler() {
    email = this.value;
    $$invalidate(0, email);
  }
  function select_change_handler() {
    role = select_value(this);
    $$invalidate(2, role);
  }
  const click_handler = (group, e) => addGroup(group.id, e);
  return [
    email,
    full_name,
    role,
    groups,
    errors,
    account,
    addGroup,
    save,
    input0_input_handler,
    input1_input_handler,
    select_change_handler,
    click_handler
  ];
}
class UserNew extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$41, create_fragment$4b, safe_not_equal, { save: 7 });
  }
  get save() {
    return this.$$.ctx[7];
  }
}
function get_each_context$11(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_each_block$11(key_1, ctx) {
  let first;
  let user;
  let current;
  user = new User({ props: { user: ctx[8] } });
  user.$on("change", ctx[3]);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(user.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(user, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const user_changes = {};
      if (dirty & 1)
        user_changes.user = ctx[8];
      user.$set(user_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(user.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(user.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(user, detaching);
    }
  };
}
function create_if_block$26(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      $$slots: {
        buttons: [create_buttons_slot$7],
        header: [create_header_slot$n],
        default: [create_default_slot$1j]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[7]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 2052) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_default_slot$1j(ctx) {
  let usernew;
  let current;
  let usernew_props = {};
  usernew = new UserNew({ props: usernew_props });
  ctx[6](usernew);
  return {
    c() {
      create_component(usernew.$$.fragment);
    },
    m(target, anchor) {
      mount_component(usernew, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const usernew_changes = {};
      usernew.$set(usernew_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(usernew.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(usernew.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[6](null);
      destroy_component(usernew, detaching);
    }
  };
}
function create_header_slot$n(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Add User";
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_buttons_slot$7(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "Add User";
      attr(button, "class", "btn btn-primary");
      attr(div, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4a(ctx) {
  let div1;
  let div0;
  let button;
  let t1;
  let div7;
  let t11;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t12;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[8].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$11(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$11(key, child_ctx));
  }
  let if_block = ctx[1] && create_if_block$26(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button = element("button");
      button.textContent = "+ Add New User";
      t1 = space();
      div7 = element("div");
      div7.innerHTML = `<div class="col-md-3"><h5>Name</h5></div> 
  <div class="col-md-3"><h5>Email</h5></div> 
  <div class="text-center col-md-2"><h5>Admin</h5></div> 
  <div class="text-center col-md-2"><h5>Export Watchlist</h5></div> 
  <div class="text-center col-md-2"><h5>Remove</h5></div>`;
      t11 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t12 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(button, "class", "btn btn-primary right");
      attr(div0, "class", "col-md-12");
      attr(div1, "class", "row mb3");
      attr(div7, "class", "row flex items-center pb2 bb");
      set_style(div7, "border-color", "#ccc");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button);
      insert(target, t1, anchor);
      insert(target, div7, anchor);
      insert(target, t11, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t12, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 9) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t12.parentNode, outro_and_destroy_block, create_each_block$11, t12, get_each_context$11);
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$26(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div7);
      if (detaching)
        detach(t11);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(t12);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$40($$self, $$props, $$invalidate) {
  let users = [];
  let add = false;
  let addUser;
  async function refreshUsers() {
    const response = await Api.api("/admin/users");
    $$invalidate(0, users = response.data);
  }
  onMount(() => {
    refreshUsers();
  });
  async function onSaveNew() {
    try {
      if (await addUser.save()) {
        $$invalidate(1, add = false);
        await refreshUsers();
      }
    } catch (e) {
      alert("Something went wrong: " + e.message);
      console.error(e);
    }
  }
  const click_handler = (e) => $$invalidate(1, add = true);
  function usernew_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      addUser = $$value;
      $$invalidate(2, addUser);
    });
  }
  const close_handler = () => $$invalidate(1, add = false);
  return [
    users,
    add,
    addUser,
    refreshUsers,
    onSaveNew,
    click_handler,
    usernew_binding,
    close_handler
  ];
}
class Users extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$40, create_fragment$4a, safe_not_equal, {});
  }
}
function create_else_block$17(ctx) {
  let entonly;
  let current;
  entonly = new EnterpriseOnly({});
  return {
    c() {
      create_component(entonly.$$.fragment);
    },
    m(target, anchor) {
      mount_component(entonly, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(entonly.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(entonly.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(entonly, detaching);
    }
  };
}
function create_if_block$25(ctx) {
  let div4;
  let div1;
  let div0;
  let a0;
  let t1;
  let a1;
  let t3;
  let a2;
  let t5;
  let div3;
  let div2;
  let router;
  let current;
  router = new Router({
    props: {
      routes: ctx[3],
      prefix: "/admin"
    }
  });
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      a0 = element("a");
      a0.textContent = "Account";
      t1 = space();
      a1 = element("a");
      a1.textContent = "Users";
      t3 = space();
      a2 = element("a");
      a2.textContent = "Teams";
      t5 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(router.$$.fragment);
      attr(a0, "class", "list-group-item");
      attr(a0, "href", "#/admin/account/");
      toggle_class(a0, "active", ctx[0].module == "account");
      attr(a1, "class", "list-group-item");
      attr(a1, "href", "#/admin/users/");
      toggle_class(a1, "active", ctx[0].module == "users");
      attr(a2, "class", "list-group-item");
      attr(a2, "href", "#/admin/teams/");
      toggle_class(a2, "active", ctx[0].module == "teams");
      attr(div0, "class", "list-group collapse dont-collapse-sm");
      set_style(div0, "width", "18rem");
      attr(div1, "class", "col-md-3");
      attr(div2, "class", "container-fluid");
      attr(div3, "class", "col-md-8 ml4");
      attr(div4, "class", "row");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      append(div0, a0);
      append(div0, t1);
      append(div0, a1);
      append(div0, t3);
      append(div0, a2);
      append(div4, t5);
      append(div4, div3);
      append(div3, div2);
      mount_component(router, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 1) {
        toggle_class(a0, "active", ctx2[0].module == "account");
      }
      if (!current || dirty & 1) {
        toggle_class(a1, "active", ctx2[0].module == "users");
      }
      if (!current || dirty & 1) {
        toggle_class(a2, "active", ctx2[0].module == "teams");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(router.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(router.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(router);
    }
  };
}
function create_default_slot$1i(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$25, create_else_block$17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].account)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      attr(div0, "class", "row");
      attr(div1, "class", "container");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_topbar_slot$a(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Teams" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$49(ctx) {
  let t;
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$a],
        default: [create_default_slot$1i]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
      document.title = "Admin Console - Distill Web Monitor";
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 19) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$3$($$self, $$props, $$invalidate) {
  let $user;
  let { params: params2 } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(1, $user = value));
  const routes = {
    "/account/": Account,
    "/teams/": Groups,
    "/users/": Users,
    "*": Error404
  };
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, $user, user, routes];
}
class Admin extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3$, create_fragment$49, safe_not_equal, { params: 0 });
  }
}
var index_svelte_svelte_type_style_lang = "";
function get_each_context$10(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function create_else_block$16(ctx) {
  let div12;
  let div11;
  let div10;
  let div0;
  let t0;
  let div8;
  let div5;
  let t8;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t9;
  let form;
  let div6;
  let input;
  let t10;
  let t11;
  let div7;
  let button;
  let t13;
  let div9;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[18].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$10(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$10(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$g();
  }
  let if_block = ctx[1] && create_if_block_1$1l();
  return {
    c() {
      div12 = element("div");
      div11 = element("div");
      div10 = element("div");
      div0 = element("div");
      t0 = space();
      div8 = element("div");
      div5 = element("div");
      div5.innerHTML = `<div class="col-md-4"><h4>Team Name</h4></div> 
              <div class="col-md-2 text-center"><h4>Role</h4></div> 
              <div class="col-md-3 text-center"><h4>Leave Team</h4></div> 
              <div class="col-md-3 text-center"><h4>Delete Team</h4></div>`;
      t8 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t9 = space();
      form = element("form");
      div6 = element("div");
      input = element("input");
      t10 = space();
      if (if_block)
        if_block.c();
      t11 = space();
      div7 = element("div");
      button = element("button");
      button.textContent = "Create New Team";
      t13 = space();
      div9 = element("div");
      attr(div0, "class", "col-md-2");
      attr(div5, "class", "row team svelte-grlz0z");
      attr(div5, "data-id", "");
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", "New Team Name");
      attr(div6, "class", "col-md-6");
      attr(button, "class", "btn btn-primary");
      attr(button, "type", "button");
      attr(div7, "class", "col-md-3 text-center");
      attr(form, "class", "row team svelte-grlz0z");
      attr(div8, "class", "col-md-8");
      attr(div9, "class", "col-md-2");
      attr(div10, "class", "row");
      attr(div11, "class", "group-table container-fluid");
      attr(div12, "class", "add-group");
      toggle_class(div12, "hide", !ctx[3]);
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, div11);
      append(div11, div10);
      append(div10, div0);
      append(div10, t0);
      append(div10, div8);
      append(div8, div5);
      append(div8, t8);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div8, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(div8, null);
      }
      append(div8, t9);
      append(div8, form);
      append(form, div6);
      append(div6, input);
      set_input_value(input, ctx[2].name);
      append(div6, t10);
      if (if_block)
        if_block.m(div6, null);
      append(form, t11);
      append(form, div7);
      append(div7, button);
      append(div10, t13);
      append(div10, div9);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[12]),
          listen(button, "click", ctx[13]),
          listen(form, "submit", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 97) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div8, outro_and_destroy_block, create_each_block$10, t9, get_each_context$10);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block_1$g();
          each_1_else.c();
          each_1_else.m(div8, t9);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
      if (dirty & 4 && input.value !== ctx2[2].name) {
        set_input_value(input, ctx2[2].name);
      }
      if (ctx2[1]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$1l();
          if_block.c();
          if_block.m(div6, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 8) {
        toggle_class(div12, "hide", !ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div12);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$24(ctx) {
  let entonly;
  let current;
  entonly = new EnterpriseOnly({});
  return {
    c() {
      create_component(entonly.$$.fragment);
    },
    m(target, anchor) {
      mount_component(entonly, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(entonly.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(entonly.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(entonly, detaching);
    }
  };
}
function create_else_block_1$g(ctx) {
  let div1;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="col-md-9 alert alert-info ml3 mt2 mb2">Not part of any team. To be part of an existing team, please ask team admin to add you to the group.</div> 
              `;
      attr(div1, "class", "row team svelte-grlz0z");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_default_slot_2$9(ctx) {
  let t;
  return {
    c() {
      t = text("Leave");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$W(ctx) {
  let confirmbtn;
  let current;
  function click_handler_1(...args) {
    return ctx[11](ctx[18], ...args);
  }
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot_1$s] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", click_handler_1);
  return {
    c() {
      create_component(confirmbtn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmbtn, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const confirmbtn_changes = {};
      if (dirty & 2097152) {
        confirmbtn_changes.$$scope = { dirty, ctx };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmbtn, detaching);
    }
  };
}
function create_default_slot_1$s(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$10(key_1, ctx) {
  let div4;
  let div0;
  let a;
  let t0_value = ctx[18].name + "";
  let t0;
  let a_href_value;
  let t1;
  let div1;
  let t2_value = checkRole(ctx[18]) + "";
  let t2;
  let t3;
  let div2;
  let confirmbtn;
  let t4;
  let div3;
  let t5;
  let current;
  function click_handler(...args) {
    return ctx[10](ctx[18], ...args);
  }
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot_2$9] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", click_handler);
  let if_block = ctx[18].permissions.admin && create_if_block_2$W(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      div4 = element("div");
      div0 = element("div");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      create_component(confirmbtn.$$.fragment);
      t4 = space();
      div3 = element("div");
      if (if_block)
        if_block.c();
      t5 = space();
      attr(a, "href", a_href_value = "#/teams/" + ctx[18].id);
      attr(div0, "class", "col-md-4");
      attr(div1, "class", "col-md-2 text-center ");
      attr(div2, "class", "col-md-3 text-center remove-user");
      attr(div3, "class", "col-md-3 text-center remove-user");
      attr(div4, "class", "row team svelte-grlz0z");
      this.first = div4;
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, a);
      append(a, t0);
      append(div4, t1);
      append(div4, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div2);
      mount_component(confirmbtn, div2, null);
      append(div4, t4);
      append(div4, div3);
      if (if_block)
        if_block.m(div3, null);
      append(div4, t5);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[18].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 1 && a_href_value !== (a_href_value = "#/teams/" + ctx[18].id)) {
        attr(a, "href", a_href_value);
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = checkRole(ctx[18]) + ""))
        set_data(t2, t2_value);
      const confirmbtn_changes = {};
      if (dirty & 2097152) {
        confirmbtn_changes.$$scope = { dirty, ctx };
      }
      confirmbtn.$set(confirmbtn_changes);
      if (ctx[18].permissions.admin) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$W(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(confirmbtn);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$1l(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Please enter a team name.";
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_default_slot$1h(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$24, create_else_block$16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_topbar_slot$9(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Teams" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$48(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$9],
        default: [create_default_slot$1h]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 2097167) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function checkRole({ permissions }) {
  if (permissions.admin) {
    return "Admin";
  } else if (permissions.edit) {
    return "Editor";
  } else {
    return "Viewer";
  }
}
function instance$3_($$self, $$props, $$invalidate) {
  let $user;
  let { params: params2 = null } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(9, $user = value));
  let groups = [];
  let errEmptyTeam = false;
  let state = { name: "" };
  let isEnterprise = $user.account_id;
  fetchGroups();
  function validate() {
    $$invalidate(1, errEmptyTeam = false);
    let name = state.name;
    name = name.trim();
    if (!name || name == "") {
      $$invalidate(1, errEmptyTeam = true);
      return false;
    }
    return true;
  }
  async function fetchGroups() {
    let res = await Api.api("/groups", "GET", {
      user: { id: $user.id },
      _opt: { order: ["ts"] }
    });
    $$invalidate(0, groups = res.data);
  }
  async function leaveGroup(id2) {
    await Api.api(`/groups/${id2}/unsubscribe`, "POST");
    fetchGroups();
  }
  async function deleteGroup(id2) {
    await Api.api(`/groups/${id2}`, "DELETE");
    fetchGroups();
  }
  function resetFieldData() {
    document.getElementById("new-team-field").value = "";
    $$invalidate(2, state.name = "", state);
  }
  async function addGroup() {
    const name = state.name;
    if (validate()) {
      await Api.api(`/groups`, "POST", { name });
      fetchGroups();
      resetFieldData();
    }
  }
  const click_handler = (group, e) => leaveGroup(group.id);
  const click_handler_1 = (group, e) => deleteGroup(group.id);
  function input_input_handler() {
    state.name = this.value;
    $$invalidate(2, state);
  }
  const click_handler_2 = () => addGroup();
  const submit_handler = (e) => addGroup();
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(8, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $$invalidate(3, isEnterprise = !!$user.account_id);
    }
  };
  return [
    groups,
    errEmptyTeam,
    state,
    isEnterprise,
    user,
    leaveGroup,
    deleteGroup,
    addGroup,
    params2,
    $user,
    click_handler,
    click_handler_1,
    input_input_handler,
    click_handler_2,
    submit_handler
  ];
}
class Teams extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3_, create_fragment$48, safe_not_equal, { params: 8 });
  }
}
const get_header_slot_changes$7 = (dirty) => ({});
const get_header_slot_context$7 = (ctx) => ({ slot: "header" });
const get_sub_header_slot_changes = (dirty) => ({});
const get_sub_header_slot_context = (ctx) => ({ slot: "sub-header" });
function create_if_block$23(ctx) {
  let div;
  let t0;
  let t1_value = (ctx[4].message || JSON.stringify(ctx[4])) + "";
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text("Please try again later. Error: ");
      t1 = text(t1_value);
      t2 = text(".");
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t1_value !== (t1_value = (ctx2[4].message || JSON.stringify(ctx2[4])) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$1g(ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  let if_block = ctx[4] && create_if_block$23(ctx);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$23(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function fallback_block$8(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_header_slot$m(ctx) {
  let current;
  const header_slot_template = ctx[8].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[10], get_header_slot_context$7);
  const header_slot_or_fallback = header_slot || fallback_block$8(ctx);
  return {
    c() {
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(header_slot_template, ctx2[10], dirty, get_header_slot_changes$7),
            get_header_slot_context$7
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & 1)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
    }
  };
}
function create_sub_header_slot$3(ctx) {
  let current;
  const sub_header_slot_template = ctx[8]["sub-header"];
  const sub_header_slot = create_slot(sub_header_slot_template, ctx, ctx[10], get_sub_header_slot_context);
  return {
    c() {
      if (sub_header_slot)
        sub_header_slot.c();
    },
    m(target, anchor) {
      if (sub_header_slot) {
        sub_header_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (sub_header_slot) {
        if (sub_header_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            sub_header_slot,
            sub_header_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(sub_header_slot_template, ctx2[10], dirty, get_sub_header_slot_changes),
            get_sub_header_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sub_header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(sub_header_slot, local);
      current = false;
    },
    d(detaching) {
      if (sub_header_slot)
        sub_header_slot.d(detaching);
    }
  };
}
function create_buttons_slot$6(ctx) {
  let div;
  let button;
  let t_value = T(ctx[3] ? "l_loading" : ctx[1]) + "";
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary");
      set_style(button, "width", "100px");
      button.disabled = button_disabled_value = ctx[2] || ctx[3];
      attr(div, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 10 && t_value !== (t_value = T(ctx2[3] ? "l_loading" : ctx2[1]) + ""))
        set_data(t, t_value);
      if (dirty & 12 && button_disabled_value !== (button_disabled_value = ctx2[2] || ctx2[3])) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$47(ctx) {
  let modal;
  let current;
  const modal_spread_levels = [ctx[6]];
  let modal_props = {
    $$slots: {
      buttons: [create_buttons_slot$6],
      "sub-header": [create_sub_header_slot$3],
      header: [create_header_slot$m],
      default: [create_default_slot$1g]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < modal_spread_levels.length; i2 += 1) {
    modal_props = assign$1(modal_props, modal_spread_levels[i2]);
  }
  modal = new Modal$3({ props: modal_props });
  modal.$on("close", ctx[9]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = dirty & 64 ? get_spread_update(modal_spread_levels, [get_spread_object(ctx2[6])]) : {};
      if (dirty & 1055) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$3Z($$self, $$props, $$invalidate) {
  const omit_props_names = ["title", "saveLabel", "disableSave", "onSave"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title = "Edit" } = $$props;
  let { saveLabel = "a_save" } = $$props;
  let { disableSave = false } = $$props;
  let { onSave } = $$props;
  const dispatch = createEventDispatcher();
  let saving = false;
  let error = null;
  async function onSaveClick() {
    $$invalidate(3, saving = true);
    $$invalidate(4, error = null);
    try {
      await onSave();
      dispatch("save");
    } catch (e) {
      console.error("onSave error:", e);
      $$invalidate(4, error = e);
    }
    $$invalidate(3, saving = false);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
    if ("saveLabel" in $$new_props)
      $$invalidate(1, saveLabel = $$new_props.saveLabel);
    if ("disableSave" in $$new_props)
      $$invalidate(2, disableSave = $$new_props.disableSave);
    if ("onSave" in $$new_props)
      $$invalidate(7, onSave = $$new_props.onSave);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  return [
    title,
    saveLabel,
    disableSave,
    saving,
    error,
    onSaveClick,
    $$restProps,
    onSave,
    slots,
    close_handler,
    $$scope
  ];
}
class SaveModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Z, create_fragment$47, safe_not_equal, {
      title: 0,
      saveLabel: 1,
      disableSave: 2,
      onSave: 7
    });
  }
}
function create_if_block_2$V(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[0].permissions.edit;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[7]),
          listen(input, "change", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        input.checked = ctx2[0].permissions.edit;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$1k(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[0].permissions.admin;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[9]),
          listen(input, "change", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        input.checked = ctx2[0].permissions.admin;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$22(ctx) {
  let confirmbtn;
  let current;
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot$1f] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[4]);
  return {
    c() {
      create_component(confirmbtn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmbtn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const confirmbtn_changes = {};
      if (dirty & 4096) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmbtn, detaching);
    }
  };
}
function create_default_slot$1f(ctx) {
  let t;
  return {
    c() {
      t = text("Remove User");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$46(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[0].full_name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[0].email + "";
  let t2;
  let t3;
  let td2;
  let t4;
  let td3;
  let t5;
  let td4;
  let current;
  let if_block0 = !ctx[3] && ctx[1].permissions.admin && create_if_block_2$V(ctx);
  let if_block1 = !ctx[3] && ctx[1].permissions.admin && create_if_block_1$1k(ctx);
  let if_block2 = ctx[0].id != ctx[2].id && ctx[1].permissions.admin && create_if_block$22(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      if (if_block0)
        if_block0.c();
      t4 = space();
      td3 = element("td");
      if (if_block1)
        if_block1.c();
      t5 = space();
      td4 = element("td");
      if (if_block2)
        if_block2.c();
      attr(td0, "class", "pa3");
      set_style(td0, "border-bottom", "solid 1px #ccc");
      attr(td1, "class", "pa3");
      set_style(td1, "border-bottom", "solid 1px #ccc");
      attr(td2, "class", "pa3");
      set_style(td2, "border-bottom", "solid 1px #ccc");
      set_style(td3, "padding", "5px");
      set_style(td3, "border-bottom", "solid 1px #ccc");
      set_style(td4, "padding", "5px");
      set_style(td4, "border-bottom", "solid 1px #ccc");
      set_style(tr, "height", "50px");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      if (if_block0)
        if_block0.m(td2, null);
      append(tr, t4);
      append(tr, td3);
      if (if_block1)
        if_block1.m(td3, null);
      append(tr, t5);
      append(tr, td4);
      if (if_block2)
        if_block2.m(td4, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].full_name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].email + ""))
        set_data(t2, t2_value);
      if (!ctx2[3] && ctx2[1].permissions.admin) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$V(ctx2);
          if_block0.c();
          if_block0.m(td2, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[3] && ctx2[1].permissions.admin) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1k(ctx2);
          if_block1.c();
          if_block1.m(td3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[0].id != ctx2[2].id && ctx2[1].permissions.admin) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 3) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$22(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(td4, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$3Y($$self, $$props, $$invalidate) {
  let { group } = $$props;
  let { user } = $$props;
  let { reload } = $$props;
  const USER2 = getContext("user");
  const isSelf = user.id == USER2.id;
  async function onRemoveClick() {
    await Api.api(`/groups/${group.id}/unsubscribe/${user.id}`, "DELETE");
    reload();
  }
  async function onChangeRole(e, context) {
    if (context == "admin") {
      if (e.target.checked) {
        await saveRole(user.id, { admin: true, edit: true });
      } else {
        await saveRole(user.id, { admin: false, edit: true });
      }
    } else if (context == "edit") {
      if (e.target.checked) {
        await saveRole(user.id, { admin: false, edit: true });
      } else {
        await saveRole(user.id, { admin: false, edit: false });
      }
    }
    reload();
  }
  async function saveRole(id2, permissions) {
    try {
      await Api.api(`/groups/${group.id}/role/${id2}`, "PUT", permissions);
      reload();
    } catch (e) {
      console.error(e);
    }
  }
  const change_handler = (e) => onChangeRole(e, "edit");
  function input_change_handler() {
    user.permissions.edit = this.checked;
    $$invalidate(0, user);
  }
  const change_handler_1 = (e) => onChangeRole(e, "admin");
  function input_change_handler_1() {
    user.permissions.admin = this.checked;
    $$invalidate(0, user);
  }
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(1, group = $$props2.group);
    if ("user" in $$props2)
      $$invalidate(0, user = $$props2.user);
    if ("reload" in $$props2)
      $$invalidate(6, reload = $$props2.reload);
  };
  return [
    user,
    group,
    USER2,
    isSelf,
    onRemoveClick,
    onChangeRole,
    reload,
    change_handler,
    input_change_handler,
    change_handler_1,
    input_change_handler_1
  ];
}
class TeamUser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Y, create_fragment$46, safe_not_equal, { group: 1, user: 0, reload: 6 });
  }
}
var Team_svelte_svelte_type_style_lang = "";
function get_each_context$$(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_catch_block$v(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$v(ctx) {
  let div9;
  let div3;
  let div0;
  let t0;
  let div1;
  let button;
  let t2;
  let div2;
  let t3;
  let div8;
  let div4;
  let t4;
  let div6;
  let div5;
  let h4;
  let t5;
  let t6_value = ctx[1].name + "";
  let t6;
  let t7;
  let t8;
  let table;
  let thead;
  let t18;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t19;
  let t20;
  let div7;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1].permissions.admin && create_if_block_2$U(ctx);
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[8].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$$(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$$(key, child_ctx));
  }
  let if_block1 = ctx[1].permissions.admin && create_if_block_1$1j(ctx);
  return {
    c() {
      div9 = element("div");
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fa fa-caret-left mr2" aria-hidden="true"></i> Back`;
      t2 = space();
      div2 = element("div");
      t3 = space();
      div8 = element("div");
      div4 = element("div");
      t4 = space();
      div6 = element("div");
      div5 = element("div");
      h4 = element("h4");
      t5 = text("Team: ");
      t6 = text(t6_value);
      t7 = space();
      if (if_block0)
        if_block0.c();
      t8 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="pa3 svelte-15nnkot">Name</th> 
                <th class="pa3 svelte-15nnkot">Email</th> 
                <th class="pa3 svelte-15nnkot">Edit</th> 
                <th class="pa3 svelte-15nnkot">Admin</th> 
                <th class="pa3 svelte-15nnkot" style="width: 300px;">Remove</th></tr>`;
      t18 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t19 = space();
      if (if_block1)
        if_block1.c();
      t20 = space();
      div7 = element("div");
      attr(div0, "class", "col-md-2");
      attr(button, "class", "btn btn-default");
      attr(button, "type", "button");
      attr(div1, "class", "col-md-2");
      attr(div2, "class", "col-md-8");
      attr(div3, "class", "row");
      attr(div4, "class", "col-md-2");
      attr(div5, "class", "page-header");
      set_style(table, "width", "100%");
      set_style(table, "margin-bottom", "40px");
      attr(div6, "class", "col-md-8");
      attr(div7, "class", "col-md-2");
      attr(div8, "class", "row");
      attr(div9, "class", "container-fluid");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div3);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      append(div1, button);
      append(div3, t2);
      append(div3, div2);
      append(div9, t3);
      append(div9, div8);
      append(div8, div4);
      append(div8, t4);
      append(div8, div6);
      append(div6, div5);
      append(div5, h4);
      append(h4, t5);
      append(h4, t6);
      append(h4, t7);
      if (if_block0)
        if_block0.m(h4, null);
      append(div6, t8);
      append(div6, table);
      append(table, thead);
      append(table, t18);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      append(div6, t19);
      if (if_block1)
        if_block1.m(div6, null);
      append(div8, t20);
      append(div8, div7);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 2) && t6_value !== (t6_value = ctx2[1].name + ""))
        set_data(t6, t6_value);
      if (ctx2[1].permissions.admin) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$U(ctx2);
          if_block0.c();
          if_block0.m(h4, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 131) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$$, null, get_each_context$$);
        check_outros();
      }
      if (ctx2[1].permissions.admin) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1j(ctx2);
          if_block1.c();
          if_block1.m(div6, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div9);
      if (if_block0)
        if_block0.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$U(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Edit";
      attr(a, "class", "f6");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[5]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$$(key_1, ctx) {
  let first;
  let teamuser;
  let current;
  teamuser = new TeamUser({
    props: {
      user: ctx[8],
      group: ctx[1],
      reload: ctx[7]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(teamuser.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(teamuser, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const teamuser_changes = {};
      if (dirty & 1)
        teamuser_changes.user = ctx[8];
      if (dirty & 2)
        teamuser_changes.group = ctx[1];
      teamuser.$set(teamuser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(teamuser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(teamuser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(teamuser, detaching);
    }
  };
}
function create_if_block_1$1j(ctx) {
  let input;
  return {
    c() {
      input = element("input");
      attr(input, "placeholder", "Add User");
      attr(input, "type", "text");
      attr(input, "autocomplete", "off");
      attr(input, "class", "form-control");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[12](input);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[12](null);
    }
  };
}
function create_pending_block$v(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$r(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$v,
    then: create_then_block$v,
    catch: create_catch_block$v,
    blocks: [, , ,]
  };
  handle_promise(ctx[4], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_topbar_slot$8(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Manage Team" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_if_block$21(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Edit Team Name",
      onSave: ctx[6],
      $$slots: { default: [create_default_slot$1e] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[14]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 1048578) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$1e(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      input.autofocus = true;
      attr(input, "class", "form-control");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1].name);
      input.focus();
      if (!mounted) {
        dispose = listen(input, "input", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1].name) {
        set_input_value(input, ctx2[1].name);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$45(ctx) {
  let layout;
  let t;
  let if_block_anchor;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$8],
        default: [create_default_slot_1$r]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[2] && create_if_block$21(ctx);
  return {
    c() {
      create_component(layout.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 1048587) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$21(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3X($$self, $$props, $$invalidate) {
  let $user;
  let { params: params2 = null } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(10, $user = value));
  let users = [];
  let nonMembers = [];
  let group;
  let promiseLoad = reload();
  let editingName = false;
  let elUserInput;
  afterUpdate(async () => {
    await promiseLoad;
    window.$(elUserInput).atwho({
      at: "",
      data: nonMembers,
      displayTpl: "<li data-id=${id} data-full_name=${full_name}>${full_name} - ${email}</li>",
      searchKey: "full_name",
      callbacks: {
        beforeInsert: (value, $li) => {
          subscribe2($li.data("id"));
          return "";
        }
      }
    });
  });
  function changeName(e) {
    e.preventDefault();
    $$invalidate(2, editingName = true);
  }
  async function onSaveName() {
    $$invalidate(2, editingName = false);
    await Api.api(`/groups/${group.id}`, "PATCH", { name: group.name });
  }
  async function reload() {
    $$invalidate(1, group = await Api.api(`/groups/${params2.id}`));
    const resUsersGroup = await Api.api(`/groups/${group.id}/users`);
    $$invalidate(0, users = resUsersGroup.data);
    const resUsersAll = await Api.api(`/accounts/users`);
    let usersAll = resUsersAll.data;
    let ids = users.map((u) => u.id);
    nonMembers = usersAll.filter((u) => !ids.includes(u.id));
  }
  async function subscribe2(user_id) {
    try {
      const response = await Api.api(`/groups/${group.id}/subscribe`, "POST", { user_id, admin: false, edit: true });
      await reload();
    } catch (e) {
      console.error(e);
    }
  }
  const click_handler = (e) => history.back();
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elUserInput = $$value;
      $$invalidate(3, elUserInput);
    });
  }
  function input_input_handler() {
    group.name = this.value;
    $$invalidate(1, group);
  }
  const close_handler = (e) => $$invalidate(2, editingName = false);
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(9, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      !!$user.account_id;
    }
  };
  return [
    users,
    group,
    editingName,
    elUserInput,
    promiseLoad,
    changeName,
    onSaveName,
    reload,
    user,
    params2,
    $user,
    click_handler,
    input_binding,
    input_input_handler,
    close_handler
  ];
}
class Team extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3X, create_fragment$45, safe_not_equal, { params: 9 });
  }
}
function create_fragment$44(ctx) {
  let form_1;
  return {
    c() {
      form_1 = element("form");
      form_1.innerHTML = `<i class="fa fa-search p-3"></i> 
  <input name="q" class="flex-grow p-3 border-0 border-l border-solid border-gray-300" type="text" autocomplete="off" placeholder="Search..."/>`;
      attr(form_1, "class", "xsearchbar flex mt1 border border-solid border-bottom-0 border-gray-300");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      ctx[3](form_1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(form_1);
      ctx[3](null);
    }
  };
}
function instance$3W($$self, $$props, $$invalidate) {
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(2, $params = $$value));
  let form;
  let labels = getContext("labels");
  let parent2 = getContext("view:root");
  let view;
  onMount(() => {
    $$invalidate(1, view = new SearchForm({ el: form, parent: parent2, labels }));
    return () => view.remove();
  });
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(0, form);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      view && view.setRouteParams($params);
    }
  };
  return [form, view, $params, form_1_binding];
}
class Search extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3W, create_fragment$44, safe_not_equal, {});
  }
}
const get_title_slot_changes$1 = (dirty) => ({});
const get_title_slot_context$1 = (ctx) => ({});
const get_header_slot_changes$6 = (dirty) => ({});
const get_header_slot_context$6 = (ctx) => ({});
const get_action_slot_changes = (dirty) => ({});
const get_action_slot_context = (ctx) => ({});
function fallback_block_1$2(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$15(ctx) {
  let div;
  let t;
  let button;
  let current;
  const title_slot_template = ctx[7].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[6], get_title_slot_context$1);
  const title_slot_or_fallback = title_slot || fallback_block$7(ctx);
  return {
    c() {
      div = element("div");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      t = space();
      button = element("button");
      attr(button, "type", "button");
      attr(button, "class", "btn-close text-reset");
      attr(button, "data-bs-dismiss", "offcanvas");
      attr(div, "class", "offcanvas-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(div, null);
      }
      append(div, t);
      append(div, button);
      current = true;
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(title_slot_template, ctx2[6], dirty, get_title_slot_changes$1),
            get_title_slot_context$1
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & 9)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block$20(ctx) {
  let current;
  const header_slot_template = ctx[7].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[6], get_header_slot_context$6);
  return {
    c() {
      if (header_slot)
        header_slot.c();
    },
    m(target, anchor) {
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(header_slot_template, ctx2[6], dirty, get_header_slot_changes$6),
            get_header_slot_context$6
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (header_slot)
        header_slot.d(detaching);
    }
  };
}
function fallback_block$7(ctx) {
  let h3;
  let t;
  let h3_class_value;
  return {
    c() {
      h3 = element("h3");
      t = text(ctx[0]);
      attr(h3, "class", h3_class_value = "offcanvas-title " + ctx[3]);
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
      if (dirty & 8 && h3_class_value !== (h3_class_value = "offcanvas-title " + ctx2[3])) {
        attr(h3, "class", h3_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(h3);
    }
  };
}
function create_fragment$43(ctx) {
  let a;
  let a_class_value;
  let t0;
  let div1;
  let current_block_type_index;
  let if_block;
  let t1;
  let div0;
  let div1_class_value;
  let current;
  const action_slot_template = ctx[7].action;
  const action_slot = create_slot(action_slot_template, ctx, ctx[6], get_action_slot_context);
  const action_slot_or_fallback = action_slot || fallback_block_1$2(ctx);
  const if_block_creators = [create_if_block$20, create_else_block$15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5].header)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  return {
    c() {
      a = element("a");
      if (action_slot_or_fallback)
        action_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      if_block.c();
      t1 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(a, "class", a_class_value = "xbtn-primary " + ctx[4]);
      attr(a, "data-bs-toggle", "offcanvas");
      attr(a, "href", "#offcanvasExample");
      attr(div0, "class", "offcanvas-body");
      attr(div1, "class", div1_class_value = "offcanvas " + ctx[2]);
      attr(div1, "tabindex", "-1");
      attr(div1, "id", "offcanvasExample");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (action_slot_or_fallback) {
        action_slot_or_fallback.m(a, null);
      }
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      if_blocks[current_block_type_index].m(div1, null);
      append(div1, t1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(action_slot_template, ctx2[6], dirty, get_action_slot_changes),
            get_action_slot_context
          );
        }
      } else {
        if (action_slot_or_fallback && action_slot_or_fallback.p && (!current || dirty & 2)) {
          action_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 16 && a_class_value !== (a_class_value = "xbtn-primary " + ctx2[4])) {
        attr(a, "class", a_class_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, t1);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4 && div1_class_value !== (div1_class_value = "offcanvas " + ctx2[2])) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(action_slot_or_fallback, local);
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(action_slot_or_fallback, local);
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (action_slot_or_fallback)
        action_slot_or_fallback.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$3V($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { title } = $$props;
  let { label } = $$props;
  let { drawerClasses = "offcanvas-start" } = $$props;
  let { titleClasses = "" } = $$props;
  let { class: classes2 = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("drawerClasses" in $$props2)
      $$invalidate(2, drawerClasses = $$props2.drawerClasses);
    if ("titleClasses" in $$props2)
      $$invalidate(3, titleClasses = $$props2.titleClasses);
    if ("class" in $$props2)
      $$invalidate(4, classes2 = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [title, label, drawerClasses, titleClasses, classes2, $$slots, $$scope, slots];
}
class Drawer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3V, create_fragment$43, safe_not_equal, {
      title: 0,
      label: 1,
      drawerClasses: 2,
      titleClasses: 3,
      class: 4
    });
  }
}
class ClientMsgs extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "url", "/public/clients/messages");
  }
  isEmpty() {
    return this.models.length == 0;
  }
}
class UserMsgs extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "url", "/users/messages");
  }
}
let clientMsgs = new ClientMsgs();
let userMsgs = new UserMsgs([], {
  orderBy: "-ts",
  limit: 25
});
let count = derived(
  [clientMsgs, userMsgs],
  ([$1, $2]) => $1.length + $2.length
);
let flash = derived(
  [clientMsgs, userMsgs],
  ([$1, $2]) => $1.find((m) => m.get("flash")) || $2.find((m) => m.get("flash"))
);
const get_footer_slot_changes = (dirty) => ({});
const get_footer_slot_context = (ctx) => ({});
const get_post_body_slot_changes = (dirty) => ({});
const get_post_body_slot_context = (ctx) => ({});
const get_header_slot_changes$5 = (dirty) => ({});
const get_header_slot_context$5 = (ctx) => ({});
function create_if_block$1$(ctx) {
  let div;
  let t;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = space();
      button = element("button");
      attr(div, "class", "flex-1");
      attr(button, "class", "btn-close text-sm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$42(ctx) {
  let div3;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div2;
  let current;
  const header_slot_template = ctx[3].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[2], get_header_slot_context$5);
  let if_block = ctx[0] && create_if_block$1$(ctx);
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const post_body_slot_template = ctx[3]["post-body"];
  const post_body_slot = create_slot(post_body_slot_template, ctx, ctx[2], get_post_body_slot_context);
  const footer_slot_template = ctx[3].footer;
  const footer_slot = create_slot(footer_slot_template, ctx, ctx[2], get_footer_slot_context);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      if (header_slot)
        header_slot.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (post_body_slot)
        post_body_slot.c();
      t3 = space();
      div2 = element("div");
      if (footer_slot)
        footer_slot.c();
      attr(div0, "class", "card-header flex");
      attr(div1, "class", "card-body flex flex-row");
      attr(div2, "class", "card-footer bg-white");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      if (header_slot) {
        header_slot.m(div0, null);
      }
      append(div0, t0);
      if (if_block)
        if_block.m(div0, null);
      append(div3, t1);
      append(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div3, t2);
      if (post_body_slot) {
        post_body_slot.m(div3, null);
      }
      append(div3, t3);
      append(div3, div2);
      if (footer_slot) {
        footer_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(header_slot_template, ctx2[2], dirty, get_header_slot_changes$5),
            get_header_slot_context$5
          );
        }
      }
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1$(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      if (post_body_slot) {
        if (post_body_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            post_body_slot,
            post_body_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(post_body_slot_template, ctx2[2], dirty, get_post_body_slot_changes),
            get_post_body_slot_context
          );
        }
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(footer_slot_template, ctx2[2], dirty, get_footer_slot_changes),
            get_footer_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(default_slot, local);
      transition_in(post_body_slot, local);
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(default_slot, local);
      transition_out(post_body_slot, local);
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (header_slot)
        header_slot.d(detaching);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      if (post_body_slot)
        post_body_slot.d(detaching);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
}
function instance$3U($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { closable = true } = $$props;
  let dispatch = createEventDispatcher();
  const click_handler = (_2) => dispatch("close");
  $$self.$$set = ($$props2) => {
    if ("closable" in $$props2)
      $$invalidate(0, closable = $$props2.closable);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [closable, dispatch, $$scope, slots, click_handler];
}
class Card extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3U, create_fragment$42, safe_not_equal, { closable: 0 });
  }
}
function get_each_context$_(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_default_slot$1d(ctx) {
  let t_value = ctx[1].body + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].body + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot$l(ctx) {
  let div;
  let t0_value = ctx[1].title + "";
  let t0;
  let t1;
  let small;
  let t2_value = formatTime(ctx[1].ts, true) + "";
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      small = element("small");
      t2 = text(t2_value);
      attr(small, "class", "pl-4 text-gray-400");
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, small);
      append(small, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].title + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = formatTime(ctx2[1].ts, true) + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$_(ctx) {
  let a;
  let t0_value = ctx[3].label + "";
  let t0;
  let t1;
  let a_href_value;
  return {
    c() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "href", a_href_value = ctx[3].link);
      attr(a, "target", "_blank");
      attr(a, "class", "text-center btn btn-default btn-sm capitalize");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[3].label + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && a_href_value !== (a_href_value = ctx2[3].link)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_footer_slot(ctx) {
  let div;
  let each_value = ctx[1].actions;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$_(get_each_context$_(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "slot", "footer");
      attr(div, "class", "flex space-x-2");
      toggle_class(div, "hide", ctx[1].actions.length == 0);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1].actions;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$_(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$_(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        toggle_class(div, "hide", ctx2[1].actions.length == 0);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$41(ctx) {
  let card;
  let current;
  card = new Card({
    props: {
      $$slots: {
        footer: [create_footer_slot],
        header: [create_header_slot$l],
        default: [create_default_slot$1d]
      },
      $$scope: { ctx }
    }
  });
  card.$on("close", ctx[2]);
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const card_changes = {};
      if (dirty & 66) {
        card_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function instance$3T($$self, $$props, $$invalidate) {
  let $message, $$unsubscribe_message = noop, $$subscribe_message = () => ($$unsubscribe_message(), $$unsubscribe_message = subscribe(message, ($$value) => $$invalidate(1, $message = $$value)), message);
  $$self.$$.on_destroy.push(() => $$unsubscribe_message());
  let { message } = $$props;
  $$subscribe_message();
  const close_handler = (e) => message.destroy();
  $$self.$$set = ($$props2) => {
    if ("message" in $$props2)
      $$subscribe_message($$invalidate(0, message = $$props2.message));
  };
  return [message, $message, close_handler];
}
class MessageCard extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3T, create_fragment$41, safe_not_equal, { message: 0 });
  }
}
function get_each_context$Z(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2];
  return child_ctx;
}
function create_catch_block$u(ctx) {
  return { c: noop, m: noop, d: noop };
}
function create_then_block$u(ctx) {
  return { c: noop, m: noop, d: noop };
}
function create_pending_block$u(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$14(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No more message to show.";
      attr(p, "class", "text-2xl text-center");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_each_block$Z(key_1, ctx) {
  let first;
  let card;
  let current;
  card = new MessageCard({ props: { message: ctx[1] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(card.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 1)
        card_changes.message = ctx[1];
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(card, detaching);
    }
  };
}
function create_fragment$40(ctx) {
  let div;
  let promise;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$u,
    then: create_then_block$u,
    catch: create_catch_block$u
  };
  handle_promise(promise = ctx[0].fetchPromise, info);
  let each_value = ctx[0].models;
  const get_key = (ctx2) => ctx2[1].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$Z(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$Z(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$14();
  }
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(div, "class", "d-flex flex-column gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(div, null);
      }
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      info.ctx = ctx;
      dirty & 1 && promise !== (promise = ctx[0].fetchPromise) && handle_promise(promise, info);
      if (dirty & 1) {
        each_value = ctx[0].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$Z, null, get_each_context$Z);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$14();
          each_1_else.c();
          each_1_else.m(div, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$3S($$self, $$props, $$invalidate) {
  let $userMsgs;
  component_subscribe($$self, userMsgs, ($$value) => $$invalidate(0, $userMsgs = $$value));
  return [$userMsgs];
}
class UserMessages extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3S, create_fragment$40, safe_not_equal, {});
  }
}
function get_each_context$Y(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2];
  return child_ctx;
}
function create_each_block$Y(key_1, ctx) {
  let first;
  let card;
  let current;
  card = new MessageCard({ props: { message: ctx[1] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(card.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 1)
        card_changes.message = ctx[1];
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(card, detaching);
    }
  };
}
function create_fragment$3$(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[0].models;
  const get_key = (ctx2) => ctx2[1].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$Y(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$Y(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$Y, each_1_anchor, get_each_context$Y);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance$3R($$self, $$props, $$invalidate) {
  let $clientMsgs;
  component_subscribe($$self, clientMsgs, ($$value) => $$invalidate(0, $clientMsgs = $$value));
  return [$clientMsgs];
}
class ClientMessages extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3R, create_fragment$3$, safe_not_equal, {});
  }
}
function create_action_slot$f(ctx) {
  let i2;
  let t0;
  let span;
  let t1;
  let t2;
  let t3;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      span = element("span");
      t1 = text("(");
      t2 = text(ctx[0]);
      t3 = text(")");
      attr(i2, "class", "fa fa-envelope");
      attr(span, "class", "px-1 text-md font-bold");
      toggle_class(span, "d-none", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t2, ctx2[0]);
      if (dirty & 1) {
        toggle_class(span, "d-none", !ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(i2);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(span);
    }
  };
}
function create_header_slot$k(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<h3>Messages</h3> 
      <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas"></button>`;
      attr(div, "class", "offcanvas-header bg-primary text-white");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$1i(ctx) {
  let clientmessages;
  let current;
  clientmessages = new ClientMessages({});
  return {
    c() {
      create_component(clientmessages.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientmessages, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(clientmessages.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientmessages.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientmessages, detaching);
    }
  };
}
function create_if_block$1_(ctx) {
  let usermessages;
  let current;
  usermessages = new UserMessages({});
  return {
    c() {
      create_component(usermessages.$$.fragment);
    },
    m(target, anchor) {
      mount_component(usermessages, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(usermessages.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(usermessages.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(usermessages, detaching);
    }
  };
}
function create_default_slot$1c(ctx) {
  let t;
  let show_if = ctx[1].isLoggedIn();
  let if_block1_anchor;
  let current;
  let if_block0 = Supports.agents.local && create_if_block_1$1i();
  let if_block1 = show_if && create_if_block$1_();
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_fragment$3_(ctx) {
  let drawer;
  let current;
  drawer = new Drawer({
    props: {
      class: "text-primary text-nowrap",
      drawerClasses: "offcanvas-end",
      $$slots: {
        default: [create_default_slot$1c],
        header: [create_header_slot$k],
        action: [create_action_slot$f]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(drawer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(drawer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const drawer_changes = {};
      if (dirty & 5) {
        drawer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      drawer.$set(drawer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(drawer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(drawer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(drawer, detaching);
    }
  };
}
function instance$3Q($$self, $$props, $$invalidate) {
  let $count;
  component_subscribe($$self, count, ($$value) => $$invalidate(0, $count = $$value));
  const user = getContext("user");
  return [$count, user];
}
class Messages extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Q, create_fragment$3_, safe_not_equal, {});
  }
}
function get_each_context$X(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_if_block$1Z(ctx) {
  let div4;
  let div2;
  let div0;
  let t0_value = formatTime(ctx[1].ts, true) + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ctx[1].body + "";
  let t2;
  let t3;
  let div3;
  let t4;
  let button;
  let mounted;
  let dispose;
  let each_value = ctx[1].actions;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$X(get_each_context$X(ctx, each_value, i2));
  }
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div3 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t4 = space();
      button = element("button");
      button.innerHTML = `<span aria-hidden="true">Dismiss</span>`;
      attr(div0, "class", "text-base");
      attr(div1, "class", "overflow-hidden");
      attr(div2, "class", "flex flex-column");
      attr(button, "class", "btn btn-default btn-sm");
      attr(button, "aria-label", "Close");
      attr(div3, "class", "flex self-center gap-4");
      attr(div4, "class", "alert alert-dismissible mb-0 alert-" + ctx[2]() + " flex justify-between p-2 max-h-[70px]");
      attr(div4, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div3, null);
        }
      }
      append(div3, t4);
      append(div3, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = formatTime(ctx2[1].ts, true) + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = ctx2[1].body + ""))
        set_data(t2, t2_value);
      if (dirty & 2) {
        each_value = ctx2[1].actions;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$X(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$X(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div3, t4);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$X(ctx) {
  let a;
  let t_value = ctx[5].label + "";
  let t;
  let a_href_value;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "class", "text-lg text-center");
      attr(a, "href", a_href_value = ctx[5].link);
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[5].label + ""))
        set_data(t, t_value);
      if (dirty & 2 && a_href_value !== (a_href_value = ctx2[5].link)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_fragment$3Z(ctx) {
  let if_block_anchor;
  let if_block = ctx[0] && create_if_block$1Z(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1Z(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3P($$self, $$props, $$invalidate) {
  let $message, $$unsubscribe_message = noop, $$subscribe_message = () => ($$unsubscribe_message(), $$unsubscribe_message = subscribe(message, ($$value) => $$invalidate(1, $message = $$value)), message);
  let $flash;
  component_subscribe($$self, flash, ($$value) => $$invalidate(3, $flash = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_message());
  let message;
  function getAlertClass() {
    let level = $message.level;
    return level == "error" ? "danger" : level == "warn" ? "warning" : "info";
  }
  const click_handler = (e) => message.destroy();
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $$subscribe_message($$invalidate(0, message = $flash));
    }
  };
  return [message, $message, getAlertClass, $flash, click_handler];
}
class Notification extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3P, create_fragment$3Z, safe_not_equal, {});
  }
}
const get_header_slot_changes$4 = (dirty) => ({});
const get_header_slot_context$4 = (ctx) => ({});
function fallback_block$6(ctx) {
  let div0;
  let t1;
  let div1;
  let t2_value = (ctx[2] ? ctx[2].info || ctx[2].name : "") + "";
  let t2;
  let div1_title_value;
  return {
    c() {
      div0 = element("div");
      div0.textContent = "Watchlist";
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      attr(div0, "class", "fw3 fs-2");
      attr(div1, "class", "fw1 text-sm text-truncate");
      attr(div1, "title", div1_title_value = ctx[2] ? ctx[2].info || ctx[2].name : "");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = (ctx2[2] ? ctx2[2].info || ctx2[2].name : "") + ""))
        set_data(t2, t2_value);
      if (dirty & 4 && div1_title_value !== (div1_title_value = ctx2[2] ? ctx2[2].info || ctx2[2].name : "")) {
        attr(div1, "title", div1_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block$1Y(ctx) {
  let search;
  let current;
  search = new Search({});
  return {
    c() {
      create_component(search.$$.fragment);
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(search, detaching);
    }
  };
}
function create_fragment$3Y(ctx) {
  var _a;
  let notification;
  let t0;
  let div3;
  let div0;
  let t1;
  let div2;
  let t2;
  let div1;
  let t3;
  let a;
  let t5;
  let messages;
  let t6;
  let selector;
  let current;
  notification = new Notification({});
  const header_slot_template = ctx[7].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[6], get_header_slot_context$4);
  const header_slot_or_fallback = header_slot || fallback_block$6(ctx);
  let if_block = ctx[0] && create_if_block$1Y();
  messages = new Messages({});
  selector = new Selector$2({
    props: {
      menuAlign: "right",
      team: (_a = ctx[3]) == null ? void 0 : _a.team
    }
  });
  return {
    c() {
      create_component(notification.$$.fragment);
      t0 = space();
      div3 = element("div");
      div0 = element("div");
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
      t1 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      div1 = element("div");
      t3 = space();
      a = element("a");
      a.textContent = "Get Help";
      t5 = space();
      create_component(messages.$$.fragment);
      t6 = space();
      create_component(selector.$$.fragment);
      attr(div0, "class", "d-flex flex-column relative title-header ttu");
      set_style(div0, "top", "5px");
      set_style(div0, "line-height", "2em");
      attr(div1, "class", "flex-grow");
      attr(a, "class", "btn btn-primary btn-sm xbtn-default mr-2");
      attr(a, "href", "https://distill.io/docs/contact-us/");
      attr(a, "target", "_blank");
      attr(div2, "class", "flex-grow flex items-center border-b border-gray-300");
      set_style(div2, "border-bottom-style", "solid");
      attr(div3, "class", "flex items-center mb-10");
    },
    m(target, anchor) {
      mount_component(notification, target, anchor);
      insert(target, t0, anchor);
      insert(target, div3, anchor);
      append(div3, div0);
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(div0, null);
      }
      append(div3, t1);
      append(div3, div2);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t2);
      append(div2, div1);
      append(div2, t3);
      append(div2, a);
      append(div2, t5);
      mount_component(messages, div2, null);
      append(div2, t6);
      mount_component(selector, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(header_slot_template, ctx2[6], dirty, get_header_slot_changes$4),
            get_header_slot_context$4
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & 4)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (ctx2[0]) {
        if (if_block) {
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1Y();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const selector_changes = {};
      if (dirty & 8)
        selector_changes.team = (_a2 = ctx2[3]) == null ? void 0 : _a2.team;
      selector.$set(selector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notification.$$.fragment, local);
      transition_in(header_slot_or_fallback, local);
      transition_in(if_block);
      transition_in(messages.$$.fragment, local);
      transition_in(selector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notification.$$.fragment, local);
      transition_out(header_slot_or_fallback, local);
      transition_out(if_block);
      transition_out(messages.$$.fragment, local);
      transition_out(selector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notification, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div3);
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      destroy_component(messages);
      destroy_component(selector);
    }
  };
}
function instance$3O($$self, $$props, $$invalidate) {
  let $clients;
  let $client, $$unsubscribe_client = noop, $$subscribe_client = () => ($$unsubscribe_client(), $$unsubscribe_client = subscribe(client, ($$value) => $$invalidate(2, $client = $$value)), client);
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(3, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_client());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { showSearch = true } = $$props;
  let clients = getContext("clients");
  component_subscribe($$self, clients, (value) => $$invalidate(5, $clients = value));
  let client;
  $$self.$$set = ($$props2) => {
    if ("showSearch" in $$props2)
      $$invalidate(0, showSearch = $$props2.showSearch);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      {
        $$subscribe_client($$invalidate(1, client = $clients && clients.get(clients.defaultId)));
      }
    }
  };
  return [showSearch, client, $client, $params, clients, $clients, $$scope, slots];
}
class Topbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3O, create_fragment$3Y, safe_not_equal, { showSearch: 0 });
  }
}
function get_then_context(ctx) {
  ctx[3] = ctx[5][0];
  ctx[4] = ctx[5][1];
}
function create_catch_block$t(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$t(ctx) {
  get_then_context(ctx);
  let div15;
  let div0;
  let t0;
  let a0;
  let t1;
  let t2;
  let t3;
  let table;
  let thead0;
  let t4;
  let thead1;
  let t10;
  let tbody;
  let tr1;
  let td0;
  let t12;
  let td1;
  let div1;
  let t13_value = ctx[3].item + "";
  let t13;
  let t14;
  let td2;
  let div2;
  let t15_value = ctx[4].item + "";
  let t15;
  let t16;
  let tr2;
  let td3;
  let t18;
  let td4;
  let div3;
  let t19_value = ctx[3].run + "";
  let t19;
  let t20;
  let td5;
  let div4;
  let t21_value = ctx[4].run + "";
  let t21;
  let t22;
  let tr3;
  let td6;
  let t24;
  let td7;
  let div5;
  let t25_value = ctx[3].sms + "";
  let t25;
  let t26;
  let td8;
  let div6;
  let t27_value = ctx[4].sms + "";
  let t27;
  let t28;
  let tr4;
  let td9;
  let t30;
  let td10;
  let div7;
  let t31_value = ctx[3].email + "";
  let t31;
  let t32;
  let td11;
  let div8;
  let t33_value = ctx[4].email + "";
  let t33;
  let t34;
  let tr5;
  let td12;
  let t36;
  let td13;
  let div9;
  let t37_value = ctx[3].action + "";
  let t37;
  let t38;
  let td14;
  let div10;
  let t39_value = ctx[4].action + "";
  let t39;
  let t40;
  let tr6;
  let td15;
  let t42;
  let td16;
  let div11;
  let t43_value = ctx[3].push + "";
  let t43;
  let t44;
  let td17;
  let div12;
  let t45_value = ctx[4].push + "";
  let t45;
  let t46;
  let div14;
  return {
    c() {
      div15 = element("div");
      div0 = element("div");
      t0 = text("Resource usage based on your ");
      a0 = element("a");
      t1 = text("current plan");
      t2 = text(".");
      t3 = space();
      table = element("table");
      thead0 = element("thead");
      t4 = space();
      thead1 = element("thead");
      thead1.innerHTML = `<tr><th scope="col">Resource</th> 
        <th scope="col">Quantity</th> 
        <th scope="col">Usage</th></tr>`;
      t10 = space();
      tbody = element("tbody");
      tr1 = element("tr");
      td0 = element("td");
      td0.textContent = "Monitors";
      t12 = space();
      td1 = element("td");
      div1 = element("div");
      t13 = text(t13_value);
      t14 = space();
      td2 = element("td");
      div2 = element("div");
      t15 = text(t15_value);
      t16 = space();
      tr2 = element("tr");
      td3 = element("td");
      td3.textContent = "Checks";
      t18 = space();
      td4 = element("td");
      div3 = element("div");
      t19 = text(t19_value);
      t20 = space();
      td5 = element("td");
      div4 = element("div");
      t21 = text(t21_value);
      t22 = space();
      tr3 = element("tr");
      td6 = element("td");
      td6.textContent = "SMSes";
      t24 = space();
      td7 = element("td");
      div5 = element("div");
      t25 = text(t25_value);
      t26 = space();
      td8 = element("td");
      div6 = element("div");
      t27 = text(t27_value);
      t28 = space();
      tr4 = element("tr");
      td9 = element("td");
      td9.textContent = "Emails";
      t30 = space();
      td10 = element("td");
      div7 = element("div");
      t31 = text(t31_value);
      t32 = space();
      td11 = element("td");
      div8 = element("div");
      t33 = text(t33_value);
      t34 = space();
      tr5 = element("tr");
      td12 = element("td");
      td12.textContent = "Actions (webhooks)";
      t36 = space();
      td13 = element("td");
      div9 = element("div");
      t37 = text(t37_value);
      t38 = space();
      td14 = element("td");
      div10 = element("div");
      t39 = text(t39_value);
      t40 = space();
      tr6 = element("tr");
      td15 = element("td");
      td15.textContent = "Push";
      t42 = space();
      td16 = element("td");
      div11 = element("div");
      t43 = text(t43_value);
      t44 = space();
      td17 = element("td");
      div12 = element("div");
      t45 = text(t45_value);
      t46 = space();
      div14 = element("div");
      div14.innerHTML = `Checks made using browser extensions are unlimited and not counted. <a href="https://distill.io/docs/web-monitor/cloud-local-monitors/">Learn More</a> 
    <div>In cloud, checks are counted in units of 7 seconds. If a check takes upto 7s, it is counted as
      one. If it takes more than 7s and less than 15s, it is counted as two.</div>`;
      attr(a0, "href", urlCfg.billing);
      attr(div0, "class", "ml-1 fs-5 pb-3 bg-light");
      attr(div1, "class", "xitem");
      attr(div2, "class", "xitem");
      attr(div3, "class", "xcheck");
      attr(div4, "class", "xcheck");
      attr(div5, "class", "xsms");
      attr(div6, "class", "xsms");
      attr(div7, "class", "xemail");
      attr(div8, "class", "xemail");
      attr(div9, "class", "xaction");
      attr(div10, "class", "xaction");
      attr(div11, "class", "xpush");
      attr(div12, "class", "xpush");
      attr(table, "class", "table table-bordered xblock xblock-thin");
      attr(div14, "class", "xblock");
      attr(div15, "id", "availability");
    },
    m(target, anchor) {
      insert(target, div15, anchor);
      append(div15, div0);
      append(div0, t0);
      append(div0, a0);
      append(a0, t1);
      append(div0, t2);
      append(div15, t3);
      append(div15, table);
      append(table, thead0);
      append(table, t4);
      append(table, thead1);
      append(table, t10);
      append(table, tbody);
      append(tbody, tr1);
      append(tr1, td0);
      append(tr1, t12);
      append(tr1, td1);
      append(td1, div1);
      append(div1, t13);
      append(tr1, t14);
      append(tr1, td2);
      append(td2, div2);
      append(div2, t15);
      append(tbody, t16);
      append(tbody, tr2);
      append(tr2, td3);
      append(tr2, t18);
      append(tr2, td4);
      append(td4, div3);
      append(div3, t19);
      append(tr2, t20);
      append(tr2, td5);
      append(td5, div4);
      append(div4, t21);
      append(tbody, t22);
      append(tbody, tr3);
      append(tr3, td6);
      append(tr3, t24);
      append(tr3, td7);
      append(td7, div5);
      append(div5, t25);
      append(tr3, t26);
      append(tr3, td8);
      append(td8, div6);
      append(div6, t27);
      append(tbody, t28);
      append(tbody, tr4);
      append(tr4, td9);
      append(tr4, t30);
      append(tr4, td10);
      append(td10, div7);
      append(div7, t31);
      append(tr4, t32);
      append(tr4, td11);
      append(td11, div8);
      append(div8, t33);
      append(tbody, t34);
      append(tbody, tr5);
      append(tr5, td12);
      append(tr5, t36);
      append(tr5, td13);
      append(td13, div9);
      append(div9, t37);
      append(tr5, t38);
      append(tr5, td14);
      append(td14, div10);
      append(div10, t39);
      append(tbody, t40);
      append(tbody, tr6);
      append(tr6, td15);
      append(tr6, t42);
      append(tr6, td16);
      append(td16, div11);
      append(div11, t43);
      append(tr6, t44);
      append(tr6, td17);
      append(td17, div12);
      append(div12, t45);
      append(div15, t46);
      append(div15, div14);
    },
    p(ctx2, dirty) {
      get_then_context(ctx2);
    },
    d(detaching) {
      if (detaching)
        detach(div15);
    }
  };
}
function create_pending_block$t(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$3X(ctx) {
  let await_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$t,
    then: create_then_block$t,
    catch: create_catch_block$t,
    value: 5
  };
  handle_promise(ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function getTsMonthQuery() {
  const date = new Date();
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  return `${year}-${month}-1`;
}
function instance$3N($$self) {
  let api = getContext("api");
  async function getMonthlyUsage() {
    let usage = {
      item: 0,
      run: 0,
      sms: 0,
      email: 0,
      action: 0,
      push: 0
    };
    const res = await api(`/users/usage/monthly?ts_month=${getTsMonthQuery()}`);
    if (res.count !== 0) {
      usage = res.data[0];
    }
    const { count: count2 } = await api("/users/sieve-count");
    usage.item = count2;
    return usage;
  }
  const resPromise = Promise.all([api("/users/constraints"), getMonthlyUsage()]);
  return [resPromise];
}
class Avail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3N, create_fragment$3X, safe_not_equal, {});
  }
}
function get_each_context$W(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function get_each_context_1$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_catch_block$s(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$s(ctx) {
  let table;
  let thead;
  let t11;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ctx[4].data;
  const get_key = (ctx2) => ctx2[5].ts;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$W(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$W(key, child_ctx));
  }
  return {
    c() {
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th>Date</th> 
      <th>Checks</th> 
      <th>Emails</th> 
      <th>SMSes</th> 
      <th>Webhooks</th> 
      <th>Push</th></tr>`;
      t11 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(table, "id", "daily");
      attr(table, "class", "table table-bordered xblock xblock-thin");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, thead);
      append(table, t11);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[4].data;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, destroy_block, create_each_block$W, null, get_each_context$W);
      }
    },
    d(detaching) {
      if (detaching)
        detach(table);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_each_block_1$9(ctx) {
  let td;
  let div;
  let t_value = ctx[5][ctx[8]] + "";
  let t;
  return {
    c() {
      td = element("td");
      div = element("div");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, div);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[5][ctx2[8]] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_each_block$W(key_1, ctx) {
  let tr;
  let t;
  let each_value_1 = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$9(get_each_context_1$9(ctx, each_value_1, i2));
  }
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tr, null);
        }
      }
      append(tr, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 3) {
        each_value_1 = ctx[1];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$9(ctx, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$9(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tr, t);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_pending_block$s(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$3W(ctx) {
  let await_block_anchor;
  let promise;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$s,
    then: create_then_block$s,
    catch: create_catch_block$s,
    value: 4
  };
  handle_promise(promise = ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 1 && promise !== (promise = ctx[0]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$3M($$self, $$props, $$invalidate) {
  let { cycle } = $$props;
  let api = getContext("api");
  let resPromise;
  const NAMES = ["ts", "run", "email", "sms", "action", "push"];
  $$self.$$set = ($$props2) => {
    if ("cycle" in $$props2)
      $$invalidate(2, cycle = $$props2.cycle);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(0, resPromise = api("/users/usage/" + cycle, "GET"));
    }
  };
  return [resPromise, NAMES, cycle];
}
class Usage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3M, create_fragment$3W, safe_not_equal, { cycle: 2 });
  }
}
class Job$1 extends base.Model {
}
class Jobs extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "model", Job$1);
    __publicField(this, "url", "/jobs");
    __publicField(this, "limit", 20);
  }
}
function get_each_context$V(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function create_if_block$1X(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ctx[3];
  const get_key = (ctx2) => ctx2[13];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$V(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$V(key, child_ctx));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "dropdown-menu dropdown-menu-right overflow-scroll max-h-[60vh]");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 43) {
        each_value = ctx2[3];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block$V, null, get_each_context$V);
      }
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_each_block$V(key_1, ctx) {
  let li;
  let a;
  let t0_value = ctx[5](ctx[13]) + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[7](ctx[13], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", "dropdown-item");
      attr(a, "href", href$2);
      toggle_class(li, "active", ctx[1].offset === ctx[13] * ctx[1].limit);
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && t0_value !== (t0_value = ctx[5](ctx[13]) + ""))
        set_data(t0, t0_value);
      if (dirty & 10) {
        toggle_class(li, "active", ctx[1].offset === ctx[13] * ctx[1].limit);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3V(ctx) {
  let ul;
  let li0;
  let a0;
  let t0;
  let t1;
  let i0;
  let t2;
  let t3;
  let li1;
  let a1;
  let i1;
  let t4;
  let li2;
  let a2;
  let i2;
  let mounted;
  let dispose;
  let if_block = ctx[3].length && create_if_block$1X(ctx);
  return {
    c() {
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      t0 = text(ctx[4]);
      t1 = space();
      i0 = element("i");
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      li1 = element("li");
      a1 = element("a");
      i1 = element("i");
      t4 = space();
      li2 = element("li");
      a2 = element("a");
      i2 = element("i");
      attr(i0, "class", "fa fa-caret-down");
      attr(a0, "href", href$2);
      attr(a0, "class", "text-secondary-emphasis whitespace-nowrap page-link");
      attr(a0, "data-bs-toggle", "dropdown");
      attr(li0, "class", "page-item");
      attr(i1, "class", "fa fa-chevron-left");
      attr(a1, "class", "page-link");
      attr(a1, "href", href$2);
      attr(li1, "class", "page-item");
      toggle_class(li1, "disabled", !ctx[2].hasPrev());
      attr(i2, "class", "fa fa-chevron-right");
      attr(a2, "class", "page-link");
      attr(a2, "href", href$2);
      attr(li2, "class", "page-item");
      toggle_class(li2, "disabled", !ctx[2].hasNext());
      attr(ul, "class", "pagination pagination-sm dropdown align-items-center");
      set_style(ul, "margin", "0 5px 0 0");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      append(ul, li0);
      append(li0, a0);
      append(a0, t0);
      append(a0, t1);
      append(a0, i0);
      append(li0, t2);
      if (if_block)
        if_block.m(li0, null);
      append(ul, t3);
      append(ul, li1);
      append(li1, a1);
      append(a1, i1);
      append(ul, t4);
      append(ul, li2);
      append(li2, a2);
      append(a2, i2);
      if (!mounted) {
        dispose = [
          listen(a1, "click", prevent_default(ctx[8])),
          listen(a2, "click", prevent_default(ctx[9]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 16)
        set_data(t0, ctx2[4]);
      if (ctx2[3].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1X(ctx2);
          if_block.c();
          if_block.m(li0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 4) {
        toggle_class(li1, "disabled", !ctx2[2].hasPrev());
      }
      if (dirty & 4) {
        toggle_class(li2, "disabled", !ctx2[2].hasNext());
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(ul);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const href$2 = "";
function instance$3L($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store2, ($$value) => $$invalidate(2, $store = $$value)), store2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { name = "list-nav" } = $$props;
  let { store: store2 } = $$props;
  $$subscribe_store();
  let info = {};
  let pages = [];
  let currentRange = "0-0";
  function setCurrentRange() {
    let { count: count2, offset, total_count, limit: limit2 } = info;
    $$invalidate(4, currentRange = `${offset + (count2 > 0 ? 1 : 0)} - ${Math.min(offset + limit2, total_count)} of ${total_count}`);
  }
  function getRange(index2) {
    let { limit: limit2, total_count } = info;
    const offset = limit2 * index2;
    return `${offset + 1} - ${Math.min(offset + limit2, total_count)}`;
  }
  const click_handler = (i2, e) => store2.goto(i2);
  const click_handler_1 = (e) => store2.onPrev();
  const click_handler_2 = (e) => store2.onNext();
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(6, name = $$props2.name);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(0, store2 = $$props2.store));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      {
        $$invalidate(1, info = $store.info());
        $$invalidate(3, pages = Array(info.nPages));
        setCurrentRange();
      }
    }
  };
  return [
    store2,
    info,
    $store,
    pages,
    currentRange,
    getRange,
    name,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class ListPager extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3L, create_fragment$3V, safe_not_equal, { name: 6, store: 0 });
  }
}
function get_each_context$U(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$U(ctx) {
  let li;
  let a;
  let t0_value = ctx[4].label + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[3](ctx[4], ...args);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", "dropdown-item");
      attr(a, "href", href$1);
      toggle_class(a, "active", ctx[4].value == ctx[2]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = ctx[4].label + ""))
        set_data(t0, t0_value);
      if (dirty & 6) {
        toggle_class(a, "active", ctx[4].value == ctx[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3U(ctx) {
  let ul1;
  let li;
  let a;
  let i2;
  let i_class_value;
  let t;
  let ul0;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$U(get_each_context$U(ctx, each_value, i3));
  }
  return {
    c() {
      ul1 = element("ul");
      li = element("li");
      a = element("a");
      i2 = element("i");
      t = space();
      ul0 = element("ul");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      attr(i2, "class", i_class_value = "fa fa-sort-amount-" + (ctx[2][0] == "-" ? "desc" : "asc"));
      attr(a, "href", href$1);
      attr(a, "class", "dropdown-toggle btn btn-default btn-sm");
      attr(a, "data-bs-toggle", "dropdown");
      attr(ul0, "class", "dropdown-menu dropdown-menu-end");
      attr(ul1, "class", "pagination pagination-sm dropdown");
      set_style(ul1, "margin", "0 5px 0 0");
    },
    m(target, anchor) {
      insert(target, ul1, anchor);
      append(ul1, li);
      append(li, a);
      append(a, i2);
      append(li, t);
      append(li, ul0);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(ul0, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && i_class_value !== (i_class_value = "fa fa-sort-amount-" + (ctx2[2][0] == "-" ? "desc" : "asc"))) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & 7) {
        each_value = ctx2[1];
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$U(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
          } else {
            each_blocks[i3] = create_each_block$U(child_ctx);
            each_blocks[i3].c();
            each_blocks[i3].m(ul0, null);
          }
        }
        for (; i3 < each_blocks.length; i3 += 1) {
          each_blocks[i3].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(ul1);
      destroy_each(each_blocks, detaching);
    }
  };
}
let href$1 = "";
function instance$3K($$self, $$props, $$invalidate) {
  let { onSort } = $$props;
  let { sortingFields } = $$props;
  let { currentFieldName } = $$props;
  const click_handler = (field, e) => onSort(field.value);
  $$self.$$set = ($$props2) => {
    if ("onSort" in $$props2)
      $$invalidate(0, onSort = $$props2.onSort);
    if ("sortingFields" in $$props2)
      $$invalidate(1, sortingFields = $$props2.sortingFields);
    if ("currentFieldName" in $$props2)
      $$invalidate(2, currentFieldName = $$props2.currentFieldName);
  };
  return [onSort, sortingFields, currentFieldName, click_handler];
}
class SortBy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3K, create_fragment$3U, safe_not_equal, {
      onSort: 0,
      sortingFields: 1,
      currentFieldName: 2
    });
  }
}
function create_fragment$3T(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "xindeterminate");
      attr(div1, "class", div1_class_value = "xprogress " + ctx[0]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && div1_class_value !== (div1_class_value = "xprogress " + ctx2[0])) {
        attr(div1, "class", div1_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function instance$3J($$self, $$props, $$invalidate) {
  let { class: clazz = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
  };
  return [clazz];
}
class Loader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3J, create_fragment$3T, safe_not_equal, { class: 0 });
  }
}
function get_each_context$T(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_if_block_7$5(ctx) {
  let a;
  let t_value = ctx[3].sieve_name + "";
  let t;
  let a_href_value;
  let a_title_value;
  return {
    c() {
      var _a;
      a = element("a");
      t = text(t_value);
      attr(a, "target", "_blank");
      attr(a, "href", a_href_value = `${urlCfg.app}/#/w/${(_a = ctx[4]) == null ? void 0 : _a.team}/sieve/detail/${ctx[3].sieve_id}.id`);
      attr(a, "title", a_title_value = ctx[3].sieve_name);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      var _a;
      if (dirty & 8 && t_value !== (t_value = ctx2[3].sieve_name + ""))
        set_data(t, t_value);
      if (dirty & 24 && a_href_value !== (a_href_value = `${urlCfg.app}/#/w/${(_a = ctx2[4]) == null ? void 0 : _a.team}/sieve/detail/${ctx2[3].sieve_id}.id`)) {
        attr(a, "href", a_href_value);
      }
      if (dirty & 8 && a_title_value !== (a_title_value = ctx2[3].sieve_name)) {
        attr(a, "title", a_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_else_block_2$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Success";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$1W(ctx) {
  let div3;
  let a;
  let t0_value = ctx[2].message + "";
  let t0;
  let span0;
  let t1;
  let div2;
  let div0;
  let t3;
  let div1;
  let label;
  let t5;
  let span1;
  let t6_value = (ctx[2].message || "NA") + "";
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2].attemptsMade)
      return create_if_block_6$9;
    return create_else_block_1$f;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[2].statusCode && create_if_block_5$i(ctx);
  let if_block2 = ctx[2].body && create_if_block_4$r(ctx);
  let if_block3 = ctx[2].cause && create_if_block_1$1h(ctx);
  return {
    c() {
      div3 = element("div");
      a = element("a");
      t0 = text(t0_value);
      span0 = element("span");
      span0.innerHTML = `<i class="xcaret fa fa-caret-down"></i>`;
      t1 = space();
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Error Details";
      t3 = space();
      div1 = element("div");
      label = element("label");
      label.textContent = "Message:";
      t5 = space();
      span1 = element("span");
      t6 = text(t6_value);
      t7 = space();
      if_block0.c();
      t8 = space();
      if (if_block1)
        if_block1.c();
      t9 = space();
      if (if_block2)
        if_block2.c();
      t10 = space();
      if (if_block3)
        if_block3.c();
      attr(span0, "class", "ml1");
      attr(a, "title", "Click to view the error details");
      attr(a, "class", "pointer");
      attr(a, "data-bs-toggle", "dropdown");
      attr(a, "aria-haspopup", "true");
      attr(a, "aria-expanded", "false");
      toggle_class(a, "red", ctx[5]);
      attr(div0, "class", "gray f5 lh-copy");
      attr(div2, "class", "dropdown-menu dropdown-menu-end pa2");
      attr(div3, "class", "dropdown clearfix");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, a);
      append(a, t0);
      append(a, span0);
      append(div3, t1);
      append(div3, div2);
      append(div2, div0);
      append(div2, t3);
      append(div2, div1);
      append(div1, label);
      append(div1, t5);
      append(div1, span1);
      append(span1, t6);
      append(div2, t7);
      if_block0.m(div2, null);
      append(div2, t8);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t9);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t10);
      if (if_block3)
        if_block3.m(div2, null);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[2].message + ""))
        set_data(t0, t0_value);
      if (dirty & 4 && t6_value !== (t6_value = (ctx2[2].message || "NA") + ""))
        set_data(t6, t6_value);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div2, t8);
        }
      }
      if (ctx2[2].statusCode) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$i(ctx2);
          if_block1.c();
          if_block1.m(div2, t9);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[2].body) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_4$r(ctx2);
          if_block2.c();
          if_block2.m(div2, t10);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[2].cause) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_1$1h(ctx2);
          if_block3.c();
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
}
function create_else_block_1$f(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<label>Attempts:</label> 
              <span>1</span>`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_6$9(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[2].attemptsMade + 1 + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Attempts:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = ctx2[2].attemptsMade + 1 + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_5$i(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[2].statusCode + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Status Code:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = ctx2[2].statusCode + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$r(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[2].body + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Body:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = ctx2[2].body + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$1h(ctx) {
  let div;
  let t1;
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (typeof ctx2[2].cause === "string")
      return create_if_block_2$T;
    return create_else_block$13;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      div.textContent = "Cause";
      t1 = space();
      if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "gray f5 lh-copy");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$13(ctx) {
  let each_1_anchor;
  let each_value = Object.keys(ctx[2].cause);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$T(get_each_context$T(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        each_value = Object.keys(ctx2[2].cause);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$T(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$T(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2$T(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[2].cause + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Message:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = ctx2[2].cause + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$G(ctx) {
  let div;
  let label;
  let t0_value = ctx[6] + "";
  let t0;
  let t1;
  let t2;
  let span;
  let t3_value = (typeof ctx[2].cause[ctx[6]] === "string" ? ctx[2].cause[ctx[6]] : JSON.stringify(ctx[2].cause[ctx[6]])) + "";
  let t3;
  let t4;
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = text(":");
      t2 = space();
      span = element("span");
      t3 = text(t3_value);
      t4 = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      append(div, span);
      append(span, t3);
      append(div, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[6] + ""))
        set_data(t0, t0_value);
      if (dirty & 4 && t3_value !== (t3_value = (typeof ctx2[2].cause[ctx2[6]] === "string" ? ctx2[2].cause[ctx2[6]] : JSON.stringify(ctx2[2].cause[ctx2[6]])) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$T(ctx) {
  let if_block_anchor;
  let if_block = ctx[6] !== "stack" && create_if_block_3$G(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[6] !== "stack") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$G(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$3S(ctx) {
  let tr;
  let td0;
  let div0;
  let t0_value = toISOString(ctx[3].ts) + "";
  let t0;
  let t1;
  let td1;
  let t2;
  let td2;
  let div1;
  let t3_value = ctx[3].category + "";
  let t3;
  let t4;
  let td3;
  let div2;
  let t5_value = ctx[1].get(ctx[3].type) + "";
  let t5;
  let t6;
  let td4;
  let if_block0 = ctx[3].sieve_id && create_if_block_7$5(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return create_if_block$1W;
    return create_else_block_2$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      if (if_block0)
        if_block0.c();
      t2 = space();
      td2 = element("td");
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      td3 = element("td");
      div2 = element("div");
      t5 = text(t5_value);
      t6 = space();
      td4 = element("td");
      if_block1.c();
      attr(td1, "class", "mw5 truncate");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, div0);
      append(div0, t0);
      append(tr, t1);
      append(tr, td1);
      if (if_block0)
        if_block0.m(td1, null);
      append(tr, t2);
      append(tr, td2);
      append(td2, div1);
      append(div1, t3);
      append(tr, t4);
      append(tr, td3);
      append(td3, div2);
      append(div2, t5);
      append(tr, t6);
      append(tr, td4);
      if_block1.m(td4, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 8 && t0_value !== (t0_value = toISOString(ctx2[3].ts) + ""))
        set_data(t0, t0_value);
      if (ctx2[3].sieve_id) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_7$5(ctx2);
          if_block0.c();
          if_block0.m(td1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 8 && t3_value !== (t3_value = ctx2[3].category + ""))
        set_data(t3, t3_value);
      if (dirty & 10 && t5_value !== (t5_value = ctx2[1].get(ctx2[3].type) + ""))
        set_data(t5, t5_value);
      if_block1.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
}
function instance$3I($$self, $$props, $$invalidate) {
  let $job, $$unsubscribe_job = noop, $$subscribe_job = () => ($$unsubscribe_job(), $$unsubscribe_job = subscribe(job, ($$value) => $$invalidate(3, $job = $$value)), job);
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(4, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_job());
  let { job } = $$props;
  $$subscribe_job();
  let { jobTypesMap } = $$props;
  let { errorObj = $job.err } = $$props;
  let hasError = !!errorObj;
  $$self.$$set = ($$props2) => {
    if ("job" in $$props2)
      $$subscribe_job($$invalidate(0, job = $$props2.job));
    if ("jobTypesMap" in $$props2)
      $$invalidate(1, jobTypesMap = $$props2.jobTypesMap);
    if ("errorObj" in $$props2)
      $$invalidate(2, errorObj = $$props2.errorObj);
  };
  return [job, jobTypesMap, errorObj, $job, $params, hasError];
}
class Log$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3I, create_fragment$3S, safe_not_equal, { job: 0, jobTypesMap: 1, errorObj: 2 });
  }
}
const { Map: Map_1 } = globals;
function get_each_context$S(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  return child_ctx;
}
function get_each_context_1$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  return child_ctx;
}
function create_each_block_1$8(ctx) {
  let option;
  let t_value = ctx[15].name + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[15].value;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_catch_block$r(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$r(ctx) {
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let each_1_anchor;
  let current;
  let each_value = ctx[2].models;
  const get_key = (ctx2) => ctx2[12].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$S(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$S(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$12();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 36) {
        each_value = ctx2[2].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$S, each_1_anchor, get_each_context$S);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$12();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_else_block$12(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No jobs were found.</td> 
        `;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$S(key_1, ctx) {
  let first;
  let job;
  let current;
  job = new Log$1({
    props: {
      job: ctx[12],
      jobTypesMap: ctx[5]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(job.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(job, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const job_changes = {};
      if (dirty & 4)
        job_changes.job = ctx[12];
      job.$set(job_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(job.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(job.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(job, detaching);
    }
  };
}
function create_pending_block$r(ctx) {
  let td;
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      td = element("td");
      create_component(loader.$$.fragment);
      attr(td, "colspan", "5");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      mount_component(loader, td, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      destroy_component(loader);
    }
  };
}
function create_fragment$3R(ctx) {
  let div3;
  let div2;
  let div0;
  let t3;
  let div1;
  let select;
  let option;
  let t5;
  let listpager;
  let t6;
  let sortby;
  let t7;
  let table;
  let thead;
  let t15;
  let tbody;
  let promise;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ctx[4];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i2));
  }
  listpager = new ListPager({ props: { store: ctx[1] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[7],
      sortingFields: ctx[3],
      currentFieldName: ctx[2].orderBy
    }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$r,
    then: create_then_block$r,
    catch: create_catch_block$r,
    value: 11,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[2].fetchPromise, info);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>Logs</h3> 
      <h6>This section contains the log of all actions. It includes change alerts as well as verification messages.</h6>`;
      t3 = space();
      div1 = element("div");
      select = element("select");
      option = element("option");
      option.textContent = "All(Job Types)";
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t5 = space();
      create_component(listpager.$$.fragment);
      t6 = space();
      create_component(sortby.$$.fragment);
      t7 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th style="width: 50%;" colspan="2">Date</th> 
      <th>Category</th> 
      <th>Type</th> 
      <th>Status</th></tr>`;
      t15 = space();
      tbody = element("tbody");
      info.block.c();
      set_style(div0, "flex", "1");
      option.__value = "all";
      option.value = option.__value;
      attr(select, "id", "job-type-selection");
      attr(select, "class", "pa1 btn-sm");
      attr(select, "title", "Select Job Types");
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[8].call(select));
      attr(div1, "class", "mb0 pa1");
      attr(div2, "class", "card-header flex items-center");
      attr(table, "class", "table");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t3);
      append(div2, div1);
      append(div1, select);
      append(select, option);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[0], true);
      append(div2, t5);
      mount_component(listpager, div2, null);
      append(div2, t6);
      mount_component(sortby, div2, null);
      append(div3, t7);
      append(div3, table);
      append(table, thead);
      append(table, t15);
      append(table, tbody);
      info.block.m(tbody, info.anchor = null);
      info.mount = () => tbody;
      info.anchor = null;
      current = true;
      if (!mounted) {
        dispose = [
          listen(select, "change", ctx[8]),
          listen(select, "change", ctx[9])
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & 16) {
        each_value_1 = ctx[4];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$8(ctx, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$8(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & 17) {
        select_option(select, ctx[0]);
      }
      const listpager_changes = {};
      if (dirty & 2)
        listpager_changes.store = ctx[1];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 4)
        sortby_changes.currentFieldName = ctx[2].orderBy;
      sortby.$set(sortby_changes);
      info.ctx = ctx;
      if (dirty & 4 && promise !== (promise = ctx[2].fetchPromise) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      destroy_component(listpager);
      destroy_component(sortby);
      info.block.d();
      info.token = null;
      info = null;
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3H($$self, $$props, $$invalidate) {
  let $store;
  getContext("api");
  let selectedJobType = "all";
  let sortingFields = [
    { value: "-ts", label: "Newest First" },
    { value: "ts", label: "Oldest First" }
  ];
  const jobTypes = [
    {
      name: "Macro Action",
      value: "action_macro"
    },
    {
      name: "Webhook Action",
      value: "action_webhook"
    },
    {
      name: "Push Action",
      value: "action_push"
    },
    {
      name: "Discord Action",
      value: "action_discord"
    },
    { name: "Email", value: "email" },
    { name: "SMS", value: "sms" },
    { name: "Slack", value: "action_slack" }
  ];
  const jobTypesMap = new Map(jobTypes.map((i2) => [i2.value, i2.name]));
  let store2 = getContext("store");
  component_subscribe($$self, store2, (value) => $$invalidate(2, $store = value));
  store2.setQuery({ "state": 0 });
  async function onJobTypeChange(e) {
    const query = { "state": 0 };
    if (selectedJobType !== "all") {
      query.type = selectedJobType;
    }
    store2.setQuery(query);
    return await store2.goto(0, { reset: true });
  }
  async function onSort(by) {
    $$invalidate(1, store2.orderBy = by, store2);
    await store2.fetch({ reset: true });
  }
  function select_change_handler() {
    selectedJobType = select_value(this);
    $$invalidate(0, selectedJobType);
    $$invalidate(4, jobTypes);
  }
  const change_handler = (e) => onJobTypeChange();
  return [
    selectedJobType,
    store2,
    $store,
    sortingFields,
    jobTypes,
    jobTypesMap,
    onJobTypeChange,
    onSort,
    select_change_handler,
    change_handler
  ];
}
class List$9 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3H, create_fragment$3R, safe_not_equal, {});
  }
}
function create_fragment$3Q(ctx) {
  let list;
  let current;
  list = new List$9({});
  return {
    c() {
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function instance$3G($$self, $$props, $$invalidate) {
  let { api = getContext("api") } = $$props;
  let { user = getContext("user") } = $$props;
  let store2 = new Jobs([], { orderBy: "-ts" });
  store2.setQuery({ state: "0" });
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  $$self.$$set = ($$props2) => {
    if ("api" in $$props2)
      $$invalidate(0, api = $$props2.api);
    if ("user" in $$props2)
      $$invalidate(1, user = $$props2.user);
  };
  return [api, user];
}
class Logs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3G, create_fragment$3Q, safe_not_equal, { api: 0, user: 1 });
  }
}
function create_if_block$1V(ctx) {
  let previous_key = ctx[0];
  let key_block_anchor;
  let current;
  let key_block = create_key_block$2(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$2(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_if_block_3$F(ctx) {
  let usage;
  let current;
  usage = new Usage({ props: { cycle: ctx[2] } });
  return {
    c() {
      create_component(usage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(usage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const usage_changes = {};
      if (dirty & 4)
        usage_changes.cycle = ctx2[2];
      usage.$set(usage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(usage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(usage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(usage, detaching);
    }
  };
}
function create_if_block_2$S(ctx) {
  let log;
  let current;
  log = new Logs({});
  return {
    c() {
      create_component(log.$$.fragment);
    },
    m(target, anchor) {
      mount_component(log, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(log.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(log.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(log, detaching);
    }
  };
}
function create_if_block_1$1g(ctx) {
  let avail;
  let current;
  avail = new Avail({});
  return {
    c() {
      create_component(avail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(avail, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(avail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(avail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(avail, detaching);
    }
  };
}
function create_key_block$2(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_1$1g, create_if_block_2$S, create_if_block_3$F];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2] === "availability")
      return 0;
    if (ctx2[2] === "logs")
      return 1;
    if (ctx2[2] === "daily" || ctx2[2] === "monthly")
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "col-sm-9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_default_slot$1b(ctx) {
  let div2;
  let div1;
  let div0;
  let ul;
  let a0;
  let t0;
  let i0;
  let a0_href_value;
  let t1;
  let a1;
  let t2;
  let i1;
  let a1_href_value;
  let t3;
  let a2;
  let t4;
  let i2;
  let a2_href_value;
  let t5;
  let a3;
  let t6;
  let i3;
  let a3_href_value;
  let t7;
  let current;
  let if_block = ctx[1] && create_if_block$1V(ctx);
  return {
    c() {
      var _a, _b, _c, _d;
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      ul = element("ul");
      a0 = element("a");
      t0 = text("Available Resources");
      i0 = element("i");
      t1 = space();
      a1 = element("a");
      t2 = text("Daily Usage");
      i1 = element("i");
      t3 = space();
      a2 = element("a");
      t4 = text("Monthly Usage");
      i2 = element("i");
      t5 = space();
      a3 = element("a");
      t6 = text("Logs");
      i3 = element("i");
      t7 = space();
      if (if_block)
        if_block.c();
      attr(i0, "class", "fa fa-chevron-right right");
      attr(a0, "href", a0_href_value = "#/u/" + ((_a = ctx[1]) == null ? void 0 : _a.team) + "/usage/availability/");
      attr(a0, "class", "list-group-item");
      toggle_class(a0, "active", ctx[2] === "availability");
      attr(i1, "class", "fa fa-chevron-right right");
      attr(a1, "href", a1_href_value = "#/u/" + ((_b = ctx[1]) == null ? void 0 : _b.team) + "/usage/daily/");
      attr(a1, "class", "list-group-item");
      toggle_class(a1, "active", ctx[2] === "daily");
      attr(i2, "class", "fa fa-chevron-right right");
      attr(a2, "href", a2_href_value = "#/u/" + ((_c = ctx[1]) == null ? void 0 : _c.team) + "/usage/monthly/");
      attr(a2, "class", "list-group-item");
      toggle_class(a2, "active", ctx[2] === "monthly");
      attr(i3, "class", "fa fa-chevron-right right");
      attr(a3, "href", a3_href_value = "#/u/" + ((_d = ctx[1]) == null ? void 0 : _d.team) + "/usage/logs/");
      attr(a3, "class", "list-group-item");
      toggle_class(a3, "active", ctx[2] === "logs");
      attr(ul, "id", "sidebar");
      attr(ul, "class", "list-group");
      attr(div0, "class", "col-sm-3");
      attr(div1, "class", "row");
      attr(div2, "class", "container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, ul);
      append(ul, a0);
      append(a0, t0);
      append(a0, i0);
      append(ul, t1);
      append(ul, a1);
      append(a1, t2);
      append(a1, i1);
      append(ul, t3);
      append(ul, a2);
      append(a2, t4);
      append(a2, i2);
      append(ul, t5);
      append(ul, a3);
      append(a3, t6);
      append(a3, i3);
      append(div1, t7);
      if (if_block)
        if_block.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a, _b, _c, _d;
      if (!current || dirty & 2 && a0_href_value !== (a0_href_value = "#/u/" + ((_a = ctx2[1]) == null ? void 0 : _a.team) + "/usage/availability/")) {
        attr(a0, "href", a0_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a0, "active", ctx2[2] === "availability");
      }
      if (!current || dirty & 2 && a1_href_value !== (a1_href_value = "#/u/" + ((_b = ctx2[1]) == null ? void 0 : _b.team) + "/usage/daily/")) {
        attr(a1, "href", a1_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a1, "active", ctx2[2] === "daily");
      }
      if (!current || dirty & 2 && a2_href_value !== (a2_href_value = "#/u/" + ((_c = ctx2[1]) == null ? void 0 : _c.team) + "/usage/monthly/")) {
        attr(a2, "href", a2_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a2, "active", ctx2[2] === "monthly");
      }
      if (!current || dirty & 2 && a3_href_value !== (a3_href_value = "#/u/" + ((_d = ctx2[1]) == null ? void 0 : _d.team) + "/usage/logs/")) {
        attr(a3, "href", a3_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a3, "active", ctx2[2] === "logs");
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1V(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
    }
  };
}
function create_header_slot$j(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Usage</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot$7(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 8) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$3P(ctx) {
  let t;
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$7],
        default: [create_default_slot$1b]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
      document.title = "Usage | Distill.io";
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 15) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$3F($$self, $$props, $$invalidate) {
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(1, $params = $$value));
  let module;
  let identityId;
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      {
        $$invalidate(2, module = $params == null ? void 0 : $params.module);
        $$invalidate(0, identityId = $params == null ? void 0 : $params.team);
        Api.setIdentityId(identityId == 0 || !identityId ? null : identityId);
      }
    }
  };
  return [identityId, $params, module];
}
class Usage_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3F, create_fragment$3P, safe_not_equal, {});
  }
}
let diffWorker;
let diffPromises = {};
function diffHtml(oldHtml, newHtml, context) {
  const data = { oldHtml: oldHtml || "<html></html>", newHtml: newHtml || "<html></html>", context };
  if (typeof Worker !== "undefined") {
    const isLocal = Supports.agents.local;
    const prefix = isLocal ? "/ui" : "";
    if (!diffWorker) {
      diffWorker = new Worker(prefix + "/lib/diff_html.js");
      diffWorker.addEventListener("message", function(event) {
        const { context: resCtx, diff: diff2, error } = event.data;
        if (diffPromises[resCtx]) {
          if (error) {
            diffPromises[resCtx].reject(Object.assign(new Error(), error));
            return;
          }
          diffPromises[resCtx].resolve({ diff: diff2, additions: getInsertCount$1(diff2), deletions: getRemoveCount$1(diff2) });
        } else {
          console.warn(`Resolve for ${resCtx} not found`);
        }
      });
    }
    diffWorker.postMessage(data);
    return new Promise((resolve, reject) => {
      diffPromises[context] = { resolve, reject };
    });
  } else {
    document.getElementById("result").innerHTML = "Sorry, your browser does not support Web Workers...";
  }
}
function getInsertCount$1(html2) {
  return getCount$1(html2, "inserted");
}
function getRemoveCount$1(html2) {
  return getCount$1(html2, "removed");
}
function getCount$1(diff2, cls) {
  const pattern = new RegExp(`class="diffMark ${cls}`, "g");
  let count2 = (diff2.match(pattern) || []).length;
  return count2;
}
const get_tvi_right_content_slot_changes = (dirty) => ({});
const get_tvi_right_content_slot_context = (ctx) => ({});
const get_tvi_label_slot_changes = (dirty) => ({});
const get_tvi_label_slot_context = (ctx) => ({});
const get_tvi_icon_slot_changes = (dirty) => ({});
const get_tvi_icon_slot_context = (ctx) => ({});
const get_tvi_checkbox_slot_changes = (dirty) => ({});
const get_tvi_checkbox_slot_context = (ctx) => ({});
const get_tvi_expandable_slot_changes = (dirty) => ({});
const get_tvi_expandable_slot_context = (ctx) => ({});
function create_if_block$1U(ctx) {
  let current;
  const tvi_expandable_slot_template = ctx[9]["tvi-expandable"];
  const tvi_expandable_slot = create_slot(tvi_expandable_slot_template, ctx, ctx[8], get_tvi_expandable_slot_context);
  return {
    c() {
      if (tvi_expandable_slot)
        tvi_expandable_slot.c();
    },
    m(target, anchor) {
      if (tvi_expandable_slot) {
        tvi_expandable_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tvi_expandable_slot) {
        if (tvi_expandable_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            tvi_expandable_slot,
            tvi_expandable_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_expandable_slot_template, ctx2[8], dirty, get_tvi_expandable_slot_changes),
            get_tvi_expandable_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tvi_expandable_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tvi_expandable_slot, local);
      current = false;
    },
    d(detaching) {
      if (tvi_expandable_slot)
        tvi_expandable_slot.d(detaching);
    }
  };
}
function fallback_block$5(ctx) {
  let t_value = ctx[5].label + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$3O(ctx) {
  let div7;
  let div5;
  let div4;
  let div0;
  let show_if = ctx[5].isExpandable();
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  let div3;
  let div4_class_value;
  let div4_disabled_value;
  let t3;
  let div6;
  let div6_class_value;
  let action_action;
  let current;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block$1U(ctx);
  const tvi_checkbox_slot_template = ctx[9]["tvi-checkbox"];
  const tvi_checkbox_slot = create_slot(tvi_checkbox_slot_template, ctx, ctx[8], get_tvi_checkbox_slot_context);
  const tvi_icon_slot_template = ctx[9]["tvi-icon"];
  const tvi_icon_slot = create_slot(tvi_icon_slot_template, ctx, ctx[8], get_tvi_icon_slot_context);
  const tvi_label_slot_template = ctx[9]["tvi-label"];
  const tvi_label_slot = create_slot(tvi_label_slot_template, ctx, ctx[8], get_tvi_label_slot_context);
  const tvi_label_slot_or_fallback = tvi_label_slot || fallback_block$5(ctx);
  const tvi_right_content_slot_template = ctx[9]["tvi-right-content"];
  const tvi_right_content_slot = create_slot(tvi_right_content_slot_template, ctx, ctx[8], get_tvi_right_content_slot_context);
  return {
    c() {
      div7 = element("div");
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div1 = element("div");
      if (tvi_checkbox_slot)
        tvi_checkbox_slot.c();
      t1 = space();
      div2 = element("div");
      if (tvi_icon_slot)
        tvi_icon_slot.c();
      t2 = space();
      div3 = element("div");
      if (tvi_label_slot_or_fallback)
        tvi_label_slot_or_fallback.c();
      t3 = space();
      div6 = element("div");
      if (tvi_right_content_slot)
        tvi_right_content_slot.c();
      attr(div0, "class", "tv-caret");
      toggle_class(div1, "tv-checkbox", ctx[5].isCheckable());
      toggle_class(div2, "tv-icon", ctx[2]);
      attr(div3, "class", "tv-label");
      attr(div4, "class", div4_class_value = `tv-flex tv-flex-row ${ctx[3] === "medium" ? "tv-md" : ctx[3] === "small" ? "tv-sm" : "tv-lg"}`);
      attr(div4, "disabled", div4_disabled_value = ctx[5].isDisabled());
      attr(div4, "tabindex", ctx[1]);
      set_style(div4, "padding-left", "calc(" + ctx[5].getNodeLevel() + "*16px - 4px)");
      attr(div5, "class", "tv-key");
      attr(div6, "class", div6_class_value = `tv-key-meta tv-flex tv-flex-row tv-flex-wrap tv-tree-item ${ctx[3] === "medium" ? "tv-md" : ctx[3] === "small" ? "tv-sm" : "tv-lg"}`);
      attr(div7, "class", "tv-flex tv-container w-full tv-tree-item");
      toggle_class(div7, "tv-hover-select", ctx[5].selected);
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div5);
      append(div5, div4);
      append(div4, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div4, t0);
      append(div4, div1);
      if (tvi_checkbox_slot) {
        tvi_checkbox_slot.m(div1, null);
      }
      append(div4, t1);
      append(div4, div2);
      if (tvi_icon_slot) {
        tvi_icon_slot.m(div2, null);
      }
      append(div4, t2);
      append(div4, div3);
      if (tvi_label_slot_or_fallback) {
        tvi_label_slot_or_fallback.m(div3, null);
      }
      append(div7, t3);
      append(div7, div6);
      if (tvi_right_content_slot) {
        tvi_right_content_slot.m(div6, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div3, "click", ctx[6]),
          action_destroyer(action_action = ctx[4].call(null, div7, ctx[5]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 32)
        show_if = ctx2[5].isExpandable();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1U(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (tvi_checkbox_slot) {
        if (tvi_checkbox_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            tvi_checkbox_slot,
            tvi_checkbox_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_checkbox_slot_template, ctx2[8], dirty, get_tvi_checkbox_slot_changes),
            get_tvi_checkbox_slot_context
          );
        }
      }
      if (!current || dirty & 32) {
        toggle_class(div1, "tv-checkbox", ctx2[5].isCheckable());
      }
      if (tvi_icon_slot) {
        if (tvi_icon_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            tvi_icon_slot,
            tvi_icon_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_icon_slot_template, ctx2[8], dirty, get_tvi_icon_slot_changes),
            get_tvi_icon_slot_context
          );
        }
      }
      if (!current || dirty & 4) {
        toggle_class(div2, "tv-icon", ctx2[2]);
      }
      if (tvi_label_slot) {
        if (tvi_label_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            tvi_label_slot,
            tvi_label_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_label_slot_template, ctx2[8], dirty, get_tvi_label_slot_changes),
            get_tvi_label_slot_context
          );
        }
      } else {
        if (tvi_label_slot_or_fallback && tvi_label_slot_or_fallback.p && (!current || dirty & 32)) {
          tvi_label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 8 && div4_class_value !== (div4_class_value = `tv-flex tv-flex-row ${ctx2[3] === "medium" ? "tv-md" : ctx2[3] === "small" ? "tv-sm" : "tv-lg"}`)) {
        attr(div4, "class", div4_class_value);
      }
      if (!current || dirty & 32 && div4_disabled_value !== (div4_disabled_value = ctx2[5].isDisabled())) {
        attr(div4, "disabled", div4_disabled_value);
      }
      if (!current || dirty & 2) {
        attr(div4, "tabindex", ctx2[1]);
      }
      if (!current || dirty & 32) {
        set_style(div4, "padding-left", "calc(" + ctx2[5].getNodeLevel() + "*16px - 4px)");
      }
      if (tvi_right_content_slot) {
        if (tvi_right_content_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            tvi_right_content_slot,
            tvi_right_content_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_right_content_slot_template, ctx2[8], dirty, get_tvi_right_content_slot_changes),
            get_tvi_right_content_slot_context
          );
        }
      }
      if (!current || dirty & 8 && div6_class_value !== (div6_class_value = `tv-key-meta tv-flex tv-flex-row tv-flex-wrap tv-tree-item ${ctx2[3] === "medium" ? "tv-md" : ctx2[3] === "small" ? "tv-sm" : "tv-lg"}`)) {
        attr(div6, "class", div6_class_value);
      }
      if (action_action && is_function(action_action.update) && dirty & 32)
        action_action.update.call(null, ctx2[5]);
      if (!current || dirty & 32) {
        toggle_class(div7, "tv-hover-select", ctx2[5].selected);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(tvi_checkbox_slot, local);
      transition_in(tvi_icon_slot, local);
      transition_in(tvi_label_slot_or_fallback, local);
      transition_in(tvi_right_content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(tvi_checkbox_slot, local);
      transition_out(tvi_icon_slot, local);
      transition_out(tvi_label_slot_or_fallback, local);
      transition_out(tvi_right_content_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div7);
      if (if_block)
        if_block.d();
      if (tvi_checkbox_slot)
        tvi_checkbox_slot.d(detaching);
      if (tvi_icon_slot)
        tvi_icon_slot.d(detaching);
      if (tvi_label_slot_or_fallback)
        tvi_label_slot_or_fallback.d(detaching);
      if (tvi_right_content_slot)
        tvi_right_content_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3E($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(5, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { tabindex = "-1" } = $$props;
  let { isIcon = false } = $$props;
  let { size = "medium" } = $$props;
  let { action } = $$props;
  const dispatch = createEventDispatcher();
  function onClick(e) {
    e.preventDefault();
    dispatch("click", { e, node: node2 });
  }
  let { showRoot } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("tabindex" in $$props2)
      $$invalidate(1, tabindex = $$props2.tabindex);
    if ("isIcon" in $$props2)
      $$invalidate(2, isIcon = $$props2.isIcon);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
    if ("action" in $$props2)
      $$invalidate(4, action = $$props2.action);
    if ("showRoot" in $$props2)
      $$invalidate(7, showRoot = $$props2.showRoot);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [node2, tabindex, isIcon, size, action, $node, onClick, showRoot, $$scope, slots];
}
class TreeviewItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3E, create_fragment$3O, safe_not_equal, {
      node: 0,
      tabindex: 1,
      isIcon: 2,
      size: 3,
      action: 4,
      showRoot: 7
    });
  }
}
function get_each_context$R(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
const get_expandable_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_expandable_slot_context_1 = (ctx) => ({
  slot: "expandable",
  node: ctx[4]
});
const get_checkbox_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_checkbox_slot_context_1 = (ctx) => ({ slot: "checkbox", node: ctx[4] });
const get_icon_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_icon_slot_context_1 = (ctx) => ({ slot: "icon", node: ctx[4] });
const get_label_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_label_slot_context_1 = (ctx) => ({ slot: "label", node: ctx[4] });
const get_right_content_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_right_content_slot_context_1 = (ctx) => ({
  slot: "right-content",
  node: ctx[4]
});
const get_expandable_slot_changes$1 = (dirty) => ({ node: dirty & 16 });
const get_expandable_slot_context$1 = (ctx) => ({ node: ctx[4] });
const get_checkbox_slot_changes$1 = (dirty) => ({ node: dirty & 16 });
const get_checkbox_slot_context$1 = (ctx) => ({ node: ctx[4] });
const get_icon_slot_changes$2 = (dirty) => ({ node: dirty & 16 });
const get_icon_slot_context$2 = (ctx) => ({ node: ctx[4] });
const get_label_slot_changes$1 = (dirty) => ({ node: dirty & 16 });
const get_label_slot_context$1 = (ctx) => ({ slot: "tvi-label", node: ctx[4] });
const get_right_content_slot_changes = (dirty) => ({ node: dirty & 16 });
const get_right_content_slot_context = (ctx) => ({ node: ctx[4] });
function create_tvi_expandable_slot(ctx) {
  let div;
  let current;
  const expandable_slot_template = ctx[9].expandable;
  const expandable_slot = create_slot(expandable_slot_template, ctx, ctx[12], get_expandable_slot_context$1);
  return {
    c() {
      div = element("div");
      if (expandable_slot)
        expandable_slot.c();
      attr(div, "slot", "tvi-expandable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (expandable_slot) {
        expandable_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (expandable_slot) {
        if (expandable_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            expandable_slot,
            expandable_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(expandable_slot_template, ctx2[12], dirty, get_expandable_slot_changes$1),
            get_expandable_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_slot, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (expandable_slot)
        expandable_slot.d(detaching);
    }
  };
}
function create_tvi_checkbox_slot(ctx) {
  let div;
  let current;
  const checkbox_slot_template = ctx[9].checkbox;
  const checkbox_slot = create_slot(checkbox_slot_template, ctx, ctx[12], get_checkbox_slot_context$1);
  return {
    c() {
      div = element("div");
      if (checkbox_slot)
        checkbox_slot.c();
      attr(div, "slot", "tvi-checkbox");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (checkbox_slot) {
        checkbox_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (checkbox_slot) {
        if (checkbox_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            checkbox_slot,
            checkbox_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(checkbox_slot_template, ctx2[12], dirty, get_checkbox_slot_changes$1),
            get_checkbox_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox_slot, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (checkbox_slot)
        checkbox_slot.d(detaching);
    }
  };
}
function create_tvi_icon_slot(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[9].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[12], get_icon_slot_context$2);
  return {
    c() {
      div = element("div");
      if (icon_slot)
        icon_slot.c();
      attr(div, "slot", "tvi-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (icon_slot) {
        icon_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(icon_slot_template, ctx2[12], dirty, get_icon_slot_changes$2),
            get_icon_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_tvi_label_slot(ctx) {
  let current;
  const label_slot_template = ctx[9].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[12], get_label_slot_context$1);
  return {
    c() {
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(label_slot_template, ctx2[12], dirty, get_label_slot_changes$1),
            get_label_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_tvi_right_content_slot(ctx) {
  let div;
  let current;
  const right_content_slot_template = ctx[9]["right-content"];
  const right_content_slot = create_slot(right_content_slot_template, ctx, ctx[12], get_right_content_slot_context);
  return {
    c() {
      div = element("div");
      if (right_content_slot)
        right_content_slot.c();
      attr(div, "slot", "tvi-right-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (right_content_slot) {
        right_content_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (right_content_slot) {
        if (right_content_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            right_content_slot,
            right_content_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(right_content_slot_template, ctx2[12], dirty, get_right_content_slot_changes),
            get_right_content_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_content_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (right_content_slot)
        right_content_slot.d(detaching);
    }
  };
}
function create_if_block$1T(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$1f, create_else_block$11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$11(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[6];
  const get_key = (ctx2) => ctx2[14].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$R(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$R(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 4187) {
        each_value = ctx2[6];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$R, each_1_anchor, get_each_context$R);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$1f(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text("Loading...");
      set_style(div, "padding-left", "calc(" + (ctx[5].getNodeLevel() + 1) + "*16px - 4px)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32) {
        set_style(div, "padding-left", "calc(" + (ctx2[5].getNodeLevel() + 1) + "*16px - 4px)");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_expandable_slot$1(ctx) {
  let current;
  const expandable_slot_template = ctx[9].expandable;
  const expandable_slot = create_slot(expandable_slot_template, ctx, ctx[12], get_expandable_slot_context_1);
  return {
    c() {
      if (expandable_slot)
        expandable_slot.c();
    },
    m(target, anchor) {
      if (expandable_slot) {
        expandable_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (expandable_slot) {
        if (expandable_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            expandable_slot,
            expandable_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(expandable_slot_template, ctx2[12], dirty, get_expandable_slot_changes_1),
            get_expandable_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_slot, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_slot, local);
      current = false;
    },
    d(detaching) {
      if (expandable_slot)
        expandable_slot.d(detaching);
    }
  };
}
function create_checkbox_slot$1(ctx) {
  let current;
  const checkbox_slot_template = ctx[9].checkbox;
  const checkbox_slot = create_slot(checkbox_slot_template, ctx, ctx[12], get_checkbox_slot_context_1);
  return {
    c() {
      if (checkbox_slot)
        checkbox_slot.c();
    },
    m(target, anchor) {
      if (checkbox_slot) {
        checkbox_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (checkbox_slot) {
        if (checkbox_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            checkbox_slot,
            checkbox_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(checkbox_slot_template, ctx2[12], dirty, get_checkbox_slot_changes_1),
            get_checkbox_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox_slot, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox_slot, local);
      current = false;
    },
    d(detaching) {
      if (checkbox_slot)
        checkbox_slot.d(detaching);
    }
  };
}
function create_icon_slot$6(ctx) {
  let current;
  const icon_slot_template = ctx[9].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[12], get_icon_slot_context_1);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(icon_slot_template, ctx2[12], dirty, get_icon_slot_changes_1),
            get_icon_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_label_slot$3(ctx) {
  let current;
  const label_slot_template = ctx[9].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[12], get_label_slot_context_1);
  return {
    c() {
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(label_slot_template, ctx2[12], dirty, get_label_slot_changes_1),
            get_label_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_right_content_slot$1(ctx) {
  let current;
  const right_content_slot_template = ctx[9]["right-content"];
  const right_content_slot = create_slot(right_content_slot_template, ctx, ctx[12], get_right_content_slot_context_1);
  return {
    c() {
      if (right_content_slot)
        right_content_slot.c();
    },
    m(target, anchor) {
      if (right_content_slot) {
        right_content_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (right_content_slot) {
        if (right_content_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            right_content_slot,
            right_content_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(right_content_slot_template, ctx2[12], dirty, get_right_content_slot_changes_1),
            get_right_content_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_content_slot, local);
      current = false;
    },
    d(detaching) {
      if (right_content_slot)
        right_content_slot.d(detaching);
    }
  };
}
function create_each_block$R(key_1, ctx) {
  let first;
  let treenode;
  let current;
  treenode = new TreeNode({
    props: {
      node: ctx[14],
      isIcon: ctx[1],
      size: ctx[3],
      action: ctx[0],
      $$slots: {
        "right-content": [
          create_right_content_slot$1,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ],
        label: [
          create_label_slot$3,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ],
        icon: [
          create_icon_slot$6,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ],
        checkbox: [
          create_checkbox_slot$1,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ],
        expandable: [
          create_expandable_slot$1,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  treenode.$on("click", ctx[11]);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(treenode.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(treenode, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const treenode_changes = {};
      if (dirty & 64)
        treenode_changes.node = ctx[14];
      if (dirty & 2)
        treenode_changes.isIcon = ctx[1];
      if (dirty & 8)
        treenode_changes.size = ctx[3];
      if (dirty & 1)
        treenode_changes.action = ctx[0];
      if (dirty & 4112) {
        treenode_changes.$$scope = { dirty, ctx };
      }
      treenode.$set(treenode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treenode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treenode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(treenode, detaching);
    }
  };
}
function create_fragment$3N(ctx) {
  let treeviewitem;
  let t;
  let show_if = ctx[5].isExpanded();
  let if_block_anchor;
  let current;
  treeviewitem = new TreeviewItem({
    props: {
      tabindex: ctx[5].getSelected() || ctx[8] ? "0" : "-1",
      node: ctx[5],
      isIcon: ctx[1],
      size: ctx[3],
      showRoot: ctx[8] ? ctx[2] : true,
      action: ctx[0],
      $$slots: {
        "tvi-right-content": [create_tvi_right_content_slot],
        "tvi-label": [create_tvi_label_slot],
        "tvi-icon": [create_tvi_icon_slot],
        "tvi-checkbox": [create_tvi_checkbox_slot],
        "tvi-expandable": [create_tvi_expandable_slot]
      },
      $$scope: { ctx }
    }
  });
  treeviewitem.$on("click", ctx[10]);
  let if_block = show_if && create_if_block$1T(ctx);
  return {
    c() {
      create_component(treeviewitem.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(treeviewitem, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const treeviewitem_changes = {};
      if (dirty & 288)
        treeviewitem_changes.tabindex = ctx2[5].getSelected() || ctx2[8] ? "0" : "-1";
      if (dirty & 32)
        treeviewitem_changes.node = ctx2[5];
      if (dirty & 2)
        treeviewitem_changes.isIcon = ctx2[1];
      if (dirty & 8)
        treeviewitem_changes.size = ctx2[3];
      if (dirty & 260)
        treeviewitem_changes.showRoot = ctx2[8] ? ctx2[2] : true;
      if (dirty & 1)
        treeviewitem_changes.action = ctx2[0];
      if (dirty & 4112) {
        treeviewitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeviewitem.$set(treeviewitem_changes);
      if (dirty & 32)
        show_if = ctx2[5].isExpanded();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1T(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treeviewitem.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(treeviewitem.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(treeviewitem, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3D($$self, $$props, $$invalidate) {
  let _root;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(5, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { action } = $$props;
  let { isIcon } = $$props;
  let { showRoot = true } = $$props;
  let { size = "medium" } = $$props;
  let children = [];
  let loading2 = false;
  async function getChildren(node3) {
    if (node3.isExpanded()) {
      if (children.length === 0) {
        $$invalidate(7, loading2 = true);
      }
      $$invalidate(6, children = await node3.getChildren());
      $$invalidate(7, loading2 = false);
    } else {
      $$invalidate(6, children = []);
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(4, node2 = $$props2.node));
    if ("action" in $$props2)
      $$invalidate(0, action = $$props2.action);
    if ("isIcon" in $$props2)
      $$invalidate(1, isIcon = $$props2.isIcon);
    if ("showRoot" in $$props2)
      $$invalidate(2, showRoot = $$props2.showRoot);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $$invalidate(8, _root = $node.isRoot());
    }
    if ($$self.$$.dirty & 32) {
      getChildren($node);
    }
  };
  return [
    action,
    isIcon,
    showRoot,
    size,
    node2,
    $node,
    children,
    loading2,
    _root,
    slots,
    click_handler,
    click_handler_1,
    $$scope
  ];
}
class TreeNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3D, create_fragment$3N, safe_not_equal, {
      node: 4,
      action: 0,
      isIcon: 1,
      showRoot: 2,
      size: 3
    });
  }
}
function create_else_block$10(ctx) {
  let svg;
  let path;
  let mounted;
  let dispose;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z");
      attr(path, "clip-rule", "evenodd");
      attr(svg, "class", "tv-svg");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      if (!mounted) {
        dispose = listen(svg, "click", ctx[5]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1S(ctx) {
  let svg;
  let path;
  let mounted;
  let dispose;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z");
      attr(path, "clip-rule", "evenodd");
      attr(svg, "class", "tv-svg");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      if (!mounted) {
        dispose = listen(svg, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3M(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1])
      return create_if_block$1S;
    return create_else_block$10;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3C($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(3, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let expanded;
  const dispatch = createEventDispatcher();
  function click(e) {
    $$invalidate(1, expanded = !expanded);
    node2.setExpanded(expanded);
    dispatch("expanded", { expanded, node: node2 });
  }
  const click_handler = (e) => click();
  const click_handler_1 = (e) => click();
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $$invalidate(1, expanded = $node.isExpanded());
    }
  };
  return [node2, expanded, click, $node, click_handler, click_handler_1];
}
class Expandable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3C, create_fragment$3M, safe_not_equal, { node: 0 });
  }
}
Object.freeze({
  none: "none",
  single: "single",
  multi: "multi"
});
const CheckState = Object.freeze({
  none: "none",
  indeterminate: "indeterminate",
  selected: "selected"
});
function create_fragment$3L(ctx) {
  let input_1;
  let mounted;
  let dispose;
  return {
    c() {
      input_1 = element("input");
      attr(input_1, "class", "");
      input_1.checked = ctx[2];
      attr(input_1, "type", "checkbox");
      attr(input_1, "tabindex", "-1");
      input_1.disabled = ctx[0];
    },
    m(target, anchor) {
      insert(target, input_1, anchor);
      ctx[5](input_1);
      if (!mounted) {
        dispose = listen(input_1, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        input_1.checked = ctx2[2];
      }
      if (dirty & 1) {
        input_1.disabled = ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input_1);
      ctx[5](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$3B($$self, $$props, $$invalidate) {
  let checked;
  let { disabled: disabled2 = false } = $$props;
  let { node: node2 } = $$props;
  let input;
  const dispatch = createEventDispatcher();
  onMount(() => {
    $$invalidate(1, input.indeterminate = node2.checkState === CheckState.indeterminate, input);
  });
  function click(e) {
    $$invalidate(2, checked = !checked);
    $$invalidate(4, node2.checkState = checked ? CheckState.selected : CheckState.none, node2);
    dispatch("checked", { checked, node: node2 });
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(1, input), $$invalidate(4, node2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(0, disabled2 = $$props2.disabled);
    if ("node" in $$props2)
      $$invalidate(4, node2 = $$props2.node);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $$invalidate(2, checked = node2.checkState === CheckState.none ? false : true);
    }
    if ($$self.$$.dirty & 18) {
      if (input) {
        $$invalidate(1, input.indeterminate = node2.checkState === CheckState.indeterminate, input);
      }
    }
  };
  return [disabled2, input, checked, click, node2, input_1_binding];
}
class Checkbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3B, create_fragment$3L, safe_not_equal, { disabled: 0, node: 4 });
  }
}
function classes(...classArray) {
  if (!classArray)
    return "";
  return classArray.filter((cls) => !!cls).join(" ");
}
const get_expandable_slot_changes = (dirty) => ({ node: dirty & 262144 });
const get_expandable_slot_context = (ctx) => ({ node: ctx[18] });
const get_checkbox_slot_changes = (dirty) => ({ node: dirty & 262144 });
const get_checkbox_slot_context = (ctx) => ({ node: ctx[18] });
const get_icon_slot_changes$1 = (dirty) => ({ node: dirty & 262144 });
const get_icon_slot_context$1 = (ctx) => ({ node: ctx[18] });
const get_label_slot_changes = (dirty) => ({ node: dirty & 262144 });
const get_label_slot_context = (ctx) => ({ node: ctx[18] });
const get_meta_slot_changes = (dirty) => ({ node: dirty & 262144 });
const get_meta_slot_context = (ctx) => ({ node: ctx[18] });
function create_if_block_2$R(ctx) {
  let current;
  const expandable_slot_template = ctx[11].expandable;
  const expandable_slot = create_slot(expandable_slot_template, ctx, ctx[12], get_expandable_slot_context);
  const expandable_slot_or_fallback = expandable_slot || fallback_block_2(ctx);
  return {
    c() {
      if (expandable_slot_or_fallback)
        expandable_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (expandable_slot_or_fallback) {
        expandable_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (expandable_slot) {
        if (expandable_slot.p && (!current || dirty & 266240)) {
          update_slot_base(
            expandable_slot,
            expandable_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(expandable_slot_template, ctx2[12], dirty, get_expandable_slot_changes),
            get_expandable_slot_context
          );
        }
      } else {
        if (expandable_slot_or_fallback && expandable_slot_or_fallback.p && (!current || dirty & 262144)) {
          expandable_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (expandable_slot_or_fallback)
        expandable_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_2(ctx) {
  let expandable;
  let current;
  expandable = new Expandable({ props: { node: ctx[18] } });
  expandable.$on("expanded", ctx[10]);
  return {
    c() {
      create_component(expandable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expandable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const expandable_changes = {};
      if (dirty & 262144)
        expandable_changes.node = ctx2[18];
      expandable.$set(expandable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expandable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expandable, detaching);
    }
  };
}
function create_expandable_slot(ctx) {
  let div;
  let show_if = ctx[18].isExpandable();
  let current;
  let if_block = show_if && create_if_block_2$R(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "slot", "expandable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 262144)
        show_if = ctx2[18].isExpandable();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 262144) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$R(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$1e(ctx) {
  let current;
  const checkbox_slot_template = ctx[11].checkbox;
  const checkbox_slot = create_slot(checkbox_slot_template, ctx, ctx[12], get_checkbox_slot_context);
  const checkbox_slot_or_fallback = checkbox_slot || fallback_block_1$1(ctx);
  return {
    c() {
      if (checkbox_slot_or_fallback)
        checkbox_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (checkbox_slot_or_fallback) {
        checkbox_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (checkbox_slot) {
        if (checkbox_slot.p && (!current || dirty & 266240)) {
          update_slot_base(
            checkbox_slot,
            checkbox_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(checkbox_slot_template, ctx2[12], dirty, get_checkbox_slot_changes),
            get_checkbox_slot_context
          );
        }
      } else {
        if (checkbox_slot_or_fallback && checkbox_slot_or_fallback.p && (!current || dirty & 262144)) {
          checkbox_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (checkbox_slot_or_fallback)
        checkbox_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_1$1(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox({
    props: {
      node: ctx[18],
      disabled: ctx[18].isDisabled()
    }
  });
  checkbox.$on("checked", ctx[7]);
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & 262144)
        checkbox_changes.node = ctx2[18];
      if (dirty & 262144)
        checkbox_changes.disabled = ctx2[18].isDisabled();
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_checkbox_slot(ctx) {
  let div;
  let show_if = ctx[18].isCheckable();
  let current;
  let if_block = show_if && create_if_block_1$1e(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "slot", "checkbox");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 262144)
        show_if = ctx2[18].isCheckable();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 262144) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$1e(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block$1R(ctx) {
  let current;
  const icon_slot_template = ctx[11].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[12], get_icon_slot_context$1);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 266240)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(icon_slot_template, ctx2[12], dirty, get_icon_slot_changes$1),
            get_icon_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_icon_slot$5(ctx) {
  let div;
  let current;
  let if_block = ctx[5] && create_if_block$1R(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "slot", "icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1R(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function fallback_block$4(ctx) {
  let t_value = ctx[18].label + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 262144 && t_value !== (t_value = ctx2[18].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_label_slot$2(ctx) {
  let div;
  let current;
  const label_slot_template = ctx[11].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[12], get_label_slot_context);
  const label_slot_or_fallback = label_slot || fallback_block$4(ctx);
  return {
    c() {
      div = element("div");
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      attr(div, "slot", "label");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 266240)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(label_slot_template, ctx2[12], dirty, get_label_slot_changes),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & 262144)) {
          label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
}
function create_right_content_slot(ctx) {
  let div;
  let current;
  const meta_slot_template = ctx[11].meta;
  const meta_slot = create_slot(meta_slot_template, ctx, ctx[12], get_meta_slot_context);
  return {
    c() {
      div = element("div");
      if (meta_slot)
        meta_slot.c();
      attr(div, "slot", "right-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (meta_slot) {
        meta_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (meta_slot) {
        if (meta_slot.p && (!current || dirty & 266240)) {
          update_slot_base(
            meta_slot,
            meta_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(meta_slot_template, ctx2[12], dirty, get_meta_slot_changes),
            get_meta_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(meta_slot, local);
      current = true;
    },
    o(local) {
      transition_out(meta_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (meta_slot)
        meta_slot.d(detaching);
    }
  };
}
function create_fragment$3K(ctx) {
  let div;
  let treenode;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  treenode = new TreeNode({
    props: {
      node: ctx[6],
      size: ctx[4],
      isIcon: ctx[5],
      action: ctx[1],
      $$slots: {
        "right-content": [
          create_right_content_slot,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ],
        label: [
          create_label_slot$2,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ],
        icon: [
          create_icon_slot$5,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ],
        checkbox: [
          create_checkbox_slot,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ],
        expandable: [
          create_expandable_slot,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  treenode.$on("click", ctx[9]);
  return {
    c() {
      div = element("div");
      create_component(treenode.$$.fragment);
      attr(div, "class", div_class_value = classes(ctx[2]));
      attr(div, "showroot", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(treenode, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(div, "keydown", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const treenode_changes = {};
      if (dirty & 64)
        treenode_changes.node = ctx2[6];
      if (dirty & 16)
        treenode_changes.size = ctx2[4];
      if (dirty & 32)
        treenode_changes.isIcon = ctx2[5];
      if (dirty & 2)
        treenode_changes.action = ctx2[1];
      if (dirty & 266272) {
        treenode_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treenode.$set(treenode_changes);
      if (!current || dirty & 4 && div_class_value !== (div_class_value = classes(ctx2[2]))) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & 8) {
        attr(div, "showroot", ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treenode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treenode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(treenode);
      mounted = false;
      dispose();
    }
  };
}
function instance$3A($$self, $$props, $$invalidate) {
  let isIcon;
  let $root, $$unsubscribe_root = noop, $$subscribe_root = () => ($$unsubscribe_root(), $$unsubscribe_root = subscribe(root, ($$value) => $$invalidate(6, $root = $$value)), root);
  $$self.$$.on_destroy.push(() => $$unsubscribe_root());
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { root } = $$props;
  $$subscribe_root();
  let { nodeAction = () => ({}) } = $$props;
  let { class: _class = "" } = $$props;
  let selectedNode = null;
  const dispatch = createEventDispatcher();
  let { showRoot = true } = $$props;
  let { size = "medium" } = $$props;
  function onChecked(e) {
    let { checked, node: node2 } = e.detail;
    if (checked) {
      node2.checkAll(CheckState.selected);
    } else {
      node2.checkAll(CheckState.none);
    }
    dispatch("check", { checked, node: node2 });
  }
  function selectNext() {
    if (!selectedNode) {
      selectedNode = root;
      selectedNode.setSelected(true);
    } else {
      selectedNode = selectedNode.selectNext();
    }
    dispatch("select", { node: selectedNode });
  }
  function selectPrevious() {
    if (!selectedNode) {
      selectedNode = root;
      selectedNode.setSelected(true);
    } else {
      selectedNode = selectedNode.selectPrevious();
    }
    dispatch("select", { node: selectedNode });
  }
  function onKeypress(e) {
    let { keyCode } = e;
    if (keyCode === 40) {
      selectNext();
    } else if (keyCode === 38) {
      selectPrevious();
    } else if (keyCode === 37) {
      if (!selectedNode)
        selectedNode = root;
      selectedNode.setExpanded(false);
      dispatch("expand", { expanded: false, node: selectedNode });
    } else if (keyCode === 39) {
      if (!selectedNode)
        selectedNode = root;
      if (selectedNode.isExpandable()) {
        selectedNode.setExpanded(true);
        dispatch("expand", { expanded: true, node: selectedNode });
      }
    } else if (keyCode === 32) {
      if (!selectedNode)
        selectedNode = node;
      onChecked({
        detail: {
          checked: selectedNode.checkState === CheckState.none,
          node: selectedNode
        }
      });
    }
  }
  function onClick(e) {
    let { node: node2 } = e.detail;
    if (!node2.isDisabled() && node2.isSelectable()) {
      if (selectedNode)
        selectedNode.setSelected(false);
      selectedNode = node2;
      node2.setSelected(true);
      dispatch("select", { node: node2 });
    }
  }
  function onExpand(e) {
    dispatch("expand", {
      expanded: e.detail.expanded,
      node: e.detail.node
    });
  }
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$subscribe_root($$invalidate(0, root = $$props2.root));
    if ("nodeAction" in $$props2)
      $$invalidate(1, nodeAction = $$props2.nodeAction);
    if ("class" in $$props2)
      $$invalidate(2, _class = $$props2.class);
    if ("showRoot" in $$props2)
      $$invalidate(3, showRoot = $$props2.showRoot);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$invalidate(5, isIcon = $$slots.icon);
  return [
    root,
    nodeAction,
    _class,
    showRoot,
    size,
    isIcon,
    $root,
    onChecked,
    onKeypress,
    onClick,
    onExpand,
    slots,
    $$scope
  ];
}
class TreeView$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3A, create_fragment$3K, safe_not_equal, {
      root: 0,
      nodeAction: 1,
      class: 2,
      showRoot: 3,
      size: 4
    });
  }
}
class BaseNode {
  constructor(id2, label, parent2 = null) {
    if (this.constructor === BaseNode) {
      throw new Error("unable to instantiate the abstract class");
    }
    this.id = id2;
    this.label = label;
    this.children = null;
    this.parent = parent2;
    this._expanded = false;
    this.selected = false;
    this.checkState = CheckState.none;
    this.listeners = [];
    this.checkable = false;
    this.disabled = false;
    this.selectable = false;
    this.loading = false;
  }
  subscribe(listener) {
    this.listeners.push(listener);
    listener(this);
    return () => {
      this.listeners.splice(this.listeners.indexOf(listener), 1);
    };
  }
  notify() {
    for (let listener of this.listeners) {
      listener(this);
    }
  }
  getId() {
    return this.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(label) {
    this.label = label;
    this.notify();
  }
  getChildCount() {
    return this.children ? this.children.length : 0;
  }
  async getChildren() {
    return this.children ? this.children : [];
  }
  setChildren(children) {
    this.children = children;
  }
  pushChild(child) {
    if (this.children !== null)
      this.children.push(child);
  }
  getParent() {
    return this.parent;
  }
  setParent(parent2) {
    this.parent = parent2;
  }
  isExpanded() {
    return this._expanded;
  }
  setExpanded(state) {
    if (this.isExpandable() && this._expanded !== state) {
      this._expanded = state;
      this.notify();
    }
    if (state && this.parent) {
      this.parent.setExpanded(true);
    }
  }
  isExpandable() {
    return this.children ? this.children.length > 0 : false;
  }
  isSelectable() {
    return this.selectable && !this.disabled;
  }
  setSelectable(selectable) {
    this.selectable = selectable;
  }
  getCheckState() {
    return this.checkState;
  }
  setCheckState(checkState) {
    this.checkState = checkState;
    this.notify();
  }
  isDisabled() {
    return this.disabled;
  }
  setDisabled(disabled2) {
    this.disabled = disabled2;
  }
  isCheckable() {
    return this.checkable && !this.disabled;
  }
  setCheckable(checkable) {
    this.checkable = checkable;
  }
  isLoading() {
    return this.loading;
  }
  setLoading(state) {
    this.loading = state;
    this.notify();
  }
  isRoot() {
    return !this.parent;
  }
  getRoot() {
    let node2 = this;
    let root = node2;
    while (node2.parent) {
      root = node2.parent;
      node2 = node2.parent;
    }
    return root;
  }
  checkAllChild(state) {
    this.checkState = state;
    if (!this.children) {
      return;
    }
    for (let child of this.children) {
      child.checkState = state;
      child.checkAllChild(state);
    }
  }
  checkAllParent(state) {
    if (this.parent === null)
      return;
    let siblings = this.getSiblings();
    let countOfNone = 0, partial = false;
    const checkableSiblings = siblings.filter((s) => s.isCheckable());
    for (let sibling of checkableSiblings) {
      if (sibling.checkState === CheckState.none) {
        countOfNone++;
      } else if (sibling.checkState === CheckState.indeterminate) {
        partial = true;
        break;
      }
    }
    if (partial || countOfNone > 0 && countOfNone < checkableSiblings.length) {
      this.parent.checkState = CheckState.indeterminate;
    } else if (countOfNone === 0) {
      this.parent.checkState = CheckState.selected;
    } else {
      this.parent.checkState = CheckState.none;
    }
    this.parent.checkAllParent(state);
  }
  checkAll(state) {
    this.checkAllChild(state);
    this.checkAllParent(state);
    this.checkState = state;
    this.getRoot().notify();
  }
  expandedAll(state, root) {
    root._expanded = state;
    for (let child of parent.children) {
      child._expanded = state;
      this.expandedAll(state, child);
    }
    this.notify();
  }
  getSelected() {
    return this.selected;
  }
  setSelected(selected) {
    this.selected = selected;
    this.notify();
    if (selected) {
      this.setExpanded(true);
    }
  }
  getSiblings() {
    if (this.parent === null)
      return null;
    if (this.parent.getChildCount() > 0)
      return this.parent.children;
    return null;
  }
  findNextSibling() {
    let siblings = this.getSiblings();
    if (!siblings)
      return null;
    const index2 = siblings.indexOf(this);
    return siblings[index2 + 1] || this.parent.findNextSibling();
  }
  findPreviousSibling() {
    let siblings = this.getSiblings();
    if (!siblings)
      return null;
    const index2 = siblings.indexOf(this);
    return siblings[index2 - 1] || null;
  }
  findInnermostChild() {
    let childCount = this.getChildCount();
    if (childCount === 0 || (!this.isExpanded() || this.isLoading()))
      return this;
    return this.children[childCount - 1].findInnermostChild();
  }
  selectNext() {
    let next2;
    if (this.isExpanded() && !this.isLoading() && this.getChildCount() > 0) {
      next2 = this.children[0];
    } else {
      next2 = this.findNextSibling();
    }
    if (next2) {
      this.setSelected(false);
      if (next2.isDisabled() || !next2.isSelectable())
        return next2.selectNext();
      next2.setSelected(true);
      return next2;
    } else {
      return null;
    }
  }
  selectPrevious() {
    let previous;
    let previousSibling = this.findPreviousSibling();
    if (!previousSibling)
      previous = this.parent;
    else if (previousSibling.isExpanded() && !previousSibling.isLoading()) {
      previous = previousSibling.findInnermostChild();
    } else {
      previous = previousSibling;
    }
    if (previous) {
      this.setSelected(false);
      if (previous.isDisabled() || !previous.isSelectable())
        return previous.selectPrevious();
      previous.setSelected(true);
      return previous;
    } else {
      return null;
    }
  }
  getNodeLevel() {
    if (!this.parent)
      return 0;
    return 1 + this.parent.getNodeLevel();
  }
}
const types = {
  ARRAY: "Array",
  ARRAY_OF_OBJECTS: "ArrayOfObjects",
  OBJECT: "Object",
  NUMBER: "Number",
  BOOLEAN: "Boolean",
  STRING: "String",
  NULL: "Null",
  UNDEFINED: "Undefined",
  PRIMITIVE: "Primitive"
};
function jsonType(json) {
  const type = Object.prototype.toString.call(json).slice(8, -1);
  if (type === "Object") {
    if (typeof json[Symbol.iterator] === "function") {
      return "Iterable";
    }
    return json.constructor.name;
  }
  return type;
}
function isPrimitive$1(value) {
  return isPrimitiveType(jsonType(value));
}
function isArrayOfPrimitives(arr) {
  if (!arr) {
    return false;
  }
  if (!Array.isArray(arr)) {
    return false;
  }
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (!isPrimitive$1(arr[i2])) {
      return false;
    }
  }
  return true;
}
function isArrayOfObject(array) {
  for (let arr of array) {
    if (jsonType(arr) === types.OBJECT) {
      return true;
    }
  }
  return false;
}
function isPrimitiveType(type) {
  switch (type) {
    case types.NUMBER:
    case types.BOOLEAN:
    case types.STRING:
    case types.PRIMITIVE:
    case types.NULL:
    case types.UNDEFINED:
      return true;
    case types.ARRAY:
    case types.ARRAY_OF_OBJECTS:
    case types.OBJECT:
      return false;
  }
}
class DiffTreeNode extends BaseNode {
  constructor({ id: id2, label, parent: parent2 = null, type, value, oldValue = null, oldType = null, changeType, dirty = false, depth = 0 }) {
    super(id2, label, parent2);
    this.checkable = false;
    this.selectable = false;
    this.disabled = false;
    this._expanded = true;
    this.type = type;
    this.value = value;
    this.dirty = dirty;
    this.oldValue = oldValue;
    this.oldType = oldType;
    this.changeType = changeType;
    this.children = null;
    this.depth = depth;
  }
  getChildren() {
    return this.children || [];
  }
  isLeaf() {
    return this.getChildren().length === 0;
  }
  getValue() {
    switch (this.type) {
      case types.STRING:
        return this.value;
      default:
        return this.getPrettyValue();
    }
  }
  getPrettyValue(opts) {
    return this.getPretty({ value: this.value, type: this.type, ...opts });
  }
  getPrettyOldValue(opts) {
    return this.getPretty({ value: this.oldValue, type: this.oldType, ...opts });
  }
  getPretty({ value, type, trim = false }) {
    if (value === void 0) {
      return "";
    }
    if (!this.parent) {
      return this.value;
    }
    switch (type) {
      case types.STRING:
        value = firstValue(value);
        if (trim && value.length > 100) {
          return value.replace(/\s/g, " ").substring(0, 100) + `...`;
        } else {
          return value;
        }
      case types.NUMBER:
        return firstValue(value);
      case types.ARRAY:
      case types.OBJECT:
        return "";
      case types.BOOLEAN:
      default:
        return value;
    }
  }
}
const ChangeType = {
  ADDED: "added",
  DELETED: "deleted",
  VALUE_CHANGED: "value_changed"
};
function firstValue(arrayOrValue) {
  if (arrayOrValue !== 0 && !arrayOrValue) {
    return "";
  }
  if (Array.isArray(arrayOrValue) && arrayOrValue.length > 0) {
    for (let i2 = 0; i2 < arrayOrValue.length; i2++) {
      if (arrayOrValue[i2]) {
        return arrayOrValue[i2];
      }
    }
    return arrayOrValue[0];
  }
  return arrayOrValue;
}
function isArrayDiff(item) {
  return !(jsonType(item) !== types.ARRAY || !(item.length === 2 || item.length === 1 && item[0] === " ") || !(typeof item[0] === "string") || item[0].length !== 1 || ![" ", "-", "+", "~"].includes(item[0]));
}
class ComputeDiff {
  constructor() {
    this.count = 0;
    this.maxDepth = 0;
    this.additions = 0;
    this.deletions = 0;
    this.jsonDiffToNode = this.jsonDiffToNode.bind(this);
  }
  updateDiffCount(changeType) {
    switch (changeType) {
      case ChangeType.ADDED:
        this.additions++;
        break;
      case ChangeType.DELETED:
        this.deletions++;
        break;
      case ChangeType.VALUE_CHANGED:
        this.additions++;
        this.deletions++;
        break;
    }
  }
  generateTree(json, root, value) {
    const diffRoot = this.jsonDiffToNode(json, root, null, value);
    Object.assign(diffRoot, { maxDepth: this.maxDepth, additions: this.additions, deletions: this.deletions });
    return diffRoot;
  }
  jsonDiffToNode(json, label, parent2, value, changeType, depth = 0) {
    let type = jsonType(json);
    let newNode;
    let oldValue;
    let oldType;
    let change;
    let dirty = false;
    if (this.maxDepth < depth) {
      this.maxDepth = depth;
    }
    if (jsonType(label) === types.STRING) {
      if (change = label.match(/^(.*)__deleted$/)) {
        label = change[1];
        dirty = true;
        changeType = ChangeType.DELETED;
      } else if (change = label.match(/^(.*)__added$/)) {
        label = change[1];
        dirty = true;
        changeType = ChangeType.ADDED;
      }
    }
    switch (type) {
      case types.ARRAY:
        newNode = new DiffTreeNode({
          id: this.count++,
          label,
          parent: parent2,
          type,
          value,
          changeType
        });
        this.updateDiffCount(changeType);
        let looksLikeDiff = true;
        for (const item of json) {
          if (!isArrayDiff(item)) {
            looksLikeDiff = false;
          }
        }
        if (looksLikeDiff) {
          newNode.children = [];
          let add_count = 0, delete_count = 0;
          for (let index2 in json) {
            let [op, value2] = json[index2];
            if (value2 === void 0) {
              continue;
            }
            if (op === "~") {
              op = " ";
            }
            switch (op) {
              case "+":
                add_count++;
                newNode.children.push(this.jsonDiffToNode(value2, index2 - delete_count, newNode, value2, ChangeType.ADDED, depth + 1));
                break;
              case "-":
                newNode.children.push(this.jsonDiffToNode(value2, index2 - add_count, newNode, value2, ChangeType.DELETED, depth + 1));
                delete_count++;
                break;
              case " ":
              default:
                newNode.children.push(this.jsonDiffToNode(value2, index2 - delete_count, newNode, value2, void 0, depth + 1));
            }
          }
        } else {
          newNode.children = json.map((value2, index2) => this.jsonDiffToNode(value2, index2, newNode, value2, changeType, depth + 1));
        }
        break;
      case types.OBJECT:
        if ("__old" in json && "__new" in json && Object.keys(json).length === 2) {
          dirty = true;
          oldValue = json.__old;
          value = json.__new;
          oldType = jsonType(oldValue);
          type = jsonType(value);
          changeType = ChangeType.VALUE_CHANGED;
          this.updateDiffCount(changeType);
          if (!isPrimitive$1(oldValue) || !isPrimitive$1(value)) {
            newNode = new DiffTreeNode({
              id: this.count++,
              label,
              parent: parent2,
              type,
              value,
              oldValue,
              oldType,
              changeType
            });
            newNode.children = [];
            newNode.children.push(this.jsonDiffToNode(oldValue, void 0, newNode, oldValue, ChangeType.DELETED, depth + 1));
            newNode.children.push(this.jsonDiffToNode(value, void 0, newNode, value, ChangeType.ADDED, depth));
          } else {
            newNode = this.createLeafNode({ label, parent: parent2, type, value, oldValue, oldType, dirty, changeType });
          }
        } else {
          newNode = new DiffTreeNode({
            id: this.count++,
            label,
            parent: parent2,
            type,
            value,
            changeType
          });
          this.updateDiffCount(changeType);
          newNode.children = Object.keys(json).map((key) => this.jsonDiffToNode(json[key], key, newNode, json[key], changeType, depth + 1));
        }
        break;
      case types.NUMBER:
      case types.BOOLEAN:
      case types.STRING:
      case types.PRIMITIVE:
      default:
        this.updateDiffCount(changeType);
        newNode = this.createLeafNode({ label, parent: parent2, type, value, oldValue, oldType, dirty, changeType });
    }
    return newNode;
  }
  createLeafNode(data) {
    let { parent: parent2, changeType } = data;
    if (changeType) {
      let p = parent2;
      data.dirty = true;
      while (p) {
        if (p.dirty)
          break;
        p.dirty = true;
        p = p.parent;
      }
    }
    return new DiffTreeNode({
      id: this.count++,
      ...data
    });
  }
}
function pruneByChangeType(node2, changeType) {
  (function prune(node3) {
    let index2 = 0;
    let children = node3.getChildren();
    let length = children.length;
    while (index2 < length) {
      let curr = children[index2];
      if (curr.changeType === changeType) {
        children.splice(index2, 1);
        index2--;
        length--;
      } else if (curr.changeType === ChangeType.VALUE_CHANGED && curr.isLeaf()) {
        if (changeType === ChangeType.ADDED) {
          curr.value = void 0;
        } else {
          curr.oldValue = void 0;
        }
      } else {
        prune(curr);
      }
      index2++;
    }
  })(node2);
}
function removeDeletions(node2) {
  pruneByChangeType(node2, ChangeType.DELETED);
}
function removeAdditions(node2) {
  pruneByChangeType(node2, ChangeType.ADDED);
}
function generateTree(obj, options = {}) {
  let { pruneDeletions = false, pruneAdditions = false, root = "~", value } = options;
  const diff2 = new ComputeDiff();
  const diffNode = diff2.generateTree(obj, root, value);
  if (pruneDeletions) {
    removeDeletions(diffNode);
  }
  if (pruneAdditions) {
    removeAdditions(diffNode);
  }
  return diffNode;
}
function cloneJsonDiff(root) {
  const diffClone = function clone(diffNode, parent2 = null) {
    let newNode = new DiffTreeNode(diffNode);
    newNode.parent = parent2;
    newNode.children = [];
    for (const child of diffNode.getChildren()) {
      newNode.children.push(clone(child, newNode));
    }
    return newNode;
  }(root);
  const { maxDepth, additions, deletions } = root;
  Object.assign(diffClone, { maxDepth, additions, deletions });
  return diffClone;
}
let jsonDiff;
async function diffJson(oldJson, newJson, options = {}) {
  const { full = true } = options;
  if (!jsonDiff) {
    ({ jsonDiff } = await __vitePreload(() => import("./json-diff.min.648166e2.js"), true ? [] : void 0));
  }
  let diff2 = jsonDiff.diff(oldJson, newJson, { full });
  let diffNode;
  if (diff2) {
    diffNode = generateTree(diff2);
  } else {
    diffNode = generateTree(oldJson);
  }
  return diffNode;
}
function diffDMP(oldData, newData) {
  try {
    const dmp = new diff_match_patch();
    const a = dmp.diff_wordsToChars_(oldData.replace(/\s+/g, " "), newData.replace(/\s+/g, " "));
    const diffs = dmp.diff_main(a.chars1, a.chars2, false);
    dmp.diff_charsToLines_(diffs, a.wordArray);
    dmp.diff_cleanupSemantic(diffs);
    const diff2 = dmp.diff_prettyHtml(diffs);
    return { diff: diff2, additions: getInsertCount(diff2), deletions: getRemoveCount(diff2) };
  } catch (e) {
    return `Error showing diff: ${e.message} 
 ${e.stack}`;
  }
}
function getInsertCount(html2) {
  return getCount(html2, "<ins");
}
function getRemoveCount(html2) {
  return getCount(html2, "<del");
}
function getCount(diff2, selector) {
  const pattern = new RegExp(selector, "g");
  return (diff2.match(pattern) || []).length;
}
async function diffSieve(oldData, newData, context, selectedDiffContentMode = C$2.DIFF_MODE_VISUAL) {
  let diff2, additions, deletions;
  switch (selectedDiffContentMode) {
    case C$2.DIFF_MODE_VISUAL: {
      if (oldData.data === newData.data) {
        diff2 = newData.data;
        additions = deletions = 0;
      } else {
        ({ diff: diff2, additions, deletions } = await diffHtml(oldData.data, newData.data, context));
      }
      break;
    }
    case C$2.DIFF_MODE_TEXT: {
      if (oldData.text === newData.text) {
        diff2 = newData.text;
        additions = deletions = 0;
      } else {
        ({ diff: diff2, additions, deletions } = diffDMP(oldData.text, newData.text));
        diff2 = diff2.replace(/\&para;/g, "");
      }
      break;
    }
    case C$2.DIFF_MODE_SOURCE: {
      if (oldData.data === newData.data) {
        diff2 = "<html><body><span>" + htmlEscape(newData.data) + "</span></body></html>";
        additions = deletions = 0;
      } else {
        ({ diff: diff2, additions, deletions } = diffDMP(oldData.data, newData.data));
        diff2 = diff2.replace(/\&para;/g, "");
      }
      break;
    }
  }
  return { diff: diff2, additions, deletions };
}
async function diffSitemap(oldData, newData) {
  const { crawler_id: crawlerId, job_id: jobId1 } = newData;
  const { job_id: jobId2 } = oldData;
  let diffEndpoint = `/crawlers/data/${crawlerId}/diff/${jobId1}`;
  if (jobId2) {
    diffEndpoint += `?id2=${jobId2}`;
  }
  const diffData = await Api.api(diffEndpoint);
  const { summary, diff: diff2 } = diffData;
  return { diff: diff2, ...summary };
}
function htmlEscape(str) {
  return str.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;");
}
const Diff = {
  diffHtml,
  diffJson,
  diff: diffDMP,
  diffSieve,
  diffSitemap
};
function initStore() {
  const { subscribe: subscribe2, set, update } = writable({ sieve_data: null, data1: null, data2: null, diff: null, additions: 0, deletions: 0, type: null, uri: null });
  store = {
    subscribe: subscribe2,
    set,
    fetchSieveData: async function(sieveId, sieveDataId1, sieveDataId2) {
      try {
        const { data } = await Api.api(`/sieves/${sieveId}/data`, "GET");
        let index2 = -1, index22 = -1;
        if (!sieveDataId1 && !sieveDataId2) {
          index2 = 0;
          index22 = 0;
        } else if (sieveDataId1 && sieveDataId2) {
          index2 = data.findIndex((dat) => dat.id === sieveDataId1);
          index22 = data.findIndex((dat) => dat.id === sieveDataId2);
        } else if (sieveDataId1 && !sieveDataId2) {
          index2 = data.findIndex((dat) => dat.id === sieveDataId1);
          index22 = index2 + 1;
        } else if (!sieveDataId1 && sieveDataId2) {
          index22 = data.findIndex((dat) => dat.id === sieveDataId2);
          index2 = index22 - 1;
        }
        await this.init({ sieve_data: data, data1: data[index22], data2: data[index2] });
        if (index2 === -1 || index22 === -1) {
          this.setErrorMessage(T("m_invalid_sieve_data_id_explore_diff"));
        }
      } catch (e) {
        console.error(`error while fetching sieve data for the sieve`, sieveId, e);
      }
    },
    init: async function(data) {
      this.updateStore(data);
      if (data.data1 && data.data2) {
        await this.updateDiff(data);
      }
    },
    updateData1ById: function(id2) {
      const currStore = get_store_value(this);
      const data1 = currStore.sieve_data.find((data) => data.id === id2);
      this.updateDiff({ data1, data2: currStore.data2 });
    },
    updateData2ById: function(id2) {
      const currStore = get_store_value(this);
      const data2 = currStore.sieve_data.find((data) => data.id === id2);
      this.updateDiff({ data1: currStore.data1, data2 });
    },
    updateDiff: async function({ data1, data2 }) {
      let diffData = await this.getDiff(data1, data2);
      this.updateStore({ ...diffData, data1, data2 });
    },
    updateDiffContentMode: async function(diffContentMode = C$2.DIFF_MODE_VISUAL) {
      const currStore = get_store_value(this);
      this.updateStore({ diffContentMode });
      if (currStore.data1 && currStore.data2) {
        let diffData = await this.getDiff(currStore.data1, currStore.data2);
        this.updateStore({ ...diffData });
      }
    },
    setErrorMessage: function(errorMessage) {
      this.updateStore({ errorMessage });
    },
    getDiff: async function(data1, data2) {
      const { type, diffContentMode } = get_store_value(this);
      let content1 = data1.data;
      let content2 = data2.data;
      let diff2, additions = 0, deletions = 0;
      switch (type) {
        case C$2.TYPE_DOC:
        case C$2.TYPE_HTML:
        case C$2.TYPE_PDF_HTML:
          try {
            ({ diff: diff2, additions, deletions } = await Diff.diffSieve(data1, data2, data1.id + data2.id, diffContentMode));
          } catch (e) {
            diff2 = content2;
            console.error("error while generating the diff", e);
          }
          break;
        case C$2.TYPE_JSON:
          if (typeof content1 === "string") {
            content1 = JSON.parse(content1);
            data1.data = content1;
          }
          if (typeof content2 === "string") {
            content2 = JSON.parse(content2);
            data2.data = content2;
          }
          diff2 = await Diff.diffJson(content1, content2);
          ({ additions, deletions } = diff2);
          break;
        case C$2.TYPE_XML:
          ({ diff: diff2, additions, deletions } = Diff.diff(content1, content2));
          diff2 = diff2.replace(/\&para;/g, "");
          break;
        case C$2.TYPE_SITEMAP:
          if (typeof content1 === "string") {
            content1 = JSON.parse(content1);
            data1.data = content1;
          }
          if (typeof content2 === "string") {
            content2 = JSON.parse(content2);
            data2.data = content2;
          }
          ({ diff: diff2, additions, deletions } = await Diff.diffSitemap(content1, content2));
          break;
      }
      return { diff: diff2, additions, deletions };
    },
    updateStore: function(obj) {
      update((value) => {
        return { ...value, ...obj };
      });
    }
  };
  return store;
}
function destroyStore() {
  store = void 0;
}
let store;
function get_each_context$Q(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_each_block$Q(ctx) {
  let option;
  let t_value = new Date(ctx[8].ts_mod).toLocaleString() + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[8].id;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = new Date(ctx2[8].ts_mod).toLocaleString() + ""))
        set_data(t, t_value);
      if (dirty & 2 && option_value_value !== (option_value_value = ctx2[8].id)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$3J(ctx) {
  let div;
  let select;
  let select_class_value;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$Q(get_each_context$Q(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(select, "class", select_class_value = "form-select " + ctx[2]);
      attr(select, "title", ctx[3]);
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[6].call(select));
      attr(div, "class", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[0], true);
      if (!mounted) {
        dispose = [
          listen(select, "change", ctx[6]),
          listen(select, "change", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$Q(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$Q(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 4 && select_class_value !== (select_class_value = "form-select " + ctx2[2])) {
        attr(select, "class", select_class_value);
      }
      if (dirty & 8) {
        attr(select, "title", ctx2[3]);
      }
      if (dirty & 3) {
        select_option(select, ctx2[0]);
      }
      if (dirty & 16) {
        attr(div, "class", ctx2[4]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3z($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { timestamps } = $$props;
  let { value } = $$props;
  let { selectClass = "" } = $$props;
  let { title } = $$props;
  let { class: classes2 = "" } = $$props;
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(0, value);
    $$invalidate(1, timestamps);
  }
  const change_handler = (e) => dispatch("change", { value: e.target.value });
  $$self.$$set = ($$props2) => {
    if ("timestamps" in $$props2)
      $$invalidate(1, timestamps = $$props2.timestamps);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("selectClass" in $$props2)
      $$invalidate(2, selectClass = $$props2.selectClass);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
    if ("class" in $$props2)
      $$invalidate(4, classes2 = $$props2.class);
  };
  return [
    value,
    timestamps,
    selectClass,
    title,
    classes2,
    dispatch,
    select_change_handler,
    change_handler
  ];
}
class DateSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3z, create_fragment$3J, safe_not_equal, {
      timestamps: 1,
      value: 0,
      selectClass: 2,
      title: 3,
      class: 4
    });
  }
}
function create_fragment$3I(ctx) {
  let div;
  let span1;
  let span0;
  let t0;
  let t1;
  let t2;
  let span4;
  let span2;
  let t3;
  let span3;
  return {
    c() {
      div = element("div");
      span1 = element("span");
      span0 = element("span");
      t0 = text(ctx[0]);
      t1 = text("+");
      t2 = space();
      span4 = element("span");
      span2 = element("span");
      t3 = text(ctx[1]);
      span3 = element("span");
      span3.textContent = "\u2013";
      attr(span1, "class", "text-green-700 font-bold");
      set_style(span3, "font-size", "1.1em");
      set_style(span3, "line-height", "1.1");
      attr(span4, "class", "text-red-700 font-bold");
      attr(div, "class", ctx[2]);
      attr(div, "title", T("l_diff_stats"));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span1);
      append(span1, span0);
      append(span0, t0);
      append(span1, t1);
      append(div, t2);
      append(div, span4);
      append(span4, span2);
      append(span2, t3);
      append(span4, span3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (dirty & 2)
        set_data(t3, ctx2[1]);
      if (dirty & 4) {
        attr(div, "class", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$3y($$self, $$props, $$invalidate) {
  let { additions } = $$props;
  let { deletions } = $$props;
  let { class: classes2 = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("additions" in $$props2)
      $$invalidate(0, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(1, deletions = $$props2.deletions);
    if ("class" in $$props2)
      $$invalidate(2, classes2 = $$props2.class);
  };
  return [additions, deletions, classes2];
}
class DiffStats extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3y, create_fragment$3I, safe_not_equal, { additions: 0, deletions: 1, class: 2 });
  }
}
var ExploreDiffHeader_svelte_svelte_type_style_lang = "";
function create_if_block_3$E(ctx) {
  let div;
  let button0;
  let t0_value = T("a_side_by_side_diff") + "";
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2_value = T("a_inline_diff") + "";
  let t2;
  let button1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      attr(button0, "class", button0_class_value = "btn btn-default flex-grow " + (!ctx[1] ? "btn-primary min-w-0 active" : ""));
      attr(button1, "class", button1_class_value = "btn btn-default flex-grow " + (ctx[1] ? "btn-primary min-w-0 active" : ""));
      attr(div, "class", "btn-group btn-toggle flex btn-group-sm");
      attr(div, "role", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[12]),
          listen(button1, "click", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && button0_class_value !== (button0_class_value = "btn btn-default flex-grow " + (!ctx2[1] ? "btn-primary min-w-0 active" : ""))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty & 2 && button1_class_value !== (button1_class_value = "btn btn-default flex-grow " + (ctx2[1] ? "btn-primary min-w-0 active" : ""))) {
        attr(button1, "class", button1_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$Q(ctx) {
  let div;
  let button0;
  let t0_value = T("a_styled_page") + "";
  let t0;
  let button0_class_value;
  let button1;
  let t1_value = T("a_unstyled_page") + "";
  let t1;
  let button1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      button1 = element("button");
      t1 = text(t1_value);
      attr(button0, "class", button0_class_value = "btn btn-default " + (!ctx[2] ? "btn-primary min-w-0 active" : ""));
      attr(button1, "class", button1_class_value = "btn btn-default " + (ctx[2] ? "btn-primary min-w-0 active" : ""));
      attr(div, "class", "btn-group btn-toggle no-wrap flex conceal btn-group-sm svelte-gdbbe6");
      attr(div, "role", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, button1);
      append(button1, t1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[14]),
          listen(button1, "click", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4 && button0_class_value !== (button0_class_value = "btn btn-default " + (!ctx2[2] ? "btn-primary min-w-0 active" : ""))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty & 4 && button1_class_value !== (button1_class_value = "btn btn-default " + (ctx2[2] ? "btn-primary min-w-0 active" : ""))) {
        attr(button1, "class", button1_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_catch_block_1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1(ctx) {
  var _a, _b;
  let t0;
  let div1;
  let dateselect0;
  let t1;
  let div0;
  let t2;
  let dateselect1;
  let t3;
  let a;
  let i1;
  let a_href_value;
  let current;
  let if_block = ctx[0] && create_if_block_1$1d(ctx);
  dateselect0 = new DateSelect({
    props: {
      timestamps: ctx[8].sieve_data,
      value: (_a = ctx[8].data1) == null ? void 0 : _a.id,
      title: T("l_sieve_to_compare")
    }
  });
  dateselect0.$on("change", ctx[19]);
  dateselect1 = new DateSelect({
    props: {
      timestamps: ctx[8].sieve_data,
      value: (_b = ctx[8].data2) == null ? void 0 : _b.id,
      title: T("l_sieve_to_compare_with")
    }
  });
  dateselect1.$on("change", ctx[20]);
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      div1 = element("div");
      create_component(dateselect0.$$.fragment);
      t1 = space();
      div0 = element("div");
      div0.innerHTML = `<i class="fa fa-arrow-right"></i>`;
      t2 = space();
      create_component(dateselect1.$$.fragment);
      t3 = space();
      a = element("a");
      i1 = element("i");
      attr(div0, "class", "flex items-center");
      attr(div1, "class", "flex items-center gap-2");
      attr(i1, "class", "fa fa-external-link");
      attr(a, "href", a_href_value = ctx[8].uri);
      attr(a, "class", "btn btn-default");
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      mount_component(dateselect0, div1, null);
      append(div1, t1);
      append(div1, div0);
      append(div1, t2);
      mount_component(dateselect1, div1, null);
      insert(target, t3, anchor);
      insert(target, a, anchor);
      append(a, i1);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1d(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const dateselect0_changes = {};
      if (dirty & 256)
        dateselect0_changes.timestamps = ctx2[8].sieve_data;
      if (dirty & 256)
        dateselect0_changes.value = (_a2 = ctx2[8].data1) == null ? void 0 : _a2.id;
      dateselect0.$set(dateselect0_changes);
      const dateselect1_changes = {};
      if (dirty & 256)
        dateselect1_changes.timestamps = ctx2[8].sieve_data;
      if (dirty & 256)
        dateselect1_changes.value = (_b2 = ctx2[8].data2) == null ? void 0 : _b2.id;
      dateselect1.$set(dateselect1_changes);
      if (!current || dirty & 256 && a_href_value !== (a_href_value = ctx2[8].uri)) {
        attr(a, "href", a_href_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(dateselect0.$$.fragment, local);
      transition_in(dateselect1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateselect0.$$.fragment, local);
      transition_out(dateselect1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      destroy_component(dateselect0);
      destroy_component(dateselect1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_1$1d(ctx) {
  let div;
  let button0;
  let t0_value = T("l_visual") + "";
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2_value = T("l_text") + "";
  let t2;
  let button1_class_value;
  let t3;
  let button2;
  let t4_value = T("l_source") + "";
  let t4;
  let button2_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      button2 = element("button");
      t4 = text(t4_value);
      attr(button0, "class", button0_class_value = "btn btn-default flex-grow " + (C$2.DIFF_MODE_VISUAL === ctx[0] ? "btn-primary min-w-0 active" : ""));
      attr(button1, "class", button1_class_value = "btn btn-default flex-grow " + (C$2.DIFF_MODE_TEXT === ctx[0] ? "btn-primary min-w-0 active" : ""));
      attr(button2, "class", button2_class_value = "btn btn-default flex-grow " + (C$2.DIFF_MODE_SOURCE === ctx[0] ? "btn-primary min-w-0 active" : ""));
      attr(div, "class", "btn-group btn-toggle flex btn-group-sm");
      attr(div, "role", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      append(div, t3);
      append(div, button2);
      append(button2, t4);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[16]),
          listen(button1, "click", ctx[17]),
          listen(button2, "click", ctx[18])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && button0_class_value !== (button0_class_value = "btn btn-default flex-grow " + (C$2.DIFF_MODE_VISUAL === ctx2[0] ? "btn-primary min-w-0 active" : ""))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty & 1 && button1_class_value !== (button1_class_value = "btn btn-default flex-grow " + (C$2.DIFF_MODE_TEXT === ctx2[0] ? "btn-primary min-w-0 active" : ""))) {
        attr(button1, "class", button1_class_value);
      }
      if (dirty & 1 && button2_class_value !== (button2_class_value = "btn btn-default flex-grow " + (C$2.DIFF_MODE_SOURCE === ctx2[0] ? "btn-primary min-w-0 active" : ""))) {
        attr(button2, "class", button2_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_pending_block_1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_catch_block$q(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$q(ctx) {
  let div;
  let diffstats;
  let current;
  diffstats = new DiffStats({
    props: {
      additions: ctx[8].additions,
      deletions: ctx[8].deletions,
      class: "bg-white border-[1px] border-[#cccccc] border-solid p-2 rounded-md "
    }
  });
  return {
    c() {
      div = element("div");
      create_component(diffstats.$$.fragment);
      attr(div, "class", "flex mr-5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(diffstats, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const diffstats_changes = {};
      if (dirty & 256)
        diffstats_changes.additions = ctx2[8].additions;
      if (dirty & 256)
        diffstats_changes.deletions = ctx2[8].deletions;
      diffstats.$set(diffstats_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffstats.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffstats.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(diffstats);
    }
  };
}
function create_pending_block$q(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_if_block$1Q(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      attr(button, "class", "btn-close");
      attr(button, "title", T("a_close"));
      attr(div, "class", "flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[21]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3H(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let promise_1;
  let t2;
  let div1;
  let promise_2;
  let t3;
  let div2_class_value;
  let current;
  let if_block0 = ctx[3] && create_if_block_3$E(ctx);
  let if_block1 = ctx[4] && create_if_block_2$Q(ctx);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 22,
    blocks: [, , ,]
  };
  handle_promise(promise_1 = ctx[6], info);
  let info_1 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$q,
    then: create_then_block$q,
    catch: create_catch_block$q,
    value: 22,
    blocks: [, , ,]
  };
  handle_promise(promise_2 = ctx[6], info_1);
  let if_block2 = ctx[5] && create_if_block$1Q(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      info.block.c();
      t2 = space();
      div1 = element("div");
      info_1.block.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "flex gap-4 no-wrap");
      attr(div1, "class", "flex items-center");
      attr(div2, "class", div2_class_value = "card-header px-3 py-2 xpanel-heading-alt flex justify-between gap-8 items-stretch no-wrap " + ctx[7] + " svelte-gdbbe6");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append(div0, t1);
      info.block.m(div0, info.anchor = null);
      info.mount = () => div0;
      info.anchor = null;
      append(div2, t2);
      append(div2, div1);
      info_1.block.m(div1, info_1.anchor = null);
      info_1.mount = () => div1;
      info_1.anchor = t3;
      append(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[3]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_3$E(ctx);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx[4]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2$Q(ctx);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      info.ctx = ctx;
      if (dirty & 64 && promise_1 !== (promise_1 = ctx[6]) && handle_promise(promise_1, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      info_1.ctx = ctx;
      if (dirty & 64 && promise_2 !== (promise_2 = ctx[6]) && handle_promise(promise_2, info_1))
        ;
      else {
        update_await_block_branch(info_1, ctx, dirty);
      }
      if (ctx[5]) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block$1Q(ctx);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & 128 && div2_class_value !== (div2_class_value = "card-header px-3 py-2 xpanel-heading-alt flex justify-between gap-8 items-stretch no-wrap " + ctx[7] + " svelte-gdbbe6")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      transition_in(info_1.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info_1.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      info.block.d();
      info.token = null;
      info = null;
      info_1.block.d();
      info_1.token = null;
      info_1 = null;
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$3x($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(8, $store = $$value));
  const dispatch = createEventDispatcher();
  let { showDiffMode = true } = $$props;
  let { showStyleMode = true } = $$props;
  let { showCloseButton = false } = $$props;
  let { inlined = false } = $$props;
  let { withoutStyle = false } = $$props;
  let { promise } = $$props;
  let { selectedDiffContentMode } = $$props;
  let { class: classes2 = "" } = $$props;
  function showDiffInline(value) {
    $$invalidate(1, inlined = value);
  }
  function removeStyles(value) {
    $$invalidate(2, withoutStyle = value);
  }
  const click_handler = () => showDiffInline(false);
  const click_handler_1 = () => showDiffInline(true);
  const click_handler_2 = () => removeStyles(false);
  const click_handler_3 = () => removeStyles(true);
  const click_handler_4 = () => {
    $$invalidate(0, selectedDiffContentMode = C$2.DIFF_MODE_VISUAL);
  };
  const click_handler_5 = () => {
    $$invalidate(0, selectedDiffContentMode = C$2.DIFF_MODE_TEXT);
  };
  const click_handler_6 = () => {
    $$invalidate(0, selectedDiffContentMode = C$2.DIFF_MODE_SOURCE);
  };
  const change_handler = (e) => store.updateData1ById(e.detail.value);
  const change_handler_1 = (e) => store.updateData2ById(e.detail.value);
  const click_handler_7 = () => dispatch("close");
  $$self.$$set = ($$props2) => {
    if ("showDiffMode" in $$props2)
      $$invalidate(3, showDiffMode = $$props2.showDiffMode);
    if ("showStyleMode" in $$props2)
      $$invalidate(4, showStyleMode = $$props2.showStyleMode);
    if ("showCloseButton" in $$props2)
      $$invalidate(5, showCloseButton = $$props2.showCloseButton);
    if ("inlined" in $$props2)
      $$invalidate(1, inlined = $$props2.inlined);
    if ("withoutStyle" in $$props2)
      $$invalidate(2, withoutStyle = $$props2.withoutStyle);
    if ("promise" in $$props2)
      $$invalidate(6, promise = $$props2.promise);
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(0, selectedDiffContentMode = $$props2.selectedDiffContentMode);
    if ("class" in $$props2)
      $$invalidate(7, classes2 = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      store.updateDiffContentMode(selectedDiffContentMode);
    }
  };
  return [
    selectedDiffContentMode,
    inlined,
    withoutStyle,
    showDiffMode,
    showStyleMode,
    showCloseButton,
    promise,
    classes2,
    $store,
    dispatch,
    showDiffInline,
    removeStyles,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    change_handler,
    change_handler_1,
    click_handler_7
  ];
}
class ExploreDiffHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3x, create_fragment$3H, safe_not_equal, {
      showDiffMode: 3,
      showStyleMode: 4,
      showCloseButton: 5,
      inlined: 1,
      withoutStyle: 2,
      promise: 6,
      selectedDiffContentMode: 0,
      class: 7
    });
  }
}
function create_else_block$$(ctx) {
  let span;
  let t0;
  let t1;
  let if_block_anchor;
  let if_block = ctx[2] && create_if_block_1$1c(ctx);
  return {
    c() {
      span = element("span");
      t0 = text(ctx[0]);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1c(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$1P(ctx) {
  let span;
  let t0_value = ctx[0].replace(/\s/g, " ").substring(0, ctx[1]) + "";
  let t0;
  let t1;
  let t2;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text("...");
      t2 = space();
      button = element("button");
      button.textContent = ">>";
      attr(button, "class", "btn btn-default btn-sm py-[2px] px-[4px] shadow-sm bg-[#eee] font-bold");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      insert(target, t2, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 3 && t0_value !== (t0_value = ctx2[0].replace(/\s/g, " ").substring(0, ctx2[1]) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1c(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "<<";
      attr(button, "class", "btn btn-default btn-sm py-[2px] px-[4px] shadow-sm bg-[#eee] font-bold");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3G(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2] && !ctx2[3])
      return create_if_block$1P;
    return create_else_block$$;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3w($$self, $$props, $$invalidate) {
  let { content } = $$props;
  let { limit: limit2 = 100 } = $$props;
  let limitExceeded = false;
  let showMore = false;
  const click_handler = () => $$invalidate(3, showMore = true);
  const click_handler_1 = () => $$invalidate(3, showMore = false);
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
    if ("limit" in $$props2)
      $$invalidate(1, limit2 = $$props2.limit);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      if (typeof content === "string") {
        $$invalidate(2, limitExceeded = content.length > limit2);
      }
    }
  };
  return [content, limit2, limitExceeded, showMore, click_handler, click_handler_1];
}
class NodeValue extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3w, create_fragment$3G, safe_not_equal, { content: 0, limit: 1 });
  }
}
function create_fragment$3F(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "#183a90");
      attr(path, "d", "M25.198,6.273c-0.014,0.23-0.045,0.389-0.087,0.467c-0.045,0.084-0.176,0.145-0.392,0.183 c-0.469,0.104-0.781-0.074-0.935-0.533C23.239,4.7,22.59,3.578,21.84,3.016c-1.041-0.773-2.862-1.161-5.469-1.161 c-1.054,0-1.633,0.115-1.734,0.343c-0.036,0.075-0.057,0.184-0.057,0.324v18.999c0,0.812,0.188,1.383,0.571,1.709 c0.382,0.32,1.069,0.731,2.201,0.999c0.483,0.103,0.97,0.2,1.034,0.239c0.46,0,0.504,1.057-0.376,1.057 c-0.025,0.016-10.375-0.008-10.375-0.008s-0.723-0.439-0.074-1.023c0.271-0.121,0.767-0.343,0.767-0.343s1.83-0.614,2.211-1.009 c0.434-0.445,0.648-1.164,0.648-2.154V2.521c0-0.369-0.229-0.585-0.687-0.647c-0.049-0.015-0.425-0.02-1.122-0.02 c-2.415,0-4.191,0.418-5.338,1.259C3.176,3.735,2.411,4.877,1.737,6.545C1.52,7.065,1.22,7.234,0.84,7.058 C0.408,6.957,0.251,6.719,0.363,6.353c0.445-1.374,0.668-3.31,0.668-5.814c0-0.292,0.387-0.586,1.163-0.533L23.56,0.064 c0.709-0.104,1.096,0.012,1.16,0.343C25.076,2.096,25.234,4.052,25.198,6.273z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "70%");
      attr(svg, "height", "90%");
      attr(svg, "viewBox", "0 0 25 25");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class StringSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$3F, safe_not_equal, {});
  }
}
function create_fragment$3E(ctx) {
  let svg;
  let g1;
  let g0;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g1 = svg_element("g");
      g0 = svg_element("g");
      path = svg_element("path");
      attr(path, "fill", "#41b310");
      attr(path, "d", "M17.2881302,2.00089344 L17.3894,2.01308 C17.7964,2.09007 18.064,2.48242 17.987,2.88941 L17.987,2.88941 L17.0214,7.99404 L21.2496,7.99207 C21.6639,7.99187 21.9998,8.3275 21.9999999,8.74172 C21.9999999,9.15593 21.6646,9.49187 21.2503,9.49207 L21.2503,9.49207 L16.7376,9.49417 L15.7919,14.4939 L20.2496,14.4918 C20.6639,14.4916 20.9998,14.8273 20.9999999,15.2415 C21.0002,15.6557 20.6646,15.9916 20.2503,15.9918 L20.2503,15.9918 L15.5081,15.994 L14.4869,21.3924 C14.41,21.7994 14.0176,22.0669 13.6106,21.9899 C13.2036,21.9129 12.9361,21.5206 13.0131,21.1136 L13.0131,21.1136 L13.9814,15.9948 L8.50742,15.9973 L7.48688,21.3924 C7.4099,21.7994 7.01755,22.0669 6.61055,21.9899 C6.20356,21.9129 5.93603,21.5206 6.01302,21.1136 L6.01302,21.1136 L6.98068,15.998 L2.75035,16 C2.33614,16.0002 1.99999992,15.6646 1.99999992,15.2503 C1.99999992,14.8361 2.33544,14.5002 2.74965,14.5 L2.74965,14.5 L7.26445,14.4979 L8.2102,9.49816 L3.75035,9.50024 C3.33614,9.50044 3.00019,9.16481 2.99999992,8.75059 C2.99981,8.33638 3.33544,8.00044 3.74965,8.00024 L3.74965,8.00024 L8.49396,7.99803 L9.51305,2.61062 C9.59003,2.20362 9.98238,1.9361 10.3894,2.01308 C10.7964,2.09007 11.0639,2.48242 10.9869,2.88941 L10.9869,2.88941 L10.0207,7.99731 L15.4946,7.99476 L16.5131,2.61062 C16.5901,2.20362 16.9824,1.9361 17.3894,2.01308 Z M15.2109,9.49489 L9.73693,9.49745 L8.79118,14.4972 L14.2651,14.4946 L15.2109,9.49489 Z");
      attr(g0, "id", "ic_fluent_number_symbol_24_regular");
      attr(g0, "fill", "#212121");
      attr(g0, "fill-rule", "nonzero");
      attr(g1, "stroke", "none");
      attr(g1, "stroke-width", "1");
      attr(g1, "fill", "none");
      attr(g1, "fill-rule", "evenodd");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g1);
      append(g1, g0);
      append(g0, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class NumberSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$3E, safe_not_equal, {});
  }
}
function create_fragment$3D(ctx) {
  let svg;
  let g;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "fill", "#0cc8d2");
      attr(path1, "d", "M9 3v2H6v14h3v2H4V3h5zm6 0h5v18h-5v-2h3V5h-3V3z");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path0);
      append(g, path1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class ArraySVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$3D, safe_not_equal, {});
  }
}
function create_fragment$3C(ctx) {
  let svg;
  let g;
  let t;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      t = text("null\n    ");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "fill", "#bf3126");
      attr(path1, "d", "M4 18v-3.7a1.5 1.5 0 0 0-1.5-1.5H2v-1.6h.5A1.5 1.5 0 0 0 4 9.7V6a3 3 0 0 1 3-3h1v2H7a1 1 0 0 0-1 1v4.1A2 2 0 0 1 4.626 12 2 2 0 0 1 6 13.9V18a1 1 0 0 0 1 1h1v2H7a3 3 0 0 1-3-3zm16-3.7V18a3 3 0 0 1-3 3h-1v-2h1a1 1 0 0 0 1-1v-4.1a2 2 0 0 1 1.374-1.9A2 2 0 0 1 18 10.1V6a1 1 0 0 0-1-1h-1V3h1a3 3 0 0 1 3 3v3.7a1.5 1.5 0 0 0 1.5 1.5h.5v1.6h-.5a1.5 1.5 0 0 0-1.5 1.5z");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, t);
      append(g, path0);
      append(g, path1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class ObjectSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$3C, safe_not_equal, {});
  }
}
function create_fragment$3B(ctx) {
  let svg;
  let defs2;
  let style;
  let t;
  let path;
  let circle;
  let rect;
  return {
    c() {
      svg = svg_element("svg");
      defs2 = svg_element("defs");
      style = svg_element("style");
      t = text(".cls-1{fill:none}");
      path = svg_element("path");
      circle = svg_element("circle");
      rect = svg_element("rect");
      attr(path, "fill", "#ec8f0c");
      attr(path, "d", "M23,23a7,7,0,1,1,7-7A7.0078,7.0078,0,0,1,23,23Zm0-12a5,5,0,1,0,5,5A5.0055,5.0055,0,0,0,23,11Z");
      attr(circle, "fill", "#ec8f0c");
      attr(circle, "cx", "9");
      attr(circle, "cy", "16");
      attr(circle, "r", "7");
      attr(rect, "id", "_Transparent_Rectangle_");
      attr(rect, "data-name", "<Transparent Rectangle>");
      attr(rect, "class", "cls-1");
      attr(rect, "width", "32");
      attr(rect, "height", "32");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "120%");
      attr(svg, "height", "120%");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, defs2);
      append(defs2, style);
      append(style, t);
      append(svg, path);
      append(svg, circle);
      append(svg, rect);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class BooleanSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$3B, safe_not_equal, {});
  }
}
function create_else_block$_(ctx) {
  let objectsvg;
  let current;
  objectsvg = new ObjectSVG({});
  return {
    c() {
      create_component(objectsvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(objectsvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(objectsvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(objectsvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(objectsvg, detaching);
    }
  };
}
function create_if_block_3$D(ctx) {
  let arraytypesvg;
  let current;
  arraytypesvg = new ArraySVG({});
  return {
    c() {
      create_component(arraytypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arraytypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(arraytypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arraytypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arraytypesvg, detaching);
    }
  };
}
function create_if_block_2$P(ctx) {
  let booleantypesvg;
  let current;
  booleantypesvg = new BooleanSVG({});
  return {
    c() {
      create_component(booleantypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(booleantypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(booleantypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(booleantypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(booleantypesvg, detaching);
    }
  };
}
function create_if_block_1$1b(ctx) {
  let numbertypesvg;
  let current;
  numbertypesvg = new NumberSVG({});
  return {
    c() {
      create_component(numbertypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numbertypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(numbertypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numbertypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numbertypesvg, detaching);
    }
  };
}
function create_if_block$1O(ctx) {
  let stringtypesvg;
  let current;
  stringtypesvg = new StringSVG({});
  return {
    c() {
      create_component(stringtypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(stringtypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(stringtypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(stringtypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(stringtypesvg, detaching);
    }
  };
}
function create_fragment$3A(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block$1O,
    create_if_block_1$1b,
    create_if_block_2$P,
    create_if_block_3$D,
    create_else_block$_
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === types.STRING)
      return 0;
    if (ctx2[0] === types.NUMBER)
      return 1;
    if (ctx2[0] === types.BOOLEAN)
      return 2;
    if (ctx2[0] === types.ARRAY || ctx2[0] === types.ARRAY_OF_OBJECTS)
      return 3;
    return 4;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3v($$self, $$props, $$invalidate) {
  let { type } = $$props;
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
  };
  return [type];
}
class TypeSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3v, create_fragment$3A, safe_not_equal, { type: 0 });
  }
}
function create_fragment$3z(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      attr(rect, "fill", "white");
      attr(rect, "fill-opacity", "0.01");
      attr(path, "d", "M24 33C28.9706 33 33 28.9706 33 24C33 19.0294 28.9706 15 24 15C19.0294 15 15 19.0294 15 24C15 28.9706 19.0294 33 24 33Z");
      attr(path, "fill", "blue");
      attr(path, "stroke", "blue");
      attr(path, "stroke-width", "4");
      attr(svg, "viewBox", "0 0 64 64");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, rect);
      append(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class DirtySVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$3z, safe_not_equal, {});
  }
}
var diff$1 = "";
var DiffJsonView_svelte_svelte_type_style_lang = "";
function create_catch_block$p(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$p(ctx) {
  let div1;
  let div0;
  let treeview;
  let div1_class_value;
  let current;
  treeview = new TreeView$1({
    props: {
      root: ctx[0],
      size: "medium",
      class: " bg-white bb bl br bt border-bootstrap-border " + ctx[7],
      nodeAction: ctx[10],
      $$slots: {
        meta: [
          create_meta_slot$1,
          ({ node: node2 }) => ({ 35: node2 }),
          ({ node: node2 }) => [0, node2 ? 16 : 0]
        ],
        icon: [
          create_icon_slot$4,
          ({ node: node2 }) => ({ 35: node2 }),
          ({ node: node2 }) => [0, node2 ? 16 : 0]
        ],
        label: [
          create_label_slot$1,
          ({ node: node2 }) => ({ 35: node2 }),
          ({ node: node2 }) => [0, node2 ? 16 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(treeview.$$.fragment);
      attr(div0, "class", "w-full h-full");
      attr(div1, "class", div1_class_value = null_to_empty(ctx[8]) + " svelte-is15v7");
      set_style(div1, "--max-depth", ctx[9]());
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(treeview, div0, null);
      ctx[22](div1);
      current = true;
    },
    p(ctx2, dirty) {
      const treeview_changes = {};
      if (dirty[0] & 1)
        treeview_changes.root = ctx2[0];
      if (dirty[0] & 128)
        treeview_changes.class = " bg-white bb bl br bt border-bootstrap-border " + ctx2[7];
      if (dirty[0] & 120 | dirty[1] & 48) {
        treeview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeview.$set(treeview_changes);
      if (!current || dirty[0] & 256 && div1_class_value !== (div1_class_value = null_to_empty(ctx2[8]) + " svelte-is15v7")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(treeview);
      ctx[22](null);
    }
  };
}
function create_label_slot$1(ctx) {
  let div;
  let t_value = (ctx[35].label !== void 0 ? ctx[35].label : "") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "slot", "label");
      attr(div, "class", "xbreak-long-words xpadding svelte-is15v7");
      toggle_class(div, "inserted", ctx[35].changeType === ChangeType.ADDED && ctx[35].label !== void 0);
      toggle_class(div, "removed", ctx[35].changeType === ChangeType.DELETED && ctx[35].label !== void 0);
      toggle_class(div, "xdiff", ctx[35].changeType);
      toggle_class(div, "opacity-0", ctx[35].changeType === ChangeType.ADDED && ctx[5] || ctx[35].changeType === ChangeType.DELETED && ctx[4]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[1] & 16 && t_value !== (t_value = (ctx2[35].label !== void 0 ? ctx2[35].label : "") + ""))
        set_data(t, t_value);
      if (dirty[1] & 16) {
        toggle_class(div, "inserted", ctx2[35].changeType === ChangeType.ADDED && ctx2[35].label !== void 0);
      }
      if (dirty[1] & 16) {
        toggle_class(div, "removed", ctx2[35].changeType === ChangeType.DELETED && ctx2[35].label !== void 0);
      }
      if (dirty[1] & 16) {
        toggle_class(div, "xdiff", ctx2[35].changeType);
      }
      if (dirty[0] & 48 | dirty[1] & 16) {
        toggle_class(div, "opacity-0", ctx2[35].changeType === ChangeType.ADDED && ctx2[5] || ctx2[35].changeType === ChangeType.DELETED && ctx2[4]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$O(ctx) {
  let div;
  let current;
  let if_block = ctx[35].dirty && create_if_block_3$C();
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "xdirty svelte-is15v7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[35].dirty) {
        if (if_block) {
          if (dirty[1] & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$C();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_3$C(ctx) {
  let dirtysvg;
  let current;
  dirtysvg = new DirtySVG({});
  return {
    c() {
      create_component(dirtysvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dirtysvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(dirtysvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dirtysvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dirtysvg, detaching);
    }
  };
}
function create_icon_slot$4(ctx) {
  let div1;
  let t;
  let div0;
  let typesvg;
  let div0_title_value;
  let current;
  let if_block = ctx[6] && ctx[3] && create_if_block_2$O(ctx);
  typesvg = new TypeSVG({ props: { type: ctx[35].type } });
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      create_component(typesvg.$$.fragment);
      attr(div0, "class", "tv-svg");
      attr(div0, "title", div0_title_value = ctx[35].type);
      attr(div1, "slot", "icon");
      attr(div1, "class", "tv-flex tv-svg-parent");
      toggle_class(div1, "opacity-0", ctx[35].changeType === ChangeType.ADDED && ctx[5] || ctx[35].changeType === ChangeType.DELETED && ctx[4]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t);
      append(div1, div0);
      mount_component(typesvg, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[6] && ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 72) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$O(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const typesvg_changes = {};
      if (dirty[1] & 16)
        typesvg_changes.type = ctx2[35].type;
      typesvg.$set(typesvg_changes);
      if (!current || dirty[1] & 16 && div0_title_value !== (div0_title_value = ctx2[35].type)) {
        attr(div0, "title", div0_title_value);
      }
      if (!current || dirty[0] & 48 | dirty[1] & 16) {
        toggle_class(div1, "opacity-0", ctx2[35].changeType === ChangeType.ADDED && ctx2[5] || ctx2[35].changeType === ChangeType.DELETED && ctx2[4]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(typesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(typesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_component(typesvg);
    }
  };
}
function create_if_block_1$1a(ctx) {
  let div;
  let nodevalue;
  let current;
  nodevalue = new NodeValue({
    props: {
      content: ctx[35].getPrettyOldValue()
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nodevalue.$$.fragment);
      attr(div, "class", "xbreak-long-words removed flex-grow xpadding svelte-is15v7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nodevalue, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nodevalue_changes = {};
      if (dirty[1] & 16)
        nodevalue_changes.content = ctx2[35].getPrettyOldValue();
      nodevalue.$set(nodevalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodevalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodevalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(nodevalue);
    }
  };
}
function create_if_block$1N(ctx) {
  let div;
  let nodevalue;
  let current;
  nodevalue = new NodeValue({
    props: {
      content: ctx[35].getPrettyValue()
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nodevalue.$$.fragment);
      attr(div, "class", "xbreak-long-words flex-grow xpadding svelte-is15v7");
      toggle_class(div, "inserted", (ctx[35].changeType === ChangeType.ADDED || ctx[35].changeType === ChangeType.VALUE_CHANGED) && ctx[35].isLeaf() && ctx[35].value !== void 0);
      toggle_class(div, "removed", ctx[35].changeType === ChangeType.DELETED && ctx[35].isLeaf());
      toggle_class(div, "opacity-0", ctx[35].changeType && ctx[35].changeType === ChangeType.ADDED && ctx[5] || ctx[35].changeType === ChangeType.DELETED && ctx[4]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nodevalue, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nodevalue_changes = {};
      if (dirty[1] & 16)
        nodevalue_changes.content = ctx2[35].getPrettyValue();
      nodevalue.$set(nodevalue_changes);
      if (!current || dirty[1] & 16) {
        toggle_class(div, "inserted", (ctx2[35].changeType === ChangeType.ADDED || ctx2[35].changeType === ChangeType.VALUE_CHANGED) && ctx2[35].isLeaf() && ctx2[35].value !== void 0);
      }
      if (!current || dirty[1] & 16) {
        toggle_class(div, "removed", ctx2[35].changeType === ChangeType.DELETED && ctx2[35].isLeaf());
      }
      if (!current || dirty[0] & 48 | dirty[1] & 16) {
        toggle_class(div, "opacity-0", ctx2[35].changeType && ctx2[35].changeType === ChangeType.ADDED && ctx2[5] || ctx2[35].changeType === ChangeType.DELETED && ctx2[4]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(nodevalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodevalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(nodevalue);
    }
  };
}
function create_meta_slot$1(ctx) {
  let div;
  let show_if = ctx[35].changeType === ChangeType.VALUE_CHANGED && ctx[35].isLeaf() && ctx[35].oldValue !== void 0 && !ctx[4];
  let t;
  let div_title_value;
  let current;
  let if_block0 = show_if && create_if_block_1$1a(ctx);
  let if_block1 = !(ctx[35].changeType === ChangeType.VALUE_CHANGED && ctx[5]) && create_if_block$1N(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div, "slot", "meta");
      attr(div, "title", div_title_value = ctx[35].getValue());
      attr(div, "class", "flex gap-2 xl:flex-1");
      toggle_class(div, "xdiffMeta", ctx[35].changeType === ChangeType.VALUE_CHANGED && ctx[35].oldValue !== void 0 && ctx[35].value !== void 0);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 | dirty[1] & 16)
        show_if = ctx2[35].changeType === ChangeType.VALUE_CHANGED && ctx2[35].isLeaf() && ctx2[35].oldValue !== void 0 && !ctx2[4];
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 16 | dirty[1] & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$1a(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!(ctx2[35].changeType === ChangeType.VALUE_CHANGED && ctx2[5])) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 32 | dirty[1] & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1N(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[1] & 16 && div_title_value !== (div_title_value = ctx2[35].getValue())) {
        attr(div, "title", div_title_value);
      }
      if (!current || dirty[1] & 16) {
        toggle_class(div, "xdiffMeta", ctx2[35].changeType === ChangeType.VALUE_CHANGED && ctx2[35].oldValue !== void 0 && ctx2[35].value !== void 0);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_pending_block$p(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$3y(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$p,
    then: create_then_block$p,
    catch: create_catch_block$p,
    value: 34,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[1], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty[0] & 2 && promise !== (promise = ctx[1]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$3u($$self, $$props, $$invalidate) {
  let { oldData } = $$props;
  let { newData } = $$props;
  let { diff: diff2 } = $$props;
  let { jsonDiffPromise } = $$props;
  let { full = true } = $$props;
  let { pruneDeletions = false } = $$props;
  let { pruneAdditions = false } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { hideDeletions = false } = $$props;
  let { hideAdditions = false } = $$props;
  let { showDirty = false } = $$props;
  let { treeViewClass = "" } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { diffNavigation = false } = $$props;
  let { diffView } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  const dispatch = createEventDispatcher();
  let { class: classes2 = "" } = $$props;
  let maxDepth;
  let diffs = { nodes: [], curr: null };
  let currDiff;
  let computeDiff = oldData && newData;
  let init2 = !computeDiff;
  const STEP = { NEXT: 1, PREV: -1 };
  async function getDiff2(oldData2, newData2, options = {}) {
    init2 = false;
    const { full: full2 } = options;
    if (typeof oldData2 === "string") {
      oldData2 = JSON.parse(oldData2);
    }
    if (typeof newData2 === "string") {
      newData2 = JSON.parse(newData2);
    }
    $$invalidate(0, diff2 = await Diff.diffJson(oldData2, newData2, { full: full2 }));
    $$invalidate(11, { maxDepth, additions, deletions } = diff2, additions, $$invalidate(12, deletions));
    init2 = true;
  }
  function getDiffNodes2() {
    let nodes = [];
    (function getNodes(node2) {
      if (node2.changeType) {
        nodes.push(node2);
      }
      node2.getChildren().forEach((child) => getNodes(child));
    })(diff2);
    diffs.nodes = nodes;
    diffs.curr = null;
  }
  function goToDiff(step) {
    var _a;
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0 || length === 1 && nodes[0].getSelected()) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next2 = curr + step;
    if (next2 < 0) {
      next2 = length - 1;
    } else if (next2 >= length) {
      next2 = 0;
    }
    (_a = nodes[curr]) == null ? void 0 : _a.setSelected(false);
    nodes[next2].setSelected(true);
    diffs.curr = next2;
  }
  function goToFirstDiff() {
    const firstDiffNode = diffs.nodes[0];
    if (firstDiffNode) {
      diffs.curr = 0;
      firstDiffNode.setSelected(true);
    }
  }
  async function processDiff() {
    $$invalidate(21, currDiff = diff2);
    if (!computeDiff) {
      let diffClone = cloneJsonDiff(diff2);
      $$invalidate(11, { maxDepth, additions, deletions } = diffClone, additions, $$invalidate(12, deletions));
      $$invalidate(0, diff2 = diffClone);
      $$invalidate(21, currDiff = diff2);
    }
    if (pruneAdditions && init2) {
      removeAdditions(diff2);
    }
    if (pruneDeletions && init2) {
      removeDeletions(diff2);
    }
    if (diffNavigation) {
      getDiffNodes2();
      if (scrollToFirstDiff) {
        await tick();
        goToFirstDiff();
      }
    }
  }
  function getDepth() {
    let minWidth = 30, upper_bound = 40;
    let depth = minWidth + 2 * maxDepth;
    return `${depth > upper_bound ? upper_bound : depth}%`;
  }
  const actionFn = (elRef, node2) => {
    dispatch("load");
    return {
      update: (node3) => {
        if (node3.getSelected()) {
          elRef.scrollIntoView({ behaviour: "smooth", block: "center" });
        }
      }
    };
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      diffView = $$value;
      $$invalidate(2, diffView);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("oldData" in $$props2)
      $$invalidate(13, oldData = $$props2.oldData);
    if ("newData" in $$props2)
      $$invalidate(14, newData = $$props2.newData);
    if ("diff" in $$props2)
      $$invalidate(0, diff2 = $$props2.diff);
    if ("jsonDiffPromise" in $$props2)
      $$invalidate(1, jsonDiffPromise = $$props2.jsonDiffPromise);
    if ("full" in $$props2)
      $$invalidate(3, full = $$props2.full);
    if ("pruneDeletions" in $$props2)
      $$invalidate(15, pruneDeletions = $$props2.pruneDeletions);
    if ("pruneAdditions" in $$props2)
      $$invalidate(16, pruneAdditions = $$props2.pruneAdditions);
    if ("additions" in $$props2)
      $$invalidate(11, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(12, deletions = $$props2.deletions);
    if ("hideDeletions" in $$props2)
      $$invalidate(4, hideDeletions = $$props2.hideDeletions);
    if ("hideAdditions" in $$props2)
      $$invalidate(5, hideAdditions = $$props2.hideAdditions);
    if ("showDirty" in $$props2)
      $$invalidate(6, showDirty = $$props2.showDirty);
    if ("treeViewClass" in $$props2)
      $$invalidate(7, treeViewClass = $$props2.treeViewClass);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(17, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(18, diffNavigation = $$props2.diffNavigation);
    if ("diffView" in $$props2)
      $$invalidate(2, diffView = $$props2.diffView);
    if ("class" in $$props2)
      $$invalidate(8, classes2 = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 57352) {
      computeDiff && $$invalidate(1, jsonDiffPromise = getDiff2(oldData, newData, { full }));
    }
    if ($$self.$$.dirty[0] & 2097153) {
      if (diff2 !== currDiff) {
        processDiff();
      }
    }
  };
  return [
    diff2,
    jsonDiffPromise,
    diffView,
    full,
    hideDeletions,
    hideAdditions,
    showDirty,
    treeViewClass,
    classes2,
    getDepth,
    actionFn,
    additions,
    deletions,
    oldData,
    newData,
    pruneDeletions,
    pruneAdditions,
    scrollToFirstDiff,
    diffNavigation,
    goToNextDiff,
    goToPrevDiff,
    currDiff,
    div1_binding
  ];
}
class DiffJsonView extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3u,
      create_fragment$3y,
      safe_not_equal,
      {
        oldData: 13,
        newData: 14,
        diff: 0,
        jsonDiffPromise: 1,
        full: 3,
        pruneDeletions: 15,
        pruneAdditions: 16,
        additions: 11,
        deletions: 12,
        hideDeletions: 4,
        hideAdditions: 5,
        showDirty: 6,
        treeViewClass: 7,
        scrollToFirstDiff: 17,
        diffNavigation: 18,
        diffView: 2,
        goToNextDiff: 19,
        goToPrevDiff: 20,
        class: 8
      },
      null,
      [-1, -1]
    );
  }
  get oldData() {
    return this.$$.ctx[13];
  }
  set oldData(oldData) {
    this.$$set({ oldData });
    flush();
  }
  get newData() {
    return this.$$.ctx[14];
  }
  set newData(newData) {
    this.$$set({ newData });
    flush();
  }
  get diff() {
    return this.$$.ctx[0];
  }
  set diff(diff2) {
    this.$$set({ diff: diff2 });
    flush();
  }
  get jsonDiffPromise() {
    return this.$$.ctx[1];
  }
  set jsonDiffPromise(jsonDiffPromise) {
    this.$$set({ jsonDiffPromise });
    flush();
  }
  get full() {
    return this.$$.ctx[3];
  }
  set full(full) {
    this.$$set({ full });
    flush();
  }
  get pruneDeletions() {
    return this.$$.ctx[15];
  }
  set pruneDeletions(pruneDeletions) {
    this.$$set({ pruneDeletions });
    flush();
  }
  get pruneAdditions() {
    return this.$$.ctx[16];
  }
  set pruneAdditions(pruneAdditions) {
    this.$$set({ pruneAdditions });
    flush();
  }
  get additions() {
    return this.$$.ctx[11];
  }
  set additions(additions) {
    this.$$set({ additions });
    flush();
  }
  get deletions() {
    return this.$$.ctx[12];
  }
  set deletions(deletions) {
    this.$$set({ deletions });
    flush();
  }
  get hideDeletions() {
    return this.$$.ctx[4];
  }
  set hideDeletions(hideDeletions) {
    this.$$set({ hideDeletions });
    flush();
  }
  get hideAdditions() {
    return this.$$.ctx[5];
  }
  set hideAdditions(hideAdditions) {
    this.$$set({ hideAdditions });
    flush();
  }
  get showDirty() {
    return this.$$.ctx[6];
  }
  set showDirty(showDirty) {
    this.$$set({ showDirty });
    flush();
  }
  get treeViewClass() {
    return this.$$.ctx[7];
  }
  set treeViewClass(treeViewClass) {
    this.$$set({ treeViewClass });
    flush();
  }
  get scrollToFirstDiff() {
    return this.$$.ctx[17];
  }
  set scrollToFirstDiff(scrollToFirstDiff) {
    this.$$set({ scrollToFirstDiff });
    flush();
  }
  get diffNavigation() {
    return this.$$.ctx[18];
  }
  set diffNavigation(diffNavigation) {
    this.$$set({ diffNavigation });
    flush();
  }
  get diffView() {
    return this.$$.ctx[2];
  }
  set diffView(diffView) {
    this.$$set({ diffView });
    flush();
  }
  get goToNextDiff() {
    return this.$$.ctx[19];
  }
  get goToPrevDiff() {
    return this.$$.ctx[20];
  }
  get class() {
    return this.$$.ctx[8];
  }
  set class(classes2) {
    this.$$set({ class: classes2 });
    flush();
  }
}
function create_fragment$3x(ctx) {
  let div;
  let button0;
  let i0;
  let button0_disabled_value;
  let t;
  let button1;
  let i1;
  let button1_disabled_value;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      i0 = element("i");
      t = space();
      button1 = element("button");
      i1 = element("i");
      attr(i0, "class", "fa fa-chevron-up");
      attr(button0, "class", "btn btn-default");
      attr(button0, "title", "Previous Diff");
      button0.disabled = button0_disabled_value = ctx[4] || ctx[2];
      attr(i1, "class", "fa fa-chevron-down");
      attr(button1, "class", "btn btn-default");
      attr(button1, "title", "Next Diff");
      button1.disabled = button1_disabled_value = ctx[4] || ctx[3];
      attr(div, "class", div_class_value = "btn-group flex flex-nowrap " + ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, i0);
      append(div, t);
      append(div, button1);
      append(button1, i1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(ctx[0]))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & 20 && button0_disabled_value !== (button0_disabled_value = ctx[4] || ctx[2])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & 24 && button1_disabled_value !== (button1_disabled_value = ctx[4] || ctx[3])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & 32 && div_class_value !== (div_class_value = "btn-group flex flex-nowrap " + ctx[5])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3t($$self, $$props, $$invalidate) {
  let { nextFn } = $$props;
  let { prevFn } = $$props;
  let { nextDisabled = false } = $$props;
  let { prevDisabled = false } = $$props;
  let { disableButtons = false } = $$props;
  let { class: classes2 = "" } = $$props;
  createEventDispatcher();
  $$self.$$set = ($$props2) => {
    if ("nextFn" in $$props2)
      $$invalidate(0, nextFn = $$props2.nextFn);
    if ("prevFn" in $$props2)
      $$invalidate(1, prevFn = $$props2.prevFn);
    if ("nextDisabled" in $$props2)
      $$invalidate(2, nextDisabled = $$props2.nextDisabled);
    if ("prevDisabled" in $$props2)
      $$invalidate(3, prevDisabled = $$props2.prevDisabled);
    if ("disableButtons" in $$props2)
      $$invalidate(4, disableButtons = $$props2.disableButtons);
    if ("class" in $$props2)
      $$invalidate(5, classes2 = $$props2.class);
  };
  return [nextFn, prevFn, nextDisabled, prevDisabled, disableButtons, classes2];
}
class NavigateDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3t, create_fragment$3x, safe_not_equal, {
      nextFn: 0,
      prevFn: 1,
      nextDisabled: 2,
      prevDisabled: 3,
      disableButtons: 4,
      class: 5
    });
  }
}
function create_fragment$3w(ctx) {
  let ul;
  let li0;
  let navigatediff;
  let t0;
  let li1;
  let a0;
  let t2;
  let li2;
  let a1;
  let t4;
  let li3;
  let ul_class_value;
  let current;
  let mounted;
  let dispose;
  navigatediff = new NavigateDiff({
    props: {
      nextFn: ctx[1],
      prevFn: ctx[2],
      disableButtons: ctx[4].disableButtons
    }
  });
  return {
    c() {
      ul = element("ul");
      li0 = element("li");
      create_component(navigatediff.$$.fragment);
      t0 = space();
      li1 = element("li");
      a0 = element("a");
      a0.textContent = `${T("l_tree")}`;
      t2 = space();
      li2 = element("li");
      a1 = element("a");
      a1.textContent = `${T("l_raw")}`;
      t4 = space();
      li3 = element("li");
      attr(li0, "class", "m-0 pl-2 mr-3 ");
      attr(a0, "class", "nav-link");
      toggle_class(a0, "active", ctx[0]);
      attr(li1, "class", "nav-item");
      attr(a1, "class", "nav-link");
      toggle_class(a1, "active", !ctx[0]);
      attr(li2, "class", "nav-item");
      attr(li3, "class", "flex-1");
      attr(ul, "class", ul_class_value = "nav nav-tabs sticky top-[-13px] bg-white flex w-full " + ctx[3]);
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      append(ul, li0);
      mount_component(navigatediff, li0, null);
      append(ul, t0);
      append(ul, li1);
      append(li1, a0);
      append(ul, t2);
      append(ul, li2);
      append(li2, a1);
      append(ul, t4);
      append(ul, li3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[5]),
          listen(a1, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 2)
        navigatediff_changes.nextFn = ctx2[1];
      if (dirty & 4)
        navigatediff_changes.prevFn = ctx2[2];
      if (dirty & 16)
        navigatediff_changes.disableButtons = ctx2[4].disableButtons;
      navigatediff.$set(navigatediff_changes);
      if (!current || dirty & 1) {
        toggle_class(a0, "active", ctx2[0]);
      }
      if (!current || dirty & 1) {
        toggle_class(a1, "active", !ctx2[0]);
      }
      if (!current || dirty & 8 && ul_class_value !== (ul_class_value = "nav nav-tabs sticky top-[-13px] bg-white flex w-full " + ctx2[3])) {
        attr(ul, "class", ul_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_component(navigatediff);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3s($$self, $$props, $$invalidate) {
  const omit_props_names = ["treeViewMode", "goToNextDiff", "goToPrevDiff", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { treeViewMode = true } = $$props;
  let { goToNextDiff } = $$props;
  let { goToPrevDiff } = $$props;
  let { class: classes2 = "" } = $$props;
  const click_handler = () => $$invalidate(0, treeViewMode = true);
  const click_handler_1 = () => $$invalidate(0, treeViewMode = false);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("treeViewMode" in $$new_props)
      $$invalidate(0, treeViewMode = $$new_props.treeViewMode);
    if ("goToNextDiff" in $$new_props)
      $$invalidate(1, goToNextDiff = $$new_props.goToNextDiff);
    if ("goToPrevDiff" in $$new_props)
      $$invalidate(2, goToPrevDiff = $$new_props.goToPrevDiff);
    if ("class" in $$new_props)
      $$invalidate(3, classes2 = $$new_props.class);
  };
  return [
    treeViewMode,
    goToNextDiff,
    goToPrevDiff,
    classes2,
    $$restProps,
    click_handler,
    click_handler_1
  ];
}
class JSONDiffHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3s, create_fragment$3w, safe_not_equal, {
      treeViewMode: 0,
      goToNextDiff: 1,
      goToPrevDiff: 2,
      class: 3
    });
  }
}
var JSONSideBySideDiff_svelte_svelte_type_style_lang = "";
function create_else_block_1$e(ctx) {
  let pre;
  let t_value = JSON.stringify(ctx[6].data1.data, null, 2) + "";
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(t_value);
      attr(pre, "class", "overflow-auto whitespace-pre-wrap border-top-0 bg-white svelte-1nksjwa");
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = JSON.stringify(ctx2[6].data1.data, null, 2) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_if_block_1$19(ctx) {
  let diffjsonview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  function diffjsonview_goToNextDiff_binding(value) {
    ctx[8](value);
  }
  function diffjsonview_goToPrevDiff_binding(value) {
    ctx[9](value);
  }
  let diffjsonview_props = {
    diff: ctx[6].diff,
    pruneAdditions: true,
    class: "flex-grow",
    treeViewClass: "border-t-0",
    diffNavigation: true
  };
  if (ctx[1] !== void 0) {
    diffjsonview_props.goToNextDiff = ctx[1];
  }
  if (ctx[2] !== void 0) {
    diffjsonview_props.goToPrevDiff = ctx[2];
  }
  diffjsonview = new DiffJsonView({ props: diffjsonview_props });
  binding_callbacks.push(() => bind$2(diffjsonview, "goToNextDiff", diffjsonview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffjsonview, "goToPrevDiff", diffjsonview_goToPrevDiff_binding));
  return {
    c() {
      create_component(diffjsonview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffjsonview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffjsonview_changes = {};
      if (dirty & 64)
        diffjsonview_changes.diff = ctx2[6].diff;
      if (!updating_goToNextDiff && dirty & 2) {
        updating_goToNextDiff = true;
        diffjsonview_changes.goToNextDiff = ctx2[1];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 4) {
        updating_goToPrevDiff = true;
        diffjsonview_changes.goToPrevDiff = ctx2[2];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffjsonview.$set(diffjsonview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffjsonview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffjsonview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffjsonview, detaching);
    }
  };
}
function create_else_block$Z(ctx) {
  let pre;
  let t_value = JSON.stringify(ctx[6].data2.data, null, 2) + "";
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(t_value);
      attr(pre, "class", "overflow-auto whitespace-pre-wrap border-top-0 bg-white svelte-1nksjwa");
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = JSON.stringify(ctx2[6].data2.data, null, 2) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_if_block$1M(ctx) {
  let diffjsonview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  function diffjsonview_goToNextDiff_binding_1(value) {
    ctx[11](value);
  }
  function diffjsonview_goToPrevDiff_binding_1(value) {
    ctx[12](value);
  }
  let diffjsonview_props = {
    diff: ctx[6].diff,
    pruneDeletions: true,
    class: "flex-grow",
    treeViewClass: "border-t-0",
    diffNavigation: true
  };
  if (ctx[4] !== void 0) {
    diffjsonview_props.goToNextDiff = ctx[4];
  }
  if (ctx[5] !== void 0) {
    diffjsonview_props.goToPrevDiff = ctx[5];
  }
  diffjsonview = new DiffJsonView({ props: diffjsonview_props });
  binding_callbacks.push(() => bind$2(diffjsonview, "goToNextDiff", diffjsonview_goToNextDiff_binding_1));
  binding_callbacks.push(() => bind$2(diffjsonview, "goToPrevDiff", diffjsonview_goToPrevDiff_binding_1));
  return {
    c() {
      create_component(diffjsonview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffjsonview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffjsonview_changes = {};
      if (dirty & 64)
        diffjsonview_changes.diff = ctx2[6].diff;
      if (!updating_goToNextDiff && dirty & 16) {
        updating_goToNextDiff = true;
        diffjsonview_changes.goToNextDiff = ctx2[4];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 32) {
        updating_goToPrevDiff = true;
        diffjsonview_changes.goToPrevDiff = ctx2[5];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffjsonview.$set(diffjsonview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffjsonview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffjsonview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffjsonview, detaching);
    }
  };
}
function create_fragment$3v(ctx) {
  let div0;
  let jsondiffheader0;
  let updating_treeViewMode;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let div1;
  let jsondiffheader1;
  let updating_treeViewMode_1;
  let t2;
  let current_block_type_index_1;
  let if_block1;
  let current;
  function jsondiffheader0_treeViewMode_binding(value) {
    ctx[7](value);
  }
  let jsondiffheader0_props = {
    disableButtons: !ctx[0],
    goToNextDiff: ctx[1],
    goToPrevDiff: ctx[2]
  };
  if (ctx[0] !== void 0) {
    jsondiffheader0_props.treeViewMode = ctx[0];
  }
  jsondiffheader0 = new JSONDiffHeader({ props: jsondiffheader0_props });
  binding_callbacks.push(() => bind$2(jsondiffheader0, "treeViewMode", jsondiffheader0_treeViewMode_binding));
  const if_block_creators = [create_if_block_1$19, create_else_block_1$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function jsondiffheader1_treeViewMode_binding(value) {
    ctx[10](value);
  }
  let jsondiffheader1_props = {
    disableButtons: !ctx[3],
    goToNextDiff: ctx[4],
    goToPrevDiff: ctx[5]
  };
  if (ctx[3] !== void 0) {
    jsondiffheader1_props.treeViewMode = ctx[3];
  }
  jsondiffheader1 = new JSONDiffHeader({ props: jsondiffheader1_props });
  binding_callbacks.push(() => bind$2(jsondiffheader1, "treeViewMode", jsondiffheader1_treeViewMode_binding));
  const if_block_creators_1 = [create_if_block$1M, create_else_block$Z];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  return {
    c() {
      div0 = element("div");
      create_component(jsondiffheader0.$$.fragment);
      t0 = space();
      if_block0.c();
      t1 = space();
      div1 = element("div");
      create_component(jsondiffheader1.$$.fragment);
      t2 = space();
      if_block1.c();
      attr(div0, "class", "flex flex-column flex-1 pl-10 pr-10");
      attr(div1, "class", "flex flex-column flex-1 pl-10 pr-10");
      set_style(div1, "border-left", "2px solid black");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(jsondiffheader0, div0, null);
      append(div0, t0);
      if_blocks[current_block_type_index].m(div0, null);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      mount_component(jsondiffheader1, div1, null);
      append(div1, t2);
      if_blocks_1[current_block_type_index_1].m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsondiffheader0_changes = {};
      if (dirty & 1)
        jsondiffheader0_changes.disableButtons = !ctx2[0];
      if (dirty & 2)
        jsondiffheader0_changes.goToNextDiff = ctx2[1];
      if (dirty & 4)
        jsondiffheader0_changes.goToPrevDiff = ctx2[2];
      if (!updating_treeViewMode && dirty & 1) {
        updating_treeViewMode = true;
        jsondiffheader0_changes.treeViewMode = ctx2[0];
        add_flush_callback(() => updating_treeViewMode = false);
      }
      jsondiffheader0.$set(jsondiffheader0_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      const jsondiffheader1_changes = {};
      if (dirty & 8)
        jsondiffheader1_changes.disableButtons = !ctx2[3];
      if (dirty & 16)
        jsondiffheader1_changes.goToNextDiff = ctx2[4];
      if (dirty & 32)
        jsondiffheader1_changes.goToPrevDiff = ctx2[5];
      if (!updating_treeViewMode_1 && dirty & 8) {
        updating_treeViewMode_1 = true;
        jsondiffheader1_changes.treeViewMode = ctx2[3];
        add_flush_callback(() => updating_treeViewMode_1 = false);
      }
      jsondiffheader1.$set(jsondiffheader1_changes);
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(jsondiffheader0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(jsondiffheader1.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(jsondiffheader0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(jsondiffheader1.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(jsondiffheader0);
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_component(jsondiffheader1);
      if_blocks_1[current_block_type_index_1].d();
    }
  };
}
function instance$3r($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(6, $store = $$value));
  let view1TreeMode = true;
  let view1GoToNextDiff;
  let view1GoToPrevDiff;
  let view2TreeMode = true;
  let view2GoToNextDiff;
  let view2GoToPrevDiff;
  function jsondiffheader0_treeViewMode_binding(value) {
    view1TreeMode = value;
    $$invalidate(0, view1TreeMode);
  }
  function diffjsonview_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(1, view1GoToNextDiff);
  }
  function diffjsonview_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(2, view1GoToPrevDiff);
  }
  function jsondiffheader1_treeViewMode_binding(value) {
    view2TreeMode = value;
    $$invalidate(3, view2TreeMode);
  }
  function diffjsonview_goToNextDiff_binding_1(value) {
    view2GoToNextDiff = value;
    $$invalidate(4, view2GoToNextDiff);
  }
  function diffjsonview_goToPrevDiff_binding_1(value) {
    view2GoToPrevDiff = value;
    $$invalidate(5, view2GoToPrevDiff);
  }
  return [
    view1TreeMode,
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2TreeMode,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    jsondiffheader0_treeViewMode_binding,
    diffjsonview_goToNextDiff_binding,
    diffjsonview_goToPrevDiff_binding,
    jsondiffheader1_treeViewMode_binding,
    diffjsonview_goToNextDiff_binding_1,
    diffjsonview_goToPrevDiff_binding_1
  ];
}
class JSONSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3r, create_fragment$3v, safe_not_equal, {});
  }
}
function create_fragment$3u(ctx) {
  let div1;
  let div0;
  let navigatediff;
  let t;
  let diffjsonview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  navigatediff = new NavigateDiff({
    props: {
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function diffjsonview_goToNextDiff_binding(value) {
    ctx[3](value);
  }
  function diffjsonview_goToPrevDiff_binding(value) {
    ctx[4](value);
  }
  let diffjsonview_props = {
    scrollToFirstDiff: true,
    diff: ctx[2].diff,
    diffNavigation: true
  };
  if (ctx[0] !== void 0) {
    diffjsonview_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    diffjsonview_props.goToPrevDiff = ctx[1];
  }
  diffjsonview = new DiffJsonView({ props: diffjsonview_props });
  binding_callbacks.push(() => bind$2(diffjsonview, "goToNextDiff", diffjsonview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffjsonview, "goToPrevDiff", diffjsonview_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff.$$.fragment);
      t = space();
      create_component(diffjsonview.$$.fragment);
      attr(div0, "class", "flex mb-3 sticky top-0 bg-transparent");
      attr(div1, "class", "flex-grow pl-10 pr-10 flex flex-column");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff, div0, null);
      append(div1, t);
      mount_component(diffjsonview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 1)
        navigatediff_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff_changes.prevFn = ctx2[1];
      navigatediff.$set(navigatediff_changes);
      const diffjsonview_changes = {};
      if (dirty & 4)
        diffjsonview_changes.diff = ctx2[2].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        diffjsonview_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        diffjsonview_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffjsonview.$set(diffjsonview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      transition_in(diffjsonview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      transition_out(diffjsonview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff);
      destroy_component(diffjsonview);
    }
  };
}
function instance$3q($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(2, $store = $$value));
  let goToNextDiff;
  let goToPrevDiff;
  function diffjsonview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(0, goToNextDiff);
  }
  function diffjsonview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(1, goToPrevDiff);
  }
  return [
    goToNextDiff,
    goToPrevDiff,
    $store,
    diffjsonview_goToNextDiff_binding,
    diffjsonview_goToPrevDiff_binding
  ];
}
class JSONInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3q, create_fragment$3u, safe_not_equal, {});
  }
}
function create_else_block$Y(ctx) {
  let jsonsidebysidediff;
  let current;
  jsonsidebysidediff = new JSONSideBySideDiff({});
  return {
    c() {
      create_component(jsonsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonsidebysidediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonsidebysidediff, detaching);
    }
  };
}
function create_if_block$1L(ctx) {
  let jsoninlinediff;
  let current;
  jsoninlinediff = new JSONInlineDiff({});
  return {
    c() {
      create_component(jsoninlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsoninlinediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(jsoninlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsoninlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsoninlinediff, detaching);
    }
  };
}
function create_fragment$3t(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1L, create_else_block$Y];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex items-stretch h-full");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3p($$self, $$props, $$invalidate) {
  let { inlined = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
  };
  return [inlined];
}
class ExploreJSONDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3p, create_fragment$3t, safe_not_equal, { inlined: 0 });
  }
}
var diffStyles = ".removed,tr>td.removed{background:#fbb}.inserted,tr>td.inserted{background:#bfb}.xhighlighted{outline:2px solid blue}";
function create_fragment$3s(ctx) {
  let div;
  let iframe_1;
  let iframe_1_class_value;
  let iframe_1_scrolling_value;
  return {
    c() {
      div = element("div");
      iframe_1 = element("iframe");
      attr(iframe_1, "title", "");
      attr(iframe_1, "class", iframe_1_class_value = "w-full border-none " + ctx[2]);
      attr(iframe_1, "style", ctx[4]);
      attr(iframe_1, "scrolling", iframe_1_scrolling_value = ctx[3] ? "" : "no");
      attr(iframe_1, "srcdoc", ctx[0]);
      set_style(iframe_1, "height", ctx[6]);
      attr(div, "class", ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, iframe_1);
      ctx[24](iframe_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4 && iframe_1_class_value !== (iframe_1_class_value = "w-full border-none " + ctx2[2])) {
        attr(iframe_1, "class", iframe_1_class_value);
      }
      if (dirty[0] & 16) {
        attr(iframe_1, "style", ctx2[4]);
      }
      if (dirty[0] & 8 && iframe_1_scrolling_value !== (iframe_1_scrolling_value = ctx2[3] ? "" : "no")) {
        attr(iframe_1, "scrolling", iframe_1_scrolling_value);
      }
      if (dirty[0] & 1) {
        attr(iframe_1, "srcdoc", ctx2[0]);
      }
      const style_changed = dirty[0] & 16;
      if (style_changed || dirty[0] & 80) {
        set_style(iframe_1, "height", ctx2[6]);
      }
      if (dirty[0] & 32) {
        attr(div, "class", ctx2[5]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[24](null);
    }
  };
}
const highlightClass$2 = "xhighlighted";
function wait$4(timeout) {
  return new Promise((resolve) => setTimeout(resolve, timeout));
}
function getDiffNodes$1(parentEl, diffs, options = {}) {
  let { selector } = options;
  diffs.nodes = [];
  diffs.curr = null;
  diffs.nodes = Array.from(parentEl.querySelectorAll(selector));
}
function instance$3o($$self, $$props, $$invalidate) {
  let { oldData } = $$props;
  let { newData } = $$props;
  let { context } = $$props;
  let { diff: diff2 } = $$props;
  let { uri } = $$props;
  let { selectedDiffContentMode } = $$props;
  let { hideInserted = false } = $$props;
  let { hideRemoved = false } = $$props;
  let { withoutStyle = false } = $$props;
  let { snipped = false } = $$props;
  let { iframeClass = "" } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { diffNavigation = false } = $$props;
  let { showScrollBar } = $$props;
  let { dynamicHeight = true } = $$props;
  let { iframe } = $$props;
  let { iframeStyle = "" } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  const dispatch = createEventDispatcher();
  const STEP = { NEXT: 1, PREV: -1 };
  let { class: classes2 = "" } = $$props;
  let styleSheets;
  let styledElements;
  let interval;
  let selector;
  if (!hideInserted && !hideRemoved) {
    selector = ".inserted,.removed";
  } else if (!hideInserted) {
    selector = ".inserted";
  } else if (!hideRemoved) {
    selector = ".removed";
  } else {
    selector = "";
  }
  let styles;
  let prevHeight = 0;
  let loaded = false;
  let parentEl;
  let height;
  let diffs = { nodes: [], curr: null };
  onMount(() => {
    $$invalidate(1, iframe.onload = onLoad, iframe);
    return () => clearInterval(interval);
  });
  async function onLoad() {
    parentEl = iframe.contentWindow.document;
    styleSheets = void 0;
    styledElements = void 0;
    resetHighlighting();
    setDiffStyles();
    if (dynamicHeight) {
      await waitForResourceLoad();
      startInterval();
    }
    updateLinks();
    if (diffNavigation) {
      getDiffNodes$1(parentEl, diffs, { selector });
      if (scrollToFirstDiff) {
        goToFirstDiff();
      }
    }
    $$invalidate(23, loaded = true);
    dispatch("load");
  }
  async function waitForResourceLoad() {
    const contentEls = Array.from(iframe.contentWindow.document.querySelectorAll('link[rel="stylesheet"], img'));
    const checkPromise = new Promise((resolve) => {
      let elsLoaded = 0;
      contentEls.forEach((el) => {
        if (el.complete || el.sheet) {
          elsLoaded++;
        } else {
          const listener = () => {
            elsLoaded++;
            setIframeHeight();
            el.removeEventListener("load", listener);
            el.removeEventListener("error", listener);
            if (elsLoaded === contentEls.length) {
              resolve();
            }
          };
          ["load", "error"].forEach((evt) => {
            el.addEventListener(evt, listener);
          });
        }
      });
      if (elsLoaded === contentEls.length) {
        resolve();
      }
      setIframeHeight();
    });
    return await Promise.race([wait$4(15 * 1e3), checkPromise]);
  }
  function startInterval() {
    interval = setInterval(() => setIframeHeight(), 2e3);
  }
  function computeStyle() {
    styles = `
    ${diffStyles}
    span.inserted,
    span.removed {
      padding: 1px 4px;
    }
    a.removed,
    a .removed {
      color: #008;
    }
    img.inserted {
      border: solid 2px green;
      background-color: transparent;
      padding: 2px;
    }
    img.removed {
      border: solid 2px red;
      background-color: transparent;
      padding: 2px;
    }
    [hidden] {
      display:block;
    }
    .xdistill-hide {display: none !important}
    body {
     padding: 10px;
    }
    td {
     padding: 10px;
    }
    ins, del {
      text-decoration: none;
    }
  ${snipped ? ".nonDiffHide{display:none;}" : ""}
  ${hideRemoved ? ".removed{display:none;}" : ""}
  ${hideInserted ? ".inserted{display:none}" : ""}
   `;
  }
  function goToDiff(step) {
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next2 = curr + step;
    if (next2 < 0) {
      next2 = length - 1;
    } else if (next2 >= length) {
      next2 = 0;
    }
    const currDiff = nodes[curr];
    const nextDiff = nodes[next2];
    currDiff == null ? void 0 : currDiff.classList.remove(highlightClass$2);
    nextDiff.classList.add(highlightClass$2);
    nextDiff.scrollIntoView({ behaviour: "smooth", block: "center" });
    diffs.curr = next2;
  }
  function goToFirstDiff() {
    const firstDiffEl = diffs.nodes[0];
    if (firstDiffEl) {
      diffs.curr = 0;
      firstDiffEl.scrollIntoView({ behaviour: "smooth", block: "center" });
      firstDiffEl.classList.add(highlightClass$2);
    }
  }
  function updateLinks() {
    const baseURIMatch = diff2.match(/<base\s*href=\"(.*?)\"/);
    let baseURI;
    if (baseURIMatch) {
      baseURI = baseURIMatch[1];
    } else {
      baseURI = uri;
    }
    const base2 = parentEl.createElement("base");
    base2.setAttribute("href", baseURI);
    (parentEl.head || parentEl.documentElement).prepend(base2);
    parentEl.querySelectorAll("a[href]").forEach((el) => {
      el.setAttribute("target", "_blank");
      el.setAttribute("rel", "noopener");
    });
  }
  function resetHighlighting() {
    Array.from(parentEl.querySelectorAll(`.${highlightClass$2}`)).map((el) => el.classList.remove(highlightClass$2));
  }
  function setIframeHeight() {
    const doc = iframe.contentWindow.document;
    const html2 = doc.documentElement;
    const body = doc.body;
    let h = Math.max(body.scrollHeight, body.offsetHeight, html2.clientHeight, html2.scrollHeight, html2.offsetHeight);
    if (h > prevHeight * 1.03) {
      h = h * 1.02;
      prevHeight = h;
      $$invalidate(6, height = h + "px");
    }
  }
  async function getDiff2() {
    try {
      $$invalidate(0, { diff: diff2, additions, deletions } = await Diff.diffSieve(oldData, newData, context, selectedDiffContentMode), diff2, $$invalidate(7, additions), $$invalidate(8, deletions));
    } catch (e) {
      console.error("error while getting the diff", oldData.id, newData.id, e);
      $$invalidate(0, diff2 = newData.data);
      $$invalidate(7, additions = 0);
      $$invalidate(8, deletions = 0);
    }
  }
  function setDiffStyles() {
    let styleEl = parentEl.querySelector("style.xdistill");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.classList.add("xdistill");
      parentEl.querySelector("head").appendChild(styleEl);
    }
    computeStyle();
    styleEl.innerHTML = styles;
    setIframeHeight();
  }
  function toggleStyle(flag) {
    if (flag) {
      styleSheets = Array.from(parentEl.querySelectorAll("link[rel=stylesheet],style:not(.xdistill)"));
      styleSheets.forEach((style) => style.remove());
      styledElements = Array.from(parentEl.querySelectorAll("[style]")).map((element2) => {
        let data = [element2, element2.getAttribute("style")];
        element2.removeAttribute("style");
        return data;
      });
    } else {
      styleSheets && styleSheets.forEach((style) => parentEl.querySelector("head").appendChild(style));
      styledElements && styledElements.forEach(([element2, style]) => {
        element2.setAttribute("style", style);
      });
    }
    setIframeHeight();
  }
  function iframe_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframe = $$value;
      $$invalidate(1, iframe);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("oldData" in $$props2)
      $$invalidate(9, oldData = $$props2.oldData);
    if ("newData" in $$props2)
      $$invalidate(10, newData = $$props2.newData);
    if ("context" in $$props2)
      $$invalidate(11, context = $$props2.context);
    if ("diff" in $$props2)
      $$invalidate(0, diff2 = $$props2.diff);
    if ("uri" in $$props2)
      $$invalidate(12, uri = $$props2.uri);
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(13, selectedDiffContentMode = $$props2.selectedDiffContentMode);
    if ("hideInserted" in $$props2)
      $$invalidate(14, hideInserted = $$props2.hideInserted);
    if ("hideRemoved" in $$props2)
      $$invalidate(15, hideRemoved = $$props2.hideRemoved);
    if ("withoutStyle" in $$props2)
      $$invalidate(16, withoutStyle = $$props2.withoutStyle);
    if ("snipped" in $$props2)
      $$invalidate(17, snipped = $$props2.snipped);
    if ("iframeClass" in $$props2)
      $$invalidate(2, iframeClass = $$props2.iframeClass);
    if ("additions" in $$props2)
      $$invalidate(7, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(8, deletions = $$props2.deletions);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(18, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(19, diffNavigation = $$props2.diffNavigation);
    if ("showScrollBar" in $$props2)
      $$invalidate(3, showScrollBar = $$props2.showScrollBar);
    if ("dynamicHeight" in $$props2)
      $$invalidate(20, dynamicHeight = $$props2.dynamicHeight);
    if ("iframe" in $$props2)
      $$invalidate(1, iframe = $$props2.iframe);
    if ("iframeStyle" in $$props2)
      $$invalidate(4, iframeStyle = $$props2.iframeStyle);
    if ("class" in $$props2)
      $$invalidate(5, classes2 = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1) {
      $$invalidate(23, loaded = false);
    }
    if ($$self.$$.dirty[0] & 8454144) {
      loaded && toggleStyle(withoutStyle);
    }
    if ($$self.$$.dirty[0] & 8192) {
      selectedDiffContentMode && getDiff2();
    }
    if ($$self.$$.dirty[0] & 1536) {
      oldData && newData && getDiff2();
    }
    if ($$self.$$.dirty[0] & 8568833) {
      loaded && setDiffStyles();
    }
  };
  return [
    diff2,
    iframe,
    iframeClass,
    showScrollBar,
    iframeStyle,
    classes2,
    height,
    additions,
    deletions,
    oldData,
    newData,
    context,
    uri,
    selectedDiffContentMode,
    hideInserted,
    hideRemoved,
    withoutStyle,
    snipped,
    scrollToFirstDiff,
    diffNavigation,
    dynamicHeight,
    goToNextDiff,
    goToPrevDiff,
    loaded,
    iframe_1_binding
  ];
}
class DiffHtmlView extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3o,
      create_fragment$3s,
      safe_not_equal,
      {
        oldData: 9,
        newData: 10,
        context: 11,
        diff: 0,
        uri: 12,
        selectedDiffContentMode: 13,
        hideInserted: 14,
        hideRemoved: 15,
        withoutStyle: 16,
        snipped: 17,
        iframeClass: 2,
        additions: 7,
        deletions: 8,
        scrollToFirstDiff: 18,
        diffNavigation: 19,
        showScrollBar: 3,
        dynamicHeight: 20,
        iframe: 1,
        iframeStyle: 4,
        goToNextDiff: 21,
        goToPrevDiff: 22,
        class: 5
      },
      null,
      [-1, -1]
    );
  }
  get goToNextDiff() {
    return this.$$.ctx[21];
  }
  get goToPrevDiff() {
    return this.$$.ctx[22];
  }
}
function create_if_block$1K(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3r(ctx) {
  let div1;
  let div0;
  let t0;
  let navigatediff;
  let t1;
  let diffhtmlview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let updating_withoutStyle;
  let current;
  let if_block = ctx[1] && create_if_block$1K();
  navigatediff = new NavigateDiff({
    props: {
      class: "ml-5 bg-transparent",
      nextFn: ctx[2],
      prevFn: ctx[3]
    }
  });
  function diffhtmlview_goToNextDiff_binding(value) {
    ctx[5](value);
  }
  function diffhtmlview_goToPrevDiff_binding(value) {
    ctx[6](value);
  }
  function diffhtmlview_withoutStyle_binding(value) {
    ctx[7](value);
  }
  let diffhtmlview_props = {
    diff: ctx[4].diff,
    uri: ctx[4].uri,
    scrollToFirstDiff: true,
    diffNavigation: true,
    iframeStyle: "min-height:100vh;",
    class: "flex-grow pt-6"
  };
  if (ctx[2] !== void 0) {
    diffhtmlview_props.goToNextDiff = ctx[2];
  }
  if (ctx[3] !== void 0) {
    diffhtmlview_props.goToPrevDiff = ctx[3];
  }
  if (ctx[0] !== void 0) {
    diffhtmlview_props.withoutStyle = ctx[0];
  }
  diffhtmlview = new DiffHtmlView({ props: diffhtmlview_props });
  binding_callbacks.push(() => bind$2(diffhtmlview, "goToNextDiff", diffhtmlview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview, "goToPrevDiff", diffhtmlview_goToPrevDiff_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview, "withoutStyle", diffhtmlview_withoutStyle_binding));
  diffhtmlview.$on("load", ctx[8]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(navigatediff.$$.fragment);
      t1 = space();
      create_component(diffhtmlview.$$.fragment);
      attr(div0, "class", "flex flex-col align-items-start sticky top-0");
      attr(div1, "class", "flex flex-column self-stretch flex-grow");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t0);
      mount_component(navigatediff, div0, null);
      append(div1, t1);
      mount_component(diffhtmlview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1K();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const navigatediff_changes = {};
      if (dirty & 4)
        navigatediff_changes.nextFn = ctx2[2];
      if (dirty & 8)
        navigatediff_changes.prevFn = ctx2[3];
      navigatediff.$set(navigatediff_changes);
      const diffhtmlview_changes = {};
      if (dirty & 16)
        diffhtmlview_changes.diff = ctx2[4].diff;
      if (dirty & 16)
        diffhtmlview_changes.uri = ctx2[4].uri;
      if (!updating_goToNextDiff && dirty & 4) {
        updating_goToNextDiff = true;
        diffhtmlview_changes.goToNextDiff = ctx2[2];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 8) {
        updating_goToPrevDiff = true;
        diffhtmlview_changes.goToPrevDiff = ctx2[3];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      if (!updating_withoutStyle && dirty & 1) {
        updating_withoutStyle = true;
        diffhtmlview_changes.withoutStyle = ctx2[0];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      diffhtmlview.$set(diffhtmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(navigatediff.$$.fragment, local);
      transition_in(diffhtmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(navigatediff.$$.fragment, local);
      transition_out(diffhtmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_component(navigatediff);
      destroy_component(diffhtmlview);
    }
  };
}
function instance$3n($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(4, $store = $$value));
  let { withoutStyle = false } = $$props;
  let showLoader = true;
  let goToNextDiff;
  let goToPrevDiff;
  function diffhtmlview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(2, goToNextDiff);
  }
  function diffhtmlview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(3, goToPrevDiff);
  }
  function diffhtmlview_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(0, withoutStyle);
  }
  const load_handler = () => $$invalidate(1, showLoader = false);
  $$self.$$set = ($$props2) => {
    if ("withoutStyle" in $$props2)
      $$invalidate(0, withoutStyle = $$props2.withoutStyle);
  };
  return [
    withoutStyle,
    showLoader,
    goToNextDiff,
    goToPrevDiff,
    $store,
    diffhtmlview_goToNextDiff_binding,
    diffhtmlview_goToPrevDiff_binding,
    diffhtmlview_withoutStyle_binding,
    load_handler
  ];
}
class HTMLInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3n, create_fragment$3r, safe_not_equal, { withoutStyle: 0 });
  }
}
function create_if_block_1$18(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block$1J(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3q(ctx) {
  let div1;
  let div0;
  let t0;
  let navigatediff0;
  let t1;
  let diffhtmlview0;
  let updating_withoutStyle;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let t2;
  let div3;
  let div2;
  let t3;
  let navigatediff1;
  let t4;
  let diffhtmlview1;
  let updating_withoutStyle_1;
  let updating_goToNextDiff_1;
  let updating_goToPrevDiff_1;
  let current;
  let if_block0 = ctx[1] && create_if_block_1$18();
  navigatediff0 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[3],
      prevFn: ctx[4]
    }
  });
  function diffhtmlview0_withoutStyle_binding(value) {
    ctx[8](value);
  }
  function diffhtmlview0_goToNextDiff_binding(value) {
    ctx[9](value);
  }
  function diffhtmlview0_goToPrevDiff_binding(value) {
    ctx[10](value);
  }
  let diffhtmlview0_props = {
    diff: ctx[7].diff,
    uri: ctx[7].uri,
    hideInserted: true,
    diffNavigation: true,
    iframeStyle: "min-height:100vh;",
    class: "flex-grow pt-6"
  };
  if (ctx[0] !== void 0) {
    diffhtmlview0_props.withoutStyle = ctx[0];
  }
  if (ctx[3] !== void 0) {
    diffhtmlview0_props.goToNextDiff = ctx[3];
  }
  if (ctx[4] !== void 0) {
    diffhtmlview0_props.goToPrevDiff = ctx[4];
  }
  diffhtmlview0 = new DiffHtmlView({ props: diffhtmlview0_props });
  binding_callbacks.push(() => bind$2(diffhtmlview0, "withoutStyle", diffhtmlview0_withoutStyle_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview0, "goToNextDiff", diffhtmlview0_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview0, "goToPrevDiff", diffhtmlview0_goToPrevDiff_binding));
  diffhtmlview0.$on("load", ctx[11]);
  let if_block1 = ctx[2] && create_if_block$1J();
  navigatediff1 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[5],
      prevFn: ctx[6]
    }
  });
  function diffhtmlview1_withoutStyle_binding(value) {
    ctx[12](value);
  }
  function diffhtmlview1_goToNextDiff_binding(value) {
    ctx[13](value);
  }
  function diffhtmlview1_goToPrevDiff_binding(value) {
    ctx[14](value);
  }
  let diffhtmlview1_props = {
    diff: ctx[7].diff,
    uri: ctx[7].uri,
    hideRemoved: true,
    diffNavigation: true,
    showLoader: true,
    iframeStyle: "min-height:100vh;",
    class: "flex-grow pt-6"
  };
  if (ctx[0] !== void 0) {
    diffhtmlview1_props.withoutStyle = ctx[0];
  }
  if (ctx[5] !== void 0) {
    diffhtmlview1_props.goToNextDiff = ctx[5];
  }
  if (ctx[6] !== void 0) {
    diffhtmlview1_props.goToPrevDiff = ctx[6];
  }
  diffhtmlview1 = new DiffHtmlView({ props: diffhtmlview1_props });
  binding_callbacks.push(() => bind$2(diffhtmlview1, "withoutStyle", diffhtmlview1_withoutStyle_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview1, "goToNextDiff", diffhtmlview1_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview1, "goToPrevDiff", diffhtmlview1_goToPrevDiff_binding));
  diffhtmlview1.$on("load", ctx[15]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(navigatediff0.$$.fragment);
      t1 = space();
      create_component(diffhtmlview0.$$.fragment);
      t2 = space();
      div3 = element("div");
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      create_component(navigatediff1.$$.fragment);
      t4 = space();
      create_component(diffhtmlview1.$$.fragment);
      attr(div0, "class", "flex flex-col align-items-start sticky top-0");
      attr(div1, "class", "flex-grow flex flex-column items-stretch");
      attr(div2, "class", "flex flex-col align-items-start sticky top-0");
      attr(div3, "class", "flex-grow flex flex-column items-stretch");
      set_style(div3, "border-left", "2px solid black");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      mount_component(navigatediff0, div0, null);
      append(div1, t1);
      mount_component(diffhtmlview0, div1, null);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t3);
      mount_component(navigatediff1, div2, null);
      append(div3, t4);
      mount_component(diffhtmlview1, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block0) {
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$18();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const navigatediff0_changes = {};
      if (dirty & 8)
        navigatediff0_changes.nextFn = ctx2[3];
      if (dirty & 16)
        navigatediff0_changes.prevFn = ctx2[4];
      navigatediff0.$set(navigatediff0_changes);
      const diffhtmlview0_changes = {};
      if (dirty & 128)
        diffhtmlview0_changes.diff = ctx2[7].diff;
      if (dirty & 128)
        diffhtmlview0_changes.uri = ctx2[7].uri;
      if (!updating_withoutStyle && dirty & 1) {
        updating_withoutStyle = true;
        diffhtmlview0_changes.withoutStyle = ctx2[0];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      if (!updating_goToNextDiff && dirty & 8) {
        updating_goToNextDiff = true;
        diffhtmlview0_changes.goToNextDiff = ctx2[3];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 16) {
        updating_goToPrevDiff = true;
        diffhtmlview0_changes.goToPrevDiff = ctx2[4];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffhtmlview0.$set(diffhtmlview0_changes);
      if (ctx2[2]) {
        if (if_block1) {
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1J();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const navigatediff1_changes = {};
      if (dirty & 32)
        navigatediff1_changes.nextFn = ctx2[5];
      if (dirty & 64)
        navigatediff1_changes.prevFn = ctx2[6];
      navigatediff1.$set(navigatediff1_changes);
      const diffhtmlview1_changes = {};
      if (dirty & 128)
        diffhtmlview1_changes.diff = ctx2[7].diff;
      if (dirty & 128)
        diffhtmlview1_changes.uri = ctx2[7].uri;
      if (!updating_withoutStyle_1 && dirty & 1) {
        updating_withoutStyle_1 = true;
        diffhtmlview1_changes.withoutStyle = ctx2[0];
        add_flush_callback(() => updating_withoutStyle_1 = false);
      }
      if (!updating_goToNextDiff_1 && dirty & 32) {
        updating_goToNextDiff_1 = true;
        diffhtmlview1_changes.goToNextDiff = ctx2[5];
        add_flush_callback(() => updating_goToNextDiff_1 = false);
      }
      if (!updating_goToPrevDiff_1 && dirty & 64) {
        updating_goToPrevDiff_1 = true;
        diffhtmlview1_changes.goToPrevDiff = ctx2[6];
        add_flush_callback(() => updating_goToPrevDiff_1 = false);
      }
      diffhtmlview1.$set(diffhtmlview1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(navigatediff0.$$.fragment, local);
      transition_in(diffhtmlview0.$$.fragment, local);
      transition_in(if_block1);
      transition_in(navigatediff1.$$.fragment, local);
      transition_in(diffhtmlview1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(navigatediff0.$$.fragment, local);
      transition_out(diffhtmlview0.$$.fragment, local);
      transition_out(if_block1);
      transition_out(navigatediff1.$$.fragment, local);
      transition_out(diffhtmlview1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      destroy_component(navigatediff0);
      destroy_component(diffhtmlview0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      if (if_block1)
        if_block1.d();
      destroy_component(navigatediff1);
      destroy_component(diffhtmlview1);
    }
  };
}
function instance$3m($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(7, $store = $$value));
  let { withoutStyle = false } = $$props;
  let showLoader1 = true;
  let showLoader2 = true;
  let view1GoToNextDiff, view1GoToPrevDiff, view2GoToNextDiff, view2GoToPrevDiff;
  function diffhtmlview0_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(0, withoutStyle);
  }
  function diffhtmlview0_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(3, view1GoToNextDiff);
  }
  function diffhtmlview0_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(4, view1GoToPrevDiff);
  }
  const load_handler = () => $$invalidate(1, showLoader1 = false);
  function diffhtmlview1_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(0, withoutStyle);
  }
  function diffhtmlview1_goToNextDiff_binding(value) {
    view2GoToNextDiff = value;
    $$invalidate(5, view2GoToNextDiff);
  }
  function diffhtmlview1_goToPrevDiff_binding(value) {
    view2GoToPrevDiff = value;
    $$invalidate(6, view2GoToPrevDiff);
  }
  const load_handler_1 = () => $$invalidate(2, showLoader2 = false);
  $$self.$$set = ($$props2) => {
    if ("withoutStyle" in $$props2)
      $$invalidate(0, withoutStyle = $$props2.withoutStyle);
  };
  return [
    withoutStyle,
    showLoader1,
    showLoader2,
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    diffhtmlview0_withoutStyle_binding,
    diffhtmlview0_goToNextDiff_binding,
    diffhtmlview0_goToPrevDiff_binding,
    load_handler,
    diffhtmlview1_withoutStyle_binding,
    diffhtmlview1_goToNextDiff_binding,
    diffhtmlview1_goToPrevDiff_binding,
    load_handler_1
  ];
}
class HTMLSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3m, create_fragment$3q, safe_not_equal, { withoutStyle: 0 });
  }
}
function create_else_block$X(ctx) {
  let htmlsidebysidediff;
  let current;
  htmlsidebysidediff = new HTMLSideBySideDiff({
    props: { withoutStyle: ctx[1] }
  });
  return {
    c() {
      create_component(htmlsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmlsidebysidediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const htmlsidebysidediff_changes = {};
      if (dirty & 2)
        htmlsidebysidediff_changes.withoutStyle = ctx2[1];
      htmlsidebysidediff.$set(htmlsidebysidediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(htmlsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmlsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmlsidebysidediff, detaching);
    }
  };
}
function create_if_block$1I(ctx) {
  let htmlinlinediff;
  let current;
  htmlinlinediff = new HTMLInlineDiff({
    props: { withoutStyle: ctx[1] }
  });
  return {
    c() {
      create_component(htmlinlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmlinlinediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const htmlinlinediff_changes = {};
      if (dirty & 2)
        htmlinlinediff_changes.withoutStyle = ctx2[1];
      htmlinlinediff.$set(htmlinlinediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(htmlinlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmlinlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmlinlinediff, detaching);
    }
  };
}
function create_fragment$3p(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1I, create_else_block$X];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex-grow flex min-h-full w-full");
      set_style(div, "height", "fit-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3l($$self, $$props, $$invalidate) {
  let { inlined } = $$props;
  let { withoutStyle = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
    if ("withoutStyle" in $$props2)
      $$invalidate(1, withoutStyle = $$props2.withoutStyle);
  };
  return [inlined, withoutStyle];
}
class ExploreHTMLDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3l, create_fragment$3p, safe_not_equal, { inlined: 0, withoutStyle: 1 });
  }
}
function create_fragment$3o(ctx) {
  let div;
  let iframe_1;
  let iframe_1_class_value;
  let iframe_1_scrolling_value;
  let iframe_1_style_value;
  return {
    c() {
      div = element("div");
      iframe_1 = element("iframe");
      attr(iframe_1, "class", iframe_1_class_value = "w-full border-none " + ctx[3]);
      attr(iframe_1, "scrolling", iframe_1_scrolling_value = ctx[2] ? "" : "no");
      attr(iframe_1, "srcdoc", ctx[0]);
      attr(iframe_1, "style", iframe_1_style_value = "min-height:100px;" + ctx[4]);
      set_style(iframe_1, "height", ctx[6]);
      attr(div, "class", ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, iframe_1);
      ctx[19](iframe_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8 && iframe_1_class_value !== (iframe_1_class_value = "w-full border-none " + ctx2[3])) {
        attr(iframe_1, "class", iframe_1_class_value);
      }
      if (dirty[0] & 4 && iframe_1_scrolling_value !== (iframe_1_scrolling_value = ctx2[2] ? "" : "no")) {
        attr(iframe_1, "scrolling", iframe_1_scrolling_value);
      }
      if (dirty[0] & 1) {
        attr(iframe_1, "srcdoc", ctx2[0]);
      }
      if (dirty[0] & 16 && iframe_1_style_value !== (iframe_1_style_value = "min-height:100px;" + ctx2[4])) {
        attr(iframe_1, "style", iframe_1_style_value);
      }
      const style_changed = dirty[0] & 16;
      if (style_changed || dirty[0] & 80) {
        set_style(iframe_1, "height", ctx2[6]);
      }
      if (dirty[0] & 32) {
        attr(div, "class", ctx2[5]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[19](null);
    }
  };
}
const highlightClass$1 = "highlighted";
function getDiffNodes(parentEl, diffs, options = {}) {
  let { selector } = options;
  diffs.nodes = [];
  diffs.curr = null;
  diffs.nodes = Array.from(parentEl.querySelectorAll(selector));
}
function instance$3k($$self, $$props, $$invalidate) {
  let { oldData } = $$props;
  let { newData } = $$props;
  let { diff: diff2 } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { hideRemoved = false } = $$props;
  let { hideInserted = false } = $$props;
  let { snipped = false } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { diffNavigation = false } = $$props;
  let { showScrollBar } = $$props;
  let { iframe } = $$props;
  let { iframeClass = "" } = $$props;
  let { iframeStyle = "" } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  const dispatch = createEventDispatcher();
  const STEP = { NEXT: 1, PREV: -1 };
  const selector = generateSelector();
  let { class: classes2 = "" } = $$props;
  let iframeDocEl;
  let loaded = false;
  let height;
  let diffs = { nodes: [], curr: null };
  onMount(() => {
    $$invalidate(1, iframe.onload = onLoad, iframe);
  });
  function setIframeHeight() {
    const doc = iframe.contentWindow.document;
    const html2 = doc.documentElement;
    const body = doc.body;
    $$invalidate(6, height = Math.max(body.scrollHeight, body.offsetHeight, html2.clientHeight, html2.scrollHeight, html2.offsetHeight) + "px");
  }
  function countAdditions() {
    $$invalidate(7, additions = iframeDocEl.querySelectorAll("ins").length);
  }
  function countDeletions() {
    $$invalidate(8, deletions = iframeDocEl.querySelectorAll("del").length);
  }
  function onLoad() {
    iframeDocEl = iframe.contentDocument.documentElement;
    countAdditions();
    countDeletions();
    if (diffNavigation) {
      getDiffNodes(iframeDocEl, diffs, { selector });
      if (scrollToFirstDiff) {
        goToFirstDiff();
      }
    }
    $$invalidate(18, loaded = true);
    dispatch("load");
  }
  function setDiffStyles() {
    let styleEl = iframeDocEl.querySelector("style.xdistill");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.classList.add("xdistill");
      iframeDocEl.querySelector("body").appendChild(styleEl);
    }
    let content = `
      ${diffStyles}
      body{
        padding: 20px;
      }
      ins,del {
        text-decoration: none;
      }
      .highlighted {
     outline: blue solid 2px;
      }
     ${hideRemoved ? "del{ display:none;}" : ""}
     ${hideInserted ? "ins{ display:none;}" : ""}
     ${snipped ? "body > span{display:none;}" : ""}
    `;
    styleEl.innerHTML = content;
    setIframeHeight();
  }
  function getDiff2() {
    try {
      if (oldData === newData) {
        $$invalidate(0, diff2 = htmlEscape(newData));
        $$invalidate(7, additions = $$invalidate(8, deletions = 0));
        return;
      }
      $$invalidate(0, { diff: diff2 } = Diff.diff(oldData, newData), diff2);
      $$invalidate(0, diff2 = diff2.replace(/\&para;/g, ""));
    } catch (e) {
      console.error(e);
      $$invalidate(0, diff2 = newData);
    }
  }
  function generateSelector() {
    const selectors = [];
    if (!hideInserted) {
      selectors.push("ins");
    }
    if (!hideRemoved) {
      selectors.push("del");
    }
    return selectors.join(",");
  }
  function goToFirstDiff() {
    const firstDiffEl = diffs.nodes[0];
    if (firstDiffEl) {
      diffs.curr = 0;
      firstDiffEl.scrollIntoView({ behaviour: "smooth", block: "center" });
      firstDiffEl.classList.add(highlightClass$1);
    }
  }
  function goToDiff(step) {
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next2 = curr + step;
    if (next2 < 0) {
      next2 = length - 1;
    } else if (next2 >= length) {
      next2 = 0;
    }
    const currDiff = nodes[curr];
    const nextDiff = nodes[next2];
    currDiff == null ? void 0 : currDiff.classList.remove(highlightClass$1);
    nextDiff.classList.add(highlightClass$1);
    nextDiff.scrollIntoView({ behaviour: "smooth", block: "center" });
    diffs.curr = next2;
  }
  function iframe_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframe = $$value;
      $$invalidate(1, iframe);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("oldData" in $$props2)
      $$invalidate(9, oldData = $$props2.oldData);
    if ("newData" in $$props2)
      $$invalidate(10, newData = $$props2.newData);
    if ("diff" in $$props2)
      $$invalidate(0, diff2 = $$props2.diff);
    if ("additions" in $$props2)
      $$invalidate(7, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(8, deletions = $$props2.deletions);
    if ("hideRemoved" in $$props2)
      $$invalidate(11, hideRemoved = $$props2.hideRemoved);
    if ("hideInserted" in $$props2)
      $$invalidate(12, hideInserted = $$props2.hideInserted);
    if ("snipped" in $$props2)
      $$invalidate(13, snipped = $$props2.snipped);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(14, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(15, diffNavigation = $$props2.diffNavigation);
    if ("showScrollBar" in $$props2)
      $$invalidate(2, showScrollBar = $$props2.showScrollBar);
    if ("iframe" in $$props2)
      $$invalidate(1, iframe = $$props2.iframe);
    if ("iframeClass" in $$props2)
      $$invalidate(3, iframeClass = $$props2.iframeClass);
    if ("iframeStyle" in $$props2)
      $$invalidate(4, iframeStyle = $$props2.iframeStyle);
    if ("class" in $$props2)
      $$invalidate(5, classes2 = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1) {
      $$invalidate(18, loaded = false);
    }
    if ($$self.$$.dirty[0] & 1536) {
      oldData && newData && getDiff2();
    }
    if ($$self.$$.dirty[0] & 276481) {
      loaded && setDiffStyles();
    }
  };
  return [
    diff2,
    iframe,
    showScrollBar,
    iframeClass,
    iframeStyle,
    classes2,
    height,
    additions,
    deletions,
    oldData,
    newData,
    hideRemoved,
    hideInserted,
    snipped,
    scrollToFirstDiff,
    diffNavigation,
    goToNextDiff,
    goToPrevDiff,
    loaded,
    iframe_1_binding
  ];
}
class DiffXmlView extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3k,
      create_fragment$3o,
      safe_not_equal,
      {
        oldData: 9,
        newData: 10,
        diff: 0,
        additions: 7,
        deletions: 8,
        hideRemoved: 11,
        hideInserted: 12,
        snipped: 13,
        scrollToFirstDiff: 14,
        diffNavigation: 15,
        showScrollBar: 2,
        iframe: 1,
        iframeClass: 3,
        iframeStyle: 4,
        goToNextDiff: 16,
        goToPrevDiff: 17,
        class: 5
      },
      null,
      [-1, -1]
    );
  }
  get goToNextDiff() {
    return this.$$.ctx[16];
  }
  get goToPrevDiff() {
    return this.$$.ctx[17];
  }
}
function create_fragment$3n(ctx) {
  let div1;
  let div0;
  let navigatediff;
  let t;
  let diffxmlview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  navigatediff = new NavigateDiff({
    props: {
      class: "ml-5 bg-transparent",
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function diffxmlview_goToNextDiff_binding(value) {
    ctx[3](value);
  }
  function diffxmlview_goToPrevDiff_binding(value) {
    ctx[4](value);
  }
  let diffxmlview_props = {
    diff: ctx[2].diff,
    scrollToFirstDiff: true,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[0] !== void 0) {
    diffxmlview_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    diffxmlview_props.goToPrevDiff = ctx[1];
  }
  diffxmlview = new DiffXmlView({ props: diffxmlview_props });
  binding_callbacks.push(() => bind$2(diffxmlview, "goToNextDiff", diffxmlview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffxmlview, "goToPrevDiff", diffxmlview_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff.$$.fragment);
      t = space();
      create_component(diffxmlview.$$.fragment);
      attr(div0, "class", "flex justify-start sticky top-0");
      attr(div1, "class", "flex flex-column self-stretch flex-grow");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff, div0, null);
      append(div1, t);
      mount_component(diffxmlview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 1)
        navigatediff_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff_changes.prevFn = ctx2[1];
      navigatediff.$set(navigatediff_changes);
      const diffxmlview_changes = {};
      if (dirty & 4)
        diffxmlview_changes.diff = ctx2[2].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        diffxmlview_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        diffxmlview_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffxmlview.$set(diffxmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      transition_in(diffxmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      transition_out(diffxmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff);
      destroy_component(diffxmlview);
    }
  };
}
function instance$3j($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(2, $store = $$value));
  let goToNextDiff;
  let goToPrevDiff;
  function diffxmlview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(0, goToNextDiff);
  }
  function diffxmlview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(1, goToPrevDiff);
  }
  return [
    goToNextDiff,
    goToPrevDiff,
    $store,
    diffxmlview_goToNextDiff_binding,
    diffxmlview_goToPrevDiff_binding
  ];
}
class XmlInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3j, create_fragment$3n, safe_not_equal, {});
  }
}
function create_fragment$3m(ctx) {
  let div1;
  let div0;
  let navigatediff0;
  let t0;
  let diffxmlview0;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let t1;
  let div3;
  let div2;
  let navigatediff1;
  let t2;
  let diffxmlview1;
  let updating_goToNextDiff_1;
  let updating_goToPrevDiff_1;
  let current;
  navigatediff0 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function diffxmlview0_goToNextDiff_binding(value) {
    ctx[5](value);
  }
  function diffxmlview0_goToPrevDiff_binding(value) {
    ctx[6](value);
  }
  let diffxmlview0_props = {
    diff: ctx[4].diff,
    hideInserted: true,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[0] !== void 0) {
    diffxmlview0_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    diffxmlview0_props.goToPrevDiff = ctx[1];
  }
  diffxmlview0 = new DiffXmlView({ props: diffxmlview0_props });
  binding_callbacks.push(() => bind$2(diffxmlview0, "goToNextDiff", diffxmlview0_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffxmlview0, "goToPrevDiff", diffxmlview0_goToPrevDiff_binding));
  navigatediff1 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[2],
      prevFn: ctx[3]
    }
  });
  function diffxmlview1_goToNextDiff_binding(value) {
    ctx[7](value);
  }
  function diffxmlview1_goToPrevDiff_binding(value) {
    ctx[8](value);
  }
  let diffxmlview1_props = {
    diff: ctx[4].diff,
    hideRemoved: true,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[2] !== void 0) {
    diffxmlview1_props.goToNextDiff = ctx[2];
  }
  if (ctx[3] !== void 0) {
    diffxmlview1_props.goToPrevDiff = ctx[3];
  }
  diffxmlview1 = new DiffXmlView({ props: diffxmlview1_props });
  binding_callbacks.push(() => bind$2(diffxmlview1, "goToNextDiff", diffxmlview1_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffxmlview1, "goToPrevDiff", diffxmlview1_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff0.$$.fragment);
      t0 = space();
      create_component(diffxmlview0.$$.fragment);
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(navigatediff1.$$.fragment);
      t2 = space();
      create_component(diffxmlview1.$$.fragment);
      attr(div0, "class", "flex justify-start sticky bg-white top-0");
      attr(div1, "class", "flex-grow flex flex-column items-stretch");
      attr(div2, "class", "flex justify-start sticky bg-white top-0");
      attr(div3, "class", "flex-grow flex flex-column items-stretch");
      set_style(div3, "border-left", "2px solid black");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff0, div0, null);
      append(div1, t0);
      mount_component(diffxmlview0, div1, null);
      insert(target, t1, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      mount_component(navigatediff1, div2, null);
      append(div3, t2);
      mount_component(diffxmlview1, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff0_changes = {};
      if (dirty & 1)
        navigatediff0_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff0_changes.prevFn = ctx2[1];
      navigatediff0.$set(navigatediff0_changes);
      const diffxmlview0_changes = {};
      if (dirty & 16)
        diffxmlview0_changes.diff = ctx2[4].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        diffxmlview0_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        diffxmlview0_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffxmlview0.$set(diffxmlview0_changes);
      const navigatediff1_changes = {};
      if (dirty & 4)
        navigatediff1_changes.nextFn = ctx2[2];
      if (dirty & 8)
        navigatediff1_changes.prevFn = ctx2[3];
      navigatediff1.$set(navigatediff1_changes);
      const diffxmlview1_changes = {};
      if (dirty & 16)
        diffxmlview1_changes.diff = ctx2[4].diff;
      if (!updating_goToNextDiff_1 && dirty & 4) {
        updating_goToNextDiff_1 = true;
        diffxmlview1_changes.goToNextDiff = ctx2[2];
        add_flush_callback(() => updating_goToNextDiff_1 = false);
      }
      if (!updating_goToPrevDiff_1 && dirty & 8) {
        updating_goToPrevDiff_1 = true;
        diffxmlview1_changes.goToPrevDiff = ctx2[3];
        add_flush_callback(() => updating_goToPrevDiff_1 = false);
      }
      diffxmlview1.$set(diffxmlview1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff0.$$.fragment, local);
      transition_in(diffxmlview0.$$.fragment, local);
      transition_in(navigatediff1.$$.fragment, local);
      transition_in(diffxmlview1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff0.$$.fragment, local);
      transition_out(diffxmlview0.$$.fragment, local);
      transition_out(navigatediff1.$$.fragment, local);
      transition_out(diffxmlview1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff0);
      destroy_component(diffxmlview0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div3);
      destroy_component(navigatediff1);
      destroy_component(diffxmlview1);
    }
  };
}
function instance$3i($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(4, $store = $$value));
  let view1GoToNextDiff, view1GoToPrevDiff, view2GoToNextDiff, view2GoToPrevDiff;
  function diffxmlview0_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(0, view1GoToNextDiff);
  }
  function diffxmlview0_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(1, view1GoToPrevDiff);
  }
  function diffxmlview1_goToNextDiff_binding(value) {
    view2GoToNextDiff = value;
    $$invalidate(2, view2GoToNextDiff);
  }
  function diffxmlview1_goToPrevDiff_binding(value) {
    view2GoToPrevDiff = value;
    $$invalidate(3, view2GoToPrevDiff);
  }
  return [
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    diffxmlview0_goToNextDiff_binding,
    diffxmlview0_goToPrevDiff_binding,
    diffxmlview1_goToNextDiff_binding,
    diffxmlview1_goToPrevDiff_binding
  ];
}
class XmlSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3i, create_fragment$3m, safe_not_equal, {});
  }
}
function create_else_block$W(ctx) {
  let xmlsidebysidediff;
  let current;
  xmlsidebysidediff = new XmlSideBySideDiff({});
  return {
    c() {
      create_component(xmlsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(xmlsidebysidediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(xmlsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(xmlsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(xmlsidebysidediff, detaching);
    }
  };
}
function create_if_block$1H(ctx) {
  let xmlinlinediff;
  let current;
  xmlinlinediff = new XmlInlineDiff({});
  return {
    c() {
      create_component(xmlinlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(xmlinlinediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(xmlinlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(xmlinlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(xmlinlinediff, detaching);
    }
  };
}
function create_fragment$3l(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1H, create_else_block$W];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex-grow flex w-full min-h-full");
      set_style(div, "height", "fit-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3h($$self, $$props, $$invalidate) {
  let { inlined } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
  };
  return [inlined];
}
class ExploreXmlDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3h, create_fragment$3l, safe_not_equal, { inlined: 0 });
  }
}
function create_fragment$3k(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "form-control xform-control-sm p-1");
      attr(input, "placeholder", "Search...");
      attr(div, "class", "form-group mb-0 mr-6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[2]),
          listen(input, "input", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3g($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let phrase = "";
  function onInput() {
    dispatch("search", { phrase: phrase.trim() });
  }
  function input_input_handler() {
    phrase = this.value;
    $$invalidate(0, phrase);
  }
  return [phrase, onInput, input_input_handler];
}
class SearchBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3g, create_fragment$3k, safe_not_equal, {});
  }
}
var diff = "";
function get_each_context$P(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i2];
  child_ctx[43] = i2;
  return child_ctx;
}
function create_catch_block$o(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$o(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[9];
  const get_key = (ctx2) => ctx2[41].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$P(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$P(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$V(ctx);
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 3902) {
        each_value = ctx2[9];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$P, each_1_anchor, get_each_context$P);
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$V(ctx2);
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_else_block$V(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[8])
      return create_if_block_1$17;
    return create_else_block_1$d;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_1$d(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No URLs found </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block_1$17(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No URLs found for this search query </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block$1G(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[41].url + "";
  let t0;
  let td0_title_value;
  let td0_class_value;
  let t1;
  let td1;
  let t2_value = ctx[41].status_code + "";
  let t2;
  let t3;
  let checkRender_action;
  let mounted;
  let dispose;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      attr(td0, "title", td0_title_value = ctx[41].url);
      attr(td0, "class", td0_class_value = "" + ctx[10][ctx[41].diff_type] + " " + ctx[5]);
      toggle_class(tr, "opacity-0", ctx[3] && ctx[41].diff_type === ctx[11].addition || ctx[2] && ctx[41].diff_type === ctx[11].deletion);
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      if (!mounted) {
        dispose = action_destroyer(checkRender_action = ctx[13].call(null, tr, ctx[43]));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 512 && t0_value !== (t0_value = ctx[41].url + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 512 && td0_title_value !== (td0_title_value = ctx[41].url)) {
        attr(td0, "title", td0_title_value);
      }
      if (dirty[0] & 544 && td0_class_value !== (td0_class_value = "" + ctx[10][ctx[41].diff_type] + " " + ctx[5])) {
        attr(td0, "class", td0_class_value);
      }
      if (dirty[0] & 512 && t2_value !== (t2_value = ctx[41].status_code + ""))
        set_data(t2, t2_value);
      if (checkRender_action && is_function(checkRender_action.update) && dirty[0] & 512)
        checkRender_action.update.call(null, ctx[43]);
      if (dirty[0] & 2572) {
        toggle_class(tr, "opacity-0", ctx[3] && ctx[41].diff_type === ctx[11].addition || ctx[2] && ctx[41].diff_type === ctx[11].deletion);
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$P(key_1, ctx) {
  let first;
  let if_block_anchor;
  let if_block = !(ctx[1] && ctx[41].diff_type === ctx[11].deletion || ctx[4] && ctx[41].diff_type === ctx[11].unchanged) && create_if_block$1G(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!(ctx[1] && ctx[41].diff_type === ctx[11].deletion || ctx[4] && ctx[41].diff_type === ctx[11].unchanged)) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$1G(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$o(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_fragment$3j(ctx) {
  let div2;
  let div0;
  let searchbar;
  let t0;
  let div1;
  let table;
  let thead;
  let t4;
  let tbody_1;
  let promise;
  let current;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[12]);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$o,
    then: create_then_block$o,
    catch: create_catch_block$o,
    value: 40
  };
  handle_promise(promise = ctx[0], info);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(searchbar.$$.fragment);
      t0 = space();
      div1 = element("div");
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th>URL</th> 
          <th>Status Code</th></tr>`;
      t4 = space();
      tbody_1 = element("tbody");
      info.block.c();
      attr(div0, "class", "mt-6 mb-2 w-[300px] pl-2");
      attr(thead, "class", "table-light");
      attr(table, "class", "table");
      attr(div1, "id", "myTable");
      attr(div2, "class", ctx[6]);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(searchbar, div0, null);
      append(div2, t0);
      append(div2, div1);
      append(div1, table);
      append(table, thead);
      append(table, t4);
      append(table, tbody_1);
      info.block.m(tbody_1, info.anchor = null);
      info.mount = () => tbody_1;
      info.anchor = null;
      ctx[27](tbody_1);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty[0] & 1 && promise !== (promise = ctx[0]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      if (!current || dirty[0] & 64) {
        attr(div2, "class", ctx[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(searchbar);
      info.block.d();
      info.token = null;
      info = null;
      ctx[27](null);
    }
  };
}
const highlightClass = "xhighlighted";
function removeHighlighting(node2) {
  const highlightedEl = node2.querySelector(`.${highlightClass}`);
  if (highlightedEl) {
    highlightedEl.classList.remove(highlightClass);
  }
}
function instance$3f($$self, $$props, $$invalidate) {
  let { newData } = $$props;
  let { oldData } = $$props;
  let { diff: diff2 } = $$props;
  let { sitemapDiffpromise } = $$props;
  let { pruneDeletions = false } = $$props;
  let { hideDeletions = false } = $$props;
  let { hideAdditions = false } = $$props;
  let { snipped = false } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { diffNavigation = false } = $$props;
  let { diffView } = $$props;
  let { urlClass = "" } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  if (typeof oldData === "string") {
    oldData = JSON.parse(oldData);
  }
  if (typeof newData === "string") {
    newData = JSON.parse(newData);
  }
  const crawlerId = newData == null ? void 0 : newData.crawler_id;
  const dispatch = createEventDispatcher();
  const STEP = { NEXT: 1, PREV: -1 };
  const selector = getSelector();
  const diffClass = {
    addition: "inserted",
    deletion: "removed",
    unchanged: ""
  };
  const diffType = {
    addition: "addition",
    deletion: "deletion",
    unchanged: "unchanged"
  };
  let tbody;
  let summary;
  let diffs = { nodes: [], curr: null };
  let filteredDiff;
  let init2 = diff2 ? true : false;
  let diffRendered = false;
  let searchPhrase = "";
  let { class: classes2 = "" } = $$props;
  async function getDiff2(jobId1, jobId2) {
    try {
      $$invalidate(25, init2 = false);
      let diffEndpoint = `/crawlers/data/${crawlerId}/diff/${jobId1}`;
      if (jobId2) {
        diffEndpoint += `?id2=${jobId2}`;
      }
      const diffData = await Api.api(diffEndpoint);
      $$invalidate(24, { summary, diff: diff2 } = diffData, summary, $$invalidate(16, diff2));
      $$invalidate(9, filteredDiff = diff2);
      $$invalidate(25, init2 = true);
      dispatch("load");
      $$invalidate(19, diffView = diffData.summary);
    } catch (err) {
      console.error(`Error while generating diff for crawler:${crawlerId} : id1:${jobId1} -> id2:${jobId2}`, err);
    }
  }
  function filterDiff() {
    if (!searchPhrase) {
      $$invalidate(9, filteredDiff = diff2);
      return;
    }
    $$invalidate(9, filteredDiff = diff2.filter((diffData) => {
      if (hideAdditions && diffData.diff_type === diffType.addition || hideDeletions && diffData.diff_type === diffType.deletion) {
        return false;
      }
      return diffData.url.includes(searchPhrase);
    }));
  }
  function getSelector() {
    const selArr = [];
    if (!hideAdditions) {
      selArr.push(".inserted");
    }
    if (!hideDeletions) {
      selArr.push(".removed");
    }
    return selArr.join(",");
  }
  function goToDiff(step) {
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next2 = curr + step;
    if (next2 < 0) {
      next2 = length - 1;
    } else if (next2 >= length) {
      next2 = 0;
    }
    const currDiff = nodes[curr];
    const nextDiff = nodes[next2];
    currDiff == null ? void 0 : currDiff.classList.remove(highlightClass);
    nextDiff.classList.add(highlightClass);
    nextDiff.scrollIntoView({ behaviour: "smooth", block: "center" });
    diffs.curr = next2;
  }
  function goToFirstDiff() {
    const firstDiffEl = diffs.nodes[0];
    if (firstDiffEl) {
      diffs.curr = 0;
      firstDiffEl.scrollIntoView({ behaviour: "smooth", block: "center" });
      firstDiffEl.classList.add(highlightClass);
    }
  }
  function getDiffNodes2(node2, selector2) {
    diffs.nodes = [];
    diffs.curr = null;
    diffs.nodes = Array.from(node2.querySelectorAll(selector2));
  }
  function onSearch2(e) {
    $$invalidate(8, searchPhrase = e.detail.phrase);
    filterDiff();
  }
  function diffNavigationActions(node2) {
    removeHighlighting(node2);
    getDiffNodes2(node2, selector);
    if (scrollToFirstDiff) {
      goToFirstDiff();
    }
    $$invalidate(26, diffRendered = false);
  }
  function checkRender(_2, index2) {
    if (index2 === filteredDiff.length - 1)
      $$invalidate(26, diffRendered = true);
    return {
      update: (index3) => {
        if (index3 === filteredDiff.length - 1) {
          $$invalidate(26, diffRendered = true);
        }
      }
    };
  }
  function tbody_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tbody = $$value;
      $$invalidate(7, tbody);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("newData" in $$props2)
      $$invalidate(14, newData = $$props2.newData);
    if ("oldData" in $$props2)
      $$invalidate(15, oldData = $$props2.oldData);
    if ("diff" in $$props2)
      $$invalidate(16, diff2 = $$props2.diff);
    if ("sitemapDiffpromise" in $$props2)
      $$invalidate(0, sitemapDiffpromise = $$props2.sitemapDiffpromise);
    if ("pruneDeletions" in $$props2)
      $$invalidate(1, pruneDeletions = $$props2.pruneDeletions);
    if ("hideDeletions" in $$props2)
      $$invalidate(2, hideDeletions = $$props2.hideDeletions);
    if ("hideAdditions" in $$props2)
      $$invalidate(3, hideAdditions = $$props2.hideAdditions);
    if ("snipped" in $$props2)
      $$invalidate(4, snipped = $$props2.snipped);
    if ("additions" in $$props2)
      $$invalidate(17, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(18, deletions = $$props2.deletions);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(20, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(21, diffNavigation = $$props2.diffNavigation);
    if ("diffView" in $$props2)
      $$invalidate(19, diffView = $$props2.diffView);
    if ("urlClass" in $$props2)
      $$invalidate(5, urlClass = $$props2.urlClass);
    if ("class" in $$props2)
      $$invalidate(6, classes2 = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 16777216) {
      if (summary) {
        $$invalidate(17, { additions, deletions } = summary, additions, ($$invalidate(18, deletions), $$invalidate(24, summary)));
      }
    }
    if ($$self.$$.dirty[0] & 49152) {
      oldData && newData && $$invalidate(0, sitemapDiffpromise = getDiff2(newData.job_id, oldData.job_id));
    }
    if ($$self.$$.dirty[0] & 33620252) {
      init2 && filterDiff();
    }
    if ($$self.$$.dirty[0] & 69206144) {
      tbody && diffNavigation && diffRendered && diffNavigationActions(tbody);
    }
  };
  return [
    sitemapDiffpromise,
    pruneDeletions,
    hideDeletions,
    hideAdditions,
    snipped,
    urlClass,
    classes2,
    tbody,
    searchPhrase,
    filteredDiff,
    diffClass,
    diffType,
    onSearch2,
    checkRender,
    newData,
    oldData,
    diff2,
    additions,
    deletions,
    diffView,
    scrollToFirstDiff,
    diffNavigation,
    goToNextDiff,
    goToPrevDiff,
    summary,
    init2,
    diffRendered,
    tbody_1_binding
  ];
}
class DiffSitemapView extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3f,
      create_fragment$3j,
      safe_not_equal,
      {
        newData: 14,
        oldData: 15,
        diff: 16,
        sitemapDiffpromise: 0,
        pruneDeletions: 1,
        hideDeletions: 2,
        hideAdditions: 3,
        snipped: 4,
        additions: 17,
        deletions: 18,
        scrollToFirstDiff: 20,
        diffNavigation: 21,
        diffView: 19,
        urlClass: 5,
        goToNextDiff: 22,
        goToPrevDiff: 23,
        class: 6
      },
      null,
      [-1, -1]
    );
  }
  get newData() {
    return this.$$.ctx[14];
  }
  set newData(newData) {
    this.$$set({ newData });
    flush();
  }
  get oldData() {
    return this.$$.ctx[15];
  }
  set oldData(oldData) {
    this.$$set({ oldData });
    flush();
  }
  get diff() {
    return this.$$.ctx[16];
  }
  set diff(diff2) {
    this.$$set({ diff: diff2 });
    flush();
  }
  get sitemapDiffpromise() {
    return this.$$.ctx[0];
  }
  set sitemapDiffpromise(sitemapDiffpromise) {
    this.$$set({ sitemapDiffpromise });
    flush();
  }
  get pruneDeletions() {
    return this.$$.ctx[1];
  }
  set pruneDeletions(pruneDeletions) {
    this.$$set({ pruneDeletions });
    flush();
  }
  get hideDeletions() {
    return this.$$.ctx[2];
  }
  set hideDeletions(hideDeletions) {
    this.$$set({ hideDeletions });
    flush();
  }
  get hideAdditions() {
    return this.$$.ctx[3];
  }
  set hideAdditions(hideAdditions) {
    this.$$set({ hideAdditions });
    flush();
  }
  get snipped() {
    return this.$$.ctx[4];
  }
  set snipped(snipped) {
    this.$$set({ snipped });
    flush();
  }
  get additions() {
    return this.$$.ctx[17];
  }
  set additions(additions) {
    this.$$set({ additions });
    flush();
  }
  get deletions() {
    return this.$$.ctx[18];
  }
  set deletions(deletions) {
    this.$$set({ deletions });
    flush();
  }
  get scrollToFirstDiff() {
    return this.$$.ctx[20];
  }
  set scrollToFirstDiff(scrollToFirstDiff) {
    this.$$set({ scrollToFirstDiff });
    flush();
  }
  get diffNavigation() {
    return this.$$.ctx[21];
  }
  set diffNavigation(diffNavigation) {
    this.$$set({ diffNavigation });
    flush();
  }
  get diffView() {
    return this.$$.ctx[19];
  }
  set diffView(diffView) {
    this.$$set({ diffView });
    flush();
  }
  get urlClass() {
    return this.$$.ctx[5];
  }
  set urlClass(urlClass) {
    this.$$set({ urlClass });
    flush();
  }
  get goToNextDiff() {
    return this.$$.ctx[22];
  }
  get goToPrevDiff() {
    return this.$$.ctx[23];
  }
  get class() {
    return this.$$.ctx[6];
  }
  set class(classes2) {
    this.$$set({ class: classes2 });
    flush();
  }
}
function create_fragment$3i(ctx) {
  let div1;
  let div0;
  let navigatediff;
  let t;
  let diffsitemapview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  navigatediff = new NavigateDiff({
    props: {
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function diffsitemapview_goToNextDiff_binding(value) {
    ctx[3](value);
  }
  function diffsitemapview_goToPrevDiff_binding(value) {
    ctx[4](value);
  }
  let diffsitemapview_props = {
    scrollToFirstDiff: true,
    class: "flex-grow",
    urlClass: "truncate max-w-[50vw]",
    diff: ctx[2].diff,
    diffNavigation: true
  };
  if (ctx[0] !== void 0) {
    diffsitemapview_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    diffsitemapview_props.goToPrevDiff = ctx[1];
  }
  diffsitemapview = new DiffSitemapView({ props: diffsitemapview_props });
  binding_callbacks.push(() => bind$2(diffsitemapview, "goToNextDiff", diffsitemapview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffsitemapview, "goToPrevDiff", diffsitemapview_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff.$$.fragment);
      t = space();
      create_component(diffsitemapview.$$.fragment);
      attr(div0, "class", "flex mb-3 sticky top-0 bg-transparent");
      attr(div1, "class", "flex-grow pl-5 pr-5 flex flex-column");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff, div0, null);
      append(div1, t);
      mount_component(diffsitemapview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 1)
        navigatediff_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff_changes.prevFn = ctx2[1];
      navigatediff.$set(navigatediff_changes);
      const diffsitemapview_changes = {};
      if (dirty & 4)
        diffsitemapview_changes.diff = ctx2[2].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        diffsitemapview_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        diffsitemapview_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffsitemapview.$set(diffsitemapview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      transition_in(diffsitemapview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      transition_out(diffsitemapview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff);
      destroy_component(diffsitemapview);
    }
  };
}
function instance$3e($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(2, $store = $$value));
  let goToNextDiff;
  let goToPrevDiff;
  function diffsitemapview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(0, goToNextDiff);
  }
  function diffsitemapview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(1, goToPrevDiff);
  }
  return [
    goToNextDiff,
    goToPrevDiff,
    $store,
    diffsitemapview_goToNextDiff_binding,
    diffsitemapview_goToPrevDiff_binding
  ];
}
class SitemapInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3e, create_fragment$3i, safe_not_equal, {});
  }
}
function create_fragment$3h(ctx) {
  let div1;
  let div0;
  let navigatediff0;
  let t0;
  let diffsitemapview0;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let t1;
  let div3;
  let div2;
  let navigatediff1;
  let t2;
  let diffsitemapview1;
  let updating_goToNextDiff_1;
  let updating_goToPrevDiff_1;
  let current;
  navigatediff0 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function diffsitemapview0_goToNextDiff_binding(value) {
    ctx[5](value);
  }
  function diffsitemapview0_goToPrevDiff_binding(value) {
    ctx[6](value);
  }
  let diffsitemapview0_props = {
    diff: ctx[4].diff,
    hideAdditions: true,
    class: "flex-grow  max-w-[48vw]",
    urlClass: "truncate max-w-[40vw]",
    diffNavigation: true
  };
  if (ctx[0] !== void 0) {
    diffsitemapview0_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    diffsitemapview0_props.goToPrevDiff = ctx[1];
  }
  diffsitemapview0 = new DiffSitemapView({ props: diffsitemapview0_props });
  binding_callbacks.push(() => bind$2(diffsitemapview0, "goToNextDiff", diffsitemapview0_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffsitemapview0, "goToPrevDiff", diffsitemapview0_goToPrevDiff_binding));
  navigatediff1 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[2],
      prevFn: ctx[3]
    }
  });
  function diffsitemapview1_goToNextDiff_binding(value) {
    ctx[7](value);
  }
  function diffsitemapview1_goToPrevDiff_binding(value) {
    ctx[8](value);
  }
  let diffsitemapview1_props = {
    diff: ctx[4].diff,
    hideDeletions: true,
    class: "flex-grow  max-w-[48vw]",
    diffNavigation: true,
    urlClass: "truncate max-w-[40vw]"
  };
  if (ctx[2] !== void 0) {
    diffsitemapview1_props.goToNextDiff = ctx[2];
  }
  if (ctx[3] !== void 0) {
    diffsitemapview1_props.goToPrevDiff = ctx[3];
  }
  diffsitemapview1 = new DiffSitemapView({ props: diffsitemapview1_props });
  binding_callbacks.push(() => bind$2(diffsitemapview1, "goToNextDiff", diffsitemapview1_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffsitemapview1, "goToPrevDiff", diffsitemapview1_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff0.$$.fragment);
      t0 = space();
      create_component(diffsitemapview0.$$.fragment);
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(navigatediff1.$$.fragment);
      t2 = space();
      create_component(diffsitemapview1.$$.fragment);
      attr(div0, "class", "flex justify-start sticky top-0");
      attr(div1, "class", "flex flex-column flex-1");
      attr(div2, "class", "flex justify-start sticky top-0");
      attr(div3, "class", "flex flex-column flex-1");
      set_style(div3, "border-left", "2px solid black");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff0, div0, null);
      append(div1, t0);
      mount_component(diffsitemapview0, div1, null);
      insert(target, t1, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      mount_component(navigatediff1, div2, null);
      append(div3, t2);
      mount_component(diffsitemapview1, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff0_changes = {};
      if (dirty & 1)
        navigatediff0_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff0_changes.prevFn = ctx2[1];
      navigatediff0.$set(navigatediff0_changes);
      const diffsitemapview0_changes = {};
      if (dirty & 16)
        diffsitemapview0_changes.diff = ctx2[4].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        diffsitemapview0_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        diffsitemapview0_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffsitemapview0.$set(diffsitemapview0_changes);
      const navigatediff1_changes = {};
      if (dirty & 4)
        navigatediff1_changes.nextFn = ctx2[2];
      if (dirty & 8)
        navigatediff1_changes.prevFn = ctx2[3];
      navigatediff1.$set(navigatediff1_changes);
      const diffsitemapview1_changes = {};
      if (dirty & 16)
        diffsitemapview1_changes.diff = ctx2[4].diff;
      if (!updating_goToNextDiff_1 && dirty & 4) {
        updating_goToNextDiff_1 = true;
        diffsitemapview1_changes.goToNextDiff = ctx2[2];
        add_flush_callback(() => updating_goToNextDiff_1 = false);
      }
      if (!updating_goToPrevDiff_1 && dirty & 8) {
        updating_goToPrevDiff_1 = true;
        diffsitemapview1_changes.goToPrevDiff = ctx2[3];
        add_flush_callback(() => updating_goToPrevDiff_1 = false);
      }
      diffsitemapview1.$set(diffsitemapview1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff0.$$.fragment, local);
      transition_in(diffsitemapview0.$$.fragment, local);
      transition_in(navigatediff1.$$.fragment, local);
      transition_in(diffsitemapview1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff0.$$.fragment, local);
      transition_out(diffsitemapview0.$$.fragment, local);
      transition_out(navigatediff1.$$.fragment, local);
      transition_out(diffsitemapview1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff0);
      destroy_component(diffsitemapview0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div3);
      destroy_component(navigatediff1);
      destroy_component(diffsitemapview1);
    }
  };
}
function instance$3d($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(4, $store = $$value));
  let view1GoToNextDiff;
  let view1GoToPrevDiff;
  let view2GoToNextDiff;
  let view2GoToPrevDiff;
  function diffsitemapview0_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(0, view1GoToNextDiff);
  }
  function diffsitemapview0_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(1, view1GoToPrevDiff);
  }
  function diffsitemapview1_goToNextDiff_binding(value) {
    view2GoToNextDiff = value;
    $$invalidate(2, view2GoToNextDiff);
  }
  function diffsitemapview1_goToPrevDiff_binding(value) {
    view2GoToPrevDiff = value;
    $$invalidate(3, view2GoToPrevDiff);
  }
  return [
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    diffsitemapview0_goToNextDiff_binding,
    diffsitemapview0_goToPrevDiff_binding,
    diffsitemapview1_goToNextDiff_binding,
    diffsitemapview1_goToPrevDiff_binding
  ];
}
class SitemapSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3d, create_fragment$3h, safe_not_equal, {});
  }
}
function create_else_block$U(ctx) {
  let sitemapsidebysidediff;
  let current;
  sitemapsidebysidediff = new SitemapSideBySideDiff({});
  return {
    c() {
      create_component(sitemapsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sitemapsidebysidediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(sitemapsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sitemapsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sitemapsidebysidediff, detaching);
    }
  };
}
function create_if_block$1F(ctx) {
  let sitemapinlinediff;
  let current;
  sitemapinlinediff = new SitemapInlineDiff({});
  return {
    c() {
      create_component(sitemapinlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sitemapinlinediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(sitemapinlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sitemapinlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sitemapinlinediff, detaching);
    }
  };
}
function create_fragment$3g(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1F, create_else_block$U];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex items-stretch max-w-[100vw]");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3c($$self, $$props, $$invalidate) {
  let { inlined = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
  };
  return [inlined];
}
class ExploreSitemapDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3c, create_fragment$3g, safe_not_equal, { inlined: 0 });
  }
}
function create_catch_block$n(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$n(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1E, create_if_block_5$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3].diff)
      return 0;
    if (ctx2[3].errorMessage)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "flex-grow overflow-y-auto bg-white pt2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_5$h(ctx) {
  let div;
  let t0_value = ctx[3].errorMessage + "";
  let t0;
  let t1;
  let p;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      p = element("p");
      p.textContent = `${T("m_sieve_count_per_plan")}`;
      attr(p, "class", "help");
      attr(div, "class", "alert alert-danger ma3 ");
      attr(div, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, p);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t0_value !== (t0_value = ctx2[3].errorMessage + ""))
        set_data(t0, t0_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$1E(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$16, create_if_block_2$N, create_if_block_3$B, create_if_block_4$q];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (show_if == null)
      show_if = !!ctx2[7]();
    if (show_if)
      return 0;
    if (ctx2[3].type === C$2.TYPE_JSON)
      return 1;
    if (ctx2[3].type === C$2.TYPE_XML)
      return 2;
    if (ctx2[3].type === C$2.TYPE_SITEMAP)
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_4$q(ctx) {
  let exploresitemapdiff;
  let current;
  exploresitemapdiff = new ExploreSitemapDiff({ props: { inlined: ctx[1] } });
  return {
    c() {
      create_component(exploresitemapdiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exploresitemapdiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exploresitemapdiff_changes = {};
      if (dirty & 2)
        exploresitemapdiff_changes.inlined = ctx2[1];
      exploresitemapdiff.$set(exploresitemapdiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(exploresitemapdiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exploresitemapdiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exploresitemapdiff, detaching);
    }
  };
}
function create_if_block_3$B(ctx) {
  let explorexmldiff;
  let current;
  explorexmldiff = new ExploreXmlDiff({ props: { inlined: ctx[1] } });
  return {
    c() {
      create_component(explorexmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorexmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorexmldiff_changes = {};
      if (dirty & 2)
        explorexmldiff_changes.inlined = ctx2[1];
      explorexmldiff.$set(explorexmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorexmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorexmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorexmldiff, detaching);
    }
  };
}
function create_if_block_2$N(ctx) {
  let explorejsondiff;
  let current;
  explorejsondiff = new ExploreJSONDiff({ props: { inlined: ctx[1] } });
  return {
    c() {
      create_component(explorejsondiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorejsondiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorejsondiff_changes = {};
      if (dirty & 2)
        explorejsondiff_changes.inlined = ctx2[1];
      explorejsondiff.$set(explorejsondiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorejsondiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorejsondiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorejsondiff, detaching);
    }
  };
}
function create_if_block_1$16(ctx) {
  let explorehtmldiff;
  let updating_withoutStyle;
  let current;
  function explorehtmldiff_withoutStyle_binding(value) {
    ctx[13](value);
  }
  let explorehtmldiff_props = { inlined: ctx[1] };
  if (ctx[2] !== void 0) {
    explorehtmldiff_props.withoutStyle = ctx[2];
  }
  explorehtmldiff = new ExploreHTMLDiff({ props: explorehtmldiff_props });
  binding_callbacks.push(() => bind$2(explorehtmldiff, "withoutStyle", explorehtmldiff_withoutStyle_binding));
  return {
    c() {
      create_component(explorehtmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorehtmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorehtmldiff_changes = {};
      if (dirty & 2)
        explorehtmldiff_changes.inlined = ctx2[1];
      if (!updating_withoutStyle && dirty & 4) {
        updating_withoutStyle = true;
        explorehtmldiff_changes.withoutStyle = ctx2[2];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      explorehtmldiff.$set(explorehtmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorehtmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorehtmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorehtmldiff, detaching);
    }
  };
}
function create_pending_block$n(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3f(ctx) {
  let div;
  let explorediffheader;
  let updating_inlined;
  let updating_withoutStyle;
  let t;
  let current;
  function explorediffheader_inlined_binding(value) {
    ctx[11](value);
  }
  function explorediffheader_withoutStyle_binding(value) {
    ctx[12](value);
  }
  let explorediffheader_props = {
    class: "bb b--light-gray",
    promise: ctx[5],
    showStyleMode: ctx[3].type === C$2.TYPE_HTML,
    selectedDiffContentMode: ctx[0]
  };
  if (ctx[1] !== void 0) {
    explorediffheader_props.inlined = ctx[1];
  }
  if (ctx[2] !== void 0) {
    explorediffheader_props.withoutStyle = ctx[2];
  }
  explorediffheader = new ExploreDiffHeader({ props: explorediffheader_props });
  binding_callbacks.push(() => bind$2(explorediffheader, "inlined", explorediffheader_inlined_binding));
  binding_callbacks.push(() => bind$2(explorediffheader, "withoutStyle", explorediffheader_withoutStyle_binding));
  explorediffheader.$on("close", ctx[6]);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$n,
    then: create_then_block$n,
    catch: create_catch_block$n,
    value: 17,
    blocks: [, , ,]
  };
  handle_promise(ctx[5], info);
  return {
    c() {
      div = element("div");
      create_component(explorediffheader.$$.fragment);
      t = space();
      info.block.c();
      attr(div, "class", "flex flex-column h-screen");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(explorediffheader, div, null);
      append(div, t);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const explorediffheader_changes = {};
      if (dirty & 8)
        explorediffheader_changes.showStyleMode = ctx[3].type === C$2.TYPE_HTML;
      if (dirty & 1)
        explorediffheader_changes.selectedDiffContentMode = ctx[0];
      if (!updating_inlined && dirty & 2) {
        updating_inlined = true;
        explorediffheader_changes.inlined = ctx[1];
        add_flush_callback(() => updating_inlined = false);
      }
      if (!updating_withoutStyle && dirty & 4) {
        updating_withoutStyle = true;
        explorediffheader_changes.withoutStyle = ctx[2];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      explorediffheader.$set(explorediffheader_changes);
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorediffheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(explorediffheader.$$.fragment, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(explorediffheader);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$3b($$self, $$props, $$invalidate) {
  let $store;
  let { sieveId } = $$props;
  let { sieveDataId1 } = $$props;
  let { sieveDataId2 } = $$props;
  let selectedDiffContentMode = C$2.DIFF_MODE_VISUAL;
  const dispatch = createEventDispatcher();
  const store2 = initStore();
  component_subscribe($$self, store2, (value) => $$invalidate(3, $store = value));
  const sieveStore = new Model$2.Sieve({ id: sieveId });
  let myResolve;
  let promise = new Promise((r) => {
    myResolve = r;
  });
  sieveStore.fetch().then((_2) => {
    if (sieveStore.get("content_type") !== C$2.TYPE_SITEMAP) {
      $$invalidate(0, selectedDiffContentMode = sieveStore.get("meta").diffContentMode);
    } else {
      $$invalidate(0, selectedDiffContentMode = null);
    }
    store2.updateStore({
      type: sieveStore.get("content_type"),
      uri: sieveStore.get("uri")
    });
    store2.fetchSieveData(sieveId, sieveDataId1, sieveDataId2).then((_3) => {
      myResolve();
    });
    dispatch("sieve", sieveStore);
  });
  let inlined = false;
  let withoutStyle = false;
  function onClose() {
    dispatch("close");
  }
  function isHTML() {
    return [C$2.TYPE_DOC, C$2.TYPE_HTML, C$2.TYPE_PDF_HTML].includes($store.type);
  }
  onDestroy(() => {
    destroyStore();
  });
  function explorediffheader_inlined_binding(value) {
    inlined = value;
    $$invalidate(1, inlined);
  }
  function explorediffheader_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(2, withoutStyle);
  }
  function explorehtmldiff_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(2, withoutStyle);
  }
  $$self.$$set = ($$props2) => {
    if ("sieveId" in $$props2)
      $$invalidate(8, sieveId = $$props2.sieveId);
    if ("sieveDataId1" in $$props2)
      $$invalidate(9, sieveDataId1 = $$props2.sieveDataId1);
    if ("sieveDataId2" in $$props2)
      $$invalidate(10, sieveDataId2 = $$props2.sieveDataId2);
  };
  return [
    selectedDiffContentMode,
    inlined,
    withoutStyle,
    $store,
    store2,
    promise,
    onClose,
    isHTML,
    sieveId,
    sieveDataId1,
    sieveDataId2,
    explorediffheader_inlined_binding,
    explorediffheader_withoutStyle_binding,
    explorehtmldiff_withoutStyle_binding
  ];
}
class ExploreDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3b, create_fragment$3f, safe_not_equal, {
      sieveId: 8,
      sieveDataId1: 9,
      sieveDataId2: 10
    });
  }
}
function create_default_slot$1a(ctx) {
  let a;
  let h3;
  let t0_value = (ctx[2] && ctx[3].name) + "";
  let t0;
  let a_href_value;
  let t1;
  let explorediff;
  let current;
  explorediff = new ExploreDiff({
    props: {
      sieveId: ctx[0],
      sieveDataId1: ctx[4],
      sieveDataId2: ctx[1]
    }
  });
  explorediff.$on("sieve", ctx[6]);
  return {
    c() {
      a = element("a");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      create_component(explorediff.$$.fragment);
      attr(h3, "class", "ph3 mt-3 mb-2");
      attr(a, "href", a_href_value = urlCfg.sievePage(ctx[2] && ctx[3].id));
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, h3);
      append(h3, t0);
      insert(target, t1, anchor);
      mount_component(explorediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 12) && t0_value !== (t0_value = (ctx2[2] && ctx2[3].name) + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 12 && a_href_value !== (a_href_value = urlCfg.sievePage(ctx2[2] && ctx2[3].id))) {
        attr(a, "href", a_href_value);
      }
      const explorediff_changes = {};
      if (dirty & 1)
        explorediff_changes.sieveId = ctx2[0];
      if (dirty & 2)
        explorediff_changes.sieveDataId2 = ctx2[1];
      explorediff.$set(explorediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (detaching)
        detach(t1);
      destroy_component(explorediff, detaching);
    }
  };
}
function create_topbar_slot$6(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Changes" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$3e(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$6],
        default: [create_default_slot$1a]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 271) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$3a($$self, $$props, $$invalidate) {
  let $querystring;
  let $sieveStore, $$unsubscribe_sieveStore = noop, $$subscribe_sieveStore = () => ($$unsubscribe_sieveStore(), $$unsubscribe_sieveStore = subscribe(sieveStore, ($$value) => $$invalidate(3, $sieveStore = $$value)), sieveStore);
  component_subscribe($$self, querystring, ($$value) => $$invalidate(7, $querystring = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieveStore());
  let { params: params2 = {} } = $$props;
  let { sieveId = params2.sieveId } = $$props;
  Api.setIdentityId(params2.team == 0 ? null : params2.team);
  let sieveDataId1 = params2.dataId, sieveDataId2 = null;
  if ($querystring) {
    const searchParams = new URLSearchParams($querystring);
    sieveDataId2 = searchParams.has("d2") && searchParams.get("d2");
  }
  let sieveStore;
  const sieve_handler = (e) => $$subscribe_sieveStore($$invalidate(2, sieveStore = e.detail));
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(5, params2 = $$props2.params);
    if ("sieveId" in $$props2)
      $$invalidate(0, sieveId = $$props2.sieveId);
  };
  return [
    sieveId,
    sieveDataId2,
    sieveStore,
    $sieveStore,
    sieveDataId1,
    params2,
    sieve_handler
  ];
}
class Explore_diff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3a, create_fragment$3e, safe_not_equal, { params: 5, sieveId: 0 });
  }
}
function create_if_block$1D(ctx) {
  let div8;
  let div0;
  let t1;
  let div7;
  let div6;
  let div1;
  let label0;
  let t3;
  let span;
  let t4_value = (ctx[0].get("err").code || "NA") + "";
  let t4;
  let t5;
  let div2;
  let label1;
  let t7;
  let pre;
  let t8_value = (ctx[0].get("err").msg || ctx[0].get("err").message || JSON.stringify(ctx[0].get("err"))) + "";
  let t8;
  let t9;
  let div5;
  let strong0;
  let t11;
  let show_if;
  let show_if_1;
  let show_if_2;
  let show_if_3;
  let show_if_4;
  let t12;
  let div4;
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if = null;
    if (dirty & 1)
      show_if_1 = null;
    if (dirty & 1)
      show_if_2 = null;
    if (dirty & 1)
      show_if_3 = null;
    if (dirty & 1)
      show_if_4 = null;
    if (show_if == null)
      show_if = !!(ctx2[0].get("err").code === "SELECTION_EMPTY");
    if (show_if)
      return create_if_block_1$15;
    if (show_if_1 == null)
      show_if_1 = !!(ctx2[0].get("err").code === "EPROXY");
    if (show_if_1)
      return create_if_block_2$M;
    if (show_if_2 == null)
      show_if_2 = !!(ctx2[0].get("err").code === "EMACRO");
    if (show_if_2)
      return create_if_block_3$A;
    if (show_if_3 == null)
      show_if_3 = !!(ctx2[0].get("err").code === "TIMEOUT" || ctx2[0].get("err").code === "ENOTFOUND" || ctx2[0].get("err").code === "EREQUEST" || ctx2[0].get("err").code === "ETIMEDOUT" || ctx2[0].get("err").code === "ECONNREFUSED");
    if (show_if_3)
      return create_if_block_4$p;
    if (show_if_4 == null)
      show_if_4 = !!(ctx2[0].get("err").code === "JAVASCRIPT");
    if (show_if_4)
      return create_if_block_5$g;
    return create_else_block$T;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div8 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3 class="card-title">Error Details</h3>`;
      t1 = space();
      div7 = element("div");
      div6 = element("div");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = "Code:";
      t3 = space();
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      div2 = element("div");
      label1 = element("label");
      label1.textContent = "Msg:";
      t7 = space();
      pre = element("pre");
      t8 = text(t8_value);
      t9 = space();
      div5 = element("div");
      strong0 = element("strong");
      strong0.textContent = "Recommended Actions";
      t11 = space();
      if_block.c();
      t12 = space();
      div4 = element("div");
      div4.innerHTML = `<strong>Need Help?</strong> 
            <div>Contact us at support@distill.io</div>`;
      attr(div0, "class", "card-header text-danger");
      attr(pre, "class", "card-footer");
      attr(div4, "class", "pt1");
      attr(div5, "class", "pt1");
      attr(div6, "data-id", "error");
      attr(div7, "class", "card-body overflow-scroll");
      attr(div8, "class", "card");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div0);
      append(div8, t1);
      append(div8, div7);
      append(div7, div6);
      append(div6, div1);
      append(div1, label0);
      append(div1, t3);
      append(div1, span);
      append(span, t4);
      append(div6, t5);
      append(div6, div2);
      append(div2, label1);
      append(div2, t7);
      append(div2, pre);
      append(pre, t8);
      append(div6, t9);
      append(div6, div5);
      append(div5, strong0);
      append(div5, t11);
      if_block.m(div5, null);
      append(div5, t12);
      append(div5, div4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t4_value !== (t4_value = (ctx2[0].get("err").code || "NA") + ""))
        set_data(t4, t4_value);
      if (dirty & 1 && t8_value !== (t8_value = (ctx2[0].get("err").msg || ctx2[0].get("err").message || JSON.stringify(ctx2[0].get("err"))) + ""))
        set_data(t8, t8_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div5, t12);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div8);
      if_block.d();
    }
  };
}
function create_else_block$T(ctx) {
  let show_if = ctx[0].get("err").status === 0;
  let t0;
  let div;
  let if_block = show_if && create_if_block_6$8();
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      div = element("div");
      div.textContent = "There is no information about this error.";
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = ctx2[0].get("err").status === 0;
      if (show_if) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_6$8();
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_5$g(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Ensure that JavaScript is working in the page.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$p(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Please ensure that the webpage is accessible.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$A(ctx) {
  let div;
  let t0_value = (prepareEMacroErrorMessage(ctx[0]) || "") + "";
  let t0;
  let t1;
  let a;
  let t3;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      a.textContent = "Macro: Record and Replay Automated Actions";
      t3 = text(".");
      attr(a, "href", "https://distill.io/docs/web-monitor/macro-to-record-replay-actions/");
      attr(div, "class", "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, a);
      append(div, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = (prepareEMacroErrorMessage(ctx2[0]) || "") + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$M(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `Please consider using a different proxy:

                <a href="https://distill.io/docs/web-monitor/monitor-webpage-using-proxy-servers/">Using proxy servers for checks</a>.`;
      attr(div, "class", "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$15(ctx) {
  let ul;
  return {
    c() {
      ul = element("ul");
      ul.innerHTML = `<li>Ensure that selected elements has text content.</li> 
              <li>If website needs login, make sure that you are logged in.</li>`;
      attr(ul, "class", "pl3");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(ul);
    }
  };
}
function create_if_block_6$8(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Ensure that internet connection is working.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$3d(ctx) {
  let show_if = ctx[0].get("err");
  let if_block_anchor;
  let if_block = show_if && create_if_block$1D(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        show_if = ctx2[0].get("err");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1D(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function prepareEMacroErrorMessage(workStore) {
  if (workStore.get("err").code !== "EMACRO") {
    return;
  }
  if (!workStore.get("err").step) {
    return;
  }
  const stepType = workStore.get("err").step;
  switch (stepType.type) {
    case "KEYPRESS": {
      return "KEYPRESS is not supported in this device type. Please use a supported device for this monitor and retry";
    }
  }
}
function instance$39($$self, $$props, $$invalidate) {
  let { workStore } = $$props;
  $$self.$$set = ($$props2) => {
    if ("workStore" in $$props2)
      $$invalidate(0, workStore = $$props2.workStore);
  };
  return [workStore];
}
class Error$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$39, create_fragment$3d, safe_not_equal, { workStore: 0 });
  }
}
function create_else_block$S(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-check green");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_if_block_2$L(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-2x fa-times-circle red");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_if_block_1$14(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${T("l_no_snapshot_found")}`;
      attr(p, "class", "pa2");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block$1C(ctx) {
  let loader;
  let current;
  loader = new Loader({ props: { class: "absolute z-1 ma0 mr2" } });
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3c(ctx) {
  let title_value;
  let t0;
  let div13;
  let div10;
  let div9;
  let div8;
  let div0;
  let t1;
  let div7;
  let div2;
  let div1;
  let h2;
  let span0;
  let t2_value = new Date(ctx[0].get("ts")).toDateString() + "";
  let t2;
  let t3;
  let span1;
  let t4_value = new Date(ctx[0].get("ts")).toLocaleTimeString() + "";
  let t4;
  let t5;
  let t6_value = T("l_snapshot") + "";
  let t6;
  let t7;
  let div6;
  let div5;
  let div3;
  let label0;
  let t10;
  let span2;
  let t11_value = ctx[0].get("duration") + "";
  let t11;
  let t12;
  let t13_value = ctx[0].get("duration") > 1 ? "seconds" : "second";
  let t13;
  let t14;
  let div4;
  let label1;
  let t17;
  let a;
  let span3;
  let t18_value = ctx[2].uri + "";
  let t18;
  let a_href_value;
  let t19;
  let div12;
  let div11;
  let current_block_type_index;
  let if_block1;
  let t20;
  let iframe;
  let iframe_title_value;
  let current;
  document.title = title_value = ctx[1].get("name") + " | Check Logs";
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].err)
      return create_if_block_2$L;
    return create_else_block$S;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  const if_block_creators = [create_if_block$1C, create_if_block_1$14];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2].fetchingSnapshot || ctx2[5])
      return 0;
    if (!ctx2[2]["snapshot_id"])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      t0 = space();
      div13 = element("div");
      div10 = element("div");
      div9 = element("div");
      div8 = element("div");
      div0 = element("div");
      if_block0.c();
      t1 = space();
      div7 = element("div");
      div2 = element("div");
      div1 = element("div");
      h2 = element("h2");
      span0 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      t5 = text("\n                | ");
      t6 = text(t6_value);
      t7 = space();
      div6 = element("div");
      div5 = element("div");
      div3 = element("div");
      label0 = element("label");
      label0.textContent = `${T("l_duration")}:`;
      t10 = space();
      span2 = element("span");
      t11 = text(t11_value);
      t12 = space();
      t13 = text(t13_value);
      t14 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = `${T("l_url")}:`;
      t17 = space();
      a = element("a");
      span3 = element("span");
      t18 = text(t18_value);
      t19 = space();
      div12 = element("div");
      div11 = element("div");
      if (if_block1)
        if_block1.c();
      t20 = space();
      iframe = element("iframe");
      attr(div0, "class", "mr1 mw2");
      attr(h2, "class", "card-title f3");
      attr(div2, "class", "flex");
      attr(div3, "data-id", "duration");
      attr(a, "href", a_href_value = ctx[2].uri);
      attr(a, "target", "_blank");
      attr(a, "class", "truncate");
      attr(div4, "data-id", "links");
      attr(div4, "class", "ml3");
      attr(div5, "class", "flex");
      attr(div6, "class", "f4 pt1");
      attr(div7, "class", "ml2");
      attr(div8, "class", "flex");
      set_style(div8, "align-items", "center");
      attr(div9, "class", "mt3");
      attr(div10, "class", "card-header overflow-hidden");
      attr(iframe, "frameborder", "none");
      attr(iframe, "class", "flex-grow-1");
      set_style(iframe, "height", "calc(100vh - " + ctx[4] + "px)");
      set_style(iframe, "width", "100%");
      attr(iframe, "title", iframe_title_value = "Iframe for " + ctx[1].get("name"));
      attr(div11, "data-id", "snapshot");
      attr(div11, "class", "flex flex-column relative");
      attr(div12, "class", "card-body pa0");
      attr(div13, "class", "card mb0 panel-default");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div13, anchor);
      append(div13, div10);
      append(div10, div9);
      append(div9, div8);
      append(div8, div0);
      if_block0.m(div0, null);
      append(div8, t1);
      append(div8, div7);
      append(div7, div2);
      append(div2, div1);
      append(div1, h2);
      append(h2, span0);
      append(span0, t2);
      append(h2, t3);
      append(h2, span1);
      append(span1, t4);
      append(h2, t5);
      append(h2, t6);
      append(div7, t7);
      append(div7, div6);
      append(div6, div5);
      append(div5, div3);
      append(div3, label0);
      append(div3, t10);
      append(div3, span2);
      append(span2, t11);
      append(span2, t12);
      append(span2, t13);
      append(div5, t14);
      append(div5, div4);
      append(div4, label1);
      append(div4, t17);
      append(div4, a);
      append(a, span3);
      append(span3, t18);
      append(div13, t19);
      append(div13, div12);
      append(div12, div11);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div11, null);
      }
      append(div11, t20);
      append(div11, iframe);
      ctx[7](iframe);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 2) && title_value !== (title_value = ctx2[1].get("name") + " | Check Logs")) {
        document.title = title_value;
      }
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = new Date(ctx2[0].get("ts")).toDateString() + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 1) && t4_value !== (t4_value = new Date(ctx2[0].get("ts")).toLocaleTimeString() + ""))
        set_data(t4, t4_value);
      if ((!current || dirty & 1) && t11_value !== (t11_value = ctx2[0].get("duration") + ""))
        set_data(t11, t11_value);
      if ((!current || dirty & 1) && t13_value !== (t13_value = ctx2[0].get("duration") > 1 ? "seconds" : "second"))
        set_data(t13, t13_value);
      if ((!current || dirty & 4) && t18_value !== (t18_value = ctx2[2].uri + ""))
        set_data(t18, t18_value);
      if (!current || dirty & 4 && a_href_value !== (a_href_value = ctx2[2].uri)) {
        attr(a, "href", a_href_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div11, t20);
        } else {
          if_block1 = null;
        }
      }
      if (!current || dirty & 16) {
        set_style(iframe, "height", "calc(100vh - " + ctx2[4] + "px)");
      }
      if (!current || dirty & 2 && iframe_title_value !== (iframe_title_value = "Iframe for " + ctx2[1].get("name"))) {
        attr(iframe, "title", iframe_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div13);
      if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[7](null);
    }
  };
}
function instance$38($$self, $$props, $$invalidate) {
  let $workStore, $$unsubscribe_workStore = noop, $$subscribe_workStore = () => ($$unsubscribe_workStore(), $$unsubscribe_workStore = subscribe(workStore, ($$value) => $$invalidate(2, $workStore = $$value)), workStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_workStore());
  let { workStore } = $$props;
  $$subscribe_workStore();
  let { sieveStore } = $$props;
  let workID = workStore.id;
  let iframeElement;
  let iframeTop = 0;
  let loadingSrcDoc = false;
  async function loadSrcDoc() {
    $$invalidate(5, loadingSrcDoc = true);
    $$invalidate(3, iframeElement.src = "about:blank", iframeElement);
    $$invalidate(3, iframeElement.srcdoc = workStore.get("snapshot").content, iframeElement);
    $$invalidate(4, iframeTop = iframeElement.getBoundingClientRect().y);
    await new Promise((res) => {
      setTimeout(res, 100);
    });
    const win = iframeElement.contentWindow;
    const doc = win.document;
    const el = doc.documentElement;
    async.map(
      el.querySelectorAll("link[rel=stylesheet]"),
      function(link, callback) {
        const img = doc.createElement("img");
        img.onerror = function() {
          callback();
        };
        img.src = link.href;
      },
      (err, res) => {
        $$invalidate(5, loadingSrcDoc = false);
      }
    );
  }
  async function fetchSieveSnapshot() {
    if (!iframeElement) {
      await new Promise((res) => {
        setTimeout(res, 100);
      });
    }
    if (workStore.get("snapshot")) {
      await loadSrcDoc();
      return;
    }
    if (!workStore.get("err") || !workStore.get("snapshot_id")) {
      $$invalidate(3, iframeElement.srcdoc = "", iframeElement);
      $$invalidate(4, iframeTop = iframeElement.getBoundingClientRect().y);
      console.warn(`invalid work, ${workStore.id}, used for getting the sieve snapshot`);
      return;
    }
    await workStore.fetchScreenshot(sieveStore.id);
    await loadSrcDoc();
  }
  onMount(async () => {
    await fetchSieveSnapshot();
  });
  function iframe_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframeElement = $$value;
      $$invalidate(3, iframeElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("workStore" in $$props2)
      $$subscribe_workStore($$invalidate(0, workStore = $$props2.workStore));
    if ("sieveStore" in $$props2)
      $$invalidate(1, sieveStore = $$props2.sieveStore);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(6, workID = $workStore.id);
    }
    if ($$self.$$.dirty & 64) {
      workID && fetchSieveSnapshot();
    }
  };
  return [
    workStore,
    sieveStore,
    $workStore,
    iframeElement,
    iframeTop,
    loadingSrcDoc,
    workID,
    iframe_binding
  ];
}
class Work$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$38, create_fragment$3c, safe_not_equal, { workStore: 0, sieveStore: 1 });
  }
}
function get_each_context$O(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  child_ctx[20] = i2;
  return child_ctx;
}
function create_catch_block$m(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$m(ctx) {
  let a;
  let h3;
  let t2;
  let div7;
  let div5;
  let div4;
  let div0;
  let show_if = ctx[7].get(ctx[0]);
  let t3;
  let div3;
  let div1;
  let t5;
  let div2;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t6;
  let div6;
  let work;
  let current;
  let if_block = show_if && create_if_block_1$13(ctx);
  let each_value = ctx[5].models;
  const get_key = (ctx2) => ctx2[18].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$O(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$O(key, child_ctx));
  }
  work = new Work$1({
    props: {
      workStore: ctx[7].get(ctx[0]),
      sieveStore: ctx[6]
    }
  });
  return {
    c() {
      a = element("a");
      h3 = element("h3");
      h3.textContent = `${ctx[6].get("name")} | Monitor`;
      t2 = space();
      div7 = element("div");
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t3 = space();
      div3 = element("div");
      div1 = element("div");
      div1.textContent = "Logs";
      t5 = space();
      div2 = element("div");
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t6 = space();
      div6 = element("div");
      create_component(work.$$.fragment);
      attr(h3, "class", "ph3");
      attr(a, "href", urlCfg.sievePage(ctx[6].id));
      set_style(div0, "height", "35%");
      attr(div0, "class", "overflow-auto");
      attr(div1, "class", "card-header");
      attr(ul, "class", "list-group");
      attr(div2, "class", "card-body pa0 pt1 overflow-scroll");
      set_style(div2, "height", "calc(100% - 40px)");
      attr(div3, "class", "card panel-default");
      set_style(div3, "height", "65%");
      attr(div4, "class", "flex flex-column-l mr2");
      set_style(div4, "height", "calc(100vh - " + ctx[3] + "px)");
      attr(div5, "class", "w-25");
      attr(div6, "class", "border-right-none w-75 h-100");
      attr(div7, "class", "flex pa2 w-[calc(100vw-var(--vbar-margin))]");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, h3);
      insert(target, t2, anchor);
      insert(target, div7, anchor);
      append(div7, div5);
      append(div5, div4);
      append(div4, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div4, t3);
      append(div4, div3);
      append(div3, div1);
      append(div3, t5);
      append(div3, div2);
      append(div2, ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      ctx[11](ul);
      ctx[12](div4);
      append(div7, t6);
      append(div7, div6);
      mount_component(work, div6, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = ctx2[7].get(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 35) {
        each_value = ctx2[5].models;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block$O, null, get_each_context$O);
      }
      if (!current || dirty & 8) {
        set_style(div4, "height", "calc(100vh - " + ctx2[3] + "px)");
      }
      const work_changes = {};
      if (dirty & 1)
        work_changes.workStore = ctx2[7].get(ctx2[0]);
      work.$set(work_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(work.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(work.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div7);
      if (if_block)
        if_block.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      ctx[11](null);
      ctx[12](null);
      destroy_component(work);
    }
  };
}
function create_if_block_1$13(ctx) {
  let error;
  let current;
  error = new Error$1({
    props: {
      workStore: ctx[7].get(ctx[0])
    }
  });
  return {
    c() {
      create_component(error.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const error_changes = {};
      if (dirty & 1)
        error_changes.workStore = ctx2[7].get(ctx2[0]);
      error.$set(error_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error, detaching);
    }
  };
}
function create_if_block$1B(ctx) {
  let span;
  let t_value = ctx[18].get("err").code + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[18].get("err").code + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$O(key_1, ctx) {
  let li;
  let a;
  let div;
  let span;
  let t0_value = formatTimeV2(ctx[18].get("ts"), false, true) + "";
  let t0;
  let t1;
  let br;
  let t2;
  let show_if = ctx[18].get("err");
  let a_href_value;
  let t3;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block$1B(ctx);
  function click_handler(...args) {
    return ctx[10](ctx[18], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      a = element("a");
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      br = element("br");
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      toggle_class(div, "text-danger", !!ctx[18].get("err"));
      toggle_class(div, "text-secondary", !ctx[18].get("err"));
      attr(a, "href", a_href_value = "#" + (ctx[1] + "?work=" + ctx[18].id));
      attr(li, "role", "presentation");
      attr(li, "class", "list-group-item");
      toggle_class(li, "list-group-item-primary", ctx[0] === ctx[18].id);
      toggle_class(li, "disabled", !ctx[18].get("err"));
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, div);
      append(div, span);
      append(span, t0);
      append(div, t1);
      append(div, br);
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      append(li, t3);
      if (!mounted) {
        dispose = listen(a, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && t0_value !== (t0_value = formatTimeV2(ctx[18].get("ts"), false, true) + ""))
        set_data(t0, t0_value);
      if (dirty & 32)
        show_if = ctx[18].get("err");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$1B(ctx);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32) {
        toggle_class(div, "text-danger", !!ctx[18].get("err"));
      }
      if (dirty & 32) {
        toggle_class(div, "text-secondary", !ctx[18].get("err"));
      }
      if (dirty & 34 && a_href_value !== (a_href_value = "#" + (ctx[1] + "?work=" + ctx[18].id))) {
        attr(a, "href", a_href_value);
      }
      if (dirty & 33) {
        toggle_class(li, "list-group-item-primary", ctx[0] === ctx[18].id);
      }
      if (dirty & 32) {
        toggle_class(li, "disabled", !ctx[18].get("err"));
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_pending_block$m(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3b(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$m,
    then: create_then_block$m,
    catch: create_catch_block$m,
    value: 17,
    blocks: [, , ,]
  };
  handle_promise(ctx[8], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$37($$self, $$props, $$invalidate) {
  let $worksStore;
  let { sieveID } = $$props;
  let { workID } = $$props;
  let { basePath } = $$props;
  let el;
  let elTop = 0;
  let workListElem;
  const sieveStore = new Model$2.Sieve({ "id": sieveID });
  let worksStore = new Model$2.Works(null, { sieve: sieveStore });
  component_subscribe($$self, worksStore, (value) => $$invalidate(5, $worksStore = value));
  let worksFetched;
  let worksFetchPromise = new Promise((res, rej) => {
    worksFetched = res;
  });
  async function fetchWorks() {
    await sieveStore.fetch();
    await worksStore.fetch({ reset: true });
    if (!workID) {
      $$invalidate(0, workID = worksStore.at(0).id);
    }
    worksFetched(true);
  }
  fetchWorks();
  onMount(async () => {
    await worksFetchPromise;
    const selectedItemElem = workListElem.querySelector("li.active");
    if (selectedItemElem) {
      selectedItemElem.scrollIntoView({ block: "nearest", inline: "nearest" });
    }
    $$invalidate(3, elTop = el.getBoundingClientRect().top);
  });
  const click_handler = (work, e) => {
    $$invalidate(0, workID = work.id);
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      workListElem = $$value;
      $$invalidate(4, workListElem);
    });
  }
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("sieveID" in $$props2)
      $$invalidate(9, sieveID = $$props2.sieveID);
    if ("workID" in $$props2)
      $$invalidate(0, workID = $$props2.workID);
    if ("basePath" in $$props2)
      $$invalidate(1, basePath = $$props2.basePath);
  };
  return [
    workID,
    basePath,
    el,
    elTop,
    workListElem,
    $worksStore,
    sieveStore,
    worksStore,
    worksFetchPromise,
    sieveID,
    click_handler,
    ul_binding,
    div4_binding
  ];
}
class List$8 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$37, create_fragment$3b, safe_not_equal, { sieveID: 9, workID: 0, basePath: 1 });
  }
}
function create_else_block$R(ctx) {
  let error404;
  let current;
  error404 = new Error404({ props: { useLayout: false } });
  return {
    c() {
      create_component(error404.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error404, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(error404.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error404.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error404, detaching);
    }
  };
}
function create_if_block$1A(ctx) {
  let list;
  let current;
  list = new List$8({
    props: {
      sieveID: ctx[0].sieveID,
      workID: ctx[1],
      basePath: ctx[2]
    }
  });
  return {
    c() {
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & 1)
        list_changes.sieveID = ctx2[0].sieveID;
      if (dirty & 2)
        list_changes.workID = ctx2[1];
      if (dirty & 4)
        list_changes.basePath = ctx2[2];
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function create_default_slot$19(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1A, create_else_block$R];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    return 0;
  }
  current_block_type_index = select_block_type();
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_topbar_slot$5(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Check Logs" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$3a(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$5],
        default: [create_default_slot$19]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 23) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$36($$self, $$props, $$invalidate) {
  let $querystring;
  let $location;
  component_subscribe($$self, querystring, ($$value) => $$invalidate(3, $querystring = $$value));
  component_subscribe($$self, location$1, ($$value) => $$invalidate(2, $location = $$value));
  let { params: params2 = {} } = $$props;
  Api.setIdentityId(params2.team == 0 ? null : params2.team);
  let workID;
  if ($querystring) {
    const searchParams = new URLSearchParams($querystring);
    workID = searchParams.has("work") && searchParams.get("work");
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, workID, $location];
}
class Works$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$36, create_fragment$3a, safe_not_equal, { params: 0 });
  }
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  foo: {}
};
var $Object = Object;
var hasProto$1 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        args.concat(slice.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs.push("$" + i2);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var bind$1 = functionBind;
var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$1 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var hasProto2 = hasProto$1();
var getProto = Object.getPrototypeOf || (hasProto2 ? function(x) {
  return x.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$1 = src;
var $concat$1 = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var $exec = bind2.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string, rePropName, function(match, number, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i2 + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
(function(module) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    var func2 = $reflectApply(bind3, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func2, "length");
      if (desc.configurable) {
        $defineProperty(
          func2,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func2;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$1);
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBind$1.exports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
  return O.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$4(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp$1(obj)) {
    var name = nameOf(obj);
    var keys = arrObjKeys(obj, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i2 = 0; i2 < attrs.length; i2++) {
      s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
    }
    s += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s += "...";
    }
    s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s;
  }
  if (isArray$4(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (!isDate(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return $replace.call(String(s), /"/g, "&quot;");
}
function isArray$4(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i2 = 0, l = xs.length; i2 < l; i2++) {
    if (xs[i2] === x) {
      return i2;
    }
  }
  return -1;
}
function isMap(x) {
  if (!mapSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }
    return x instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }
    return x instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, "single", opts);
}
function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type) {
  return type + " { ? }";
}
function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (indexOf(xs[i2], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$4(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i2 = 0; i2 < obj.length; i2++) {
      xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap["$" + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = GetIntrinsic2("%TypeError%");
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node2 = listGetNode(objects, key);
  return node2 && node2.value;
};
var listSet = function(objects, key, value) {
  var node2 = listGetNode(objects, key);
  if (node2) {
    node2.value = value;
  } else {
    objects.next = {
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$3 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$3(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i2 = 0; i2 < source.length; ++i2) {
    if (typeof source[i2] !== "undefined") {
      obj[i2] = source[i2];
    }
  }
  return obj;
};
var merge$2 = function merge(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$3(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$3(target) && !isArray$3(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$3(target) && isArray$3(source)) {
    source.forEach(function(item, i2) {
      if (has$2.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i2 = 0; i2 < string.length; ++i2) {
    var c = string.charCodeAt(i2);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats$2.RFC1738 && (c === 40 || c === 41)) {
      out += string.charAt(i2);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i2 += 1;
    c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i2) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue.length; ++i2) {
    var item = queue[i2];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);
    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$3(val)) {
    var mapped = [];
    for (var i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn(val[i2]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge: merge$2
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat2(prefix) {
    return prefix;
  }
};
var isArray$2 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var sentinel = {};
var stringify$1 = function stringify(object2, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object2;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$2(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format2) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format2);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format2))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = utils$1.maybeMap(obj, encoder);
    }
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$2(filter)) {
    objKeys = filter;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }
  var adjustedPrefix = commaRoundTrip && isArray$2(obj) && obj.length === 1 ? prefix + "[]" : prefix;
  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
    sideChannel2.set(object2, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      strictNullHandling,
      skipNulls,
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray$2(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate2,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$1.formatters[format2];
  var filter = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$2(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object2, opts) {
  var obj = object2;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray$2(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys, stringify$1(
      obj[key],
      key,
      generateArrayPrefix,
      commaRoundTrip,
      options.strictNullHandling,
      options.skipNulls,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray$1 = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = { __proto__: null };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit2 = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit2);
  var skipIndex = -1;
  var i2;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (parts[i2].indexOf("utf8=") === 0) {
        if (parts[i2] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i2] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts.length;
      }
    }
  }
  for (i2 = 0; i2 < parts.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils.maybeMap(
        parseArrayValue(part.slice(pos + 1), options),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$1(val) ? [val] : val;
    }
    if (has.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root = chain[i2];
    if (root === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
      var index2 = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent2 = segment ? key.slice(0, segment.index) : key;
  var keys = [];
  if (parent2) {
    if (!options.plainObjects && has.call(Object.prototype, parent2)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(parent2);
  }
  var i2 = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
    i2 += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(segment[1]);
  }
  if (segment) {
    keys.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$2 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys.length; ++i2) {
    var key = keys[i2];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify2 = stringify_1;
var parse$1 = parse$2;
var formats = formats$3;
var lib = {
  formats,
  parse: parse$1,
  stringify: stringify2
};
const domo$3 = window.domo;
if (!domo$3) {
  throw new Error("ADD domo");
}
const async$4 = window.async;
if (!async$4) {
  throw new Error("ADD async");
}
const FeedEntry$1 = View.Base.extend({
  name: "FeedEntry",
  className: "mb3 bb b--black-20",
  render: function() {
    const attrs = this.model.attributes;
    let date = attrs.pubdate || attrs.date;
    let preview;
    this.$el.append(
      H4({ "class": "mb2" }, A({
        "class": "black-80",
        href: attrs.link
      }, attrs.title)),
      DIV({ "class": "mb2 black-40" }, moment(date).format("LLL")),
      preview = DIV({ "class": "summary mb2" })
    );
    $(preview).html(attrs.description || attrs.summary || "");
    return this;
  }
});
const FeedEntryList = View.Collection.extend({
  name: "FeedEntryList",
  addOne: function(model) {
    const view = new FeedEntry$1({
      parent: this,
      model
    }).render();
    this.$el.append(view.el);
    return view;
  }
});
const Feed$2 = View.Base.extend({
  name: "Feed",
  render: function() {
    const attrs = this.model.attributes;
    this.$el.append(
      H3(A({ href: attrs.link }, attrs.title)),
      DIV({ "class": "pb2 mb2 bb b--black-20" }, attrs.description || attrs.summary || ""),
      new FeedEntryList({
        parent: this,
        collection: this.model.get("entries")
      }).render().el
    );
    return this;
  }
});
var ViewFeed = {
  Feed: Feed$2,
  FeedEntry: FeedEntry$1,
  FeedEntryList
};
const FeedEntry = base.Model.extend();
const FeedEntryCollection = base.Collection.extend({
  model: FeedEntry
});
const Feed$1 = base.Model.extend({
  parse: function(response) {
    response.entries = new FeedEntryCollection(response.entries);
    return response;
  }
});
var ModelFeed = {
  Feed: Feed$1,
  FeedEntry,
  FeedEntryCollection
};
function create_catch_block$l(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$l(ctx) {
  let div;
  let current;
  let if_block = ctx[3].diff && create_if_block$1z(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "flex-grow overflow-y-auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[3].diff) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1z(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block$1z(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$12, create_if_block_2$K, create_if_block_3$z, create_if_block_4$o];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (show_if == null)
      show_if = !!ctx2[7]();
    if (show_if)
      return 0;
    if (ctx2[3].type === C$2.TYPE_JSON)
      return 1;
    if (ctx2[3].type === C$2.TYPE_XML)
      return 2;
    if (ctx2[3].type === C$2.TYPE_SITEMAP)
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_4$o(ctx) {
  let exploresitemapdiff;
  let current;
  exploresitemapdiff = new ExploreSitemapDiff({ props: { inlined: ctx[1] } });
  return {
    c() {
      create_component(exploresitemapdiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exploresitemapdiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exploresitemapdiff_changes = {};
      if (dirty & 2)
        exploresitemapdiff_changes.inlined = ctx2[1];
      exploresitemapdiff.$set(exploresitemapdiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(exploresitemapdiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exploresitemapdiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exploresitemapdiff, detaching);
    }
  };
}
function create_if_block_3$z(ctx) {
  let explorexmldiff;
  let current;
  explorexmldiff = new ExploreXmlDiff({ props: { inlined: ctx[1] } });
  return {
    c() {
      create_component(explorexmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorexmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorexmldiff_changes = {};
      if (dirty & 2)
        explorexmldiff_changes.inlined = ctx2[1];
      explorexmldiff.$set(explorexmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorexmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorexmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorexmldiff, detaching);
    }
  };
}
function create_if_block_2$K(ctx) {
  let explorejsondiff;
  let current;
  explorejsondiff = new ExploreJSONDiff({ props: { inlined: ctx[1] } });
  return {
    c() {
      create_component(explorejsondiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorejsondiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorejsondiff_changes = {};
      if (dirty & 2)
        explorejsondiff_changes.inlined = ctx2[1];
      explorejsondiff.$set(explorejsondiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorejsondiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorejsondiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorejsondiff, detaching);
    }
  };
}
function create_if_block_1$12(ctx) {
  let explorehtmldiff;
  let updating_withoutStyle;
  let current;
  function explorehtmldiff_withoutStyle_binding(value) {
    ctx[11](value);
  }
  let explorehtmldiff_props = { inlined: ctx[1] };
  if (ctx[2] !== void 0) {
    explorehtmldiff_props.withoutStyle = ctx[2];
  }
  explorehtmldiff = new ExploreHTMLDiff({ props: explorehtmldiff_props });
  binding_callbacks.push(() => bind$2(explorehtmldiff, "withoutStyle", explorehtmldiff_withoutStyle_binding));
  return {
    c() {
      create_component(explorehtmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorehtmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorehtmldiff_changes = {};
      if (dirty & 2)
        explorehtmldiff_changes.inlined = ctx2[1];
      if (!updating_withoutStyle && dirty & 4) {
        updating_withoutStyle = true;
        explorehtmldiff_changes.withoutStyle = ctx2[2];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      explorehtmldiff.$set(explorehtmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorehtmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorehtmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorehtmldiff, detaching);
    }
  };
}
function create_pending_block$l(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_content_slot$4(ctx) {
  let div;
  let explorediffheader;
  let updating_inlined;
  let updating_withoutStyle;
  let t;
  let current;
  function explorediffheader_inlined_binding(value) {
    ctx[9](value);
  }
  function explorediffheader_withoutStyle_binding(value) {
    ctx[10](value);
  }
  let explorediffheader_props = {
    class: "mb-4",
    promise: ctx[5],
    showStyleMode: ctx[3].type === C$2.TYPE_HTML,
    selectedDiffContentMode: ctx[0],
    showCloseButton: true
  };
  if (ctx[1] !== void 0) {
    explorediffheader_props.inlined = ctx[1];
  }
  if (ctx[2] !== void 0) {
    explorediffheader_props.withoutStyle = ctx[2];
  }
  explorediffheader = new ExploreDiffHeader({ props: explorediffheader_props });
  binding_callbacks.push(() => bind$2(explorediffheader, "inlined", explorediffheader_inlined_binding));
  binding_callbacks.push(() => bind$2(explorediffheader, "withoutStyle", explorediffheader_withoutStyle_binding));
  explorediffheader.$on("close", ctx[6]);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$l,
    then: create_then_block$l,
    catch: create_catch_block$l,
    value: 13,
    blocks: [, , ,]
  };
  handle_promise(ctx[5], info);
  return {
    c() {
      div = element("div");
      create_component(explorediffheader.$$.fragment);
      t = space();
      info.block.c();
      attr(div, "class", "xmodal card panel-default flex flex-column h-screen");
      attr(div, "slot", "content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(explorediffheader, div, null);
      append(div, t);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const explorediffheader_changes = {};
      if (dirty & 8)
        explorediffheader_changes.showStyleMode = ctx[3].type === C$2.TYPE_HTML;
      if (dirty & 1)
        explorediffheader_changes.selectedDiffContentMode = ctx[0];
      if (!updating_inlined && dirty & 2) {
        updating_inlined = true;
        explorediffheader_changes.inlined = ctx[1];
        add_flush_callback(() => updating_inlined = false);
      }
      if (!updating_withoutStyle && dirty & 4) {
        updating_withoutStyle = true;
        explorediffheader_changes.withoutStyle = ctx[2];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      explorediffheader.$set(explorediffheader_changes);
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorediffheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(explorediffheader.$$.fragment, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(explorediffheader);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$39(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      $$slots: { content: [create_content_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 16399) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$35($$self, $$props, $$invalidate) {
  let $store;
  let { model } = $$props;
  let selectedDiffContentMode = null;
  if (model.get("data_type") !== C$2.TYPE_SITEMAP) {
    selectedDiffContentMode = model.parent.get("meta").diffContentMode;
  }
  const dispatch = createEventDispatcher();
  const store2 = initStore();
  component_subscribe($$self, store2, (value) => $$invalidate(3, $store = value));
  const promise = store2.fetchSieveData(model.parent.id, model.id);
  store2.updateStore({
    type: model.get("data_type"),
    uri: model.parent.get("uri")
  });
  let inlined = false;
  let withoutStyle = false;
  function onClose() {
    dispatch("close");
  }
  function isHTML() {
    return [C$2.TYPE_DOC, C$2.TYPE_HTML, C$2.TYPE_PDF_HTML].includes($store.type);
  }
  onDestroy(() => {
    destroyStore();
  });
  function explorediffheader_inlined_binding(value) {
    inlined = value;
    $$invalidate(1, inlined);
  }
  function explorediffheader_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(2, withoutStyle);
  }
  function explorehtmldiff_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(2, withoutStyle);
  }
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(8, model = $$props2.model);
  };
  return [
    selectedDiffContentMode,
    inlined,
    withoutStyle,
    $store,
    store2,
    promise,
    onClose,
    isHTML,
    model,
    explorediffheader_inlined_binding,
    explorediffheader_withoutStyle_binding,
    explorehtmldiff_withoutStyle_binding
  ];
}
class ExploreDiffModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$35, create_fragment$39, safe_not_equal, { model: 8 });
  }
}
const Backbone$5 = window.Backbone;
const feeddiff = window.feeddiff;
if (!feeddiff) {
  throw new Error("ADD feeddiff");
}
const PREFS_DEFAULT = {
  snipped: false,
  removed: false
};
var DiffableView = View.Base.extend({
  initialize: function(options) {
    DiffableView.__super__.initialize.call(this, options);
    this.oldModel = options.oldModel;
  },
  getDiffCount: function() {
    return [0, 0];
  },
  getDiffCount: function() {
    return [0, 0];
  },
  setState: function(state) {
    this.state = state;
    this.show(state);
  },
  show: function(state) {
    if (!state.diff) {
      return this.render();
    }
    const model = this.model;
    Msg.start("diff", { info: "l_loading" });
    try {
      const dmp = new diff_match_patch();
      const text_new = model.get("data");
      const text_old = (this.oldModel || model).get("data");
      const diffs = dmp.diff_main(text_old, text_new);
      dmp.diff_cleanupSemantic(diffs);
      this.$el.empty().append(dmp.diff_prettyHtml(diffs));
    } catch (e) {
      this.$el.empty().append("Error showing diff: ", e.message).append(e.stack);
    }
    Msg.stop("diff");
  },
  showDiffModal: function() {
    throw new Error("Not implemented");
  }
});
const SieveFeedView = DiffableView.extend({
  name: "SieveFeedView",
  tagName: "iframe",
  attributes: {
    frameborder: 0,
    style: "width:100%;height:80px"
  },
  onFrameLoad: function() {
    this.el.style.height = this.el.contentDocument.documentElement.scrollHeight + "px";
    this.frame_loaded = true;
    this.trigger("frame_loaded");
  },
  getDiffCount: function() {
    return [this.newFeedCount, this.updatedFeedCount];
  },
  postInit: function() {
    this.el.onload = this.onFrameLoad;
  },
  show: function(state) {
    if (!this.frame_loaded) {
      this.once("frame_loaded", () => this.show(state));
      return;
    }
    const feedNew = JSON.parse(this.model.get("data"));
    const feedOld = this.oldModel && JSON.parse(this.oldModel.get("data"));
    const feedDict = {};
    new DOMParser();
    const style = document.createElement("style");
    this.el.contentDocument;
    let css;
    feedDict["newHashedFeed"] = feedNew;
    feedDict["oldHashedFeed"] = feedOld;
    css = ".inserted{background-color:#b7fdcb;}";
    css += ".removed{background-color:#ff9494;}";
    css += "img{margin-top:2px;margin-bottom:5px;}";
    css += state.removed ? ".removed{display:inline}" : ".removed{display:none}";
    css += "body{width:700px;margin:0 auto;padding:0 10px;}";
    css += ".summary{padding-top:5px;}";
    style.type = "text/css";
    $(style).attr("class", "xdistill").text(css);
    feeddiff.getUpdatedEntries(Diff.diffHtml, feedDict, this.model.id, (err, result) => {
      if (err) {
        console.error("Error in update feed: ", err);
        Msg.error("Error finding changes in feed");
        return;
      }
      if (result["changes"].length == 0) {
        result.changes = feedDict.newHashedFeed.entries;
      } else {
        result.changes = result["newEntries"].concat(result["updatedEntries"]);
      }
      this.newFeedCount = result["newEntries"].length;
      this.updatedFeedCount = result["updatedEntries"].length;
      const view = new ViewFeed.FeedEntryList({
        model: new ModelFeed.FeedEntryCollection(result.changes)
      }).render();
      view.$el.append(style);
      this.once("frame_loaded", () => this.bubbleEvent("sieve:data:loaded"));
      this.el.setAttribute("srcdoc", view.el.outerHTML);
    });
  }
});
var SieveXMLView = DiffableView.extend({
  name: "SieveXMLView",
  postInit: function(options) {
    SieveXMLView.__super__.postInit.call(this, options);
    this.show({ diff: true });
    _.defer(() => this.bubbleEvent("sieve:data:loaded"));
  }
});
var SieveJSONView = DiffableView.extend({
  name: "SieveJSONView",
  getDiffCount() {
    return [this.additions, this.deletions];
  },
  show(state) {
    if (this.view) {
      this.view.full = !state.snipped;
      this.view.pruneDeletions = !state.removed;
    } else {
      let newJson = JSON.parse(this.model.get("data"));
      let oldJson = this.oldModel && JSON.parse(this.oldModel.get("data"));
      this.view = new DiffJsonView({
        target: this.el,
        props: {
          oldJson,
          newJson,
          full: !state.snipped,
          pruneDeletions: !state.removed,
          showDirty: !state.snipped,
          class: "ml-20 pr-10 my-10 w-auto max-h-[40vh] overflow-scroll"
        }
      });
      (async () => {
        await this.view.jsonDiffPromise;
        this.additions = this.view.additions;
        this.deletions = this.view.deletions;
        _.defer(() => this.bubbleEvent("sieve:data:loaded"));
      })();
    }
  },
  showDiffModal: function() {
    this.diffModal = new ExploreDiffModal({
      target: document.querySelector("body"),
      props: {
        model: this.model
      }
    });
    this.diffModal.$on("close", () => {
      this.diffModal.$destroy();
    });
  },
  remove() {
    SieveJSONView.__super__.remove.call(this);
    if (this.diffModal) {
      this.diffModal.$destroy();
    }
  }
});
const SieveHTMLView = DiffableView.extend({
  name: "SieveHTMLView",
  attributes: {
    src: window.IE ? `javascript:document.write('<script>document.open();document.domain="` + document.domain + `";document.close();<\/script>')` : "about:blank",
    frameborder: 0,
    style: "width:100%;height:40px"
  },
  tagName: "iframe",
  getDiffCount: function() {
    return [$(this.doc).find(".inserted").length, $(this.doc).find(".removed").length];
  },
  postInit: function() {
    this.showingDiff = false;
    this.el.onload = this.onFrameLoad;
    this.sieve = this.model.parent;
    this.model.get("text");
    this.el.style.height = "40px";
  },
  onFrameLoad: function() {
    this.frameReady = true;
    this.trigger("frame_ready");
    $(this.el.contentDocument).on("click", function(e) {
      const href2 = e.target.href || "";
      if (href2.slice(0, 11) == "javascript:") {
        e.preventDefault();
      }
    });
  },
  onFrameReady: function(callback) {
    try {
      this.frameReady ? callback() : this.once("frame_ready", callback);
    } catch (e) {
      console.error("Error calling frame ready callback", e);
    }
  },
  renderHTML: function(html2, state) {
    this.model.id;
    let nSyncs = 0;
    const host = this.el;
    const win = host.contentWindow;
    const doc = win.document;
    const el = doc.documentElement;
    const uri = this.sieve.get("uri");
    updateFrameContent(doc, uri, html2);
    async.map($(el).find("link[rel=stylesheet]").toArray(), function(link, callback) {
      const img = doc.createElement("img");
      img.onerror = function() {
        callback();
      };
      img.src = link.href;
    }, (err, res) => {
      if (this.syncIntervalId)
        clearInterval(this.syncIntervalId);
      this.syncIntervalId = setInterval(() => {
        try {
          const win2 = host.contentWindow;
          if (!win2 || !win2.document) {
            clearInterval(this.syncIntervalId);
            return;
          }
          const iframeRoot = win2.document.body || el;
          const height = Math.min(1e4, Math.max(el.scrollHeight, iframeRoot.scrollHeight));
          if (height > win2.innerHeight) {
            host.style.height = height + "px";
          }
          nSyncs += 1;
          if (nSyncs > 10)
            clearInterval(this.syncIntervalId);
        } catch (e) {
          clearInterval(this.syncIntervalId);
          throw e;
        }
      }, 100);
    });
    setTimeout(() => {
      this.$("span").css({ left: 0, position: "relative" });
      $(el).find("a[href]").attr("target", "_blank").attr("rel", "noopener");
      this.bubbleEvent("sieve:data:loaded");
    }, 200);
  },
  show: async function(state) {
    this.state = state;
    if (this.shown) {
      return this.doc && this.showDoc(state);
    }
    this.shown = true;
    Msg.start("diff", { info: "l_loading" });
    const newHtml = this.model.get("data");
    const oldHtml = this.oldModel.get("data");
    const parser = new DOMParser();
    let showHTML = (data) => {
      this.markedHTML = data;
      this.doc = parser.parseFromString(data, "text/html");
      if (this.doc.querySelectorAll(".inserted,.removed").length == 0) {
        this.markedHTML = newHtml;
        this.doc = parser.parseFromString(newHtml, "text/html");
      }
      this.showDoc(this.state);
      Msg.stop("diff");
    };
    if (newHtml == oldHtml) {
      return showHTML(newHtml);
    }
    try {
      let { diff: diff2 } = await Diff.diffHtml(oldHtml, newHtml, this.model.id);
      showHTML(diff2);
    } catch (e) {
      console.error("Error ", e);
      showHTML(newHtml);
    }
  },
  showDoc: function(state) {
    const doc = this.doc;
    const style = this.styleSheet || doc.createElement("style");
    let css = "";
    let html2;
    css = ".inserted{background-color:#b7fdcb;}";
    css += ".removed{background-color:#ff9494;}";
    css += "span.inserted, span.removed{padding: 1px 4px;}";
    css += "a.removed, a .removed{color: #008}";
    css += "img.inserted{border: solid 2px green; background-color: transparent; padding: 2px;}";
    css += "img.removed{border: solid 2px red; background-color: transparent; padding: 2px;}";
    css += "[hidden]{display:block;}";
    css += state.removed ? ".removed{display:inline}" : ".removed{display:none}";
    if (state.snipped) {
      css += ".nonDiffHide {display:none}";
      this.srcStylesheet = doc.querySelectorAll("link[rel=stylesheet], style:not(.xdistill)");
      $(this.srcStylesheet).remove();
      this.styledElements2 = $(doc).find("[style]").each(function() {
        this.dataset.oldStyle2 = this.getAttribute("style");
        this.removeAttribute("style");
      });
      this.snippedHeight && this.$el.height(this.snippedHeight);
    } else {
      this.snippedHeight = this.snippedHeight || this.$el.height();
      $(doc).find("head").append(this.srcStylesheet);
      this.styledElements2 && this.styledElements2.each(function() {
        this.setAttribute("style", this.dataset.oldStyle2);
      });
    }
    if (!$(doc).find('link[rel="stylesheet"], style:not(.xdistill)').length) {
      css += "body {padding: 10px;}";
      css += "td {padding: 10px}";
      css += "body {font-size: 0.94em}";
    }
    style.type = "text/css";
    $(style).attr("class", "xdistill").text(css);
    doc.body.appendChild(style);
    this.styleSheet = style;
    html2 = doc.documentElement.outerHTML;
    this.onFrameReady(() => this.renderHTML(html2, state));
  },
  showDiffModal: function() {
    this.diffModal = new ExploreDiffModal({
      target: document.querySelector("body"),
      props: {
        model: this.model
      }
    });
    this.diffModal.$on("close", () => {
      this.diffModal.$destroy();
    });
  },
  remove: function() {
    SieveHTMLView.__super__.remove.call(this);
    if (this.diffModal) {
      this.diffModal.$destroy();
    }
  }
});
const DiffPrefMenu = View.ContextMenu.extend({
  name: "DiffPrefMenu",
  events: {
    "change input": "event_change"
  },
  event_change: function(e) {
    e.stopPropagation();
    this.save();
  },
  getPrefs: function() {
    const prefs = {};
    this.$(":checkbox").each(function(_2, el) {
      prefs[el.name] = el.checked ? 1 : 0;
    });
    return prefs;
  },
  load: async function() {
    try {
      let res = await Api.api("/users/prefs/ui_diff", "GET");
      this.showPrefs(res);
    } catch (err) {
      console.error("Failed to get prefs", err);
      this.showApiErr();
    }
    this.show();
  },
  renderMenu: function() {
    this.load();
    this.$el.empty().append(
      LI({ "class": "xview" }, DIV(T("l_loading"), "..."))
    );
  },
  save: async function() {
    const prefs = this.getPrefs();
    try {
      await Api.api("/users/prefs/ui_diff", "PUT", prefs);
      USER.prefs.ui_diff = prefs;
      if (Supports.agents.local) {
        await Service.SyncMan.get(Service.store.UserStore);
      }
    } catch (err) {
      Msg.error("e_req");
    }
  },
  showApiErr: function(err) {
    this.$el.empty().append(
      LI(
        { "class": "xview error" },
        DIV(
          "Couldn't get prefs. ",
          A({ href: "/ui/settings.html#general" }, "Sign in to account.")
        )
      )
    );
  },
  showPrefs: function(prefs) {
    const tid = Date.now() * Math.random() | 0;
    _.defaults(prefs, PREFS_DEFAULT);
    this.$el.empty().append(
      LI(
        { "class": "xview" },
        DIV({ style: "font-size: 1.1em; " }, T("Defaults")),
        DIV(
          INPUT({
            id: "removed" + tid,
            name: "removed",
            type: "checkbox",
            style: "position: relative; top: 2px;"
          }),
          LABEL({
            "for": "removed" + tid,
            "style": "margin:0 4px;padding:0;font-size:.9em; user-select: none;"
          }, T("Deleted"))
        ),
        DIV(
          INPUT({
            id: "snipped" + tid,
            name: "snipped",
            type: "checkbox",
            style: "position: relative; top: 2px;"
          }),
          LABEL({
            "for": "snipped" + tid,
            "style": "margin:0 4px;padding:0;font-size:.9em; user-select: none;"
          }, T("Snipped"))
        )
      )
    );
    this.$(":checkbox").each(function(_2, el) {
      const checked = prefs[el.name];
      if (checked) {
        el.checked = 1;
      }
    });
  }
});
let diffMenu;
const BaseDiffBar = View.Base.extend({
  event_settings: function(e) {
    if (diffMenu && diffMenu.el.parentNode) {
      diffMenu.remove();
      diffMenu = null;
    } else {
      (diffMenu = new DiffPrefMenu({
        parent: this
      })).toggle(this.name, e.currentTarget);
    }
  }
});
const FeedBar = BaseDiffBar.extend({
  name: "FeedBar",
  events: {
    "click .xsettings": "event_settings",
    "click .xremoved": "event_show_removed"
  },
  event_show_removed: function(e) {
    this.state.removed = e.target.checked;
    this.updateState();
  },
  postInit: function(options) {
    this.state = _.extend({}, PREFS_DEFAULT, USER.prefs.ui_diff);
    this.view = options.view;
    this.view.setState(this.state);
  },
  render: function() {
    const tid = Date.now() * Math.random() | 0;
    this.$el.css({
      position: "absolute",
      right: 1,
      borderBottom: "solid 1px #ddd",
      backgroundColor: "#f3f3f3",
      backgroundColor: "#f0f0f0",
      marginTop: "-4px",
      padding: 0
    }).append(
      DIV(
        { "class": "inline-block" },
        DIV(
          { "class": "btn", "style": "padding:0 6px;", "title": "Shows the number of new and updated feeds" },
          SPAN({ style: "font-weight: bold;" }, this.elNewFeed = SPAN(0), " new, "),
          " ",
          SPAN(
            { style: "font-weight: bold;", title: "Shows the number of new and updated feeds" },
            this.elChangedFeed = SPAN(0),
            " updated. "
          )
        ),
        INPUT({ "class": "xremoved", "type": "checkbox", "id": "show-del" + tid }),
        LABEL(
          {
            "for": "show-del" + tid,
            "style": "margin:0 4px;font-size:.9em; user-select: none;",
            "title": "Shows deleted content in changed feed entry"
          },
          "Deleted"
        ),
        BUTTON({
          "class": "btn btn-default btn-sm xsettings",
          "style": "min-width:20px;padding:0;margin:0;"
        }, I({ "class": "fa fa-cog" }))
      )
    );
    return this;
  },
  setDiffCount: function(feedCount) {
    this.elNewFeed.textContent = Math.min(feedCount[0], 999);
    this.elChangedFeed.textContent = Math.min(feedCount[1], 999);
  },
  updateState: function() {
    this.$(".xremoved").prop("checked", this.state.removed);
    this.view.setState(this.state);
  }
});
const DiffBar$1 = BaseDiffBar.extend({
  name: "DiffBar",
  events: {
    "click .xpopup": "event_popup",
    "click .xsettings": "event_settings",
    "click .xsnipped": "event_show_snipped",
    "click .xremoved": "event_show_removed"
  },
  event_popup: function(e) {
    this.popWindow(e);
  },
  event_show_removed: function(e) {
    this.state.removed = e.target.checked;
    this.updateState();
  },
  event_show_snipped: function(e) {
    this.state.snipped = e.target.checked;
    this.updateState();
  },
  postInit: function(options) {
    this.state = _.extend({}, PREFS_DEFAULT, USER.prefs.ui_diff);
    this.view = options.view;
    this.view.setState(this.state);
  },
  render: function() {
    const tid = Date.now() * Math.random() | 0;
    this.$el.css({
      position: "absolute",
      right: 1,
      borderBottom: "solid 1px #ddd",
      backgroundColor: "#f3f3f3",
      backgroundColor: "#f0f0f0",
      marginTop: "-4px",
      padding: 0
    }).append(
      DIV(
        { "class": "inline-block" },
        A(
          {
            "class": "btn btn-default btn-sm xpopup",
            "style": "padding:0 6px; margin-right: 4px;"
          },
          T("Explore diff (beta)"),
          " ",
          SPAN(
            { style: "color: green;font-weight: bold;" },
            this.elPlus = SPAN(0),
            "+"
          ),
          " ",
          SPAN(
            { style: "color: red;font-weight: bold;" },
            this.elMinus = SPAN(0),
            SPAN({ style: "font-size: 1.1em; line-height: 1.1" }, "\u2013")
          )
        ),
        INPUT({
          "id": "removed" + tid,
          "class": "xremoved",
          "name": "removed",
          "type": "checkbox",
          "style": "position: relative; top: 2px;"
        }),
        LABEL({
          "for": "removed" + tid,
          "style": "margin:0 4px;padding:0;font-size:.9em; user-select: none;"
        }, T("Deleted")),
        INPUT({
          "id": "snipped" + tid,
          "class": "xsnipped",
          "name": "snipped",
          "type": "checkbox",
          "style": "position: relative; top: 2px;"
        }),
        LABEL({
          "for": "snipped" + tid,
          "style": "margin:0 4px;padding:0;font-size:.9em; user-select: none;"
        }, T("Snipped")),
        BUTTON({
          "class": "btn btn-default btn-sm xsettings",
          "style": "min-width:20px;padding:0;margin:0;"
        }, I({ "class": "fa fa-cog" }))
      )
    );
    this.$(":checkbox").each((_2, el) => {
      if (this.state[el.name]) {
        el.checked = true;
      }
    });
    return this;
  },
  setDiffCount: function(diffCounts) {
    this.elPlus.textContent = Math.min(diffCounts[0], 999);
    this.elMinus.textContent = Math.min(diffCounts[1], 999);
    if (diffCounts[0] + diffCounts[1] == 0) {
      this.$(".xpopup,.xsnipped,.xremoved").attr("disabled", 1);
    }
  },
  updateState: function() {
    this.$(".xsnipped").prop("checked", this.state.snipped);
    this.$(".xremoved").prop("checked", this.state.removed);
    this.view.setState(this.state);
  },
  popWindow: function(event) {
    this.view.showDiffModal();
  }
});
const DiffHTMLView = View.Base.extend({
  attributes: {
    style: "width: 100%;"
  },
  getScrollHeight: function() {
    return this.frameReady ? this.iframe.contentWindow.document.body.scrollHeight : 400;
  },
  toggleStyle: function(flag) {
    this.onFrameReady(() => {
      const doc = this.iframe.contentWindow.document;
      if (flag) {
        this.styleSheets = doc.querySelectorAll("link[rel=stylesheet],style:not(.xdistill)");
        $(this.styleSheets).remove();
        this.styledElements = $(doc).find("[style]").each(function() {
          this.dataset.oldStyle = this.getAttribute("style");
          this.removeAttribute("style");
        });
      } else {
        $(doc.head).append(this.styleSheets);
        this.styledElements.each(function() {
          this.setAttribute("style", this.dataset.oldStyle);
        });
      }
    });
  },
  hideRemoved: function() {
    this.onFrameReady(() => {
      $(this.iframe.contentWindow.document).find(".removed").addClass("xdistill-hide");
    });
  },
  hideInserted: function() {
    this.onFrameReady(() => {
      $(this.iframe.contentWindow.document).find(".inserted").addClass("xdistill-hide");
    });
  },
  moveToNextDiff: function() {
    let count2 = 0;
    const scrollCt = this.options.scrollCt;
    const scrollTop = scrollCt.scrollTop;
    const viewportHeight = $(scrollCt).height();
    const elements = $(this.iframe.contentWindow.document).find(".diffMark:visible");
    while (count2 < elements.length && elements.eq(count2++).offset().top - scrollTop < viewportHeight)
      ;
    count2 -= 1;
    if (elements[count2]) {
      elements[count2].scrollIntoView({ behavior: "smooth" });
      return true;
    }
    return false;
  },
  moveToPrevDiff: function() {
    const scrollCt = this.options.scrollCt;
    const scrollTop = scrollCt.scrollTop;
    $(scrollCt).height();
    const element2 = $(this.iframe.contentWindow.document).find(".diffMark:visible");
    let count2 = element2.length;
    while (--count2 > 0 && element2.eq(count2).offset().top + element2.eq(count2).height() > scrollTop)
      ;
    element2[count2].scrollIntoView({ behavior: "smooth" });
  },
  onFrameReady: function(callback) {
    try {
      this.frameReady ? callback() : this.once("frame_ready", callback);
    } catch (e) {
      console.error("Error calling frame ready callback", e);
    }
  },
  onViewReady: function(callback) {
    try {
      this.viewReady ? callback() : this.once("view_ready", callback);
    } catch (e) {
      console.error("Error calling view ready callback", e);
    }
  },
  render: function() {
    const iframe = IFRAME({ "class": "data-pad", "width": "100%", "scrolling": "no", "style": "border: none;" });
    this.iframe = iframe;
    this.$el.append(iframe);
    iframe.onload = () => {
      this.frameReady = true;
      this.trigger("frame_ready");
    };
    this.onFrameReady(this.renderFrameContent);
    return this;
  },
  renderFrameContent: function() {
    const sieve = this.options.model.parent;
    const html2 = this.options.html;
    const doc = this.iframe.contentWindow.document;
    const style = doc.createElement("style");
    updateFrameContent(doc, sieve.get("uri"), html2);
    $(style).attr({
      "class": "xdistill",
      "type": "text/css"
    }).text(
      ".removed {background-color:#ff9494; display:inline !important}a.removed, a .removed {color: #008}.inserted {background-color:#b7fdcb; display:inline !important}span.inserted, span.removed{padding: 1px 4px;}.xdistill-hide {display: none !important} img.inserted{border: solid 2px green; background-color: transparent; padding: 2px;}img.removed{border: solid 2px red; background-color: transparent; padding: 2px;}[hidden]{display:block;}"
    );
    $(doc).find("body").append(style);
    const cssLinks = $(doc).find('link[rel="stylesheet"]');
    async.each(cssLinks, function(link, callback) {
      link.addEventListener("load", callback);
    }, (err, res) => {
      this.viewReady = true;
      this.trigger("view_ready");
    });
  },
  scrollFirstDiffIntoView: function() {
    const el = $(this.iframe.contentWindow.document).find(".diffMark:visible")[0];
    if (el) {
      el.scrollIntoView({ behavior: "smooth" });
      return true;
    }
    return false;
  },
  setFrameHeight: function(height) {
    $(this.iframe).css("height", height);
  },
  showDiff: function() {
    this.onFrameReady(() => {
      $(this.iframe.contentWindow.document).find(".inserted").removeClass("xdistill-hide");
      $(this.iframe.contentWindow.document).find(".removed").removeClass("xdistill-hide");
    });
  }
});
View.Modal.extend({
  events: {
    "click .xdiff-toggle-mode": "toggleMode",
    "click .xdiff-toggle-style": "toggleStyle",
    "click .xleft-frame-up": "moveToPrevDiffLeftEle",
    "click .xleft-frame-down": "moveToNextDiffLeftEle",
    "click .xright-frame-up": "moveToPrevDiffRightEle",
    "click .xright-frame-down": "moveToNextDiffRightEle"
  },
  headerClass: "card-header xcard-header-alt",
  showSplitView: function() {
    this.view1.$el.parent().css("width", "50%");
    this.view2.$el.parent().css("width", "50%");
    $(this.elView2).show();
    this.view1.hideRemoved();
    this.view2.hideInserted();
    $(this.toolbarView1).css("right", "51%");
    this.syncHeight();
  },
  showInlinedView: function() {
    this.view1.$el.parent().css("width", "100%");
    $(this.elView2).hide();
    this.view1.showDiff();
    $(this.toolbarView1).css("right", "10px");
    this.syncHeight();
  },
  syncHeight: function() {
    const height = Math.max(this.view1.getScrollHeight(), this.view2.getScrollHeight());
    this.view1.setFrameHeight(height);
    this.view2.setFrameHeight(height);
    $(this.scrollCt).css("height", $(window).height() - this.scrollCt.getBoundingClientRect().y);
  },
  toggleMode: function(event) {
    this.isModeInlined = !this.isModeInlined;
    this[this.isModeInlined ? "showInlinedView" : "showSplitView"]();
    const tb = $(event.currentTarget);
    tb.find(".active").removeClass("active").removeClass("btn-primary");
    tb.find(this.isModeInlined ? ".xdiff-mode-inlined" : ".xdiff-mode-sbs").addClass("active btn-primary");
    this.syncHeight();
  },
  toggleStyle: function(event) {
    this.isStyleRemoved = !this.isStyleRemoved;
    this.view1.toggleStyle(this.isStyleRemoved);
    this.view2.toggleStyle(this.isStyleRemoved);
    const tb = $(event.currentTarget);
    tb.find(".active").removeClass("active").removeClass("btn-primary");
    tb.find(this.isStyleRemoved ? ".xdiff-style-restore" : ".xdiff-style-remove").addClass("active btn-primary");
    this.syncHeight();
  },
  moveToPrevDiffLeftEle: function() {
    this.view1.moveToPrevDiff();
  },
  moveToNextDiffLeftEle: function() {
    this.view1.moveToNextDiff();
  },
  moveToPrevDiffRightEle: function() {
    this.view2.moveToPrevDiff();
  },
  moveToNextDiffRightEle: function() {
    this.view2.moveToNextDiff();
  },
  renderHeader: function() {
    let header;
    header = DIV(
      DIV(
        { "class": "xtbar xvbar-margin pull-right" },
        BUTTON({
          "class": "close",
          "data-action": "modal close",
          "title": T("a_window_close")
        }, "\u2715")
      ),
      DIV(
        { "class": "xtbar xvbar-margin" },
        DIV(
          { "class": "btn-group btn-toggle xdiff-toggle-mode" },
          BUTTON({ "class": "btn btn-default xdiff-mode-sbs btn-primary active" }, T("Side-by-side diff")),
          BUTTON({ "class": "btn btn-default xdiff-mode-inlined" }, T("Inlined diff"))
        ),
        DIV(
          { "class": "btn-group btn-toggle xdiff-toggle-style" },
          BUTTON({ "class": "btn btn-default xdiff-style-remove btn-primary active" }, T("Styled Page")),
          BUTTON({ "class": "btn btn-default xdiff-style-restore" }, T("Unstyled Page"))
        ),
        A(
          { "href": this.model.parent.get("uri"), "class": "btn btn-default", "target": "_blank", "rel": "noopener" },
          I({ "class": "fa fa-external-link" })
        )
      )
    );
    return header;
  },
  renderView: function() {
    const el = DIV(
      { "style": "overflow-y: scroll;" },
      this.elView1 = DIV(
        { style: "width: 50%; height: 100%; float: left" },
        this.toolbarView1 = DIV(
          { "class": "btn-group", "style": "position: fixed; right: 51%" },
          BUTTON(
            { "class": "btn btn-default xleft-frame-up" },
            I({ "class": "fa fa-chevron-up" })
          ),
          BUTTON(
            { "class": "btn btn-default xleft-frame-down" },
            I({ "class": "fa fa-chevron-down" })
          )
        )
      ),
      this.elView2 = DIV(
        { style: "width: 50%; height: 100%; float:right;" },
        DIV(
          { "class": "btn-group", "style": "position: fixed; right: 15px;" },
          BUTTON(
            { "class": "btn btn-default xright-frame-up" },
            I({ "class": "fa fa-chevron-up" })
          ),
          BUTTON(
            { "class": "btn btn-default xright-frame-down" },
            I({ "class": "fa fa-chevron-down" })
          )
        )
      )
    );
    this.scrollCt = el;
    this.view1 = new DiffHTMLView({
      parent: this.parent,
      model: this.model,
      html: this.options.html,
      scrollCt: el
    }).render();
    this.elView1.appendChild(this.view1.el);
    this.view2 = new DiffHTMLView({
      parent: this.parent,
      model: this.model,
      html: this.options.html,
      scrollCt: el
    }).render();
    this.elView2.appendChild(this.view2.el);
    this.view1.hideRemoved();
    this.view2.hideInserted();
    this.view1.onViewReady(onViewReady);
    this.view2.onViewReady(onViewReady);
    const self = this;
    function onViewReady() {
      if (self.view1.frameReady && self.view2.frameReady) {
        self.syncHeight();
        $(self.view2.iframe).css("border-left", "solid 1px #666");
        if (!self.view1.scrollFirstDiffIntoView()) {
          self.view2.scrollFirstDiffIntoView();
        }
      }
      $(window).resize(self.syncHeight);
      self.on("remove", function() {
        $(window).off("resize", self.syncHeight);
      });
    }
    return el;
  }
});
const SieveToolbar$1 = View.ActionProvider.extend({
  actions: {
    list_view: { fn: "action_list_view" },
    sieve_close: { fn: "sieve_close" }
  },
  sieve_close: function(id2) {
    let base2 = getBasePath();
    let path = base2;
    let queryStr = qs.stringify(get_store_value(route).query);
    if (queryStr.length > 0) {
      path += `?${queryStr}`;
    }
    push$1(path);
  },
  action_list_view() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/list/all/`);
  },
  render: function() {
    let module = get_store_value(params).module;
    this.$el.empty().append(DIV(
      { "class": "form-actions btn-toolbar flex align-item justify-center pa3" },
      BUTTON({
        "class": "btn btn-default ",
        "data-action": "sieve more data"
      }, T("Show More")),
      BUTTON({
        "class": "btn btn-default ",
        "data-action": "sieve edit"
      }, T(T("a_edit_options"))),
      BUTTON({
        "class": "btn btn-default",
        "data-action": module == "list" ? "sieve_close" : "list_view"
      }, T("Close"))
    ));
    return this;
  }
});
const SieveDataView = View.Base.extend({
  name: "SieveDataView",
  className: "xsieve-data-item",
  action_email: async function() {
    Msg.info("loading");
    let res = await Api.api("/users/attrs", { name: "email", state: 40 });
    Msg.reset();
    const select = SELECT(res.data.map((attr2) => OPTION({ value: attr2.value }, attr2.value)));
    const view = new View.Base({
      el: DIV({ style: "margin: 5px;" }, select)
    });
    const modal = new View.SaveDiscardModal({
      name: "SieveData$Email",
      parent: this,
      title: "Email",
      a_save: "Send",
      view
    });
    modal.on("save", async () => {
      try {
        let doc1 = this.view.el.contentDocument.cloneNode(true);
        setDiffStyle$1(doc1);
        await Api.api("/agents/actions/email", "POST", {
          action: { config: { email: select.value } },
          sieve: this.model.parent.pick("id", "name", "uri", "ts"),
          sieve_data: this.model.pick("id", "text", "ts"),
          emailContent: `<div id="highlighted-inlined"
            style="padding: 10px; background-color: #fff">
            ${doc1.body.innerHTML}
          </div>`,
          hasDiff: true
        });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", () => modal.remove());
    modal.show();
  },
  createView: function() {
    const model = this.model;
    const oldModel = this.options.oldModel;
    const opts = {
      index: this.options.index,
      parent: this,
      model,
      oldModel
    };
    switch (model.get("data_type")) {
      case C$2.TYPE_HTML:
        return new SieveHTMLView(opts);
      case C$2.TYPE_FEED:
        return new SieveFeedView(opts);
      case C$2.TYPE_XML:
        return new SieveXMLView(opts);
      case C$2.TYPE_PDF_HTML:
        return new SieveHTMLView(opts);
      case C$2.TYPE_DOC:
        return new SieveHTMLView(opts);
      case C$2.TYPE_JSON:
        return new SieveJSONView(opts);
      default:
        return new Backbone$5.View({
          el: SPAN("ERR! Unknown data type")
        });
    }
  },
  onViewLoad: function() {
    this.bubbleEvent("sieve:data:loaded");
    this.diffBar && this.diffBar.setDiffCount(this.view.getDiffCount());
  },
  postInit: function() {
    this.view = this.createView();
    this.view.on("sieve:data:loaded", this.onViewLoad);
    if (this.model.get("data_type") == C$2.TYPE_FEED) {
      this.diffBar = new FeedBar({ parent: this, view: this.view });
    }
    if (this.model.get("data_type") == C$2.TYPE_HTML) {
      this.diffBar = new DiffBar$1({ parent: this, view: this.view });
    }
    if (this.model.get("data_type") == C$2.TYPE_DOC) {
      this.diffBar = new DiffBar$1({ parent: this, view: this.view });
    }
    if (this.model.get("data_type") == C$2.TYPE_PDF_HTML) {
      this.diffBar = new DiffBar$1({ parent: this, view: this.view });
    }
    if (this.model.get("data_type") == C$2.TYPE_JSON) {
      this.diffBar = new DiffBar$1({ parent: this, view: this.view });
    }
    this.listenTo(this.model, "destroy", this.remove);
  },
  render: function() {
    const ts_mod = moment(this.model.get("ts_mod"));
    let aCollapseExpand, aSendEmail;
    this.$el.empty().append(
      this.diffBar ? this.diffBar.render().el : "",
      DIV(
        { style: "display:flex;margin:4px 0;" },
        DIV(
          { style: "margin-right:10px;", title: ts_mod.format() },
          aCollapseExpand = A(
            { href: "#" },
            I({ "class": "fa fa-caret-down f4" }),
            " ",
            ts_mod.format("hh:mm A")
          ),
          DIV(
            { style: "position: relative" },
            A({
              href: "#",
              "class": "dropdown-toggle",
              "data-toggle": "dropdown"
            }, I({ "class": "fa fa-caret-down f4" }), " ", ts_mod.format("MMM DD")),
            UL(
              { "class": "dropdown-menu", "role": "menu" },
              LI(
                aSendEmail = A({
                  tabindex: -1,
                  href: "#"
                }, T("Email"))
              )
            )
          )
        ),
        DIV(
          { "style": "flex:1;background-color:#fff;border-bottom:solid 1px #ccc;" },
          DIV({
            "style": "flex:1;background-color:#fff;border-bottom:solid 1px #ccc;"
          }, this.view.render().el)
        )
      )
    );
    $(aCollapseExpand).click((e) => {
      e.preventDefault();
      this.collapsed = !this.collapsed;
      $(aCollapseExpand).find(".fa").toggleClass("fa-caret-right").toggleClass("fa-caret-down");
      this.view.$el[this.collapsed ? "hide" : "show"]();
    });
    $(aSendEmail).click((e) => {
      e.preventDefault();
      this.action_email();
    });
    return this;
  }
});
const SieveDataList$1 = View.ActionProvider.extend({
  name: "SieveDataList",
  fetch: async function() {
    const $btn = this.$('[data-action="sieve more data"]');
    const $msg = this.$(".xmsg");
    const init2 = !this.lastData;
    const limit2 = init2 ? this.options.initialFetchCount || 2 : 2;
    const query = { _opt: { limit: limit2 } };
    if (!init2) {
      query["ts.lt"] = this.lastData.ts;
    }
    $btn.button("loading");
    Msg.start("sieve:data:fetch", { info: "l_loading" });
    try {
      let res = await Api.api("/sieves/" + this.model.id + "/data", "GET", query);
      $btn.button("reset");
      const currentData = this.data;
      const newData = res.data;
      let dataToDisplay = [];
      Msg.stop("sieve:data:fetch");
      if (init2 && res.count == 0) {
        this.$data.append(DIV({ "class": "xinfo" }, T("m_history_empty")));
        this.removeProgress();
        return;
      }
      $msg.removeClass("hide").find(".info > span").text(res.count);
      if (init2) {
        dataToDisplay = newData.slice(0);
        if (dataToDisplay.length > limit2 - 1) {
          dataToDisplay.pop();
        }
      } else {
        if (this.lastData.id != this.lastDisplayedData.id) {
          dataToDisplay.push(currentData[currentData.length - 1]);
        }
        if (newData.length > 1) {
          dataToDisplay = dataToDisplay.concat(newData);
          dataToDisplay.pop();
        }
      }
      if (newData.length > 0) {
        this.lastData = newData[newData.length - 1];
      }
      for (let i2 = 0; i2 < dataToDisplay.length; i2 += 1) {
        this.addDataView(dataToDisplay[i2], dataToDisplay[i2 + 1] || this.lastData, i2);
      }
      if (dataToDisplay.length > 0) {
        this.lastDisplayedData = dataToDisplay[dataToDisplay.length - 1];
      }
      this.data = currentData.concat(newData);
      if (res.count == 0) {
      }
    } catch (err) {
      this.removeProgress();
      return Msg.stop("sieve:data:fetch", { error: "err:sieve:data:fetch" });
    }
  },
  addDataView: function(data, oldData, index2) {
    const model = new Backbone$5.Model(data);
    model.parent = this.model;
    const view = new SieveDataView({
      index: index2,
      model,
      oldModel: oldData && new Backbone$5.Model(oldData),
      parent: this
    }).render();
    this.listenTo(view, "sieve:data:loaded", this.removeProgress);
    this.$(".xinfo").remove();
    this.$data.append(view.el);
  },
  postInit: function(options) {
    this.listenTo(this.model, "change:ts_data", this.renderUpdateMsg);
    this.resetData();
  },
  removeProgress: function() {
    this.$(".xprogress").remove();
  },
  render: function() {
    const err = this.model.get("err");
    const aLog = A({
      "href": "https://distill.io/help/check-log",
      "data-action": "sieve log menu",
      "data-action-param": this.model.id
    }, "View log for details.");
    const elErr = err && DIV(
      { "class": "xinfo" },
      SPAN(
        {
          "class": "error"
        },
        T("Error encountered checking for updates. It may correct automatically on next check."),
        " ",
        aLog
      ),
      " ",
      A({ href: "https://distill.io/help/contact" }, "Get help.")
    ) || "";
    const progressBar = DIV(
      { "class": "xprogress", "style": "margin-top: -2px;position:absolute;" },
      DIV({ "class": "xindeterminate" })
    );
    const data = DIV({ "class": "xsieve-data" }, elErr);
    const actionMsg = DIV(
      { "class": "xmsg centered hide" },
      SPAN({ "class": "info" })
    );
    this.$el.append(DIV({ "class": "xview-body" }, progressBar, data), actionMsg).css({ margin: "4px 0" });
    this.$data = $(data);
    return this;
  },
  resetData: function() {
    delete this.lastData;
    delete this.lastDisplayedData;
    this.data = [];
    this.removeChildren();
    this.fetch();
  },
  renderUpdateMsg: function() {
    const $msg = $(DIV(
      { style: "text-align:center;" },
      "Updated. Reloading now... "
    ));
    _.delay(this.resetData, 100);
    _.delay(function remove() {
      $msg.remove();
    }, 1400);
  }
});
const SieveDetail$1 = View.ActionProvider.extend({
  name: "SieveDetail",
  actions: {
    "sieve edit": {
      fn: "action_edit"
    },
    "sieve more data": {
      fn: "action_more"
    }
  },
  action_edit: function() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/sieve/edit/${this.model.id}.id`);
  },
  action_more: function() {
    this.list.fetch();
  },
  postInit: function() {
    this.toolbar = new SieveToolbar$1({
      parent: this
    });
    this.list = new SieveDataList$1({
      parent: this,
      model: this.model,
      initialFetchCount: 3
    });
  },
  render: function() {
    this.$el.empty().append(
      this.list.render().el,
      this.toolbar.render().el
    );
    return this;
  }
});
function updateFrameContent(doc, uri, html2) {
  const base2 = doc.createElement("base");
  const baseURIMatch = html2.match(/<base\s*href=\"(.*?)\"/);
  let baseURI;
  if (baseURIMatch) {
    baseURI = baseURIMatch[1];
  } else {
    baseURI = uri;
    const index2 = html2.indexOf("</head>");
    html2 = html2.slice(0, index2) + '<base href="' + baseURI + '">' + html2.slice(index2);
  }
  base2.setAttribute("href", baseURI);
  $(doc.head || doc.documentElement).prepend(base2);
  if (window.IE) {
    html2 = html2.match(/^<html.*?>([\s\S]*)<\/html>$/)[1];
  }
  doc.documentElement.innerHTML = html2;
  $(doc.head || doc.documentElement).prepend(base2);
  $(doc.documentElement).find("a[href]").attr("target", "_blank").attr("rel", "noopener");
}
function setStyle$1(els, name, value) {
  _.each(els, function(el) {
    el.style[name] = value;
  });
}
function setDiffStyle$1(doc) {
  setStyle$1($(".removed"), "background-color", "#ff9494");
  setStyle$1($(".inserted"), "background-color", "#b7fdcb");
  setStyle$1($("span.inserted, span.removed"), "padding", "1px 4px");
  setStyle$1($("a.removed, a .removed"), "color", "#008");
  setStyle$1($("img.removed"), "border", "solid 2px red");
  setStyle$1($("img.removed"), "background-color", "transparent");
  setStyle$1($("img.removed"), "padding", "2px");
  setStyle$1($("img.inserted"), "border", "solid 2px green");
  setStyle$1($("img.inserted"), "background-color", "transparent");
  setStyle$1($("img.inserted"), "padding", "2px");
}
const _SieveFormModel = class extends FormModel {
  constructor(model) {
    super(_SieveFormModel.fieldDefs, model.toJSON());
    this.model = model;
    this.unsubscribeCallbacks = [];
    Object.entries(this.fields).forEach(([field, store2]) => {
      this.unsubscribeCallbacks.push(store2.subscribe((_2) => {
        this.model.parseAndSet(field, store2.toJSON());
      }));
    });
  }
  copyForm(formModel) {
    this.copyFields(formModel.fields);
  }
  set(res) {
    const fields = this.defs;
    Object.keys(fields).forEach((key) => {
      if (key in res) {
        this.fields[key].set(res[key], { parse: true });
      }
    });
  }
  copyFromModel(model) {
    this.set(model.toJSON());
  }
  copyFields(fields) {
    Object.entries(fields).forEach(([field, store2]) => {
      this.fields[field].set(get_store_value(store2));
    });
  }
  clone() {
    this.modelClone = this.model.clone();
    return new _SieveFormModel(this.modelClone);
  }
  unsubscribe() {
    this.unsubscribeCallbacks.forEach((_unsubscribe) => _unsubscribe());
  }
};
let SieveFormModel = _SieveFormModel;
__publicField(SieveFormModel, "fieldDefs", {
  uri: {
    type: "url",
    required: true
  },
  config: {
    type: "jsonStr",
    required: true
  },
  schedule: {
    type: "jsonStr",
    required: true
  }
});
__publicField(SieveFormModel, "path", "sieves");
const get_content_slot_changes = (dirty) => ({});
const get_content_slot_context = (ctx) => ({});
function create_if_block$1y(ctx) {
  let div;
  let h3;
  let t;
  return {
    c() {
      div = element("div");
      h3 = element("h3");
      t = text(ctx[0]);
      attr(div, "class", "xpage-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h3);
      append(h3, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$38(ctx) {
  let t;
  let div;
  let current;
  let if_block = ctx[0] && create_if_block$1y(ctx);
  const content_slot_template = ctx[2].content;
  const content_slot = create_slot(content_slot_template, ctx, ctx[1], get_content_slot_context);
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (content_slot)
        content_slot.c();
      set_style(div, "padding", "10px");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      if (content_slot) {
        content_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1y(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(content_slot_template, ctx2[1], dirty, get_content_slot_changes),
            get_content_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(content_slot, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      if (content_slot)
        content_slot.d(detaching);
    }
  };
}
function instance$34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [title, $$scope, slots];
}
class Layout extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$34, create_fragment$38, safe_not_equal, { title: 0 });
  }
}
function create_else_block$Q(ctx) {
  let t;
  return {
    c() {
      t = text("Please sign in or contact support to get more information");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$1x(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let a;
  let t4;
  return {
    c() {
      t0 = text(ctx[0]);
      t1 = text(" monitors are available in ");
      t2 = text(ctx[1]);
      t3 = text(" or higher subscriptions. ");
      a = element("a");
      t4 = text("Manage Subscription");
      attr(a, "href", urlCfg.billing);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, a, anchor);
      append(a, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (dirty & 2)
        set_data(t2, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(a);
    }
  };
}
function create_content_slot$3(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block$1x;
    return create_else_block$Q;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$37(ctx) {
  let sieveoptionslayout;
  let current;
  sieveoptionslayout = new Layout({
    props: {
      title: T("m_upgrade_account"),
      $$slots: { content: [create_content_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sieveoptionslayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptionslayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sieveoptionslayout_changes = {};
      if (dirty & 7) {
        sieveoptionslayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sieveoptionslayout.$set(sieveoptionslayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptionslayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptionslayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptionslayout, detaching);
    }
  };
}
function instance$33($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { minPlan } = $$props;
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("minPlan" in $$props2)
      $$invalidate(1, minPlan = $$props2.minPlan);
  };
  return [type, minPlan];
}
class UpgradeAccount extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$33, create_fragment$37, safe_not_equal, { type: 0, minPlan: 1 });
  }
}
function create_content_slot$2(ctx) {
  let div1;
  let div0;
  let t0_value = SPRINTF("m_monitor_constraint_1", ctx[0].count, ctx[0].limit) + "";
  let t0;
  let t1;
  let t2_value = SPRINTF("m_monitor_constraint_2") + "";
  let t2;
  let t3;
  let ul;
  let li0;
  let a0;
  let i0;
  let t4;
  let t5_value = SPRINTF("a_go_to_watchlist") + "";
  let t5;
  let t6;
  let t7_value = SPRINTF("m_monitor_constraint_3") + "";
  let t7;
  let t8;
  let li1;
  let a1;
  let i1;
  let t9;
  let t10_value = SPRINTF("a_go_to_billing") + "";
  let t10;
  let t11;
  let t12_value = SPRINTF("m_monitor_constraint_4") + "";
  let t12;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      i0 = element("i");
      t4 = space();
      t5 = text(t5_value);
      t6 = text("\n            : ");
      t7 = text(t7_value);
      t8 = space();
      li1 = element("li");
      a1 = element("a");
      i1 = element("i");
      t9 = space();
      t10 = text(t10_value);
      t11 = text(" : ");
      t12 = text(t12_value);
      attr(i0, "class", "fa fa-link");
      attr(a0, "href", urlCfg.watchlist);
      attr(i1, "class", "fa fa-link");
      attr(a1, "href", urlCfg.billing);
      attr(div0, "class", "alert alert-danger");
      attr(div1, "class", "xmonitor-limit");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      append(div0, t2);
      append(div0, t3);
      append(div0, ul);
      append(ul, li0);
      append(li0, a0);
      append(a0, i0);
      append(a0, t4);
      append(a0, t5);
      append(li0, t6);
      append(li0, t7);
      append(ul, t8);
      append(ul, li1);
      append(li1, a1);
      append(a1, i1);
      append(a1, t9);
      append(a1, t10);
      append(a1, t11);
      append(a1, t12);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = SPRINTF("m_monitor_constraint_1", ctx2[0].count, ctx2[0].limit) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_fragment$36(ctx) {
  let sieveoptionslayout;
  let current;
  sieveoptionslayout = new Layout({
    props: {
      title: SPRINTF("m_monitor_limit"),
      $$slots: { content: [create_content_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sieveoptionslayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptionslayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sieveoptionslayout_changes = {};
      if (dirty & 3) {
        sieveoptionslayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sieveoptionslayout.$set(sieveoptionslayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptionslayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptionslayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptionslayout, detaching);
    }
  };
}
function instance$32($$self, $$props, $$invalidate) {
  let { constraint } = $$props;
  $$self.$$set = ($$props2) => {
    if ("constraint" in $$props2)
      $$invalidate(0, constraint = $$props2.constraint);
  };
  return [constraint];
}
class SieveConstraint extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$32, create_fragment$36, safe_not_equal, { constraint: 0 });
  }
}
function create_header_slot$i(ctx) {
  let t;
  return {
    c() {
      t = text("Visual Selector");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$P(ctx) {
  let t_value = T("h_opened_selector_in_tab") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$1w(ctx) {
  let t_value = T("h_opening_selector_in_new_tab") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$18(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block$1w;
    return create_else_block$P;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$35(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      $$slots: {
        default: [create_default_slot$18],
        header: [create_header_slot$i]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[1]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 513) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
async function createTab(info) {
  return new Promise(function(resolve, reject) {
    chrome.tabs.create(info, async (tab) => {
      if (tab) {
        resolve(tab);
      } else {
        reject({
          code: "EBROWSER",
          msg: "chrome.tabs.create failed to create a tab"
        });
      }
    });
  });
}
function instance$31($$self, $$props, $$invalidate) {
  let { formModel } = $$props;
  const { model } = formModel;
  const { uri } = formModel.fields;
  const dispatch = createEventDispatcher();
  let tabId;
  let loading2 = false;
  openVisualSelector();
  function onDiscard() {
    serviceProxy.closeSelector(tabId);
    dispatch("discard");
  }
  function openVisualSelector() {
    Msg.reset();
    $$invalidate(0, loading2 = true);
    setTimeout(
      async () => {
        try {
          await renderTab();
        } catch (err) {
          console.error("Error opening Visual Selector", err);
          Msg.error(err.msg || err.message || err);
        }
      },
      400
    );
  }
  async function renderTab() {
    let url = uri.toJSON() || "https://google.com";
    $$invalidate(0, loading2 = false);
    const tab = await createTab({ active: true });
    tabId = tab.id;
    try {
      let sieve = await serviceProxy.attachAndOpenSelector({ tabId, url, model: model.toJSON() });
      if (sieve) {
        model.parseAndSet({ ...sieve });
        formModel.copyFromModel(model);
        dispatch("save");
        Msg.info("m_selection_saved");
      } else {
        onDiscard();
        Msg.info("m_selection_discarded");
      }
    } catch (e) {
      Msg.error(`${T("e_err")}: ${e.message}`);
    }
    chrome.tabs.getCurrent(function(tab2) {
      chrome.tabs.update(tab2.id, { active: true });
    });
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(2, formModel = $$props2.formModel);
  };
  return [loading2, onDiscard, formModel];
}
class Html extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$31, create_fragment$35, safe_not_equal, { formModel: 2 });
  }
}
function applyFilters(json, filters) {
  let prev = isArray(json) ? [] : {};
  let filtersExecuted = [];
  if (filters.length === 1 && filters[0] === ".") {
    return json;
  }
  let clone = structuredClone(prev);
  filters.forEach((filter) => {
    if (!isSubstring(filtersExecuted, filter)) {
      let operations = getOperationsArray(filter);
      try {
        prev = applyFilter(json, operations, prev);
        clone = structuredClone(prev);
      } catch (e) {
        prev = structuredClone(clone);
      }
      filtersExecuted.push(filter);
    }
  });
  return prev;
}
function applyFilter(data, operations, prev, explode = false) {
  let res = prev || {};
  let temp = res;
  let key;
  for (let index2 = 0; index2 < operations.length; index2++) {
    let op = operations[index2];
    if (op.includes("[]?")) {
      if (data === void 0) {
        throw new Error("Data Undefined");
      }
      key = op.split("[]?")[0];
      if (key) {
        data = data[key];
        if (!temp[key]) {
          temp[key] = [];
        }
        temp = temp[key];
      } else if (!prev) {
        res = [];
        temp = res;
      }
      if (!operations[index2 + 1]) {
        data.forEach((value) => temp.push(value));
      } else {
        let ops = operations.splice(index2 + 1);
        if (temp.length !== 0) {
          data.forEach((obj, i2) => applyFilter(obj, [...ops], temp[i2], true));
        } else {
          data.forEach(
            (obj) => temp.push(applyFilter(obj, [...ops], void 0, true))
          );
        }
      }
    } else if (op !== "") {
      data = data[op];
      if (data === void 0) {
        if (explode) {
          return res;
        } else {
          throw new Error("Data Undefined");
        }
      }
      if (isObject(data) && operations[index2 + 1]) {
        if (!temp[op]) {
          temp[op] = {};
        }
        temp = temp[op];
      } else {
        temp[op] = data;
      }
    }
  }
  return res;
}
function getOperationsArray(filter) {
  filter = filter.replace(/"/g, "");
  return filter.split(".");
}
function getType(data) {
  return Object.prototype.toString.call(data).slice(8, -1);
}
function isObject(data) {
  return Object.prototype.toString.call(data).slice(8, -1) === "Object";
}
function isArray(data) {
  return getType(data) === "Array";
}
function isSubstring(arr, str) {
  let res = false;
  for (let val of arr) {
    if (str.includes(val)) {
      res = true;
      break;
    }
  }
  return res;
}
function initStores(includedJSON = []) {
  const originalJson = writable("");
  const includedJson = writable(includedJSON);
  return {
    originalJson,
    includedJson,
    previewJson: derived(includedJson, ($includedJson) => applyFilters(get_store_value(originalJson), $includedJson))
  };
}
const ParsedPropertyName = "parsed__properties";
const NumberOfMerges = "number__merges";
const PrimitiveProperties = "primitive__properties";
function isInternalField(name) {
  switch (name) {
    case ParsedPropertyName:
    case NumberOfMerges:
    case PrimitiveProperties:
      return true;
    default:
      return false;
  }
}
let outputTemplate = {};
function merge$1(template, obj) {
  const primitivePropertiesEncountered = {};
  Object.keys(obj).filter((k) => !isInternalField(k)).forEach((k) => {
    switch (obj[ParsedPropertyName][k]) {
      case types.OBJECT:
        if (!template[k]) {
          template[k] = {};
        }
        merge$1(template[k], obj[k]);
        break;
      case types.ARRAY_OF_OBJECTS:
        if (!template[k]) {
          template[k] = obj[k];
        } else if (template[k].length === 1 && obj[k].length === 1) {
          merge$1(template[k][0], obj[k][0]);
        }
        break;
      case types.ARRAY:
        if (!template[k]) {
          template[k] = [];
        }
        template[k].push(obj[k]);
        break;
      case types.PRIMITIVE:
        if (!template[k]) {
          template[k] = [];
          const numberOfMerges = template[NumberOfMerges] || 0;
          for (let i2 = 0; i2 < numberOfMerges; i2++) {
            template[k].push(null);
          }
        }
        if (Array.isArray(template[k]) && Array.isArray(obj[k])) {
          template[k].push(...obj[k]);
        } else if (Array.isArray(template[k])) {
          template[k].push(obj[k]);
        } else {
          break;
        }
        if (!template[PrimitiveProperties]) {
          template[PrimitiveProperties] = {};
        }
        template[PrimitiveProperties][k] = true;
        primitivePropertiesEncountered[k] = true;
        break;
    }
  });
  if (!template[ParsedPropertyName]) {
    template[ParsedPropertyName] = obj[ParsedPropertyName];
  } else {
    template[ParsedPropertyName] = {
      ...template[ParsedPropertyName],
      ...obj[ParsedPropertyName]
    };
  }
  template[NumberOfMerges] = template[NumberOfMerges] ? ++template[NumberOfMerges] : 1;
  if (template[PrimitiveProperties]) {
    Object.keys(template[PrimitiveProperties]).filter((key) => !primitivePropertiesEncountered[key]).forEach((key) => {
      if (template[key]) {
        template[key].push(null);
      }
    });
  }
}
function createArrayTemplate(array, template) {
  let mergedObject = {};
  for (let arr of array) {
    const type = jsonType(arr);
    if (type === types.OBJECT) {
      const innerTemplate = createTemplate(arr, {});
      merge$1(mergedObject, innerTemplate);
    }
  }
  template.push(mergedObject);
  return template;
}
function createTemplate(json, template) {
  let properties = {};
  for (let key in json) {
    if (Object.prototype.hasOwnProperty.call(json, key)) {
      let type = jsonType(json[key]);
      if (type === types.OBJECT) {
        template[key] = createTemplate(json[key], {});
        properties[key] = types.OBJECT;
      } else if (type === types.ARRAY) {
        if (isArrayOfObject(json[key])) {
          template[key] = createArrayTemplate(json[key], []);
          properties[key] = types.ARRAY_OF_OBJECTS;
        } else {
          template[key] = json[key];
          properties[key] = types.ARRAY;
        }
      } else {
        template[key] = json[key];
        properties[key] = types.PRIMITIVE;
      }
    }
  }
  template[ParsedPropertyName] = properties;
  return template;
}
function performJSONParsing(json) {
  const type = jsonType(json);
  if (type === types.ARRAY) {
    if (isArrayOfObject(json)) {
      outputTemplate = createArrayTemplate(json, []);
    } else if (isArrayOfPrimitives(json)) {
      outputTemplate = json;
    } else {
      outputTemplate = "Array";
    }
  } else if (type === types.OBJECT) {
    outputTemplate = createTemplate(json, {});
  } else {
    return {
      msg: "Invalid Json"
    };
  }
  return outputTemplate;
}
function sanitize(parsedJSON, fieldName) {
  if (!parsedJSON) {
    return parsedJSON;
  } else if (Array.isArray(parsedJSON)) {
    for (let i2 = 0; i2 < parsedJSON.length; i2++) {
      sanitize(parsedJSON[i2], fieldName);
    }
  } else if (jsonType(parsedJSON) === types.OBJECT) {
    if (Object.prototype.hasOwnProperty.call(parsedJSON, fieldName)) {
      delete parsedJSON[fieldName];
    }
    Object.keys(parsedJSON).filter((k) => parsedJSON[k]).filter((k) => !isPrimitive$1(parsedJSON[k])).forEach((k) => sanitize(parsedJSON[k], fieldName));
  }
}
function jsonParser(json) {
  const parsedJSON = performJSONParsing(json);
  sanitize(parsedJSON, NumberOfMerges);
  sanitize(parsedJSON, PrimitiveProperties);
  return parsedJSON;
}
function prepareSchema(parsedJSON) {
  const schema = prepareSchema1(parsedJSON);
  return schema;
}
function prepareSchema1(parsedJSON) {
  const type = jsonType(parsedJSON);
  if (type === types.ARRAY) {
    if (isArrayOfObject(parsedJSON)) {
      return handleArrayOfObjects(parsedJSON);
    } else {
      return handleArrayOfPrimitives(parsedJSON);
    }
  } else if (type === types.OBJECT) {
    return handleObject(parsedJSON);
  } else {
    return parsedJSON;
  }
}
function handleObject(parsedJSON) {
  const deepCopy = JSON.parse(JSON.stringify(parsedJSON));
  const properties = parsedJSON[ParsedPropertyName];
  Object.keys(parsedJSON).filter((k) => k !== ParsedPropertyName).forEach((k) => {
    switch (properties[k]) {
      case types.PRIMITIVE:
        parsedJSON[k] = handlePrimitive(parsedJSON[k]);
        break;
      case types.ARRAY:
        parsedJSON[k] = handleArrayOfPrimitives(parsedJSON[k]);
        break;
      case types.ARRAY_OF_OBJECTS:
        parsedJSON[k] = handleArrayOfObjects(parsedJSON[k]);
        break;
      case types.OBJECT:
        parsedJSON[k] = handleObject(parsedJSON[k]);
        break;
    }
  });
  return {
    schema: parsedJSON,
    type: types.OBJECT,
    value: deepCopy
  };
}
function handlePrimitive(value) {
  return {
    value,
    type: Array.isArray(value) ? jsonType(findFirstNotNullElemFromArray(value)) : jsonType(value)
  };
}
function handleArrayOfPrimitives(value) {
  return {
    value,
    type: types.ARRAY
  };
}
function handleArrayOfObjects(value) {
  return {
    value,
    type: types.ARRAY_OF_OBJECTS,
    schema: handleObject(value[0])
  };
}
function findFirstNotNullElemFromArray(arr) {
  if (!arr) {
    return null;
  }
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2]) {
      return arr[i2];
    }
  }
  return null;
}
var svelteTree = "";
function create_label_slot(ctx) {
  let span;
  let t_value = ctx[0].label + "";
  let t;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "slot", "label");
      attr(span, "title", span_title_value = ctx[0].label);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].label + ""))
        set_data(t, t_value);
      if (dirty & 1 && span_title_value !== (span_title_value = ctx2[0].label)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_icon_slot$3(ctx) {
  let span;
  let div;
  let typesvg;
  let div_title_value;
  let current;
  typesvg = new TypeSVG({ props: { type: ctx[0].type } });
  return {
    c() {
      span = element("span");
      div = element("div");
      create_component(typesvg.$$.fragment);
      attr(div, "class", "tv-svg");
      attr(div, "title", div_title_value = ctx[0].type);
      attr(span, "slot", "icon");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, div);
      mount_component(typesvg, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const typesvg_changes = {};
      if (dirty & 1)
        typesvg_changes.type = ctx2[0].type;
      typesvg.$set(typesvg_changes);
      if (!current || dirty & 1 && div_title_value !== (div_title_value = ctx2[0].type)) {
        attr(div, "title", div_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(typesvg);
    }
  };
}
function create_meta_slot(ctx) {
  let div;
  let nodevalue;
  let div_title_value;
  let current;
  nodevalue = new NodeValue({
    props: {
      content: ctx[0].getPrettyValue()
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nodevalue.$$.fragment);
      attr(div, "slot", "meta");
      set_style(div, "white-space", "normal");
      set_style(div, "overflow-wrap", "anywhere");
      attr(div, "title", div_title_value = ctx[0].getValue());
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nodevalue, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nodevalue_changes = {};
      if (dirty & 1)
        nodevalue_changes.content = ctx2[0].getPrettyValue();
      nodevalue.$set(nodevalue_changes);
      if (!current || dirty & 1 && div_title_value !== (div_title_value = ctx2[0].getValue())) {
        attr(div, "title", div_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(nodevalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodevalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(nodevalue);
    }
  };
}
function create_fragment$34(ctx) {
  let div;
  let treeview;
  let current;
  treeview = new TreeView$1({
    props: {
      root: ctx[0],
      class: "tree-view bg-white min-w-min",
      $$slots: {
        meta: [
          create_meta_slot,
          ({ node: node2 }) => ({ 0: node2 }),
          ({ node: node2 }) => node2 ? 1 : 0
        ],
        icon: [
          create_icon_slot$3,
          ({ node: node2 }) => ({ 0: node2 }),
          ({ node: node2 }) => node2 ? 1 : 0
        ],
        label: [
          create_label_slot,
          ({ node: node2 }) => ({ 0: node2 }),
          ({ node: node2 }) => node2 ? 1 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  treeview.$on("check", ctx[7]);
  return {
    c() {
      div = element("div");
      create_component(treeview.$$.fragment);
      set_style(div, "--max-depth", ctx[3]());
      attr(div, "class", "overflow-auto bb bl br border-bootstrap-border");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(treeview, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const treeview_changes = {};
      if (dirty & 1)
        treeview_changes.root = ctx2[0];
      if (dirty & 32769) {
        treeview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeview.$set(treeview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(treeview);
    }
  };
}
const MaxAllowableDepthForWidth = 12;
const MinAllowableDepthForWidth = 8;
function instance$30($$self, $$props, $$invalidate) {
  let $maxDepth;
  let { obj } = $$props;
  let { includedJqFilter = [] } = $$props;
  let { stores = {} } = $$props;
  let maxDepth = writable(0);
  component_subscribe($$self, maxDepth, (value) => $$invalidate(9, $maxDepth = value));
  class Node2 extends BaseNode {
    constructor({ id: id2, label, parent: parent2 = null, type = null, key = null, jqSelector = ".", value = null, checkable = true, disabled: disabled2 = false }) {
      super(id2, label, parent2);
      this.checkable = checkable;
      this.selectable = false;
      this.disabled = disabled2;
      this._expanded = true;
      this.type = type;
      this.key = key;
      this.jqSelector = jqSelector;
      this.value = value;
    }
    isSelectable() {
      return false;
    }
    getJqSelector() {
      return this.jqSelector;
    }
    getIncludedSelectors() {
      const res = [];
      (function getSelectors(node3, res2) {
        if (!node3.isCheckable()) {
          return;
        }
        const state = node3.getCheckState();
        if (state === CheckState.selected) {
          res2.push(node3.getJqSelector());
        } else {
          (node3.children || []).forEach((child) => {
            getSelectors(child, res2);
          });
        }
      })(this, res);
      return res;
    }
    changeInitialSelector() {
      const selector = this.getJqSelector();
      if (get_store_value(stores.includedJson).some((filter) => selector === filter)) {
        this.checkAll(CheckState.selected);
      } else {
        (this.children || []).forEach((child) => child.changeInitialSelector());
      }
    }
    firstValue(arrayOrValue) {
      if (arrayOrValue === void 0) {
        return "";
      }
      if (Array.isArray(arrayOrValue) && arrayOrValue && arrayOrValue.length > 0) {
        for (let i2 = 0; i2 < arrayOrValue.length; i2++) {
          if (arrayOrValue[i2]) {
            return arrayOrValue[i2];
          }
        }
        return arrayOrValue[0];
      }
      return arrayOrValue;
    }
    getValue() {
      switch (this.type) {
        case types.STRING:
          return this.value;
        default:
          return this.getPrettyValue();
      }
    }
    getPrettyValue() {
      switch (this.type) {
        case types.STRING:
        case types.NUMBER:
          return this.firstValue(this.value);
        case types.BOOLEAN:
          return this.value;
        case types.ARRAY:
          return `Array with ${this.value.length} values(s)`;
        case types.ARRAY_OF_OBJECTS:
          return "Array containing Objects";
        case types.OBJECT:
          return "";
        default:
          return this.value;
      }
    }
  }
  class ArrOfObjectNode extends Node2 {
    constructor({ id: id2, label, parent: parent2 = null, type = null, key = null, jqSelector = ".", value = null, checkable = true, previewJSONStore = null }) {
      super({
        id: id2,
        label,
        parent: parent2,
        type,
        key,
        jqSelector,
        value,
        checkable
      });
      if (this.type === types.ARRAY_OF_OBJECTS) {
        this.previewJSONStore = previewJSONStore;
        this.unsubscribe = this.previewJSONStore.subscribe((val) => {
          if (this.unsubscribe) {
            this.updatePreview(val);
          }
        });
      }
    }
    getPreviewNode() {
      if (this.children && this.children.length > 0) {
        const lastChild = this.children[this.children.length - 1];
        if (lastChild && lastChild.label === "Preview") {
          return lastChild;
        }
      }
      return null;
    }
    async updatePreview(newContent) {
      if (this.type !== types.ARRAY_OF_OBJECTS) {
        return;
      }
      if (!this.children || this.children.length === 0) {
        return;
      }
      const itemsNode = this.children[0];
      const children = await itemsNode.getChildren();
      const previewValues = {};
      let valueLength = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (isPrimitiveType(child.type) && child.checkState === CheckState.selected) {
          previewValues[child.key] = child.value;
          valueLength = child.value.length;
        }
      }
      const preview = [];
      for (let i2 = 0; i2 < valueLength; i2++) {
        const previewElem = {};
        Object.keys(previewValues).forEach((k) => {
          previewElem[k] = previewValues[k][i2];
        });
        preview.push(previewElem);
      }
      if (preview) {
        this.getPreviewNode().setChildren(jsonToNodeForPreview(preview, this.getPreviewNode()));
        this.getPreviewNode().setDisabled(false);
      } else {
        this.getPreviewNode().setChildren([]);
        this.getPreviewNode().setDisabled(true);
      }
      this.getPreviewNode().notify();
      this.notify();
    }
  }
  let count2 = 0;
  let node2;
  function createNode(obj2) {
    sanitize(obj2, ParsedPropertyName);
    $$invalidate(0, node2 = jsonToNode(obj2, "Properties", null, ".", 0));
    if ($maxDepth > MaxAllowableDepthForWidth) {
      maxDepth.set(MaxAllowableDepthForWidth);
    } else if ($maxDepth < MinAllowableDepthForWidth) {
      maxDepth.set(MinAllowableDepthForWidth);
    }
    node2.changeInitialSelector();
    const jq = node2.getIncludedSelectors();
    stores.includedJson.update((val) => jq);
  }
  function jsonToNode(json, label, parent2, jq, depth) {
    let type = json.type;
    let value;
    try {
      value = JSON.parse(JSON.stringify(json.value));
    } catch (e) {
      console.error("error while JSON conversion for creating the value", json.value, e);
    }
    let newNode;
    if ($maxDepth < depth) {
      maxDepth.set(depth);
    }
    delete json.value;
    switch (type) {
      case types.ARRAY_OF_OBJECTS:
        newNode = new ArrOfObjectNode({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value,
          previewJSONStore: stores.previewJson
        });
        const schema = json.schema;
        newNode.children = [];
        newNode.children.push(jsonToNode(schema, "Items", newNode, jq + "[]?", depth + 1));
        newNode.children.push(new Node2({
          id: count2++,
          label: "Preview",
          parent: newNode,
          checkable: false,
          value: "",
          disabled: true,
          expandable: false
        }));
        break;
      case types.OBJECT:
        newNode = new Node2({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value
        });
        newNode.children = Object.keys(json.schema).map((key) => jsonToNode(json.schema[key], key, newNode, jq + (newNode.isRoot() ? "" : ".") + `"${key}"`, depth + 1));
        break;
      case types.NUMBER:
      case types.BOOLEAN:
      case types.STRING:
      case types.PRIMITIVE:
      case types.ARRAY:
      default:
        newNode = new Node2({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value
        });
        break;
    }
    return newNode;
  }
  function onCheck(detail) {
    let { checked, node: node3 } = detail;
    let jqSelectors = node3.getRoot().getIncludedSelectors();
    stores.includedJson.update(function(val) {
      return jqSelectors;
    });
  }
  function jsonToNodeForPreview(obj2, parent2) {
    const newNodes = [];
    for (const key in obj2) {
      let newNode = new Node2({
        id: count2++,
        label: key,
        parent: parent2,
        value: isPrimitive$1(obj2[key]) || isArrayOfPrimitives(obj2[key]) ? obj2[key] : "",
        checkable: false,
        type: jsonType(obj2[key])
      });
      if (!isPrimitive$1(obj2[key]) && !Array.isArray(obj2[key])) {
        newNode.children = jsonToNodeForPreview(obj2[key], newNode);
      }
      newNodes.push(newNode);
    }
    return newNodes;
  }
  function getDepth() {
    let minWidth = 30, upper_bound = 40;
    let depth = minWidth + 2 * $maxDepth;
    return `${depth > upper_bound ? upper_bound : depth}%`;
  }
  const check_handler = (e) => onCheck(e.detail);
  $$self.$$set = ($$props2) => {
    if ("obj" in $$props2)
      $$invalidate(4, obj = $$props2.obj);
    if ("includedJqFilter" in $$props2)
      $$invalidate(5, includedJqFilter = $$props2.includedJqFilter);
    if ("stores" in $$props2)
      $$invalidate(6, stores = $$props2.stores);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      createNode(obj);
    }
  };
  return [
    node2,
    maxDepth,
    onCheck,
    getDepth,
    obj,
    includedJqFilter,
    stores,
    check_handler
  ];
}
class Tree extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$30, create_fragment$34, safe_not_equal, { obj: 4, includedJqFilter: 5, stores: 6 });
  }
}
function create_fragment$33(ctx) {
  let div;
  let ul;
  let li0;
  let a0;
  let t1;
  let li1;
  let a1;
  let t3;
  let pre;
  let t4_value = JSON.stringify(
    ctx[0] == "distilled" ? ctx[3] : ctx[1],
    null,
    2
  ) + "";
  let t4;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      a0.textContent = "Distilled";
      t1 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = "Response";
      t3 = space();
      pre = element("pre");
      t4 = text(t4_value);
      attr(a0, "class", "nav-link cursor-pointer");
      attr(a0, "data-toggle", "tab");
      toggle_class(a0, "active", ctx[0] === "distilled");
      attr(li0, "class", "nav-item");
      attr(a1, "class", "nav-link cursor-pointer");
      attr(a1, "data-toggle", "tab");
      toggle_class(a1, "active", ctx[0] === "response");
      attr(li1, "class", "nav-item");
      attr(ul, "class", "nav nav-tabs ");
      attr(pre, "class", "max-h-[600px] bg-white overflow-auto max-w-[40vw]");
      set_style(pre, "border-top", "none");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ul);
      append(ul, li0);
      append(li0, a0);
      append(ul, t1);
      append(ul, li1);
      append(li1, a1);
      append(div, t3);
      append(div, pre);
      append(pre, t4);
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[6]),
          listen(a1, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        toggle_class(a0, "active", ctx2[0] === "distilled");
      }
      if (dirty & 1) {
        toggle_class(a1, "active", ctx2[0] === "response");
      }
      if (dirty & 11 && t4_value !== (t4_value = JSON.stringify(
        ctx2[0] == "distilled" ? ctx2[3] : ctx2[1],
        null,
        2
      ) + ""))
        set_data(t4, t4_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2$($$self, $$props, $$invalidate) {
  let $previewJsonStore, $$unsubscribe_previewJsonStore = noop, $$subscribe_previewJsonStore = () => ($$unsubscribe_previewJsonStore(), $$unsubscribe_previewJsonStore = subscribe(previewJsonStore, ($$value) => $$invalidate(5, $previewJsonStore = $$value)), previewJsonStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_previewJsonStore());
  let { output = {} } = $$props;
  let { previewJsonStore } = $$props;
  $$subscribe_previewJsonStore();
  let distilledJSON = {};
  let { preview = "distilled" } = $$props;
  function onClickTabPreview(newValue) {
    $$invalidate(0, preview = newValue);
  }
  const click_handler = () => onClickTabPreview("distilled");
  const click_handler_1 = () => onClickTabPreview("response");
  $$self.$$set = ($$props2) => {
    if ("output" in $$props2)
      $$invalidate(1, output = $$props2.output);
    if ("previewJsonStore" in $$props2)
      $$subscribe_previewJsonStore($$invalidate(2, previewJsonStore = $$props2.previewJsonStore));
    if ("preview" in $$props2)
      $$invalidate(0, preview = $$props2.preview);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 36) {
      $$invalidate(3, distilledJSON = (previewJsonStore ? $previewJsonStore : {}) || {});
    }
  };
  return [
    preview,
    output,
    previewJsonStore,
    distilledJSON,
    onClickTabPreview,
    $previewJsonStore,
    click_handler,
    click_handler_1
  ];
}
class DistilledJSONText extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2$, create_fragment$33, safe_not_equal, {
      output: 1,
      previewJsonStore: 2,
      preview: 0
    });
  }
}
function create_fragment$32(ctx) {
  let div;
  let input0;
  let t0;
  let input1;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 col-center-block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>`;
      attr(input0, "type", "text");
      attr(input0, "class", "form-control flex-grow-1 flex-shrink-1 input-sm mr-2 w-auto");
      attr(input0, "placeholder", "Key");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control flex-grow-1 flex-shrink-1 input-sm mr-2 w-auto");
      attr(input1, "placeholder", "Value");
      attr(button, "class", "btn btn-default btn-sm flex items-center");
      attr(button, "title", "Delete");
      attr(div, "class", "flex flex-row item-center mb-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      set_input_value(input0, ctx[0]);
      append(div, t0);
      append(div, input1);
      set_input_value(input1, ctx[1]);
      append(div, t1);
      append(div, button);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[9]),
          listen(input0, "input", ctx[10]),
          listen(input1, "input", ctx[11]),
          listen(input1, "input", ctx[12]),
          listen(button, "click", function() {
            if (is_function(ctx[2]))
              ctx[2].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & 1 && input0.value !== ctx[0]) {
        set_input_value(input0, ctx[0]);
      }
      if (dirty & 2 && input1.value !== ctx[1]) {
        set_input_value(input1, ctx[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2_($$self, $$props, $$invalidate) {
  let $valueField;
  let $keyField;
  const dispatch = createEventDispatcher();
  let { model } = $$props;
  let { key } = $$props;
  let { value } = $$props;
  let { onRemove } = $$props;
  const keyField = model == null ? void 0 : model.fields.key;
  component_subscribe($$self, keyField, (value2) => $$invalidate(8, $keyField = value2));
  const valueField = model == null ? void 0 : model.fields.value;
  component_subscribe($$self, valueField, (value2) => $$invalidate(7, $valueField = value2));
  function input0_input_handler() {
    key = this.value;
    $$invalidate(0, key), $$invalidate(8, $keyField), $$invalidate(7, $valueField);
  }
  const input_handler = (e) => dispatch("keyUpdate", $$invalidate(0, key = e.target.value));
  function input1_input_handler() {
    value = this.value;
    $$invalidate(1, value), $$invalidate(8, $keyField), $$invalidate(7, $valueField);
  }
  const input_handler_1 = (e) => dispatch("valueUpdate", $$invalidate(1, value = e.target.value));
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(6, model = $$props2.model);
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("onRemove" in $$props2)
      $$invalidate(2, onRemove = $$props2.onRemove);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 384) {
      {
        if (keyField && valueField) {
          $$invalidate(0, key = $keyField);
          $$invalidate(1, value = $valueField);
        }
      }
    }
  };
  return [
    key,
    value,
    onRemove,
    dispatch,
    keyField,
    valueField,
    model,
    $valueField,
    $keyField,
    input0_input_handler,
    input_handler,
    input1_input_handler,
    input_handler_1
  ];
}
class KeyValueTable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2_, create_fragment$32, safe_not_equal, { model: 6, key: 0, value: 1, onRemove: 2 });
  }
}
const get_icon_slot_changes = (dirty) => ({});
const get_icon_slot_context = (ctx) => ({ slot: "icon" });
const get_label_pre_slot_changes = (dirty) => ({});
const get_label_pre_slot_context = (ctx) => ({ slot: "label-pre" });
const get_bottom_slot_changes = (dirty) => ({});
const get_bottom_slot_context = (ctx) => ({ slot: "bottom" });
function create_icon_slot$2(ctx) {
  let current;
  const icon_slot_template = ctx[10].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[18], get_icon_slot_context);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(icon_slot_template, ctx2[18], dirty, get_icon_slot_changes),
            get_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_label_pre_slot$3(ctx) {
  let current;
  const label_pre_slot_template = ctx[10]["label-pre"];
  const label_pre_slot = create_slot(label_pre_slot_template, ctx, ctx[18], get_label_pre_slot_context);
  return {
    c() {
      if (label_pre_slot)
        label_pre_slot.c();
    },
    m(target, anchor) {
      if (label_pre_slot) {
        label_pre_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_pre_slot) {
        if (label_pre_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            label_pre_slot,
            label_pre_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(label_pre_slot_template, ctx2[18], dirty, get_label_pre_slot_changes),
            get_label_pre_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_pre_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_pre_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_pre_slot)
        label_pre_slot.d(detaching);
    }
  };
}
function create_top_slot$3(ctx) {
  let li;
  let div;
  let input_1;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      div = element("div");
      input_1 = element("input");
      attr(input_1, "type", "text");
      attr(input_1, "class", "mx-2 my-2 flex-grow-1 p-2 rounded");
      attr(input_1, "placeholder", "Search");
      attr(div, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      append(div, input_1);
      ctx[12](input_1);
      if (!mounted) {
        dispose = [
          listen(input_1, "input", ctx[13]),
          listen(div, "click", prevent_default(ctx[11]))
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_bottom_slot$7(ctx) {
  let current;
  const bottom_slot_template = ctx[10].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[18], get_bottom_slot_context);
  return {
    c() {
      if (bottom_slot)
        bottom_slot.c();
    },
    m(target, anchor) {
      if (bottom_slot) {
        bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            bottom_slot,
            bottom_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(bottom_slot_template, ctx2[18], dirty, get_bottom_slot_changes),
            get_bottom_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (bottom_slot)
        bottom_slot.d(detaching);
    }
  };
}
function create_fragment$31(ctx) {
  let menu;
  let updating_id;
  let current;
  const menu_spread_levels = [{ toggle: false }, { items: ctx[1] }, ctx[7]];
  function menu_id_binding(value) {
    ctx[14](value);
  }
  let menu_props = {
    $$slots: {
      bottom: [create_bottom_slot$7],
      top: [create_top_slot$3],
      "label-pre": [create_label_pre_slot$3],
      icon: [create_icon_slot$2]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < menu_spread_levels.length; i2 += 1) {
    menu_props = assign$1(menu_props, menu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    menu_props.id = ctx[0];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "id", menu_id_binding));
  menu.$on("open", ctx[15]);
  menu.$on("open", ctx[6]);
  menu.$on("close", ctx[16]);
  menu.$on("select", ctx[17]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 130 ? get_spread_update(menu_spread_levels, [
        menu_spread_levels[0],
        dirty & 2 && { items: ctx2[1] },
        dirty & 128 && get_spread_object(ctx2[7])
      ]) : {};
      if (dirty & 262168) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        menu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$2Z($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "allItems", "items", "field"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $field, $$unsubscribe_field = noop, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(9, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id: id2 } = $$props;
  let { allItems } = $$props;
  let { items } = $$props;
  let { field } = $$props;
  $$subscribe_field();
  let onSearch2 = null;
  if (field) {
    onSearch2 = (val) => {
      let query = val.toLowerCase();
      if (val.length) {
        $$invalidate(1, items = allItems.filter((item) => item.name.toLowerCase().includes(query)));
      } else {
        $$invalidate(1, items = allItems);
      }
    };
  }
  const dispatch = createEventDispatcher();
  let input;
  function focus() {
    setTimeout(() => input.focus(), 100);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(4, input);
    });
  }
  const input_handler = (e) => {
    const query = e.target.value.trim();
    dispatch("search", query);
    if (onSearch2) {
      onSearch2(query);
    }
  };
  function menu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2), $$invalidate(2, field), $$invalidate(9, $field);
  }
  function open_handler(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  function select_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("allItems" in $$new_props)
      $$invalidate(8, allItems = $$new_props.allItems);
    if ("items" in $$new_props)
      $$invalidate(1, items = $$new_props.items);
    if ("field" in $$new_props)
      $$subscribe_field($$invalidate(2, field = $$new_props.field));
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      allItems && $$invalidate(1, items = [...allItems]);
    }
    if ($$self.$$.dirty & 516) {
      field && $$invalidate(0, id2 = $field);
    }
  };
  return [
    id2,
    items,
    field,
    onSearch2,
    input,
    dispatch,
    focus,
    $$restProps,
    allItems,
    $field,
    slots,
    click_handler,
    input_1_binding,
    input_handler,
    menu_id_binding,
    open_handler,
    close_handler,
    select_handler,
    $$scope
  ];
}
class SearchableMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Z, create_fragment$31, safe_not_equal, { id: 0, allItems: 8, items: 1, field: 2 });
  }
}
function create_fragment$30(ctx) {
  let li;
  let a;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let a_levels = [{ href: ctx[0] }, ctx[1]];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 1) && { href: ctx2[0] },
        dirty & 2 && ctx2[1]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2Y($$self, $$props, $$invalidate) {
  const omit_props_names = ["href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { href: href2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(0, href2 = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  return [href2, $$restProps, $$scope, slots];
}
class MenuItemLink extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Y, create_fragment$30, safe_not_equal, { href: 0 });
  }
}
function create_icon_slot$1(ctx) {
  let t;
  return {
    c() {
      t = text("\u{1F464}");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_label_pre_slot$2(ctx) {
  let t;
  return {
    c() {
      t = text("Profile -");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$q(ctx) {
  let t;
  return {
    c() {
      t = text("Manage Profiles");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$17(ctx) {
  let t;
  return {
    c() {
      t = text("Learn More");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot$6(ctx) {
  let li;
  let t0;
  let menuitemlink0;
  let t1;
  let menuitemlink1;
  let current;
  menuitemlink0 = new MenuItemLink({
    props: {
      class: "dropdown-item",
      href: "#/w/" + ctx[2].team + "/profiles/",
      target: "_blank",
      $$slots: { default: [create_default_slot_1$q] },
      $$scope: { ctx }
    }
  });
  menuitemlink1 = new MenuItemLink({
    props: {
      class: "dropdown-item",
      href: urlCfg.website + "/docs/web-monitor/profiles-for-cloud-monitors",
      target: "_blank",
      $$slots: { default: [create_default_slot$17] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      li = element("li");
      t0 = space();
      create_component(menuitemlink0.$$.fragment);
      t1 = space();
      create_component(menuitemlink1.$$.fragment);
      attr(li, "class", "dropdown-divider");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      insert(target, t0, anchor);
      mount_component(menuitemlink0, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitemlink1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemlink0_changes = {};
      if (dirty & 4)
        menuitemlink0_changes.href = "#/w/" + ctx2[2].team + "/profiles/";
      if (dirty & 4096) {
        menuitemlink0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemlink0.$set(menuitemlink0_changes);
      const menuitemlink1_changes = {};
      if (dirty & 4096) {
        menuitemlink1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemlink1.$set(menuitemlink1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemlink0.$$.fragment, local);
      transition_in(menuitemlink1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemlink0.$$.fragment, local);
      transition_out(menuitemlink1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t0);
      destroy_component(menuitemlink0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitemlink1, detaching);
    }
  };
}
function create_fragment$2$(ctx) {
  let searchablemenu;
  let updating_id;
  let current;
  const searchablemenu_spread_levels = [
    { title: "Select Session" },
    { items: ctx[1] },
    ctx[6]
  ];
  function searchablemenu_id_binding(value) {
    ctx[8](value);
  }
  let searchablemenu_props = {
    $$slots: {
      bottom: [create_bottom_slot$6],
      "label-pre": [create_label_pre_slot$2],
      icon: [create_icon_slot$1]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < searchablemenu_spread_levels.length; i2 += 1) {
    searchablemenu_props = assign$1(searchablemenu_props, searchablemenu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    searchablemenu_props.id = ctx[0];
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  binding_callbacks.push(() => bind$2(searchablemenu, "id", searchablemenu_id_binding));
  searchablemenu.$on("close", ctx[5]);
  searchablemenu.$on("search", ctx[3]);
  searchablemenu.$on("select", ctx[4]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemenu_changes = dirty & 66 ? get_spread_update(searchablemenu_spread_levels, [
        searchablemenu_spread_levels[0],
        dirty & 2 && { items: ctx2[1] },
        dirty & 64 && get_spread_object(ctx2[6])
      ]) : {};
      if (dirty & 4100) {
        searchablemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function instance$2X($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "session"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(2, $route = $$value));
  let { id: id2 } = $$props;
  let { session } = $$props;
  let initSessions;
  let items = [];
  init2();
  async function init2() {
    initSessions = $$invalidate(1, items = await getSessions());
    await addSelected();
  }
  async function onSearch2(e) {
    $$invalidate(1, items = await getSessions(e.detail));
  }
  async function getSessions(phrase = "") {
    const query = {
      _opt: { only: ["id", "name", "cookies"] }
    };
    if (phrase) {
      query["name.ilike"] = `%${phrase}%`;
    }
    const res = await Api.api("/sessions", query);
    return res.data;
  }
  async function addSelected() {
    if (!id2 || initSessions.find((s) => s.id === id2)) {
      return;
    }
    const item = await Api.api(`/sessions/${id2}`);
    $$invalidate(1, items = [item, ...initSessions]);
  }
  async function resetSessions() {
    if (!id2 || initSessions.find((m) => m.id === id2)) {
      $$invalidate(1, items = initSessions);
    } else if (id2) {
      const s = items.find((m) => m.id === id2);
      $$invalidate(1, items = [s, ...initSessions]);
    }
  }
  function searchablemenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("session" in $$new_props)
      $$invalidate(7, session = $$new_props.session);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $$invalidate(7, session = items.find((item) => item.id == id2));
    }
  };
  return [
    id2,
    items,
    $route,
    onSearch2,
    addSelected,
    resetSessions,
    $$restProps,
    session,
    searchablemenu_id_binding
  ];
}
class SelectSession extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2X, create_fragment$2$, safe_not_equal, { id: 0, session: 7 });
  }
}
async function getProxies() {
  let proxies = (await Api.api("/proxies/global")).data;
  let customProxies = (await Api.api("/proxies")).data;
  customProxies = customProxies.map((p) => ({ ...p, available: true }));
  return [...proxies, ...customProxies];
}
function create_icon_slot(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = "assets/icons/ic_ip.svg"))
        attr(img, "src", img_src_value);
      attr(img, "height", "20px");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_label_pre_slot$1(ctx) {
  let t;
  return {
    c() {
      t = text("Proxy -");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot$5(ctx) {
  let li0;
  let t0;
  let li1;
  let a0;
  let t1;
  let a0_href_value;
  let t2;
  let li2;
  let a1;
  let t3;
  return {
    c() {
      li0 = element("li");
      t0 = space();
      li1 = element("li");
      a0 = element("a");
      t1 = text("Manage Proxies");
      t2 = space();
      li2 = element("li");
      a1 = element("a");
      t3 = text("Learn More");
      attr(li0, "class", "dropdown-divider");
      attr(a0, "class", "dropdown-item");
      attr(a0, "href", a0_href_value = "#/w/" + ctx[2].team + "/proxies/");
      attr(a0, "target", "_blank");
      attr(a1, "class", "dropdown-item");
      attr(a1, "href", urlCfg.website + "/docs/web-monitor/monitor-webpage-using-proxy-servers/");
      attr(a1, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t0, anchor);
      insert(target, li1, anchor);
      append(li1, a0);
      append(a0, t1);
      insert(target, t2, anchor);
      insert(target, li2, anchor);
      append(li2, a1);
      append(a1, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && a0_href_value !== (a0_href_value = "#/w/" + ctx2[2].team + "/proxies/")) {
        attr(a0, "href", a0_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(li1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(li2);
    }
  };
}
function create_fragment$2_(ctx) {
  let menu;
  let updating_id;
  let current;
  const menu_spread_levels = [
    { items: ctx[1] },
    { title: "Select Proxy" },
    { defaultActionLabel: "Shared Pool" },
    ctx[3]
  ];
  function menu_id_binding(value) {
    ctx[5](value);
  }
  let menu_props = {
    $$slots: {
      bottom: [create_bottom_slot$5],
      "label-pre": [create_label_pre_slot$1],
      icon: [create_icon_slot]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < menu_spread_levels.length; i2 += 1) {
    menu_props = assign$1(menu_props, menu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    menu_props.id = ctx[0];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "id", menu_id_binding));
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 10 ? get_spread_update(menu_spread_levels, [
        dirty & 2 && { items: ctx2[1] },
        menu_spread_levels[1],
        menu_spread_levels[2],
        dirty & 8 && get_spread_object(ctx2[3])
      ]) : {};
      if (dirty & 68) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        menu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$2W($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "proxy"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(2, $route = $$value));
  let { id: id2 } = $$props;
  let { proxy } = $$props;
  let items = [];
  onMount(async () => {
    $$invalidate(1, items = await getProxies());
  });
  function menu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("proxy" in $$new_props)
      $$invalidate(4, proxy = $$new_props.proxy);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $$invalidate(4, proxy = items.find((item) => item.id === id2));
    }
  };
  return [id2, items, $route, $$restProps, proxy, menu_id_binding];
}
class SelectProxy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2W, create_fragment$2_, safe_not_equal, { id: 0, proxy: 4 });
  }
}
const get_addons_slot_changes = (dirty) => ({});
const get_addons_slot_context = (ctx) => ({});
function create_if_block_1$11(ctx) {
  let selectsession;
  let updating_id;
  let current;
  function selectsession_id_binding(value) {
    ctx[12](value);
  }
  let selectsession_props = {
    class: "input-group-text",
    actionClass: "text-secondary-emphasis"
  };
  if (ctx[3].session_id !== void 0) {
    selectsession_props.id = ctx[3].session_id;
  }
  selectsession = new SelectSession({ props: selectsession_props });
  binding_callbacks.push(() => bind$2(selectsession, "id", selectsession_id_binding));
  return {
    c() {
      create_component(selectsession.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectsession, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectsession_changes = {};
      if (!updating_id && dirty & 8) {
        updating_id = true;
        selectsession_changes.id = ctx2[3].session_id;
        add_flush_callback(() => updating_id = false);
      }
      selectsession.$set(selectsession_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectsession.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectsession.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectsession, detaching);
    }
  };
}
function create_if_block$1v(ctx) {
  let selectproxy;
  let updating_id;
  let current;
  function selectproxy_id_binding(value) {
    ctx[14](value);
  }
  let selectproxy_props = {
    class: "input-group-text min-w-max p-0",
    actionClass: "text-secondary-emphasis"
  };
  if (ctx[3].proxy_id !== void 0) {
    selectproxy_props.id = ctx[3].proxy_id;
  }
  selectproxy = new SelectProxy({ props: selectproxy_props });
  binding_callbacks.push(() => bind$2(selectproxy, "id", selectproxy_id_binding));
  return {
    c() {
      create_component(selectproxy.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectproxy, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectproxy_changes = {};
      if (!updating_id && dirty & 8) {
        updating_id = true;
        selectproxy_changes.id = ctx2[3].proxy_id;
        add_flush_callback(() => updating_id = false);
      }
      selectproxy.$set(selectproxy_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectproxy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectproxy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectproxy, detaching);
    }
  };
}
function create_fragment$2Z(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let urledit;
  let t2;
  let t3;
  let button;
  let t4;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[6] && create_if_block_1$11(ctx);
  const addons_slot_template = ctx[11].addons;
  const addons_slot = create_slot(addons_slot_template, ctx, ctx[10], get_addons_slot_context);
  const urledit_spread_levels = [{ field: ctx[1] }, ctx[9]];
  let urledit_props = {};
  for (let i2 = 0; i2 < urledit_spread_levels.length; i2 += 1) {
    urledit_props = assign$1(urledit_props, urledit_spread_levels[i2]);
  }
  urledit = new UrlEdit({ props: urledit_props });
  urledit.$on("input", ctx[13]);
  let if_block1 = ctx[7] && create_if_block$1v(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (addons_slot)
        addons_slot.c();
      t1 = space();
      create_component(urledit.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      button = element("button");
      t4 = text(ctx[2]);
      attr(button, "class", "btn btn-success");
      button.disabled = ctx[4];
      attr(div0, "class", "input-group");
      attr(div1, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      if (addons_slot) {
        addons_slot.m(div0, null);
      }
      append(div0, t1);
      mount_component(urledit, div0, null);
      append(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      append(div0, t3);
      append(div0, button);
      append(button, t4);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[6])
        if_block0.p(ctx2, dirty);
      if (addons_slot) {
        if (addons_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            addons_slot,
            addons_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(addons_slot_template, ctx2[10], dirty, get_addons_slot_changes),
            get_addons_slot_context
          );
        }
      }
      const urledit_changes = dirty & 514 ? get_spread_update(urledit_spread_levels, [
        dirty & 2 && { field: ctx2[1] },
        dirty & 512 && get_spread_object(ctx2[9])
      ]) : {};
      urledit.$set(urledit_changes);
      if (ctx2[7])
        if_block1.p(ctx2, dirty);
      if (!current || dirty & 4)
        set_data(t4, ctx2[2]);
      if (!current || dirty & 16) {
        button.disabled = ctx2[4];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(addons_slot, local);
      transition_in(urledit.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(addons_slot, local);
      transition_out(urledit.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (addons_slot)
        addons_slot.d(detaching);
      destroy_component(urledit);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$2V($$self, $$props, $$invalidate) {
  const omit_props_names = ["model", "uri", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $model, $$unsubscribe_model = noop, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(3, $model = $$value)), model);
  let $error;
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { model } = $$props;
  $$subscribe_model();
  let { uri } = $$props;
  let { label = "GO" } = $$props;
  const { error } = uri;
  component_subscribe($$self, error, (value) => $$invalidate(4, $error = value));
  const showSessionSelector = $model.content_type === C$2.TYPE_HTML;
  const showProxySelector = !Supports.agents.local && [C$2.TYPE_HTML, C$2.TYPE_JSON].includes($model.content_type);
  const dispatch = createEventDispatcher();
  function selectsession_id_binding(value) {
    if ($$self.$$.not_equal($model.session_id, value)) {
      $model.session_id = value;
      model.set($model);
    }
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function selectproxy_id_binding(value) {
    if ($$self.$$.not_equal($model.proxy_id, value)) {
      $model.proxy_id = value;
      model.set($model);
    }
  }
  const click_handler = () => dispatch("go");
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("model" in $$new_props)
      $$subscribe_model($$invalidate(0, model = $$new_props.model));
    if ("uri" in $$new_props)
      $$invalidate(1, uri = $$new_props.uri);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  return [
    model,
    uri,
    label,
    $model,
    $error,
    error,
    showSessionSelector,
    showProxySelector,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    selectsession_id_binding,
    input_handler,
    selectproxy_id_binding,
    click_handler
  ];
}
class SelectorUrlEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2V, create_fragment$2Z, safe_not_equal, { model: 0, uri: 1, label: 2 });
  }
}
function get_each_context$N(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[57] = list[i2];
  child_ctx[58] = list;
  child_ctx[59] = i2;
  return child_ctx;
}
function get_each_context_1$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[60] = list[i2];
  return child_ctx;
}
function get_each_context_2$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[57] = list[i2];
  child_ctx[63] = list;
  child_ctx[59] = i2;
  return child_ctx;
}
function get_each_context_3$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[57] = list[i2];
  child_ctx[59] = i2;
  return child_ctx;
}
function create_if_block_5$f(ctx) {
  let selectorurledit;
  let current;
  const selectorurledit_spread_levels = [{ model: ctx[9] }, { uri: ctx[10] }, ctx[26]];
  let selectorurledit_props = {
    $$slots: { addons: [create_addons_slot] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < selectorurledit_spread_levels.length; i2 += 1) {
    selectorurledit_props = assign$1(selectorurledit_props, selectorurledit_spread_levels[i2]);
  }
  selectorurledit = new SelectorUrlEdit({ props: selectorurledit_props });
  selectorurledit.$on("go", ctx[29]);
  selectorurledit.$on("input", ctx[30]);
  return {
    c() {
      create_component(selectorurledit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectorurledit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectorurledit_changes = dirty[0] & 67110400 ? get_spread_update(selectorurledit_spread_levels, [
        dirty[0] & 512 && { model: ctx2[9] },
        dirty[0] & 1024 && { uri: ctx2[10] },
        dirty[0] & 67108864 && get_spread_object(ctx2[26])
      ]) : {};
      if (dirty[0] & 2 | dirty[2] & 8) {
        selectorurledit_changes.$$scope = { dirty, ctx: ctx2 };
      }
      selectorurledit.$set(selectorurledit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectorurledit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectorurledit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectorurledit, detaching);
    }
  };
}
function create_addons_slot(ctx) {
  let menu;
  let updating_id;
  let current;
  function menu_id_binding(value) {
    ctx[28](value);
  }
  let menu_props = {
    title: "Request Method",
    items: ctx[12],
    allowNull: false,
    class: "input-group-addon min-w-max p-0 btn btn-default",
    actionClass: "btn btn-default border-0 "
  };
  if (ctx[1] !== void 0) {
    menu_props.id = ctx[1];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "id", menu_id_binding));
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menu_changes = {};
      if (!updating_id && dirty[0] & 2) {
        updating_id = true;
        menu_changes.id = ctx2[1];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function create_if_block_4$n(ctx) {
  let li;
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      a = element("a");
      a.textContent = "Body";
      attr(a, "class", "nav-link");
      attr(a, "href", "#body_tab");
      attr(a, "data-bs-toggle", "tab");
      toggle_class(a, "active", ctx[5] === ctx[14].BODY);
      attr(li, "class", "nav-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      if (!mounted) {
        dispose = listen(a, "click", ctx[33]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16416) {
        toggle_class(a, "active", ctx2[5] === ctx2[14].BODY);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_3$1(ctx) {
  let keyvaluetable;
  let current;
  function func2() {
    return ctx[34](ctx[59]);
  }
  function keyUpdate_handler(...args) {
    return ctx[35](ctx[59], ...args);
  }
  function valueUpdate_handler(...args) {
    return ctx[36](ctx[59], ...args);
  }
  keyvaluetable = new KeyValueTable({
    props: {
      key: ctx[57][0],
      value: ctx[57][1],
      onRemove: func2
    }
  });
  keyvaluetable.$on("keyUpdate", keyUpdate_handler);
  keyvaluetable.$on("valueUpdate", valueUpdate_handler);
  return {
    c() {
      create_component(keyvaluetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvaluetable, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const keyvaluetable_changes = {};
      if (dirty[0] & 16)
        keyvaluetable_changes.key = ctx[57][0];
      if (dirty[0] & 16)
        keyvaluetable_changes.value = ctx[57][1];
      keyvaluetable.$set(keyvaluetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvaluetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvaluetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvaluetable, detaching);
    }
  };
}
function create_each_block_2$3(ctx) {
  let keyvaluetable;
  let updating_key;
  let updating_value;
  let current;
  function func_1() {
    return ctx[37](ctx[59]);
  }
  function keyvaluetable_key_binding(value) {
    ctx[38](value, ctx[57]);
  }
  function keyvaluetable_value_binding(value) {
    ctx[39](value, ctx[57]);
  }
  let keyvaluetable_props = { onRemove: func_1 };
  if (ctx[57][0] !== void 0) {
    keyvaluetable_props.key = ctx[57][0];
  }
  if (ctx[57][1] !== void 0) {
    keyvaluetable_props.value = ctx[57][1];
  }
  keyvaluetable = new KeyValueTable({ props: keyvaluetable_props });
  binding_callbacks.push(() => bind$2(keyvaluetable, "key", keyvaluetable_key_binding));
  binding_callbacks.push(() => bind$2(keyvaluetable, "value", keyvaluetable_value_binding));
  return {
    c() {
      create_component(keyvaluetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvaluetable, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const keyvaluetable_changes = {};
      if (!updating_key && dirty[0] & 8) {
        updating_key = true;
        keyvaluetable_changes.key = ctx[57][0];
        add_flush_callback(() => updating_key = false);
      }
      if (!updating_value && dirty[0] & 8) {
        updating_value = true;
        keyvaluetable_changes.value = ctx[57][1];
        add_flush_callback(() => updating_value = false);
      }
      keyvaluetable.$set(keyvaluetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvaluetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvaluetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvaluetable, detaching);
    }
  };
}
function create_if_block$1u(ctx) {
  let div1;
  let div0;
  let label;
  let t1;
  let select;
  let t2;
  let hr;
  let t3;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ctx[13];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i2));
  }
  const if_block_creators = [create_if_block_1$10, create_if_block_2$J];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].type === "urlencoded")
      return 0;
    if (ctx2[2].type === "json")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      label = element("label");
      label.innerHTML = `<b>Content Type</b>`;
      t1 = space();
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      hr = element("hr");
      t3 = space();
      if (if_block)
        if_block.c();
      attr(select, "class", "p-1");
      if (ctx[2].type === void 0)
        add_render_callback(() => ctx[40].call(select));
      attr(div0, "class", "mlb-3");
      attr(hr, "class", "m-3");
      attr(div1, "class", "tab-pane");
      attr(div1, "id", "body_tab");
      toggle_class(div1, "active", ctx[5] === ctx[14].BODY);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, label);
      append(div0, t1);
      append(div0, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[2].type, true);
      append(div1, t2);
      append(div1, hr);
      append(div1, t3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", ctx[40]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8192) {
        each_value_1 = ctx2[13];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$7(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$7(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & 8196) {
        select_option(select, ctx2[2].type);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div1, null);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty[0] & 16416) {
        toggle_class(div1, "active", ctx2[5] === ctx2[14].BODY);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$7(ctx) {
  let option;
  let t_value = ctx[60] + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[60];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_2$J(ctx) {
  let div;
  let textarea;
  let t;
  let mounted;
  let dispose;
  let if_block = ctx[7] && create_if_block_3$y();
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      t = space();
      if (if_block)
        if_block.c();
      attr(textarea, "placeholder", "JSON");
      attr(textarea, "rows", "6");
      attr(textarea, "name", "bodyjson");
      attr(textarea, "class", "form-control");
      textarea.value = ctx[6];
      attr(div, "class", "flex flex-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(textarea, "input", ctx[44]),
          listen(textarea, "blur", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64) {
        textarea.value = ctx2[6];
      }
      if (ctx2[7]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_3$y();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$10(ctx) {
  let t0;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[2].data;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$N(get_each_context$N(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      button = element("button");
      button.textContent = "Add Field";
      attr(button, "class", "btn btn-default btn-sm");
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      insert(target, button, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[17]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 262148) {
        each_value = ctx2[2].data;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$N(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$N(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$y(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Invalid Json!!";
      attr(div, "class", "alert alert-danger");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$N(ctx) {
  let keyvaluetable;
  let updating_key;
  let updating_value;
  let current;
  function func_2() {
    return ctx[41](ctx[59]);
  }
  function keyvaluetable_key_binding_1(value) {
    ctx[42](value, ctx[57]);
  }
  function keyvaluetable_value_binding_1(value) {
    ctx[43](value, ctx[57]);
  }
  let keyvaluetable_props = { onRemove: func_2 };
  if (ctx[57][0] !== void 0) {
    keyvaluetable_props.key = ctx[57][0];
  }
  if (ctx[57][1] !== void 0) {
    keyvaluetable_props.value = ctx[57][1];
  }
  keyvaluetable = new KeyValueTable({ props: keyvaluetable_props });
  binding_callbacks.push(() => bind$2(keyvaluetable, "key", keyvaluetable_key_binding_1));
  binding_callbacks.push(() => bind$2(keyvaluetable, "value", keyvaluetable_value_binding_1));
  return {
    c() {
      create_component(keyvaluetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvaluetable, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const keyvaluetable_changes = {};
      if (!updating_key && dirty[0] & 4) {
        updating_key = true;
        keyvaluetable_changes.key = ctx[57][0];
        add_flush_callback(() => updating_key = false);
      }
      if (!updating_value && dirty[0] & 4) {
        updating_value = true;
        keyvaluetable_changes.value = ctx[57][1];
        add_flush_callback(() => updating_value = false);
      }
      keyvaluetable.$set(keyvaluetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvaluetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvaluetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvaluetable, detaching);
    }
  };
}
function create_fragment$2Y(ctx) {
  let t0;
  let ul;
  let li0;
  let a0;
  let t2;
  let li1;
  let a1;
  let t4;
  let t5;
  let div2;
  let div0;
  let t6;
  let button0;
  let t8;
  let div1;
  let t9;
  let button1;
  let t11;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[9] && create_if_block_5$f(ctx);
  let if_block1 = ctx[0] && create_if_block_4$n(ctx);
  let each_value_3 = ctx[4];
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value_2 = ctx[3];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block2 = ctx[0] && create_if_block$1u(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      a0.textContent = "Params";
      t2 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = "Header";
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t6 = space();
      button0 = element("button");
      button0.textContent = "Add Query Param";
      t8 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t9 = space();
      button1 = element("button");
      button1.textContent = "Add Header";
      t11 = space();
      if (if_block2)
        if_block2.c();
      attr(a0, "class", "nav-link");
      attr(a0, "href", "#params_tab");
      attr(a0, "data-bs-toggle", "tab");
      toggle_class(a0, "active", ctx[5] === ctx[14].PARAMS);
      attr(li0, "class", "nav-item");
      attr(a1, "class", "nav-link");
      attr(a1, "href", "#header_tab");
      attr(a1, "data-bs-toggle", "tab");
      toggle_class(a1, "active", ctx[5] === ctx[14].HEADERS);
      attr(li1, "class", "nav-item");
      attr(ul, "class", "nav nav-tabs mt-2");
      attr(button0, "class", "btn btn-default btn-sm");
      attr(div0, "class", "tab-pane");
      attr(div0, "id", "params_tab");
      toggle_class(div0, "active", ctx[5] == ctx[14].PARAMS);
      attr(button1, "class", "btn btn-default btn-sm");
      attr(div1, "class", "tab-pane");
      attr(div1, "id", "header_tab");
      toggle_class(div1, "active", ctx[5] == ctx[14].HEADERS);
      attr(div2, "class", "tab-content bg-white bb bl br border-bootstrap-border p-3");
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, ul, anchor);
      append(ul, li0);
      append(li0, a0);
      append(ul, t2);
      append(ul, li1);
      append(li1, a1);
      append(ul, t4);
      if (if_block1)
        if_block1.m(ul, null);
      insert(target, t5, anchor);
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(div0, null);
        }
      }
      append(div0, t6);
      append(div0, button0);
      append(div2, t8);
      append(div2, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t9);
      append(div1, button1);
      append(div2, t11);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[31]),
          listen(a1, "click", ctx[32]),
          listen(button0, "click", ctx[21]),
          listen(button1, "click", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[9])
        if_block0.p(ctx2, dirty);
      if (!current || dirty[0] & 16416) {
        toggle_class(a0, "active", ctx2[5] === ctx2[14].PARAMS);
      }
      if (!current || dirty[0] & 16416) {
        toggle_class(a1, "active", ctx2[5] === ctx2[14].HEADERS);
      }
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4$n(ctx2);
          if_block1.c();
          if_block1.m(ul, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 54525968) {
        each_value_3 = ctx2[4];
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3$1(ctx2, each_value_3, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_3$1(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(div0, t6);
          }
        }
        group_outros();
        for (i2 = each_value_3.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty[0] & 16416) {
        toggle_class(div0, "active", ctx2[5] == ctx2[14].PARAMS);
      }
      if (dirty[0] & 1048584) {
        each_value_2 = ctx2[3];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$3(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, t9);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
      if (!current || dirty[0] & 16416) {
        toggle_class(div1, "active", ctx2[5] == ctx2[14].HEADERS);
      }
      if (ctx2[0]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1u(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(ul);
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div2);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function updateStores(store2, items) {
  if (store2) {
    const currentItems = {};
    items.forEach(([key, value]) => {
      currentItems[key] = value;
    });
    store2.set(currentItems);
  }
}
function instance$2U($$self, $$props, $$invalidate) {
  var _a;
  const omit_props_names = ["formModel", "configureBody"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $uri;
  let $config;
  let { formModel } = $$props;
  let { configureBody = true } = $$props;
  const { model } = formModel;
  const { uri, data: paramsStore, headers: headersStore } = formModel.fields;
  component_subscribe($$self, uri, (value) => $$invalidate(8, $uri = value));
  const config = (_a = formModel.fields.config) != null ? _a : writable({});
  component_subscribe($$self, config, (value) => $$invalidate(46, $config = value));
  const methods = ["GET", "POST", "PATCH", "PUT", "DELETE"];
  const methodMenuItems = methods.map((m) => ({ id: m, name: m }));
  const bodyTypes = ["none", "urlencoded", "json"];
  const TABS = {
    PARAMS: "params",
    HEADERS: "headers",
    BODY: "body"
  };
  let { method = "GET", body = { type: "none" }, headers } = ($config == null ? void 0 : $config.request) || {};
  let params2 = getParams();
  let currentTab = TABS.PARAMS;
  let resetParams = true;
  let jsonStr = null;
  let isBodyJSONInvalid = false;
  syncParamsHeaders();
  function onBodyTypeChange() {
    const data = body.data;
    switch (body.type) {
      case "json":
        if (data == null || !_.isObject(data) || _.isArray(data)) {
          $$invalidate(2, body.data = {}, body);
        }
        $$invalidate(6, jsonStr = JSON.stringify(body.data, null, 2));
        $$invalidate(7, isBodyJSONInvalid = false);
        break;
      case "urlencoded":
        if (!_.isArray(data)) {
          $$invalidate(2, body.data = [["", ""]], body);
        }
        break;
      default:
        $$invalidate(2, body.data = null, body);
    }
  }
  function formatJSON(e) {
    try {
      $$invalidate(6, jsonStr = JSON.stringify(JSON.parse(e.target.value), null, 2));
    } catch (e2) {
    }
  }
  function parseBodyJSON(str) {
    try {
      $$invalidate(2, body.data = JSON.parse(str), body);
      $$invalidate(7, isBodyJSONInvalid = false);
    } catch (e) {
      $$invalidate(7, isBodyJSONInvalid = true);
    }
  }
  function checkFormBody() {
    body.data || $$invalidate(2, body.data = [], body);
  }
  function addURLEncodedParam() {
    checkFormBody();
    body.data.push(["", ""]);
    $$invalidate(2, body);
  }
  function onRemoveUrlencoded(index2) {
    body.data.splice(index2, 1);
    $$invalidate(2, body);
  }
  function addHeader() {
    headers.push(["", ""]);
    $$invalidate(3, headers);
  }
  function onRemoveHeader(index2) {
    headers.splice(index2, 1);
    $$invalidate(3, headers);
  }
  function getParams() {
    const params3 = [];
    try {
      for (let [key, value] of $uri.searchParams.entries()) {
        params3.push([key, value]);
      }
    } catch (e) {
    }
    return params3;
  }
  function addNewParams() {
    $$invalidate(4, params2 = [...params2, ["", ""]]);
  }
  function onRemoveParam(index2) {
    params2.splice(index2, 1);
    $$invalidate(4, params2);
  }
  const onURLInputUpdateParams = _.debounce(
    (url) => {
      $$invalidate(4, params2 = []);
      resetParams = true;
      try {
        if (url.search) {
          for (let [key, value] of url.searchParams.entries()) {
            if (key || value)
              params2.push([key, value]);
          }
        }
      } catch (e) {
      }
    },
    200,
    false
  );
  const updateParamKey = _.debounce(
    (index2, key) => {
      $$invalidate(4, params2[index2][0] = key, params2);
    },
    200,
    false
  );
  const updateParamValue = _.debounce(
    (index2, value) => {
      $$invalidate(4, params2[index2][1] = value, params2);
    },
    200,
    false
  );
  function getParameterizedURL() {
    if (resetParams) {
      resetParams = false;
      return;
    }
    const search = new URLSearchParams(params2.filter(([key, _2]) => key)).toString();
    if (!$uri) {
      set_store_value(uri, $uri = new URL("https://example.com"), $uri);
    }
    set_store_value(uri, $uri.search = search.toString(), $uri);
    uri.set($uri);
  }
  function syncParamsHeaders() {
    if (paramsStore) {
      const currentParams = paramsStore.get();
      $$invalidate(4, params2 = Object.entries(currentParams));
    }
    if (headersStore) {
      const currentHeaders = headersStore.get();
      $$invalidate(3, headers = Object.entries(currentHeaders));
    }
  }
  function menu_id_binding(value) {
    method = value;
    $$invalidate(1, method);
  }
  function go_handler(event) {
    bubble.call(this, $$self, event);
  }
  const input_handler = () => onURLInputUpdateParams($uri);
  const click_handler = (e) => $$invalidate(5, currentTab = TABS.PARAMS);
  const click_handler_1 = (e) => $$invalidate(5, currentTab = TABS.HEADERS);
  const click_handler_2 = (e) => $$invalidate(5, currentTab = TABS.BODY);
  const func2 = (i2) => onRemoveParam(i2);
  const keyUpdate_handler = (i2, e) => updateParamKey(i2, e.detail);
  const valueUpdate_handler = (i2, e) => updateParamValue(i2, e.detail);
  const func_1 = (i2) => onRemoveHeader(i2);
  function keyvaluetable_key_binding(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[0], value)) {
      keyValue[0] = value;
      $$invalidate(3, headers);
    }
  }
  function keyvaluetable_value_binding(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[1], value)) {
      keyValue[1] = value;
      $$invalidate(3, headers);
    }
  }
  function select_change_handler() {
    body.type = select_value(this);
    $$invalidate(2, body);
    $$invalidate(13, bodyTypes);
  }
  const func_2 = (i2) => onRemoveUrlencoded(i2);
  function keyvaluetable_key_binding_1(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[0], value)) {
      keyValue[0] = value;
      $$invalidate(2, body);
    }
  }
  function keyvaluetable_value_binding_1(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[1], value)) {
      keyValue[1] = value;
      $$invalidate(2, body);
    }
  }
  const input_handler_1 = (e) => parseBodyJSON(e.target.value);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("formModel" in $$new_props)
      $$invalidate(27, formModel = $$new_props.formModel);
    if ("configureBody" in $$new_props)
      $$invalidate(0, configureBody = $$new_props.configureBody);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 14) {
      set_store_value(config, $config.request = { method, body, headers }, $config);
    }
    if ($$self.$$.dirty[0] & 4) {
      body.type && onBodyTypeChange();
    }
    if ($$self.$$.dirty[0] & 16) {
      params2 && uri && getParameterizedURL();
    }
    if ($$self.$$.dirty[0] & 16) {
      updateStores(paramsStore, params2);
    }
    if ($$self.$$.dirty[0] & 8) {
      updateStores(headersStore, headers);
    }
  };
  return [
    configureBody,
    method,
    body,
    headers,
    params2,
    currentTab,
    jsonStr,
    isBodyJSONInvalid,
    $uri,
    model,
    uri,
    config,
    methodMenuItems,
    bodyTypes,
    TABS,
    formatJSON,
    parseBodyJSON,
    addURLEncodedParam,
    onRemoveUrlencoded,
    addHeader,
    onRemoveHeader,
    addNewParams,
    onRemoveParam,
    onURLInputUpdateParams,
    updateParamKey,
    updateParamValue,
    $$restProps,
    formModel,
    menu_id_binding,
    go_handler,
    input_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    func2,
    keyUpdate_handler,
    valueUpdate_handler,
    func_1,
    keyvaluetable_key_binding,
    keyvaluetable_value_binding,
    select_change_handler,
    func_2,
    keyvaluetable_key_binding_1,
    keyvaluetable_value_binding_1,
    input_handler_1
  ];
}
class RequestEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2U, create_fragment$2Y, safe_not_equal, { formModel: 27, configureBody: 0 }, null, [-1, -1, -1]);
  }
}
function create_catch_block$k(ctx) {
  let p;
  let t0;
  let t1_value = ctx[25] + "";
  let t1;
  return {
    c() {
      p = element("p");
      t0 = text("Retry ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[25] + ""))
        set_data(t1, t1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_then_block$k(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[4] && create_if_block$1t(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1t(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$1t(ctx) {
  let div1;
  let div0;
  let ul;
  let li0;
  let a;
  let t1;
  let li1;
  let label;
  let input;
  let t2;
  let t3;
  let tree;
  let t4;
  let t5;
  let div2;
  let button;
  let t6;
  let button_disabled_value;
  let t7;
  let current;
  let mounted;
  let dispose;
  tree = new Tree({
    props: {
      obj: prepareSchema(jsonParser(ctx[4])),
      stores: ctx[8]
    }
  });
  let if_block0 = ctx[3] && create_if_block_2$I(ctx);
  let if_block1 = !ctx[2] && create_if_block_1$$();
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      ul = element("ul");
      li0 = element("li");
      a = element("a");
      a.textContent = `${T("a_select_properties")}`;
      t1 = space();
      li1 = element("li");
      label = element("label");
      input = element("input");
      t2 = text("\n              Preview JSON");
      t3 = space();
      create_component(tree.$$.fragment);
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div2 = element("div");
      button = element("button");
      t6 = text("Save");
      t7 = space();
      if (if_block1)
        if_block1.c();
      attr(a, "class", "nav-link active");
      attr(a, "href", "#default");
      attr(a, "data-toggle", "tab");
      attr(input, "type", "checkbox");
      attr(label, "class", "nav-link");
      attr(li1, "class", "nav-item pull-right");
      attr(ul, "class", "nav nav-tabs");
      attr(div0, "class", "flex flex-col flex-1");
      attr(div1, "class", "flex flex-row mt-4");
      attr(button, "class", "btn btn-primary");
      button.disabled = button_disabled_value = !ctx[2];
      attr(div2, "class", "mt1");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, ul);
      append(ul, li0);
      append(li0, a);
      append(ul, t1);
      append(ul, li1);
      append(li1, label);
      append(label, input);
      input.checked = ctx[3];
      append(label, t2);
      append(div0, t3);
      mount_component(tree, div0, null);
      append(div1, t4);
      if (if_block0)
        if_block0.m(div1, null);
      insert(target, t5, anchor);
      insert(target, div2, anchor);
      append(div2, button);
      append(button, t6);
      append(div2, t7);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[13]),
          listen(button, "click", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8) {
        input.checked = ctx2[3];
      }
      const tree_changes = {};
      if (dirty & 16)
        tree_changes.obj = prepareSchema(jsonParser(ctx2[4]));
      tree.$set(tree_changes);
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$I(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & 4 && button_disabled_value !== (button_disabled_value = !ctx2[2])) {
        button.disabled = button_disabled_value;
      }
      if (!ctx2[2]) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_1$$();
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tree.$$.fragment, local);
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(tree.$$.fragment, local);
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(tree);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div2);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$I(ctx) {
  let div;
  let distilledjsontext;
  let current;
  distilledjsontext = new DistilledJSONText({
    props: {
      output: ctx[4],
      preview: "distilled",
      previewJsonStore: ctx[8].previewJson
    }
  });
  return {
    c() {
      div = element("div");
      create_component(distilledjsontext.$$.fragment);
      attr(div, "class", "flex-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(distilledjsontext, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const distilledjsontext_changes = {};
      if (dirty & 16)
        distilledjsontext_changes.output = ctx2[4];
      distilledjsontext.$set(distilledjsontext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(distilledjsontext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(distilledjsontext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(distilledjsontext);
    }
  };
}
function create_if_block_1$$(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Invalid api/json";
      attr(p, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_pending_block$k(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$2X(ctx) {
  let requesteditor;
  let t;
  let await_block_anchor;
  let promise;
  let current;
  requesteditor = new RequestEditor({
    props: {
      formModel: ctx[0],
      placeholder: "Enter URL to monitor json"
    }
  });
  requesteditor.$on("go", ctx[11]);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$k,
    then: create_then_block$k,
    catch: create_catch_block$k,
    value: 24,
    error: 25,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[1], info);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
      t = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      insert(target, t, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx[0];
      requesteditor.$set(requesteditor_changes);
      info.ctx = ctx;
      if (dirty & 2 && promise !== (promise = ctx[1]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$2T($$self, $$props, $$invalidate) {
  let $config;
  let $uri;
  let $model;
  let $includedJson;
  let $originalJson;
  let { formModel } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(16, $model = value));
  const { uri, config } = formModel.fields;
  component_subscribe($$self, uri, (value) => $$invalidate(15, $uri = value));
  component_subscribe($$self, config, (value) => $$invalidate(14, $config = value));
  const dispatch = createEventDispatcher();
  const datasource_id = $model.datasource_id;
  const stores = initStores($config.filters.included);
  const { includedJson, originalJson } = stores;
  component_subscribe($$self, includedJson, (value) => $$invalidate(17, $includedJson = value));
  component_subscribe($$self, originalJson, (value) => $$invalidate(4, $originalJson = value));
  let outputPromise;
  let savable = false;
  let expanded = true;
  if ($uri) {
    fetchData();
  }
  async function fetchDatasource() {
    try {
      $$invalidate(2, savable = false);
      const data = await Api.utils(`/datasources/${datasource_id}/fetch`, "POST", getSieve(true));
      $$invalidate(2, savable = true);
      originalJson.set(data);
    } catch (e) {
      console.error(e);
      if (e.error) {
        e = e.error;
      }
      const error = {
        status: 0,
        message: "error while fetching the data from the datasource",
        body: {
          code: e.code,
          message: e.message || "Fetch failed",
          details: e.details
        }
      };
      originalJson.set(error);
    }
  }
  function fetchData() {
    $$invalidate(1, outputPromise = fetchDatasource());
  }
  function getSieve(skipFilters = false) {
    return {
      name: $uri.host,
      uri: uri.toJSON(),
      config: getConfig(skipFilters)
    };
  }
  function getConfig(skipFilters = false) {
    return {
      request: JSON.parse(config.toJSON()).request,
      filters: skipFilters ? void 0 : getFilters()
    };
  }
  function getFilters() {
    return { included: $includedJson };
  }
  function save() {
    set_store_value(model, $model.name = $uri.host, $model);
    set_store_value(config, $config = getConfig(), $config);
    dispatch("save");
  }
  function input_change_handler() {
    expanded = this.checked;
    $$invalidate(3, expanded);
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
  };
  return [
    formModel,
    outputPromise,
    savable,
    expanded,
    $originalJson,
    model,
    uri,
    config,
    stores,
    includedJson,
    originalJson,
    fetchData,
    save,
    input_change_handler
  ];
}
class Json extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2T, create_fragment$2X, safe_not_equal, { formModel: 0 });
  }
}
function get_each_context$M(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_each_block$M(ctx) {
  var _a;
  let div2;
  let h4;
  let a;
  let t0_value = ctx[6].title + "";
  let t0;
  let a_href_value;
  let t1;
  let div0;
  let t2_value = moment(ctx[6].pubdate || ctx[6].date || ctx[6].published || "").format("LLL") + "";
  let t2;
  let t3;
  let div1;
  let raw_value = (((_a = ctx[6].description) == null ? void 0 : _a.diff) || ctx[6].summary || "") + "";
  let t4;
  return {
    c() {
      div2 = element("div");
      h4 = element("h4");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div1 = element("div");
      t4 = space();
      attr(a, "class", "black-80");
      attr(a, "href", a_href_value = ctx[6].link);
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener noreferrer");
      attr(h4, "class", "mb2");
      attr(div0, "class", "mb2 black-40");
      attr(div1, "class", "summary mb2");
      attr(div2, "class", "wrapper");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h4);
      append(h4, a);
      append(a, t0);
      append(div2, t1);
      append(div2, div0);
      append(div0, t2);
      append(div2, t3);
      append(div2, div1);
      div1.innerHTML = raw_value;
      append(div2, t4);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 1 && t0_value !== (t0_value = ctx2[6].title + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && a_href_value !== (a_href_value = ctx2[6].link)) {
        attr(a, "href", a_href_value);
      }
      if (dirty & 1 && t2_value !== (t2_value = moment(ctx2[6].pubdate || ctx2[6].date || ctx2[6].published || "").format("LLL") + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && raw_value !== (raw_value = (((_a2 = ctx2[6].description) == null ? void 0 : _a2.diff) || ctx2[6].summary || "") + ""))
        div1.innerHTML = raw_value;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
function create_fragment$2W(ctx) {
  let div;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$M(get_each_context$M(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      ctx[4](div);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$M(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$M(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      ctx[4](null);
    }
  };
}
function instance$2S($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { feedItems } = $$props;
  let imgLoadCount = 0;
  let imgs = [];
  let feedEl;
  onMount(() => {
    $$invalidate(3, imgs = feedEl.querySelectorAll("img"));
    imgs.forEach((img) => ["load", "error"].forEach((evt) => img.addEventListener(evt, () => {
      $$invalidate(2, imgLoadCount++, imgLoadCount);
    })));
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      feedEl = $$value;
      $$invalidate(1, feedEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("feedItems" in $$props2)
      $$invalidate(0, feedItems = $$props2.feedItems);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      if (imgLoadCount === imgs.length) {
        dispatch("load");
      }
    }
  };
  return [feedItems, feedEl, imgLoadCount, imgs, div_binding];
}
class FeedList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2S, create_fragment$2W, safe_not_equal, { feedItems: 0 });
  }
}
function create_fragment$2V(ctx) {
  let h3;
  let a;
  let t0_value = ctx[0].title + "";
  let t0;
  let a_href_value;
  let t1;
  let div;
  let t2_value = (ctx[0].description || ctx[0].summary || "") + "";
  let t2;
  let t3;
  let feedlist;
  let current;
  feedlist = new FeedList({
    props: { feedItems: ctx[0].entries }
  });
  return {
    c() {
      h3 = element("h3");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      div = element("div");
      t2 = text(t2_value);
      t3 = space();
      create_component(feedlist.$$.fragment);
      attr(a, "href", a_href_value = ctx[0].link);
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener noreferrer");
      attr(div, "class", "pb2 mb2 bb b--black-20");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, a);
      append(a, t0);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      append(div, t2);
      insert(target, t3, anchor);
      mount_component(feedlist, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].title + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 1 && a_href_value !== (a_href_value = ctx2[0].link)) {
        attr(a, "href", a_href_value);
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = (ctx2[0].description || ctx2[0].summary || "") + ""))
        set_data(t2, t2_value);
      const feedlist_changes = {};
      if (dirty & 1)
        feedlist_changes.feedItems = ctx2[0].entries;
      feedlist.$set(feedlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(feedlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(feedlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      if (detaching)
        detach(t3);
      destroy_component(feedlist, detaching);
    }
  };
}
function instance$2R($$self, $$props, $$invalidate) {
  let { feed } = $$props;
  $$self.$$set = ($$props2) => {
    if ("feed" in $$props2)
      $$invalidate(0, feed = $$props2.feed);
  };
  return [feed];
}
class Feed extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2R, create_fragment$2V, safe_not_equal, { feed: 0 });
  }
}
function get_each_context$L(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2].href;
  child_ctx[22] = list[i2].title;
  return child_ctx;
}
function create_if_block_4$m(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
      attr(div, "class", "xmsg inline-block my-[5px] px-[5px]");
      toggle_class(div, "xerror", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
      if (dirty & 8) {
        toggle_class(div, "xerror", ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$_(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return create_if_block_2$H;
    if (ctx2[4])
      return create_if_block_3$x;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "xtbar my-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_if_block_3$x(ctx) {
  let each_1_anchor;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$L(get_each_context$L(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 516) {
        each_value = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$L(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$L(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2$H(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${T("a_select")}`;
      attr(button, "class", "btn btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[10]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$L(ctx) {
  let button;
  let t0_value = T("Load feed") + "";
  let t0;
  let t1;
  let t2_value = ctx[22] + "";
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[11](ctx[21]);
  }
  return {
    c() {
      button = element("button");
      t0 = text(t0_value);
      t1 = text(" - ");
      t2 = text(t2_value);
      attr(button, "class", "btn btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t2_value !== (t2_value = ctx[22] + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1s(ctx) {
  let feed_1;
  let current;
  feed_1 = new Feed({ props: { feed: ctx[5] } });
  return {
    c() {
      create_component(feed_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(feed_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const feed_1_changes = {};
      if (dirty & 32)
        feed_1_changes.feed = ctx2[5];
      feed_1.$set(feed_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(feed_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(feed_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(feed_1, detaching);
    }
  };
}
function create_fragment$2U(ctx) {
  let requesteditor;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  requesteditor = new RequestEditor({
    props: {
      formModel: ctx[0],
      placeholder: T("m_enter_feed_url")
    }
  });
  requesteditor.$on("go", ctx[8]);
  let if_block0 = ctx[1] && create_if_block_4$m(ctx);
  let if_block1 = (ctx[5] || ctx[4]) && create_if_block_1$_(ctx);
  let if_block2 = ctx[5] && create_if_block$1s(ctx);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx2[0];
      requesteditor.$set(requesteditor_changes);
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4$m(ctx2);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[5] || ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$_(ctx2);
          if_block1.c();
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1s(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function findFeeds(htmlDoc) {
  if (!htmlDoc) {
    throw {
      code: "NULL",
      msg: "HTML document is null"
    };
  }
  const result = htmlDoc.querySelectorAll('link[type="application/rss+xml"],link[type="application/atom+xml"]');
  return Array.from(result).map((link) => ({
    title: link.getAttribute("title"),
    href: link.getAttribute("href")
  }));
}
function instance$2Q($$self, $$props, $$invalidate) {
  let $config;
  let $model;
  let { formModel } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(13, $model = value));
  const { uri, config } = formModel.fields;
  component_subscribe($$self, config, (value) => $$invalidate(12, $config = value));
  const dispatch = createEventDispatcher();
  let msg = "";
  let feedLinks = [];
  let errorred = false;
  let showFeedLinks = false;
  let feed;
  async function fetchResource(url) {
    if (Supports.agents.local) {
      return await serviceProxy.HTTP.get({ url });
    } else {
      const response = await Api.utils(`/v1/http/get?url=${encodeURIComponent(url)}`);
      return { response, headers: Api.headers };
    }
  }
  async function loadURL() {
    resetMsg();
    $$invalidate(4, showFeedLinks = false);
    $$invalidate(5, feed = void 0);
    setMsg(T("l_loading"));
    let xhrObj;
    try {
      xhrObj = await fetchResource(uri.toJSON());
    } catch (e) {
      setError(T("e_load_source"));
      return;
    }
    let response = xhrObj.response;
    let contentType = xhrObj.headers["content-type"];
    contentType = contentType.split(";")[0];
    if (response.nodeType === Node.DOCUMENT_NODE) {
      response = response.documentElement.outerHTML;
    }
    switch (contentType) {
      case "text/html":
      case "application/xhtml+xml":
        setMsg(T("m_feed_finding"));
        const parser = new DOMParser();
        let doc = parser.parseFromString(response, contentType);
        if (!doc) {
          const htmlFragment = response.match(/<link.*\/>/gim).join("");
          doc = parser.parseFromString(htmlFragment, contentType);
        }
        try {
          $$invalidate(2, feedLinks = findFeeds(doc));
          if (feedLinks.length === 0) {
            setError(T("e_feed_in_page_na"));
          } else if (feedLinks.length === 1) {
            uri.set(feedLinks[0].href, { parse: true });
            return loadURL();
          } else {
            setMsg(T("m_feed_multi_selection"));
            $$invalidate(4, showFeedLinks = true);
          }
        } catch (e) {
        }
        break;
      case "application/xml":
      case "text/xml":
      case "application/rss+xml":
      case "application/atom+xml":
        setMsg("Parsing feed..");
        try {
          let result = await parseFeed(response, uri.toJSON());
          $$invalidate(5, feed = JSON.parse(JSON.stringify(result)));
          resetMsg();
          $$invalidate(4, showFeedLinks = false);
        } catch (e) {
          console.error(e);
          setError(`${T("m_try_later")} ${T("e_load_source")}`);
        }
        break;
      default:
        setError(SPRINTF("e_unknown_content_type", contentType));
        break;
    }
  }
  async function parseFeed(text2, url) {
    if (Supports.agents.local) {
      return await serviceProxy.Feed.fromString(text2, url);
    } else {
      return await Api.utils(`/v1/feed/json`, "POST", { text: text2 });
    }
  }
  function resetMsg() {
    $$invalidate(1, msg = "");
    $$invalidate(3, errorred = false);
  }
  function setMsg(message) {
    $$invalidate(1, msg = message);
  }
  function setError(error) {
    $$invalidate(1, msg = error);
    $$invalidate(3, errorred = true);
  }
  function showFeed(link) {
    uri.set(link, { parse: true });
    loadURL();
  }
  function save() {
    set_store_value(model, $model.name = feed.title, $model);
    set_store_value(config, $config.uri = uri.toJSON(), $config);
    uri.set(feed.link, { parse: true });
    dispatch("save");
  }
  const click_handler = (href2) => showFeed(href2);
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
  };
  return [
    formModel,
    msg,
    feedLinks,
    errorred,
    showFeedLinks,
    feed,
    model,
    config,
    loadURL,
    showFeed,
    save,
    click_handler
  ];
}
class Feed_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Q, create_fragment$2U, safe_not_equal, { formModel: 0 });
  }
}
function create_else_block$O(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "PDF monitoring is available to Flexi and Enterprise customers only. Please upgrade your account or contact support\n    for more information.";
      attr(div, "class", "alert alert-info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$1r(ctx) {
  let requesteditor;
  let current;
  requesteditor = new RequestEditor({
    props: {
      placeholder: T("m_enter_pdf_url"),
      formModel: ctx[0],
      label: ctx[1]
    }
  });
  requesteditor.$on("go", ctx[5]);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx2[0];
      if (dirty & 2)
        requesteditor_changes.label = ctx2[1];
      requesteditor.$set(requesteditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
    }
  };
}
function create_fragment$2T(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1r, create_else_block$O];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[2].constraint) == null ? void 0 : _a.flexi)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2P($$self, $$props, $$invalidate) {
  let $model;
  let $user;
  let { formModel } = $$props;
  let { label = "SAVE" } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(6, $model = value));
  const { uri } = formModel.fields;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(2, $user = value));
  const dispatch = createEventDispatcher();
  function save() {
    const name = uri.toJSON().split("/").at(-1);
    set_store_value(model, $model.name = name + (name.match(/\.pdf$/) ? "" : " pdf"), $model);
    dispatch("save");
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  return [formModel, label, $user, model, user, save];
}
class Pdf extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2P, create_fragment$2T, safe_not_equal, { formModel: 0, label: 1 });
  }
}
function create_else_block$N(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Doc monitoring is available to Flexi and Enterprise customers only. Please upgrade your account or contact support\n    for more information.";
      attr(div, "class", "alert alert-info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$1q(ctx) {
  let requesteditor;
  let current;
  requesteditor = new RequestEditor({
    props: {
      placeholder: T("m_enter_doc_url"),
      formModel: ctx[0],
      label: ctx[1]
    }
  });
  requesteditor.$on("go", ctx[5]);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx2[0];
      if (dirty & 2)
        requesteditor_changes.label = ctx2[1];
      requesteditor.$set(requesteditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
    }
  };
}
function create_fragment$2S(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1q, create_else_block$N];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[2].constraint) == null ? void 0 : _a.flexi)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2O($$self, $$props, $$invalidate) {
  let $model;
  let $user;
  let { formModel } = $$props;
  let { label = "SAVE" } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(6, $model = value));
  const { uri } = formModel.fields;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(2, $user = value));
  const dispatch = createEventDispatcher();
  function save() {
    const name = uri.toJSON().split("/").at(-1);
    set_store_value(model, $model.name = name + (name.match(/\.docx?$/) ? "" : " doc"), $model);
    dispatch("save");
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  return [formModel, label, $user, model, user, save];
}
class Doc extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2O, create_fragment$2S, safe_not_equal, { formModel: 0, label: 1 });
  }
}
function create_if_block_1$Z(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[2]);
      attr(div, "class", "xmsg inline-block my-[5px] px-[5px]");
      toggle_class(div, "xerror", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
      if (dirty & 8) {
        toggle_class(div, "xerror", ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$1p(ctx) {
  let div;
  let button;
  let t0_value = T("a_select") + "";
  let t0;
  let t1;
  let pre;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      pre = element("pre");
      t2 = text(ctx[1]);
      attr(button, "class", "btn btn-primary");
      button.disabled = ctx[3];
      attr(div, "class", "xtbar my-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t0);
      insert(target, t1, anchor);
      insert(target, pre, anchor);
      append(pre, t2);
      if (!mounted) {
        dispose = listen(button, "click", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8) {
        button.disabled = ctx2[3];
      }
      if (dirty & 2)
        set_data(t2, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(pre);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2R(ctx) {
  let requesteditor;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  requesteditor = new RequestEditor({
    props: { formModel: ctx[0] }
  });
  requesteditor.$on("go", ctx[8]);
  let if_block0 = ctx[2] && create_if_block_1$Z(ctx);
  let if_block1 = ctx[1] && create_if_block$1p(ctx);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx2[0];
      requesteditor.$set(requesteditor_changes);
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$Z(ctx2);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1p(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$2N($$self, $$props, $$invalidate) {
  let $model;
  let $config;
  let $uri;
  let { formModel } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(9, $model = value));
  const { uri, config } = formModel.fields;
  component_subscribe($$self, uri, (value) => $$invalidate(11, $uri = value));
  component_subscribe($$self, config, (value) => $$invalidate(10, $config = value));
  const dispatch = createEventDispatcher();
  let xml;
  let msg;
  let errorred = false;
  async function fetchResource() {
    const response = await Api.utils(`/datasources/${C$2.DS_ID_TEXT}/fetch`, "POST", {
      name: $uri.host,
      uri: $uri.toJSON(),
      config: { request: $config.request }
    });
    if (response.headers) {
      return response;
    }
    return { text: response, headers: Api.headers };
  }
  function onXML(str) {
    const xmlEl = new DOMParser().parseFromString(str, "text/xml");
    if (!xmlEl) {
      setError("Failed to parse XML");
    } else {
      $$invalidate(1, xml = str);
      resetMsg();
    }
  }
  function save() {
    const name = uri.toJSON().split("/").at(-1);
    set_store_value(model, $model.name = name + (name.match(/\.xml$/) ? "" : " xml"), $model);
    dispatch("save");
  }
  async function loadXML() {
    $$invalidate(1, xml = void 0);
    resetMsg();
    setMsg(T("l_loading"));
    try {
      const xhrObj = await fetchResource();
      let { text: text2 } = xhrObj;
      let contentType = xhrObj.headers["content-type"];
      if (text2.nodeType === Node.DOCUMENT_NODE) {
        text2 = text2.documentElement.outerHTML;
      }
      contentType = contentType.split(";")[0];
      switch (contentType) {
        case "application/xml":
        case "text/xml":
        case "application/rss+xml":
        case "application/atom+xml":
          setMsg("Parsing xml...");
          onXML(text2);
          break;
        default:
          setError(SPRINTF("e_unknown_content_type", contentType));
          break;
      }
    } catch (e) {
      console.error(e);
      setError(T("e_load_source"));
    }
  }
  function setMsg(message) {
    $$invalidate(2, msg = message);
  }
  function setError(err) {
    $$invalidate(2, msg = err);
    $$invalidate(3, errorred = true);
  }
  function resetMsg() {
    $$invalidate(2, msg = "");
    $$invalidate(3, errorred = false);
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
  };
  return [formModel, xml, msg, errorred, model, uri, config, save, loadXML];
}
class Xml extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2N, create_fragment$2R, safe_not_equal, { formModel: 0 });
  }
}
function get_each_context$K(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_each_block$K(ctx) {
  let a;
  let div0;
  let t0;
  let div1;
  let t1_value = ctx[5].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[3](ctx[5]);
  }
  return {
    c() {
      a = element("a");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      attr(div0, "class", "ba h-[8px]");
      attr(a, "href", "javascript:void(0)");
      attr(a, "class", "flex flex-col items-center");
      set_style(a, "width", "0");
      set_style(a, "margin-left", ctx[5].margin + "%");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, div0);
      append(a, t0);
      append(a, div1);
      append(div1, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t1_value !== (t1_value = ctx[5].label + ""))
        set_data(t1, t1_value);
      if (dirty & 1) {
        set_style(a, "margin-left", ctx[5].margin + "%");
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2Q(ctx) {
  let div;
  let div_class_value;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$K(get_each_context$K(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", div_class_value = "flex " + ctx[1] + " mx-[4px]");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 5) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$K(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$K(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2 && div_class_value !== (div_class_value = "flex " + ctx2[1] + " mx-[4px]")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2M($$self, $$props, $$invalidate) {
  let { ticks } = $$props;
  const dispatch = createEventDispatcher();
  let { class: classes2 = "" } = $$props;
  calcMargin();
  function calcMargin() {
    let lastMargin = 0;
    for (let tick2 of ticks) {
      tick2.margin = tick2.value - lastMargin;
      lastMargin = tick2.value;
    }
  }
  const click_handler = (tick2) => dispatch("click", tick2);
  $$self.$$set = ($$props2) => {
    if ("ticks" in $$props2)
      $$invalidate(0, ticks = $$props2.ticks);
    if ("class" in $$props2)
      $$invalidate(1, classes2 = $$props2.class);
  };
  return [ticks, classes2, dispatch, click_handler];
}
class TickBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2M, create_fragment$2Q, safe_not_equal, { ticks: 0, class: 1 });
  }
}
function create_fragment$2P(ctx) {
  let div;
  let input;
  let t;
  let tickbar;
  let current;
  let mounted;
  let dispose;
  tickbar = new TickBar({ props: { ticks: ctx[1] } });
  tickbar.$on("click", ctx[3]);
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      create_component(tickbar.$$.fragment);
      attr(input, "type", "range");
      attr(div, "class", "flex flex-col items-stretch w-full");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[0]);
      append(div, t);
      mount_component(tickbar, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[4]),
          listen(input, "input", ctx[4]),
          listen(input, "change", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_input_value(input, ctx2[0]);
      }
      const tickbar_changes = {};
      if (dirty & 2)
        tickbar_changes.ticks = ctx2[1];
      tickbar.$set(tickbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tickbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tickbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tickbar);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2L($$self, $$props, $$invalidate) {
  let { ticks } = $$props;
  let { value } = $$props;
  const dispatch = createEventDispatcher();
  function updateValue(e) {
    const tick2 = e.detail;
    $$invalidate(0, value = tick2.value);
    dispatch("change", value);
  }
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  const change_handler = (e) => dispatch("change", e.target.valueAsNumber);
  $$self.$$set = ($$props2) => {
    if ("ticks" in $$props2)
      $$invalidate(1, ticks = $$props2.ticks);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [
    value,
    ticks,
    dispatch,
    updateValue,
    input_change_input_handler,
    change_handler
  ];
}
class Slider extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2L, create_fragment$2P, safe_not_equal, { ticks: 1, value: 0 });
  }
}
function create_if_block$1o(ctx) {
  let span1;
  let span0;
  let t0_value = T("h_schedule_constraint_1") + "";
  let t0;
  let t1;
  let t2_value = T(formatInterval(ctx[3].constraint.interval, false)) + "";
  let t2;
  let t3;
  let br;
  let t4_value = T("h_schedule_constraint_2") + "";
  let t4;
  let t5;
  let a;
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = text(".");
      br = element("br");
      t4 = text(t4_value);
      t5 = space();
      a = element("a");
      a.textContent = "Upgrade Account";
      attr(a, "href", "https://distill.io/pricing/");
      attr(a, "target", "_blank");
      attr(span0, "class", "error");
      attr(span1, "class", "help");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, span0);
      append(span0, t0);
      append(span0, t1);
      append(span0, t2);
      append(span0, t3);
      append(span0, br);
      append(span0, t4);
      append(span0, t5);
      append(span0, a);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t2_value !== (t2_value = T(formatInterval(ctx2[3].constraint.interval, false)) + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(span1);
    }
  };
}
function create_fragment$2O(ctx) {
  let div;
  let slider;
  let updating_value;
  let t0;
  let input;
  let t1;
  let t2;
  let p;
  let current;
  let mounted;
  let dispose;
  function slider_value_binding(value) {
    ctx[15](value);
  }
  let slider_props = { class: "flex-1", ticks: ctx[6] };
  if (ctx[0] !== void 0) {
    slider_props.value = ctx[0];
  }
  slider = new Slider({ props: slider_props });
  binding_callbacks.push(() => bind$2(slider, "value", slider_value_binding));
  slider.$on("change", ctx[9]);
  let if_block = ctx[2] && create_if_block$1o(ctx);
  return {
    c() {
      div = element("div");
      create_component(slider.$$.fragment);
      t0 = space();
      input = element("input");
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      p = element("p");
      p.textContent = `${T("h_schedule_interval")}`;
      attr(input, "class", "xschdlr-input self-start");
      input.value = ctx[1];
      attr(div, "class", "flex min-w-[420px]");
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(slider, div, null);
      append(div, t0);
      append(div, input);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, p, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const slider_changes = {};
      if (!updating_value && dirty & 1) {
        updating_value = true;
        slider_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      slider.$set(slider_changes);
      if (!current || dirty & 2 && input.value !== ctx2[1]) {
        input.value = ctx2[1];
      }
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1o(ctx2);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(slider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(slider);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(p);
      mounted = false;
      dispose();
    }
  };
}
function instance$2K($$self, $$props, $$invalidate) {
  let $schedule;
  let $model;
  let $user;
  let { formModel } = $$props;
  let { minInt } = $$props;
  let { MIN = 5 } = $$props;
  let { MAX = 3600 * 24 * 30 } = $$props;
  let { schedules = [
    { value: MIN, label: "5s" },
    { value: 30, label: "30s" },
    { value: 300, label: "5m" },
    { value: 3600, label: "1h" },
    { value: 3600 * 24, label: "1d" },
    { value: MAX, label: "Never" }
  ] } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(17, $model = value));
  const { schedule } = formModel.fields;
  component_subscribe($$self, schedule, (value) => $$invalidate(16, $schedule = value));
  const ticks = schedules.map(scheduleToTick);
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(3, $user = value));
  const dispatch = createEventDispatcher();
  let sliderValue = valueToPct($schedule.params.interval);
  let inputValue = getShortDisplayText($schedule);
  let showError;
  function scheduleToTick({ value, label }) {
    return { label, value: valueToPct(value) };
  }
  function valueToPct(v) {
    if (!v) {
      return 100;
    }
    return 100 * Math.log(v / MIN) / Math.log(MAX / MIN);
  }
  function pctToValue(pct) {
    return Math.round(Math.pow(Math.E, pct / 100 * Math.log(MAX / MIN)) * MIN);
  }
  function updateValue(seconds) {
    if ($model.client_id == ModelClient.Clients.webAppId && seconds < minInt) {
      set_store_value(schedule, $schedule.params.interval = minInt, $schedule);
      $$invalidate(2, showError = true);
    } else {
      set_store_value(schedule, $schedule.params.interval = seconds, $schedule);
      $$invalidate(2, showError = false);
    }
    $$invalidate(1, inputValue = getShortDisplayText($schedule));
    $$invalidate(0, sliderValue = valueToPct($schedule.params.interval));
    dispatch("change", $schedule);
  }
  function textInputChanged(e) {
    const seconds = getInterval$1(e.target.value, "m", 3600);
    updateValue(seconds);
  }
  function sliderMoved(e) {
    const seconds = pctToValue(e.detail);
    updateValue(seconds);
  }
  function slider_value_binding(value) {
    sliderValue = value;
    $$invalidate(0, sliderValue);
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(10, formModel = $$props2.formModel);
    if ("minInt" in $$props2)
      $$invalidate(11, minInt = $$props2.minInt);
    if ("MIN" in $$props2)
      $$invalidate(12, MIN = $$props2.MIN);
    if ("MAX" in $$props2)
      $$invalidate(13, MAX = $$props2.MAX);
    if ("schedules" in $$props2)
      $$invalidate(14, schedules = $$props2.schedules);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2049) {
      updateValue(pctToValue(sliderValue));
    }
  };
  return [
    sliderValue,
    inputValue,
    showError,
    $user,
    model,
    schedule,
    ticks,
    user,
    textInputChanged,
    sliderMoved,
    formModel,
    minInt,
    MIN,
    MAX,
    schedules,
    slider_value_binding
  ];
}
class IntervalScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2K, create_fragment$2O, safe_not_equal, {
      formModel: 10,
      minInt: 11,
      MIN: 12,
      MAX: 13,
      schedules: 14
    });
  }
}
const WEEKS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
const MONTHS = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
class Unit {
  constructor(options) {
    this.min = 0;
    this.SYMBOL_INDEX = {};
    Object.assign(this, options);
  }
  possilbeValues() {
    let possilbeValuesList = [];
    for (let i2 = 0; i2 <= 59; i2++) {
      possilbeValuesList.push(i2);
    }
    return possilbeValuesList;
  }
  symbolToIndex(symbol) {
    let index2 = this.SYMBOL_INDEX[symbol];
    if (index2 == null) {
      throw new Error(`Invalid symbol ${symbol} for ${this.type}`);
    }
    return index2;
  }
  getName(index2) {
    if (index2 < this.min || index2 > this.max) {
      throw new Error(`${index2} out of range for ${this.type}, it should be in [${this.min}-${this.max}]`);
    }
    return this.indexToName(index2);
  }
  indexToName(index2) {
    return index2 + "";
  }
}
const YEAR = new Unit({
  type: "year",
  min: 1970,
  max: 2099
});
const MINUTE = new Unit({
  type: "minute",
  max: 59,
  prefix: "At"
});
const HOUR = new Unit({
  type: "hour",
  max: 23,
  prefix: "past"
});
const DO_MONTH = new Unit({
  type: "day-of-month",
  min: 1,
  max: 31,
  prefix: "on"
});
const MONTH = new Unit({
  type: "month",
  min: 1,
  max: 12,
  SYMBOL_INDEX: {
    "JAN": 1,
    "FEB": 2,
    "MAR": 3,
    "APR": 4,
    "MAY": 5,
    "JUN": 6,
    "JUL": 7,
    "AUG": 8,
    "SEP": 9,
    "OCT": 10,
    "NOV": 11,
    "DEC": 12
  },
  prefix: "in",
  indexToName(index2) {
    return MONTHS[index2];
  }
});
const DO_WEEK = new Unit({
  type: "day-of-week",
  max: 6,
  SYMBOL_INDEX: {
    "SUN": 0,
    "MON": 1,
    "TUE": 2,
    "WED": 3,
    "THU": 4,
    "FRI": 5,
    "SAT": 6
  },
  prefix: "on",
  indexToName(index2) {
    return WEEKS[index2];
  }
});
class Value {
  constructor(unit, expr) {
    this.step = 1;
    this.expr = expr;
    this.unit = unit;
    if (expr.includes("/")) {
      let parts = expr.split("/");
      if (parts.length != 2) {
        throw new Error(`Unexpected number of steps for ${this.unit.type}`);
      }
      let range = parts[0];
      let step = parts[1];
      this.step = parseIntAndValidate(step, `Unexpected step format for ${this.unit.type}`);
      this.parseRange(range);
    } else {
      this.parseRange(expr);
    }
  }
  getTicks() {
    let listOfElements = [];
    for (let i2 = this.unit.min; i2 <= this.unit.max; i2 = i2 + this.step) {
      listOfElements.push(i2);
    }
    return listOfElements;
  }
  getDescription() {
    return `every ${this.unit.type}`;
  }
}
class Star extends Value {
  constructor(unit, expr) {
    super(unit, expr);
  }
  next(current) {
    return next(current, this.unit.min, this.step, this.unit.max);
  }
  getTicks() {
    let listOfElements = [];
    for (let i2 = this.unit.min; i2 <= this.unit.max; i2 = i2 + this.step) {
      listOfElements.push(i2);
    }
    return listOfElements;
  }
  getDescription() {
    let ordinal = this.step > 1 ? `${this.step}${getOrdinal(this.step)} ` : "";
    return `every ${ordinal}${this.unit.type}`;
  }
  parseRange(expr) {
    if (expr != "*") {
      throw new Error(`Unexpected format of Any value for ${this.unit.type}`);
    }
  }
}
class Range extends Value {
  constructor(unit, expr) {
    super(unit, expr);
  }
  next(current) {
    return next(current, this.start, this.step, this.end);
  }
  getTicks() {
    let listOfElements = [];
    for (let i2 = this.start; i2 <= this.end; i2 = i2 + this.step) {
      listOfElements.push(i2);
    }
    return listOfElements;
  }
  getDescription() {
    let ordinal = this.step > 1 ? `${this.step}${getOrdinal(this.step)} ` : "";
    return `every ${ordinal}${this.unit.type} from ${this.unit.getName(this.start)} through ${this.unit.getName(this.end)}`;
  }
  parseRange(expr) {
    let range = expr.split("-");
    if (range.length == 2) {
      this.start = parseIntAndValidate(range[0], `Unexpected format of start value of range for ${this.unit.type}`);
      this.end = parseIntAndValidate(range[1], `Unexpected format of end value of range for ${this.unit.type}`);
      if (this.start < this.unit.min || this.start > this.unit.max) {
        throw new Error(`Start value of range for ${this.unit.type} out of range: Correct Range: [${this.unit.min} - ${this.unit.max}]`);
      } else if (this.end < this.unit.min || this.end > this.unit.max) {
        throw new Error(`End value of range for ${this.unit.type} out of range: Correct Range: [${this.unit.min} - ${this.unit.max}]`);
      } else if (this.start > this.end) {
        throw new Error(`Start value should be less or equal to End for ${this.unit.type}`);
      }
    } else {
      throw new Error(`Unexpected numbers of range values ${this.unit.type}`);
    }
  }
}
class Single extends Value {
  constructor(unit, expr) {
    super(unit, expr);
  }
  next(current) {
    if (this.step == 1) {
      return [this.value, current > this.value];
    }
    return next(current, this.value, this.step, this.unit.max);
  }
  getTicks() {
    let listOfElements = [];
    if (this.step == 1) {
      listOfElements.push(this.value);
    } else {
      for (let i2 = this.value; i2 <= this.unit.max; i2 = i2 + this.step) {
        listOfElements.push(i2);
      }
    }
    return listOfElements;
  }
  getDescription() {
    let start = this.unit.getName(this.value);
    if (this.step == 1) {
      return `${start}`;
    } else {
      let ordinal = `${this.step}${getOrdinal(this.step)} `;
      return `every ${ordinal}${this.unit.type} from ${start} through ${this.unit.getName(this.unit.max)}`;
    }
  }
  parseRange(expr) {
    let numVal = parseInt(expr);
    if (!isNaN(numVal)) {
      this.value = numVal;
    } else {
      let symbolValue = this.unit.SYMBOL_INDEX[expr.toUpperCase()];
      if (symbolValue == null) {
        throw new Error(`Unexpected value for ${this.unit.type}`);
      } else {
        this.value = symbolValue;
      }
    }
    if (this.value < this.unit.min || this.value > this.unit.max) {
      throw new Error(`Value for ${this.unit.type} out of range: Correct Range: [${this.unit.min} - ${this.unit.max}]`);
    }
  }
}
function getOrdinal(step) {
  switch (step) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
    default:
      return "th";
  }
}
function next(current, start, step, max) {
  if (current < start) {
    return [start, false];
  }
  if (current > max) {
    return [start, true];
  }
  current -= start;
  let mod = current % step;
  let next2 = start + current + (mod == 0 ? 0 : step - mod);
  let overflow = next2 > max;
  return [overflow ? start : next2, overflow];
}
function parseIntAndValidate(number, err) {
  let num = parseInt(number);
  if (isNaN(num)) {
    throw new Error(err);
  } else {
    return num;
  }
}
const INDEX_TO_UNIT = {
  0: MINUTE,
  1: HOUR,
  2: DO_MONTH,
  3: MONTH,
  4: DO_WEEK
};
class Cron {
  constructor(str) {
    this.components = {
      minute: [],
      hour: [],
      dom: [],
      month: [],
      dow: []
    };
    this.starDOM = false;
    this.starDOW = false;
    str = str.trim();
    this.expr = str;
    this.parse();
  }
  _next(year, month, dom, hour, minute) {
    let [oYear, nYear] = nextForUnitValues(this.yearComponents, year);
    if (oYear) {
      throw new Error("Unexpected Error");
    }
    if (year != nYear) {
      return this._next(nYear, 0, 1, 0, 0);
    }
    let [oMonth, nMonth] = nextForUnitValues(this.components.month, month + 1);
    nMonth--;
    if (month != nMonth) {
      return this._next(nYear + (oMonth ? 1 : 0), oMonth ? 0 : nMonth, 1, 0, 0);
    }
    let [oDOMon, nDOMon] = nextForUnitValues(this.components.dom, dom);
    if (this.starDOW || this.starDOM) {
      if (dom != nDOMon) {
        return this._next(nYear, nMonth + (oDOMon ? 1 : 0), oDOMon ? 0 : nDOMon, 0, 0);
      }
      let dayOfWeek = new Date(nYear, nMonth, nDOMon, 0, 0).getDay();
      let [oDOW, nDOW] = nextForUnitValues(this.components.dow, dayOfWeek);
      if (nDOW != dayOfWeek) {
        return this._next(nYear, nMonth, nDOMon + 1, 0, 0);
      }
    } else {
      let dayOfWeek = new Date(year, month, dom, 0, 0).getDay();
      let [oDOW, nDOW] = nextForUnitValues(this.components.dow, dayOfWeek);
      if (nDOMon != dom && dayOfWeek != nDOW) {
        let nextDate = new Date(nYear, nMonth, dom + 1);
        return this._next(nextDate.getFullYear(), nextDate.getMonth(), nextDate.getDate(), 0, 0);
      }
      nDOMon = dayOfWeek == nDOW ? dom : nDOMon;
    }
    let [oHour, nHour] = nextForUnitValues(this.components.hour, hour);
    if (hour != nHour) {
      return this._next(nYear, nMonth, nDOMon + (oHour ? 1 : 0), oHour ? 0 : nHour, 0);
    }
    let [oMinute, nMinute] = nextForUnitValues(this.components.minute, minute);
    if (minute != nMinute) {
      return this._next(nYear, nMonth, nDOMon, nHour + (oMinute ? 1 : 0), oMinute ? 0 : nMinute);
    }
    return [nYear, nMonth, nDOMon, nHour, nMinute];
  }
  next(last = new Date(), offSetMin = new Date().getTimezoneOffset()) {
    let serverOffSet = new Date().getTimezoneOffset();
    let offSetDelta = (offSetMin - serverOffSet) * 60 * 1e3;
    last = new Date(last.valueOf() - offSetDelta);
    let year = last.getFullYear();
    let month = last.getMonth();
    let dom = last.getDate();
    let hour = last.getHours();
    let minute = last.getMinutes();
    this.yearComponents = [new Range(YEAR, `${year}-${year + 1}`)];
    let nextValues = this._next(year, month, dom, hour, minute + 1);
    let nextDate = new Date(...nextValues);
    return new Date(nextDate.valueOf() + offSetDelta);
  }
  parse() {
    this.parts = this.expr.split(/\s+/g);
    if (this.parts.length != 5) {
      throw new Error(`Unexpected number of arguments in cron expression`);
    }
    let components = [];
    for (let i2 = 0; i2 < this.parts.length; i2++) {
      let component = [];
      let componentList = this.parts[i2].split(",");
      for (let j = 0; j < componentList.length; j++) {
        let element2 = componentList[j];
        let range = element2.split("/")[0];
        if (range.includes("-")) {
          component.push(new Range(INDEX_TO_UNIT[i2], element2));
        } else if (range == "*") {
          component.push(new Star(INDEX_TO_UNIT[i2], element2));
          this.starDOM = i2 == 2 ? true : this.starDOM;
          this.starDOW = i2 == 4 ? true : this.starDOW;
        } else {
          component.push(new Single(INDEX_TO_UNIT[i2], element2));
        }
      }
      components.push(component);
    }
    let _i = 0;
    for (let key in this.components) {
      this.components[key] = components[_i++];
    }
  }
  getDescription() {
    let description = "";
    let descriptionArr = [];
    let _i = 0;
    for (let i2 in this.components) {
      let component = this.components[i2];
      let componentDescription = "";
      let componentDescriptionArr = [];
      for (let j = 0; j < component.length; j++) {
        if (component[j].constructor.name == "Star" && i2 != "minute" && !component[j].expr.includes("/") && component.length == 1) {
          componentDescriptionArr.push("");
        } else {
          componentDescriptionArr.push(component[j].getDescription());
        }
      }
      if (componentDescriptionArr.length > 1) {
        let last = componentDescriptionArr.pop();
        componentDescription = `${componentDescriptionArr.join(", ")} and ${last}`;
      } else {
        componentDescription = componentDescriptionArr[0];
      }
      if (componentDescription) {
        descriptionArr.push(INDEX_TO_UNIT[_i].prefix);
        descriptionArr.push(componentDescription);
      }
      _i++;
    }
    description = descriptionArr.join(" ") + ".";
    return description;
  }
  getList() {
    let componentObj = {
      minute: [],
      hour: [],
      dom: [],
      month: [],
      dow: []
    };
    let components = [];
    for (let i2 in this.components) {
      let component = this.components[i2];
      let componentSet = /* @__PURE__ */ new Set();
      for (let j = 0; j < component.length; j++) {
        let ticks = component[j].getTicks();
        for (let k = 0; k < ticks.length; k++) {
          componentSet.add(ticks[k]);
        }
      }
      let componentList = Array.from(componentSet).sort(function(a, b) {
        return a - b;
      });
      components.push(componentList);
    }
    let _i = 0;
    for (let key in componentObj) {
      componentObj[key] = components[_i++];
    }
    return componentObj;
  }
}
function nextForUnitValues(unitValues, current) {
  let minNext = Infinity, minStartOnOverflow = Infinity;
  for (let i2 = 0; i2 < unitValues.length; i2++) {
    let unitValue = unitValues[i2];
    let [next2, overflow] = unitValue.next(current);
    if (overflow) {
      minStartOnOverflow = Math.min(minStartOnOverflow, next2);
    } else {
      minNext = Math.min(minNext, next2);
    }
  }
  let overflowed = minNext == Infinity;
  return [overflowed, overflowed ? minStartOnOverflow : minNext];
}
function parse(str) {
  let cron = new Cron(str);
  return cron;
}
function get_each_context$J(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2].expr;
  child_ctx[17] = list[i2].name;
  return child_ctx;
}
function get_each_context_1$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2][0];
  child_ctx[21] = list[i2][1];
  return child_ctx;
}
function create_each_block_1$6(ctx) {
  let div;
  let b;
  let t0_value = ctx[4][ctx[20]] + "";
  let t0;
  let t1;
  let input;
  let input_value_value;
  let input_placeholder_value;
  let mounted;
  let dispose;
  function keyup_handler(...args) {
    return ctx[9](ctx[20], ...args);
  }
  return {
    c() {
      div = element("div");
      b = element("b");
      t0 = text(t0_value);
      t1 = space();
      input = element("input");
      attr(input, "class", "w-[60px] px-[10px]");
      input.value = input_value_value = ctx[21];
      attr(input, "placeholder", input_placeholder_value = ctx[4][ctx[20]]);
      attr(div, "class", "flex flex-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, b);
      append(b, t0);
      append(div, t1);
      append(div, input);
      if (!mounted) {
        dispose = listen(input, "keyup", keyup_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = ctx[4][ctx[20]] + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && input_value_value !== (input_value_value = ctx[21]) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (dirty & 2 && input_placeholder_value !== (input_placeholder_value = ctx[4][ctx[20]])) {
        attr(input, "placeholder", input_placeholder_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$J(ctx) {
  let li;
  let a;
  let t0_value = ctx[17] + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[10](ctx[16]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", "dropdown-item");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$p(ctx) {
  let each_1_anchor;
  let each_value = ctx[5];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$J(get_each_context$J(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 160) {
        each_value = ctx2[5];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$J(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$J(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot$16(ctx) {
  let div2;
  let div0;
  let t0;
  let menu;
  let t1;
  let div1;
  let t2;
  let current;
  let each_value_1 = Object.entries(ctx[1]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i2));
  }
  menu = new Menu$1({
    props: {
      items: ctx[5],
      class: "self-center",
      defaultActionLabel: "Use Preset",
      $$slots: { default: [create_default_slot_1$p] },
      $$scope: { ctx }
    }
  });
  menu.$on("select", ctx[7]);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      create_component(menu.$$.fragment);
      t1 = space();
      div1 = element("div");
      t2 = text(ctx[0]);
      attr(div0, "class", "flex gap-6 mx-[4px]");
      attr(div1, "class", "help whitespace-normal");
      attr(div2, "class", "flex flex-col");
      toggle_class(div2, "is-invalid", ctx[15]);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div0, t0);
      mount_component(menu, div0, null);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 82) {
        each_value_1 = Object.entries(ctx2[1]);
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$6(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$6(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, t0);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      const menu_changes = {};
      if (dirty & 16777216) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (!current || dirty & 1)
        set_data(t2, ctx2[0]);
      if (!current || dirty & 32768) {
        toggle_class(div2, "is-invalid", ctx2[15]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      destroy_component(menu);
    }
  };
}
function create_fragment$2N(ctx) {
  let fieldwrapper;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[2],
      $$slots: {
        default: [
          create_default_slot$16,
          ({ showError }) => ({ 15: showError }),
          ({ showError }) => showError ? 32768 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 16809987) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
    }
  };
}
const DEFAULT_CRON = "0 3 * * *";
function instance$2J($$self, $$props, $$invalidate) {
  let $schedule;
  let $error;
  let { formModel } = $$props;
  const { schedule } = formModel.fields;
  component_subscribe($$self, schedule, (value) => $$invalidate(11, $schedule = value));
  const { error } = schedule;
  component_subscribe($$self, error, (value) => $$invalidate(12, $error = value));
  const names = {
    m: "Minute",
    h: "Hour",
    dm: "Day",
    mon: "Month",
    dw: "Weekday"
  };
  const presets = [
    {
      expr: "0 9 * * 1-5",
      name: "Weekdays at 9am"
    },
    {
      expr: "0 9-17 * * 1-5",
      name: "Weekdays between 9am to 5pm"
    },
    {
      expr: "0 9 * * *",
      name: "All days at 9am"
    },
    {
      expr: "0 9-17 * * *",
      name: "All days between 9am to 5pm"
    }
  ];
  const dispatch = createEventDispatcher();
  schedule.setTouched(true);
  let desc, attrMap;
  destructureExpr();
  function destructureExpr() {
    const split = $schedule.params.expr.split(/\s/g);
    $$invalidate(1, attrMap = ["m", "h", "dm", "mon", "dw"].reduce(
      (acc, value, index2) => {
        acc[value] = split[index2];
        return acc;
      },
      {}
    ));
    $$invalidate(0, desc = parse($schedule.params.expr).getDescription());
  }
  function onChange(name, value) {
    const index2 = ["m", "h", "dm", "mon", "dw"].indexOf(name);
    const params2 = { ...$schedule.params };
    const { expr } = params2;
    const parts = expr.split(/\s/g);
    parts[index2] = value;
    params2.expr = parts.join(" ");
    try {
      $$invalidate(0, desc = parse(params2.expr).getDescription());
      set_store_value(schedule, $schedule.params = params2, $schedule);
      dispatch("change", $schedule);
    } catch (e) {
      set_store_value(error, $error = e, $error);
      $$invalidate(0, desc = "");
      console.error("cannot parse the expression ", params2.expr, e);
    }
  }
  function onPresetClick(preset) {
    set_store_value(schedule, $schedule.params.expr = preset != null ? preset : DEFAULT_CRON, $schedule);
    dispatch("change", $schedule);
    destructureExpr();
  }
  const keyup_handler = (key, e) => onChange(key, e.target.value);
  const click_handler = (expr) => onPresetClick(expr);
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(8, formModel = $$props2.formModel);
  };
  return [
    desc,
    attrMap,
    schedule,
    error,
    names,
    presets,
    onChange,
    onPresetClick,
    formModel,
    keyup_handler,
    click_handler
  ];
}
class CronScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2J, create_fragment$2N, safe_not_equal, { formModel: 8 });
  }
}
function create_if_block$1n(ctx) {
  let div;
  let t0_value = T("h_schedule_constraint_1") + "";
  let t0;
  let t1;
  let b;
  let t2_value = T(ctx[3].constraint.interval + " seconds. ") + "";
  let t2;
  let t3;
  let br;
  let t4;
  let t5_value = T("h_schedule_constraint_2") + "";
  let t5;
  let a;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      b = element("b");
      t2 = text(t2_value);
      t3 = space();
      br = element("br");
      t4 = space();
      t5 = text(t5_value);
      a = element("a");
      a.textContent = "Upgrade Account";
      attr(a, "href", "https://distill.io/pricing/");
      attr(a, "target", "_blank");
      attr(div, "class", "mt-2");
      set_style(div, "color", "black");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, b);
      append(b, t2);
      append(div, t3);
      append(div, br);
      append(div, t4);
      append(div, t5);
      append(div, a);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t2_value !== (t2_value = T(ctx2[3].constraint.interval + " seconds. ") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$2M(ctx) {
  let div2;
  let div0;
  let span0;
  let t1;
  let input0;
  let t2;
  let div1;
  let span1;
  let t4;
  let input1;
  let t5;
  let t6;
  let p;
  let mounted;
  let dispose;
  let if_block = ctx[2].client_id === ModelClient.Clients.webAppId && create_if_block$1n(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "Min :";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      span1 = element("span");
      span1.textContent = "Max :";
      t4 = space();
      input1 = element("input");
      t5 = space();
      if (if_block)
        if_block.c();
      t6 = space();
      p = element("p");
      p.textContent = `${T("h_schedule_random")}`;
      attr(input0, "type", "number");
      attr(input0, "class", "xschdlr-input");
      attr(input1, "type", "number");
      attr(input1, "class", "xschdlr-input");
      attr(div2, "class", "flex gap-8");
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(input0, ctx[0]);
      append(div2, t2);
      append(div2, div1);
      append(div1, span1);
      append(div1, t4);
      append(div1, input1);
      set_input_value(input1, ctx[1]);
      insert(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t6, anchor);
      insert(target, p, anchor);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[10]),
          listen(input0, "change", ctx[7]),
          listen(input1, "input", ctx[11]),
          listen(input1, "change", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && to_number(input0.value) !== ctx2[0]) {
        set_input_value(input0, ctx2[0]);
      }
      if (dirty & 2 && to_number(input1.value) !== ctx2[1]) {
        set_input_value(input1, ctx2[1]);
      }
      if (ctx2[2].client_id === ModelClient.Clients.webAppId) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1n(ctx2);
          if_block.c();
          if_block.m(t6.parentNode, t6);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t5);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(p);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2I($$self, $$props, $$invalidate) {
  let $schedule;
  let $model;
  let $user;
  let { formModel } = $$props;
  let { minInt } = $$props;
  const { schedule } = formModel.fields;
  component_subscribe($$self, schedule, (value) => $$invalidate(12, $schedule = value));
  const model = formModel.model;
  component_subscribe($$self, model, (value) => $$invalidate(2, $model = value));
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(3, $user = value));
  const dispatch = createEventDispatcher();
  let { min, max } = $schedule.params;
  function updateValue() {
    let maxSecs = getInterval$1(max, "s");
    let minSecs = Math.max(minInt, getInterval$1(min, "s"));
    if (minSecs > maxSecs) {
      maxSecs = Math.max(minInt, minSecs + 1);
    } else {
      maxSecs = Math.max(minInt, maxSecs);
    }
    set_store_value(schedule, $schedule.params = { min: minSecs, max: maxSecs }, $schedule);
    $$invalidate(0, min = minSecs);
    $$invalidate(1, max = maxSecs);
    dispatch("change", $schedule);
  }
  function input0_input_handler() {
    min = to_number(this.value);
    $$invalidate(0, min);
  }
  function input1_input_handler() {
    max = to_number(this.value);
    $$invalidate(1, max);
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(8, formModel = $$props2.formModel);
    if ("minInt" in $$props2)
      $$invalidate(9, minInt = $$props2.minInt);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      updateValue();
    }
  };
  return [
    min,
    max,
    $model,
    $user,
    schedule,
    model,
    user,
    updateValue,
    formModel,
    minInt,
    input0_input_handler,
    input1_input_handler
  ];
}
class RandomScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2I, create_fragment$2M, safe_not_equal, { formModel: 8, minInt: 9 });
  }
}
function create_fragment$2L(ctx) {
  let div0;
  let t1;
  let div1;
  return {
    c() {
      div0 = element("div");
      div0.textContent = "Use it only if page auto-updates content using JavaScript.";
      t1 = space();
      div1 = element("div");
      div1.textContent = `${T("l_schedule_live_desc")}`;
      attr(div1, "class", "help");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
    }
  };
}
class LiveScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$2L, safe_not_equal, {});
  }
}
function create_fragment$2K(ctx) {
  let div2;
  let div0;
  let menu;
  let t;
  let div1;
  let switch_instance;
  let current;
  menu = new Menu$1({
    props: {
      id: ctx[3],
      items: ctx[10](),
      allowNull: false,
      actionClass: "btn btn-default",
      dropDownClass: "dropdown-menu-start"
    }
  });
  menu.$on("select", ctx[8]);
  const switch_instance_spread_levels = [
    { formModel: ctx[0] },
    { minInt: ctx[2] },
    ctx[11]
  ];
  var switch_value = ctx[1][ctx[3]].component;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
    switch_instance.$on("change", ctx[9]);
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(menu.$$.fragment);
      t = space();
      div1 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div0, "class", "flex items-start mr-6");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "flex");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(menu, div0, null);
      append(div2, t);
      append(div2, div1);
      if (switch_instance)
        mount_component(switch_instance, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 8)
        menu_changes.id = ctx2[3];
      menu.$set(menu_changes);
      const switch_instance_changes = dirty & 2053 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 1 && { formModel: ctx2[0] },
        dirty & 4 && { minInt: ctx2[2] },
        dirty & 2048 && get_spread_object(ctx2[11])
      ]) : {};
      if (dirty & 10 && switch_value !== (switch_value = ctx2[1][ctx2[3]].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          switch_instance.$on("change", ctx2[9]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div1, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(menu);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function instance$2H($$self, $$props, $$invalidate) {
  const omit_props_names = ["formModel", "autoSync", "editors"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $showError;
  let $schedule;
  let $user;
  let $model;
  let { formModel } = $$props;
  let { autoSync = false } = $$props;
  const { schedule } = formModel.fields;
  component_subscribe($$self, schedule, (value) => $$invalidate(15, $schedule = value));
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(13, $model = value));
  const { showError } = schedule;
  component_subscribe($$self, showError, (value) => $$invalidate(14, $showError = value));
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(16, $user = value));
  const debouncedScheduleChange = _.debounce(onScheduleChange, 300);
  let minInt = getMinInt();
  let selectedEditor = $schedule.type || "INTERVAL";
  let { editors = {
    INTERVAL: {
      name: "Interval",
      component: IntervalScheduleEditor,
      default: {
        type: "INTERVAL",
        params: { interval: 10800 }
      }
    },
    RANDOM: {
      name: "Random",
      component: RandomScheduleEditor,
      default: {
        type: "RANDOM",
        params: { min: minInt, max: minInt + 60 }
      }
    },
    LIVE: {
      name: "Live (beta)",
      component: LiveScheduleEditor,
      default: { type: "LIVE" }
    },
    CRON: {
      name: "Crontab *",
      disabled: !$user.account_id,
      component: CronScheduleEditor,
      default: {
        type: "CRON",
        params: {
          expr: "0 3 * * *",
          tz: new Date().getTimezoneOffset()
        }
      }
    },
    enterprise: { name: "* For Enterprise", disabled: true }
  } } = $$props;
  function getMinInt() {
    return $model.client_id === ModelClient.Clients.webAppId ? $user.constraint.interval : 5;
  }
  function onTypeChange(e) {
    const type = e.detail;
    set_store_value(schedule, $schedule = editors[type].default, $schedule);
    $$invalidate(3, selectedEditor = type);
    if (autoSync && !$showError) {
      debouncedScheduleChange($schedule);
    }
  }
  function onScheduleChange(schedule2) {
    Msg.start("save", "l_loading");
    formModel.model.save(null, {
      patch: true,
      silent: true,
      data: { schedule: schedule2 },
      error() {
        Msg.stop("save", { error: "e_req" });
      },
      success() {
        Msg.stop("save", { info: "m_saved_schedule" });
      }
    });
  }
  function onChange(e) {
    if (!autoSync || $showError) {
      return;
    }
    const schedule2 = JSON.stringify(e.detail);
    debouncedScheduleChange(schedule2);
  }
  function getItems() {
    return Object.entries(editors).map(([id2, val]) => ({ id: id2, ...val }));
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("formModel" in $$new_props)
      $$invalidate(0, formModel = $$new_props.formModel);
    if ("autoSync" in $$new_props)
      $$invalidate(12, autoSync = $$new_props.autoSync);
    if ("editors" in $$new_props)
      $$invalidate(1, editors = $$new_props.editors);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8192) {
      $model.client_id, $$invalidate(2, minInt = getMinInt());
    }
  };
  return [
    formModel,
    editors,
    minInt,
    selectedEditor,
    schedule,
    model,
    showError,
    user,
    onTypeChange,
    onChange,
    getItems,
    $$restProps,
    autoSync,
    $model
  ];
}
class ScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2H, create_fragment$2K, safe_not_equal, { formModel: 0, autoSync: 12, editors: 1 });
  }
}
function create_if_block$1m(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Invalid regular expression";
      attr(div, "class", "invalid-tooltip");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$2J(ctx) {
  let div;
  let input0;
  let t0;
  let t1;
  let input1;
  let mounted;
  let dispose;
  let if_block = ctx[4] && create_if_block$1m();
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      input1 = element("input");
      attr(input0, "class", "flex form-control xform-control-sm");
      attr(input0, "type", "text");
      attr(input0, "autocomplete", "off");
      attr(input0, "placeholder", "Expression");
      input0.disabled = ctx[1];
      toggle_class(input0, "is-invalid", ctx[4]);
      attr(input1, "class", "flex form-control xform-control-sm w-20");
      attr(input1, "type", "text");
      attr(input1, "autocomplete", "off");
      attr(input1, "placeholder", "Flags");
      input1.disabled = ctx[1];
      toggle_class(input1, "is-invalid", ctx[4]);
      attr(div, "class", "form-control pa0 border-0 input-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      set_input_value(input0, ctx[2]);
      append(div, t0);
      if (if_block)
        if_block.m(div, null);
      append(div, t1);
      append(div, input1);
      set_input_value(input1, ctx[3]);
      if (!mounted) {
        dispose = [
          listen(input0, "beforeinput", ctx[7], { once: true }),
          listen(input0, "input", ctx[8]),
          listen(input0, "input", ctx[9]),
          listen(input1, "beforeinput", ctx[10], { once: true }),
          listen(input1, "input", ctx[11]),
          listen(input1, "input", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        input0.disabled = ctx2[1];
      }
      if (dirty & 4 && input0.value !== ctx2[2]) {
        set_input_value(input0, ctx2[2]);
      }
      if (dirty & 16) {
        toggle_class(input0, "is-invalid", ctx2[4]);
      }
      if (ctx2[4]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$1m();
          if_block.c();
          if_block.m(div, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 2) {
        input1.disabled = ctx2[1];
      }
      if (dirty & 8 && input1.value !== ctx2[3]) {
        set_input_value(input1, ctx2[3]);
      }
      if (dirty & 16) {
        toggle_class(input1, "is-invalid", ctx2[4]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2G($$self, $$props, $$invalidate) {
  let $regex, $$unsubscribe_regex = noop, $$subscribe_regex = () => ($$unsubscribe_regex(), $$unsubscribe_regex = subscribe(regex, ($$value) => $$invalidate(13, $regex = $$value)), regex);
  let $showError;
  $$self.$$.on_destroy.push(() => $$unsubscribe_regex());
  let { regex } = $$props;
  $$subscribe_regex();
  let { disabled: disabled2 } = $$props;
  regex.dirty;
  let expr = $regex.expr;
  let flags = $regex.flags;
  const { showError } = regex;
  component_subscribe($$self, showError, (value) => $$invalidate(4, $showError = value));
  function set(key, value) {
    regex.update(($old) => ({ ...$old, [key]: value }));
  }
  const beforeinput_handler = () => {
    regex.setTouched(true);
  };
  function input0_input_handler() {
    expr = this.value;
    $$invalidate(2, expr);
  }
  const input_handler = (e) => set("expr", e.target.value);
  const beforeinput_handler_1 = () => {
    regex.setTouched(true);
  };
  function input1_input_handler() {
    flags = this.value;
    $$invalidate(3, flags);
  }
  const input_handler_1 = (e) => set("flags", e.target.value);
  $$self.$$set = ($$props2) => {
    if ("regex" in $$props2)
      $$subscribe_regex($$invalidate(0, regex = $$props2.regex));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled2 = $$props2.disabled);
  };
  return [
    regex,
    disabled2,
    expr,
    flags,
    $showError,
    showError,
    set,
    beforeinput_handler,
    input0_input_handler,
    input_handler,
    beforeinput_handler_1,
    input1_input_handler,
    input_handler_1
  ];
}
class Regex extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2G, create_fragment$2J, safe_not_equal, { regex: 0, disabled: 1 });
  }
}
function get_each_context$I(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  child_ctx[7] = i2;
  return child_ctx;
}
function create_each_block$I(ctx) {
  let div2;
  let div0;
  let regex;
  let t;
  let div1;
  let button;
  let current;
  let mounted;
  let dispose;
  regex = new Regex({ props: { regex: ctx[5] } });
  function click_handler(...args) {
    return ctx[4](ctx[7], ...args);
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(regex.$$.fragment);
      t = space();
      div1 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fa fa-times"></i>`;
      attr(div0, "class", "input-group my-1");
      attr(button, "class", "btn py-2 px-3 btn-sm btn-default");
      attr(div1, "class", "mx-2");
      attr(div2, "class", "d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(regex, div0, null);
      append(div2, t);
      append(div2, div1);
      append(div1, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const regex_changes = {};
      if (dirty & 2)
        regex_changes.regex = ctx[5];
      regex.$set(regex_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(regex.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(regex.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(regex);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2I(ctx) {
  let t;
  let div;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$I(get_each_context$I(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      div = element("div");
      button = element("button");
      button.innerHTML = `<i class="fa fa-plus"></i>`;
      attr(button, "class", "btn btn-sm btn-default py-2 px-3");
      attr(div, "class", "flex items-center my-2");
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t, anchor);
      insert(target, div, anchor);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(ctx[2]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 10) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$I(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$I(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t.parentNode, t);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance$2F($$self, $$props, $$invalidate) {
  let $list, $$unsubscribe_list = noop, $$subscribe_list = () => ($$unsubscribe_list(), $$unsubscribe_list = subscribe(list, ($$value) => $$invalidate(1, $list = $$value)), list);
  $$self.$$.on_destroy.push(() => $$unsubscribe_list());
  let { list } = $$props;
  $$subscribe_list();
  function add() {
    list.add();
  }
  function remove(i2) {
    list.remove(i2);
  }
  const click_handler = (i2, e) => remove(i2);
  $$self.$$set = ($$props2) => {
    if ("list" in $$props2)
      $$subscribe_list($$invalidate(0, list = $$props2.list));
  };
  return [list, $list, add, remove, click_handler];
}
class RegexList$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2F, create_fragment$2I, safe_not_equal, { list: 0 });
  }
}
const get_buttons_slot_changes$2 = (dirty) => ({});
const get_buttons_slot_context$2 = (ctx) => ({});
function create_if_block_2$G(ctx) {
  let div1;
  let label0;
  let br0;
  let t1;
  let div0;
  let inputedit;
  let t2;
  let p;
  let t4;
  let div4;
  let label1;
  let br1;
  let t6;
  let div3;
  let div2;
  let scheduleeditor;
  let current;
  inputedit = new InputEdit({
    props: {
      field: ctx[0].fields.name,
      id: "name",
      name: "name"
    }
  });
  scheduleeditor = new ScheduleEditor({
    props: {
      formModel: ctx[0],
      minInt: ctx[5],
      MIN: ctx[6],
      MAX: ctx[7],
      schedules: ctx[8],
      editors: ctx[4]
    }
  });
  return {
    c() {
      div1 = element("div");
      label0 = element("label");
      label0.textContent = "Name:";
      br0 = element("br");
      t1 = space();
      div0 = element("div");
      create_component(inputedit.$$.fragment);
      t2 = space();
      p = element("p");
      p.textContent = "Crawler name";
      t4 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = "Schedule: ";
      br1 = element("br");
      t6 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(scheduleeditor.$$.fragment);
      attr(label0, "class", "xoption-label");
      attr(label0, "for", "name");
      attr(p, "class", "help");
      attr(div0, "class", "flex-1");
      attr(div1, "class", "flex gap-x-6 mt-5 items-center");
      attr(label1, "class", "xoption-label");
      attr(label1, "for", "url");
      attr(div2, "class", "gap-2");
      set_style(div3, "width", "100%");
      attr(div4, "class", "flex gap-x-6 mt-5 items-center");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, label0);
      append(div1, br0);
      append(div1, t1);
      append(div1, div0);
      mount_component(inputedit, div0, null);
      append(div0, t2);
      append(div0, p);
      insert(target, t4, anchor);
      insert(target, div4, anchor);
      append(div4, label1);
      append(div4, br1);
      append(div4, t6);
      append(div4, div3);
      append(div3, div2);
      mount_component(scheduleeditor, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const inputedit_changes = {};
      if (dirty & 1)
        inputedit_changes.field = ctx2[0].fields.name;
      inputedit.$set(inputedit_changes);
      const scheduleeditor_changes = {};
      if (dirty & 1)
        scheduleeditor_changes.formModel = ctx2[0];
      scheduleeditor.$set(scheduleeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      transition_in(scheduleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      transition_out(scheduleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(inputedit);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div4);
      destroy_component(scheduleeditor);
    }
  };
}
function create_if_block$1l(ctx) {
  let div;
  let p;
  return {
    c() {
      div = element("div");
      p = element("p");
      p.textContent = `${ctx[9]}`;
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$2H(ctx) {
  let div8;
  let div2;
  let label0;
  let br0;
  let t1;
  let div1;
  let div0;
  let urledit;
  let t2;
  let p0;
  let t4;
  let t5;
  let div5;
  let label1;
  let br1;
  let t7;
  let div4;
  let div3;
  let inputedit;
  let t8;
  let p1;
  let t10;
  let div7;
  let label2;
  let br2;
  let t12;
  let div6;
  let regexlist;
  let t13;
  let p2;
  let t15;
  let t16;
  let t17;
  let current;
  urledit = new UrlEdit({
    props: { field: ctx[0].fields.url }
  });
  let if_block0 = ctx[1] && create_if_block_2$G(ctx);
  inputedit = new InputEdit({
    props: {
      type: "number",
      field: ctx[2].fields.maxPages
    }
  });
  regexlist = new RegexList$1({ props: { list: ctx[3] } });
  let if_block1 = loading$1;
  let if_block2 = ctx[9] && create_if_block$1l(ctx);
  const buttons_slot_template = ctx[11].buttons;
  const buttons_slot = create_slot(buttons_slot_template, ctx, ctx[10], get_buttons_slot_context$2);
  return {
    c() {
      div8 = element("div");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Start URL:";
      br0 = element("br");
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      create_component(urledit.$$.fragment);
      t2 = space();
      p0 = element("p");
      p0.textContent = "The url to start crawling. Only the sub-paths of this url will be crawled.";
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div5 = element("div");
      label1 = element("label");
      label1.textContent = "URL limit:";
      br1 = element("br");
      t7 = space();
      div4 = element("div");
      div3 = element("div");
      create_component(inputedit.$$.fragment);
      t8 = space();
      p1 = element("p");
      p1.textContent = "Maximum limit of urls to crawl";
      t10 = space();
      div7 = element("div");
      label2 = element("label");
      label2.textContent = "Excludes: ";
      br2 = element("br");
      t12 = space();
      div6 = element("div");
      create_component(regexlist.$$.fragment);
      t13 = space();
      p2 = element("p");
      p2.textContent = "Regular expressions list for filtering";
      t15 = space();
      t16 = space();
      if (if_block2)
        if_block2.c();
      t17 = space();
      if (buttons_slot)
        buttons_slot.c();
      attr(label0, "class", "xoption-label");
      attr(label0, "for", "url");
      attr(div0, "class", "flex gap-2");
      attr(p0, "class", "help");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "flex gap-x-6 mt-5 items-center");
      attr(label1, "class", "xoption-label");
      attr(label1, "for", "url");
      attr(div3, "class", "flex gap-2");
      attr(p1, "class", "help");
      attr(div4, "class", "flex-1");
      attr(div5, "class", "flex gap-x-6 mt-5 items-center");
      attr(label2, "class", "xoption-label");
      attr(label2, "for", "url");
      attr(p2, "class", "help");
      attr(div6, "class", "gap-1");
      set_style(div6, "width", "100%");
      attr(div7, "class", "flex gap-x-6 mt-5 items-center");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div2);
      append(div2, label0);
      append(div2, br0);
      append(div2, t1);
      append(div2, div1);
      append(div1, div0);
      mount_component(urledit, div0, null);
      append(div1, t2);
      append(div1, p0);
      append(div8, t4);
      if (if_block0)
        if_block0.m(div8, null);
      append(div8, t5);
      append(div8, div5);
      append(div5, label1);
      append(div5, br1);
      append(div5, t7);
      append(div5, div4);
      append(div4, div3);
      mount_component(inputedit, div3, null);
      append(div4, t8);
      append(div4, p1);
      append(div8, t10);
      append(div8, div7);
      append(div7, label2);
      append(div7, br2);
      append(div7, t12);
      append(div7, div6);
      mount_component(regexlist, div6, null);
      append(div6, t13);
      append(div6, p2);
      append(div8, t15);
      append(div8, t16);
      if (if_block2)
        if_block2.m(div8, null);
      insert(target, t17, anchor);
      if (buttons_slot) {
        buttons_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const urledit_changes = {};
      if (dirty & 1)
        urledit_changes.field = ctx2[0].fields.url;
      urledit.$set(urledit_changes);
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$G(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div8, t5);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[9])
        if_block2.p(ctx2, dirty);
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(buttons_slot_template, ctx2[10], dirty, get_buttons_slot_changes$2),
            get_buttons_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(urledit.$$.fragment, local);
      transition_in(if_block0);
      transition_in(inputedit.$$.fragment, local);
      transition_in(regexlist.$$.fragment, local);
      transition_in(if_block1);
      transition_in(buttons_slot, local);
      current = true;
    },
    o(local) {
      transition_out(urledit.$$.fragment, local);
      transition_out(if_block0);
      transition_out(inputedit.$$.fragment, local);
      transition_out(regexlist.$$.fragment, local);
      transition_out(if_block1);
      transition_out(buttons_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div8);
      destroy_component(urledit);
      if (if_block0)
        if_block0.d();
      destroy_component(inputedit);
      destroy_component(regexlist);
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach(t17);
      if (buttons_slot)
        buttons_slot.d(detaching);
    }
  };
}
let loading$1 = false;
function instance$2E($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { crawler } = $$props;
  let { showNameAndSchedule = true } = $$props;
  const { config } = crawler.fields;
  const { excludes } = config.fields;
  const editors = {
    INTERVAL: {
      name: "Interval",
      component: IntervalScheduleEditor
    },
    CRON: {
      name: "Crontab *",
      disabled: !App.user.isEnterprise(),
      component: CronScheduleEditor
    },
    enterprise: { name: "* For Enterprise", disabled: true }
  };
  const minInt = 3600 * 24;
  const MIN = 3600 * 24;
  const MAX = 3600 * 24 * 50;
  const schedules = [
    { value: MIN, label: "1d" },
    { value: 3600 * 24 * 2, label: "2d" },
    { value: 3600 * 24 * 3, label: "3d" },
    { value: 3600 * 24 * 5, label: "5d" },
    { value: 3600 * 24 * 10, label: "10d" },
    { value: 3600 * 24 * 15, label: "15d" },
    { value: MAX, label: "Never" }
  ];
  let errorMsg;
  $$self.$$set = ($$props2) => {
    if ("crawler" in $$props2)
      $$invalidate(0, crawler = $$props2.crawler);
    if ("showNameAndSchedule" in $$props2)
      $$invalidate(1, showNameAndSchedule = $$props2.showNameAndSchedule);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    crawler,
    showNameAndSchedule,
    config,
    excludes,
    editors,
    minInt,
    MIN,
    MAX,
    schedules,
    errorMsg,
    $$scope,
    slots
  ];
}
class CrawlEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2E, create_fragment$2H, safe_not_equal, { crawler: 0, showNameAndSchedule: 1 });
  }
}
const JOB_ERR_TYPES = {
  "onDemand": "A new job is running",
  "retry": "A job is being retried",
  "scheduled": "A scheduled job is running",
  "unknown": "Please check the console for more info"
};
function checkLimitConstraint(limit2) {
  limit2 = parseInt(limit2);
  let crawlPageConstraint = App.user.get("constraint").crawl_pages;
  if (crawlPageConstraint < limit2) {
    return `URL limit cannot exceed ${crawlPageConstraint}`;
  }
  if (limit2 <= 0) {
    return `URL limit should be greater than 0`;
  }
  return;
}
function getJobErrFromErr(err) {
  return JOB_ERR_TYPES[err.type] || JOB_ERR_TYPES["unknown"];
}
class RegexList extends FieldList {
  constructor(values) {
    super({ type: "regex" }, values);
  }
  getDefaultValue() {
    return { expr: "", flags: "gim" };
  }
}
const _ConfigFormModel = class extends FormModel {
  constructor(json) {
    super(_ConfigFormModel.fields, json);
  }
};
let ConfigFormModel = _ConfigFormModel;
__publicField(ConfigFormModel, "fields", {
  maxPages: {
    type: "int",
    required: true,
    validators: [
      checkLimitConstraint
    ]
  },
  excludes: {
    type: "list:regex"
  }
});
class ConfigType extends TYPES.json {
  static toJSON(config) {
    return config.toJSON();
  }
  static parse(json) {
    return new ConfigFormModel(json);
  }
}
class RegexListType extends TYPES.base {
  static toJSON(config) {
    return config.toJSON();
  }
  static parse(json) {
    return new RegexList(json);
  }
}
__publicField(RegexListType, "default");
register("crawlerConfig", ConfigType);
register("list:regex", RegexListType);
const _Crawler$1 = class extends FormModel {
  constructor(model) {
    super(_Crawler$1.fields, model.toJSON());
    this.model = model;
  }
  getURLRoot() {
    return "/crawlers";
  }
};
let Crawler$1 = _Crawler$1;
__publicField(Crawler$1, "fields", {
  name: {
    type: "text",
    required: true
  },
  schedule: {
    type: "json",
    required: true
  },
  url: {
    type: "url",
    required: true
  },
  config: {
    type: "crawlerConfig",
    required: true
  }
});
const get_buttons_slot_changes$1 = (dirty) => ({});
const get_buttons_slot_context$1 = (ctx) => ({ slot: "buttons" });
function create_catch_block$j(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$j(ctx) {
  let crawleditor;
  let current;
  crawleditor = new CrawlEditor({
    props: {
      crawler: ctx[0],
      showNameAndSchedule: false,
      $$slots: { buttons: [create_buttons_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(crawleditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(crawleditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const crawleditor_changes = {};
      if (dirty & 1)
        crawleditor_changes.crawler = ctx2[0];
      if (dirty & 1028) {
        crawleditor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      crawleditor.$set(crawleditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crawleditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crawleditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(crawleditor, detaching);
    }
  };
}
function fallback_block$3(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let button0;
  let t1;
  let t2;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      button0 = element("button");
      t1 = text("Done");
      t2 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(div0, "class", "xoption-label");
      button0.disabled = ctx[2];
      attr(button0, "class", "btn btn-primary");
      attr(button1, "class", "btn btn-default");
      attr(div1, "class", "flex-1 mt-4 pt-2");
      attr(div2, "class", "flex gap-x-6 mb-[30px]");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      append(div1, button0);
      append(button0, t1);
      append(div1, t2);
      append(div1, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[6]),
          listen(button1, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        button0.disabled = ctx2[2];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_buttons_slot$5(ctx) {
  let current;
  const buttons_slot_template = ctx[8].buttons;
  const buttons_slot = create_slot(buttons_slot_template, ctx, ctx[10], get_buttons_slot_context$1);
  const buttons_slot_or_fallback = buttons_slot || fallback_block$3(ctx);
  return {
    c() {
      if (buttons_slot_or_fallback)
        buttons_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (buttons_slot_or_fallback) {
        buttons_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(buttons_slot_template, ctx2[10], dirty, get_buttons_slot_changes$1),
            get_buttons_slot_context$1
          );
        }
      } else {
        if (buttons_slot_or_fallback && buttons_slot_or_fallback.p && (!current || dirty & 4)) {
          buttons_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(buttons_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(buttons_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (buttons_slot_or_fallback)
        buttons_slot_or_fallback.d(detaching);
    }
  };
}
function create_pending_block$j(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$2G(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$j,
    then: create_then_block$j,
    catch: create_catch_block$j,
    value: 12,
    blocks: [, , ,]
  };
  handle_promise(ctx[5], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$2D($$self, $$props, $$invalidate) {
  let $model;
  let $error, $$unsubscribe_error = noop, $$subscribe_error = () => ($$unsubscribe_error(), $$unsubscribe_error = subscribe(error, ($$value) => $$invalidate(2, $error = $$value)), error);
  $$self.$$.on_destroy.push(() => $$unsubscribe_error());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { formModel } = $$props;
  let { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(11, $model = value));
  let crawlerForm;
  let error;
  const dispatch = createEventDispatcher();
  const crawlerLoadPromise = model.loadCrawler();
  crawlerLoadPromise.then(() => {
    $$invalidate(0, crawlerForm = new Crawler$1($model.crawler));
    $$subscribe_error($$invalidate(1, error = crawlerForm.error));
  });
  async function updateSieveWithCrawler() {
    try {
      let crawler = crawlerForm.toJSON();
      model.set("crawler", crawlerForm);
      model.set("uri", crawler.url);
      dispatch("save");
    } catch (err) {
      console.error("Error saving", err);
    }
  }
  const click_handler = (e) => dispatch("discard");
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(7, formModel = $$props2.formModel);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    crawlerForm,
    error,
    $error,
    model,
    dispatch,
    crawlerLoadPromise,
    updateSieveWithCrawler,
    formModel,
    slots,
    click_handler,
    $$scope
  ];
}
class Sitemap extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2D, create_fragment$2G, safe_not_equal, { formModel: 7 });
  }
}
function create_content_slot$1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [{ formModel: ctx[0] }, ctx[4]];
  var switch_value = ctx[3].component;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
    switch_instance.$on("save", ctx[5]);
    switch_instance.$on("discard", ctx[6]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & 17 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 1 && { formModel: ctx2[0] },
        dirty & 16 && get_spread_object(ctx2[4])
      ]) : {};
      if (switch_value !== (switch_value = ctx2[3].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          switch_instance.$on("save", ctx2[5]);
          switch_instance.$on("discard", ctx2[6]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$2F(ctx) {
  let sieveoptionslayout;
  let current;
  sieveoptionslayout = new Layout({
    props: {
      title: !ctx[1] && `${T("l_source")} - ${ctx[3].title}`,
      $$slots: { content: [create_content_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sieveoptionslayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptionslayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sieveoptionslayout_changes = {};
      if (dirty & 2)
        sieveoptionslayout_changes.title = !ctx2[1] && `${T("l_source")} - ${ctx2[3].title}`;
      if (dirty & 2065) {
        sieveoptionslayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sieveoptionslayout.$set(sieveoptionslayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptionslayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptionslayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptionslayout, detaching);
    }
  };
}
function instance$2C($$self, $$props, $$invalidate) {
  const omit_props_names = ["formModel", "hideTitle"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $model;
  let { formModel } = $$props;
  let { hideTitle = false } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(7, $model = value));
  const type = getType2();
  const sources = {
    [C$2.TYPE_HTML]: {
      title: "Webpage",
      component: Html
    },
    [C$2.TYPE_FEED]: { title: "Feed", component: Feed_1 },
    [C$2.TYPE_XML]: { title: "XML", component: Xml },
    [C$2.TYPE_PDF_HTML]: { title: "PDF", component: Pdf },
    [C$2.TYPE_DOC]: {
      title: "Word Document",
      component: Doc
    },
    [C$2.TYPE_JSON]: {
      title: $model.datasource_id === C$2.DS_ID_JSON ? "JSON" : "Uptime",
      component: Json
    },
    [C$2.TYPE_SITEMAP]: {
      title: "Sitemap",
      component: Sitemap
    }
  };
  const selected = sources[type];
  function getType2() {
    if ($model.content_type === C$2.TYPE_JSON && ![C$2.DS_ID_JSON, C$2.DS_ID_UPTIME].includes($model.datasource_id)) {
      return C$2.TYPE_HTML;
    }
    return $model.content_type;
  }
  function save_handler(event) {
    bubble.call(this, $$self, event);
  }
  function discard_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("formModel" in $$new_props)
      $$invalidate(0, formModel = $$new_props.formModel);
    if ("hideTitle" in $$new_props)
      $$invalidate(1, hideTitle = $$new_props.hideTitle);
  };
  return [
    formModel,
    hideTitle,
    model,
    selected,
    $$restProps,
    save_handler,
    discard_handler
  ];
}
class SourceSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2C, create_fragment$2F, safe_not_equal, { formModel: 0, hideTitle: 1 });
  }
}
class SessionSelector extends Base$2 {
  constructor({ model }) {
    super();
    this.model = model;
    this.setId(model.get("session_id"));
    this.state.names = {};
    if (App.user.isLoggedIn()) {
      this.loadSessions();
    }
  }
  async loadSessions(query = {}) {
    let res = await Api.api("/sessions", query);
    this.state.sessions = res.data;
    let names = res.data.reduce((m, s) => {
      m[s.id] = s.name;
      return m;
    }, {});
    let id2 = this.state.id;
    if (id2 && !names[id2]) {
      let res2 = await Api.api(`/sessions/${id2}`);
      names[id2] = res2.name;
    }
    this.state.names = names;
  }
  onSearch(e) {
    this.loadSessions({
      "name.ilike": `%${e.target.value}%`
    });
  }
  setId(id2, e) {
    e && e.preventDefault();
    this.state.id = id2;
    this.model.set("session_id", id2);
  }
  createTpl({ id: id2, sessions, names }) {
    let loadedSessions = !!sessions;
    let team = get_store_value(params).team;
    return html`<div class='dropdown'>
      <a class='btn btn-default dropdown-toggle' data-bs-toggle='dropdown'
        href='#'>
        Profile - ${!id2 ? "Empty" : names[id2] || "Deleted"}
        <span class='caret'></span>
      </a>
      <ul class='dropdown-menu'>
        ${loadedSessions ? [
      html`
        <li>
          <div class='ma2 dropdown-item' @click=${(e) => (e.preventDefault(), e.stopPropagation())}>
            <input type='text' class='ba0' placeholder='Search' @input=${(e) => this.onSearch(e)}></input>
          </div>
        </li>
          <li><a href='#' class='dropdown-item' @click=${(e) => this.setId(null, e)}>
              <i class='mr2 fa ${!id2 ? "fa-check" : "mr4"}'></i>
              Empty (Default)</a></li>`,
      ...sessions.map((s) => html`<li>
            <a data-id=${s.id} class='dropdown-item' href='#' @click=${(e) => this.setId(s.id, e)}>
              <i class='mr2 fa ${id2 == s.id ? "fa-check" : "mr4"}'></i>
              ${s.name}
            </a>
          </li>`),
      html`
          <li class='dropdown-divider'></li>

          <li><a class='dropdown-item' href='#/w/${team}/profiles/' target='_blank'>
              <span class='pl4'> Manage Profiles<span></a></li>

          <li><a class='dropdown-item' href='${URL_WEBSITE}/kb/help/profiles-for-cloud-monitors' target='_blank'>
              <span class='pl4'> Learn More<span></a></li>
              `
    ] : html`<li><a class='dropdown-item'>Loading...</a></li>`}
      </ul>
    </div>`;
  }
}
const async$3 = window.async;
if (!async$3) {
  throw new Error("ADD async");
}
class ClientSelector$1 extends Base$2 {
  constructor({ model }) {
    super();
    this.model = model;
    this.state.showOptions = false;
    this.setClientId(this.getDefaultClientID());
    this.sessionSelector = new SessionSelector({ model });
    this.setProxyID(model.get("proxy_id"));
    this.state.proxyNames = {};
    if (App.user.isLoggedIn()) {
      this.loadProxies();
    }
  }
  getDefaultClientID() {
    let id2 = this.model.get("client_id") || App.clients.defaultId;
    let ids = this.model.getAccessibleClients(App.clients).map((c) => c.id);
    return ids.includes(id2) ? id2 : ids[0];
  }
  setClientId(client_id) {
    this.state.client_id = client_id;
    this.model.set("client_id", client_id);
  }
  setProxyID(proxy_id, e) {
    e && e.preventDefault();
    this.state.proxy_id = proxy_id;
    this.model.set("proxy_id", proxy_id);
  }
  async loadProxies() {
    const res = await Api.api("/proxies", {
      only: ["id", "name", "cost"]
    });
    let globalData = (await Api.api("/proxies/global")).data;
    globalData = globalData.filter((p) => p.available);
    this.state.proxies = [...res.data, ...globalData];
    res.data.reduce((m, s) => (m[s.id] = s.name, m), this.state.proxyNames);
    globalData.reduce((m, s) => (m[s.id] = s.name, m), this.state.proxyNames);
  }
  createTpl({
    client_id,
    proxyNames,
    proxies,
    proxy_id,
    showOptions
  }) {
    let $params = get_store_value(params);
    let team = $params.team;
    let client = App.clients.get(client_id);
    let loadedProxies = !!proxies;
    let availableClients = this.model.getAccessibleClients(App.clients);
    return html`<div class='flex align-items'>
      <select @change=${(e) => this.setClientId(e.target.value)} class='mr3'>
        ${repeat(availableClients, (c) => c.id, (c) => html`<option value=${c.id} ?selected=${c.id == client_id}>${c.getInfo()}</option>`)}
      </select>
      ${client && client.isWeb() && !showOptions ? html`<a
        @click=${(e) => this.state.showOptions = true}
        href='javascript:void 0'>Options</a>` : ""}
      ${client && client.isWeb() && showOptions ? this.sessionSelector.el : ""}
      ${showOptions && client && client.isWeb() ? html`<div class='ml3 dropdown relative'>
        <a class='dropdown-toggle btn btn-default' data-bs-toggle='dropdown'
          href=#
          >
          Proxy - ${!proxy_id ? "Shared Pool" : proxyNames[proxy_id] || "Deleted"} <span class='caret'></span>
        </a>
        <ul class='dropdown-menu'>
        ${loadedProxies ? [
      html`<li><a class='dropdown-item' href='#' @click=${(e) => this.setProxyID(null, e)}>
            <i class='mr2 fa ${!proxy_id ? "fa-check" : "mr4"}'></i>
            Shared Pool (Default)</a></li>`,
      ...proxies.map((s) => html`<li>
            <a data-id=${s.id} class='dropdown-item' href='#' @click=${(e) => this.setProxyID(s.id, e)}>
              <i class='mr2 fa ${proxy_id == s.id ? "fa-check" : "mr4"}'></i>
              ${s.name}
            </a>
          </li>`),
      html`
          <li class='dropdown-divider'></li>

          <li><a class='dropdown-item' href='#/w/${team}/proxies/' target='_blank'>
              <span class='pl4'> Manage Proxies<span></a></li>

          <li><a class='dropdown-item' href='${URL_WEBSITE}/kb/help/monitor-webpage-using-proxy-servers/' target='_blank'>
              <span class='pl4'> Learn More<span></a></li>
          `
    ] : html`<li><a class='dropdown-item'>Loading...</a></li>`}
        </ul>
      
      </div>` : ""}
    </div>`;
  }
}
const ClientManager$1 = View.Collection.extend({
  name: "ClientManager",
  actions: {
    "client edit name": {
      fn: "action_edit_name"
    },
    "client remove": {
      fn: "action_remove"
    }
  },
  action_edit_name: function(id2) {
    const view = Editor.create("text");
    const model = this.collection.get(id2);
    const modal = new View.PromptModal({
      title: "l_name",
      parent: this.getRoot(),
      view,
      width: 500
    });
    modal.show();
    view.setValue(model.get("info"));
    $(view.field).focus();
    modal.on("save", () => {
      const value = view.getValue();
      model.save({ "info": value }, { patch: true });
      modal.remove();
      this.onReset(this.collection, {
        previousModels: this.collection.models
      });
    });
  },
  action_remove: function(id2) {
    const model = this.collection.get(id2);
    if (id2 == this.collection.defaultId) {
      return alert(T("Can't remove self"));
    } else if (model.isWeb()) {
      return alert(T("Can't remove web app"));
    } else if (confirm(T("Remove " + model.get("info") + "?"))) {
      model.save({ state: 90 }, {
        wait: true,
        success: () => {
          this.collection.remove(model);
        }
      });
    }
  },
  addOne: function(model) {
    if (model.get("type") < 3) {
      return new View.Base();
    }
    const info = model.get("info");
    const isThisClient = model.id == this.collection.defaultId;
    const view = new View.Base({
      el: P(
        SPAN(
          BUTTON({
            "class": "btn btn-default btn-sm",
            "data-action": "client edit name",
            "data-action-param": model.id
          }, I({ "class": "fa fa-edit" })),
          " ",
          BUTTON({
            "class": "btn btn-danger btn-sm",
            "data-action": "client remove",
            "data-action-param": model.id
          }, I({ "class": "fa fa-trash-o" }))
        ),
        " ",
        SPAN({ style: isThisClient ? "font-weight: bold;" : "" }, info, isThisClient ? " (" + T("l_device_this") + ")" : ""),
        SMALL({}, moment(model.get("ts")).format(" (YYYY-MM-DD)"))
      ),
      parent: this
    }).render();
    this.$el.append(view.el);
    return view;
  },
  onSave: function() {
    Msg.info("l_loading");
    async$3.eachSeries(this.collection.models, function(model, callback) {
      if (model.hasChanged("info")) {
        model.save(null, {
          error: function() {
            callback(new Error("Failed to save changes"));
          },
          success: function() {
            callback();
          }
        });
      } else {
        callback();
      }
    }, function(err) {
      Msg.reset();
    });
  },
  renderBase: function() {
  }
});
var ViewClients = {
  ClientManager: ClientManager$1,
  ClientSelector: ClientSelector$1
};
const SieveActionEditor$1 = View.Base.extend({
  name: "SieveActionEditor",
  postInit: function() {
    this.listenTo(this.model, "remove", this.remove);
    this.paramsModel = new Backbone.Model(this.model.get("config"));
    this.listenTo(this.paramsModel, "change", this.onEditParams);
  },
  onDelete: function() {
    this.model.collection.remove(this.model);
  },
  onEditParams: function() {
    this.model.set("config", this.paramsModel.toJSON());
  },
  render: function() {
    const desc = this.model.desc;
    let paramsEl;
    let editors;
    if (!desc.single) {
      let del;
      this.$el.append(
        del = A({
          "class": "btn fa fa-trash-o xbtn-light",
          "style": "vertical-align: top;margin-top: 5px;",
          "href": "javascript:void 0",
          "title": T("h_del_action")
        })
      );
      del.onclick = this.onDelete;
    } else {
      this.$el.css({
        "margin-left": 30,
        "line-height": 0
      });
    }
    this.$el.append(
      paramsEl = DIV({ style: "display:inline-block;width:80%; margin-bottom: 5px;white-space:nowrap;" })
    ).css({ position: "relative", overflow: "visible" });
    editors = this.paramEditors = _.map(desc.params, function(param) {
      const paramEditor = Editor.create(param.type, {
        param,
        parent: this,
        model: this.paramsModel
      });
      paramsEl.appendChild(paramEditor.render().el);
      if (!param.must) {
        paramEditor.$el.hide();
      }
      return paramEditor;
    }, this);
    if (_.any(desc.params, function(param) {
      return !param.must;
    })) {
      let elToggle;
      paramsEl.appendChild(
        elToggle = BUTTON(
          { "class": "btn btn-default btn-sm xbtn-light" },
          T("l_options")
        )
      );
      elToggle.onclick = function() {
        _.each(editors, function(editor) {
          editor.$el.show();
        });
        $(elToggle).remove();
      };
    }
    if (desc.plugin) {
      desc.plugin(this);
    }
    return this;
  }
});
const SieveActionGroup$1 = View.Base.extend({
  name: "SieveActionGroup",
  className: "xtype-group",
  postInit: function(options) {
    this.desc = options.desc;
    this.models = options.models;
    this.views = {};
    this.listenTo(this.models, "add", this.addOne);
    this.listenTo(this.models, "remove", this.onActionRemove);
  },
  addOne: function(action) {
    if (this.views[action.cid] == null && action.desc.type == this.desc.type) {
      const view = new SieveActionEditor$1({
        model: action,
        parent: this
      }).render();
      this.$list.append(view.el);
      this.views[action.cid] = view;
    }
  },
  isVoid: function(view) {
    return this.desc.single || this.desc.params.length == 0;
  },
  onActionAdd: function() {
    this.models.add(new Model$2.SieveAction[this.desc.type]());
  },
  onActionRemove: function(action, actionGroup) {
    if (this.models.where({ type: this.desc.type }).length == 0) {
      this.remove();
    }
  },
  onDelete: function() {
    const actions = this.models.where({ type: this.desc.type });
    _.each(actions, function(action) {
      this.models.remove(action);
    }, this);
  },
  render: function() {
    const desc = this.desc;
    let btnAdd;
    let btnDel;
    this.$list = $(DIV());
    if (desc.single) {
      this.$el.append(
        btnDel = BUTTON({
          "class": "btn fa fa-trash-o xbtn-light",
          "title": T("h_del_action")
        })
      );
      btnDel.onclick = this.onDelete;
    }
    if (!desc.single) {
      this.$el.append(
        btnAdd = BUTTON({ "class": "btn fa fa-plus xbtn-light pull-right" })
      );
      btnAdd.onclick = this.onActionAdd;
    }
    this.$el.append(
      SPAN(
        { style: "" },
        SPAN(T(desc.label)),
        this.$list[0]
      )
    );
    if (desc.groupPlugin) {
      desc.groupPlugin(this);
    }
    this.models.each(this.addOne);
    return this;
  }
});
function getGlobalActions() {
  var _a, _b;
  return (_b = (_a = USER.prefs) == null ? void 0 : _a.actions) != null ? _b : [{ type: C.ACTION_PUSH, config: null }];
}
const SieveActionsEditor = View.ActionProvider.extend({
  name: "SieveActionsEditor",
  actions: {
    action_global_actions: { fn: "action_global_actions" }
  },
  action_global_actions: function() {
    showGlobalActionEditor();
  },
  postInit: function(options) {
    this.actionGroups = {};
    this.dels = [];
    this.sieve = options.sieve;
    this.models = options.actions;
    this.listenTo(this.models, "add", this.addOne);
    this.listenTo(this.models, "remove", this.onActionRemove);
    this.listenTo(this.models, "reset", this.render);
    this.listenTo(App.user, "change", this.renderGlobalCount);
  },
  addOne: function(action) {
    const desc = action.desc;
    const type = desc.type;
    this.$emptyEl.remove();
    if (!this.actionGroups[type]) {
      const view = this.actionGroups[type] = new SieveActionGroup$1({
        models: this.models,
        desc,
        parent: this
      }).render();
      this.listenTo(view, "remove", function() {
        delete this.actionGroups[type];
      }, this);
      this.$list.append(view.el);
    }
  },
  getChanges: function() {
    return {
      dels: this.dels,
      posts: this.getPosts(),
      puts: this.getPuts()
    };
  },
  getPosts: function() {
    return this.models.filter(function(action) {
      return action.isNew();
    });
  },
  getPuts: function() {
    return this.models.filter(function(action) {
      return !action.isNew() && action.hasChanged();
    });
  },
  onAddActionMenuClick: function(e) {
    const type = $(e.currentTarget).attr("tag");
    const Type = Model$2.SieveAction[type];
    if (Type.desc.single && this.models.where({ type: Type.desc.type }).length > 0) {
      Msg.info("m_action_can_add_only_one");
      return;
    }
    this.models.add(new Type(null, {
      parent: this.sieve
    }));
    e.preventDefault();
  },
  onActionRemove: function(action) {
    if (!action.isNew()) {
      this.dels.push(action);
    }
  },
  render: function() {
    let menu;
    this.reset();
    this.$emptyEl = $(DIV(
      { "class": "alert alert-warning hide" },
      "No action added - add one to get alerted on changes"
    ));
    this.$list = $(DIV());
    this.$el.empty().append(
      DIV(
        { style: "position: relative;" },
        DIV(
          { "class": "space-x-4" },
          A({
            "id": "menu_add_action",
            "class": "dropdown-toggle",
            "data-bs-toggle": "dropdown",
            "href": "javascript:void 0"
          }, T("a_add_action"), " ", B({ "class": "caret" })),
          " ",
          menu = UL({
            "class": "dropdown-menu",
            "role": "menu",
            "aria-labelledby": "menu_add_action",
            "style": "z-index: 2000"
          }),
          " ",
          this.options.global ? "" : A({
            "href": "#",
            "class": "",
            "data-action": "action_global_actions"
          }, "Global Actions: ", this.elGlobalCount = SPAN(0))
        ),
        DIV({
          "class": "right",
          "style": "margin-left:10px;"
        })
      ),
      this.$emptyEl,
      DIV({ style: "max-height: 360px;overflow-y:auto;overflow-x-hidden;" }, this.$list[0])
    );
    _.each(Model$2.SieveActionDescList, function(desc) {
      menu.appendChild(LI(
        A(
          { tag: desc.type, tabindex: -1, href: "javascript:void 0", class: "dropdown-item" },
          I({ "class": "fa " + desc.icon }),
          SPAN({ style: "margin-left: 10px;" }, T(desc.label), desc.paid ? " *" : "")
        )
      ));
    });
    this.renderGlobalCount();
    menu.appendChild(LI(
      { "class": "disabled" },
      A({ href: "#", class: "dropdown-item" }, "* " + T("m_premium_only"))
    ));
    $(menu).find("a").click(this.onAddActionMenuClick);
    this.models.each(this.addOne);
    this.$emptyEl[this.models.length == 0 ? "removeClass" : "addClass"]("hide");
    return this;
  },
  async renderGlobalCount() {
    if (App.user.isLoggedIn()) {
      $(this.elGlobalCount).text(getGlobalActions().length);
    }
  },
  reset: function() {
    _.each(this.actionGroups, function(view) {
      view.remove();
    });
    this.actionGroups = {};
    this.dels = [];
  }
});
async function showGlobalActionEditor() {
  if (!USER.id) {
    return alert("Please sign in save global actions");
  }
  let sieve = new Model$2.Sieve();
  let actions = new Model$2.SieveActions(null, { parent: sieve });
  actions.set({
    data: getGlobalActions()
  }, { parse: true });
  let view = new SieveActionsEditor({
    actions,
    sieve,
    parent: App.root,
    global: true
  });
  const modal = new View.SaveDiscardModal({
    name: "GlobalActionEditor$SaveDiscardModal",
    title: "Global Actions",
    titleEx: `taken on changes for all monitors, merged with monitor's actions`,
    view,
    parent: App.root
  });
  modal.on("save", async () => {
    modal.remove();
    let data = actions.toJSON();
    try {
      await Api.api("/prefs/actions", "PUT", data);
      USER.prefs.actions = data;
    } catch (e) {
      console.error(e);
      Msg.error("Failed to save data, please try again later");
    }
  });
  modal.on("discard", () => {
    modal.remove();
  });
  modal.show();
}
const DescList$1 = [
  {
    type: C$2.RULE_NOT_EMPTY,
    label: "l_not_is_empty",
    params: []
  },
  {
    type: C$2.RULE_HAS_TEXT,
    label: "l_has",
    params: [{
      label: "l_text",
      must: true,
      name: "input",
      type: "text"
    }]
  },
  {
    type: C$2.RULE_HAS_TEXT_NOT,
    label: "l_has_not",
    params: [{
      label: "l_text",
      must: true,
      name: "input",
      type: "text"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_LT,
    label: "l_has_num_lt",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_GT,
    label: "l_has_num_gt",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_DECR_MIN,
    label: "l_has_num_decr_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_INCR_MIN,
    label: "l_has_num_incr_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_DECR_PERCENT_MIN,
    label: "l_has_num_decr_pct_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_INCR_PERCENT_MIN,
    label: "l_has_num_incr_pct_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_MATCH_REGEX,
    label: "l_match_regex",
    params: [{
      label: "l_regex",
      must: true,
      name: "input",
      type: "regexp"
    }]
  }
];
const ContentList$1 = [{
  type: C$2.CONTENT_TYPE_TEXT,
  label: "l_text"
}, {
  type: C$2.CONTENT_TYPE_CHANGED_TEXT,
  label: "l_added_text"
}, {
  type: C$2.CONTENT_TYPE_OLD_TEXT,
  label: "l_text_old"
}];
const NumericConditions$1 = [
  C$2.RULE_HAS_NUMBER_LT,
  C$2.RULE_HAS_NUMBER_GT,
  C$2.RULE_HAS_NUMBER_DECR_MIN,
  C$2.RULE_HAS_NUMBER_INCR_MIN,
  C$2.RULE_HAS_NUMBER_DECR_PERCENT_MIN,
  C$2.RULE_HAS_NUMBER_INCR_PERCENT_MIN
];
var Rules$1 = {
  ContentList: ContentList$1,
  DescList: DescList$1,
  NumericConditions: NumericConditions$1
};
function get_each_context$H(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function create_each_block$H(key_1, ctx) {
  let option;
  let t_value = T(ctx[7].label) + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[7].value;
      option.value = option.__value;
      attr(option, "title", T(ctx[7].title));
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$2E(ctx) {
  let div;
  let span;
  let t2;
  let select;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let mounted;
  let dispose;
  let each_value = ctx[3];
  const get_key = (ctx2) => ctx2[7].value;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$H(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$H(key, child_ctx));
  }
  let div_levels = [
    {
      class: div_class_value = "flex " + ctx[2]
    },
    ctx[4]
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${T("l_num_format")}:`;
      t2 = space();
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(span, "class", "pr-2");
      attr(select, "title", T("title_num_format"));
      select.disabled = ctx[1];
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[5].call(select));
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t2);
      append(div, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[0], true);
      if (!mounted) {
        dispose = listen(select, "change", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8) {
        each_value = ctx2[3];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$H, null, get_each_context$H);
      }
      if (dirty & 2) {
        select.disabled = ctx2[1];
      }
      if (dirty & 9) {
        select_option(select, ctx2[0]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 4 && div_class_value !== (div_class_value = "flex " + ctx2[2]) && { class: div_class_value },
        dirty & 16 && ctx2[4]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2B($$self, $$props, $$invalidate) {
  const omit_props_names = ["format", "disabled", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { format: format2 } = $$props;
  let { disabled: disabled2 } = $$props;
  const OPTIONS = [
    {
      label: "rule_comma_dot",
      title: "title_format_option_comma_dot",
      value: C$2.NUM_FORMAT_COMMA_DOT
    },
    {
      label: "rule_dot_comma",
      title: "title_format_option_dot_comma",
      value: C$2.NUM_FORMAT_DOT_COMMA
    },
    {
      label: "rule_space_comma",
      title: "title_format_option_space_comma",
      value: C$2.NUM_FORMAT_SPACE_COMMA
    }
  ];
  format2 || (format2 = C$2.NUM_FORMAT_COMMA_DOT);
  let dispatch = createEventDispatcher();
  let { class: clazz } = $$props;
  function select_change_handler() {
    format2 = select_value(this);
    $$invalidate(0, format2);
    $$invalidate(3, OPTIONS);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("format" in $$new_props)
      $$invalidate(0, format2 = $$new_props.format);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled2 = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(2, clazz = $$new_props.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      dispatch("change", format2);
    }
  };
  return [format2, disabled2, clazz, OPTIONS, $$restProps, select_change_handler];
}
class NumberFormat extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2B, create_fragment$2E, safe_not_equal, { format: 0, disabled: 1, class: 2 });
  }
}
const SieveRuleEditor = View.Base.extend({
  name: "SieveRuleEditor",
  className: "flex space-x-2",
  postInit: function() {
    this.paramsModel = new Backbone.Model(this.model.rule.params);
  },
  getConfig: function() {
    return {
      type: C$2.TYPE_RULE,
      contentType: this.getContentType(),
      rule: {
        type: this.getRuleType(),
        params: this.getParams()
      }
    };
  },
  getContentType: function() {
    return parseInt(this.selContentType.value);
  },
  getParams: function() {
    const keys = _.pluck(this.getRuleDesc().params, "name");
    const json = this.paramsModel.toJSON();
    return _.pick(...[json].concat(keys));
  },
  getRuleDesc: function() {
    return _.findWhere(Rules$1.DescList, { type: this.getRuleType() }) || {
      type: 0,
      lable: "l_rule_unknown",
      params: []
    };
  },
  getRuleType: function() {
    return parseInt(this.selRuleType.value);
  },
  onTypeChange: function() {
    this.renderParams();
    this.bubbleEvent("onTypeChange");
  },
  render: function() {
    let elParams;
    this.$el.append(
      this.selContentType = SELECT.apply(
        window,
        _.map(Rules$1.ContentList, function(item) {
          return OPTION({ value: item.type }, T(item.label));
        })
      ),
      this.selRuleType = SELECT.apply(
        window,
        _.map(Rules$1.DescList, function(item) {
          return OPTION({ value: item.type }, T(item.label));
        })
      ),
      elParams = DIV({
        style: "flex: 1"
      })
    );
    this.selContentType.value = this.model.contentType;
    this.selRuleType.value = this.model.rule.type;
    this.$elParams = $(elParams);
    this.renderParams();
    $(this.selRuleType).change(this.onTypeChange);
    return this;
  },
  renderParams: function() {
    const elParams = this.$elParams;
    const model = this.paramsModel;
    const desc = this.getRuleDesc();
    if (!desc)
      throw new Error("Unknown rule desc:" + this.getRuleType());
    elParams.empty();
    const els = _.map(desc.params, function(param) {
      return Editor.create(param.type, {
        param,
        parent: this,
        model
      }).render().el;
    }, this);
    elParams.append(els);
  }
});
var SieveRuleGroupEditor$1 = View.Base.extend({
  name: "SieveRuleGroupEditor",
  tagName: "fieldset",
  className: "xrulegroup flex-1",
  postInit: function() {
    this.editors = [];
  },
  addOne: function(config) {
    if (config.type == C$2.TYPE_RULE) {
      this.addRule(config);
    } else if (config.type == C$2.TYPE_RULE_GROUP) {
      this.addRuleGroup(config);
    }
  },
  addEditor: function(editor, isGroup) {
    let btn;
    let wrapper;
    editor.el.style.flex = 1;
    this.$list.append(
      wrapper = DIV(
        {
          "class": `flex items-start ${isGroup ? "py-4 px-4 bl border-gray-400" : ""}`
        },
        editor.el,
        btn = BUTTON(
          { "class": "btn btn-default btn-sm ml-2", title: T("a_del") },
          I({ "class": "fa fa-trash-o" })
        )
      )
    );
    $(btn).click(() => {
      editor.remove();
      wrapper.remove();
      this.editors.splice(_.indexOf(this.editors, editor), 1);
    });
    this.editors.push(editor);
  },
  addRule: function(ruleConfig) {
    ruleConfig || (ruleConfig = this.defaultRule());
    const editor = new SieveRuleEditor({
      model: ruleConfig,
      parent: this
    }).render();
    this.addEditor(editor, false);
  },
  addRuleGroup: function(ruleGroupConfig) {
    ruleGroupConfig || (ruleGroupConfig = this.defaultRuleGroup());
    const editor = new SieveRuleGroupEditor$1({
      model: ruleGroupConfig,
      parent: this
    }).render();
    editor.setConfig(ruleGroupConfig);
    this.addEditor(editor, true);
  },
  defaultRule: function() {
    return {
      type: C$2.TYPE_RULE,
      contentType: C$2.CONTENT_TYPE_CHANGED_TEXT,
      rule: {
        type: C$2.RULE_HAS_TEXT,
        params: { input: "" }
      }
    };
  },
  defaultRuleGroup: function() {
    return {
      type: C$2.TYPE_RULE_GROUP,
      op: C$2.OP_AND,
      rules: [this.defaultRule()]
    };
  },
  getConfig: function() {
    return {
      type: C$2.TYPE_RULE_GROUP,
      op: parseInt(this.selOp.value),
      rules: _.map(this.editors, function(editor) {
        return editor.getConfig();
      })
    };
  },
  isEmpty: function() {
    return this.editors.length == 0;
  },
  onAddClick: function(e) {
    const tag = e.target.getAttribute("tag");
    if (!tag)
      return;
    if (tag == C$2.TYPE_RULE) {
      this.addRule();
    } else if (tag == C$2.TYPE_RULE_GROUP) {
      this.addRuleGroup();
    } else
      ;
  },
  render: function() {
    let list;
    let actions;
    this.$el.append(
      LEGEND(
        T("l_rule_true_if_matches_x") + " ",
        this.selOp = SELECT(
          OPTION({ value: C$2.OP_AND }, T("l_all")),
          OPTION({ value: C$2.OP_OR }, T("l_any"))
        ),
        " " + T("l_x_of_following_rules") + ":",
        actions = DIV(
          { "class": "btn-group xadd-rule right" },
          BUTTON(
            { "class": "btn btn-default btn-sm w-28", "tag": C$2.TYPE_RULE },
            I({ "class": "fa fa-plus" }),
            " ",
            T("a_add")
          ),
          BUTTON({
            "class": "btn btn-default btn-sm dropdown-toggle",
            "data-toggle": "dropdown"
          }, SPAN({ "class": "caret" })),
          UL(
            { "class": "dropdown-menu dropdown-menu-right", "role": "menu" },
            LI(
              A({
                tag: C$2.TYPE_RULE_GROUP,
                tabindex: -1,
                href: "javascript:void 0"
              }, SPRINTF("a_action_object", "a_add", "l_rule_group"))
            )
          )
        )
      ),
      list = DIV({ "class": "space-y-2" })
    );
    $(actions).click(this.onAddClick);
    this.$list = $(list);
    return this;
  },
  setConfig: function(model) {
    this.selOp.value = model.op;
    _.each(this.editors, function(editor) {
      editor.remove();
    });
    this.editors = [];
    _.each(model.rules, this.addOne);
  }
});
const SieveRulesEditorV1$1 = View.ActionProvider.extend({
  name: "SieveRulesEditorV1",
  numberFormat: C$2.NUM_FORMAT_COMMA_DOT,
  actions: {
    add_condition: { fn: "action_add" }
  },
  action_add: function() {
    this.ruleView.addRule();
    this.renderRules();
    this.trigger("onTypeChange");
  },
  postInit: function(options) {
    this.ruleView = new SieveRuleGroupEditor$1({
      parent: this
    }).render();
    if (!this.model.isEmpty()) {
      _.delay(this.onLoad);
    } else {
      this.ruleView.setConfig(this.model.get("config"));
    }
    this.on("onTypeChange", function() {
      let config = this.ruleView.getConfig();
      if (config) {
        let cl = this.elNumFormat.classList;
        if (containsRuleWithNumber(config)) {
          cl.remove("hide");
        } else {
          cl.add("hide");
        }
      }
    });
  },
  onLoad: function() {
    let config = this.model.get("config");
    this.numberFormat = config.numberFormat || C$2.NUM_FORMAT_COMMA_DOT;
    this.ruleView.setConfig(config);
    this.renderRules();
    this.renderNumberFormat();
    this.trigger("onTypeChange");
  },
  render: function() {
    let body;
    this.$el.append(
      body = DIV({ style: "max-height: 600px; overflow-y: auto; overflow-x:hidden;" })
    );
    this.$body = $(body);
    this.renderRules();
    this.renderNumberFormat();
    return this;
  },
  renderRules: function() {
    const $el = this.$body;
    $el.empty();
    if (this.ruleView.isEmpty()) {
      $el.append(
        A({
          href: "#",
          "data-action": "add_condition"
        }, SPRINTF("a_action_object", "a_add", "l_rule"))
      );
    } else {
      $el.append(this.ruleView.el);
    }
  },
  renderNumberFormat: function() {
    this.$el.append(this.elNumFormat = DIV({ "class": "mt-4 hide" }));
    this.viewNumFormat = new NumberFormat({
      target: this.elNumFormat,
      props: {
        format: this.numberFormat
      }
    });
    this.viewNumFormat.$on("change", (e) => this.numberFormat = e.detail);
  },
  remove() {
    SieveRulesEditorV1$1.__super__.remove.call(this);
    this.viewNumFormat.$destroy();
  },
  updateModel: function() {
    const config = this.ruleView.getConfig();
    config.numberFormat = this.numberFormat;
    this.model.set("config", config);
  }
});
function containsRuleWithNumber(config) {
  if (config.type === 1 && !!config.rule) {
    return Rules$1.NumericConditions.includes(config.rule.type);
  } else if (config.type === 2 && config.rules.length > 0) {
    return _.any(config.rules, function(config2) {
      return containsRuleWithNumber(config2);
    });
  }
  return false;
}
function create_default_slot$15(ctx) {
  let t;
  return {
    c() {
      t = text("Learn More");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot$4(ctx) {
  let li;
  let t;
  let menuitemlink;
  let current;
  menuitemlink = new MenuItemLink({
    props: {
      class: "dropdown-item",
      href: URL_WEBSITE + "/docs/web-monitor/using-conditions-to-get-alert-on-important-changes/",
      target: "_blank",
      $$slots: { default: [create_default_slot$15] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      li = element("li");
      t = space();
      create_component(menuitemlink.$$.fragment);
      attr(li, "class", "dropdown-divider");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      insert(target, t, anchor);
      mount_component(menuitemlink, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemlink_changes = {};
      if (dirty & 32) {
        menuitemlink_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemlink.$set(menuitemlink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemlink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemlink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t);
      destroy_component(menuitemlink, detaching);
    }
  };
}
function create_fragment$2D(ctx) {
  let menu;
  let updating_id;
  let current;
  function menu_id_binding(value) {
    ctx[3](value);
  }
  let menu_props = {
    items: ctx[2],
    allowNull: false,
    actionClass: "btn btn-default w-40 text-start",
    style: "text-align: start;",
    disabled: ctx[1],
    $$slots: { bottom: [create_bottom_slot$4] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    menu_props.id = ctx[0];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "id", menu_id_binding));
  menu.$on("search", onSearch);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 2)
        menu_changes.disabled = ctx2[1];
      if (dirty & 32) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        menu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function onSearch(e) {
  e.detail;
}
function instance$2A($$self, $$props, $$invalidate) {
  createEventDispatcher();
  let { id: id2 } = $$props;
  let { disabled: disabled2 } = $$props;
  let items = [
    { id: "$new", name: T("l_text") },
    {
      id: "$diff.new",
      name: T("l_added_text")
    },
    { id: "$diff.old", name: T("l_text_del") },
    { id: "$old", name: T("l_text_old") }
  ];
  function menu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled2 = $$props2.disabled);
  };
  return [id2, disabled2, items, menu_id_binding];
}
class Left extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2A, create_fragment$2D, safe_not_equal, { id: 0, disabled: 1 });
  }
}
function create_fragment$2C(ctx) {
  let searchablemenu;
  let updating_id;
  let current;
  function searchablemenu_id_binding(value) {
    ctx[4](value);
  }
  let searchablemenu_props = {
    items: ctx[1],
    allowNull: false,
    actionClass: "btn btn-default",
    disabled: ctx[2]
  };
  if (ctx[0] !== void 0) {
    searchablemenu_props.id = ctx[0];
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  binding_callbacks.push(() => bind$2(searchablemenu, "id", searchablemenu_id_binding));
  searchablemenu.$on("search", ctx[3]);
  searchablemenu.$on("select", ctx[5]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemenu_changes = {};
      if (dirty & 2)
        searchablemenu_changes.items = ctx2[1];
      if (dirty & 4)
        searchablemenu_changes.disabled = ctx2[2];
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function instance$2z($$self, $$props, $$invalidate) {
  createEventDispatcher();
  let { id: id2 } = $$props;
  let { items = [] } = $$props;
  let { disabled: disabled2 } = $$props;
  let allItems = [...items];
  function onSearch2(e) {
    let query = e.detail.toLowerCase();
    $$invalidate(1, items = allItems.filter((item) => item.name.toLowerCase().includes(query)));
  }
  function searchablemenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  function select_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("items" in $$props2)
      $$invalidate(1, items = $$props2.items);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled2 = $$props2.disabled);
  };
  return [id2, items, disabled2, onSearch2, searchablemenu_id_binding, select_handler];
}
class Operator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2z, create_fragment$2C, safe_not_equal, { id: 0, items: 1, disabled: 2 });
  }
}
function create_if_block_3$w(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-control xform-control-sm");
      attr(input, "type", ctx[3]);
      input.value = ctx[0];
      attr(input, "autocomplete", "off");
      attr(input, "placeholder", ctx[3]);
      input.disabled = ctx[2];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8) {
        attr(input, "type", ctx2[3]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 8) {
        attr(input, "placeholder", ctx2[3]);
      }
      if (dirty & 4) {
        input.disabled = ctx2[2];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$F(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-control xform-control-sm");
      attr(input, "type", ctx[3]);
      input.value = ctx[0];
      attr(input, "autocomplete", "off");
      attr(input, "placeholder", ctx[3]);
      input.disabled = ctx[2];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8) {
        attr(input, "type", ctx2[3]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 8) {
        attr(input, "placeholder", ctx2[3]);
      }
      if (dirty & 4) {
        input.disabled = ctx2[2];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$Y(ctx) {
  let regex;
  let current;
  regex = new Regex({
    props: {
      regex: ctx[4],
      disabled: ctx[2]
    }
  });
  return {
    c() {
      create_component(regex.$$.fragment);
    },
    m(target, anchor) {
      mount_component(regex, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const regex_changes = {};
      if (dirty & 4)
        regex_changes.disabled = ctx2[2];
      regex.$set(regex_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(regex.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(regex.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(regex, detaching);
    }
  };
}
function create_if_block$1k(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Unknown operator - upgrading app maybe needed";
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$2B(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1k, create_if_block_1$Y, create_if_block_2$F, create_if_block_3$w];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!defs[ctx2[1]])
      return 0;
    if (ctx2[3] === "regex")
      return 1;
    if (ctx2[3] == "number")
      return 2;
    if (ctx2[3] != null)
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2y($$self, $$props, $$invalidate) {
  let $fieldStore;
  let { operator } = $$props;
  let { value } = $$props;
  let { disabled: disabled2 } = $$props;
  let type = "text";
  getDef(operator);
  let fieldStore = createFieldStore({ type: "regex" }, value);
  component_subscribe($$self, fieldStore, (value2) => $$invalidate(5, $fieldStore = value2));
  function updateType(operator2) {
    let def = getDef(operator2);
    $$invalidate(3, type = def.fieldType);
  }
  const input_handler = (e) => $$invalidate(0, value = e.target.valueAsNumber);
  const input_handler_1 = (e) => $$invalidate(0, value = e.target.value);
  $$self.$$set = ($$props2) => {
    if ("operator" in $$props2)
      $$invalidate(1, operator = $$props2.operator);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled2 = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      getDef(operator);
    }
    if ($$self.$$.dirty & 32) {
      $$invalidate(0, value = $fieldStore);
    }
    if ($$self.$$.dirty & 2) {
      updateType(operator);
    }
  };
  return [
    value,
    operator,
    disabled2,
    type,
    fieldStore,
    $fieldStore,
    input_handler,
    input_handler_1
  ];
}
class Right extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2y, create_fragment$2B, safe_not_equal, { operator: 1, value: 0, disabled: 2 });
  }
}
function create_fragment$2A(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[0]);
      attr(span, "class", "text-capitalize badge " + ctx[1]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function instance$2x($$self, $$props, $$invalidate) {
  let { result } = $$props;
  let { classes: classes2 = {
    true: "text-bg-light text-success",
    false: "text-bg-light text-danger"
  } } = $$props;
  const finalClass = classes2[result];
  $$self.$$set = ($$props2) => {
    if ("result" in $$props2)
      $$invalidate(0, result = $$props2.result);
    if ("classes" in $$props2)
      $$invalidate(2, classes2 = $$props2.classes);
  };
  return [result, finalClass, classes2];
}
class RuleResult extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2x, create_fragment$2A, safe_not_equal, { result: 0, classes: 2 });
  }
}
function create_if_block_1$X(ctx) {
  let div1;
  let div0;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: { result: ctx[0].result }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(ruleresult.$$.fragment);
      attr(div0, "class", "d-flex");
      attr(div1, "class", "py-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(ruleresult, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 1)
        ruleresult_changes.result = ctx2[0].result;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(ruleresult);
    }
  };
}
function create_if_block$1j(ctx) {
  let button;
  let cross;
  let current;
  let mounted;
  let dispose;
  cross = new Cross$1({ props: { class: "h-5 w-5" } });
  return {
    c() {
      button = element("button");
      create_component(cross.$$.fragment);
      attr(button, "class", "btn btn-default btn-sm flex items-center px-2");
      attr(button, "title", T("a_del"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(cross, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[3]);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      destroy_component(cross);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2z(ctx) {
  let div;
  let left;
  let updating_id;
  let t0;
  let operator;
  let updating_id_1;
  let t1;
  let right;
  let updating_value;
  let t2;
  let t3;
  let current;
  function left_id_binding(value) {
    ctx[5](value);
  }
  let left_props = { disabled: ctx[1] };
  if (ctx[0].expr[1] !== void 0) {
    left_props.id = ctx[0].expr[1];
  }
  left = new Left({ props: left_props });
  binding_callbacks.push(() => bind$2(left, "id", left_id_binding));
  function operator_id_binding(value) {
    ctx[6](value);
  }
  let operator_props = {
    disabled: ctx[1],
    items: ctx[2]
  };
  if (ctx[0].expr[0] !== void 0) {
    operator_props.id = ctx[0].expr[0];
  }
  operator = new Operator({ props: operator_props });
  binding_callbacks.push(() => bind$2(operator, "id", operator_id_binding));
  operator.$on("select", ctx[4]);
  function right_value_binding(value) {
    ctx[7](value);
  }
  let right_props = {
    disabled: ctx[1],
    operator: ctx[0].expr[0]
  };
  if (ctx[0].expr[2] !== void 0) {
    right_props.value = ctx[0].expr[2];
  }
  right = new Right({ props: right_props });
  binding_callbacks.push(() => bind$2(right, "value", right_value_binding));
  let if_block0 = ctx[0].result !== void 0 && create_if_block_1$X(ctx);
  let if_block1 = !ctx[1] && create_if_block$1j(ctx);
  return {
    c() {
      div = element("div");
      create_component(left.$$.fragment);
      t0 = space();
      create_component(operator.$$.fragment);
      t1 = space();
      create_component(right.$$.fragment);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "flex flex-row mb-2 space-x-2 ");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(left, div, null);
      append(div, t0);
      mount_component(operator, div, null);
      append(div, t1);
      mount_component(right, div, null);
      append(div, t2);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const left_changes = {};
      if (dirty & 2)
        left_changes.disabled = ctx2[1];
      if (!updating_id && dirty & 1) {
        updating_id = true;
        left_changes.id = ctx2[0].expr[1];
        add_flush_callback(() => updating_id = false);
      }
      left.$set(left_changes);
      const operator_changes = {};
      if (dirty & 2)
        operator_changes.disabled = ctx2[1];
      if (!updating_id_1 && dirty & 1) {
        updating_id_1 = true;
        operator_changes.id = ctx2[0].expr[0];
        add_flush_callback(() => updating_id_1 = false);
      }
      operator.$set(operator_changes);
      const right_changes = {};
      if (dirty & 2)
        right_changes.disabled = ctx2[1];
      if (dirty & 1)
        right_changes.operator = ctx2[0].expr[0];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        right_changes.value = ctx2[0].expr[2];
        add_flush_callback(() => updating_value = false);
      }
      right.$set(right_changes);
      if (ctx2[0].result !== void 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$X(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1j(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(left.$$.fragment, local);
      transition_in(operator.$$.fragment, local);
      transition_in(right.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(left.$$.fragment, local);
      transition_out(operator.$$.fragment, local);
      transition_out(right.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(left);
      destroy_component(operator);
      destroy_component(right);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$2w($$self, $$props, $$invalidate) {
  let { disabled: disabled2 } = $$props;
  const dispatch = createEventDispatcher();
  let operators = Object.values(defs).map((def) => ({ ...def, name: T("l_" + def.id) })).filter((def) => !["and", "or"].includes(def.id));
  let { rule } = $$props;
  function onDel(event) {
    dispatch("delete");
  }
  function onOperatorChange(e) {
    let op = e.detail;
    let currentValue = rule.expr[2];
    let defaultValue;
    let def = getDef(op);
    if (!def || def.fieldType == "text") {
      if (typeof currentValue == "string") {
        defaultValue = rule.expr[2];
      } else {
        defaultValue = "";
      }
    } else if (def.fieldType == "number") {
      if (typeof currentValue == "number") {
        defaultValue = currentValue;
      } else {
        defaultValue = 0;
      }
    } else {
      if (def.defaultValue) {
        defaultValue = def.defaultValue();
      } else if (def.fieldType != null) {
        throw new Error("cant set default value for rule def:" + def.id);
      }
    }
    $$invalidate(0, rule.expr[2] = defaultValue, rule);
    dispatch("operatorChange", op);
  }
  function left_id_binding(value) {
    if ($$self.$$.not_equal(rule.expr[1], value)) {
      rule.expr[1] = value;
      $$invalidate(0, rule);
    }
  }
  function operator_id_binding(value) {
    if ($$self.$$.not_equal(rule.expr[0], value)) {
      rule.expr[0] = value;
      $$invalidate(0, rule);
    }
  }
  function right_value_binding(value) {
    if ($$self.$$.not_equal(rule.expr[2], value)) {
      rule.expr[2] = value;
      $$invalidate(0, rule);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(1, disabled2 = $$props2.disabled);
    if ("rule" in $$props2)
      $$invalidate(0, rule = $$props2.rule);
  };
  return [
    rule,
    disabled2,
    operators,
    onDel,
    onOperatorChange,
    left_id_binding,
    operator_id_binding,
    right_value_binding
  ];
}
class Condition extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2w, create_fragment$2z, safe_not_equal, { disabled: 1, rule: 0 });
  }
}
function defaultRule() {
  return new SingleRule("contains", "$new", "");
}
function createStore(rules) {
  const { subscribe: subscribe2, set, update } = writable(["or"]);
  set(rules);
  return {
    subscribe: subscribe2,
    set,
    update,
    onAddRuleGrp: function(idxRuleGrp) {
      update((value) => {
        const existingExpr = value.expr[idxRuleGrp + 1];
        existingExpr.expr.push(defaultRule());
        return value;
      });
    },
    addOrCondition: function() {
      update((value) => {
        value.expr.push(new And(defaultRule()));
        return value;
      });
    },
    onRemoveRule: function(idxRuleGrp, idxRule) {
      update((value) => {
        const existingExpr = value.expr[idxRuleGrp + 1];
        existingExpr.expr.splice(idxRule + 1, 1);
        if (existingExpr.expr.length === 1) {
          value.expr.splice(idxRuleGrp + 1, 1);
        }
        return value;
      });
    },
    addRule: function() {
      update((value) => {
        if (value.expr.length === 0) {
          value.expr.push(new Or());
        }
        value.expr.push(new And(defaultRule()));
        return value;
      });
    }
  };
}
function create_fragment$2y(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { fill: "none" },
    { viewBox: "0 0 24 24" },
    { stroke: "currentColor" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "2");
      attr(path, "d", "M12 6v6m0 0v6m0-6h6m-6 0H6");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        { viewBox: "0 0 24 24" },
        { stroke: "currentColor" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$2v($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Plus extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2v, create_fragment$2y, safe_not_equal, {});
  }
}
function get_each_context$G(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function get_each_context_1$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  child_ctx[16] = i2;
  return child_ctx;
}
function create_else_block$M(ctx) {
  let div1;
  let div0;
  let t0_value = T("l_continue_only") + "";
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = ctx[2].expr[1].result !== void 0 && create_if_block_6$7(ctx);
  let each_value = ctx[2].expr.slice(1);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$G(get_each_context$G(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block1 = ctx[3] && create_if_block_1$W(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "mb-1");
      attr(div1, "class", "flex flex-col m-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div1, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t3);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2].expr[1].result !== void 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & 30) {
        each_value = ctx2[2].expr.slice(1);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$G(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$G(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$W(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block$1i(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = `${SPRINTF("a_action_object", "a_add", "l_rule")}`;
      attr(a, "class", "inline-block py-2 px-1");
      attr(a, "href", "#");
      toggle_class(a, "d-none", ctx[1]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[4].addRule));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        toggle_class(a, "d-none", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_6$7(ctx) {
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: { result: ctx[2].expr[1].result }
  });
  return {
    c() {
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 4)
        ruleresult_changes.result = ctx2[2].expr[1].result;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_each_block_1$5(ctx) {
  let condition;
  let current;
  function delete_handler() {
    return ctx[5](ctx[13], ctx[16]);
  }
  condition = new Condition({
    props: {
      rule: ctx[14],
      disabled: ctx[1]
    }
  });
  condition.$on("delete", delete_handler);
  condition.$on("operatorChange", ctx[6]);
  return {
    c() {
      create_component(condition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(condition, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const condition_changes = {};
      if (dirty & 4)
        condition_changes.rule = ctx[14];
      if (dirty & 2)
        condition_changes.disabled = ctx[1];
      condition.$set(condition_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(condition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(condition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(condition, detaching);
    }
  };
}
function create_if_block_4$l(ctx) {
  let div;
  let button;
  let plus;
  let t0;
  let t1_value = T("l_and") + "";
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  plus = new Plus({ props: { class: "h-5 w-5" } });
  function click_handler() {
    return ctx[7](ctx[13]);
  }
  let if_block = ctx[13] + 2 === ctx[2].expr.length && create_if_block_5$e(ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      create_component(plus.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      attr(button, "class", "btn btn-default btn-sm w-24 flex items-center");
      attr(div, "class", "flex flex-row space-x-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      mount_component(plus, button, null);
      append(button, t0);
      append(button, t1);
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[13] + 2 === ctx[2].expr.length) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$e(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(plus.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(plus.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(plus);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$e(ctx) {
  let button;
  let plus;
  let t0;
  let t1_value = T("l_or") + "";
  let t1;
  let current;
  let mounted;
  let dispose;
  plus = new Plus({ props: { class: "h-5 w-5" } });
  return {
    c() {
      button = element("button");
      create_component(plus.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      attr(button, "class", "btn btn-default btn-sm w-24 flex items-center");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(plus, button, null);
      append(button, t0);
      append(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[4].addOrCondition);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(plus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(plus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      destroy_component(plus);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$E(ctx) {
  let div;
  let t0_value = T("l_continue_or") + "";
  let t0;
  let t1;
  let current;
  let if_block = ctx[2].expr[ctx[13] + 2].result !== void 0 && create_if_block_3$v(ctx);
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "mt-4 mb-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2].expr[ctx2[13] + 2].result !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$v(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_3$v(ctx) {
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[2].expr[ctx[13] + 2].result
    }
  });
  return {
    c() {
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 4)
        ruleresult_changes.result = ctx2[2].expr[ctx2[13] + 2].result;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_each_block$G(ctx) {
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let each_value_1 = ctx[11].expr.slice(1);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block0 = !ctx[1] && create_if_block_4$l(ctx);
  let if_block1 = ctx[13] + 2 !== ctx[2].expr.length && create_if_block_2$E(ctx);
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 30) {
        each_value_1 = ctx2[11].expr.slice(1);
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$5(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$l(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[13] + 2 !== ctx2[2].expr.length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$E(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_if_block_1$W(ctx) {
  let numberformat;
  let updating_format;
  let current;
  function numberformat_format_binding(value) {
    ctx[8](value);
  }
  let numberformat_props = {
    class: "mt-4",
    disabled: ctx[1]
  };
  if (ctx[0].numberFormat !== void 0) {
    numberformat_props.format = ctx[0].numberFormat;
  }
  numberformat = new NumberFormat({ props: numberformat_props });
  binding_callbacks.push(() => bind$2(numberformat, "format", numberformat_format_binding));
  return {
    c() {
      create_component(numberformat.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberformat, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberformat_changes = {};
      if (dirty & 2)
        numberformat_changes.disabled = ctx2[1];
      if (!updating_format && dirty & 1) {
        updating_format = true;
        numberformat_changes.format = ctx2[0].numberFormat;
        add_flush_callback(() => updating_format = false);
      }
      numberformat.$set(numberformat_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberformat.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberformat.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberformat, detaching);
    }
  };
}
function create_fragment$2x(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1i, create_else_block$M];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[2] || ctx2[2].expr.length <= 1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2u($$self, $$props, $$invalidate) {
  let $store;
  let { config } = $$props;
  let { disabled: disabled2 = false } = $$props;
  let dispatch = createEventDispatcher();
  let numberFormat = config.numberFormat;
  let store2 = createStore(config.rule);
  component_subscribe($$self, store2, (value) => $$invalidate(2, $store = value));
  let showNumFormat = false;
  const delete_handler = (idxRuleGrp, idxRule) => store2.onRemoveRule(idxRuleGrp, idxRule);
  const operatorChange_handler = (e) => $$invalidate(3, showNumFormat = hasNumeric($store));
  const click_handler = (idxRuleGrp) => store2.onAddRuleGrp(idxRuleGrp);
  function numberformat_format_binding(value) {
    if ($$self.$$.not_equal(config.numberFormat, value)) {
      config.numberFormat = value;
      $$invalidate(0, config);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled2 = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      store2.update((previousRules) => {
        if (config.rule !== previousRules) {
          return config.rule;
        }
        return previousRules;
      });
    }
    if ($$self.$$.dirty & 4) {
      dispatch("change", { rules: $store, numberFormat });
    }
    if ($$self.$$.dirty & 4) {
      $$invalidate(3, showNumFormat = hasNumeric($store));
    }
  };
  return [
    config,
    disabled2,
    $store,
    showNumFormat,
    store2,
    delete_handler,
    operatorChange_handler,
    click_handler,
    numberformat_format_binding
  ];
}
class SieveRulesEditorV2$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2u, create_fragment$2x, safe_not_equal, { config: 0, disabled: 1 });
  }
}
const SieveRulesEditorV2 = View.ActionProvider.extend({
  name: "SieveRulesEditorV2",
  render: function() {
    let body;
    this.$el.append(
      body = DIV({ style: "max-height: 600px;" })
    );
    this.$body = $(body);
    this.renderRules();
    return this;
  },
  renderRules: function() {
    this.config = this.model.get("config");
    this.$body.empty();
    this.view = new SieveRulesEditorV2$1({
      target: this.el,
      props: {
        config: this.config
      }
    });
    this.view.$on("change", (e) => this.config = e.detail);
  },
  remove() {
    SieveRulesEditorV2.__super__.remove.call(this);
    this.view.$destroy();
  },
  updateModel: function() {
    this.model.set("config", this.config);
  }
});
const DescList = [
  {
    type: C$2.RULE_NOT_EMPTY,
    label: "l_not_is_empty",
    params: []
  },
  {
    type: C$2.RULE_HAS_TEXT,
    label: "l_has",
    params: [{
      label: "l_text",
      must: true,
      name: "input",
      type: "text"
    }]
  },
  {
    type: C$2.RULE_HAS_TEXT_NOT,
    label: "l_has_not",
    params: [{
      label: "l_text",
      must: true,
      name: "input",
      type: "text"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_LT,
    label: "l_has_num_lt",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_GT,
    label: "l_has_num_gt",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_DECR_MIN,
    label: "l_has_num_decr_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_INCR_MIN,
    label: "l_has_num_incr_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_DECR_PERCENT_MIN,
    label: "l_has_num_decr_pct_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_HAS_NUMBER_INCR_PERCENT_MIN,
    label: "l_has_num_incr_pct_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$2.RULE_MATCH_REGEX,
    label: "l_match_regex",
    params: [{
      label: "l_regex",
      must: true,
      name: "input",
      type: "regexp"
    }]
  }
];
const ContentList = [{
  type: C$2.CONTENT_TYPE_TEXT,
  label: "l_text"
}, {
  type: C$2.CONTENT_TYPE_CHANGED_TEXT,
  label: "l_added_text"
}, {
  type: C$2.CONTENT_TYPE_OLD_TEXT,
  label: "l_text_old"
}];
const NumericConditions = [
  C$2.RULE_HAS_NUMBER_LT,
  C$2.RULE_HAS_NUMBER_GT,
  C$2.RULE_HAS_NUMBER_DECR_MIN,
  C$2.RULE_HAS_NUMBER_INCR_MIN,
  C$2.RULE_HAS_NUMBER_DECR_PERCENT_MIN,
  C$2.RULE_HAS_NUMBER_INCR_PERCENT_MIN
];
var Rules = {
  ContentList,
  DescList,
  NumericConditions
};
function get_each_context$F(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function create_each_block$F(ctx) {
  let option;
  let t_value = T(ctx[11].label) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[11].type;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_else_block$L(ctx) {
  let inputedit;
  let current;
  inputedit = new InputEdit({
    props: {
      field: ctx[3],
      disabled: ctx[1]
    }
  });
  return {
    c() {
      create_component(inputedit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputedit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputedit_changes = {};
      if (dirty & 8)
        inputedit_changes.field = ctx2[3];
      if (dirty & 2)
        inputedit_changes.disabled = ctx2[1];
      inputedit.$set(inputedit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputedit, detaching);
    }
  };
}
function create_if_block_1$V(ctx) {
  let regex;
  let current;
  regex = new Regex({
    props: {
      regex: ctx[3],
      disabled: ctx[1]
    }
  });
  return {
    c() {
      create_component(regex.$$.fragment);
    },
    m(target, anchor) {
      mount_component(regex, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const regex_changes = {};
      if (dirty & 8)
        regex_changes.regex = ctx2[3];
      if (dirty & 2)
        regex_changes.disabled = ctx2[1];
      regex.$set(regex_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(regex.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(regex.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(regex, detaching);
    }
  };
}
function create_if_block$1h(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "d-flex flex-grow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_key_block$1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1h, create_if_block_1$V, create_else_block$L];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2] === C$2.RULE_NOT_EMPTY)
      return 0;
    if (ctx2[2] === C$2.RULE_MATCH_REGEX)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$2w(ctx) {
  let select;
  let select_value_value;
  let t;
  let previous_key = ctx[3];
  let key_block_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value = Rules.DescList;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$F(get_each_context$F(ctx, each_value, i2));
  }
  let key_block = create_key_block$1(ctx);
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      key_block.c();
      key_block_anchor = empty();
      attr(select, "class", "input-group-text form-select flex-grow-0 w-auto pr-8");
      select.disabled = ctx[1];
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[4].type);
      insert(target, t, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", prevent_default(ctx[6]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 0) {
        each_value = Rules.DescList;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$F(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$F(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & 2) {
        select.disabled = ctx2[1];
      }
      if (!current || dirty & 16 && select_value_value !== (select_value_value = ctx2[4].type)) {
        select_option(select, ctx2[4].type);
      }
      if (dirty & 8 && safe_not_equal(previous_key, previous_key = ctx2[3])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$2t($$self, $$props, $$invalidate) {
  let $rule, $$unsubscribe_rule = noop, $$subscribe_rule = () => ($$unsubscribe_rule(), $$unsubscribe_rule = subscribe(rule, ($$value) => $$invalidate(4, $rule = $$value)), rule);
  $$self.$$.on_destroy.push(() => $$unsubscribe_rule());
  let { rule } = $$props;
  $$subscribe_rule();
  let { disabled: disabled2 } = $$props;
  const dispatch = createEventDispatcher();
  let ruleType = $rule.type;
  let input = rule.fields.params.input;
  let originalRule = rule.toJSON();
  function setInputFieldDef() {
    let value = getOriginalValue(rule.fields.type.get());
    rule.replaceField(input, value);
    $$invalidate(3, input = rule.fields.params.input);
  }
  function getOriginalValue(ruleType2) {
    let type = RuleToTypeMap[ruleType2];
    switch (type) {
      case "regex":
        return originalRule.type === C$2.RULE_MATCH_REGEX ? originalRule.params.input : { expr: "", flags: "" };
      case "text":
        return [C$2.RULE_HAS_TEXT, C$2.RULE_HAS_TEXT_NOT].includes(originalRule.type) ? originalRule.params.input : "";
      case "int":
        return ![C$2.RULE_MATCH_REGEX, C$2.RULE_HAS_TEXT, C$2.RULE_HAS_TEXT_NOT].includes(originalRule.type) ? originalRule.params.input : 0;
    }
  }
  const onRuleTypeChange = (newType) => {
    rule.fields.type.set(newType);
    $$invalidate(2, ruleType = newType);
    setInputFieldDef();
    dispatch("update");
  };
  const change_handler = (e) => onRuleTypeChange(parseInt(e.target.value));
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$subscribe_rule($$invalidate(0, rule = $$props2.rule));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled2 = $$props2.disabled);
  };
  return [rule, disabled2, ruleType, input, $rule, onRuleTypeChange, change_handler];
}
class RuleInput extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2t, create_fragment$2w, safe_not_equal, { rule: 0, disabled: 1 });
  }
}
function get_each_context$E(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  return child_ctx;
}
function create_else_block$K(ctx) {
  let div2;
  let div0;
  let select;
  let select_value_value;
  let t0;
  let ruleinput;
  let t1;
  let t2;
  let t3;
  let div1;
  let current;
  let mounted;
  let dispose;
  let each_value = Rules.ContentList;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$E(get_each_context$E(ctx, each_value, i2));
  }
  ruleinput = new RuleInput({
    props: {
      rule: ctx[0].fields.rule,
      disabled: ctx[1]
    }
  });
  ruleinput.$on("update", ctx[7]);
  let if_block0 = !ctx[1] && create_if_block_2$D(ctx);
  let if_block1 = ctx[2].result !== void 0 && create_if_block_1$U(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      create_component(ruleinput.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div1 = element("div");
      attr(select, "class", "input-group-text form-select flex-grow-0 w-auto pr-8");
      select.disabled = ctx[1];
      attr(div0, "class", "input-group my-2 items-center");
      attr(div2, "class", "d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[2].contentType);
      append(div0, t0);
      mount_component(ruleinput, div0, null);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      append(div2, t3);
      append(div2, div1);
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", prevent_default(ctx[4]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 0) {
        each_value = Rules.ContentList;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$E(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$E(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & 4 && select_value_value !== (select_value_value = ctx2[2].contentType)) {
        select_option(select, ctx2[2].contentType);
      }
      if (!current || dirty & 2) {
        select.disabled = ctx2[1];
      }
      const ruleinput_changes = {};
      if (dirty & 1)
        ruleinput_changes.rule = ctx2[0].fields.rule;
      if (dirty & 2)
        ruleinput_changes.disabled = ctx2[1];
      ruleinput.$set(ruleinput_changes);
      if (!ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$D(ctx2);
          if_block0.c();
          if_block0.m(div0, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[2].result !== void 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$U(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleinput.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(ruleinput.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      destroy_component(ruleinput);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1g(ctx) {
  let div;
  let sieverulegroupeditor;
  let current;
  sieverulegroupeditor = new SieveRuleGroupEditor({
    props: {
      config: ctx[0],
      disabled: ctx[1]
    }
  });
  sieverulegroupeditor.$on("remove", ctx[5]);
  sieverulegroupeditor.$on("update", ctx[6]);
  return {
    c() {
      div = element("div");
      create_component(sieverulegroupeditor.$$.fragment);
      attr(div, "class", "border-start pl-10 my-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(sieverulegroupeditor, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const sieverulegroupeditor_changes = {};
      if (dirty & 1)
        sieverulegroupeditor_changes.config = ctx2[0];
      if (dirty & 2)
        sieverulegroupeditor_changes.disabled = ctx2[1];
      sieverulegroupeditor.$set(sieverulegroupeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieverulegroupeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieverulegroupeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(sieverulegroupeditor);
    }
  };
}
function create_each_block$E(ctx) {
  let option;
  let t_value = T(ctx[9].label) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[9].type;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_2$D(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-trash-o"></i>`;
      attr(button, "class", "btn input-group-text btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[3]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$U(ctx) {
  let div;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: { result: ctx[2].result }
  });
  return {
    c() {
      div = element("div");
      create_component(ruleresult.$$.fragment);
      attr(div, "class", "px-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(ruleresult, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 4)
        ruleresult_changes.result = ctx2[2].result;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(ruleresult);
    }
  };
}
function create_fragment$2v(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1g, create_else_block$K];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].type === 2)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2s($$self, $$props, $$invalidate) {
  let $rule, $$unsubscribe_rule = noop, $$subscribe_rule = () => ($$unsubscribe_rule(), $$unsubscribe_rule = subscribe(rule, ($$value) => $$invalidate(2, $rule = $$value)), rule);
  $$self.$$.on_destroy.push(() => $$unsubscribe_rule());
  let { rule } = $$props;
  $$subscribe_rule();
  let { disabled: disabled2 } = $$props;
  const dispatch = createEventDispatcher();
  function removeRule() {
    dispatch("remove");
  }
  function changeRuleType(e) {
    let newType = e.target.value;
    rule.fields.contentType.set(newType);
  }
  function remove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$subscribe_rule($$invalidate(0, rule = $$props2.rule));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled2 = $$props2.disabled);
  };
  return [
    rule,
    disabled2,
    $rule,
    removeRule,
    changeRuleType,
    remove_handler,
    update_handler,
    update_handler_1
  ];
}
class RuleTypeEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2s, create_fragment$2v, safe_not_equal, { rule: 0, disabled: 1 });
  }
}
function get_each_context$D(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  child_ctx[9] = i2;
  return child_ctx;
}
function create_each_block$D(key_1, ctx) {
  let first;
  let ruletypeeditor;
  let current;
  function remove_handler() {
    return ctx[5](ctx[9]);
  }
  ruletypeeditor = new RuleTypeEditor({
    props: {
      rule: ctx[7],
      disabled: ctx[1]
    }
  });
  ruletypeeditor.$on("update", ctx[4]);
  ruletypeeditor.$on("remove", remove_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(ruletypeeditor.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(ruletypeeditor, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const ruletypeeditor_changes = {};
      if (dirty & 4)
        ruletypeeditor_changes.rule = ctx[7];
      if (dirty & 2)
        ruletypeeditor_changes.disabled = ctx[1];
      ruletypeeditor.$set(ruletypeeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruletypeeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruletypeeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(ruletypeeditor, detaching);
    }
  };
}
function create_fragment$2u(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ctx[2];
  const get_key = (ctx2) => ctx2[7]._iid;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$D(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$D(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 14) {
        each_value = ctx2[2];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$D, null, get_each_context$D);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function instance$2r($$self, $$props, $$invalidate) {
  let $rules, $$unsubscribe_rules = noop, $$subscribe_rules = () => ($$unsubscribe_rules(), $$unsubscribe_rules = subscribe(rules, ($$value) => $$invalidate(2, $rules = $$value)), rules);
  $$self.$$.on_destroy.push(() => $$unsubscribe_rules());
  const dispatch = createEventDispatcher();
  let { rules } = $$props;
  $$subscribe_rules();
  let { disabled: disabled2 } = $$props;
  function removeRule(i2) {
    rules.remove(i2);
    dispatch("update");
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  const remove_handler = (i2) => removeRule(i2);
  $$self.$$set = ($$props2) => {
    if ("rules" in $$props2)
      $$subscribe_rules($$invalidate(0, rules = $$props2.rules));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled2 = $$props2.disabled);
  };
  return [rules, disabled2, $rules, removeRule, update_handler, remove_handler];
}
class RuleList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2r, create_fragment$2u, safe_not_equal, { rules: 0, disabled: 1 });
  }
}
function create_if_block_1$T(ctx) {
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: { result: ctx[3].result }
  });
  return {
    c() {
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 8)
        ruleresult_changes.result = ctx2[3].result;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_if_block$1f(ctx) {
  let div1;
  let div0;
  let button0;
  let t1;
  let button1;
  let t3;
  let ul;
  let li;
  let a;
  let t5;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.innerHTML = `<i class="fa fa-plus mr-2"></i>
        Add Rule`;
      t1 = space();
      button1 = element("button");
      button1.innerHTML = `<span class="visually-hidden">Toggle Dropdown</span>`;
      t3 = space();
      ul = element("ul");
      li = element("li");
      a = element("a");
      a.textContent = "Add Compound Rule";
      t5 = space();
      button2 = element("button");
      button2.innerHTML = `<i class="fa fa-trash-o"></i>`;
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-outline-dark");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-outline-dark dropdown-toggle dropdown-toggle-split");
      attr(button1, "data-bs-toggle", "dropdown");
      attr(button1, "aria-expanded", "false");
      attr(a, "class", "dropdown-item");
      attr(ul, "class", "dropdown-menu");
      attr(button2, "class", "btn btn-outline-dark");
      attr(div0, "class", "input-group input-group-sm bg-white");
      attr(div1, "class", "mx-2 ");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, button1);
      append(div0, t3);
      append(div0, ul);
      append(ul, li);
      append(li, a);
      append(div0, t5);
      append(div0, button2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", prevent_default(ctx[7])),
          listen(a, "click", prevent_default(ctx[8])),
          listen(button2, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2t(ctx) {
  let div4;
  let div3;
  let div0;
  let t1;
  let div1;
  let select;
  let option0;
  let t2;
  let option1;
  let t3;
  let select_value_value;
  let t4;
  let div2;
  let t5_value = T("l_x_of_following_rules") + "";
  let t5;
  let t6;
  let t7;
  let t8;
  let rulelist;
  let updating_rules;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[3].result !== void 0 && create_if_block_1$T(ctx);
  let if_block1 = !ctx[1] && create_if_block$1f(ctx);
  function rulelist_rules_binding(value) {
    ctx[10](value);
  }
  let rulelist_props = { disabled: ctx[1] };
  if (ctx[2] !== void 0) {
    rulelist_props.rules = ctx[2];
  }
  rulelist = new RuleList({ props: rulelist_props });
  binding_callbacks.push(() => bind$2(rulelist, "rules", rulelist_rules_binding));
  rulelist.$on("update", ctx[11]);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      div0.textContent = `${T("l_rule_true_if_matches_x")}`;
      t1 = space();
      div1 = element("div");
      select = element("select");
      option0 = element("option");
      t2 = text("Any");
      option1 = element("option");
      t3 = text("All");
      t4 = space();
      div2 = element("div");
      t5 = text(t5_value);
      t6 = text(":\n      ");
      if (if_block0)
        if_block0.c();
      t7 = space();
      if (if_block1)
        if_block1.c();
      t8 = space();
      create_component(rulelist.$$.fragment);
      attr(div0, "class", "pt-2");
      option0.__value = C$2.OP_OR;
      option0.value = option0.__value;
      option1.__value = C$2.OP_AND;
      option1.value = option1.__value;
      attr(select, "class", "form-select form-select-sm");
      select.disabled = ctx[1];
      attr(div1, "class", "mx-2");
      attr(div2, "class", "pt-2");
      attr(div3, "class", "d-flex align-items-center");
      attr(div4, "class", "d-flex justify-content-between mt-4");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div3, t1);
      append(div3, div1);
      append(div1, select);
      append(select, option0);
      append(option0, t2);
      append(select, option1);
      append(option1, t3);
      select_option(select, ctx[3].op);
      append(div3, t4);
      append(div3, div2);
      append(div2, t5);
      append(div2, t6);
      if (if_block0)
        if_block0.m(div2, null);
      append(div4, t7);
      if (if_block1)
        if_block1.m(div4, null);
      insert(target, t8, anchor);
      mount_component(rulelist, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 8 && select_value_value !== (select_value_value = ctx2[3].op)) {
        select_option(select, ctx2[3].op);
      }
      if (!current || dirty & 2) {
        select.disabled = ctx2[1];
      }
      if (ctx2[3].result !== void 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$T(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1f(ctx2);
          if_block1.c();
          if_block1.m(div4, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      const rulelist_changes = {};
      if (dirty & 2)
        rulelist_changes.disabled = ctx2[1];
      if (!updating_rules && dirty & 4) {
        updating_rules = true;
        rulelist_changes.rules = ctx2[2];
        add_flush_callback(() => updating_rules = false);
      }
      rulelist.$set(rulelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(rulelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(rulelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t8);
      destroy_component(rulelist, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$2q($$self, $$props, $$invalidate) {
  let $config, $$unsubscribe_config = noop, $$subscribe_config = () => ($$unsubscribe_config(), $$unsubscribe_config = subscribe(config, ($$value) => $$invalidate(3, $config = $$value)), config);
  $$self.$$.on_destroy.push(() => $$unsubscribe_config());
  let { config } = $$props;
  $$subscribe_config();
  let { disabled: disabled2 } = $$props;
  const dispatch = createEventDispatcher();
  let ruleFields = config.fields.rules;
  function addRule(compound) {
    let newRule;
    newRule = ruleFields.getDefaultValue(compound);
    ruleFields.add(newRule);
  }
  function changeOp(e) {
    let newOp = e.target.value;
    config.fields.op.set(newOp);
    dispatch("update");
  }
  const click_handler = () => addRule(false);
  const click_handler_1 = () => addRule(true);
  const click_handler_2 = () => dispatch("remove");
  function rulelist_rules_binding(value) {
    ruleFields = value;
    $$invalidate(2, ruleFields);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$subscribe_config($$invalidate(0, config = $$props2.config));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled2 = $$props2.disabled);
  };
  return [
    config,
    disabled2,
    ruleFields,
    $config,
    dispatch,
    addRule,
    changeOp,
    click_handler,
    click_handler_1,
    click_handler_2,
    rulelist_rules_binding,
    update_handler
  ];
}
class SieveRuleGroupEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2q, create_fragment$2t, safe_not_equal, { config: 0, disabled: 1 });
  }
}
function get_each_context$C(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function create_else_block$J(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Add Condition";
      attr(a, "class", "inline-block py-2 px-1");
      attr(a, "href", "#");
      toggle_class(a, "d-none", ctx[1]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[9]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        toggle_class(a, "d-none", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1e(ctx) {
  let div;
  let sieverulegroupeditor;
  let t;
  let current;
  sieverulegroupeditor = new SieveRuleGroupEditor({
    props: {
      config: ctx[0],
      disabled: ctx[1]
    }
  });
  sieverulegroupeditor.$on("remove", ctx[8]);
  sieverulegroupeditor.$on("update", ctx[6]);
  let if_block = ctx[4] && create_if_block_1$S(ctx);
  return {
    c() {
      div = element("div");
      create_component(sieverulegroupeditor.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(sieverulegroupeditor, div, null);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const sieverulegroupeditor_changes = {};
      if (dirty & 1)
        sieverulegroupeditor_changes.config = ctx2[0];
      if (dirty & 2)
        sieverulegroupeditor_changes.disabled = ctx2[1];
      sieverulegroupeditor.$set(sieverulegroupeditor_changes);
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$S(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sieverulegroupeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieverulegroupeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(sieverulegroupeditor);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$S(ctx) {
  let div;
  let span;
  let t1;
  let select;
  let select_value_value;
  let mounted;
  let dispose;
  let each_value = ctx[5];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$C(get_each_context$C(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = "Number Format:";
      t1 = space();
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(span, "class", "pr-2");
      attr(select, "class", "form-select w-56");
      select.disabled = ctx[1];
      attr(div, "class", "d-flex align-items-center mt-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t1);
      append(div, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[2].numberFormat);
      if (!mounted) {
        dispose = listen(select, "change", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32) {
        each_value = ctx2[5];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$C(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$C(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 36 && select_value_value !== (select_value_value = ctx2[2].numberFormat)) {
        select_option(select, ctx2[2].numberFormat);
      }
      if (dirty & 2) {
        select.disabled = ctx2[1];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$C(ctx) {
  let option;
  let t0_value = T(ctx[11].label) + "";
  let t0;
  let t1;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = ctx[11].value;
      option.value = option.__value;
      attr(option, "title", T(ctx[11].title));
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$2s(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1e, create_else_block$J];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2p($$self, $$props, $$invalidate) {
  let $config, $$unsubscribe_config = noop, $$subscribe_config = () => ($$unsubscribe_config(), $$unsubscribe_config = subscribe(config, ($$value) => $$invalidate(2, $config = $$value)), config);
  $$self.$$.on_destroy.push(() => $$unsubscribe_config());
  let { config } = $$props;
  $$subscribe_config();
  let { disabled: disabled2 = false } = $$props;
  let showConditions = false;
  const OPTIONS = [
    {
      label: "rule_comma_dot",
      title: "title_format_option_comma_dot",
      value: C$2.NUM_FORMAT_COMMA_DOT
    },
    {
      label: "rule_dot_comma",
      title: "title_format_option_dot_comma",
      value: C$2.NUM_FORMAT_DOT_COMMA
    },
    {
      label: "rule_space_comma",
      title: "title_format_option_space_comma",
      value: C$2.NUM_FORMAT_SPACE_COMMA
    }
  ];
  let hasNumeric2 = config.hasNumeric();
  let numberFormat = config.fields.numberFormat;
  function updateNumeric() {
    $$invalidate(4, hasNumeric2 = config.hasNumeric());
  }
  function changeNumberFormat(e) {
    let newFormat = e.target.value;
    numberFormat.set(newFormat);
  }
  function removeRules() {
    config.fields.rules.set([]);
    $$invalidate(3, showConditions = false);
  }
  const click_handler = () => {
    $$invalidate(3, showConditions = true);
  };
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$subscribe_config($$invalidate(0, config = $$props2.config));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled2 = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      if ($config.rules.length > 0) {
        $$invalidate(3, showConditions = true);
      }
    }
  };
  return [
    config,
    disabled2,
    $config,
    showConditions,
    hasNumeric2,
    OPTIONS,
    updateNumeric,
    changeNumberFormat,
    removeRules,
    click_handler
  ];
}
class SieveRulesEditorV1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2p, create_fragment$2s, safe_not_equal, { config: 0, disabled: 1 });
  }
}
function create_fragment$2r(ctx) {
  let div;
  let p0;
  let t1;
  let p1;
  return {
    c() {
      div = element("div");
      p0 = element("p");
      p0.textContent = "Please upgrade to the latest version of app/extension.";
      t1 = space();
      p1 = element("p");
      p1.textContent = `This condition was created using a newer version of the app which is not supported by this version. Current version is ${ctx[0]}`;
      attr(div, "class", "p-2 text-base");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p0);
      append(div, t1);
      append(div, p1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$2o($$self) {
  let currentVersion = Supports.agents && Supports.agents.local ? serviceProxy.CFG.VERSION : "1.0.0";
  return [currentVersion];
}
class VersionUpdateMsg extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2o, create_fragment$2r, safe_not_equal, {});
  }
}
const { V1, V2 } = Model$2.SieveRule;
const SieveRuleWrapper = View.ActionProvider.extend({
  name: "SieveRuleWrapper",
  actions: {
    action_global_rules: { fn: "action_global_rules" }
  },
  action_global_rules() {
    showGlobalRuleEditor();
  },
  postInit(options) {
    if (!this.model.isNew()) {
      this.loading = true;
      this.model.fetch({
        success: this.onLoad,
        error: this.onError
      });
    }
    this.listenTo(this.model, "change:version", this.renderEditor);
    this.listenTo(App.user, "change:prefs", this.renderGlobalCount);
  },
  onError() {
    this.loading = false;
    this.$body.empty();
    this.$body.append(T("e_req"), " ", T("h_try_later"));
  },
  onLoad() {
    this.loading = false;
    this.renderEditor();
  },
  getGlobalRuleModel() {
    var _a;
    let config = (_a = App.user.get("prefs")) == null ? void 0 : _a.rule;
    let version = (config == null ? void 0 : config.version) || V1;
    return new Model$2.SieveRule({ config, version });
  },
  render() {
    let elVersion;
    this.$el.append(
      DIV(
        { class: "flex gap-4" },
        elVersion = DIV({ class: "dropdown relative" }),
        this.options.global ? "" : A(
          {
            href: "#",
            "data-action": "action_global_rules"
          },
          "Global Conditions: ",
          this.elGlobalCount = SPAN()
        )
      ),
      this.$body = $(DIV())
    );
    this.$elVersion = $(elVersion);
    this.$elVersion.on("click", "li", this.onVersionSelection);
    this.renderGlobalCount();
    if (this.loading) {
      this.$body.text(T("l_loading"));
    } else {
      this.renderEditor();
    }
    return this;
  },
  renderGlobalCount() {
    let globalRule = this.getGlobalRuleModel();
    $(this.elGlobalCount).text(globalRule.getCount());
  },
  onVersionSelection(e) {
    this.model.setVersion(e.target.id);
    e.preventDefault();
  },
  renderEditor() {
    let version = this.model.get("version");
    if (USER.features.rule_default) {
      this.renderVersion(version);
    } else {
      this.$elVersion.remove();
    }
    const $el = this.$body;
    $el.empty();
    if (version && version !== V1 && version !== V2) {
      new VersionUpdateMsg({ target: this.$el[0] });
    } else if (version === V1) {
      this.editor = new SieveRulesEditorV1({ target: this.$el[0], props: { model: this.model } });
      $el.append(this.editor.el);
    } else {
      this.editor = new SieveRulesEditorV2({ ..._.omit(this.options, "el"), parent: this }).render();
      $el.append(this.editor.el);
    }
  },
  renderVersion(version) {
    const href2 = "javascript: void 0";
    this.$elVersion.empty().append(
      A({ href: href2, class: "dropdown-toggle", "data-bs-toggle": "dropdown" }, `Version: v${version[0]}`, " ", B({ class: "caret" })),
      UL(
        { class: "dropdown-menu" },
        LI({ class: "dropdown-header" }, "Change condition version"),
        LI({ class: version == V1 ? "active" : "" }, A({ href: href2, id: V1 }, `v${V1[0]} (classic)`)),
        LI({ class: version == V2 ? "active" : "" }, A({ href: href2, id: V2 }, `v${V2[0]} (modern)`))
      )
    );
  },
  async duplicate(fromId) {
    const model = new Model$2.SieveRule({ id: fromId });
    await model.fetch({
      success: () => {
        this.model.set(_.omit(model.attributes, "id", "ts", "ts_mod"));
        this.onLoad();
      }
    });
  },
  updateModel() {
    if (this.editor) {
      this.editor.updateModel();
    }
  }
});
async function showGlobalRuleEditor() {
  if (!USER.id) {
    return alert("Please sign in to save global conditions");
  }
  let prefs = App.user.get("prefs") || {};
  let config = prefs.rule;
  let version = (config == null ? void 0 : config.version) || V1;
  let model = new Model$2.SieveRule({ config, version });
  let view = new SieveRuleWrapper({ model, global: true, parent: App.root });
  const modal = new View.SaveDiscardModal({
    name: "GlobalRuleEditor$SaveDiscardModal",
    title: "Global Conditions",
    titleEx: `used for all monitors and combined with each monitor's conditions`,
    view,
    parent: App.root
  });
  modal.on("save", async () => {
    modal.remove();
    view.updateModel();
    let config2 = model.get("config");
    let version2 = model.get("version");
    try {
      await Api.api("/prefs/rule", "PUT", { ...config2, version: version2 });
      USER.prefs.rule = config2;
    } catch (e) {
      console.error(e);
      Msg.error("Failed to save data, please try again later");
    }
  });
  modal.on("discard", () => {
    modal.remove();
  });
  modal.show();
}
const Backbone$4 = window.Backbone;
function getInterval($el, defaultUnit = "m", defaultValue = 120) {
  const units = { "s": 1, "m": 60, "h": 3600, "d": 86400, "w": 604800 };
  const parts = $el.val().trim().replace(/\s+/g, "").split(/(\d*\.*\d*)/);
  const num = parseInt(parts[1]) || defaultValue;
  const unit = (parts[2] || "").toLowerCase()[0] || defaultUnit;
  const value = num * units[unit];
  return value;
}
const WEEK_DAY_INDEX = ["Sunday", "Monday", "Tuesday", "Thursday", "Friday", "Saturday", "Sunday"];
const MONTH_INDEX = ["", "Jan", "Feb", "March", "April", "May", "June", "July", "August", "Sep", "Oct", "Nov", "Dec"];
class SieveCronScheduleEditor extends Base$2 {
  constructor(options) {
    super({
      ...options.model.toJSON(),
      params: options.model.get("schedule").toJSON().params
    });
    this.model = options.model;
    this.schedule = this.model.get("schedule");
    this.el.classList.add("xtype-group");
    this.el.classList.add("inline-block");
    this.el.style.minWidth = "480px";
  }
  onChange(name, value) {
    const index2 = ["m", "h", "dm", "mon", "dw"].indexOf(name);
    const params2 = { ...this.state.params };
    const { expr } = params2;
    const parts = expr.split(/\s/g);
    parts[index2] = value;
    params2.expr = parts.join(" ");
    this.state.params = params2;
    if (parts.length == 5 && _.all(parts, (p) => p.length > 0)) {
      this.setModelParams(params2);
    }
  }
  onPresetClick(e) {
    e.preventDefault();
    const params2 = { ...this.state.params };
    params2.expr = e.target.dataset.expr;
    this.state.params = params2;
    this.setModelParams(params2);
  }
  setModelParams(params2) {
    this.schedule.set("params", new Backbone$4.Model(params2));
    this.model.trigger("change:schedule", this.model);
  }
  getDesc({ m, h, dm, mon, dw }) {
    function unit(name, val) {
      if (val.includes(",")) {
        const parts = val.split(",").map((expr) => unit(name, expr));
        const last = parts.pop();
        return `${parts.join(", ")} and ${last}`;
      }
      if ("*" == val) {
        return `every ${name}`;
      }
      if (val.includes("-")) {
        let [start, end] = val.split("-");
        if (name == "month") {
          start = MONTH_INDEX[start];
          end = MONTH_INDEX[end];
        }
        if (name == "day-of-week") {
          start = WEEK_DAY_INDEX[start];
          end = WEEK_DAY_INDEX[end - 1];
        }
        return `every ${name} from ${start} through ${end}`;
      }
      if (val.includes("/")) {
        let [start, step] = val.split("/");
        const end = "";
        let startText = "every";
        if (step > 1) {
          const suffixes = ["", "st", "nd", "rd"];
          startText = step + (suffixes[step] || "th");
        }
        if ("*" == start) {
          start = null;
        } else if (name == "month") {
          start = MONTH_INDEX[start];
        } else if (name == "day-of-week") {
          start = WEEK_DAY_INDEX[start];
        }
        return `every  ${startText} ${name} ${start ? `from ${start} through ${end}` : ""}`;
      }
      if (name == "month") {
        val = MONTH_INDEX[val];
        name = "";
      }
      if (name == "day-of-week") {
        val = WEEK_DAY_INDEX[val];
        name = "";
      }
      return `${name} ${val}`;
    }
    try {
      return `At ${unit("minute", m)} past ${unit("hour", h)} on ${unit("day-of-week", dw)} in ${unit("month", mon)}`;
    } catch (e) {
      console.error(e, arguments[0]);
      return "Invalid expression";
    }
  }
  createTpl({ params: params2 }) {
    const expr = params2.expr;
    params2.tz || new Date().getTimezoneOffset();
    const [m, h, dm, mon, dw] = expr.split(/\s/g);
    const attrMap = { m, h, dm, mon, dw };
    const desc = this.getDesc(attrMap);
    const names = {
      m: "Minute",
      h: "Hour",
      dm: "Day",
      mon: "Month",
      dw: "Weekday"
    };
    return html`
      <table>
        <thead>
          ${_.map(names, (name, key) => {
      return html`<th class='col-md-2'>${name}</th>`;
    })}
          <th></th>
        </thead>
        <tbody>
          <tr>
            ${_.map(names, (name, key) => {
      return html`
                <td class='col-md-2'>
                  <input
                    style='width: 60px; padding: 0 10px;'
                    .value=${attrMap[key]}
                    placeholder=${name}
                    @keyup=${(e) => this.onChange(key, e.target.value)}>
                  </input>
                </td>
                `;
    })}
            <td>
              <div class='dropdown'>
                <a href='#' data-toggle='dropdown'>Use Preset <i class='fa fa-caret-down'></i></a>
                <ul class='dropdown-menu' @click=${(e) => this.onPresetClick(e)}>
                  <li><a href='#' data-expr='0 9 * * 1-5'>Weekdays at 9am</a></li>
                  <li><a href='#' data-expr='0 9-17 * * 1-5'>Weekdays between 9am to 5pm</a></li>
                  <li><a href='#' data-expr='0 9 * * *'>All days at 9am</a></li>
                  <li><a href='#' data-expr='0 9-17 * * *'>All days between 9am to 5pm</a></li>
                </ul>
              </div>
            </td>
          </tr>
          <tr>
            <td
              style='width: 60px; padding: 0 12px;'
              colspan=6><div class='help'>
                ${desc}
              </div>
            </td>
          </tr>
        </tbody>
      </table>
    `;
  }
  remove() {
  }
  render() {
    return this;
  }
}
var SieveIntervalScheduleEditor = View.ActionProvider.extend({
  name: "SieveIntervalScheduleEditor",
  convertToSlider: function(v) {
    return Math.log(v);
  },
  convertToModel: function(v) {
    return Math.round(Math.pow(Math.E, v));
  },
  focus: function() {
    this.textInput.focus();
  },
  getSliderValue: function() {
    return this.convertToModel(this.$slider.val());
  },
  setSliderValue: function(value) {
    this.$slider.slider("setValue", this.convertToSlider(value));
  },
  remove: function() {
    if (this.$slider.data("slider")) {
      this.$slider.slider("destroy");
    }
    SieveIntervalScheduleEditor.__super__.remove.call(this);
  },
  render: function() {
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    const interval = params2.get("interval");
    const value = this.convertToSlider(interval);
    this.$el.empty().append(
      DIV(
        { style: "display:flex;min-width:420px;margin-bottom:25px;" },
        this.slider = INPUT({
          style: "width:100%;",
          value
        }),
        this.textInput = INPUT({ "class": "xschdlr-input" })
      ),
      SPAN(
        { "class": "help" },
        this.constraint = SPAN(
          { style: "color: red; display: none;" },
          T("h_schedule_constraint_1"),
          T(formatInterval(USER.constraint.interval, false) + "."),
          BR(),
          T("h_schedule_constraint_2"),
          A({ "href": "https://distill.io/pricing", "target": "_blank" }, "Upgrade Account")
        )
      ),
      P(
        { "class": "help" },
        T("h_schedule_interval")
      )
    );
    this.$constraint = $(this.constraint);
    this.$slider = $(this.slider).slider({
      min: 1.6,
      max: 14.78,
      step: 0.05,
      tooltip: "hide",
      value,
      "ticks": [1.6, 3.4, 5.7, 8.3, 11.55, 14.78],
      "ticks_positions": [0, 13.657, 31.107, 50.834, 75.493, 100],
      "ticks_labels": ["5s", "30s", "5m", "1h", "1d", "Never"],
      "ticks_snap_bounds": 0
    }).on("slide", this.updateValue).on("slideStop", this.updateModel);
    this.$textInput = $(this.textInput).on("change", this.textInputChanged).on("focus", function() {
      this.select();
    });
    this.updateValue();
    return this;
  },
  textInputChanged: function() {
    const value = getInterval(this.$textInput, "m", 3600);
    this.setSliderValue(value);
    this.updateValue();
    this.updateModel();
  },
  updateModel: function() {
    this.updateValue();
    this.model.get("schedule");
    this.model.trigger("change");
    this.model.trigger("change:schedule", this.model);
  },
  updateValue: function() {
    const seconds = this.getSliderValue();
    const client_id = this.model.get("client_id");
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    const constraint = USER && USER.constraint;
    const minInt = constraint && constraint.interval || 5;
    if (client_id == ModelClient.Clients.webAppId && seconds < minInt) {
      params2.set("interval", USER.constraint.interval);
      this.$constraint.css("display", "block");
    } else {
      params2.set("interval", seconds);
      this.$constraint.css("display", "none");
    }
    this.$textInput.val(getShortDisplayText(schedule.attributes));
  }
});
const SieveLiveScheduleEditor = View.ActionProvider.extend({
  name: "SieveLiveScheduleEditor",
  render: function() {
    this.$el.append(
      DIV("Use it only if page auto-updates content using JavaScript."),
      DIV({ "class": "help" }, T("l_schedule_live_desc"))
    );
    return this;
  }
});
const SieveRandomScheduleEditor = View.ActionProvider.extend({
  name: "SieveRandomScheduleEditor",
  render: function() {
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    this.$el.empty().append(
      DIV(
        SPAN("Min: "),
        this.minInput = INPUT({ "class": "xschdlr-input" }),
        SPAN({ style: "margin-left: 20px;" }, "Max: "),
        this.maxInput = INPUT({ "class": "xschdlr-input" })
      ),
      SPAN(
        { "class": "help" },
        this.constraint = SPAN(
          { style: "color: black; display: none;" },
          T("h_schedule_constraint_1"),
          T(USER.constraint.interval + " seconds. "),
          BR(),
          T("h_schedule_constraint_2"),
          A({ "href": "https://distill.io/pricing", "target": "_blank" }, "Upgrade Account")
        )
      ),
      P(
        { "class": "help" },
        T("h_schedule_random")
      )
    );
    this.$constraint = $(this.constraint);
    (this.$minInput = $(this.minInput)).val(params2.get("min"));
    (this.$maxInput = $(this.maxInput)).val(params2.get("max"));
    $([this.minInput, this.maxInput]).on("change", this.updateModel);
    this.updateValue();
    return this;
  },
  updateModel: function() {
    this.updateValue();
    this.model.get("schedule");
    this.model.trigger("change");
    this.model.trigger("change:schedule", this.model);
  },
  updateValue: function() {
    if (getInterval(this.$minInput, "s") > getInterval(this.$maxInput, "s")) {
      var maxSecs = Math.max(this.model.get("client_id") == ModelClient.Clients.webAppId ? USER.constraint.interval : 5, getInterval(this.$minInput, "s") + 1);
    } else {
      var maxSecs = Math.max(this.model.get("client_id") == ModelClient.Clients.webAppId ? USER.constraint.interval : 5, getInterval(this.$maxInput, "s"));
    }
    const minSecs = Math.max(this.model.get("client_id") == ModelClient.Clients.webAppId ? USER.constraint.interval : 5, getInterval(this.$minInput, "s"));
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    const client_id = this.model.get("client_id");
    const constraint = USER && USER.constraint;
    constraint && constraint.interval || 5;
    params2.set("min", minSecs);
    params2.set("max", maxSecs);
    this.$minInput.val(minSecs);
    this.$maxInput.val(maxSecs);
    if (client_id == ModelClient.Clients.webAppId) {
      this.$constraint.css("display", "block");
    } else {
      this.$constraint.css("display", "none");
    }
  }
});
var SieveScheduleEditor = View.ActionProvider.extend({
  name: "SieveScheduleEditor",
  EDITORS: {
    "INTERVAL": SieveIntervalScheduleEditor,
    "LIVE": SieveLiveScheduleEditor,
    "RANDOM": SieveRandomScheduleEditor,
    "CRON": SieveCronScheduleEditor
  },
  focus: function() {
  },
  render: function() {
    let elSelect;
    let elEditor;
    var schedule = this.model.get("schedule");
    const type = schedule.get("type");
    Supports.agents.local;
    let editor = new this.EDITORS[type](_.extend({ parent: this }, _.omit(this.options, "el")));
    this.$el.css({
      "display": "flex",
      "flex-direction": "row"
    }).empty().append(
      DIV(
        elSelect = SELECT(
          { style: "margin-right: 20px;" },
          OPTION({ value: "INTERVAL" }, "Interval"),
          OPTION({ value: "RANDOM" }, "Random"),
          OPTION({ value: "LIVE" }, "Live (beta)"),
          USER.account_id ? OPTION({ value: "CRON" }, "Crontab *") : OPTION({ value: "CRON", disabled: "" }, "Crontab *"),
          OPTION({ value: "", disabled: "" }, "*For Enterprise")
        )
      ),
      elEditor = DIV({ style: "flex:1" }, editor.render().el)
    );
    $(elSelect).val(type).on("change", () => {
      const type2 = elSelect.value;
      const schedule2 = new Model$2.Schedule({ type: type2 });
      if (type2 == "RANDOM") {
        schedule2.get("params").set({ min: 60, max: 120 });
      }
      if (type2 == "CRON") {
        schedule2.get("params").set({
          expr: "* * * * *",
          tz: new Date().getTimezoneOffset()
        });
      }
      editor.remove();
      this.model.set("schedule", schedule2);
      editor = new this.EDITORS[type2](_.extend({ parent: this }, _.omit(this.options, "el")));
      $(elEditor).empty().append(editor.render().el);
    });
    return this;
  }
});
var TagsEditor$1 = View.Base.extend({
  name: "TagsEditor",
  className: "flex flex-wrap",
  events: {
    "click :checkbox": "event_check"
  },
  event_check: function(e) {
    const el = e.target;
    const id2 = el.dataset.id;
    const checked = el.checked;
    const tag = App.labels.get(id2);
    if (checked) {
      this.tags.push(tag);
    } else {
      this.tags = _.without(this.tags, tag);
    }
    this.model.set("tags", _.pluck(this.tags, "id").join(","));
  },
  postInit: function() {
    this.tags = this.model.getTags(App.labels);
    this.listenTo(App.labels, "sync", this.render);
  },
  render: function() {
    this.$el.empty();
    if (App.labels.length > 0) {
      this.$el.append(_.map(App.labels.models, (tag) => {
        const input = INPUT({
          "type": "checkbox",
          "style": "vertical-align: top; margin: 0 4px;",
          "data-id": tag.id
        });
        const el = LABEL({
          "class": "flex font-normal mr-2"
        }, input, tag.get("name"));
        if (this.tags.indexOf(tag) >= 0) {
          input.checked = true;
        }
        return el;
      }));
    } else {
      this.$el.append("No label found.");
    }
    return this;
  }
});
const domo$2 = window.domo;
if (!domo$2) {
  throw new Error("ADD domo");
}
function SieveConstraints(constraint) {
  return DIV(
    { "class": "xmonitor-limit" },
    DIV(
      { "class": "alert alert-danger" },
      SPRINTF("m_monitor_constraint_1", constraint.count, constraint.limit),
      " ",
      SPRINTF("m_monitor_constraint_2"),
      UL(
        LI(
          A({ href: urlCfg.watchlist }, I({ "class": "fa fa-link" }), " ", SPRINTF("a_go_to_watchlist")),
          ": ",
          SPRINTF("m_monitor_constraint_3")
        ),
        LI(
          A({ href: urlCfg.billing }, I({ "class": "fa fa-link" }), " ", SPRINTF("a_go_to_billing")),
          ": ",
          SPRINTF("m_monitor_constraint_4")
        )
      )
    )
  );
}
class MacroSelector extends Base$2 {
  constructor({ model, classes: classes2 }) {
    super();
    this.model = model;
    this.state.classes = classes2 || [];
    this.setId(model.get("macro_id"));
    this.state.names = {};
    this.state.macros = new Macros([], {});
    if (App.user.isLoggedIn()) {
      this.loadMacros();
    }
  }
  getTrimmedURI() {
    if (!this.model.get("uri")) {
      return "";
    }
    return new URL(this.model.get("uri")).host;
  }
  async loadMacros({ name = "" } = {}) {
    const query = {
      "_opt": {
        only: ["id", "name"]
      }
    };
    if (name) {
      query["name.ilike"] = `%${name}%`;
      query["meta:->>'url'.like"] = `%${this.getTrimmedURI()}%`;
    } else if (this.state.id) {
      query["$or"] = {
        "meta:->>'url'.like": `%${this.getTrimmedURI()}%`,
        id: this.state.id
      };
    } else {
      query["meta:->>'url'.like"] = `%${this.getTrimmedURI()}%`;
    }
    this.state.macros.setQuery(query);
    await this.state.macros.fetch();
    this.state.names = this.state.macros.models.reduce((names, m) => {
      names[m.id] = m.get("name");
      return names;
    }, {});
  }
  onSearch(e) {
    this.loadMacros({
      name: e.target.value
    });
  }
  setId(id2, e) {
    e && e.preventDefault();
    this.state.id = id2;
    this.model.set("macro_id", id2);
  }
  createTpl({ id: id2, macros, names, classes: classes2 }) {
    let loadedMacros = !!macros.models;
    let team = get_store_value(params).team;
    return html`<div class='drowdown relative ${classes2.join(" ")}'>
      <a class='btn btn-default dropdown-toggle' data-toggle='dropdown'
        href='#'>
        Macro - ${!macros.get(id2) ? "None" : macros.get(id2).get("name") || "Deleted"}
        <span class='caret'></span>
      </a>
      <ul class='dropdown-menu'>
        ${loadedMacros ? [
      html`
        <li>
          <div class='ma2' @click=${(e) => (e.preventDefault(), e.stopPropagation())}>
            <input type='text' class='ba0' placeholder='Search' @input=${(e) => this.onSearch(e)}></input>
          </div>
        </li>
          <li><a href='#' @click=${(e) => this.setId(null, e)}>
              <i class='mr2 fa ${!id2 ? "fa-check" : "mr4"}'></i>
              Empty (Default)</a></li>`,
      macros.models.map((s) => html`<li>
            <a data-id=${s.id} href='#' @click=${(e) => this.setId(s.id, e)}>
              <i class='mr2 fa ${id2 === s.id ? "fa-check" : "mr4"}'></i>
              ${s.get("name")}
            </a>
          </li>`),
      html`
          <li class='divider'></li>

          <li><a href='#/w/${team}/macros/' target='_blank'>
              <span class='pl4'> Manage Macros<span></a></li>

          <li><a href='${URL_WEBSITE}/docs/web-monitor/macro-to-record-replay-actions/' target='_blank'>
              <span class='pl4'> Learn More<span></a></li>
              `
    ] : html`<li><a>Loading...</a></li>`}
      </ul>
    </div>`;
  }
}
View.ActionProvider.extend({
  name: "HTMLSelector",
  render: function() {
    this.selectorModal = new Selector.Modal({
      model: this.model.clone(),
      parent: this,
      onDiscard: this.onSelectorDiscard,
      onSave: this.onSelectorSave
    });
    this.selectorModal.show();
    return this;
  },
  onSelectorDiscard: function() {
    this.trigger("discard");
    this.selectorModal.remove();
  },
  onSelectorSave: function(err, model) {
    if (err) {
      Msg.error("Error running visual selector: " + err);
      this.trigger("error", err);
    } else {
      this.trigger(
        "save",
        _.pick(
          model.toJSON(),
          "uri",
          "name",
          "config",
          "content_type",
          "macro_id",
          "session_id",
          "datasource_id"
        )
      );
    }
    this.selectorModal.remove();
  }
});
View.ActionProvider.extend({
  name: "PDFSelector",
  postInit: function() {
    if (USER.constraint && USER.constraint.flexi) {
      this.editor = Editor.create("url", {
        param: {
          label: "m_enter_pdf_url",
          must: true,
          name: "uri"
        },
        parent: this
      }).render();
      this.listenTo(this.editor, "change", this.save);
    } else {
      this.editor = new View.Base({
        el: DIV(
          { class: "alert alert-info" },
          "PDF monitoring is available to Flexi and Enterprise customers only. Please upgrade your account or contact support for more information."
        )
      });
    }
  },
  save: function() {
    const uri = this.editor.getValue();
    const parts = uri.split("/");
    const name = parts[parts.length - 1];
    const attrs = {
      name: name + (name.match(/\.pdf$/) ? "" : " pdf"),
      uri,
      content_type: C$2.TYPE_PDF_HTML,
      config: {}
    };
    this.trigger("save", attrs);
  },
  render: function() {
    this.$el.empty().append(this.editor.el);
    return this;
  }
});
View.ActionProvider.extend({
  name: "DOCSelector",
  postInit: function() {
    this.editor = Editor.create("url", {
      param: {
        label: "m_enter_doc_url",
        must: true,
        name: "uri"
      },
      parent: this
    }).render();
    this.listenTo(this.editor, "change", this.save);
  },
  save: function() {
    const uri = this.editor.getValue();
    const parts = uri.split("/");
    const name = parts[parts.length - 1];
    const attrs = {
      name: name + (name.match(/\.docx?$/) ? "" : " doc"),
      uri,
      content_type: C$2.TYPE_DOC,
      config: {}
    };
    this.trigger("save", attrs);
  },
  render: function() {
    this.$el.empty().append(this.editor.el);
    return this;
  }
});
const SieveSourceEditor = View.ActionProvider.extend({
  name: "SieveSourceEditor",
  actions: {
    edit_url: {
      fn: "action_edit_url"
    },
    force_static: {
      fn: "action_force_static"
    },
    selector_config_show: {
      fn: "action_config_show"
    },
    selector_edit: {
      fn: "action_selector_edit"
    }
  },
  action_config_show: function() {
    openConfigEditor(this.model, T("l_selection_config"), (modal) => {
      modal.remove();
    });
  },
  action_edit_url: function() {
    const model = this.model;
    const view = Editor.create("url", {
      param: {
        label: "l_url",
        must: true,
        name: "uri"
      },
      model: model.clone(),
      parent: this
    });
    const modal = new View.SaveDiscardModal({
      name: "SieveSourceEditor$URLModal",
      parent: this,
      title: T("l_url"),
      view
    });
    modal.show();
    modal.on("save", function() {
      model.set({ uri: view.getValue() });
      modal.remove();
    });
    modal.on("discard", function() {
      modal.remove();
    });
  },
  action_force_static: function() {
    const model = this.model;
    const config = model.get("config");
    const pages = config.get("selections");
    const page = pages && pages.at(0);
    page.set("dynamic", false);
    this.checkURI(model);
    model.trigger("change");
  },
  action_selector_edit: function() {
    if (this.sourceSelector) {
      this.onEditSourceSelectorDiscard();
    } else {
      this.openSelector();
    }
  },
  checkURI: async function(model) {
    if (model.get("content_type") != C$2.TYPE_HTML) {
      return;
    }
    const url = model.get("uri");
    const config = model.get("config");
    const pages = config.get("selections");
    const page = pages.at(0);
    const tabXF = Supports.tabForXFrame;
    const tabDn = Supports.tabForDynamic;
    const elMsg = this.elXFrameNotice;
    if (!url || page.get("dynamic") === false || !Supports.agents.local || !(tabXF || tabDn)) {
      return $(elMsg).addClass("hide");
    }
    if (tabDn) {
      $(elMsg).removeClass("hide");
    } else if (tabXF) {
      try {
        let res = await serviceProxy.HTTP.get({ url });
        if (res.headers["x-frame-options"] || /x-frame-options/i.test(res.response)) {
          $(elMsg).removeClass("hide");
        }
      } catch (err) {
        return Msg.error("Failed to fetch URL.", err);
      }
    }
  },
  onSourceSelectorSave: function(attrs) {
    attrs.config = this.parseConfig(typeof attrs.config == "string" ? JSON.parse(attrs.config) : attrs.config);
    if (this.model.get("name")) {
      delete attrs.name;
    }
    this.model.set(attrs);
    this.sourceSelector.remove();
    this.sourceSelector = null;
  },
  onEditSourceSelectorDiscard: function() {
    this.sourceSelector.remove();
    this.sourceSelector = null;
    if (this.model.isNew()) {
      App.navBack();
    }
  },
  openSelector: function() {
    this.sourceSelector = new SieveSourceSelector({
      parent: this,
      model: this.model
    });
    this.listenTo(this.sourceSelector, "save", this.onSourceSelectorSave);
    this.listenTo(this.sourceSelector, "discard", this.onEditSourceSelectorDiscard);
    this.sourceSelector.render();
    this.elSelector.appendChild(this.sourceSelector.el);
    this.sourceSelector.$el.css({ padding: 10 });
  },
  parseConfig: function(config) {
    const ctor = this.model.get("config").constructor;
    return new ctor(config, { parse: true });
  },
  postInit: function() {
    const model = this.model;
    this.listenTo(model, "change:config change:uri", this.render);
    if (model.isEmpty()) {
      _.defer(this.openSelector);
    }
    this.elXFrameNotice = DIV(
      {
        "class": "alert alert-info hide",
        "style": "margin: 5px 0; padding: 5px;"
      },
      T("m_xframe_notice"),
      " ",
      BUTTON({
        "class": "btn btn-default btn-sm",
        "data-action": "force_static"
      }, T("a_static_load")),
      " ",
      A({ href: "https://distill.io/help/new-tab-chrome-extension" }, T("Learn More"))
    );
    this.listenTo(model, "change:uri", this.checkURI);
    this.checkURI(model);
  },
  getContentTypeDescription: function() {
    switch (this.model.get("content_type")) {
      case C$2.TYPE_HTML:
        return SPRINTF("a_open_x_selector", "l_webpage");
      case C$2.TYPE_FEED:
        return SPRINTF("a_open_x_selector", "l_feed");
      case C$2.TYPE_XML:
        return SPRINTF("a_open_x_selector", "l_xml");
      case C$2.TYPE_PDF_HTML:
        return SPRINTF("a_open_x_selector", "l_pdf");
      case C$2.TYPE_DOC:
        return SPRINTF("a_open_x_selector", "l_doc");
      case C$2.TYPE_JSON:
        let name = "l_datasource";
        switch (this.model.get("datasource_id")) {
          case C$2.DS_ID_UPTIME:
            name = "l_uptime";
            break;
          case C$2.DS_ID_JSON:
          case null:
            name = "l_json";
        }
        return SPRINTF("a_open_x_selector", name);
      default:
        console.warn("getContentTypeDescription", "unknown content type", this.model.get("content_type"));
        return T("a_open_selector");
    }
  },
  render: function() {
    this.macroSelector = new MacroSelector({ model: this.model, classes: [] });
    this.$el.empty().append(
      DIV(
        {
          "class": "flex"
        },
        DIV(
          {
            "class": "btn-group flex mr2",
            "role": "group"
          },
          BUTTON({
            "type": "button",
            "class": "btn btn-default",
            "data-action": "selector_edit",
            "title": T("h_selector_edit")
          }, this.getContentTypeDescription()),
          BUTTON({
            "class": "btn btn-default dropdown-toggle",
            "data-toggle": "dropdown"
          }, SPAN({ "class": "caret" })),
          UL(
            { "class": "dropdown-menu" },
            LI(
              A({
                "data-action": "selector_config_show",
                "href": "javascript:void 0"
              }, T("h_config_show"))
            )
          )
        ),
        this.model.get("content_type") == C$2.TYPE_HTML ? DIV(
          {
            "class": "mr2"
          },
          this.macroSelector.el
        ) : "",
        BUTTON({
          "class": "btn btn-default truncate mw6",
          "data-action": "edit_url"
        }, T("a_edit"), " ", this.model.get("uri"))
      ),
      this.elXFrameNotice,
      this.elSelector = DIV()
    );
    return this;
  }
});
View.ActionProvider.extend({
  name: "SieveOptions",
  actions: {
    sieve_save: { fn: "action_save" }
  },
  action_save: function(x, el) {
    const model = this.model;
    Msg.start("sieve:save", { info: "saving" });
    $(el).button("loading");
    async.series([
      (callback) => {
        const rule = this.rulesEditor.model;
        this.rulesEditor.updateModel();
        if (rule.isNew() && rule.isEmpty()) {
          return callback();
        }
        Msg.start("sieve:rule:save", { info: "l_loading" });
        rule.save(null, {
          error: function(rule2, res) {
            Msg.stop("sieve:rule:save", { error: "e_req" });
            callback({ msg: "Failed to save conditions", err: res });
          },
          success: function() {
            if (model.get("rule_id") != rule.id) {
              model.set({ rule_id: rule.id }, { silent: true });
            }
            Msg.stop("sieve:rule:save");
            callback();
          }
        });
      },
      (callback) => {
        const attrs = _.omit(
          model.toJSON(),
          "err",
          "text",
          "ts",
          "ts_data",
          "ts_mod",
          "ts_view",
          "user_id"
        );
        if (attrs.state == C$2.STATE_INIT) {
          attrs.state = C$2.STATE_READY;
        }
        model.save(null, {
          data: attrs,
          patch: true,
          silent: true,
          wait: true,
          error: function(model2, res) {
            Msg.stop("sieve:save", { error: "Failed to save changes to server" });
            callback({ msg: "Failed to save changes", err: res });
          },
          success: function(model2) {
            Msg.stop("sieve:save");
            callback(null);
          }
        });
      },
      (callback) => {
        const changes = this.actionEditor.getChanges();
        if (!base.syncBatch(changes, callback)) {
          callback();
        }
      }
    ], (err, results) => {
      $(el).button("reset");
      if (err) {
        Msg.error("Failed to save data. Please check console for more info.");
      } else {
        this.trigger("save");
        App.navBack();
      }
    });
  },
  duplicate: async function(id2) {
    const model = await this.fetch(id2);
    const json = _.pick(
      model.toJSON(),
      "name",
      "uri",
      "config",
      "client_id",
      "content_type",
      "schedule",
      "tags",
      "datasource_id"
    );
    json.name = "Copy of " + json.name;
    this.setModel(new this.collection.model(json, { parse: true }), {
      defaultsModel: model,
      editURL: false
    });
  },
  edit: async function(id2) {
    let model = await this.fetch(id2);
    this.setModel(model);
  },
  editNew: function(type, options) {
    let content_type = 0;
    let attrs = {};
    switch (type) {
      case "page":
        content_type = C$2.TYPE_HTML;
        break;
      case "feed":
        content_type = C$2.TYPE_FEED;
        break;
      case "xml":
        content_type = C$2.TYPE_XML;
        break;
      case "pdf":
        content_type = C$2.TYPE_PDF_HTML;
        break;
      case "doc":
        content_type = C$2.TYPE_DOC;
        break;
      case "json":
        content_type = C$2.TYPE_JSON;
        switch (options.type) {
          case C$2.DS_TYPE_UPTIME:
            attrs.datasource_id = C$2.DS_ID_UPTIME;
            break;
          case C$2.DS_TYPE_JSON:
          default:
            attrs.datasource_id = C$2.DS_ID_JSON;
        }
        break;
      default:
        Msg.error("Unknown monitor type: " + type);
        throw new Error("Unknown monitor type: " + type);
    }
    this.setModel(new Model$2.Sieve({
      ...attrs,
      content_type
    }, { parse: true }));
  },
  fetch: async function(id2) {
    let model = new Model$2.Sieve({ id: id2 });
    await model.fetch();
    return model;
  },
  initEditors: async function(model, defaultsModel) {
    const actions = new Model$2.SieveActions(null, { parent: model });
    const rule = new Model$2.SieveRule({
      id: model.get("rule_id") || void 0
    });
    this.sourceEditor = new SieveSourceEditor({
      model,
      parent: this,
      className: "controls"
    }).render();
    this.clientSelector = new ViewClients.ClientSelector({ model });
    this.nameEditor = Editor.create("text", {
      model,
      param: {
        label: "l_name",
        must: true,
        name: "name",
        type: "text"
      },
      parent: this
    }).render();
    this.scheduleEditor = new SieveScheduleEditor({
      model,
      parent: this
    }).render();
    this.actionEditor = new SieveActionsEditor({
      actions,
      sieve: model,
      parent: this
    }).render();
    this.rulesEditor = new SieveRuleWrapper({
      model: rule,
      parent: this
    }).render();
    this.tagsEditor = new TagsEditor$1({
      model,
      parent: this
    }).render();
    this.loadDefaults(model, actions, defaultsModel);
  },
  async createDefaults(sieve, actions, defaultsModel) {
    const uri = sieve.get("uri");
    const hostn = uri && new URL(uri).hostname;
    const colln = new Model$2.Sieves();
    if (_.isEmpty(sieve.get("name")) && uri) {
      sieve.set("name", T("l_loading"));
      $.get(URL_UTILS + "/v1/http/get?html_css_filter=title&url=" + encodeURIComponent(uri), function(res) {
        if (res) {
          sieve.set("name", $(res).text().trim() || "Untitled");
        }
      });
    }
    let copyRef = (ref, defaultRules) => {
      const refActions = new Model$2.SieveActions(null, { parent: ref });
      refActions.fetch({
        data: { state: 0 },
        success: () => {
          refActions.each((action) => {
            const attrs = action.omit("id", "sieve_id", "ts", "ts_mod");
            actions.add(new Model$2.SieveAction[attrs.type](attrs, { parse: true }));
          });
          this.onChanges();
        }
      });
      let refSchedule = ref.get("schedule");
      if (refSchedule.get("type") == "LIVE") {
        refSchedule = new Model$2.Schedule({ type: "INTERVAL" });
      }
      sieve.set("schedule", refSchedule);
      this.scheduleEditor.render();
      const rule_id = ref.get("rule_id");
      if (defaultRules && rule_id) {
        this.rulesEditor.duplicate(rule_id);
      }
    };
    if (defaultsModel) {
      return copyRef(defaultsModel, true);
    }
    await colln.fetch({
      data: {
        "uri.like": "%" + hostn + "%",
        "state.in": [C$2.STATE_READY, C$2.STATE_PAUSED],
        "_opt": {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    await colln.fetch({
      data: {
        "state.in": [C$2.STATE_READY, C$2.STATE_PAUSED],
        "_opt": {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    _.each(Model$2.SieveActionDescList, (desc) => {
      if (desc.addByDefault(Supports)) {
        actions.add(new Model$2.SieveAction[desc.type]());
      }
    });
    this.onChanges();
  },
  loadDefaults: function(sieve, actions, defaultsModel) {
    if (sieve.isNew() || sieve.get("state") == C$2.STATE_INIT) {
      this.createDefaults(sieve, actions, defaultsModel);
    } else {
      actions.fetch({ data: { state: 0 } });
    }
  },
  postInit: function(options) {
    this.clients = options.clients;
  },
  showProgress: function() {
    this.$el.children(".xprogress").show();
  },
  removeProgress: function() {
    this.$el.children(".xprogress").hide();
  },
  render: function() {
    this.$el.empty().append(
      DIV(
        { "class": "xtbar xvbar-margin mb-4 ml-2" },
        BUTTON(
          {
            "class": "btn btn-default",
            "data-action": "go_back"
          },
          I({ "class": "fa fa-chevron-left" }),
          " ",
          T("a_discard"),
          " ",
          this.elUnsavedMsg = SPAN()
        )
      ),
      DIV(
        { "class": "xpage-header" },
        H3(this.elHeading = SPAN())
      ),
      DIV(
        { "class": "xprogress", "style": "margin-top: -2px;position:absolute;" },
        DIV({ "class": "xindeterminate" })
      ),
      DIV(
        { "class": "form-horizontal", "style": "padding: 10px;" },
        this.elContent = DIV()
      )
    );
    return this;
  },
  renderOptions: function() {
    const model = this.model;
    model.getTags(App.labels);
    $(this.elHeading).empty().append(
      T("l_options"),
      " - ",
      model.isNew() ? T("l_add_monitor") : model.get("name")
    );
    $(this.elContent).empty().append(
      DIV(
        { "class": "form-group" },
        LABEL({ "class": "control-label col-md-2" }, T("l_source")),
        DIV(
          { "class": "col-md-10" },
          this.sourceEditor.el,
          P({ "class": "help" }, T("h_sieve_source"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2", "for": "sieve-device" },
          T("l_device")
        ),
        DIV(
          { "class": "col-md-10" },
          this.clientSelector.el,
          P({ "class": "help" }, T("h_sieve_device"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2", "for": "sieve-name" },
          T("l_name")
        ),
        DIV(
          { "class": "col-md-10" },
          this.nameEditor.el,
          P({ "class": "help" }, T("h_sieve_name"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2", "for": "sieve-schedule" },
          T("l_schedule")
        ),
        DIV(
          { "class": "col-md-10" },
          this.scheduleEditor.el
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2" },
          T("l_actions")
        ),
        DIV(
          { "class": "col-md-10" },
          this.actionEditor.el,
          P({ "class": "help" }, T("h_sieve_actions"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2" },
          T("l_conditions")
        ),
        DIV(
          { "class": "col-md-10" },
          this.rulesEditor.el,
          P({ "class": "help" }, T("h_sieve_rules"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2" },
          T("l_label")
        ),
        DIV(
          { "class": "col-md-10" },
          this.tagsEditor.el
        )
      ),
      DIV(
        { "class": "form-group" },
        DIV(
          { "class": "col-md-offset-2 col-md-10 xtbar-form" },
          BUTTON({
            "class": "btn btn-primary xbtn-default",
            "data-action": "sieve_save"
          }, T("a_save")),
          BUTTON({
            "class": "btn btn-default",
            "data-action": "go_back"
          }, T("a_discard"))
        )
      )
    );
  },
  onChanges: function() {
  },
  onSaveModel: function(attrs) {
    const model = new this.collection.model(_.defaults(attrs, {
      client_id: this.clients.defaultId,
      content_type: this.model.get("content_type"),
      datasource_id: this.model.get("datasource_id"),
      schedule: {
        type: "INTERVAL",
        params: {
          interval: 10800
        }
      },
      version: 1
    }), { parse: true });
    this.setModel(model);
  },
  onNewSourceSelectorDiscard: function() {
    this.sourceSelector.remove();
    App.navBack();
  },
  setModel: async function(model, options = {
    defaultsModel: null,
    editURL: false
  }) {
    this.showProgress();
    let sieveConstraint = {};
    if (this.model) {
      this.stopListening(this.model);
    }
    this.model = model;
    this.sourceSelector && this.sourceSelector.remove();
    this.listenTo(model, "change", this.onChanges);
    $(this.elUnsavedMsg).text("");
    try {
      sieveConstraint = await checkSieveConstraint(1);
    } catch (e) {
      console.error(e);
      sieveConstraint = { isOverLimit: false };
    }
    let accessInfo = await model.getAccess(App.user);
    if (model.isNew() && !accessInfo.hasAccess) {
      $(this.elHeading).text(T("m_upgrade_account"));
      let { minPlan } = accessInfo;
      if (minPlan) {
        $(this.elContent).empty().append(
          `${model.getTypeName()} monitors are available in ${minPlan} or higher subscriptions. `,
          A({
            href: urlCfg.billing
          }, "Manage Subscription")
        );
      } else {
        $(this.elContent).append("Please sign in or contact support to get more information");
      }
    } else if (model.isNew() && sieveConstraint.isOverLimit) {
      $(this.elHeading).text(T("m_monitor_limit"));
      $(this.elContent).empty().append(SieveConstraints(sieveConstraint));
    } else if (model.isEmpty()) {
      this.showSourceSelector(model);
    } else {
      await this.initEditors(model, options.defaultsModel);
      this.renderOptions();
      if (options.editURL) {
        this.sourceEditor.action_edit_url();
      }
    }
    this.removeProgress();
  },
  showSourceSelector(model) {
    const sourceSelector = new SieveSourceSelector({
      model,
      parent: this
    }).render();
    sourceSelector.on("save", this.onSaveModel);
    sourceSelector.on("discard", this.onNewSourceSelectorDiscard);
    this.sourceSelector = sourceSelector;
    $(this.elHeading).text(T("l_source"));
    $(this.elContent).empty().append(sourceSelector.el);
  }
});
const openConfigEditor = function(model, title, callback) {
  const view = Editor.create("json", {
    param: {
      label: "l_selection_config",
      must: false,
      name: "config",
      type: "json"
    },
    model: new Backbone.Model({
      config: model.get("config").toJSON()
    })
  });
  const modal = new View.SaveDiscardModal({
    name: "SieveSourceEditor$ConfigModal",
    title,
    view
  });
  modal.on("save", function() {
    const config = view.model.get("config");
    model.set({ config: parseConfig(config) });
    callback(modal);
  });
  modal.on("discard", function() {
    modal.remove();
  });
  modal.show();
  view.$el.find("textarea").css("height", 300);
  function parseConfig(config) {
    const ctor = model.get("config").constructor;
    return new ctor(config, { parse: true });
  }
};
const tokenize = function(txtQuery, callback) {
  const quoteStartRegEx = new RegExp(/(\"|\').*/);
  const quoteEndRegEx = new RegExp(/.*(\"|\')$/);
  const keywords = [];
  const paramsObj = [];
  let expectingVal = false;
  let currParam = null;
  const tokens = txtQuery.split(" ");
  for (let i2 = 0; i2 < tokens.length; i2++) {
    let currToken = tokens[i2];
    if (expectingVal) {
      for (let j = i2; j < tokens.length; j++) {
        currToken = tokens[j];
        currParam.val = (currParam.val || "") + " " + currToken;
        if (currToken.match(quoteEndRegEx)) {
          expectingVal = false;
          i2 = j;
          currParam.val = currParam.val.replace('"', "");
          break;
        }
      }
    } else {
      if (currToken.indexOf(":") > -1) {
        if (currParam != null) {
          currParam.val = currParam.val.replace(/%22/g, '"');
          paramsObj.push(currParam);
        }
        currParam = {
          name: currToken.split(":")[0].trim(),
          val: ""
        };
        var tempVal = currToken.split(":")[1].trim();
        if (tempVal) {
          if (tempVal.match(quoteStartRegEx)) {
            currParam.val = (currParam.val || "") + " " + tempVal.match(quoteStartRegEx)[0].replace(/(\"|\')/gm, "");
            expectingVal = true;
          } else {
            currParam.val = (currParam.val || "") + " " + tempVal;
          }
        }
      } else {
        if (expectingVal) {
          currParam.val = (currParam.val || "") + " " + tempVal;
        } else {
          keywords.push(currToken.replace(/%22/g, '"'));
        }
      }
    }
  }
  if (currParam != null) {
    currParam.val = currParam.val.replace(/%22/g, '"');
    paramsObj.push(currParam);
  }
  paramsObj.push({
    name: "keyword",
    val: keywords.join(" ")
  });
  callback(null, paramsObj);
};
const tokenize_new = function(txtQuery, conditionClauses, callback) {
  const quoteStartRegEx = new RegExp(/(\"|\').*/);
  const quoteEndRegEx = new RegExp(/.*(\"|\')$/);
  const keywords = [];
  const paramsObj = [];
  let expectingVal = false;
  let currParam = null;
  let conditions = [];
  const tokens = txtQuery.split(" ");
  for (let i2 = 0; i2 < tokens.length; i2++) {
    let currToken = tokens[i2];
    if (expectingVal) {
      for (let j = i2; j < tokens.length; j++) {
        currToken = tokens[j];
        currParam.val = (currParam.val || "") + " " + currToken;
        if (currToken.match(quoteEndRegEx)) {
          expectingVal = false;
          i2 = j;
          currParam.val = currParam.val.replace('"', "");
          break;
        }
      }
    } else {
      if (currToken.indexOf(":") > -1) {
        if (currParam != null) {
          currParam.val = currParam.val.replace(/%22/g, '"');
          paramsObj.push(currParam);
        }
        currParam = {
          name: currToken.split(":")[0].trim(),
          val: "",
          operator: ""
        };
        var tempVal = currToken.split(":")[1].trim();
        if (tempVal) {
          if (tempVal.match(quoteStartRegEx)) {
            currParam.val = (currParam.val || "") + " " + tempVal.match(quoteStartRegEx)[0].replace(/(\"|\')/gm, "");
            expectingVal = true;
          } else {
            currParam.val = (currParam.val || "") + " " + tempVal;
          }
        }
        if (conditions.length > 0) {
          let operator = conditions.pop();
          currParam.operator = operator;
        }
      } else {
        if (expectingVal) {
          currParam.val = (currParam.val || "") + " " + tempVal;
        } else {
          if (_.contains(conditionClauses, currToken.toLowerCase())) {
            conditions.push(currToken.replace(/%22/g, '"'));
          } else {
            keywords.push(currToken.replace(/%22/g, '"'));
          }
        }
      }
    }
  }
  if (currParam != null) {
    currParam.val = currParam.val.replace(/%22/g, '"');
    paramsObj.push(currParam);
  }
  paramsObj.push({
    name: "keyword",
    val: keywords.join(" ")
  });
  callback(null, paramsObj);
};
var SearchQuery = {
  tokenize,
  tokenize_new
};
function getQuery(route2) {
  let query = {};
  switch (route2.prefix) {
    case "all": {
      query = { "state.in": [C$2.STATE_INIT, C$2.STATE_READY, C$2.STATE_PAUSED] };
      break;
    }
    case "error": {
      query = {
        "state.in": [C$2.STATE_INIT, C$2.STATE_READY, C$2.STATE_PAUSED],
        "err.ne": "$null"
      };
      break;
    }
    case "label": {
      query = {
        "state.in": [C$2.STATE_INIT, C$2.STATE_READY, C$2.STATE_PAUSED]
      };
      let id2 = route2.data;
      query["tags.like"] = "%" + id2 + "%";
      break;
    }
    case "search": {
      query = parseQuery(route2.query.q);
      break;
    }
    case "trash": {
      query = { "state": C$2.STATE_DISCARD };
      break;
    }
    case "unread": {
      query = {
        "state.in": [C$2.STATE_INIT, C$2.STATE_READY, C$2.STATE_PAUSED],
        "ts_view.lt": { name: "ts_data", type: "field" }
      };
      break;
    }
    default: {
      query = {
        _opt: {
          limit: 0
        }
      };
    }
  }
  if (!query || Object.keys(query).length <= 0) {
    query = {
      _opt: {
        limit: 0
      }
    };
  }
  if (App.store.get("ui.list.clientfilter") == 2) {
    query = { ...query, client_id: App.clients.defaultId };
  }
  return query;
}
function parseQuery(txtQuery) {
  let queryObj = {};
  const Ortokens = txtQuery.split(" OR ");
  if (Ortokens.length > 1) {
    let stateInFound = false;
    for (let i2 = 0; i2 < Ortokens.length; i2++) {
      let orToken = Ortokens[i2].trim();
      let andtokens = orToken.split(" AND ");
      let spaceTokens = orToken.split(" ");
      if (andtokens.length > 1) {
        let spaceTokens2 = [];
        for (let j = 0; j < andtokens.length; j++) {
          let spaceWithAndTokens = andtokens[j].split(" ");
          spaceTokens2 = [...spaceTokens2, ...spaceWithAndTokens];
        }
        if (spaceTokens2.length > 0) {
          andtokens = handleLabelsWithSpace(spaceTokens2);
        } else {
          andtokens = handleLabelsWithSpace(andtokens);
        }
        if (andtokens.length > 1) {
          let res = groupANDoperations(andtokens);
          let queryParams = res.response || [];
          queryObj = {
            ...queryObj,
            "$or": [
              ...queryObj["$or"] || [],
              [...queryParams]
            ]
          };
          if (res.stateInFound) {
            stateInFound = true;
          }
        } else if (andtokens.length == 1) {
          let queryParams = getQueryParams(andtokens[0]) || [];
          queryObj = {
            ...queryObj,
            "$or": [
              ...queryObj["$or"] || [],
              [...queryParams]
            ]
          };
          if (_.contains(queryParams, "state.in")) {
            stateInFound = true;
          }
        }
      } else if (spaceTokens.length > 1) {
        spaceTokens = handleLabelsWithSpace(spaceTokens);
        if (spaceTokens.length > 1) {
          let res = groupANDoperations(spaceTokens);
          let queryParams = res.response || [];
          queryObj = {
            ...queryObj,
            "$or": [
              ...queryObj["$or"] || [],
              [...queryParams]
            ]
          };
          if (res.stateInFound) {
            stateInFound = true;
          }
        } else if (spaceTokens.length == 1) {
          let queryParams = getQueryParams(spaceTokens[0]) || [];
          queryObj = {
            ...queryObj,
            "$or": [
              ...queryObj["$or"] || [],
              [...queryParams]
            ]
          };
          if (_.contains(queryParams, "state.in")) {
            stateInFound = true;
          }
        }
      } else {
        let queryParams = getQueryParams(orToken) || [];
        queryObj = {
          ...queryObj,
          "$or": [
            ...queryObj["$or"] || [],
            [...queryParams]
          ]
        };
        if (_.contains(queryParams, "state.in")) {
          stateInFound = true;
        }
      }
    }
    if (!stateInFound) {
      queryObj["state.in"] = [C$2.STATE_INIT, C$2.STATE_READY, C$2.STATE_PAUSED];
    }
  } else {
    SearchQuery.tokenize_new(txtQuery, ["and", "or"], function(error, data) {
      queryObj = buildQuery$1(data);
    });
  }
  return queryObj;
}
function groupANDoperations(tokens) {
  let queryObj = {};
  let stateInFound = false;
  for (let j = 0; j < tokens.length; j++) {
    let andToken = tokens[j].trim();
    let queryParams = getQueryParams(andToken) || [];
    queryObj = {
      ...queryObj,
      "$and": [
        ...queryObj["$and"] || [],
        [...queryParams]
      ]
    };
    if (_.contains(queryParams, "state.in")) {
      stateInFound = true;
    }
  }
  return {
    response: ["$and", queryObj["$and"]],
    stateInFound
  };
}
function handleLabelsWithSpace(tokens) {
  const quoteStartRegEx = new RegExp(/(\"|\').*/);
  const quoteEndRegEx = new RegExp(/.*(\"|\')$/);
  let currentVal = "";
  let currentKey = "";
  let expectingVal = false;
  let outputTokens = [];
  for (let i2 = 0; i2 < tokens.length; i2++) {
    let currToken = tokens[i2];
    if (expectingVal) {
      for (let j = i2; j < tokens.length; j++) {
        currToken = tokens[j];
        currentVal = (currentVal || "") + " " + currToken;
        if (currToken.match(quoteEndRegEx)) {
          expectingVal = false;
          i2 = j;
          currentVal = currentVal.replace('"', "");
          break;
        }
      }
      let currentObj = currentKey + ":" + currentVal;
      outputTokens.push(currentObj);
      currentVal = "";
      currentKey = "";
    } else {
      if (currToken.indexOf(":") > -1) {
        currentKey = currToken.split(":")[0];
        var tempVal = currToken.split(":")[1].trim();
        if (tempVal) {
          if (tempVal.match(quoteStartRegEx) && tempVal.match(quoteEndRegEx)) {
            currentVal = (currentVal || "") + tempVal.match(quoteStartRegEx)[0].replace(/(\"|\')/gm, "");
            let currentObj = currentKey + ":" + currentVal;
            outputTokens.push(currentObj);
            currentVal = "";
            currentKey = "";
          } else if (tempVal.match(quoteStartRegEx)) {
            currentVal = (currentVal || "") + tempVal.match(quoteStartRegEx)[0].replace(/(\"|\')/gm, "");
            expectingVal = true;
          } else {
            currentVal = (currentVal || "") + tempVal;
            let currentObj = currentKey + ":" + currentVal;
            outputTokens.push(currentObj);
            currentVal = "";
            currentKey = "";
          }
        }
      } else {
        if (expectingVal) {
          currentVal = (currentVal || "") + " " + tempVal;
        }
      }
    }
  }
  return outputTokens;
}
function getQueryParams(token) {
  let queryObj = [];
  const nameVal = token.split(":");
  if (nameVal.length > 1) {
    let currName = nameVal[0];
    let currVal = nameVal[1];
    switch (currName) {
      case "label":
        var labels = App.labels.where({ name: currVal });
        if (labels && labels.length > 0) {
          _.forEach(labels, function(label) {
            queryObj.push("tags.ilike");
            queryObj.push("%" + label.id + "%");
          });
        } else {
          queryObj = [];
          return;
        }
        break;
      case "is":
        if (currVal.match(/on/i) && !queryObj["state.in"]) {
          queryObj.push("state.in");
          queryObj.push([C$2.STATE_READY]);
          break;
        } else if (currVal.match(/on/i) && queryObj["state.in"].indexOf(C$2.STATE_READY) >= 0) {
          break;
        } else if (currVal.match(/off/i) && !queryObj["state.in"]) {
          queryObj.push("state.in");
          queryObj.push([C$2.STATE_PAUSED, C$2.STATE_INIT]);
          break;
        } else if (currVal.match(/off/i) && queryObj["state.in"].indexOf(C$2.STATE_PAUSED) >= 0) {
          break;
        } else if (currVal.match(/unread/i)) {
          queryObj.push("ts_view.lt");
          queryObj.push({ name: "ts_data", type: "field" });
          break;
        } else if (currVal.match(/read/i)) {
          queryObj.push("ts_view.gt");
          queryObj.push({ name: "ts_data", type: "field" });
          break;
        } else {
          queryObj = {};
          return;
        }
      case "has":
        if (currVal.match(/error/i)) {
          queryObj.push("err.ne");
          queryObj.push("$null");
          break;
        } else {
          queryObj = {};
          return;
        }
      case "keyword":
        queryObj.push("$or");
        queryObj.push({ "uri.ilike": "%" + currVal + "%", "name.ilike": "%" + currVal + "%" });
        break;
      case "in":
        if (currVal.match(/trash/i) && !queryObj["state.in"]) {
          queryObj.push("state.in");
          queryObj.push([C$2.STATE_DISCARD]);
        } else if (currVal.match(/trash/i) && queryObj["state.in"])
          ;
        else {
          queryObj = {};
          return;
        }
        break;
      default:
        queryObj.push("state.ne");
        queryObj.push(C$2.STATE_DEL);
        queryObj.push("$or");
        queryObj.push({ "uri.ilike": "%" + currName + ":" + currVal + "%", "name.ilike": "%" + currName + ":" + currVal + "%" });
    }
  }
  return queryObj;
}
function buildQuery$1(paramsObj) {
  let queryObj = {};
  for (let i2 = 0; i2 < paramsObj.length; i2++) {
    const currName = paramsObj[i2].name.toLowerCase();
    if (!paramsObj[i2].val)
      continue;
    const currVal = paramsObj[i2].val.trim();
    switch (currName) {
      case "label":
        var labels = App.labels.where({ name: currVal });
        if (labels && labels.length > 0) {
          queryObj["tags.ilike"] = queryObj["tags.ilike"] || [];
          _.forEach(labels, function(label) {
            queryObj["tags.ilike"].push(label.id);
          });
        } else {
          queryObj = {};
          return;
        }
        break;
      case "is":
        if (currVal.match(/on/i) && !queryObj["state.in"]) {
          queryObj["state.in"] = [C$2.STATE_READY];
          break;
        } else if (currVal.match(/on/i) && queryObj["state.in"].indexOf(C$2.STATE_READY) >= 0) {
          break;
        } else if (currVal.match(/off/i) && !queryObj["state.in"]) {
          queryObj["state.in"] = [C$2.STATE_PAUSED, C$2.STATE_INIT];
          break;
        } else if (currVal.match(/off/i) && queryObj["state.in"].indexOf(C$2.STATE_PAUSED) >= 0) {
          break;
        } else if (currVal.match(/unread/i)) {
          queryObj["ts_view.lt"] = { name: "ts_data", type: "field" };
          break;
        } else if (currVal.match(/read/i)) {
          queryObj["ts_view.gt"] = { name: "ts_data", type: "field" };
          break;
        } else {
          queryObj = {};
          return;
        }
      case "keyword":
        queryObj["$or"] = { "uri.ilike": "%" + currVal + "%", "name.ilike": "%" + currVal + "%" };
        break;
      case "has":
        if (currVal.match(/error/i)) {
          queryObj["err.ne"] = "$null";
          break;
        } else {
          queryObj = {};
          return;
        }
      case "in":
        if (currVal.match(/trash/i) && !queryObj["state.in"]) {
          queryObj["state.in"] = [C$2.STATE_DISCARD];
        } else if (currVal.match(/trash/i) && queryObj["state.in"])
          ;
        else {
          queryObj = {};
          return;
        }
        break;
      default:
        queryObj["state.ne"] = C$2.STATE_DEL;
        queryObj["$or"] = { "uri.ilike": "%" + currName + ":" + currVal + "%", "name.ilike": "%" + currName + ":" + currVal + "%" };
    }
  }
  if (queryObj["tags.ilike"] && queryObj["tags.ilike"].length > 0) {
    if (queryObj["tags.ilike"].length == 1) {
      queryObj["tags.ilike"] = "%" + queryObj["tags.ilike"].join("%") + "%";
    } else {
      queryObj["$andTAGS"] = _.map(queryObj["tags.ilike"], function(id2) {
        return ["tags.ilike", "%" + id2 + "%"];
      });
      delete queryObj["tags.ilike"];
    }
  }
  if (!_.isEmpty(queryObj) && !queryObj["state.in"]) {
    queryObj["state.in"] = [C$2.STATE_INIT, C$2.STATE_READY, C$2.STATE_PAUSED];
  }
  return queryObj;
}
const diff_match_patch$1 = window.diff_match_patch;
if (!diff_match_patch$1) {
  throw new Error("ADD diff_match_patch");
}
const $$2 = window.jQuery;
if (!$$2) {
  throw new Error("ADD jQuery");
}
const _$3 = window._;
if (!_$3) {
  throw new Error("ADD _");
}
const async$2 = window.async;
if (!async$2) {
  throw new Error("ADD async");
}
const domo$1 = window.domo;
if (!domo$1) {
  throw new Error("ADD domo");
}
const moment$2 = window.moment;
if (!moment$2) {
  throw new Error("ADD moment");
}
const Backbone$3 = window.Backbone;
if (!Backbone$3) {
  throw new Error("ADD Backbone");
}
const Work = View.Base.extend({
  name: "Work",
  url: function() {
    const attrs = this.model.attributes;
    if (attrs.err) {
      const team = get_store_value(params).team;
      return `#/checks/${team}/${this.options.sieve.id}?work=${attrs.id}`;
    } else {
      return "#";
    }
  },
  render: function() {
    const attrs = this.model.attributes;
    const err = attrs.err;
    if (err) {
      this.$el.append(
        DIV(
          { "class": "flex" },
          DIV(
            { "class": "error popup flex-1 hover:grey", "tabindex": "0" },
            SPAN(formatTime(attrs.ts)),
            " ",
            SPAN(err.code || "EUNKNOWN"),
            " "
          ),
          A({ "href": this.url(), "target": "_blank", class: "ml1" }, "View Details")
        )
      ).find(".popup").popover({
        placement: "left",
        html: true,
        trigger: "click|focus",
        container: "body",
        content: () => {
          return DIV(
            { class: "overflow-y-auto max-h-[300px]" },
            DIV(LABEL("Code:"), " ", SPAN(err.code || "NA")),
            DIV(LABEL("Msg:"), " ", SPAN(err.msg || err.message || JSON.stringify(err))),
            DIV(
              { style: "padding-top: 5px;" },
              STRONG("Recommended Actions"),
              this.getSuggestions(err)
            ),
            DIV(
              { style: "padding-top: 5px;" },
              STRONG("Need help?"),
              DIV("Contact us at support@distill.io")
            )
          ).outerHTML;
        }
      }).click(function(e) {
        e.preventDefault();
      });
    } else {
      this.$el.append(
        SPAN(formatTime(attrs.ts))
      );
    }
    return this;
  },
  getSuggestions: function(err) {
    switch (err.code || "NA") {
      case "SELECTION_EMPTY":
        return UL(
          { "style": "padding-left:14px;" },
          LI("Ensure that selected elements has text content."),
          LI("If website needs login, make sure that you are logged in.")
        );
      case "TIMEOUT":
      case "ENOTFOUND":
      case "EREQUEST":
      case "ETIMEDOUT":
      case "ECONNREFUSED":
        return DIV("Please ensure that the webpage is accessible.");
      case "JAVASCRIPT":
        return DIV("Ensure that JavaScript is working in the page.");
      default:
        if (err.status === 0) {
          return DIV("Ensure that internet connection is working.");
        }
        return DIV("There is no information about this error.");
    }
  }
});
const Works = View.Collection.extend({
  name: "Works",
  postInit: function() {
    this.sieve = this.collection.sieve;
    this.collection.fetch();
    this.collection.on("sync", this.onSync);
  },
  addOne: function(model) {
    const view = new Work({
      model,
      parent: this,
      sieve: this.sieve
    });
    this.$msg.empty();
    this.$list.append(view.render().el);
    return view;
  },
  onSync: function() {
    if (this.collection.length == 0) {
      if (this.sieve.get("client_id") == App.clients.defaultId) {
        this.$msg.text(T("m_log_na"));
      } else {
        this.$msg.text(T("Log for this monitor will be available on device that runs this monitor"));
      }
    }
  },
  renderBase: function() {
    this.$msg = $$2(DIV(T("l_loading")));
    this.$list = $$2(DIV());
    this.$el.append(this.$msg, this.$list);
  }
});
var SieveRow$1 = View.Base.extend({
  name: "SieveRow",
  className: "xitem",
  tagName: "tr",
  events: {
    "click :checkbox": "event_check"
  },
  event_check: function() {
    this.model.prop("select", this.$("input[type=checkbox]:checked").length > 0);
  },
  onSelect: function(selected) {
    this.$el[selected ? "addClass" : "removeClass"]("active");
  },
  postInit: function(options) {
    const model = this.model;
    const id2 = model.id;
    this.listenTo(model, "change", this.renderRow);
    this.listenTo(model, "destroy", this.remove);
    this.listenTo(model, "remove", this.remove);
    this.listenTo(model, "sync", this.onSync);
    this.listenTo(model, "prop:select", this.onSelect);
    this.elDetail = TR(TD({ colspan: 8 }));
    this.listenTo(instance$4s, "sieves:" + id2, this.onSieveUpdate);
    this.listenTo(instance$4s, "sieves:run_state:" + id2, this.onSieveRunState);
    this.listenTo(instance$4s, "sieves:on_demand_run_status:" + id2, this.onSieveRunState);
  },
  reattach: function() {
    const parentNode = this.el.parentNode;
    parentNode && parentNode.removeChild(this.el);
    parentNode && parentNode.appendChild(this.el);
    if (this.elDetail.parentNode) {
      parentNode.removeChild(this.elDetail);
      parentNode.appendChild(this.elDetail);
    }
  },
  isSelected: function() {
    return this.model.prop("select");
  },
  onSieveRunState: function(e) {
    this.runState = e.state || e.doc.state || 0;
    this.renderRow();
  },
  onSieveUpdate: function(e) {
    if (e.doc) {
      this.model.set(this.model.parse(e.doc), { silent: true });
      this.model.trigger("change");
    } else {
      this.model.fetch();
    }
  },
  onSync: function() {
    this.render();
  },
  remove: function() {
    SieveRow$1.__super__.remove.call(this);
    $$2(this.elDetail).remove();
  },
  removeDetail: function() {
    this.$el.removeClass("active");
    this.detail && this.detail.remove();
    $$2(this.elDetail).remove();
    this.setSelected(false);
    delete this.detail;
  },
  render: function() {
    this.renderRow();
    this.detail && this.showDetail(this.detail);
    this.setSelected(this.isSelected());
    return this;
  },
  renderRow: function() {
    let { runState } = this;
    let url = this.model.attributes.uri;
    let host = "";
    try {
      host = "//" + new URL(url).host;
    } catch (e) {
    }
    const renderRowTemplate = (model) => html`
      <td data-action = 'void 0'>
        <label class='xtd xdata xaction'>
          <input type="checkbox" style='margin:0;vertical-align:middle;'>
        </label>
      </td>
      <td data-action = 'void 0'>
        <button class='xtd xbtn xaction' style='margin: 0;' data-action= 'sieve context menu' data-action-param= '$parents [data-id]@data-id'>
          <i class="fa fa-caret-down"></i>
        </button>
      </td>
      <td>
        <a @click=${(e) => model.markRead()}
          class='xtd xdata monitor-link' href=${model.attributes.uri || "#"}
          rel='noopener' target='_blank' title=${model.attributes.name}>
          <img width=14 src=${URL_ROOT + "/v1/getfavicon?url=" + escape(host)} loading='lazy'></img>
          ${model.attributes.name || SPRINTF("l_untitled")}
        </a>
      </td>
      <td data-action= 'sieve view' data-action-param=${model.id}>
        <div class= 'xtd xdata xaction' title= 'Click to view history'>
          <i class="xcaret fa fa-angle-double-down fa-lg"></i>
          ${model.attributes.state == C$2.STATE_DISCARD || model.attributes.state == C$2.STATE_DEL ? html`<span class= 'label label-danger xlabel xlabel-small'>Deleted</span>` : html`<span></span>`}
          <span>
            ${_$3.map(model.getTags(App.labels), (tag) => {
      return html`<span class='label label-info xlabel xlabel-small'>${tag.get("name")}</span>`;
    })}
          </span>
          <span>
          ${model.attributes.text != null ? model.attributes.text || "<" + SPRINTF("h_sieve_empty") + ">" : "<" + SPRINTF("h_sieve_new") + ">"}
          </span>
        </div>
      </td>
      <td class= ${model.attributes.schedule ? model.attributes.schedule.getFrequencyClass() : "error"}>
        <a 
          class= 'xtd xdata xaction'
          title= 'Click to edit schedule'
          data-action= 'sieve schedule menu'
          data-action-param= '$parents [data-id]@data-id'
          data-toggle= 'tooltip'>
            <small>${model.attributes.schedule ? model.attributes.schedule.getShortDisplayText() : "err: unset"}</small>
            <i class="xcaret fa fa-caret-down"></i>
        </a>
      </td>
      <td>
        <a
        class= ${"xtd xdata xaction xsieve-ts-data " + (model.attributes.err ? "xsieve-err" : "")}
        title= 'Click to view check/error log'
        data-action= 'sieve log menu'
        data-action-param= '$parents [data-id]@data-id'
        data-toggle= 'tooltip'>
          <small>${runState == C$2.RUN_STATE_WAIT ? "Waiting" : runState == C$2.RUN_STATE_WIP ? "Checking" : formatTime(model.attributes.ts_data, true) || "" || "NA"}</small>
          <i class="xcaret fa fa-caret-down"></i>
        </a>
      </td>
      <td style='padding: 0'>
        <a
        class= 'xtd xdata xaction xbtn'
        title= 'Click to edit device'
        data-action= 'sieve client menu'
        data-action-param= '$parents [data-id]@data-id'
        data-toggle= 'tooltip'
        style= 'text-align:center'>
          <i class="fa fa-lg ${App.clients.get(model.attributes.client_id) ? App.clients.get(model.attributes.client_id).getIcon() : " error fa-question"}"  style= 'margin: auto;'></i>
          <i class="xcaret fa fa-caret-down"></i>
        </a>
      </td>
      <td data-action= 'void 0' style= 'padding: 0'>
        <button
          class= ${"xtd btn btn-sm " + (model.attributes.state == C$2.STATE_READY ? "btn-success" : "btn-default") + (model.attributes.state == C$2.STATE_DISCARD ? " disabled" : "")}
          style= 'border-radius:0'
          data-action= 'sieve switch'
          data-action-param= '$parents [data-id]@data-id'
          title= 'Turn monitor ON or OFF'
          data-placement= 'left'>
          ${model.attributes.state == C$2.STATE_READY ? "ON " : "OFF"}
        </button>
      </td>
    `;
    render(renderRowTemplate(this.model), this.el);
    if (this.model.attributes._state && this.model.attributes._state != 0) {
      this.$el.addClass("xdirty").attr("title", T("m_sync_to_save"));
    } else {
      this.$el.removeClass("xdirty").removeAttr("title");
    }
    this.$('[data-toggle="tooltip"]').tooltip({ delay: { show: 400 } });
    if (this.model.isRead()) {
      this.$el.addClass("xfade").removeClass("xunread");
    } else {
      this.$el.addClass("xunread").removeClass("xfade");
    }
  },
  setSelected: function(selected) {
    if (this.$("input[type=checkbox]:checked").length > 0 !== selected) {
      this.$("input[type=checkbox]").prop("checked", selected);
      this.model.prop("select", selected);
    }
  },
  showDetail: function(view) {
    if (this.detail == view)
      return;
    this.listenTo(view, "remove", function() {
      if (this.detail == view) {
        delete this.detail;
        this.removeDetail();
      }
    }, this);
    this.elDetail.children[0].appendChild(view.el);
    this.detail = view;
    this.$el.addClass("active");
    this.$el.after(this.elDetail);
    view.listenTo(view, "remove", () => {
      this.model.markRead();
    });
    this.setSelected(true);
  }
});
const LogMenu$1 = View.ContextMenu.extend({
  name: "LogMenu",
  actions: {
    "log menu close": { fn: "hide" },
    "clear-error": { fn: "clear_error" }
  },
  clear_error: function() {
    const model = this.collection.get(this.id);
    model.save("err", null, {
      error: function() {
        Msg.error("e_err");
      }
    });
  },
  onSync: function() {
    this.show();
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  renderMenu: function() {
    const model = this.collection.get(this.id);
    const works = new Model$2.Works(null, { sieve: model });
    this.$el.empty().append(
      LI(
        BUTTON({
          "class": "btn xbtn-light pull-right",
          "data-action": "log menu close"
        }, I({ "class": "fa fa-times" })),
        SPAN({ style: "margin-left: 18px;" }, I(T("l_changed_on")))
      ),
      LI(
        { "class": "xview" },
        SPAN(formatTime(model.get("ts_data"))),
        I(T("l_check_log")),
        SPAN(new Works({
          parent: this,
          collection: works
        }).render().el)
      ),
      LI(
        { "class": model.get("err") ? "xview" : "hide" },
        A({
          "data-action": "clear-error"
        }, T("a_clear_error"))
      )
    );
    this.listenTo(works, "sync", this.onSync);
  }
});
const ScheduleMenu$1 = View.ContextMenu.extend({
  name: "ScheduleMenu",
  actions: {
    "schedule menu close": { fn: "hide" }
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  onScheduleChange: function(schedule) {
    const model = this.collection.get(this.id);
    Msg.start("save", "l_loading");
    model.set("schedule", schedule, { silent: true });
    model.save(null, {
      patch: true,
      silent: true,
      data: {
        schedule: JSON.stringify(schedule)
      },
      error: function() {
        Msg.stop("save", { error: "e_req" });
      },
      success: function() {
        Msg.stop("save", { info: "m_saved_schedule" });
      }
    });
  },
  renderMenu: function() {
    const model = this.collection.get(this.id).clone();
    if (!model) {
      this.$el.text("Model not found:" + this.id);
      return this;
    }
    this.editedModel = model;
    const scheduleEditor = new SieveScheduleEditor({
      model,
      parent: this
    });
    this.$el.empty().append(
      LI(
        BUTTON({
          "class": "btn xbtn-light pull-right",
          "data-action": "schedule menu close"
        }, I({ "class": "fa fa-times" })),
        SPAN({ style: "margin-left: 18px;" }, I(T("l_schedule")))
      ),
      LI(
        { "class": "xview" },
        scheduleEditor.render().el
      )
    );
    this.off();
    this.listenTo(model, "change:schedule", this.onScheduleChange);
    setTimeout(() => scheduleEditor.focus(), 10);
  }
});
const SieveClientMenu = View.ContextMenu.extend({
  name: "SieveClientMenu",
  actions: {
    "menu client change": {
      fn: "action_client_change"
    },
    "menu client settings": {
      fn: "action_client_settings"
    }
  },
  action_client_change: function(id2) {
    const model = this.collection.get(this.id);
    Msg.start("save", "l_loading");
    model.save("client_id", id2, {
      wait: true,
      error: function() {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save");
        this.hide();
      }
    });
  },
  action_client_settings: function() {
    const modal = new View.Modal({
      parent: this.getRoot(),
      title: "l_devices",
      view: new ViewClients.ClientManager({
        parent: this.getRoot(),
        collection: App.clients
      })
    });
    modal.show();
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  renderMenu: function() {
    const model = this.collection.get(this.id);
    let availableClients = model.getAccessibleClients(App.clients);
    this.$el.empty();
    this.$el.append(
      LI(
        { "class": "xview" },
        SPAN(
          T("a_select_device")
        )
      ),
      LI({ "class": "divider" })
    ).append(
      availableClients.map(function(client) {
        return LI(
          client.id == model.get("client_id") ? A(
            { "style": "font-weight:bold;" },
            I({ "class": "fa fa-check" }),
            " ",
            client.getInfo()
          ) : A(
            {
              "data-action": "menu client change",
              "data-action-param": client.id
            },
            I({ "class": client.getIcon() }),
            " ",
            client.getInfo()
          )
        );
      })
    ).append(
      LI({ "class": "divider" }),
      LI(
        A(
          {
            "data-action": "menu client settings"
          },
          I({ "class": "fa fa-edit" }),
          " ",
          T("a_edit")
        )
      )
    );
  }
});
const SieveContextMenu$1 = View.ContextMenu.extend({
  name: "SieveContextMenu",
  actions: {
    "menu check changes": {
      fn: "action_check_for_changes"
    },
    "menu del": {
      fn: "action_del"
    },
    "menu del permanent": {
      fn: "action_del_permanent"
    },
    "menu duplicate": {
      fn: "action_duplicate"
    },
    "menu edit": {
      fn: "action_edit"
    },
    "menu_create_tpl": {
      fn: "action_create_tpl"
    }
  },
  action_check_for_changes: async function() {
    const model = this.collection.get(this.id);
    const ids = [this.id];
    if (model.isDeviceWeb()) {
      Msg.info("m_check_local_only");
    } else {
      serviceProxy.service.checkNow(ids);
    }
    this.hide();
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  },
  action_create_tpl: function() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/tpls/add-from/${this.id}.id`);
    this.hide();
  },
  action_del: function() {
    const model = this.collection.get(this.id);
    Msg.start("discard", "l_loading");
    model.save("state", C$2.STATE_DISCARD, {
      patch: true,
      error: function() {
        Msg.stop("discard", { error: "e_req" });
      },
      success: () => {
        model.collection.remove(model);
        Msg.stop("discard");
        this.hide();
      }
    });
  },
  action_duplicate: function() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/sieve/dup/${this.id}.id`);
    this.hide();
  },
  action_del_permanent: function() {
    const model = this.collection.get(this.id);
    Msg.start("destroy", "l_loading");
    model.destroy({
      error: () => {
        Msg.stop("destroy", { error: "e_req" });
      },
      success: () => {
        Msg.stop("destroy");
        this.hide();
      }
    });
  },
  action_edit: function() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/sieve/edit/${this.id}.id`);
    this.hide();
  },
  onActionAdd: function(model) {
    if (model.id)
      return;
    Msg.start("save", "m_saving");
    model.save(null, {
      error: () => {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save", { info: "m_saved_action" });
      }
    });
  },
  onActionChange: function(model) {
    if (!model.id) {
      const data = model.changed;
      model.once("sync", () => {
        model.set(data);
      }, this);
    } else {
      Msg.start("save", "m_saving");
      model.save(null, {
        silent: true,
        error: () => {
          Msg.stop("save", { error: "e_req" });
        },
        success: () => {
          Msg.stop("save", { info: "m_saved_action" });
        }
      });
    }
  },
  onActionRemove: function(model) {
    if (!model.id)
      return;
    Msg.start("save", "m_saving");
    model.destroy({
      error: () => {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save", { info: "m_deleted_action" });
      }
    });
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  renderMenu: function() {
    const model = this.collection.get(this.id);
    const actions = new Model$2.SieveActions(null, { parent: model });
    if (!model) {
      this.$el.text("Model not found:" + this.id);
      return this;
    }
    actions.fetch({ data: { state: 0 } });
    this.actionEditor = new SieveActionsEditor({
      actions,
      sieve: model,
      parent: this
    });
    this.$el.empty();
    if (Supports.agents.local) {
      this.$el.append(
        LI(A({ "data-action": "menu check changes" }, T("a_check_changes")))
      );
    }
    this.$el.append(
      LI(A({ "data-action": "menu edit" }, T("a_edit_options"))),
      LI(A({ "data-action": "menu duplicate" }, T("a_duplicate"))),
      LI(A({ "data-action": "menu_create_tpl" }, SPRINTF("a_action_object", "a_create", "l_tpl"))),
      LI({ "class": "divider" }),
      LI(
        { "class": "xview" },
        this.actionEditor.render().el
      ),
      LI({ "class": "divider" }),
      LI(A({ "data-action": "menu del" }, T("a_move_to_trash"))),
      LI(A({ "data-action": "menu del permanent" }, T("a_del_permanent")))
    );
    this.listenTo(this.actionEditor.models, "add", this.onActionAdd);
    this.listenTo(this.actionEditor.models, "change", this.onActionChange);
    this.listenTo(this.actionEditor.models, "remove", this.onActionRemove);
  }
});
const SievesListMenu = View.ContextMenu.extend({
  name: "SievesListMenu",
  renderMenu: function() {
    this.$el.empty().append(
      LI(
        { "class": "xview" },
        DIV(
          LABEL(T("l_sort_by"), ": "),
          this.selSort = SELECT(
            { "class": "pull-right" },
            OPTION({ value: "-ts_data" }, T("l_time_changed_on")),
            OPTION({ value: "name" }, T("l_name")),
            OPTION({ value: "client_id" }, T("l_device"))
          )
        )
      ),
      LI(
        { "class": "xview" },
        DIV(
          LABEL(T("l_page_size"), ": "),
          this.selPageSize = SELECT(
            { "class": "pull-right" },
            OPTION({ value: 5 }, 5),
            OPTION({ value: 20 }, 20),
            OPTION({ value: 50 }, 50),
            OPTION({ value: 100 }, 100),
            OPTION({ value: 200 }, "200!!"),
            OPTION({ value: 500 }, "500!!!")
          )
        )
      ),
      LI(
        { "class": "xview" },
        DIV(
          LABEL(T("l_device_filter"), ": "),
          this.selClientFilter = SELECT(
            { "class": "pull-right" },
            OPTION({ value: 1 }, T("l_devices_all")),
            OPTION({ value: 2 }, T("l_device_this"))
          )
        )
      )
    );
    this.selSort.value = App.store.get("ui.list.sortby") || "-ts_data";
    this.selPageSize.value = App.store.get("ui.list.pagesize") || "50";
    this.selClientFilter.value = App.store.get("ui.list.clientfilter") || "1";
    $$2(this.selSort).change(() => {
      App.store.set("ui.list.sortby", this.selSort.value);
      this.parent.reload();
    });
    $$2(this.selPageSize).change(() => {
      const size = parseInt(this.selPageSize.value);
      App.store.set("ui.list.pagesize", size);
      this.parent.reload(true);
    });
    $$2(this.selClientFilter).change(() => {
      App.store.set("ui.list.clientfilter", this.selClientFilter.value);
      this.parent.reload(true);
    });
  }
});
const SievesPageMenu = View.ContextMenu.extend({
  name: "SievesPageMenu",
  actions: {
    "menu topage": { fn: "action_topage" }
  },
  action_topage: function(n) {
    this.parent.navToPage(parseInt(n));
    this.hide();
  },
  renderMenu: function() {
    const { limit: limit2, nPages, total_count } = this.parent.collection.info();
    this.$el.empty().append(
      _$3.map(_$3.range(0, nPages), function(n) {
        return LI(
          A(
            {
              "data-action": "menu topage",
              "data-action-param": n
            },
            n * limit2 + 1 + " - " + Math.min((n + 1) * limit2, total_count)
          )
        );
      })
    ).css({
      maxHeight: 600,
      overflowY: "auto",
      fontSize: ".8em"
    });
  }
});
var Sieves = View.Entities.extend({
  name: "Sieves",
  actions: {
    "action_be_action_add": { fn: "action_be_action_add" },
    "action_be_action_remove": { fn: "action_be_action_remove" },
    "action_be_config": { fn: "action_be_config" },
    "action_be_device": { fn: "action_be_device" },
    "action_be_schedule": { fn: "action_be_schedule" },
    "action_be_switch_on": { fn: "action_be_switch_on" },
    "action_be_switch_off": { fn: "action_be_switch_off" },
    "action_global_actions": { fn: "action_global_actions" },
    "action_global_rules": { fn: "action_global_rules" },
    "sieve c4c": { fn: "action_check_for_changes" },
    "sieve client menu": { fn: "action_client_menu" },
    "sieve context menu": { fn: "action_context_menu" },
    "sieve del": { fn: "action_del" },
    "sieve del permanent": { fn: "action_del_permanent" },
    "sieve label apply": { fn: "action_apply_label" },
    "sieve list menu": { fn: "action_list_menu" },
    "sieve log menu": { fn: "action_log_menu" },
    "sieve mark_read": { fn: "action_mark_read" },
    "sieve mark_unread": { fn: "action_mark_unread" },
    "sieve nav next": { fn: "action_next" },
    "sieve nav prev": { fn: "action_prev" },
    "sieve nav topage menu": { fn: "action_topage_menu" },
    "sieve restore": { fn: "action_restore" },
    "sieve schedule menu": { fn: "action_schedule_menu" },
    "sieve select all": { fn: "action_select_all" },
    "sieve select none": { fn: "action_select_none" },
    "sieve select read": { fn: "action_select_read" },
    "sieve select unread": { fn: "action_select_unread" },
    "sieve switch": { fn: "action_switch_on_off" },
    "sieve sync": { fn: "action_sync" },
    "sieve view": { fn: "action_view", doc: "View sieve details" }
  },
  reloadImmediately: true,
  syncState: {
    syncing: false
  },
  events: {
    "click .xselect-all": "event_check"
  },
  ViewClass: SieveDetail$1,
  action_apply_label: function(id2, target) {
    const models = this.getSelectedModels();
    Msg.info("l_loading");
    async$2.eachSeries(models, function(model, callback) {
      let tags = model.get("tags");
      if (tags) {
        if (tags.indexOf(id2) >= 0) {
          return callback();
        }
        tags += "," + id2;
      } else {
        tags = id2;
      }
      model.save("tags", tags, {
        patch: true,
        error: function() {
          callback("e_req");
        },
        success: function() {
          callback();
        }
      });
    }, function(err) {
      if (err) {
        Msg.error("e_req");
      } else {
        Msg.reset();
      }
    });
  },
  action_be_action_add: function() {
    const sieve = new Backbone$3.Model();
    const actions = new Model$2.SieveActions(null, { parent: sieve });
    const actionEditor = new SieveActionsEditor({
      actions,
      sieve,
      parent: this
    }).render();
    const modal = new View.SaveDiscardModal({
      name: "BatchEdit$ActionAddModal",
      parent: this,
      title: "Add Actions - Batch Editor",
      view: actionEditor
    });
    modal.on("save", async () => {
      const ids = this.getSelectedIds();
      const actions2 = actionEditor.getPosts();
      try {
        for (let i2 = 0; i2 < actions2.length; i2 += 1) {
          const doc = actions2[i2].toJSON();
          await Api.api("/batch/sieves/actions", "POST", { ...doc, ids });
        }
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", function() {
      modal.remove();
    });
    modal.show();
    setTimeout(() => actionEditor.$(".dropdown-toggle").click(), 10);
  },
  action_be_action_remove: function() {
    const modal = new View.PromptModal({
      name: "BatchEdit$ActionRemoveModal",
      parent: this.getRoot(),
      title: "Remove Actions - Batch Edit",
      a_save: "Remove",
      msg: "This action will remove all actions for selected monitors. Remove all actions?"
    });
    modal.on("save", async () => {
      const ids = this.getSelectedIds();
      try {
        await Api.api("/batch/sieves/actions", "PUT", { ids, state: C$2.STATE_DEL });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.show();
  },
  action_be_config: function() {
    const selectedModels = this.getSelectedModels();
    const model = new Model$2.Sieve({
      content_type: C$2.TYPE_HTML,
      config: selectedModels[0].get("config").clone(),
      uri: selectedModels[0].get("uri")
    });
    openConfigEditor(model, "Config - Batch Edit", async (modal) => {
      Msg.info("l_loading");
      modal.remove();
      const ids = this.getSelectedIds();
      const config = model.toJSON().config;
      try {
        await Api.api("/batch/sieves", "PUT", { ids, config });
        Msg.reset();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
  },
  action_be_device: function() {
    const selectedModels = this.getSelectedModels();
    if (selectedModels.length == 0) {
      return;
    }
    const modelOne = selectedModels[0];
    const model = new Model$2.Sieve({
      content_type: C$2.TYPE_HTML,
      client_id: modelOne.get("client_id")
    });
    const clientSelector = new ViewClients.ClientSelector({ model });
    const view = new View.Base({
      el: DIV({ style: "margin: 5px;" }, clientSelector.el)
    });
    const modal = new View.SaveDiscardModal({
      name: "BatchEdit$Device",
      parent: this,
      title: "Device - Batch Editor",
      view
    });
    modal.on("save", async () => {
      try {
        const ids = this.getSelectedIds();
        const client_id = model.get("client_id");
        const proxy_id = model.get("proxy_id");
        const session_id = model.get("session_id");
        await Api.api("/batch/sieves", "PUT", { ids, client_id, proxy_id, session_id });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", function() {
      modal.remove();
    });
    modal.show();
  },
  action_be_schedule: function() {
    const model = new Backbone$3.Model({ schedule: new Model$2.Schedule() });
    const scheduleEditor = new SieveScheduleEditor({
      model,
      parent: this
    }).render();
    const modal = new View.SaveDiscardModal({
      name: "BatchEdit$ActionAddModal",
      parent: this,
      title: "Schedule - Batch Editor",
      view: scheduleEditor
    });
    modal.on("save", async () => {
      const ids = this.getSelectedIds();
      const schedule = model.toJSON().schedule;
      try {
        await Api.api("/batch/sieves", "PUT", { ids, schedule });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", function() {
      modal.remove();
    });
    modal.show();
  },
  action_be_switch_on: function() {
    const ids = this.getSelectedIds();
    const modal = new View.PromptModal({
      name: "BatchEdit$ActionRemoveModal",
      parent: this.getRoot(),
      title: "Switch On Monitors - Batch Edit",
      a_save: "Switch ON",
      msg: `${ids.length} monitors will be switched ON.`
    });
    modal.on("save", async () => {
      try {
        await Api.api("/batch/sieves", "PUT", { ids, state: C$2.STATE_READY });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.show();
  },
  action_be_switch_off: function() {
    const ids = this.getSelectedIds();
    const modal = new View.PromptModal({
      name: "BatchEdit$ActionRemoveModal",
      parent: this.getRoot(),
      title: "Switch Off Monitors - Batch Edit",
      a_save: "Switch OFF",
      msg: `${ids.length} monitors will be switched OFF.`
    });
    modal.on("save", async () => {
      try {
        await Api.api("/batch/sieves", "PUT", { ids, state: C$2.STATE_PAUSED });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.show();
  },
  action_global_actions: function() {
    showGlobalActionEditor();
  },
  action_global_rules: function() {
    showGlobalRuleEditor();
  },
  action_run_cloud_sieves: async function(models) {
    Msg.info("l_loading");
    const cloudIds = _$3.pluck(_$3.filter(models, function(model) {
      return model.isDeviceWeb();
    }), "id");
    if (cloudIds.length > 0) {
      try {
        await Api.utils("/sieve/run", "POST", { ids: cloudIds });
        Msg.info("m_started_check_for_changes");
      } catch (err) {
        console.error("Could not check for changes", err);
        Msg.error("m_check_for_changes_failed");
      }
    }
  },
  action_check_for_changes: async function(target) {
    const models = this.getSelectedModels();
    if (!Supports.agents.local) {
      this.action_run_cloud_sieves(models);
      return;
    }
    const ids = _$3.pluck(_$3.filter(models, (model) => model.isDeviceWeb()), "id");
    serviceProxy.service.checkNow(ids);
    if (models.length > ids.length) {
      Msg.info("m_check_local_only");
    }
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  },
  action_client_menu: function(id2, target) {
    this.clientMenu || (this.clientMenu = new SieveClientMenu({
      parent: this,
      collection: this.collection
    }));
    this.clientMenu.toggle(id2, target.nodeName == "I" ? target.parentNode : target);
  },
  action_context_menu: function(id2, target) {
    this.contextMenu || (this.contextMenu = new SieveContextMenu$1({
      parent: this,
      collection: this.collection
    }));
    this.contextMenu.toggle(
      id2,
      target.nodeName == "I" ? target.parentNode : target
    );
  },
  action_del: function() {
    const models = this.getSelectedModels();
    async$2.map(models, (model, callback) => {
      model.save("state", C$2.STATE_DISCARD, {
        patch: true,
        error: function() {
          callback(new Error("sieve:del:err"));
        },
        success: function() {
          model.collection.remove(model);
          callback();
        }
      });
    }, (err) => {
      if (err) {
        Msg.error("sieve:del:err");
      } else {
        const value = models.length;
        const msg = i18n.translate("m_del_item").ifPlural(value, T("m_del_items")).fetch(value);
        Msg.info(msg);
      }
    });
    return true;
  },
  action_del_permanent: function() {
    const models = this.getSelectedModels();
    async$2.eachLimit(models, 5, function(model, callback) {
      model.destroy({
        error: function() {
          callback(new Error("sieve:del:err"));
        },
        success: function() {
          callback();
        }
      });
    }, (err) => {
      if (err) {
        Msg.error("sieve:del:err");
      } else {
        Msg.info("Permanently deleted selected items.");
      }
    });
  },
  action_list_menu: function(param, target) {
    this.listMenu || (this.listMenu = new SievesListMenu({
      parent: this
    }));
    this.listMenu.toggle("list", $$2(target).parent(".btn-group")[0]);
  },
  action_log_menu: function(id2, target) {
    this.logMenu || (this.logMenu = new LogMenu$1({
      parent: this,
      collection: this.collection
    }));
    this.logMenu.toggle(id2, target ? target : this.getRow(id2).$el.find(".xsieve-ts-data")[0]);
  },
  action_mark_read: function() {
    const models = this.getSelectedModels();
    async$2.map(models, function(model, callback) {
      model.save({
        ts_view: dateToDBFormat(Date.now())
      }, {
        patch: true,
        error: function() {
          callback(new Error("sieve:update:err"));
        },
        success: function() {
          callback();
        }
      });
    }, function(err) {
      if (err) {
        Msg.error("sieve:update:err");
      }
    });
  },
  action_mark_unread: async function() {
    const models = this.getSelectedModels();
    for (let i2 = 0; i2 < models.length; i2 += 1) {
      let model = models[i2], ts_view = dateToDBFormat(0);
      await Api.api(`/sieves/${model.id}`, "PATCH", { ts_view });
      model.set({ ts_view });
    }
  },
  action_next: function() {
    let { currentPage, nPages } = this.collection.info();
    if (currentPage >= nPages - 1)
      return;
    this.navToPage(currentPage + 1);
  },
  action_prev: function() {
    let { currentPage } = this.collection.info();
    if (currentPage == 0)
      return;
    this.navToPage(currentPage - 1);
  },
  action_topage_menu: function(param, target) {
    this.pageMenu || (this.pageMenu = new SievesPageMenu({
      parent: this
    }));
    this.pageMenu.toggle("list", target);
  },
  action_restore: async function() {
    const models = this.getSelectedModels();
    let sieveConstraint = {};
    try {
      sieveConstraint = await checkSieveConstraint(models.length);
    } catch (e) {
      console.error(e);
      sieveConstraint = {
        isOverLimit: false
      };
    }
    if (sieveConstraint.isOverLimit) {
      Msg.error("m_monitor_limit");
      return;
    }
    async$2.map(models, function(model, callback) {
      model.save("state", C$2.STATE_READY, {
        patch: true,
        error: function() {
          callback(new Error("sieve:restore:err"));
        },
        success: function() {
          model.collection.remove(model);
          callback();
        }
      });
    }, (err) => {
      if (err) {
        Msg.error("sieve:restore:err");
      } else {
        Msg.info("m_restored_from_trash");
      }
    });
  },
  action_schedule_menu: function(id2, target) {
    this.scheduleMenu || (this.scheduleMenu = new ScheduleMenu$1({
      parent: this,
      collection: this.collection
    }));
    this.scheduleMenu.toggle(id2, target);
  },
  action_select_all: function() {
    this._select(_$3.identity, true);
  },
  action_select_none: function() {
    this._select(_$3.identity, false);
  },
  action_select_read: function() {
    this.action_select_none();
    this._select(function(view) {
      return view.model.isRead();
    }, true);
  },
  action_select_unread: function() {
    this.action_select_none();
    this._select(function(view) {
      return !view.model.isRead();
    }, true);
  },
  action_switch_on_off: function(id2) {
    const model = this.collection.get(id2);
    const state = model.get("state");
    const toggledState = state == C$2.STATE_READY ? C$2.STATE_PAUSED : C$2.STATE_READY;
    Msg.start("sieve:save", { info: "l_saving" });
    model.save(null, {
      data: { state: toggledState },
      patch: true,
      err: function(err, res) {
        Msg.stop("sieve:save", { error: "e_req" });
      },
      success: function() {
        Msg.stop("sieve:save");
        model.set("state", toggledState);
      }
    });
  },
  action_sync: async function() {
    if (!Supports.agents.local)
      return;
    Msg.info("l_syncing");
    let complete = false;
    try {
      await serviceProxy.SyncMan.sync(true);
      complete = true;
      Msg.reset();
    } catch (err) {
      console.error(JSON.stringify(err));
      try {
        complete = true;
        await serviceProxy.service.initSync();
      } catch (err2) {
        console.error(JSON.stringify(err2));
        Msg.error(err2.msg || err2.message || JSON.stringify(err2));
      }
    }
    setTimeout(function() {
      if (!complete) {
        Msg.info("l_syncing_wait");
      }
    }, 5e3);
  },
  action_view: function(id2) {
    let base2 = this._getBasePath();
    let path = base2;
    if (!this.modelView || this.modelView.model.id != id2) {
      path += `${id2}.id`;
    }
    let queryStr = lib.stringify(this.route.query);
    if (queryStr.length > 0) {
      path += `?${queryStr}`;
    }
    push$1(path);
  },
  event_check: function(e) {
    this._select(_$3.identity, e.target.checked);
  },
  _getBasePath() {
    let { module, team, prefix, data } = this.route;
    let base2 = `/w/${team}/${module}/${prefix}/`;
    if (data) {
      base2 = base2 + `${data}.d/`;
    }
    return base2;
  },
  _select: function(selector, selected) {
    _$3.each(this.views, function(view) {
      if (selector(view)) {
        view.setSelected(selected);
      }
    });
  },
  addOne: function(model, top) {
    if (!this.$list)
      return;
    const view = new SieveRow$1({ model, parent: this });
    const modelIndex = this.collection.indexOf(model);
    this.$list[top === true || modelIndex == 0 ? "prepend" : "append"](view.render().el);
    return view;
  },
  close_edit: function() {
    this.optsPanel.remove();
    this.opts = null;
  },
  recentFetchAndShow: function(id2) {
    const tsModMax = this.collection.length > 0 ? this.collection.max(
      (model) => new Date(model.get("ts_mod")).valueOf()
    ).get("ts_mod") : new Date(0).toISOString();
    const tCollection = new Model$2.Sieves();
    Msg.start("fetch", { info: "l_loading" });
    tCollection.fetch({
      data: _$3.extend({
        "ts_mod.gt": tsModMax,
        "_opt": {}
      }, getQuery(this.route)),
      success: () => {
        Msg.stop("fetch");
        this.collection.add(tCollection["models"], { merge: true, at: 0 });
      }
    });
  },
  async fetchAndShow(route2, force = false) {
    const limit2 = App.store.get("ui.list.pagesize") || 50;
    let oldRoute = this.route;
    let routeKeys = ["team", "prefix", "data", "query"];
    let reloadList = force || !oldRoute || routeKeys.filter((key) => !_$3.isEqual(route2[key], oldRoute[key])).length > 0;
    this.route = { ...route2 };
    if (reloadList) {
      Msg.start("fetch", { info: "l_loading" });
      this.collection.limit = limit2;
      let currentPage = parseInt(route2.query.page || "1") - 1;
      await this.collection.goto(currentPage, {
        sort: false,
        data: _$3.extend({
          _opt: {
            order: [this.getSortField()],
            limit: limit2,
            "a": "a"
          }
        }, getQuery(this.route)),
        success: (collection, resp, options) => {
          _$3.each(options.previousModels, function(model) {
            model.trigger("remove");
          });
        }
      });
      Msg.stop("fetch");
      this.onSelectionChange();
      if (this.collection.length == 0) {
        this.renderEmpty();
      } else {
        this.removeEmpty();
      }
      this.el.scrollIntoView();
    }
    if (route2.id) {
      this.show(route2.id);
    } else {
      this.removeModelView();
    }
  },
  reload(resetCurrentPage) {
    if (resetCurrentPage && this.route.query.page > 1) {
      push$1(this._getBasePath());
    } else {
      this.fetchAndShow(this.route, true);
    }
  },
  getRow: function(id2) {
    return _$3.find(this.views, function(view) {
      return view.model.id == id2;
    });
  },
  getSelectedIds: function() {
    return _$3.chain(this.children).select(function(child) {
      return child.isSelected && child.isSelected();
    }).map(function(child) {
      return child.model.id;
    }).value();
  },
  getSelectedModels: function() {
    return _$3.chain(this.children).select((child) => {
      return child.isSelected && child.isSelected();
    }).map((child) => {
      return this.collection.get(child.model.id);
    }).value();
  },
  getSortField: function() {
    const field = App.store.get("ui.list.sortby") || "-ts_data";
    this.collection.sortField = field;
    if (field == "name" && Supports.agents.local) {
      return "name nocase";
    }
    return field;
  },
  navToPage: function(n) {
    let base2 = this._getBasePath();
    if (n == 0 || !n) {
      let query = { ...this.route.query };
      delete query.page;
      let queryStr = lib.stringify(query);
      push$1(`${base2}?${queryStr}`);
    } else {
      let query = lib.stringify({ ...this.route.query, page: n + 1 });
      push$1(`${base2}?${query}`);
    }
  },
  onUserStateChange: function(data) {
    const oldError = this.errorUnreadModel.get("error");
    const oldUnread = this.errorUnreadModel.get("unread");
    const { error, unread, sync } = data;
    this.errorUnreadModel.set(data);
    let { currentPage } = this.collection.info();
    if (oldError < error && this.route.prefix == "error" && currentPage == 0) {
      this.recentFetchAndShow();
    }
    if (oldUnread < unread && this.route.prefix == "unread" && currentPage == 0) {
      this.recentFetchAndShow();
    }
    sync && this.onSyncStateUpdate(sync);
  },
  onSyncStateUpdate(sync) {
    this.syncState = sync;
    setTimeout(() => {
      const cl = this.elRefreshButton.children[0].classList;
      if (this.syncState.syncing && !cl.contains("fa-spin")) {
        cl.add("fa-spin");
      } else {
        cl.remove("fa-spin");
      }
    }, 200);
  },
  onSelectionChange: function() {
    const n = this.getSelectedModels().length;
    if (n > 0) {
      $$2(this.elTbar).addClass("xselected");
    } else {
      $$2(this.elTbar).removeClass("xselected");
    }
  },
  onSieveInsertDebounced: _$3.debounce(function() {
    this.reload();
    this.reloadImmediately = true;
  }, 2 * 1e3),
  onSieveInsert(e) {
    if (this.reloadImmediately) {
      this.reload();
      this.reloadImmediately = false;
    } else {
      this.onSieveInsertDebounced();
    }
  },
  onSieveUpdate: function(e) {
    if (e.op == "I") {
      if (!this.collection.get(e.id)) {
        this.onSieveInsert();
      }
    }
  },
  onSort: function() {
    const newKeys = this.collection.pluck("id");
    const oldKeys = _$3.keys(this.views);
    if (!_$3.isEqual(newKeys, oldKeys)) {
      this.collection.each(function(model) {
        const view = this.views[model.id];
        view.reattach();
      }, this);
    }
  },
  postInit: function(options) {
    this.listenTo(this.collection, "sort", this.onSort);
    this.listenTo(this.collection, "sync", this.updatePageInfo);
    this.listenTo(this.collection, "prop:select", this.onSelectionChange);
    this.route = {};
    this.clients = options.clients;
    this.labels = options.labels;
    this.labels.on("add", this.labelAddOne);
    this.labels.on("remove", this.labelRemoveOne);
    this.labels.on("reset", this.labelReset);
    this.listenTo(instance$4s, "sieves", this.onSieveUpdate);
    this.errorUnreadModel = new Backbone$3.Model();
    this.listenTo(instance$4s, "user_states", this.onUserStateChange);
  },
  removeOne: function(model) {
    View.Entities.prototype.removeOne.call(this, model);
    if (this.model && this.model.id == model.id) {
      this.removeModelView();
    }
    model.trigger("remove");
  },
  renderBase: function() {
    params.subscribe(this.renderTBar);
    let list;
    let empty2;
    this.$el.append(
      this.renderTBar(),
      TABLE(
        { "class": "xlist", "cellpadding": 0, style: "box-shadow: 3px 3px 3px #ccc" },
        COLGROUP(
          COL({ style: "width:28px" }),
          COL({ style: "width:28px" }),
          COL({ style: "width:304px; padding: 0 10px;" }),
          COL({ style: "" }),
          COL({ style: "width:72px; padding: 0 10px;" }),
          COL({ style: "width:72px" }),
          COL({ style: "width:42px" }),
          COL({ style: "width:40px" })
        ),
        list = TBODY()
      ),
      empty2 = DIV()
    );
    this.$empty = $$2(empty2);
    this.$list = $$2(list);
  },
  renderTBar() {
    let $params = get_store_value(params) || {};
    let team = $params.team;
    let elExport;
    const labelList = UL({
      "class": "dropdown-menu",
      "style": "overflow-y:auto;max-height:" + ($$2(window).height() - 120) + "px"
    });
    let route2 = this.route;
    let isLocal = Supports.agents.local;
    let elTbar = DIV(
      {
        "class": "xtbar xvbar-margin xalt" + (isLocal ? " xlocal" : ""),
        context: (route2 && route2.prefix) + (isLocal ? " local" : " cloud")
      },
      DIV(
        { "class": "btn-group" },
        INPUT({
          "class": "xselect-all",
          "type": "checkbox",
          "style": "margin: 0 6px 0 0;"
        }),
        BUTTON(
          {
            "type": "button",
            "class": "dropdown-toggle xbtn-light",
            "data-toggle": "dropdown"
          },
          SPAN({ "class": "caret" }),
          SPAN({ "class": "sr-only" }, "Dropdown Toggle")
        ),
        UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(A({ "href": "#", "data-action": "sieve select all" }, T("l_all"))),
          LI(A({ "href": "#", "data-action": "sieve select none" }, T("l_none"))),
          LI(A({ "href": "#", "data-action": "sieve select read" }, T("l_read"))),
          LI(A({ "href": "#", "data-action": "sieve select unread" }, T("l_unread")))
        )
      ),
      BUTTON({
        "data-action": "sieve c4c",
        "class": "btn btn-default",
        "context": "selected local notrash",
        "title": T("a_check_changes")
      }, I({ "class": "im-run" })),
      BUTTON({
        "data-action": "sieve restore",
        "class": "btn btn-default",
        "context": "trash"
      }, T("a_restore")),
      USER.account_id ? DIV(
        {
          "class": "btn-group",
          context: "selected all notrash"
        },
        A({
          "data-action": "sieve mark_read",
          "class": "btn btn-default",
          "context": "selected all notrash",
          "title": T("a_mark_read")
        }, I({ "class": "fa fa-check" })),
        BUTTON({
          "class": "btn btn-default dropdown-toggle",
          "data-toggle": "dropdown",
          style: "min-width: 20px"
        }, I({ "class": "caret" })),
        UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(
            A({
              tabindex: -1,
              href: "#",
              "data-action": "sieve mark_unread"
            }, T("Mark as unread"))
          )
        )
      ) : BUTTON({
        "data-action": "sieve mark_read",
        "class": "btn btn-default",
        "context": "selected all notrash",
        "title": T("a_mark_read")
      }, I({ "class": "fa fa-check" })),
      BUTTON({
        "data-action": "sieve del",
        "class": "btn btn-default",
        "context": "selected all notrash",
        "title": T("a_move_to_trash")
      }, I({ "class": "im-trash" })),
      BUTTON({
        "data-action": "sieve del permanent",
        "class": "btn btn-default",
        "context": "trash"
      }, T("a_del_permanent")),
      DIV(
        {
          "class": "btn-group",
          "context": "selected all notrash",
          "title": T("l_label")
        },
        BUTTON(
          { "class": "btn btn-default dropdown-toggle", "data-toggle": "dropdown" },
          I({ "class": "fa fa-tags" }),
          " ",
          SPAN({ "class": "caret" })
        ),
        labelList
      ),
      this.elRefreshButton = BUTTON(
        {
          "class": "btn btn-default",
          "context": "all nocloud",
          "data-action": "sieve sync",
          "title": T("l_sync")
        },
        I({ "class": "fa fa-refresh }" })
      ),
      DIV(
        {
          "class": "btn-group",
          "context": "all"
        },
        BUTTON(
          { "class": "btn btn-default dropdown-toggle", "data-toggle": "dropdown" },
          I({ "class": "fa fa-bars" }),
          " ",
          SPAN({ "class": "caret" })
        ),
        UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(
            { "class": "dropdown-submenu" },
            A({ href: "javascript:void(0);" }, T("a_export")),
            elExport = UL(
              { "class": "dropdown-menu", "role": "menu" },
              LI(A({ href: "#/w/export/json/", "data-type": "json" }, "JSON")),
              LI(A({ href: "#/w/export/csv/", "data-type": "csv" }, "CSV"))
            )
          ),
          LI(
            { "class": "dropdown-submenu" },
            A({ href: "javascript:void(0);" }, T("a_import")),
            UL(
              { "class": "dropdown-menu", "role": "menu" },
              LI(A({ href: `#/w/${team}/import/json/` }, "JSON")),
              LI(A({ href: `#/w/${team}/import/csv/` }, "CSV"))
            )
          ),
          LI(A({ href: `#/w/${team}/macros/` }, T("Macros"))),
          LI(A({ href: `#/w/${team}/profiles/` }, T("Profiles"))),
          LI(A({ href: `#/w/${team}/proxies/` }, T("Proxies"))),
          LI(A({ href: `#/w/${team}/tpls/all/` }, T("l_sieve_tpl_list"))),
          LI({ "class": "divider" }),
          LI(A({ "href": "javascript:void(0);", "data-action": "action_global_actions" }, T("Global Actions"))),
          LI(A({ "href": "javascript:void(0);", "data-action": "action_global_rules" }, T("Global Conditions"))),
          ""
        )
      ),
      DIV(
        {
          "class": "btn-group mr0",
          "context": "selected all"
        },
        BUTTON(
          { "class": "btn btn-default dropdown-toggle", "data-toggle": "dropdown" },
          `${T("a_bulk_edit")} `,
          SPAN({ "class": "caret" })
        ),
        !USER.id ? UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(A({ "href": "/ui/settings.html#general" }, T("Sign in")))
        ) : UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(
            { "class": "dropdown-submenu" },
            A({ href: "#" }, "Actions"),
            UL(
              { "class": "dropdown-menu", "role": "menu" },
              LI(A({ "href": "#", "data-action": "action_be_action_add" }, "Add")),
              LI({ "class": "divider" }),
              LI(A({ "href": "#", "data-action": "action_be_action_remove", "style": "color: red" }, "Remove All"))
            )
          ),
          LI(A({ "href": "#", "data-action": "action_be_config" }, T("Config"))),
          LI(A({ "href": "#", "data-action": "action_be_device" }, T("l_device"))),
          LI(A({ "href": "#", "data-action": "action_be_schedule" }, T("l_schedule"))),
          LI(A({ "href": "#", "data-action": "action_be_switch_on" }, T("Switch ON"))),
          LI(A({ "href": "#", "data-action": "action_be_switch_off" }, T("Switch OFF"))),
          ""
        )
      ),
      DIV(
        { "class": "btn-group right xoptional" },
        BUTTON(
          {
            "class": "btn btn-default",
            "data-action": "sieve list menu"
          },
          I({ "class": "fa fa-cog" }),
          " ",
          SPAN({ "class": "caret" })
        )
      ),
      UL(
        { "class": "pagination pagination-sm right", "style": "margin: 0 5px 0 0" },
        LI(
          A(
            { "href": "", "data-action": "sieve nav topage menu" },
            this.pageInfo = SPAN(T("l_loading")),
            " ",
            I({ "class": "fa fa-caret-down" })
          )
        ),
        this.pagePrev = LI(
          A(
            { "href": "", "data-action": "sieve nav prev" },
            I({ "class": "fa fa-chevron-left" })
          )
        ),
        this.pageNext = LI(
          A(
            { "href": "", "data-action": "sieve nav next" },
            I({ "class": "fa fa-chevron-right" })
          )
        )
      )
    );
    this.$labelList = $$2(labelList);
    elExport.onclick = (e) => {
      e.preventDefault();
      let path = location.hash.slice(1);
      if (path.startsWith(`/w/${team}/export/`)) {
        return;
      }
      let { prefix, data, id: id2, query } = this.route;
      let exportQueryData = { prefix, data, id: id2, query };
      push$1(`/w/${team}/export/${e.target.dataset.type}/${lib.stringify(exportQueryData)}.d/`);
    };
    if (this.elTbar) {
      elTbar.className = this.elTbar.className;
      this.elTbar.replaceWith(elTbar);
    }
    this.elTbar = elTbar;
    this.updatePageInfo();
    this.labelReset();
    return this.elTbar;
  },
  removeEmpty: function() {
    this.$empty.empty();
  },
  renderEmpty: function() {
    App.sieves.reset();
    const isInbox = this.route.prefix == "all";
    this.$empty.empty().append(
      isInbox && !Supports.agents.local ? DIV(
        { "class": "pt-4" },
        P(
          { style: "font-size: 1em" },
          "This is webapp's Watchlist. It contains list of all monitors. ",
          "Start monitoring web by adding a monitor using the Add button. ",
          "Install Distill's browser extension to get the fastest web monitoring experience: ",
          A({ href: "https://distill.io/apps/web-monitor" }, "download extension."),
          BR(),
          A({ "class": "mt3", href: "https://distill.io/help/watchlist" }, "Learn More")
        )
      ) : H4("No monitor found.")
    );
  },
  renderModelView: function(model, view) {
    const row = this.getRow(model.id);
    row && row.showDetail(view.render());
  },
  show: function(id2) {
    if (this.model) {
      if (this.model.id == id2) {
        return;
      }
      this.removeModelView();
    }
    this.model = this.collection.get(id2);
    if (this.model) {
      return this.showModelView(this.model);
    } else {
      return this.show404();
    }
  },
  show404: function() {
    Msg.error("Monitor not found");
    return false;
  },
  showDefault: function() {
    this.removeModelView();
  },
  showModelView: function(model) {
    model.markRead();
    return Sieves.__super__.showModelView.call(this, model);
  },
  updatePageInfo: function() {
    const coll = this.collection;
    const { currentPage, offset, nPages, total_count } = coll.info();
    const { length } = coll;
    this.pageInfo.textContent = SPRINTF(
      "m_start_end_of_total",
      offset + (length > 0 ? 1 : 0),
      offset + length,
      total_count
    );
    $$2(this.pagePrev)[currentPage <= 0 ? "addClass" : "removeClass"]("disabled");
    $$2(this.pageNext)[currentPage + 1 >= nPages ? "addClass" : "removeClass"]("disabled");
  }
});
function dateToDBFormat(date) {
  return moment$2(date).format();
}
function create_fragment$2q(ctx) {
  let div;
  return {
    c() {
      div = element("div");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[3](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[3](null);
    }
  };
}
function instance$2n($$self, $$props, $$invalidate) {
  const omit_props_names = ["view", "renderedView"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { view } = $$props;
  let { renderedView = null } = $$props;
  const parent2 = getContext("view:root");
  let el;
  onMount(() => {
    $$invalidate(1, renderedView = new view({ ...$$restProps, parent: parent2, el }).render());
    return () => {
      renderedView.remove();
    };
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("view" in $$new_props)
      $$invalidate(2, view = $$new_props.view);
    if ("renderedView" in $$new_props)
      $$invalidate(1, renderedView = $$new_props.renderedView);
  };
  return [el, renderedView, view, div_binding];
}
class BackboneWrapper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2n, create_fragment$2q, safe_not_equal, { view: 2, renderedView: 1 });
  }
}
async function fetchUserAttr(attr2) {
  const attrModel = new AttrModel.UserAttrs();
  const result = await attrModel.fetch({
    data: {
      "name": attr2,
      "state.in": [10, 40],
      "_opt": {
        order: ["ts"]
      }
    }
  });
  const collection = result[0];
  return collection.models;
}
function predefinedTones() {
  return [
    {
      id: "/skin/media/bell_strike.ogg",
      name: T("l_bell_strike")
    },
    {
      id: "/skin/media/asian_koel.ogg",
      name: T("l_asian_koel")
    },
    {
      id: "/skin/media/ding_dong.ogg",
      name: T("l_ding_dong")
    },
    {
      id: "/skin/media/buzzer.ogg",
      name: T("l_buzzer")
    }
  ];
}
async function fetchTones() {
  const tones = [];
  if (Supports.agents.local) {
    let doc = await serviceProxy.store.KVStore.findOne("tones");
    if (doc) {
      const customTones = JSON.parse(doc.value).map((tone) => ({ id: tone.value, name: tone.label }));
      customTones.forEach((tone) => tones.push(tone));
    }
  }
  return tones;
}
async function fetchMacros() {
  const macros = [];
  const macroModel = new Macros([], { orderBy: "-ts" });
  await macroModel.fetch({
    success: function(collection, response, options) {
      collection.models.forEach((model) => {
        macros.push({ id: model.get("id"), name: model.get("name") });
      });
    }
  });
  return macros;
}
const attributes = {
  "run": "Checks",
  "action": "Actions",
  "email": "Emails",
  "sms": "SMS",
  "push": "Push notifications",
  "action_macro": "Macro Action"
};
function isQuotaAvailable(user, actionType) {
  var _a;
  const action = (_a = SieveActionDescList[actionType].constraint_id) != null ? _a : "action";
  if (user.isLoggedIn() && !user.isFlexi()) {
    let message;
    const constraint = user.get("constraint");
    const usage = user.get("usage");
    if (!constraint[action]) {
      message = `${action === "action" ? "Action" : attributes[action]} not included in your plan.`;
    } else if (constraint[action] - usage[action] <= 0) {
      message = `${usage[action]} of ${constraint[action]} ${attributes[action]} used.`;
    }
    return {
      error: message
    };
  }
}
const SieveActionDescList = {
  [C$2.ACTION_EMAIL]: {
    constraint_id: "email",
    label: "l_action_email",
    icon: "fa-envelope-o",
    plugins: ["datafetch", "login", "quota"],
    fields: {
      email: {
        type: "enum",
        required: true,
        multi: false,
        options: []
      }
    },
    addByDefault: function(Supports2) {
      return Supports2.user && Supports2.email;
    }
  },
  [C$2.ACTION_PUSH]: {
    constraint_id: "push",
    label: "l_action_push",
    icon: "fa-mobile",
    plugins: ["app", "paid", "quota", "single"],
    addByDefault: function(Supports2) {
      return false;
    }
  },
  [C$2.ACTION_SMS]: {
    constraint_id: "sms",
    label: "l_action_sms",
    icon: "fa-mobile",
    plugins: ["datafetch", "login", "paid", "quota"],
    fields: {
      phone: {
        type: "enum",
        required: true,
        dropdown: true,
        options: [],
        multi: false
      }
    },
    addByDefault: function(Supports2) {
      return false;
    }
  },
  [C$2.ACTION_DISCORD]: {
    label: "l_action_discord",
    icon: "fa-terminal",
    plugins: ["login", "paid", "quota"],
    fields: {
      discord: {
        required: true,
        type: "url"
      }
    },
    addByDefault: function(Supports2) {
      return false;
    }
  },
  [C$2.ACTION_SLACK]: {
    label: "l_action_slack",
    icon: "fa-slack",
    plugins: ["login", "paid", "quota"],
    fields: {
      slack: {
        required: true,
        type: "url"
      }
    },
    addByDefault: function(Supports2) {
      return false;
    }
  },
  [C$2.ACTION_WEBHOOK]: {
    label: "l_action_webhook",
    icon: "fa-terminal",
    plugins: ["login", "paid", "quota"],
    fields: {
      url: {
        required: true,
        type: "url"
      },
      data: {
        required: false,
        type: "json",
        default: {}
      },
      headers: {
        required: false,
        type: "json",
        default: {}
      }
    }
  },
  [C$2.ACTION_LOCAL_OPEN_TAB]: {
    label: "l_action_local_open_tab",
    icon: "fa-file-o",
    plugins: ["local", "single"],
    addByDefault: function() {
      return false;
    }
  },
  [C$2.ACTION_LOCAL_POPUP]: {
    label: "l_action_local_popup",
    icon: "fa-comment-o",
    plugins: ["local", "single"],
    addByDefault: function(Supports2) {
      return Supports2.agents.local;
    }
  },
  [C$2.ACTION_LOCAL_AUDIO]: {
    label: "l_action_local_audio",
    icon: "fa-volume-up",
    plugins: ["audio", "datafetch", "local", "single"],
    fields: {
      tone: {
        required: true,
        type: "enum",
        multi: false,
        options: []
      }
    },
    addByDefault: function(Supports2) {
      return Supports2.agents.local;
    }
  },
  [C$2.ACTION_MACRO]: {
    constraint_id: "action_macro",
    label: "l_action_macro_open_tab",
    icon: "fa fa-tasks",
    plugins: ["datafetch", "login", "paid", "quota"],
    fields: {
      macro_id: {
        type: "enum",
        required: true,
        multi: false,
        options: []
      }
    }
  }
};
function get_each_context$B(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2][0];
  child_ctx[24] = list[i2][1];
  return child_ctx;
}
function create_catch_block$i(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$i(ctx) {
  let div2;
  let div1;
  let button;
  let t0;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_2$C, create_else_block$I];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7].has("login") && !ctx2[3].isLoggedIn())
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[5] == C$2.ACTION_WEBHOOK && create_if_block_1$R(ctx);
  let if_block2 = ctx[5] == C$2.ACTION_WEBHOOK && ctx[2] && create_if_block$1d(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      button = element("button");
      t0 = space();
      div0 = element("div");
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      attr(button, "class", "btn fa fa-trash-o xbtn-light py-2");
      attr(button, "title", T("h_del_action"));
      attr(div0, "class", "d-inline-flex flex-grow-1 flex-column gap-2");
      attr(div1, "class", "d-flex align-items-center gap-2");
      attr(div2, "class", "d-flex flex-column");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, button);
      append(div1, t0);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if_block0.p(ctx2, dirty);
      if (ctx2[5] == C$2.ACTION_WEBHOOK)
        if_block1.p(ctx2, dirty);
      if (ctx2[5] == C$2.ACTION_WEBHOOK && ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1d(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$I(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = Object.entries(ctx[0]);
  const get_key = (ctx2) => ctx2[23];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$B(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$B(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 755) {
        each_value = Object.entries(ctx2[0]);
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$B, each_1_anchor, get_each_context$B);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2$C(ctx) {
  let a;
  let b;
  return {
    c() {
      a = element("a");
      b = element("b");
      b.textContent = `${T("a_signin")}`;
      attr(a, "href", urlCfg.login);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, b);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_8$2(ctx) {
  let inputedit;
  let current;
  inputedit = new InputEdit({
    props: {
      classes: "w-auto form-control-sm",
      field: ctx[6].fields[ctx[23]]
    }
  });
  return {
    c() {
      create_component(inputedit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputedit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputedit_changes = {};
      if (dirty & 1)
        inputedit_changes.field = ctx2[6].fields[ctx2[23]];
      inputedit.$set(inputedit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputedit, detaching);
    }
  };
}
function create_if_block_7$4(ctx) {
  let urledit;
  let current;
  urledit = new UrlEdit({
    props: {
      classes: "w-auto form-control-sm",
      field: ctx[6].fields[ctx[23]]
    }
  });
  return {
    c() {
      create_component(urledit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urledit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const urledit_changes = {};
      if (dirty & 1)
        urledit_changes.field = ctx2[6].fields[ctx2[23]];
      urledit.$set(urledit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(urledit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urledit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urledit, detaching);
    }
  };
}
function create_if_block_3$u(ctx) {
  let div;
  let searchablemenu;
  let t0;
  let show_if = ctx[5] == C$2.ACTION_LOCAL_AUDIO && ctx[7].has("audio");
  let t1;
  let current;
  function select_handler(...args) {
    return ctx[14](ctx[24], ...args);
  }
  searchablemenu = new SearchableMenu({
    props: {
      field: ctx[24],
      actionClass: "btn btn-default btn-sm",
      style: "--bs-btn-padding-y: .1rem",
      allItems: ctx[1],
      allowNull: false,
      "data-bs-auto-close": "false",
      $$slots: { bottom: [create_bottom_slot$3] },
      $$scope: { ctx }
    }
  });
  searchablemenu.$on("open", ctx[13]);
  searchablemenu.$on("select", select_handler);
  let if_block = show_if && create_if_block_4$k(ctx);
  return {
    c() {
      div = element("div");
      create_component(searchablemenu.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      attr(div, "class", "d-flex align-self-start align-items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(searchablemenu, div, null);
      append(div, t0);
      if (if_block)
        if_block.m(div, null);
      append(div, t1);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const searchablemenu_changes = {};
      if (dirty & 1)
        searchablemenu_changes.field = ctx[24];
      if (dirty & 2)
        searchablemenu_changes.allItems = ctx[1];
      if (dirty & 134217728) {
        searchablemenu_changes.$$scope = { dirty, ctx };
      }
      searchablemenu.$set(searchablemenu_changes);
      if (show_if)
        if_block.p(ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(searchablemenu);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_6$6(ctx) {
  let li;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      li.innerHTML = `<a href="#" class="dropdown-item">Manage Phones</a>`;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (!mounted) {
        dispose = listen(li, "click", ctx[12]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$d(ctx) {
  let li;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      li.innerHTML = `<a href="#" class="dropdown-item">Manage Emails</a>`;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (!mounted) {
        dispose = listen(li, "click", ctx[11]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_bottom_slot$3(ctx) {
  let li;
  let t;
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[5] == C$2.ACTION_EMAIL)
      return create_if_block_5$d;
    if (ctx2[5] == C$2.ACTION_SMS)
      return create_if_block_6$6;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      li = element("li");
      li.innerHTML = `<hr class="dropdown-divider"/>`;
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t);
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_4$k(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = `${T("a_play")}`;
      attr(a, "href", "javascript:void 0");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[15]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$B(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$u, create_if_block_7$4, create_if_block_8$2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[24].def.type == "enum")
      return 0;
    if (ctx2[24].def.type == "url")
      return 1;
    if (ctx2[24].def.type == "text")
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$R(ctx) {
  let a;
  let t0_value = ctx[2] ? "Hide" : "Show";
  let t0;
  let t1;
  let t2_value = T("l_options") + "";
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      attr(a, "href", "javascript:void 0");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[2] ? "Hide" : "Show"))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1d(ctx) {
  let requesteditor;
  let current;
  requesteditor = new RequestEditor({
    props: {
      formModel: ctx[6],
      configureBody: false
    }
  });
  return {
    c() {
      create_component(requesteditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
    }
  };
}
function create_pending_block$i(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$2p(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$i,
    then: create_then_block$i,
    catch: create_catch_block$i,
    value: 22,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$2m($$self, $$props, $$invalidate) {
  var _a;
  let $user;
  let { action } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(17, $user = value));
  const dispatch = createEventDispatcher();
  const type = action.get("type");
  const config = (_a = action.get("config")) != null ? _a : {};
  const desc = SieveActionDescList[type];
  const fieldDefs = desc.fields;
  const sieveActionModel = new FormModel(fieldDefs, config);
  const fields = sieveActionModel.fields;
  const plugins = new Set(desc.plugins);
  let data = [];
  let showRequestEditor = false;
  action.set("form-model", sieveActionModel);
  function removeAction() {
    dispatch("remove", action.cid);
  }
  function createListItem(model) {
    const name = model.get("value");
    const state = model.get("state");
    return {
      id: name,
      name: name + (state === C$2.STATE_NEW ? " - unverified " : "")
    };
  }
  async function fetchData() {
    var _a2, _b, _c;
    if (plugins.has("datafetch")) {
      if (type == C$2.ACTION_EMAIL) {
        const emails = await fetchUserAttr("email");
        $$invalidate(1, data = emails.map(createListItem));
        $$invalidate(0, fields.email.def.options = data, fields);
        if (!fields.email.get()) {
          fields.email.set(data.find((e) => e.id === $user.email) ? $user.email : (_a2 = data[0]) == null ? void 0 : _a2.id);
        }
      } else if (type == C$2.ACTION_SMS) {
        const phones = await fetchUserAttr("phone");
        $$invalidate(1, data = phones.map(createListItem));
        $$invalidate(0, fields.phone.def.options = data, fields);
        if (!fields.phone.get()) {
          fields.phone.set((_b = data[0]) == null ? void 0 : _b.id);
        }
      } else if (type == C$2.ACTION_LOCAL_AUDIO) {
        const predefTones = predefinedTones();
        const tones = await fetchTones();
        $$invalidate(1, data = [...predefTones, ...tones]);
        $$invalidate(0, fields.tone.def.options = data, fields);
        if (!fields.tone.get()) {
          fields.tone.set((_c = data[0]) == null ? void 0 : _c.id);
        }
      } else if (type == C$2.ACTION_MACRO) {
        $$invalidate(1, data = await fetchMacros());
        $$invalidate(0, fields.macro_id.def.options = data, fields);
      } else {
        $$invalidate(1, data = []);
      }
    }
  }
  const click_handler = () => dispatch("manage", "email");
  const click_handler_1 = () => dispatch("manage", "phone");
  const open_handler = () => fetchData();
  const select_handler = (field, e) => field.set(e.detail);
  const click_handler_2 = async () => {
    const audio = new Audio();
    let tone = fields.tone.get();
    if (tone) {
      if (tone.indexOf("tone:") == 0) {
        let doc = await serviceProxy.store.KVStore.findOne(tone);
        tone = doc.value;
      }
      audio.src = tone;
      audio.load();
      audio.play();
    }
  };
  const click_handler_3 = () => {
    $$invalidate(2, showRequestEditor = !showRequestEditor);
  };
  $$self.$$set = ($$props2) => {
    if ("action" in $$props2)
      $$invalidate(10, action = $$props2.action);
  };
  return [
    fields,
    data,
    showRequestEditor,
    user,
    dispatch,
    type,
    sieveActionModel,
    plugins,
    removeAction,
    fetchData,
    action,
    click_handler,
    click_handler_1,
    open_handler,
    select_handler,
    click_handler_2,
    click_handler_3
  ];
}
class SieveActionEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2m, create_fragment$2p, safe_not_equal, { action: 10 });
  }
}
function get_each_context$A(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function create_if_block_4$j(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "class", "btn fa fa-trash-o xbtn-light");
      attr(button, "title", T("h_del_action"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(ctx[8])));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$t(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "class", "btn fa fa-plus xbtn-light pull-right");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(ctx[7])));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$Q(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[4].models;
  const get_key = (ctx2) => ctx2[13].cid;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$A(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$A(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 17) {
        each_value = ctx2[4].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$A, each_1_anchor, get_each_context$A);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block$1c(ctx) {
  let p;
  let t0_value = ctx[5].error + "";
  let t0;
  let t1;
  let a;
  let t2_value = T("l_learn_more") + "";
  let t2;
  return {
    c() {
      p = element("p");
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      t2 = text(t2_value);
      attr(a, "href", urlCfg.usageAvailabilityForTeam());
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener");
      attr(p, "class", "error mt-[-5px] p-[5px] pl-[36px] text-base");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
      append(p, a);
      append(a, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t0_value !== (t0_value = ctx2[5].error + ""))
        set_data(t0, t0_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_2$B(ctx) {
  let sieveactioneditor;
  let current;
  sieveactioneditor = new SieveActionEditor({ props: { action: ctx[13] } });
  sieveactioneditor.$on("remove", ctx[9]);
  sieveactioneditor.$on("manage", ctx[10]);
  return {
    c() {
      create_component(sieveactioneditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveactioneditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveactioneditor_changes = {};
      if (dirty & 16)
        sieveactioneditor_changes.action = ctx2[13];
      sieveactioneditor.$set(sieveactioneditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveactioneditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveactioneditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveactioneditor, detaching);
    }
  };
}
function create_each_block$A(key_1, ctx) {
  let first;
  let show_if = ctx[13].get("type") == ctx[0];
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_2$B(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 17)
        show_if = ctx[13].get("type") == ctx[0];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$B(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$2o(ctx) {
  let div;
  let t0;
  let show_if = !ctx[3].has("single");
  let t1;
  let span1;
  let span0;
  let t2_value = T(ctx[2].label) + "";
  let t2;
  let t3;
  let current_block_type_index;
  let if_block2;
  let current;
  let if_block0 = (ctx[5].error || !ctx[6]) && create_if_block_4$j(ctx);
  let if_block1 = show_if && create_if_block_3$t(ctx);
  const if_block_creators = [create_if_block$1c, create_if_block_1$Q];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5].error)
      return 0;
    if (ctx2[6])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      span1 = element("span");
      span0 = element("span");
      t2 = text(t2_value);
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "class", "xtype-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      append(div, span1);
      append(span1, span0);
      append(span0, t2);
      append(span1, t3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[5].error || !ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4$j(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 8)
        show_if = !ctx2[3].has("single");
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3$t(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty & 4) && t2_value !== (t2_value = T(ctx2[2].label) + ""))
        set_data(t2, t2_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block2) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block2 = if_blocks[current_block_type_index];
          if (!if_block2) {
            if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block2.c();
          } else {
            if_block2.p(ctx2, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(span1, null);
        } else {
          if_block2 = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$2l($$self, $$props, $$invalidate) {
  let $actions, $$unsubscribe_actions = noop, $$subscribe_actions = () => ($$unsubscribe_actions(), $$unsubscribe_actions = subscribe(actions, ($$value) => $$invalidate(4, $actions = $$value)), actions);
  $$self.$$.on_destroy.push(() => $$unsubscribe_actions());
  let { type } = $$props;
  let { actions } = $$props;
  $$subscribe_actions();
  const user = getContext("user");
  const dispatch = createEventDispatcher();
  let desc = null;
  let plugins = null;
  let quotaAvailability = {};
  let renderSieveActionEditor = false;
  const onActionAdd = () => {
    actions.add(new Model$2.SieveAction[type]());
  };
  function onActionRemove() {
    const action = actions.where({ type }).at(0);
    dispatch("remove", action.cid);
  }
  function remove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function manage_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("actions" in $$props2)
      $$subscribe_actions($$invalidate(1, actions = $$props2.actions));
  };
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & 29) {
      {
        if ($actions) {
          $$invalidate(2, desc = SieveActionDescList[type]);
          $$invalidate(3, plugins = new Set(desc.plugins));
          if (plugins.has("quota")) {
            $$invalidate(5, quotaAvailability = (_a = isQuotaAvailable(user, type)) != null ? _a : {});
          }
          $$invalidate(6, renderSieveActionEditor = !!desc.fields);
        }
      }
    }
  };
  return [
    type,
    actions,
    desc,
    plugins,
    $actions,
    quotaAvailability,
    renderSieveActionEditor,
    onActionAdd,
    onActionRemove,
    remove_handler,
    manage_handler
  ];
}
class SieveActionGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2l, create_fragment$2o, safe_not_equal, { type: 0, actions: 1 });
  }
}
function get_each_context$z(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i2];
  return child_ctx;
}
function get_each_context_1$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  return child_ctx;
}
function create_each_block_1$4(ctx) {
  let li;
  let a;
  let i2;
  let t0;
  let span;
  let t1_value = T(ctx[27].label) + "";
  let t1;
  let t2_value = ctx[27].paid ? " *" : "";
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[15](ctx[27]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      i2 = element("i");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = text(t2_value);
      attr(i2, "class", "fa " + ctx[27].icon);
      set_style(span, "margin-left", "10px");
      attr(a, "class", "dropdown-item");
      attr(a, "href", "#");
      attr(a, "tabindex", "-1");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, i2);
      append(a, t0);
      append(a, span);
      append(span, t1);
      append(span, t2);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$P(ctx) {
  let a;
  let t0;
  let span;
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t0 = text("Global Actions: ");
      span = element("span");
      t1 = text(ctx[3]);
      attr(a, "href", "javascript:void 0");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, span);
      append(span, t1);
      if (!mounted) {
        dispose = listen(a, "click", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t1, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1b(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "No action added - add one to get alerted on changes";
      attr(div, "class", "alert alert-warning hide");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$z(ctx) {
  let sieveactiongroup;
  let current;
  sieveactiongroup = new SieveActionGroup({
    props: {
      type: ctx[24],
      actions: ctx[0]
    }
  });
  sieveactiongroup.$on("remove", ctx[9]);
  sieveactiongroup.$on("manage", ctx[17]);
  return {
    c() {
      create_component(sieveactiongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveactiongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveactiongroup_changes = {};
      if (dirty & 4)
        sieveactiongroup_changes.type = ctx2[24];
      if (dirty & 1)
        sieveactiongroup_changes.actions = ctx2[0];
      sieveactiongroup.$set(sieveactiongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveactiongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveactiongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveactiongroup, detaching);
    }
  };
}
function create_fragment$2n(ctx) {
  let div1;
  let div0;
  let a0;
  let t1;
  let ul;
  let t2;
  let li;
  let a1;
  let t5;
  let t6;
  let t7;
  let current;
  let each_value_1 = Model$2.SieveActionDescList;
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i2));
  }
  let if_block0 = !ctx[5] && create_if_block_1$P(ctx);
  let if_block1 = !ctx[1].length && create_if_block$1b();
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$z(get_each_context$z(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      a0 = element("a");
      a0.textContent = `${T("a_add_action")}`;
      t1 = space();
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t2 = space();
      li = element("li");
      a1 = element("a");
      a1.textContent = `*\xA0${T("m_premium_only")}`;
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(a0, "href", "#");
      attr(a0, "class", "dropdown-toggle");
      attr(a0, "data-bs-toggle", "dropdown");
      attr(a1, "href", "javascript:void 0");
      attr(a1, "class", "dropdown-item disabled");
      attr(li, "class", "text-end");
      attr(ul, "class", "dropdown-menu");
      attr(ul, "role", "menu");
      attr(div0, "class", "d-flex gap-3");
      set_style(div1, "position", "relative");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, a0);
      append(div0, t1);
      append(div0, ul);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(ul, null);
        }
      }
      append(ul, t2);
      append(ul, li);
      append(li, a1);
      append(div0, t5);
      if (if_block0)
        if_block0.m(div0, null);
      append(div1, t6);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t7);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 256) {
        each_value_1 = Model$2.SieveActionDescList;
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$4(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
          } else {
            each_blocks_1[i2] = create_each_block_1$4(child_ctx);
            each_blocks_1[i2].c();
            each_blocks_1[i2].m(ul, t2);
          }
        }
        for (; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (!ctx2[5])
        if_block0.p(ctx2, dirty);
      if (!ctx2[1].length) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block$1b();
          if_block1.c();
          if_block1.m(div1, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 517) {
        each_value = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$z(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$z(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks_1, detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2k($$self, $$props, $$invalidate) {
  const omit_props_names = ["actions", "migrateChanges", "getChanges", "getPosts", "getPuts"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $actions, $$unsubscribe_actions = noop, $$subscribe_actions = () => ($$unsubscribe_actions(), $$unsubscribe_actions = subscribe(actions, ($$value) => $$invalidate(1, $actions = $$value)), actions);
  let $user;
  let $sieve;
  $$self.$$.on_destroy.push(() => $$unsubscribe_actions());
  let { actions } = $$props;
  $$subscribe_actions();
  const { sieve, global } = $$restProps;
  component_subscribe($$self, sieve, (value) => $$invalidate(18, $sieve = value));
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(14, $user = value));
  const dispatch = createEventDispatcher();
  let dels = [];
  let groups = [];
  const groupsSet = /* @__PURE__ */ new Set();
  let globalActionsCount = 0;
  if (!actions) {
    $$subscribe_actions(actions = new Model$2.SieveActions(null, { parent: sieve }));
    if (sieve && $sieve.id) {
      actions.fetch({ data: { state: 0 } });
    }
  }
  async function fetchGlobalActions() {
    try {
      const data = await Api.api("/prefs/actions");
      Msg.reset();
      return data;
    } catch (e) {
      console.error(e);
      Msg.error("Please try again later. Failed to fetch global actions.");
      if (global) {
        dispatch("close");
      }
    }
  }
  async function setGlobalActionCount() {
    const globalActions = await fetchGlobalActions();
    $$invalidate(3, globalActionsCount = (globalActions == null ? void 0 : globalActions.length) || 0);
  }
  onMount(async () => {
    if (global) {
      let data = await fetchGlobalActions();
      actions.set({ data }, { parse: true });
    }
  });
  function addAction(type) {
    const Type = Model$2.SieveAction[type];
    const existingActions = actions.models.filter((action) => action.get("type") === Type.desc.type);
    if (Type.desc.single && existingActions.length) {
      Msg.info("m_action_can_add_only_one");
      return;
    }
    actions.add(new Type(null, { parent: sieve }));
  }
  function migrateChanges() {
    const allModels = [...actions.models, ...dels];
    allModels.forEach((action) => {
      const model = action.get("form-model");
      action.unset("form-model");
      delete action.changed;
      if (model && get_store_value(model.dirty)) {
        action.set("config", model.toJSON());
      }
    });
  }
  function getChanges() {
    migrateChanges();
    return { dels, posts: getPosts(), puts: getPuts() };
  }
  function getPosts() {
    return actions.models.filter(function(action) {
      return action.isNew();
    });
  }
  function getPuts() {
    return actions.models.filter(function(action) {
      return !action.isNew() && action.hasChanged();
    });
  }
  function onActionRemove(e) {
    const cid = e.detail;
    const action = actions.find((action2) => action2.cid == cid);
    if (action) {
      if (!action.isNew()) {
        dels.push(action);
      }
      actions.remove(action);
    }
  }
  const click_handler = (desc) => addAction(desc.type);
  const click_handler_1 = () => {
    dispatch("globalaction");
  };
  function manage_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("actions" in $$new_props)
      $$subscribe_actions($$invalidate(0, actions = $$new_props.actions));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16384) {
      {
        if (user.isLoggedIn() && !global && $user) {
          setGlobalActionCount();
        }
      }
    }
    if ($$self.$$.dirty & 2) {
      {
        const currentGroups = new Set($actions.models.map((a) => a.get("type")));
        currentGroups.forEach((group) => groupsSet.add(group));
        groupsSet.forEach((group) => {
          if (!currentGroups.has(group)) {
            groupsSet.delete(group);
          }
        });
        $$invalidate(2, groups = [...groupsSet]);
      }
    }
  };
  return [
    actions,
    $actions,
    groups,
    globalActionsCount,
    sieve,
    global,
    user,
    dispatch,
    addAction,
    onActionRemove,
    migrateChanges,
    getChanges,
    getPosts,
    getPuts,
    $user,
    click_handler,
    click_handler_1,
    manage_handler
  ];
}
class ActionsEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2k, create_fragment$2n, safe_not_equal, {
      actions: 0,
      migrateChanges: 10,
      getChanges: 11,
      getPosts: 12,
      getPuts: 13
    });
  }
  get migrateChanges() {
    return this.$$.ctx[10];
  }
  get getChanges() {
    return this.$$.ctx[11];
  }
  get getPosts() {
    return this.$$.ctx[12];
  }
  get getPuts() {
    return this.$$.ctx[13];
  }
}
function create_default_slot$14(ctx) {
  let div;
  let ruleeditor;
  let updating_rule;
  let current;
  function ruleeditor_rule_binding(value) {
    ctx[4](value);
  }
  let ruleeditor_props = { global: true };
  if (ctx[1] !== void 0) {
    ruleeditor_props.rule = ctx[1];
  }
  ruleeditor = new RuleEditor({ props: ruleeditor_props });
  binding_callbacks.push(() => bind$2(ruleeditor, "rule", ruleeditor_rule_binding));
  ruleeditor.$on("close", ctx[5]);
  return {
    c() {
      div = element("div");
      create_component(ruleeditor.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(ruleeditor, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleeditor_changes = {};
      if (!updating_rule && dirty & 2) {
        updating_rule = true;
        ruleeditor_changes.rule = ctx2[1];
        add_flush_callback(() => updating_rule = false);
      }
      ruleeditor.$set(ruleeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(ruleeditor);
    }
  };
}
function create_header_slot$h(ctx) {
  let t;
  return {
    c() {
      t = text("Global Conditions");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_sub_header_slot$2(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "used for all monitors and combined with each monitor's conditions";
      attr(small, "class", "text-body-secondary");
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment$2m(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: false,
      onSave: ctx[3],
      $$slots: {
        "sub-header": [create_sub_header_slot$2],
        header: [create_header_slot$h],
        default: [create_default_slot$14]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[2]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 514) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$2j($$self, $$props, $$invalidate) {
  let $rule, $$unsubscribe_rule = noop, $$subscribe_rule = () => ($$unsubscribe_rule(), $$unsubscribe_rule = subscribe(rule, ($$value) => $$invalidate(6, $rule = $$value)), rule);
  let $user;
  $$self.$$.on_destroy.push(() => $$unsubscribe_rule());
  const dispatch = createEventDispatcher();
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(7, $user = value));
  let rule;
  onMount(() => {
    if (!$user.id) {
      close();
      alert("Please sign in to save global conditions");
    }
  });
  function close() {
    dispatch("close");
  }
  async function save() {
    let version = $rule.version;
    let config = $rule.config.toJSON();
    try {
      await Api.api("/prefs/rule", "PUT", { ...config, version });
      $$invalidate(0, user.attributes.prefs.rule = { ...config, version }, user);
      close();
    } catch (e) {
      console.error(e);
      Msg.error("Failed to save data, please try again later");
    }
  }
  function ruleeditor_rule_binding(value) {
    rule = value;
    $$subscribe_rule($$invalidate(1, rule));
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [user, rule, close, save, ruleeditor_rule_binding, close_handler];
}
class GlobalRuleEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2j, create_fragment$2m, safe_not_equal, {});
  }
}
function create_catch_block$h(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$h(ctx) {
  let div2;
  let t0;
  let div0;
  let t1;
  let div1;
  let select;
  let option0;
  let t2;
  let option1;
  let t3;
  let select_value_value;
  let t4;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[2] && create_if_block_3$s(ctx);
  const if_block_creators = [create_if_block_1$O, create_if_block_2$A];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5].version === ctx2[6])
      return 0;
    if (ctx2[5].version === ctx2[7])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = text("\n    Version\n    ");
      div1 = element("div");
      select = element("select");
      option0 = element("option");
      t2 = text("V1 (classic)");
      option1 = element("option");
      t3 = text("V2 (modern)");
      t4 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(div0, "class", "flex-grow-1");
      option0.__value = ctx[6];
      option0.value = option0.__value;
      option1.__value = ctx[7];
      option1.value = option1.__value;
      attr(select, "class", "form-select form-select-sm");
      attr(div2, "class", "d-flex align-items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, select);
      append(select, option0);
      append(option0, t2);
      append(select, option1);
      append(option1, t3);
      select_option(select, ctx[5].version);
      insert(target, t4, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$s(ctx2);
          if_block0.c();
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & 224 && select_value_value !== (select_value_value = ctx2[5].version)) {
        select_option(select, ctx2[5].version);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        } else {
          if_block1 = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach(t4);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$s(ctx) {
  let div;
  let a;
  let t0;
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      a = element("a");
      t0 = text("Global Conditions: ");
      t1 = text(ctx[4]);
      attr(a, "href", "#");
      attr(div, "class", "p-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[10]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t1, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$A(ctx) {
  let sieveruleseditorv2;
  let current;
  sieveruleseditorv2 = new SieveRulesEditorV2$1({
    props: { config: ctx[5].config }
  });
  return {
    c() {
      create_component(sieveruleseditorv2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv2_changes = {};
      if (dirty & 32)
        sieveruleseditorv2_changes.config = ctx2[5].config;
      sieveruleseditorv2.$set(sieveruleseditorv2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv2, detaching);
    }
  };
}
function create_if_block_1$O(ctx) {
  let sieveruleseditorv1;
  let current;
  sieveruleseditorv1 = new SieveRulesEditorV1({
    props: { config: ctx[5].config }
  });
  return {
    c() {
      create_component(sieveruleseditorv1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv1_changes = {};
      if (dirty & 32)
        sieveruleseditorv1_changes.config = ctx2[5].config;
      sieveruleseditorv1.$set(sieveruleseditorv1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv1, detaching);
    }
  };
}
function create_pending_block$h(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block$1a(ctx) {
  let globalruleeditormodal;
  let current;
  globalruleeditormodal = new GlobalRuleEditorModal({});
  globalruleeditormodal.$on("close", ctx[11]);
  return {
    c() {
      create_component(globalruleeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalruleeditormodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(globalruleeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalruleeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalruleeditormodal, detaching);
    }
  };
}
function create_fragment$2l(ctx) {
  let t;
  let if_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$h,
    then: create_then_block$h,
    catch: create_catch_block$h,
    value: 17,
    blocks: [, , ,]
  };
  handle_promise(ctx[8], info);
  let if_block = ctx[3] && create_if_block$1a(ctx);
  return {
    c() {
      info.block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      info.block.m(target, info.anchor = anchor);
      info.mount = () => t.parentNode;
      info.anchor = t;
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (ctx[3]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1a(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      info.block.d(detaching);
      info.token = null;
      info = null;
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2i($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(13, $sieve = $$value)), sieve);
  let $rule, $$unsubscribe_rule = noop, $$subscribe_rule = () => ($$unsubscribe_rule(), $$unsubscribe_rule = subscribe(rule, ($$value) => $$invalidate(5, $rule = $$value)), rule);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  $$self.$$.on_destroy.push(() => $$unsubscribe_rule());
  let { sieve = null } = $$props;
  $$subscribe_sieve();
  let { global = false } = $$props;
  let { rule } = $$props;
  $$subscribe_rule();
  const { V1: V12, V2: V22 } = Model$2.SieveRule;
  const dispatch = createEventDispatcher();
  let showGlobalEditorModal = false;
  let fetchComplete;
  let pagePromise = new Promise((resolve, reject) => {
    fetchComplete = resolve;
  });
  let globalCount = 0;
  function updateVersion(e) {
    rule.setVersion(e.target.value);
  }
  async function getGlobalRuleModel() {
    try {
      let config = await Api.api("/prefs/rule") || void 0;
      Msg.reset();
      let version = (config == null ? void 0 : config.version) || V12;
      return new Model$2.SieveRule({ config, version }, { parse: true });
    } catch (e) {
      console.error(e);
      Msg.error("Please try again later. Failed to fetch global conditions.");
      if (global) {
        dispatch("close");
      }
    }
  }
  async function setGlobalCount() {
    let globalRule = await getGlobalRuleModel();
    if (globalRule) {
      $$invalidate(4, globalCount = globalRule.getCount());
    }
  }
  onMount(async () => {
    if (!rule) {
      if (global) {
        $$subscribe_rule($$invalidate(0, rule = await getGlobalRuleModel()));
      } else {
        $$subscribe_rule($$invalidate(0, rule = new Model$2.SieveRule({ id: $sieve.rule_id || void 0 }, { parse: true })));
        await rule.fetch();
      }
    }
    fetchComplete(true);
  });
  const click_handler = () => {
    $$invalidate(3, showGlobalEditorModal = true);
  };
  const close_handler = () => {
    $$invalidate(3, showGlobalEditorModal = false);
  };
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(1, sieve = $$props2.sieve));
    if ("global" in $$props2)
      $$invalidate(2, global = $$props2.global);
    if ("rule" in $$props2)
      $$subscribe_rule($$invalidate(0, rule = $$props2.rule));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      {
        if (App.user.isLoggedIn() && !global && !showGlobalEditorModal) {
          setGlobalCount();
        }
      }
    }
  };
  return [
    rule,
    sieve,
    global,
    showGlobalEditorModal,
    globalCount,
    $rule,
    V12,
    V22,
    pagePromise,
    updateVersion,
    click_handler,
    close_handler
  ];
}
class RuleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2i, create_fragment$2l, safe_not_equal, { sieve: 1, global: 2, rule: 0 });
  }
}
function create_default_slot$13(ctx) {
  let textarea;
  let textarea_class_value;
  let mounted;
  let dispose;
  let textarea_levels = [
    {
      class: textarea_class_value = ctx[2] + " h-[400px]"
    },
    { placeholder: "Selection Config" },
    ctx[1]
  ];
  let textarea_data = {};
  for (let i2 = 0; i2 < textarea_levels.length; i2 += 1) {
    textarea_data = assign$1(textarea_data, textarea_levels[i2]);
  }
  return {
    c() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
      toggle_class(textarea, "is-invalid", ctx[4]);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      if (!mounted) {
        dispose = action_destroyer(ctx[3].call(null, textarea));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty & 4 && textarea_class_value !== (textarea_class_value = ctx2[2] + " h-[400px]") && { class: textarea_class_value },
        { placeholder: "Selection Config" },
        dirty & 2 && ctx2[1]
      ]));
      toggle_class(textarea, "is-invalid", ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2k(ctx) {
  let fieldwrapper;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[0],
      $$slots: {
        default: [
          create_default_slot$13,
          ({ inputClasses, action, showError }) => ({ 2: inputClasses, 3: action, 4: showError }),
          ({ inputClasses, action, showError }) => (inputClasses ? 4 : 0) | (action ? 8 : 0) | (showError ? 16 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 1)
        fieldwrapper_changes.field = ctx2[0];
      if (dirty & 54) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
    }
  };
}
function instance$2h($$self, $$props, $$invalidate) {
  const omit_props_names = ["field"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { field } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(0, field = $$new_props.field);
  };
  return [field, $$restProps];
}
class ConfigEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2h, create_fragment$2k, safe_not_equal, { field: 0 });
  }
}
function create_default_slot$12(ctx) {
  let configedit;
  let current;
  configedit = new ConfigEdit({
    props: {
      field: ctx[1],
      style: "height: 400px;"
    }
  });
  return {
    c() {
      create_component(configedit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(configedit, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(configedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(configedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(configedit, detaching);
    }
  };
}
function create_fragment$2j(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: T("l_selection_config"),
      onSave: ctx[4],
      disableSave: ctx[0],
      $$slots: { default: [create_default_slot$12] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[6]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 1)
        savemodal_changes.disableSave = ctx2[0];
      if (dirty & 2048) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$2g($$self, $$props, $$invalidate) {
  let $clone;
  let $dirty;
  let $showError;
  let { config } = $$props;
  const clone = config.clone();
  component_subscribe($$self, clone, (value) => $$invalidate(7, $clone = value));
  const { showError, dirty } = clone;
  component_subscribe($$self, showError, (value) => $$invalidate(0, $showError = value));
  component_subscribe($$self, dirty, (value) => $$invalidate(8, $dirty = value));
  const dispatch = createEventDispatcher();
  function close() {
    dispatch("close");
  }
  function save() {
    if ($dirty) {
      config.set($clone);
    }
    close();
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(5, config = $$props2.config);
  };
  return [$showError, clone, showError, dirty, save, config, close_handler];
}
class ConfigEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2g, create_fragment$2j, safe_not_equal, { config: 5 });
  }
}
function create_default_slot$11(ctx) {
  let urledit;
  let current;
  urledit = new UrlEdit({
    props: {
      field: ctx[1],
      placeholder: "URL"
    }
  });
  return {
    c() {
      create_component(urledit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urledit, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(urledit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urledit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urledit, detaching);
    }
  };
}
function create_fragment$2i(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: T("l_url"),
      onSave: ctx[4],
      disableSave: ctx[0],
      $$slots: { default: [create_default_slot$11] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[6]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 1)
        savemodal_changes.disableSave = ctx2[0];
      if (dirty & 1024) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$2f($$self, $$props, $$invalidate) {
  let $clone;
  let $dirty;
  let $showError;
  let { uri } = $$props;
  const clone = uri.clone();
  component_subscribe($$self, clone, (value) => $$invalidate(7, $clone = value));
  const { showError, dirty } = clone;
  component_subscribe($$self, showError, (value) => $$invalidate(0, $showError = value));
  component_subscribe($$self, dirty, (value) => $$invalidate(8, $dirty = value));
  const dispatch = createEventDispatcher();
  async function save() {
    try {
      if ($dirty) {
        uri.set($clone);
      }
      dispatch("close");
    } catch (e) {
      throw new Error("Invalid URL");
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("uri" in $$props2)
      $$invalidate(5, uri = $$props2.uri);
  };
  return [$showError, clone, showError, dirty, save, uri, close_handler];
}
class UrlEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2f, create_fragment$2i, safe_not_equal, { uri: 5 });
  }
}
function create_label_pre_slot(ctx) {
  let t;
  return {
    c() {
      t = text("Macro -");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot$2(ctx) {
  let li0;
  let t0;
  let li1;
  let a0;
  let t1;
  let a0_href_value;
  let t2;
  let li2;
  let a1;
  let t3;
  return {
    c() {
      li0 = element("li");
      t0 = space();
      li1 = element("li");
      a0 = element("a");
      t1 = text("Manage Macros");
      t2 = space();
      li2 = element("li");
      a1 = element("a");
      t3 = text("Learn More");
      attr(li0, "class", "dropdown-divider");
      attr(a0, "class", "dropdown-item");
      attr(a0, "href", a0_href_value = "#/w/" + ctx[3].team + "/macros/");
      attr(a0, "target", "_blank");
      attr(a1, "class", "dropdown-item");
      attr(a1, "href", urlCfg.website + "/docs/web-monitor/macro-to-record-replay-actions/");
      attr(a1, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t0, anchor);
      insert(target, li1, anchor);
      append(li1, a0);
      append(a0, t1);
      insert(target, t2, anchor);
      insert(target, li2, anchor);
      append(li2, a1);
      append(a1, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && a0_href_value !== (a0_href_value = "#/w/" + ctx2[3].team + "/macros/")) {
        attr(a0, "href", a0_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(li1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(li2);
    }
  };
}
function create_fragment$2h(ctx) {
  let searchablemenu;
  let updating_id;
  let current;
  const searchablemenu_spread_levels = [{ items: ctx[2] }, { title: "Select Macro" }, ctx[7]];
  function searchablemenu_id_binding(value) {
    ctx[10](value);
  }
  let searchablemenu_props = {
    $$slots: {
      bottom: [create_bottom_slot$2],
      "label-pre": [create_label_pre_slot]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < searchablemenu_spread_levels.length; i2 += 1) {
    searchablemenu_props = assign$1(searchablemenu_props, searchablemenu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    searchablemenu_props.id = ctx[0];
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  binding_callbacks.push(() => bind$2(searchablemenu, "id", searchablemenu_id_binding));
  searchablemenu.$on("close", ctx[6]);
  searchablemenu.$on("search", ctx[4]);
  searchablemenu.$on("select", ctx[5]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemenu_changes = dirty & 132 ? get_spread_update(searchablemenu_spread_levels, [
        dirty & 4 && { items: ctx2[2] },
        searchablemenu_spread_levels[1],
        dirty & 128 && get_spread_object(ctx2[7])
      ]) : {};
      if (dirty & 16392) {
        searchablemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function instance$2e($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "macro", "uri"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $uri, $$unsubscribe_uri = noop, $$subscribe_uri = () => ($$unsubscribe_uri(), $$unsubscribe_uri = subscribe(uri, ($$value) => $$invalidate(9, $uri = $$value)), uri);
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(3, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_uri());
  let { id: id2 } = $$props;
  let { macro } = $$props;
  let { uri } = $$props;
  $$subscribe_uri();
  let initMacros = [];
  let items = [];
  async function init2() {
    initMacros = $$invalidate(2, items = await getMacros());
    await addSelected();
  }
  async function getMacros(phrase = "") {
    var _a;
    const query = {
      _opt: { only: ["id", "name"] },
      "meta:->>'url'.like": `%${(_a = $uri.host) != null ? _a : ""}%`
    };
    if (phrase) {
      query["name.ilike"] = `%${phrase}%`;
    }
    const res = await Api.api("/macros", query);
    return res.data;
  }
  async function onSearch2(e) {
    $$invalidate(2, items = await getMacros(e.detail));
  }
  async function addSelected() {
    if (!id2 || initMacros.find((m) => m.id === id2)) {
      return;
    }
    const item = await Api.api(`/macros/${id2}`);
    $$invalidate(2, items = [item, ...initMacros]);
  }
  async function resetMacros() {
    if (!id2 || initMacros.find((m) => m.id === id2)) {
      $$invalidate(2, items = initMacros);
    } else if (id2) {
      const m = items.find((m2) => m2.id === id2);
      $$invalidate(2, items = [m, ...initMacros]);
    }
  }
  function searchablemenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("macro" in $$new_props)
      $$invalidate(8, macro = $$new_props.macro);
    if ("uri" in $$new_props)
      $$subscribe_uri($$invalidate(1, uri = $$new_props.uri));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $uri && init2();
    }
    if ($$self.$$.dirty & 5) {
      $$invalidate(8, macro = items.find((item) => item.id === id2));
    }
  };
  return [
    id2,
    uri,
    items,
    $route,
    onSearch2,
    addSelected,
    resetMacros,
    $$restProps,
    macro,
    $uri,
    searchablemenu_id_binding
  ];
}
class SelectMacro extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2e, create_fragment$2h, safe_not_equal, { id: 0, macro: 8, uri: 1 });
  }
}
function create_action_slot$e(ctx) {
  let div;
  let button0;
  let t0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(ctx[6]);
      t1 = space();
      button1 = element("button");
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-default");
      attr(button0, "title", "Select content from a webpage.");
      attr(button1, "class", "btn btn-default dropdown-toggle");
      attr(div, "class", "btn-group flex");
      attr(div, "role", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[11]),
          listen(button1, "click", function() {
            if (is_function(ctx[25]))
              ctx[25].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 64)
        set_data(t0, ctx[6]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$10(ctx) {
  let li;
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      a = element("a");
      a.textContent = `${T("h_config_show")}`;
      attr(li, "class", "dropdown-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      if (!mounted) {
        dispose = listen(li, "click", ctx[16]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$c(ctx) {
  let selectmacro;
  let updating_id;
  let current;
  function selectmacro_id_binding(value) {
    ctx[17](value);
  }
  let selectmacro_props = {
    uri: ctx[9],
    actionClass: "btn btn-default"
  };
  if (ctx[1].macro_id !== void 0) {
    selectmacro_props.id = ctx[1].macro_id;
  }
  selectmacro = new SelectMacro({ props: selectmacro_props });
  binding_callbacks.push(() => bind$2(selectmacro, "id", selectmacro_id_binding));
  return {
    c() {
      create_component(selectmacro.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectmacro, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectmacro_changes = {};
      if (!updating_id && dirty & 2) {
        updating_id = true;
        selectmacro_changes.id = ctx2[1].macro_id;
        add_flush_callback(() => updating_id = false);
      }
      selectmacro.$set(selectmacro_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectmacro.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectmacro.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectmacro, detaching);
    }
  };
}
function create_if_block_4$i(ctx) {
  let button;
  let t0;
  let t1_value = ctx[1].uri + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text("Edit ");
      t1 = text(t1_value);
      attr(button, "class", "btn btn-default truncate mw6");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[18]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[1].uri + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$r(ctx) {
  let div2;
  let div0;
  let t0_value = T("m_xframe_notice1") + "";
  let t0;
  let t1;
  let a0;
  let t2_value = T("Download Desktop App") + "";
  let t2;
  let t3;
  let t4;
  let div1;
  let t5_value = T("m_xframe_notice2") + "";
  let t5;
  let t6;
  let button;
  let t8;
  let a1;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      a0 = element("a");
      t2 = text(t2_value);
      t3 = text(" to run checks in background.");
      t4 = space();
      div1 = element("div");
      t5 = text(t5_value);
      t6 = space();
      button = element("button");
      button.textContent = `${T("a_static_load")}`;
      t8 = space();
      a1 = element("a");
      a1.textContent = `${T("Learn More")}`;
      attr(a0, "class", "btn btn-default btn-sm");
      attr(a0, "href", urlCfg.website + "/apps/web-monitor/#desktop");
      attr(button, "class", "btn btn-default btn-sm");
      attr(a1, "href", "https://distill.io/docs/web-monitor/extensions-open-new-tab-for-checks/");
      attr(div2, "class", "alert alert-info pa2 mt2");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div0, t1);
      append(div0, a0);
      append(a0, t2);
      append(div0, t3);
      append(div2, t4);
      append(div2, div1);
      append(div1, t5);
      append(div1, t6);
      append(div1, button);
      append(div1, t8);
      append(div1, a1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[13]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$z(ctx) {
  let sourceselector;
  let current;
  sourceselector = new SourceSelector({
    props: {
      model: ctx[8],
      formModel: ctx[2],
      hideTitle: true
    }
  });
  sourceselector.$on("save", ctx[12]);
  sourceselector.$on("discard", ctx[19]);
  return {
    c() {
      create_component(sourceselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sourceselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sourceselector_changes = {};
      if (dirty & 4)
        sourceselector_changes.formModel = ctx2[2];
      sourceselector.$set(sourceselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sourceselector, detaching);
    }
  };
}
function create_if_block_1$N(ctx) {
  let configeditormodal;
  let current;
  configeditormodal = new ConfigEditorModal({ props: { config: ctx[10] } });
  configeditormodal.$on("close", ctx[20]);
  return {
    c() {
      create_component(configeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(configeditormodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(configeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(configeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(configeditormodal, detaching);
    }
  };
}
function create_if_block$19(ctx) {
  let urleditormodal;
  let current;
  urleditormodal = new UrlEditorModal({ props: { uri: ctx[9] } });
  urleditormodal.$on("close", ctx[21]);
  return {
    c() {
      create_component(urleditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urleditormodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(urleditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urleditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urleditormodal, detaching);
    }
  };
}
function create_fragment$2g(ctx) {
  let div;
  let menu;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let if_block5_anchor;
  let current;
  menu = new Menu$1({
    props: {
      title: T("h_selector_edit"),
      actionClass: "btn btn-default",
      $$slots: {
        default: [create_default_slot$10],
        action: [
          create_action_slot$e,
          ({ onClick }) => ({ 25: onClick }),
          ({ onClick }) => onClick ? 33554432 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[1].content_type === C$2.TYPE_HTML && create_if_block_5$c(ctx);
  let if_block1 = ctx[1].content_type !== C$2.TYPE_SITEMAP && create_if_block_4$i(ctx);
  let if_block2 = ctx[7] && create_if_block_3$r(ctx);
  let if_block3 = ctx[0] && ctx[5] && create_if_block_2$z(ctx);
  let if_block4 = ctx[3] && create_if_block_1$N(ctx);
  let if_block5 = ctx[4] && create_if_block$19(ctx);
  return {
    c() {
      div = element("div");
      create_component(menu.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
      attr(div, "class", "flex gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(menu, div, null);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert(target, if_block5_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 100663368) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[1].content_type === C$2.TYPE_HTML) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$c(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[1].content_type !== C$2.TYPE_SITEMAP) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4$i(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[7]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_3$r(ctx2);
          if_block2.c();
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[0] && ctx2[5]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 33) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2$z(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t4.parentNode, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1$N(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t5.parentNode, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block$19(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(menu);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(t4);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach(t5);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach(if_block5_anchor);
    }
  };
}
function instance$2d($$self, $$props, $$invalidate) {
  let $config;
  let $model;
  let { formModel } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(1, $model = value));
  const { uri, config } = formModel.fields;
  component_subscribe($$self, config, (value) => $$invalidate(15, $config = value));
  const clients = getContext("clients");
  let formClone;
  let showSelectorPanel = false;
  let showConfigEditor = false;
  let showUriEditor = false;
  let cloned = false;
  let buttonLabel;
  let willOpenTabForChecks = false;
  onDestroy(() => {
    if (formClone) {
      formClone.unsubscribe();
    }
  });
  function getContentTypeDescription() {
    let typeLabel;
    switch ($model.content_type) {
      case C$2.TYPE_HTML:
        typeLabel = "l_webpage";
        break;
      case C$2.TYPE_FEED:
        typeLabel = "l_feed";
        break;
      case C$2.TYPE_XML:
        typeLabel = "l_xml";
        break;
      case C$2.TYPE_PDF_HTML:
        typeLabel = "l_pdf";
        break;
      case C$2.TYPE_DOC:
        typeLabel = "l_doc";
        break;
      case C$2.TYPE_JSON:
        typeLabel = "l_datasource";
        switch ($model.datasource_id) {
          case C$2.DS_ID_UPTIME:
            typeLabel = "l_uptime";
            break;
          case C$2.DS_ID_JSON:
          case null:
            typeLabel = "l_json";
        }
        break;
      case C$2.TYPE_SITEMAP:
        typeLabel = "l_sitemap";
        break;
      default:
        console.warn("getContentTypeDescription", "unknown content type", $model.content_type);
    }
    if (typeLabel) {
      const actionLabel = showSelectorPanel ? "a_close_x_selector" : "a_open_x_selector";
      return SPRINTF(actionLabel, typeLabel);
    } else {
      return T(showSelectorPanel ? "a_close_selector" : "a_open_selector");
    }
  }
  function toggleSelectorPanel() {
    $$invalidate(0, showSelectorPanel = !showSelectorPanel);
  }
  function createClone() {
    $$invalidate(2, formClone = formModel.clone());
    if ($model.content_type === C$2.TYPE_FEED) {
      const { uri: uriClone } = formClone.fields;
      uriClone.set($config.uri, { parse: true });
    }
  }
  function onSave() {
    model.parseAndSet(_.omit(formClone.model.toJSON(), "name"));
    formModel.copyForm(formClone);
    $$invalidate(0, showSelectorPanel = false);
  }
  function disableJS() {
    set_store_value(config, $config.selections[0].dynamic = false, $config);
  }
  const click_handler = () => $$invalidate(3, showConfigEditor = true);
  function selectmacro_id_binding(value) {
    if ($$self.$$.not_equal($model.macro_id, value)) {
      $model.macro_id = value;
      model.set($model);
    }
  }
  const click_handler_1 = () => $$invalidate(4, showUriEditor = true);
  const discard_handler = () => $$invalidate(0, showSelectorPanel = false);
  const close_handler = () => $$invalidate(3, showConfigEditor = false);
  const close_handler_1 = () => $$invalidate(4, showUriEditor = false);
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(14, formModel = $$props2.formModel);
  };
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & 32770) {
      {
        let client = clients.get($model.client_id);
        $$invalidate(7, willOpenTabForChecks = (client == null ? void 0 : client.isExtension()) && ((_a = $config.selections) == null ? void 0 : _a[0].dynamic));
      }
    }
    if ($$self.$$.dirty & 1) {
      if (showSelectorPanel) {
        $$invalidate(5, cloned = false);
        createClone();
        $$invalidate(5, cloned = true);
      }
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(6, buttonLabel = getContentTypeDescription());
    }
  };
  return [
    showSelectorPanel,
    $model,
    formClone,
    showConfigEditor,
    showUriEditor,
    cloned,
    buttonLabel,
    willOpenTabForChecks,
    model,
    uri,
    config,
    toggleSelectorPanel,
    onSave,
    disableJS,
    formModel,
    $config,
    click_handler,
    selectmacro_id_binding,
    click_handler_1,
    discard_handler,
    close_handler,
    close_handler_1
  ];
}
class SourceEditor$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2d, create_fragment$2g, safe_not_equal, { formModel: 14 });
  }
}
function create_if_block$18(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$M, create_else_block$H];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$H(ctx) {
  let selectsession;
  let updating_id;
  let t;
  let selectproxy;
  let updating_id_1;
  let current;
  function selectsession_id_binding(value) {
    ctx[11](value);
  }
  let selectsession_props = { actionClass: "btn btn-default" };
  if (ctx[5].session_id !== void 0) {
    selectsession_props.id = ctx[5].session_id;
  }
  selectsession = new SelectSession({ props: selectsession_props });
  binding_callbacks.push(() => bind$2(selectsession, "id", selectsession_id_binding));
  function selectproxy_id_binding(value) {
    ctx[12](value);
  }
  let selectproxy_props = { actionClass: "btn btn-default" };
  if (ctx[5].proxy_id !== void 0) {
    selectproxy_props.id = ctx[5].proxy_id;
  }
  selectproxy = new SelectProxy({ props: selectproxy_props });
  binding_callbacks.push(() => bind$2(selectproxy, "id", selectproxy_id_binding));
  return {
    c() {
      create_component(selectsession.$$.fragment);
      t = space();
      create_component(selectproxy.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectsession, target, anchor);
      insert(target, t, anchor);
      mount_component(selectproxy, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectsession_changes = {};
      if (!updating_id && dirty & 32) {
        updating_id = true;
        selectsession_changes.id = ctx2[5].session_id;
        add_flush_callback(() => updating_id = false);
      }
      selectsession.$set(selectsession_changes);
      const selectproxy_changes = {};
      if (!updating_id_1 && dirty & 32) {
        updating_id_1 = true;
        selectproxy_changes.id = ctx2[5].proxy_id;
        add_flush_callback(() => updating_id_1 = false);
      }
      selectproxy.$set(selectproxy_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectsession.$$.fragment, local);
      transition_in(selectproxy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectsession.$$.fragment, local);
      transition_out(selectproxy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectsession, detaching);
      if (detaching)
        detach(t);
      destroy_component(selectproxy, detaching);
    }
  };
}
function create_if_block_1$M(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Options";
      attr(a, "class", "cursor-pointer");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[10]));
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2f(ctx) {
  let div;
  let menu;
  let updating_id;
  let t;
  let show_if = ctx[3] && ctx[3].isWeb() && ctx[5].content_type !== C$2.TYPE_SITEMAP;
  let current;
  const menu_spread_levels = [
    { items: ctx[2] },
    { title: "Select Client" },
    { actionClass: "btn btn-default" },
    { allowNull: false },
    ctx[7]
  ];
  function menu_id_binding(value) {
    ctx[9](value);
  }
  let menu_props = {};
  for (let i2 = 0; i2 < menu_spread_levels.length; i2 += 1) {
    menu_props = assign$1(menu_props, menu_spread_levels[i2]);
  }
  if (ctx[1] !== void 0) {
    menu_props.id = ctx[1];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "id", menu_id_binding));
  let if_block = show_if && create_if_block$18(ctx);
  return {
    c() {
      div = element("div");
      create_component(menu.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "flex items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(menu, div, null);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 132 ? get_spread_update(menu_spread_levels, [
        dirty & 4 && { items: ctx2[2] },
        menu_spread_levels[1],
        menu_spread_levels[2],
        menu_spread_levels[3],
        dirty & 128 && get_spread_object(ctx2[7])
      ]) : {};
      if (!updating_id && dirty & 2) {
        updating_id = true;
        menu_changes.id = ctx2[1];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
      if (dirty & 40)
        show_if = ctx2[3] && ctx2[3].isWeb() && ctx2[5].content_type !== C$2.TYPE_SITEMAP;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 40) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$18(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(menu);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$2c($$self, $$props, $$invalidate) {
  const omit_props_names = ["model", "showAllClients"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $model, $$unsubscribe_model = noop, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(5, $model = $$value)), model);
  let $clients;
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let { model } = $$props;
  $$subscribe_model();
  let { showAllClients } = $$props;
  const clients = getContext("clients");
  component_subscribe($$self, clients, (value) => $$invalidate(13, $clients = value));
  let items;
  let client_id;
  let client;
  let showOptions = false;
  if (showAllClients) {
    items = $clients.map((client2) => ({ id: client2.id, name: client2.getInfo() }));
    client_id = getDefaultClientId($clients);
  } else {
    const availableClients = model.getAccessibleClients(clients);
    items = availableClients.map((client2) => ({ id: client2.id, name: client2.getInfo() }));
    client_id = getDefaultClientId(availableClients);
  }
  function getDefaultClientId(clientList) {
    var _a;
    const id2 = $model.client_id || clients.defaultId;
    return clientList.find((client2) => id2 === client2.id) ? id2 : (_a = clientList[0]) == null ? void 0 : _a.id;
  }
  function menu_id_binding(value) {
    client_id = value;
    $$invalidate(1, client_id);
  }
  const click_handler = () => $$invalidate(4, showOptions = true);
  function selectsession_id_binding(value) {
    if ($$self.$$.not_equal($model.session_id, value)) {
      $model.session_id = value;
      model.set($model);
    }
  }
  function selectproxy_id_binding(value) {
    if ($$self.$$.not_equal($model.proxy_id, value)) {
      $model.proxy_id = value;
      model.set($model);
    }
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("model" in $$new_props)
      $$subscribe_model($$invalidate(0, model = $$new_props.model));
    if ("showAllClients" in $$new_props)
      $$invalidate(8, showAllClients = $$new_props.showAllClients);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      if (client_id) {
        set_store_value(model, $model.client_id = client_id, $model);
        $$invalidate(3, client = clients.get(client_id));
      }
    }
  };
  return [
    model,
    client_id,
    items,
    client,
    showOptions,
    $model,
    clients,
    $$restProps,
    showAllClients,
    menu_id_binding,
    click_handler,
    selectsession_id_binding,
    selectproxy_id_binding
  ];
}
class ClientSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2c, create_fragment$2f, safe_not_equal, { model: 0, showAllClients: 8 });
  }
}
function get_each_context$y(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_else_block$G(ctx) {
  let t;
  return {
    c() {
      t = text("No label found.");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$17(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ctx[1].models;
  const get_key = (ctx2) => ctx2[6].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$y(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$y(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "flex flex-wrap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 11) {
        each_value = ctx2[1].models;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block$y, null, get_each_context$y);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_each_block$y(key_1, ctx) {
  let label;
  let input;
  let input_checked_value;
  let t0;
  let t1_value = ctx[6].get("name") + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function change_handler(...args) {
    return ctx[5](ctx[6], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      set_style(input, "vertical-align", "top");
      set_style(input, "margin", "0 4px");
      input.checked = input_checked_value = ctx[0].includes(ctx[6]);
      attr(label, "class", "flex font-normal mr-2");
      this.first = label;
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input);
      append(label, t0);
      append(label, t1);
      append(label, t2);
      if (!mounted) {
        dispose = listen(input, "change", change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 3 && input_checked_value !== (input_checked_value = ctx[0].includes(ctx[6]))) {
        input.checked = input_checked_value;
      }
      if (dirty & 2 && t1_value !== (t1_value = ctx[6].get("name") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(label);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2e(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].length > 0)
      return create_if_block$17;
    return create_else_block$G;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2b($$self, $$props, $$invalidate) {
  let $tags;
  let { model } = $$props;
  const tags = getContext("labels");
  component_subscribe($$self, tags, (value) => $$invalidate(1, $tags = value));
  let currTags = model.getTags(tags);
  function onChecked(tag, checked) {
    if (checked) {
      currTags.push(tag);
    } else {
      $$invalidate(0, currTags = _.without(currTags, tag));
    }
    model.set("tags", _.pluck(currTags, "id").join(","));
  }
  const change_handler = (tag, e) => onChecked(tag, e.target.checked);
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(4, model = $$props2.model);
  };
  return [currTags, $tags, tags, onChecked, model, change_handler];
}
class TagsEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2b, create_fragment$2e, safe_not_equal, { model: 4 });
  }
}
function create_fragment$2d(ctx) {
  let div;
  let a;
  let t;
  let a_href_value;
  return {
    c() {
      div = element("div");
      a = element("a");
      t = text("Configure in crawler");
      attr(a, "href", a_href_value = urlCfg.crawlerDetail(ctx[1].team || 0, ctx[0]));
      attr(div, "class", "flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & 3 && a_href_value !== (a_href_value = urlCfg.crawlerDetail(ctx2[1].team || 0, ctx2[0]))) {
        attr(a, "href", a_href_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$2a($$self, $$props, $$invalidate) {
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(1, $params = $$value));
  let { id: id2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
  };
  return [id2, $params];
}
class AutoScheduleMessage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2a, create_fragment$2d, safe_not_equal, { id: 0 });
  }
}
function verifyPhoneWithCountryCode(value, def) {
  if (!/^\+\d{1,4}\d{6,15}$/.test(value)) {
    return "Invalid phone number";
  }
}
class Phone extends TYPES.base {
}
__publicField(Phone, "default", "");
__publicField(Phone, "validators", [verifyPhoneWithCountryCode]);
register("phone", Phone);
const get_header_slot_changes$3 = (dirty) => ({});
const get_header_slot_context$3 = (ctx) => ({ slot: "header" });
const get_buttons_slot_changes = (dirty) => ({});
const get_buttons_slot_context = (ctx) => ({ slot: "buttons" });
const get_links_slot_changes = (dirty) => ({});
const get_links_slot_context = (ctx) => ({ slot: "links" });
function create_default_slot$$(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function fallback_block_1(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot$g(ctx) {
  let current;
  const header_slot_template = ctx[1].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[4], get_header_slot_context$3);
  const header_slot_or_fallback = header_slot || fallback_block_1(ctx);
  return {
    c() {
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(header_slot_template, ctx2[4], dirty, get_header_slot_changes$3),
            get_header_slot_context$3
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & 1)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block$2(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${T("a_confirm")}`;
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_buttons_slot$4(ctx) {
  let current;
  const buttons_slot_template = ctx[1].buttons;
  const buttons_slot = create_slot(buttons_slot_template, ctx, ctx[4], get_buttons_slot_context);
  const buttons_slot_or_fallback = buttons_slot || fallback_block$2(ctx);
  return {
    c() {
      if (buttons_slot_or_fallback)
        buttons_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (buttons_slot_or_fallback) {
        buttons_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(buttons_slot_template, ctx2[4], dirty, get_buttons_slot_changes),
            get_buttons_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(buttons_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(buttons_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (buttons_slot_or_fallback)
        buttons_slot_or_fallback.d(detaching);
    }
  };
}
function create_links_slot(ctx) {
  let current;
  const links_slot_template = ctx[1].links;
  const links_slot = create_slot(links_slot_template, ctx, ctx[4], get_links_slot_context);
  return {
    c() {
      if (links_slot)
        links_slot.c();
    },
    m(target, anchor) {
      if (links_slot) {
        links_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (links_slot) {
        if (links_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            links_slot,
            links_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(links_slot_template, ctx2[4], dirty, get_links_slot_changes),
            get_links_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(links_slot, local);
      current = true;
    },
    o(local) {
      transition_out(links_slot, local);
      current = false;
    },
    d(detaching) {
      if (links_slot)
        links_slot.d(detaching);
    }
  };
}
function create_fragment$2c(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      $$slots: {
        links: [create_links_slot],
        buttons: [create_buttons_slot$4],
        header: [create_header_slot$g],
        default: [create_default_slot$$]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[3]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 17) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title = "Confirm" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [title, slots, click_handler, close_handler, $$scope];
}
class ConfirmModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$29, create_fragment$2c, safe_not_equal, { title: 0 });
  }
}
const get_msg_slot_changes = (dirty) => ({});
const get_msg_slot_context = (ctx) => ({});
function create_default_slot$_(ctx) {
  let div;
  let t;
  let inputedit;
  let current;
  const msg_slot_template = ctx[8].msg;
  const msg_slot = create_slot(msg_slot_template, ctx, ctx[10], get_msg_slot_context);
  inputedit = new InputEdit({ props: { field: ctx[1] } });
  return {
    c() {
      div = element("div");
      if (msg_slot)
        msg_slot.c();
      t = space();
      create_component(inputedit.$$.fragment);
      attr(div, "class", "d-flex flex-column");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (msg_slot) {
        msg_slot.m(div, null);
      }
      append(div, t);
      mount_component(inputedit, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (msg_slot) {
        if (msg_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            msg_slot,
            msg_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(msg_slot_template, ctx2[10], dirty, get_msg_slot_changes),
            get_msg_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(msg_slot, local);
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(msg_slot, local);
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (msg_slot)
        msg_slot.d(detaching);
      destroy_component(inputedit);
    }
  };
}
function create_header_slot$f(ctx) {
  let t_value = T("l_verification_req") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_buttons_slot$3(ctx) {
  let button;
  let t_value = T("a_verify") + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", "btn btn-primary");
      button.disabled = ctx[0];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        button.disabled = ctx2[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2b(ctx) {
  let confirmmodal;
  let current;
  confirmmodal = new ConfirmModal({
    props: {
      $$slots: {
        buttons: [create_buttons_slot$3],
        header: [create_header_slot$f],
        default: [create_default_slot$_]
      },
      $$scope: { ctx }
    }
  });
  confirmmodal.$on("close", ctx[9]);
  return {
    c() {
      create_component(confirmmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmmodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const confirmmodal_changes = {};
      if (dirty & 1025) {
        confirmmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmmodal.$set(confirmmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmmodal, detaching);
    }
  };
}
function instance$28($$self, $$props, $$invalidate) {
  let disableVerify;
  let $field;
  let $showError;
  let $dirty;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id: id2 } = $$props;
  const dispatch = createEventDispatcher();
  const field = createFieldStore({ required: false, type: "text" });
  component_subscribe($$self, field, (value) => $$invalidate(11, $field = value));
  const dirty = field.dirty;
  component_subscribe($$self, dirty, (value) => $$invalidate(7, $dirty = value));
  const showError = field.showError;
  component_subscribe($$self, showError, (value) => $$invalidate(6, $showError = value));
  async function verify() {
    try {
      await Api.api(`/users/verify/${id2}/${$field}`, "POST");
      dispatch("verified", id2);
    } catch (err) {
      console.log("error while verifying the otp", err);
      const message = `Verification failed! ${typeof err == "object" ? err.msg : err}`;
      field.error.set({ message });
      Msg.error(message);
      setTimeout(() => Msg.stop(), 2e3);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(5, id2 = $$props2.id);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 192) {
      $$invalidate(0, disableVerify = !$dirty || $dirty && $showError);
    }
  };
  return [
    disableVerify,
    field,
    dirty,
    showError,
    verify,
    id2,
    $showError,
    $dirty,
    slots,
    close_handler,
    $$scope
  ];
}
class OTPModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$28, create_fragment$2b, safe_not_equal, { id: 5 });
  }
}
function create_if_block_5$b(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "Primary";
      attr(small, "class", "badge bg-primary");
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_if_block_4$h(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${T("a_make_primary")}`;
      attr(button, "class", "btn btn-sm btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[13]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$y(ctx) {
  let small;
  let t1;
  let if_block_anchor;
  let if_block = !ctx[2] && create_if_block_3$q(ctx);
  return {
    c() {
      small = element("small");
      small.textContent = `${T("l_unverified")}`;
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(small, "class", "badge bg-light text-dark");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$q(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(small);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$q(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${T("a_resend_verification_msg")}`;
      attr(button, "class", "btn btn-sm btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[12]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$L(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${T("a_del")}`;
      attr(button, "class", "btn btn-sm btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[14]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$16(ctx) {
  let otpmodal;
  let current;
  otpmodal = new OTPModal({
    props: {
      id: ctx[4],
      $$slots: { msg: [create_msg_slot] },
      $$scope: { ctx }
    }
  });
  otpmodal.$on("close", ctx[15]);
  otpmodal.$on("verified", ctx[16]);
  return {
    c() {
      create_component(otpmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(otpmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const otpmodal_changes = {};
      if (dirty & 16)
        otpmodal_changes.id = ctx2[4];
      if (dirty & 262144) {
        otpmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      otpmodal.$set(otpmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(otpmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(otpmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(otpmodal, detaching);
    }
  };
}
function create_msg_slot(ctx) {
  let t_value = i18n.sprintf(T("m_verification_code"), "phone") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$2a(ctx) {
  let li;
  let div0;
  let t0_value = ctx[0].get("value") + "";
  let t0;
  let t1;
  let div1;
  let t2;
  let show_if_3 = ctx[0].get("value") == ctx[5].email;
  let t3;
  let show_if_1;
  let show_if_2;
  let t4;
  let show_if = !ctx[0].isPrimary();
  let t5;
  let if_block3_anchor;
  let current;
  let if_block0 = show_if_3 && create_if_block_5$b();
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if_1 = null;
    if (dirty & 69)
      show_if_2 = null;
    if (show_if_1 == null)
      show_if_1 = !!!ctx2[0].isVerified();
    if (show_if_1)
      return create_if_block_2$y;
    if (show_if_2 == null)
      show_if_2 = !!(!ctx2[2] && ctx2[6].name == "email" && !ctx2[0].isPrimary());
    if (show_if_2)
      return create_if_block_4$h;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type && current_block_type(ctx);
  let if_block2 = show_if && create_if_block_1$L(ctx);
  let if_block3 = ctx[3] && create_if_block$16(ctx);
  return {
    c() {
      li = element("li");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      attr(div0, "class", "code");
      attr(div1, "class", "flex-1");
      attr(li, "class", "list-group-item border-start-0 border-end-0 flex items-center gap-2");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      append(div0, t0);
      append(li, t1);
      append(li, div1);
      append(li, t2);
      if (if_block0)
        if_block0.m(li, null);
      append(li, t3);
      if (if_block1)
        if_block1.m(li, null);
      append(li, t4);
      if (if_block2)
        if_block2.m(li, null);
      insert(target, t5, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].get("value") + ""))
        set_data(t0, t0_value);
      if (dirty & 33)
        show_if_3 = ctx2[0].get("value") == ctx2[5].email;
      if (show_if_3) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_5$b();
          if_block0.c();
          if_block0.m(li, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(li, t4);
        }
      }
      if (dirty & 1)
        show_if = !ctx2[0].isPrimary();
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$L(ctx2);
          if_block2.c();
          if_block2.m(li, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[3]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$16(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach(t5);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
    }
  };
}
function instance$27($$self, $$props, $$invalidate) {
  let $user;
  let $attr, $$unsubscribe_attr = noop, $$subscribe_attr = () => ($$unsubscribe_attr(), $$unsubscribe_attr = subscribe(attr2, ($$value) => $$invalidate(6, $attr = $$value)), attr2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_attr());
  let { type } = $$props;
  let { attr: attr2 } = $$props;
  $$subscribe_attr();
  let { attrs } = $$props;
  let { onSieveOptions } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(5, $user = value));
  const askOTP = type == "phone";
  let showOTPModal = false;
  let idToVerify = null;
  async function setPrimary(id2) {
    Msg.info("l_loading");
    try {
      await Api.api("/users/change-primary/", "PATCH", { id: id2 });
      Msg.info("m_saved");
      await user.fetch();
      await attrs.fetch();
      setTimeout(() => Msg.stop(), 1e3);
    } catch (err) {
      if (err.message === "Password verification expired") {
        window.location.href = `${window.URL_AUTH}/verify-password?redirect=${urlCfg.app}${encodeURIComponent("/#/settings/emails_phones/")}`;
      } else {
        Msg.error(err.message || "An error occurred while updating primary email");
        console.error("An error occurred while updating primary email: ", err);
      }
    }
  }
  function remove(id2) {
    attr2.destroy();
  }
  function verify(id2) {
    Msg.info("l_loading");
    Api.api("/users/attrs/" + id2 + "/send_verification", "POST", function(err, res) {
      if (err) {
        Msg.error(res.msg);
      } else {
        Msg.info("m_sent_verify");
      }
    });
    setTimeout(() => Msg.stop(), 1e3);
    if (askOTP) {
      $$invalidate(4, idToVerify = id2);
      $$invalidate(3, showOTPModal = true);
    }
  }
  const click_handler = () => verify(attr2.id);
  const click_handler_1 = () => setPrimary(attr2.id);
  const click_handler_2 = () => remove(attr2.id);
  const close_handler = () => {
    $$invalidate(3, showOTPModal = false), $$invalidate(4, idToVerify = null);
  };
  const verified_handler = () => {
    attrs.fetch(), $$invalidate(4, idToVerify = null);
  };
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(11, type = $$props2.type);
    if ("attr" in $$props2)
      $$subscribe_attr($$invalidate(0, attr2 = $$props2.attr));
    if ("attrs" in $$props2)
      $$invalidate(1, attrs = $$props2.attrs);
    if ("onSieveOptions" in $$props2)
      $$invalidate(2, onSieveOptions = $$props2.onSieveOptions);
  };
  return [
    attr2,
    attrs,
    onSieveOptions,
    showOTPModal,
    idToVerify,
    $user,
    $attr,
    user,
    setPrimary,
    remove,
    verify,
    type,
    click_handler,
    click_handler_1,
    click_handler_2,
    close_handler,
    verified_handler
  ];
}
class Attr extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$27, create_fragment$2a, safe_not_equal, {
      type: 11,
      attr: 0,
      attrs: 1,
      onSieveOptions: 2
    });
  }
}
const get_input_field_help_slot_changes = (dirty) => ({});
const get_input_field_help_slot_context = (ctx) => ({});
const get_input_field_label_slot_changes = (dirty) => ({});
const get_input_field_label_slot_context = (ctx) => ({});
function get_each_context$x(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  return child_ctx;
}
function create_catch_block$g(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$g(ctx) {
  let ul;
  let t0;
  let li;
  let t1;
  let div2;
  let div0;
  let inputedit;
  let t2;
  let t3;
  let t4;
  let div1;
  let button;
  let t5_value = T("a_add") + "";
  let t5;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[3].models;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$x(get_each_context$x(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const input_field_label_slot_template = ctx[15]["input-field-label"];
  const input_field_label_slot = create_slot(input_field_label_slot_template, ctx, ctx[14], get_input_field_label_slot_context);
  inputedit = new InputEdit({ props: { field: ctx[7] } });
  const input_field_help_slot_template = ctx[15]["input-field-help"];
  const input_field_help_slot = create_slot(input_field_help_slot_template, ctx, ctx[14], get_input_field_help_slot_context);
  let if_block = !ctx[4] && create_if_block$15(ctx);
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      li = element("li");
      if (input_field_label_slot)
        input_field_label_slot.c();
      t1 = space();
      div2 = element("div");
      div0 = element("div");
      create_component(inputedit.$$.fragment);
      t2 = space();
      if (input_field_help_slot)
        input_field_help_slot.c();
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      div1 = element("div");
      button = element("button");
      t5 = text(t5_value);
      attr(div0, "class", "col-md-6");
      set_style(button, "margin-bottom", "10px");
      attr(button, "class", "btn btn-primary right");
      button.disabled = ctx[2];
      attr(div1, "class", "col-md-1");
      attr(div2, "class", "d-flex xadd");
      attr(li, "class", "list-group-item last-row border-0");
      attr(ul, "class", "border-0 list-group");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      append(ul, t0);
      append(ul, li);
      if (input_field_label_slot) {
        input_field_label_slot.m(li, null);
      }
      append(li, t1);
      append(li, div2);
      append(div2, div0);
      mount_component(inputedit, div0, null);
      append(div0, t2);
      if (input_field_help_slot) {
        input_field_help_slot.m(div0, null);
      }
      append(div0, t3);
      if (if_block)
        if_block.m(div0, null);
      append(div2, t4);
      append(div2, div1);
      append(div1, button);
      append(button, t5);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 75) {
        each_value = ctx2[3].models;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$x(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$x(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(ul, t0);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (input_field_label_slot) {
        if (input_field_label_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            input_field_label_slot,
            input_field_label_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(input_field_label_slot_template, ctx2[14], dirty, get_input_field_label_slot_changes),
            get_input_field_label_slot_context
          );
        }
      }
      if (input_field_help_slot) {
        if (input_field_help_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            input_field_help_slot,
            input_field_help_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(input_field_help_slot_template, ctx2[14], dirty, get_input_field_help_slot_changes),
            get_input_field_help_slot_context
          );
        }
      }
      if (!ctx2[4])
        if_block.p(ctx2, dirty);
      if (!current || dirty & 4) {
        button.disabled = ctx2[2];
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(input_field_label_slot, local);
      transition_in(inputedit.$$.fragment, local);
      transition_in(input_field_help_slot, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(input_field_label_slot, local);
      transition_out(inputedit.$$.fragment, local);
      transition_out(input_field_help_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_each(each_blocks, detaching);
      if (input_field_label_slot)
        input_field_label_slot.d(detaching);
      destroy_component(inputedit);
      if (input_field_help_slot)
        input_field_help_slot.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$x(ctx) {
  let attr_1;
  let current;
  attr_1 = new Attr({
    props: {
      type: ctx[0],
      attr: ctx[21],
      attrs: ctx[6],
      onSieveOptions: ctx[1]
    }
  });
  return {
    c() {
      create_component(attr_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(attr_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const attr_1_changes = {};
      if (dirty & 1)
        attr_1_changes.type = ctx2[0];
      if (dirty & 8)
        attr_1_changes.attr = ctx2[21];
      if (dirty & 2)
        attr_1_changes.onSieveOptions = ctx2[1];
      attr_1.$set(attr_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attr_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attr_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(attr_1, detaching);
    }
  };
}
function create_if_block$15(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${ctx[5]}`;
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_pending_block$g(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$29(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$g,
    then: create_then_block$g,
    catch: create_catch_block$g,
    value: 20,
    blocks: [, , ,]
  };
  handle_promise(ctx[10](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$26($$self, $$props, $$invalidate) {
  let disableAdd;
  let $field;
  let $showError;
  let $touched;
  let $attrs;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { type } = $$props;
  let { onSieveOptions = false } = $$props;
  const user = getContext("user");
  const constraint = user.get("constraint");
  const canAddMore = type == "email" && constraint["email"] > 101 || type == "phone" && constraint["sms"] > 0;
  const cantAddErrorMsg = `Premium subscription is required to add additional ${type}.`;
  const attrs = new AttrModel.UserAttrs();
  component_subscribe($$self, attrs, (value) => $$invalidate(3, $attrs = value));
  attrs.setQuery({ "name": type, "state.in": [10, 40] });
  attrs.setOpt({ order: ["ts"] });
  const field = createFieldStore({
    required: false,
    type,
    validators: [
      (value) => {
        if (attrs.find((attr2) => attr2.get("value") == value)) {
          return T("e_value_exists");
        }
      }
    ]
  });
  component_subscribe($$self, field, (value) => $$invalidate(17, $field = value));
  const touched = field.touched;
  component_subscribe($$self, touched, (value) => $$invalidate(13, $touched = value));
  const showError = field.showError;
  component_subscribe($$self, showError, (value) => $$invalidate(12, $showError = value));
  function fetch2() {
    return attrs.fetch();
  }
  function add() {
    if (!canAddMore) {
      field.error.set({ message: cantAddErrorMsg });
      return;
    }
    attrs.create({ name: type, value: $field });
  }
  const click_handler = () => add();
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("onSieveOptions" in $$props2)
      $$invalidate(1, onSieveOptions = $$props2.onSieveOptions);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12288) {
      $$invalidate(2, disableAdd = !$touched || $touched && $showError);
    }
  };
  return [
    type,
    onSieveOptions,
    disableAdd,
    $attrs,
    canAddMore,
    cantAddErrorMsg,
    attrs,
    field,
    touched,
    showError,
    fetch2,
    add,
    $showError,
    $touched,
    $$scope,
    slots,
    click_handler
  ];
}
class AttrList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$26, create_fragment$29, safe_not_equal, { type: 0, onSieveOptions: 1 });
  }
}
function create_input_field_label_slot$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Add email address";
      attr(div, "class", "col-md-4 fw6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$28(ctx) {
  let attrlist;
  let current;
  const attrlist_spread_levels = [{ type: "email" }, ctx[0]];
  let attrlist_props = {
    $$slots: {
      "input-field-label": [create_input_field_label_slot$1]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < attrlist_spread_levels.length; i2 += 1) {
    attrlist_props = assign$1(attrlist_props, attrlist_spread_levels[i2]);
  }
  attrlist = new AttrList({ props: attrlist_props });
  return {
    c() {
      create_component(attrlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(attrlist, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const attrlist_changes = dirty & 1 ? get_spread_update(attrlist_spread_levels, [attrlist_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 2) {
        attrlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      attrlist.$set(attrlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attrlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attrlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(attrlist, detaching);
    }
  };
}
function instance$25($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Emails extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$25, create_fragment$28, safe_not_equal, {});
  }
}
function create_header_slot$e(ctx) {
  let t;
  return {
    c() {
      t = text("Manage Emails");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$Z(ctx) {
  let emails;
  let current;
  emails = new Emails({ props: { onSieveOptions: true } });
  return {
    c() {
      create_component(emails.$$.fragment);
    },
    m(target, anchor) {
      mount_component(emails, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(emails.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(emails.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(emails, detaching);
    }
  };
}
function create_fragment$27(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      isDialog: false,
      bodyStyle: "--bs-modal-padding:0",
      $$slots: {
        default: [create_default_slot$Z],
        header: [create_header_slot$e]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[0]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 2) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$24($$self) {
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [close_handler];
}
class ManageEmailModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$24, create_fragment$27, safe_not_equal, {});
  }
}
function create_input_field_label_slot(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Add phone number";
      attr(div, "class", "col-md-4 fw6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_input_field_help_slot(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "Number including ISD code: +19999999999";
      attr(small, "class", "help-block");
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment$26(ctx) {
  let attrlist;
  let current;
  const attrlist_spread_levels = [{ type: "phone" }, ctx[0]];
  let attrlist_props = {
    $$slots: {
      "input-field-help": [create_input_field_help_slot],
      "input-field-label": [create_input_field_label_slot]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < attrlist_spread_levels.length; i2 += 1) {
    attrlist_props = assign$1(attrlist_props, attrlist_spread_levels[i2]);
  }
  attrlist = new AttrList({ props: attrlist_props });
  return {
    c() {
      create_component(attrlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(attrlist, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const attrlist_changes = dirty & 1 ? get_spread_update(attrlist_spread_levels, [attrlist_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 2) {
        attrlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      attrlist.$set(attrlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attrlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attrlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(attrlist, detaching);
    }
  };
}
function instance$23($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Phones extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$23, create_fragment$26, safe_not_equal, {});
  }
}
function create_header_slot$d(ctx) {
  let t;
  return {
    c() {
      t = text("Manage Phones");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$Y(ctx) {
  let phones;
  let current;
  phones = new Phones({ props: { onSieveOptions: true } });
  return {
    c() {
      create_component(phones.$$.fragment);
    },
    m(target, anchor) {
      mount_component(phones, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(phones.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(phones.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(phones, detaching);
    }
  };
}
function create_fragment$25(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      isDialog: false,
      bodyStyle: "--bs-modal-padding:0",
      $$slots: {
        default: [create_default_slot$Y],
        header: [create_header_slot$d]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[0]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 2) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$22($$self) {
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [close_handler];
}
class ManagePhonesModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$22, create_fragment$25, safe_not_equal, {});
  }
}
function create_header_slot$c(ctx) {
  let t;
  return {
    c() {
      t = text("Global Actions");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_sub_header_slot$1(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "taken on changes for all monitors, merged with monitor's actions";
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_default_slot$X(ctx) {
  let div;
  let actionseditor;
  let updating_actions;
  let current;
  function actionseditor_actions_binding(value) {
    ctx[8](value);
  }
  let actionseditor_props = { sieve: ctx[5], global: true };
  if (ctx[0] !== void 0) {
    actionseditor_props.actions = ctx[0];
  }
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  binding_callbacks.push(() => bind$2(actionseditor, "actions", actionseditor_actions_binding));
  ctx[9](actionseditor);
  actionseditor.$on("close", ctx[10]);
  actionseditor.$on("manage", ctx[6]);
  return {
    c() {
      div = element("div");
      create_component(actionseditor.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(actionseditor, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const actionseditor_changes = {};
      if (!updating_actions && dirty & 1) {
        updating_actions = true;
        actionseditor_changes.actions = ctx2[0];
        add_flush_callback(() => updating_actions = false);
      }
      actionseditor.$set(actionseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[9](null);
      destroy_component(actionseditor);
    }
  };
}
function create_if_block_1$K(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[12]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block$14(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[13]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_fragment$24(ctx) {
  let savemodal;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Global Actions",
      onSave: ctx[7],
      $$slots: {
        default: [create_default_slot$X],
        "sub-header": [create_sub_header_slot$1],
        header: [create_header_slot$c]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[11]);
  let if_block0 = ctx[2] && create_if_block_1$K(ctx);
  let if_block1 = ctx[3] && create_if_block$14(ctx);
  return {
    c() {
      create_component(savemodal.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 262147) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$K(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$14(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$21($$self, $$props, $$invalidate) {
  let $user;
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(15, $route = $$value));
  const dispatch = createEventDispatcher();
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(14, $user = value));
  let actions;
  let sieve = new Model$2.Sieve();
  let actionsEditor;
  let showManageEmailsModal = false;
  let showManagePhonesModal = false;
  onMount(() => {
    if (!$user.id) {
      close();
      alert("Please sign in save global actions");
    }
  });
  function close() {
    dispatch("close");
  }
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(2, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(3, showManagePhonesModal = true);
    }
  }
  async function save() {
    actionsEditor.migrateChanges();
    const data = actions.toJSON();
    try {
      await Api.api("/prefs/actions", "PUT", data);
      if ($route.team === "0") {
        set_store_value(user, $user.prefs = { ...$user.prefs, actions: data }, $user);
      } else {
        const groups = $user.groups;
        const group = groups.find((g) => g.id === $route.team);
        group.prefs = { ...group.prefs, actions: data };
        set_store_value(user, $user.groups = [...groups], $user);
      }
      close();
    } catch (e) {
      console.error(e);
      Msg.error("Failed to save data, please try again later");
    }
  }
  function actionseditor_actions_binding(value) {
    actions = value;
    $$invalidate(0, actions);
  }
  function actionseditor_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionsEditor = $$value;
      $$invalidate(1, actionsEditor);
    });
  }
  function close_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  const close_handler_2 = () => $$invalidate(2, showManageEmailsModal = false);
  const close_handler_3 = () => $$invalidate(3, showManagePhonesModal = false);
  return [
    actions,
    actionsEditor,
    showManageEmailsModal,
    showManagePhonesModal,
    user,
    sieve,
    showModal,
    save,
    actionseditor_actions_binding,
    actionseditor_binding,
    close_handler_1,
    close_handler,
    close_handler_2,
    close_handler_3
  ];
}
class GlobalActionsEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$21, create_fragment$24, safe_not_equal, {});
  }
}
function create_key_block(ctx) {
  let scheduleeditor;
  let current;
  const scheduleeditor_spread_levels = [{ formModel: ctx[1] }, ctx[13]];
  let scheduleeditor_props = {};
  for (let i2 = 0; i2 < scheduleeditor_spread_levels.length; i2 += 1) {
    scheduleeditor_props = assign$1(scheduleeditor_props, scheduleeditor_spread_levels[i2]);
  }
  scheduleeditor = new ScheduleEditor({ props: scheduleeditor_props });
  return {
    c() {
      create_component(scheduleeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scheduleeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const scheduleeditor_changes = dirty[0] & 8194 ? get_spread_update(scheduleeditor_spread_levels, [
        dirty[0] & 2 && { formModel: ctx2[1] },
        dirty[0] & 8192 && get_spread_object(ctx2[13])
      ]) : {};
      scheduleeditor.$set(scheduleeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scheduleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scheduleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scheduleeditor, detaching);
    }
  };
}
function create_if_block_2$x(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[20]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block_1$J(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[21]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block$13(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[22]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_content_slot(ctx) {
  let div17;
  let div1;
  let label0;
  let t1;
  let div0;
  let sourceeditor;
  let t2;
  let p0;
  let t4;
  let div3;
  let label1;
  let t6;
  let div2;
  let clientselector;
  let t7;
  let p1;
  let t9;
  let div5;
  let label2;
  let t11;
  let div4;
  let input;
  let t12;
  let p2;
  let t14;
  let div7;
  let label3;
  let t16;
  let div6;
  let previous_key = ctx[9];
  let t17;
  let div9;
  let label4;
  let t19;
  let div8;
  let actionseditor;
  let t20;
  let p3;
  let t22;
  let t23;
  let t24;
  let t25;
  let div11;
  let label5;
  let t27;
  let div10;
  let ruleeditor;
  let updating_rule;
  let t28;
  let p4;
  let t30;
  let div13;
  let label6;
  let t32;
  let div12;
  let tagseditor;
  let t33;
  let div16;
  let div14;
  let t34;
  let div15;
  let button0;
  let t35_value = (ctx[2] ? T("l_loading") : T("a_save")) + "";
  let t35;
  let button0_disabled_value;
  let t36;
  let button1;
  let current;
  let mounted;
  let dispose;
  sourceeditor = new SourceEditor$1({
    props: {
      model: ctx[0],
      formModel: ctx[1]
    }
  });
  clientselector = new ClientSelector({ props: { model: ctx[0] } });
  let key_block = create_key_block(ctx);
  let actionseditor_props = {
    sieve: ctx[0],
    actions: ctx[4]
  };
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  ctx[18](actionseditor);
  actionseditor.$on("globalaction", ctx[19]);
  actionseditor.$on("manage", ctx[14]);
  let if_block0 = ctx[6] && create_if_block_2$x(ctx);
  let if_block1 = ctx[7] && create_if_block_1$J(ctx);
  let if_block2 = ctx[8] && create_if_block$13(ctx);
  function ruleeditor_rule_binding(value) {
    ctx[23](value);
  }
  let ruleeditor_props = { sieve: ctx[0] };
  if (ctx[3] !== void 0) {
    ruleeditor_props.rule = ctx[3];
  }
  ruleeditor = new RuleEditor({ props: ruleeditor_props });
  binding_callbacks.push(() => bind$2(ruleeditor, "rule", ruleeditor_rule_binding));
  tagseditor = new TagsEditor({ props: { model: ctx[0] } });
  return {
    c() {
      div17 = element("div");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = `${T("l_source")}`;
      t1 = space();
      div0 = element("div");
      create_component(sourceeditor.$$.fragment);
      t2 = space();
      p0 = element("p");
      p0.textContent = `${T("h_sieve_source")}`;
      t4 = space();
      div3 = element("div");
      label1 = element("label");
      label1.textContent = `${T("l_device")}`;
      t6 = space();
      div2 = element("div");
      create_component(clientselector.$$.fragment);
      t7 = space();
      p1 = element("p");
      p1.textContent = `${T("h_sieve_device")}`;
      t9 = space();
      div5 = element("div");
      label2 = element("label");
      label2.textContent = `${T("l_name")}`;
      t11 = space();
      div4 = element("div");
      input = element("input");
      t12 = space();
      p2 = element("p");
      p2.textContent = `${T("h_sieve_name")}`;
      t14 = space();
      div7 = element("div");
      label3 = element("label");
      label3.textContent = `${T("l_schedule")}`;
      t16 = space();
      div6 = element("div");
      key_block.c();
      t17 = space();
      div9 = element("div");
      label4 = element("label");
      label4.textContent = `${T("l_actions")}`;
      t19 = space();
      div8 = element("div");
      create_component(actionseditor.$$.fragment);
      t20 = space();
      p3 = element("p");
      p3.textContent = `${T("h_sieve_actions")}`;
      t22 = space();
      if (if_block0)
        if_block0.c();
      t23 = space();
      if (if_block1)
        if_block1.c();
      t24 = space();
      if (if_block2)
        if_block2.c();
      t25 = space();
      div11 = element("div");
      label5 = element("label");
      label5.textContent = `${T("l_conditions")}`;
      t27 = space();
      div10 = element("div");
      create_component(ruleeditor.$$.fragment);
      t28 = space();
      p4 = element("p");
      p4.textContent = `${T("h_sieve_rules")}`;
      t30 = space();
      div13 = element("div");
      label6 = element("label");
      label6.textContent = `${T("l_label")}`;
      t32 = space();
      div12 = element("div");
      create_component(tagseditor.$$.fragment);
      t33 = space();
      div16 = element("div");
      div14 = element("div");
      t34 = space();
      div15 = element("div");
      button0 = element("button");
      t35 = text(t35_value);
      t36 = space();
      button1 = element("button");
      button1.textContent = `${T("a_discard")}`;
      attr(label0, "class", "xoption-label form-label");
      attr(p0, "class", "help");
      attr(div0, "class", "flex-1");
      attr(div1, "class", "flex gap-x-6");
      attr(label1, "class", "xoption-label form-label");
      attr(p1, "class", "help");
      attr(div2, "class", "flex-1");
      attr(div3, "class", "flex gap-x-6");
      attr(label2, "class", "xoption-label form-label");
      attr(input, "type", "text");
      attr(input, "class", "form-control xform-control-sm inline");
      attr(p2, "class", "help");
      attr(div4, "class", "flex-1");
      attr(div5, "class", "flex gap-x-6");
      attr(label3, "class", "xoption-label form-label");
      attr(div6, "class", "flex-1");
      attr(div7, "class", "flex gap-x-6");
      attr(label4, "class", "xoption-label form-label");
      attr(p3, "class", "help");
      attr(div8, "class", "flex-1");
      set_style(div8, "position", "relative");
      attr(div9, "class", "flex gap-x-6");
      attr(label5, "class", "xoption-label form-label");
      attr(p4, "class", "help");
      attr(div10, "class", "flex-1");
      attr(div11, "class", "flex gap-x-6");
      attr(label6, "class", "xoption-label form-label");
      attr(div12, "class", "flex-1");
      attr(div13, "class", "flex gap-x-6");
      attr(div14, "class", "xoption-label form-label");
      attr(button0, "class", "btn btn-primary xbtn-default");
      button0.disabled = button0_disabled_value = ctx[2] || ctx[11].readOnly;
      attr(button1, "class", "btn btn-default");
      attr(button1, "data-action", "go_back");
      attr(div15, "class", "flex-1 mt-2 pt-2");
      set_style(div15, "border-top", "solid 1px #ddd");
      attr(div16, "class", "flex gap-x-6 mb-[30px]");
      attr(div17, "class", "flex flex-col gap-y-6 p-[10px]");
    },
    m(target, anchor) {
      insert(target, div17, anchor);
      append(div17, div1);
      append(div1, label0);
      append(div1, t1);
      append(div1, div0);
      mount_component(sourceeditor, div0, null);
      append(div0, t2);
      append(div0, p0);
      append(div17, t4);
      append(div17, div3);
      append(div3, label1);
      append(div3, t6);
      append(div3, div2);
      mount_component(clientselector, div2, null);
      append(div2, t7);
      append(div2, p1);
      append(div17, t9);
      append(div17, div5);
      append(div5, label2);
      append(div5, t11);
      append(div5, div4);
      append(div4, input);
      set_input_value(input, ctx[10].name);
      append(div4, t12);
      append(div4, p2);
      append(div17, t14);
      append(div17, div7);
      append(div7, label3);
      append(div7, t16);
      append(div7, div6);
      key_block.m(div6, null);
      append(div17, t17);
      append(div17, div9);
      append(div9, label4);
      append(div9, t19);
      append(div9, div8);
      mount_component(actionseditor, div8, null);
      append(div8, t20);
      append(div8, p3);
      append(div8, t22);
      if (if_block0)
        if_block0.m(div8, null);
      append(div8, t23);
      if (if_block1)
        if_block1.m(div8, null);
      append(div8, t24);
      if (if_block2)
        if_block2.m(div8, null);
      append(div17, t25);
      append(div17, div11);
      append(div11, label5);
      append(div11, t27);
      append(div11, div10);
      mount_component(ruleeditor, div10, null);
      append(div10, t28);
      append(div10, p4);
      append(div17, t30);
      append(div17, div13);
      append(div13, label6);
      append(div13, t32);
      append(div13, div12);
      mount_component(tagseditor, div12, null);
      append(div17, t33);
      append(div17, div16);
      append(div16, div14);
      append(div16, t34);
      append(div16, div15);
      append(div15, button0);
      append(button0, t35);
      append(div15, t36);
      append(div15, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[17]),
          listen(button0, "click", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sourceeditor_changes = {};
      if (dirty[0] & 1)
        sourceeditor_changes.model = ctx2[0];
      if (dirty[0] & 2)
        sourceeditor_changes.formModel = ctx2[1];
      sourceeditor.$set(sourceeditor_changes);
      const clientselector_changes = {};
      if (dirty[0] & 1)
        clientselector_changes.model = ctx2[0];
      clientselector.$set(clientselector_changes);
      if (dirty[0] & 1024 && input.value !== ctx2[10].name) {
        set_input_value(input, ctx2[10].name);
      }
      if (dirty[0] & 512 && safe_not_equal(previous_key, previous_key = ctx2[9])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div6, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      const actionseditor_changes = {};
      if (dirty[0] & 1)
        actionseditor_changes.sieve = ctx2[0];
      if (dirty[0] & 16)
        actionseditor_changes.actions = ctx2[4];
      actionseditor.$set(actionseditor_changes);
      if (ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$x(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div8, t23);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[7]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$J(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div8, t24);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[8]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$13(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div8, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const ruleeditor_changes = {};
      if (dirty[0] & 1)
        ruleeditor_changes.sieve = ctx2[0];
      if (!updating_rule && dirty[0] & 8) {
        updating_rule = true;
        ruleeditor_changes.rule = ctx2[3];
        add_flush_callback(() => updating_rule = false);
      }
      ruleeditor.$set(ruleeditor_changes);
      const tagseditor_changes = {};
      if (dirty[0] & 1)
        tagseditor_changes.model = ctx2[0];
      tagseditor.$set(tagseditor_changes);
      if ((!current || dirty[0] & 4) && t35_value !== (t35_value = (ctx2[2] ? T("l_loading") : T("a_save")) + ""))
        set_data(t35, t35_value);
      if (!current || dirty[0] & 2052 && button0_disabled_value !== (button0_disabled_value = ctx2[2] || ctx2[11].readOnly)) {
        button0.disabled = button0_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceeditor.$$.fragment, local);
      transition_in(clientselector.$$.fragment, local);
      transition_in(key_block);
      transition_in(actionseditor.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(ruleeditor.$$.fragment, local);
      transition_in(tagseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceeditor.$$.fragment, local);
      transition_out(clientselector.$$.fragment, local);
      transition_out(key_block);
      transition_out(actionseditor.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(ruleeditor.$$.fragment, local);
      transition_out(tagseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div17);
      destroy_component(sourceeditor);
      destroy_component(clientselector);
      key_block.d(detaching);
      ctx[18](null);
      destroy_component(actionseditor);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(ruleeditor);
      destroy_component(tagseditor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$23(ctx) {
  let sieveoptionslayout;
  let current;
  sieveoptionslayout = new Layout({
    props: {
      title: T("l_options") + " - " + (ctx[0].isNew() ? T("l_add_monitor") : ctx[0].get("name")),
      $$slots: { content: [create_content_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sieveoptionslayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptionslayout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveoptionslayout_changes = {};
      if (dirty[0] & 1)
        sieveoptionslayout_changes.title = T("l_options") + " - " + (ctx2[0].isNew() ? T("l_add_monitor") : ctx2[0].get("name"));
      if (dirty[0] & 4095 | dirty[1] & 1) {
        sieveoptionslayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sieveoptionslayout.$set(sieveoptionslayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptionslayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptionslayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptionslayout, detaching);
    }
  };
}
function instance$20($$self, $$props, $$invalidate) {
  let $model, $$unsubscribe_model = noop, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(10, $model = $$value)), model);
  let $permissionsModel;
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let { model } = $$props;
  $$subscribe_model();
  let { formModel } = $$props;
  let { defaultModel = null } = $$props;
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(11, $permissionsModel = value));
  let saving = false;
  let rule;
  let actions;
  let actionEditor;
  let sitemapAttributes = $model.content_type === C$2.TYPE_SITEMAP ? {
    editors: {
      AUTO: {
        name: "Auto",
        component: AutoScheduleMessage
      }
    },
    id: $model.crawler_id
  } : {};
  let showGlobalActionEditor2 = false;
  let showManageEmailsModal = false;
  let showManagePhonesModal = false;
  let rerenderSchedule = false;
  if (model.isNew() || $model.state === C$2.STATE_INIT) {
    createDefaults();
  }
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(7, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(8, showManagePhonesModal = true);
    }
  }
  async function createDefaults() {
    $$invalidate(4, actions = new Model$2.SieveActions(null, { parent: model }));
    $$invalidate(3, rule = new Model$2.SieveRule());
    if (defaultModel) {
      return copyRef(defaultModel, true);
    }
    const uri = $model.uri;
    const hostname = uri && new URL(uri).hostname;
    const colln = new Model$2.Sieves();
    if (!$model.name && uri) {
      setDefaultName();
    }
    await colln.fetch({
      data: {
        "uri.like": `%${hostname}%`,
        "state.in": [C$2.STATE_READY, C$2.STATE_PAUSED],
        content_type: $model.content_type,
        _opt: {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    await colln.fetch({
      data: {
        "state.in": [C$2.STATE_READY, C$2.STATE_PAUSED],
        content_type: $model.content_type,
        _opt: {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    Model$2.SieveActionDescList.forEach((desc) => {
      if (desc.addByDefault(Supports)) {
        actions.add(new Model$2.SieveAction[desc.type]());
      }
    });
  }
  async function setDefaultName() {
    set_store_value(model, $model.name = T("l_loading"), $model);
    let title;
    try {
      title = await Api.utils(`/v1/http/get?html_css_filter=title&url=${encodeURIComponent($model.uri)}`);
    } catch (e) {
    }
    set_store_value(model, $model.name = window.$(title).text().trim() || "Untitled", $model);
  }
  async function copyRef(ref, defaultRules) {
    const refActions = new Model$2.SieveActions(null, { parent: ref });
    try {
      await refActions.fetch({ data: { state: 0 } });
      refActions.forEach((action) => {
        const attrs = action.omit("id", "sieve_id", "ts", "ts_mod");
        actions.add(new Model$2.SieveAction[attrs.type](attrs, { parse: true }));
      });
    } catch (e) {
    }
    let refSchedule = ref.get("schedule");
    if (refSchedule.get("type") !== "LIVE") {
      formModel.fields.schedule.set(refSchedule.toJSON());
      $$invalidate(9, rerenderSchedule = true);
    }
    const rule_id = ref.get("rule_id");
    if (defaultRules && rule_id) {
      const refRule = new Model$2.SieveRule({ id: rule_id });
      await refRule.fetch();
      rule.set(refRule.pick("config", "version"));
    }
  }
  async function save() {
    $$invalidate(2, saving = true);
    Msg.start("sieve:save", { info: "saving" });
    try {
      await saveRules();
      let crawler = model.get("crawler");
      if (crawler) {
        if (crawler.isNew()) {
          crawler.set({ name: model.get("name") + " | Crawler" });
        }
        await crawler.save();
        model.set("crawler_id", crawler.id);
      }
      const attrs = _.omit(model.toJSON(), "err", "text", "ts", "ts_data", "ts_mod", "ts_view", "user_id");
      if (attrs.state == C$2.STATE_INIT) {
        attrs.state = C$2.STATE_READY;
      }
      try {
        await model.save(null, {
          data: attrs,
          patch: true,
          silent: true,
          wait: true
        });
        Msg.stop("sieve:save");
      } catch (e) {
        Msg.stop("sieve:save", {
          error: "Failed to save changes to server"
        });
      }
      await saveActions();
      App.navBack();
    } catch (e) {
      Msg.error("Failed to save data. Please check console for more info.");
      console.error(e);
    }
    $$invalidate(2, saving = false);
  }
  async function saveActions() {
    const changes = actionEditor.getChanges();
    await base.syncBatch(changes);
  }
  async function saveRules() {
    if (rule.isNew() && rule.isEmpty()) {
      return;
    }
    Msg.start("sieve:rule:save", { info: "l_loading" });
    try {
      await rule.save();
      if ($model.rule_id != rule.id) {
        model.set({ rule_id: rule.id }, { silent: true });
      }
      Msg.stop("sieve:rule:save");
    } catch (e) {
      Msg.stop("sieve:rule:save", { error: "e_req" });
      Msg.error("Failed to save conditions");
      throw new Error("Failed to save conditions", { cause: e });
    }
  }
  function input_input_handler() {
    $model.name = this.value;
    model.set($model);
  }
  function actionseditor_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionEditor = $$value;
      $$invalidate(5, actionEditor);
    });
  }
  const globalaction_handler = () => {
    $$invalidate(6, showGlobalActionEditor2 = true);
  };
  const close_handler = () => $$invalidate(6, showGlobalActionEditor2 = false);
  const close_handler_1 = () => $$invalidate(7, showManageEmailsModal = false);
  const close_handler_2 = () => $$invalidate(8, showManagePhonesModal = false);
  function ruleeditor_rule_binding(value) {
    rule = value;
    $$invalidate(3, rule);
  }
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$subscribe_model($$invalidate(0, model = $$props2.model));
    if ("formModel" in $$props2)
      $$invalidate(1, formModel = $$props2.formModel);
    if ("defaultModel" in $$props2)
      $$invalidate(16, defaultModel = $$props2.defaultModel);
  };
  return [
    model,
    formModel,
    saving,
    rule,
    actions,
    actionEditor,
    showGlobalActionEditor2,
    showManageEmailsModal,
    showManagePhonesModal,
    rerenderSchedule,
    $model,
    $permissionsModel,
    permissionsModel,
    sitemapAttributes,
    showModal,
    save,
    defaultModel,
    input_input_handler,
    actionseditor_binding,
    globalaction_handler,
    close_handler,
    close_handler_1,
    close_handler_2,
    ruleeditor_rule_binding
  ];
}
class SieveOptions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$20, create_fragment$23, safe_not_equal, { model: 0, formModel: 1, defaultModel: 16 }, null, [-1, -1]);
  }
}
function create_if_block_5$a(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_catch_block$f(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$f(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && create_if_block$12(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$12(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_1$I, create_if_block_2$w, create_if_block_3$p, create_if_block_4$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6] === ctx2[8].UPGRADE_ACCOUNT)
      return 0;
    if (ctx2[6] === ctx2[8].OVERLIMIT)
      return 1;
    if (ctx2[6] === ctx2[8].SOURCE_SELECTOR)
      return 2;
    if (ctx2[6] === ctx2[8].SIEVE_OPTIONS)
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "flex flex-col items-stretch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_4$g(ctx) {
  let sieveoptions;
  let current;
  sieveoptions = new SieveOptions({
    props: {
      model: ctx[0],
      formModel: ctx[1],
      defaultModel: ctx[3]
    }
  });
  return {
    c() {
      create_component(sieveoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveoptions_changes = {};
      if (dirty & 1)
        sieveoptions_changes.model = ctx2[0];
      if (dirty & 2)
        sieveoptions_changes.formModel = ctx2[1];
      if (dirty & 8)
        sieveoptions_changes.defaultModel = ctx2[3];
      sieveoptions.$set(sieveoptions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptions, detaching);
    }
  };
}
function create_if_block_3$p(ctx) {
  let sourceselector;
  let current;
  sourceselector = new SourceSelector({
    props: {
      model: ctx[0],
      formModel: ctx[1]
    }
  });
  sourceselector.$on("save", ctx[12]);
  sourceselector.$on("discard", ctx[10]);
  return {
    c() {
      create_component(sourceselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sourceselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sourceselector_changes = {};
      if (dirty & 1)
        sourceselector_changes.model = ctx2[0];
      if (dirty & 2)
        sourceselector_changes.formModel = ctx2[1];
      sourceselector.$set(sourceselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sourceselector, detaching);
    }
  };
}
function create_if_block_2$w(ctx) {
  let sieveconstraint;
  let current;
  sieveconstraint = new SieveConstraint({
    props: { constraint: ctx[5] }
  });
  return {
    c() {
      create_component(sieveconstraint.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveconstraint, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveconstraint_changes = {};
      if (dirty & 32)
        sieveconstraint_changes.constraint = ctx2[5];
      sieveconstraint.$set(sieveconstraint_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveconstraint.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveconstraint.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveconstraint, detaching);
    }
  };
}
function create_if_block_1$I(ctx) {
  let upgradeaccount;
  let current;
  upgradeaccount = new UpgradeAccount({
    props: {
      type: ctx[0].getTypeName(),
      minPlan: ctx[4].minPlan
    }
  });
  return {
    c() {
      create_component(upgradeaccount.$$.fragment);
    },
    m(target, anchor) {
      mount_component(upgradeaccount, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const upgradeaccount_changes = {};
      if (dirty & 1)
        upgradeaccount_changes.type = ctx2[0].getTypeName();
      if (dirty & 16)
        upgradeaccount_changes.minPlan = ctx2[4].minPlan;
      upgradeaccount.$set(upgradeaccount_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(upgradeaccount.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(upgradeaccount.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(upgradeaccount, detaching);
    }
  };
}
function create_pending_block$f(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$22(ctx) {
  let div;
  let button;
  let i2;
  let t0;
  let t1_value = T("a_discard") + "";
  let t1;
  let t2;
  let t3;
  let await_block_anchor;
  let promise_1;
  let current;
  let if_block = ctx[2] && create_if_block_5$a();
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$f,
    then: create_then_block$f,
    catch: create_catch_block$f,
    value: 21,
    blocks: [, , ,]
  };
  handle_promise(promise_1 = ctx[7], info);
  return {
    c() {
      div = element("div");
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      await_block_anchor = empty();
      info.block.c();
      attr(i2, "class", "fa fa-chevron-left");
      attr(button, "class", "btn btn-default");
      attr(button, "data-action", "go_back");
      attr(div, "class", "xtbar xvbar-margin mb-4 ml-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      insert(target, t3, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[2]) {
        if (if_block) {
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$a();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      info.ctx = ctx;
      if (dirty & 128 && promise_1 !== (promise_1 = ctx[7]) && handle_promise(promise_1, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      for (let i3 = 0; i3 < 3; i3 += 1) {
        const block = info.blocks[i3];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      if (detaching)
        detach(t3);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1$($$self, $$props, $$invalidate) {
  let $model, $$unsubscribe_model = noop, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(17, $model = $$value)), model);
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(11, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  const user = getContext("user");
  const views = {
    UPGRADE_ACCOUNT: "upgrade_account",
    OVERLIMIT: "overlimit",
    SOURCE_SELECTOR: "source_selector",
    SIEVE_OPTIONS: "sieve_options"
  };
  let model;
  let formModel;
  let { id: id2, data: type, query } = $route;
  let loading2 = true;
  let defaultModel;
  let accessInfo;
  let sieveConstraint = {};
  let view;
  let newSieve;
  let promise;
  onDestroy(() => {
    if (formModel) {
      formModel.unsubscribe();
    }
  });
  async function fetch2(id3) {
    let model2 = new Model$2.Sieve({ id: id3 });
    await model2.fetch();
    return model2;
  }
  async function setModel() {
    $$invalidate(2, loading2 = true);
    newSieve = false;
    if (formModel) {
      formModel.unsubscribe();
    }
    if (id2) {
      $$subscribe_model($$invalidate(0, model = await fetch2(id2)));
      if ($route.prefix === "dup") {
        const json = _.pick(model.toJSON(), "name", "uri", "config", "client_id", "content_type", "schedule", "tags", "datasource_id", "macro_id", "proxy_id", "session_id");
        json.name = "Copy of " + json.name;
        $$invalidate(3, defaultModel = model);
        $$subscribe_model($$invalidate(0, model = new Model$2.Sieve(json, { parse: true })));
      }
    } else if (!model) {
      let content_type = 0;
      let attrs = {};
      switch (type) {
        case "page":
          content_type = C$2.TYPE_HTML;
          break;
        case "feed":
          content_type = C$2.TYPE_FEED;
          break;
        case "xml":
          content_type = C$2.TYPE_XML;
          break;
        case "pdf":
          content_type = C$2.TYPE_PDF_HTML;
          break;
        case "doc":
          content_type = C$2.TYPE_DOC;
          break;
        case "json":
          content_type = C$2.TYPE_JSON;
          switch (query.type) {
            case C$2.DS_TYPE_UPTIME:
              attrs.datasource_id = C$2.DS_ID_UPTIME;
              break;
            case C$2.DS_TYPE_JSON:
            default:
              attrs.datasource_id = C$2.DS_ID_JSON;
          }
          break;
        case "sitemap":
          content_type = C$2.TYPE_SITEMAP;
          break;
        default:
          Msg.error("Unknown monitor type: " + type);
      }
      $$subscribe_model($$invalidate(0, model = new Model$2.Sieve(
        {
          uri: query.url,
          content_type,
          version: 1,
          config: {},
          ...attrs
        },
        { parse: true }
      )));
      content_type === C$2.TYPE_SITEMAP && model.set("schedule", { type: "AUTO" });
      newSieve = true;
    }
    $$invalidate(1, formModel = new SieveFormModel(model));
    await setView();
    $$invalidate(2, loading2 = false);
  }
  async function setView() {
    $$invalidate(6, view = "");
    try {
      $$invalidate(5, sieveConstraint = await checkSieveConstraint(1));
    } catch (e) {
      console.error(e);
      $$invalidate(5, sieveConstraint = { isOverLimit: false });
    }
    $$invalidate(4, accessInfo = await model.getAccess(user));
    if (model.isNew() && !accessInfo.hasAccess) {
      $$invalidate(6, view = views.UPGRADE_ACCOUNT);
    } else if (model.isNew() && sieveConstraint.isOverLimit) {
      $$invalidate(6, view = views.OVERLIMIT);
    } else if (newSieve) {
      $$invalidate(6, view = views.SOURCE_SELECTOR);
    } else {
      $$invalidate(6, view = views.SIEVE_OPTIONS);
    }
  }
  function onDiscard() {
    if ($model.content_type === C$2.TYPE_HTML || $model.content_type === C$2.TYPE_SITEMAP) {
      App.navBack();
    }
  }
  const save_handler = () => setModel();
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2048) {
      if ($route.prefix == "dup" || $route.prefix == "add" || $route.prefix == "edit") {
        ({ id: id2, data: type, query } = $route);
        $$subscribe_model($$invalidate(0, model = void 0));
        $$invalidate(7, promise = setModel());
      }
    }
  };
  return [
    model,
    formModel,
    loading2,
    defaultModel,
    accessInfo,
    sieveConstraint,
    view,
    promise,
    views,
    setModel,
    onDiscard,
    $route,
    save_handler
  ];
}
class Sieve_options extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1$, create_fragment$22, safe_not_equal, {});
  }
}
function create_fragment$21(ctx) {
  let div;
  let input;
  let t0;
  let button;
  let t1;
  let button_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      button = element("button");
      t1 = text(ctx[1]);
      attr(input, "class", "d-none");
      attr(input, "type", "file");
      attr(input, "accept", ctx[0]);
      attr(button, "class", button_class_value = "btn btn-primary btn-lg " + ctx[3]);
      attr(div, "class", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[7](input);
      append(div, t0);
      append(div, button);
      append(button, t1);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[5]),
          listen(button, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(input, "accept", ctx2[0]);
      }
      if (dirty & 2)
        set_data(t1, ctx2[1]);
      if (dirty & 8 && button_class_value !== (button_class_value = "btn btn-primary btn-lg " + ctx2[3])) {
        attr(button, "class", button_class_value);
      }
      if (dirty & 4) {
        attr(div, "class", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1_($$self, $$props, $$invalidate) {
  let { accept } = $$props;
  let { label } = $$props;
  let { wrapperClasses = "" } = $$props;
  const dispatch = createEventDispatcher();
  let fileInputEl;
  let { class: classes2 } = $$props;
  function onFileChange(e) {
    const file = e.target.files[0];
    const reader = new FileReader();
    let filename = file.name;
    reader.readAsText(file, "utf-8");
    reader.onload = (e2) => {
      dispatch("read", { filename, data: e2.target.result });
    };
    reader.onerror = (e2) => {
      console.error("error reading file", e2);
      dispatch("error", { error: e2.message });
    };
  }
  function onFileSelect() {
    fileInputEl.click();
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fileInputEl = $$value;
      $$invalidate(4, fileInputEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("accept" in $$props2)
      $$invalidate(0, accept = $$props2.accept);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("wrapperClasses" in $$props2)
      $$invalidate(2, wrapperClasses = $$props2.wrapperClasses);
    if ("class" in $$props2)
      $$invalidate(3, classes2 = $$props2.class);
  };
  return [
    accept,
    label,
    wrapperClasses,
    classes2,
    fileInputEl,
    onFileChange,
    onFileSelect,
    input_binding
  ];
}
class FilePicker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1_, create_fragment$21, safe_not_equal, {
      accept: 0,
      label: 1,
      wrapperClasses: 2,
      class: 3
    });
  }
}
function create_default_slot$W(ctx) {
  let textarea;
  let textarea_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "id", "json");
      attr(textarea, "class", textarea_class_value = ctx[10] + " h-[400px] w-100");
      toggle_class(textarea, "is-invalid", ctx[12]);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (!mounted) {
        dispose = action_destroyer(ctx[11].call(null, textarea));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && textarea_class_value !== (textarea_class_value = ctx2[10] + " h-[400px] w-100")) {
        attr(textarea, "class", textarea_class_value);
      }
      if (dirty & 5120) {
        toggle_class(textarea, "is-invalid", ctx2[12]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$11(ctx) {
  let div;
  let t0;
  let t1;
  return {
    c() {
      div = element("div");
      t0 = text("Error Occurred : ");
      t1 = text(ctx[0]);
      attr(div, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t1, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$20(ctx) {
  let div1;
  let filepicker;
  let t0;
  let h4;
  let t2;
  let label;
  let t4;
  let fieldwrapper;
  let t5;
  let div0;
  let button;
  let t6;
  let t7;
  let current;
  let mounted;
  let dispose;
  filepicker = new FilePicker({
    props: {
      label: "Select JSON file",
      accept: ".json"
    }
  });
  filepicker.$on("read", ctx[4]);
  filepicker.$on("error", ctx[6]);
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[2],
      formatOptions: { showEmpty: false },
      $$slots: {
        default: [
          create_default_slot$W,
          ({ inputClasses, action, showError }) => ({
            10: inputClasses,
            11: action,
            12: showError
          }),
          ({ inputClasses, action, showError }) => (inputClasses ? 1024 : 0) | (action ? 2048 : 0) | (showError ? 4096 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[0] && create_if_block$11(ctx);
  return {
    c() {
      div1 = element("div");
      create_component(filepicker.$$.fragment);
      t0 = space();
      h4 = element("h4");
      h4.textContent = "OR";
      t2 = space();
      label = element("label");
      label.textContent = "Paste JSON here";
      t4 = space();
      create_component(fieldwrapper.$$.fragment);
      t5 = space();
      div0 = element("div");
      button = element("button");
      t6 = text("Next");
      t7 = space();
      if (if_block)
        if_block.c();
      attr(h4, "class", "my-3 ms-4");
      attr(label, "class", "form-label fs-5");
      attr(label, "for", "json");
      attr(button, "class", "btn btn-primary");
      button.disabled = ctx[1];
      attr(div0, "class", "mt-4 ms-2");
      attr(div1, "class", "mt-4 ms-4");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(filepicker, div1, null);
      append(div1, t0);
      append(div1, h4);
      append(div1, t2);
      append(div1, label);
      append(div1, t4);
      mount_component(fieldwrapper, div1, null);
      append(div1, t5);
      append(div1, div0);
      append(div0, button);
      append(button, t6);
      append(div1, t7);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 13312) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
      if (!current || dirty & 2) {
        button.disabled = ctx2[1];
      }
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$11(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(filepicker.$$.fragment, local);
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filepicker.$$.fragment, local);
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(filepicker);
      destroy_component(fieldwrapper);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$1Z($$self, $$props, $$invalidate) {
  let $jsonField;
  let $error;
  const jsonField = createFieldStore({ type: "jsonStr", required: true }, null);
  component_subscribe($$self, jsonField, (value) => $$invalidate(8, $jsonField = value));
  const { error } = jsonField;
  component_subscribe($$self, error, (value) => $$invalidate(1, $error = value));
  const dispatch = createEventDispatcher();
  let data;
  let err;
  function onRead(e) {
    ({ data } = e.detail);
    jsonField.set(data, { parse: true });
  }
  function onClick() {
    dispatch("next", { rows: $jsonField });
  }
  function onError(e) {
    $$invalidate(0, { error: err } = e.detail, err);
  }
  return [err, $error, jsonField, error, onRead, onClick, onError];
}
class PickFileStage$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Z, create_fragment$20, safe_not_equal, {});
  }
}
function create_if_block_2$v(ctx) {
  let div;
  let t0;
  let span0;
  let t1;
  let t2;
  let span1;
  let t3;
  return {
    c() {
      div = element("div");
      t0 = text("Importing Sieves: ");
      span0 = element("span");
      t1 = text(ctx[2]);
      t2 = text(" of ");
      span1 = element("span");
      t3 = text(ctx[3]);
      attr(div, "class", "text-lg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, span0);
      append(span0, t1);
      append(div, t2);
      append(div, span1);
      append(span1, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t1, ctx2[2]);
      if (dirty & 8)
        set_data(t3, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$H(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t1 = space();
      button1 = element("button");
      button1.textContent = `${T("a_import")}`;
      attr(button0, "class", "btn btn-default");
      attr(button1, "class", "btn btn-primary");
      attr(div, "class", "d-flex gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[12]),
          listen(button1, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$10(ctx) {
  let div;
  let t_value = (ctx[4] || "") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "text-lg ps-2");
      toggle_class(div, "text-success", ctx[1] === ctx[7].COMPLETE);
      toggle_class(div, "text-danger", ctx[1] === ctx[7].ERROR);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = (ctx2[4] || "") + ""))
        set_data(t, t_value);
      if (dirty & 130) {
        toggle_class(div, "text-success", ctx2[1] === ctx2[7].COMPLETE);
      }
      if (dirty & 130) {
        toggle_class(div, "text-danger", ctx2[1] === ctx2[7].ERROR);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1$(ctx) {
  let div0;
  let t1;
  let div5;
  let div2;
  let label0;
  let t3;
  let div1;
  let clientselector;
  let t4;
  let div4;
  let label1;
  let t6;
  let div3;
  let actionseditor;
  let updating_actions;
  let t7;
  let div6;
  let t8;
  let current;
  clientselector = new ClientSelector({
    props: {
      model: ctx[6],
      showAllClients: true
    }
  });
  function actionseditor_actions_binding(value) {
    ctx[11](value);
  }
  let actionseditor_props = {};
  if (ctx[0] !== void 0) {
    actionseditor_props.actions = ctx[0];
  }
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  binding_callbacks.push(() => bind$2(actionseditor, "actions", actionseditor_actions_binding));
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === ctx2[7].INIT)
      return create_if_block_1$H;
    if (ctx2[1] === ctx2[7].IMPORTING)
      return create_if_block_2$v;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type && current_block_type(ctx);
  let if_block1 = ctx[4] && create_if_block$10(ctx);
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<h3>Options</h3>`;
      t1 = space();
      div5 = element("div");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Device";
      t3 = space();
      div1 = element("div");
      create_component(clientselector.$$.fragment);
      t4 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = "Actions";
      t6 = space();
      div3 = element("div");
      create_component(actionseditor.$$.fragment);
      t7 = space();
      div6 = element("div");
      if (if_block0)
        if_block0.c();
      t8 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "py-2 border-bottom");
      attr(label0, "class", "xoption-label");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "flex gap-x-6");
      attr(label1, "class", "xoption-label");
      attr(div3, "class", "flex-1");
      attr(div4, "class", "flex gap-x-6");
      attr(div5, "class", "flex flex-col gap-y-6 p-[10px]");
      attr(div6, "class", "mt-4 ms-4");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div5, anchor);
      append(div5, div2);
      append(div2, label0);
      append(div2, t3);
      append(div2, div1);
      mount_component(clientselector, div1, null);
      append(div5, t4);
      append(div5, div4);
      append(div4, label1);
      append(div4, t6);
      append(div4, div3);
      mount_component(actionseditor, div3, null);
      insert(target, t7, anchor);
      insert(target, div6, anchor);
      if (if_block0)
        if_block0.m(div6, null);
      append(div6, t8);
      if (if_block1)
        if_block1.m(div6, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const actionseditor_changes = {};
      if (!updating_actions && dirty & 1) {
        updating_actions = true;
        actionseditor_changes.actions = ctx2[0];
        add_flush_callback(() => updating_actions = false);
      }
      actionseditor.$set(actionseditor_changes);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div6, t8);
        }
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$10(ctx2);
          if_block1.c();
          if_block1.m(div6, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(clientselector.$$.fragment, local);
      transition_in(actionseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientselector.$$.fragment, local);
      transition_out(actionseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div5);
      destroy_component(clientselector);
      destroy_component(actionseditor);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(div6);
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$1Y($$self, $$props, $$invalidate) {
  let $clients;
  let $model;
  let { rows } = $$props;
  const labels = getContext("labels");
  const clients = getContext("clients");
  component_subscribe($$self, clients, (value) => $$invalidate(14, $clients = value));
  const model = new Model$2.Sieve();
  component_subscribe($$self, model, (value) => $$invalidate(15, $model = value));
  const IMPORT_STATUS = {
    INIT: 0,
    IMPORTING: 1,
    COMPLETE: 2,
    ERROR: 3
  };
  const dispatch = createEventDispatcher();
  let actions;
  let status = IMPORT_STATUS.INIT;
  let labelMap;
  let index2 = 0;
  let total;
  let message = "";
  async function populateLabelMap(sieves) {
    Msg.info("Importing labels...");
    const names = _.uniq(_.flatten(_.pluck(sieves, "tags"))).filter((tag) => tag);
    const labelList = await labels.getOrCreateLabels(names);
    labelMap = labelList.reduce((acc, { id: id2, name }) => (acc[name] = id2, acc), {});
    Msg.reset();
  }
  async function checkConstraint(numRows) {
    let constraint;
    try {
      constraint = await checkSieveConstraint(numRows);
    } catch (e) {
      console.error(e);
      constraint = { isOverLimit: false };
    }
    return constraint;
  }
  async function importAll() {
    try {
      $$invalidate(1, status = IMPORT_STATUS.IMPORTING);
      let sieves = rows.data;
      $$invalidate(3, total = sieves.length);
      const constraint = await checkConstraint(total);
      if (constraint.isOverLimit) {
        throw new Error("Monitor limit exceeded");
      }
      await populateLabelMap(sieves);
      for (let i2 = 0; i2 < sieves.length; i2 += 1) {
        const sieve = sieves[i2];
        await importOne(sieve);
        $$invalidate(2, index2 += 1);
      }
      $$invalidate(1, status = IMPORT_STATUS.COMPLETE);
      $$invalidate(4, message = `Imported ${total} sieves`);
    } catch (e) {
      console.error("failed to import data:", e);
      $$invalidate(4, message = `Import failed: ${e.message || e.msg}`);
      $$invalidate(1, status = IMPORT_STATUS.ERROR);
    }
  }
  async function importOne(sieve) {
    if (sieve.rule) {
      let rule = await Api.api("/rules", "POST", { config: sieve.rule });
      sieve.rule_id = rule.id;
    }
    if (sieve.tags) {
      sieve.tags = sieve.tags.map((name) => labelMap[name]).join(",");
    }
    let client_id = $model.client_id;
    if (!validateClient(client_id, sieve)) {
      client_id = C$2.CLIENT_ID_WEB;
    }
    let res = await Api.api("/sieves", "POST", { ...sieve, client_id });
    const sieveId = res.id;
    await saveActions(sieveId);
  }
  function validateClient(selectedClientId, { content_type }) {
    const currSieve = new Model$2.Sieve({ content_type });
    const accessibleClients = currSieve.getAccessibleClients($clients);
    return !!accessibleClients.find((client) => selectedClientId === client.id);
  }
  async function saveActions(sieve_id) {
    const actionsList = actions.toJSON();
    for (let i2 = 0; i2 < actionsList.length; i2 += 1) {
      await Api.api(`/sieves/${sieve_id}/actions`, "POST", { sieve_id, ...actionsList[i2] });
    }
  }
  function actionseditor_actions_binding(value) {
    actions = value;
    $$invalidate(0, actions);
  }
  const click_handler = () => dispatch("back");
  $$self.$$set = ($$props2) => {
    if ("rows" in $$props2)
      $$invalidate(10, rows = $$props2.rows);
  };
  return [
    actions,
    status,
    index2,
    total,
    message,
    clients,
    model,
    IMPORT_STATUS,
    dispatch,
    importAll,
    rows,
    actionseditor_actions_binding,
    click_handler
  ];
}
class OptionsStage$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Y, create_fragment$1$, safe_not_equal, { rows: 10 });
  }
}
function create_if_block_1$G(ctx) {
  let optionsstage;
  let current;
  optionsstage = new OptionsStage$1({ props: { rows: ctx[1] } });
  optionsstage.$on("back", ctx[4]);
  return {
    c() {
      create_component(optionsstage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(optionsstage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const optionsstage_changes = {};
      if (dirty & 2)
        optionsstage_changes.rows = ctx2[1];
      optionsstage.$set(optionsstage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(optionsstage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(optionsstage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(optionsstage, detaching);
    }
  };
}
function create_if_block$$(ctx) {
  let pickfilestage;
  let current;
  pickfilestage = new PickFileStage$1({});
  pickfilestage.$on("next", ctx[5]);
  return {
    c() {
      create_component(pickfilestage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pickfilestage, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pickfilestage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pickfilestage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pickfilestage, detaching);
    }
  };
}
function create_fragment$1_(ctx) {
  let div0;
  let h2;
  let t2;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$$, create_if_block_1$G];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === ctx2[2].PICK_FILE)
      return 0;
    if (ctx2[0] === ctx2[2].OPTIONS)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = `${T("a_import")} - JSON`;
      t2 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      attr(div0, "class", "xpage-header");
      attr(div1, "class", "p-2 bg-white");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, h2);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div1, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$1X($$self, $$props, $$invalidate) {
  const STAGE = { PICK_FILE: 1, OPTIONS: 2 };
  function nextStage() {
    $$invalidate(0, stage += 1);
  }
  function prevStage() {
    $$invalidate(0, stage -= 1);
  }
  let stage = STAGE.PICK_FILE;
  let rows;
  const next_handler = (e) => {
    $$invalidate(1, { rows } = e.detail, rows);
    nextStage();
  };
  return [stage, rows, STAGE, nextStage, prevStage, next_handler];
}
class Import_json extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1X, create_fragment$1_, safe_not_equal, {});
  }
}
function create_fragment$1Z(ctx) {
  let div2;
  let div0;
  let filepicker;
  let t0;
  let div1;
  let current;
  filepicker = new FilePicker({
    props: {
      label: "Select CSV file to import monitors",
      accept: ".csv"
    }
  });
  filepicker.$on("read", ctx[0]);
  filepicker.$on("error", ctx[1]);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(filepicker.$$.fragment);
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `Please note that the file should have columns with following headers:
    <ul><li>Name</li> 
      <li>URL</li> 
      <li class="hide">Config (Optional)</li> 
      <li>Labels (Optional)</li> 
      <li>Datasource ID (Optional)</li></ul>`;
      attr(div0, "class", "col-md-4 d-flex justify-content-center order-1 order-md-0");
      attr(div1, "class", "col-md-4 fs-5 order-0 order-md-1");
      attr(div2, "class", "row align-items-center justify-content-center");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(filepicker, div0, null);
      append(div2, t0);
      append(div2, div1);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(filepicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filepicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(filepicker);
    }
  };
}
function instance$1W($$self) {
  const dispatch = createEventDispatcher();
  let filename;
  function onFileRead(e) {
    const text2 = e.detail.data;
    Papa.parse(text2, {
      header: true,
      skipEmptyLines: true,
      complete: (result) => dispatch("next", { filename, csv: result })
    });
  }
  function error_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [onFileRead, error_handler];
}
class PickFileStage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1W, create_fragment$1Z, safe_not_equal, {});
  }
}
function get_each_context$w(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  child_ctx[22] = i2;
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  return child_ctx;
}
function get_each_context_2$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  child_ctx[27] = list;
  child_ctx[28] = i2;
  return child_ctx;
}
function get_each_context_3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i2];
  return child_ctx;
}
function create_each_block_3(ctx) {
  let option;
  let t_value = ctx[29] + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[29];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block_2$2(ctx) {
  let th;
  let div;
  let select;
  let option;
  let t;
  let mounted;
  let dispose;
  let each_value_3 = Object.values(ctx[7]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks[i2] = create_each_block_3(get_each_context_3(ctx, each_value_3, i2));
  }
  function select_change_handler() {
    ctx[14].call(select, ctx[28]);
  }
  return {
    c() {
      th = element("th");
      div = element("div");
      select = element("select");
      option = element("option");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      option.__value = "";
      option.value = option.__value;
      if (ctx[1][ctx[28]] === void 0)
        add_render_callback(select_change_handler);
      attr(th, "class", "max-w-[150px] p-[5px]");
      set_style(th, "border", "solid 1px #ccc");
    },
    m(target, anchor) {
      insert(target, th, anchor);
      append(th, div);
      append(div, select);
      append(select, option);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[1][ctx[28]], true);
      append(th, t);
      if (!mounted) {
        dispose = listen(select, "change", select_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 128) {
        each_value_3 = Object.values(ctx[7]);
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3(ctx, each_value_3, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
      if (dirty[0] & 130) {
        select_option(select, ctx[1][ctx[28]]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(th);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$3(ctx) {
  let td;
  let t_value = ctx[20][ctx[23]] + "";
  let t;
  let td_title_value;
  return {
    c() {
      td = element("td");
      t = text(t_value);
      attr(td, "class", "max-w-[200px] p-[5px] overflow-x-scroll");
      set_style(td, "border", "solid 1px #ccc");
      set_style(td, "scrollbar-width", "thin");
      attr(td, "title", td_title_value = ctx[20][ctx[23]]);
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t_value !== (t_value = ctx2[20][ctx2[23]] + ""))
        set_data(t, t_value);
      if (dirty[0] & 1 && td_title_value !== (td_title_value = ctx2[20][ctx2[23]])) {
        attr(td, "title", td_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_each_block$w(ctx) {
  let tr;
  let td;
  let t0_value = ctx[22] + 1 + "";
  let t0;
  let t1;
  let t2;
  let each_value_1 = ctx[8];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i2));
  }
  return {
    c() {
      tr = element("tr");
      td = element("td");
      t0 = text(t0_value);
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      attr(td, "class", "max-w-[200px] p-[5px] overflow-x-scroll");
      set_style(td, "border", "solid 1px #ccc");
      set_style(td, "scrollbar-width", "thin");
      attr(tr, "class", "whitespace-nowrap");
      set_style(tr, "border-bottom", "solid 1px #ccc");
      toggle_class(tr, "bg-danger-subtle", ctx[3].has(ctx[22]));
      toggle_class(tr, "bg-secondary-subtle", ctx[5].has(ctx[22]));
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(td, t0);
      append(tr, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tr, null);
        }
      }
      append(tr, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 257) {
        each_value_1 = ctx2[8];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tr, t2);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & 8) {
        toggle_class(tr, "bg-danger-subtle", ctx2[3].has(ctx2[22]));
      }
      if (dirty[0] & 32) {
        toggle_class(tr, "bg-secondary-subtle", ctx2[5].has(ctx2[22]));
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$F(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].key === "url-validation")
      return create_if_block_2$u;
    return create_else_block$F;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "error mt-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_else_block$F(ctx) {
  let t_value = ctx[2].msg + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4 && t_value !== (t_value = ctx2[2].msg + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$u(ctx) {
  let t0_value = ctx[2].msg + "";
  let t0;
  let t1;
  let br0;
  let t2;
  let br1;
  let t3;
  let small;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" (highlighted in red)");
      br0 = element("br");
      t2 = text("Please check these rows and ensure the URLs conform to the expected\n        structure ");
      br1 = element("br");
      t3 = space();
      small = element("small");
      small.innerHTML = `<kbd title="protocol">https://</kbd>  <kbd title="host">example.com</kbd> 
          <kbd title="path">/path/to/resource</kbd>  <kbd title="queries">?param1=value1&amp;param2=value2</kbd> 
          <kbd title="hash">#fragment</kbd>`;
      set_style(small, "--bs-body-color", "#eee");
      set_style(small, "--bs-body-bg", "#333");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, br0, anchor);
      insert(target, t2, anchor);
      insert(target, br1, anchor);
      insert(target, t3, anchor);
      insert(target, small, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4 && t0_value !== (t0_value = ctx2[2].msg + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(br0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(br1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(small);
    }
  };
}
function create_if_block$_(ctx) {
  let small;
  let t0;
  let t1_value = getIndexesStr(Array.from(ctx[5]).slice(0, 10)) + "";
  let t1;
  let t2_value = ctx[5].size > 10 ? "... " : "";
  let t2;
  let t3;
  return {
    c() {
      small = element("small");
      t0 = text("Currently feed monitors are not supported via CSV rows: ");
      t1 = text(t1_value);
      t2 = text(t2_value);
      t3 = text(" (highlighted in gray)");
      attr(small, "class", "text-dark-emphasis mt-2");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t0);
      append(small, t1);
      append(small, t2);
      append(small, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32 && t1_value !== (t1_value = getIndexesStr(Array.from(ctx2[5]).slice(0, 10)) + ""))
        set_data(t1, t1_value);
      if (dirty[0] & 32 && t2_value !== (t2_value = ctx2[5].size > 10 ? "... " : ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment$1Y(ctx) {
  let div0;
  let t2;
  let div3;
  let div1;
  let table;
  let thead;
  let tr;
  let th;
  let t4;
  let t5;
  let tbody;
  let t6;
  let div2;
  let button0;
  let t8;
  let button1;
  let t9;
  let button1_disabled_value;
  let t10;
  let t11;
  let mounted;
  let dispose;
  let each_value_2 = ctx[1];
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i2));
  }
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$w(get_each_context$w(ctx, each_value, i2));
  }
  let if_block0 = ctx[2] && create_if_block_1$F(ctx);
  let if_block1 = ctx[5] && ctx[5].size > 0 && create_if_block$_(ctx);
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<h3 class="ms-2">Data
    <small class="text-muted fs-5">Column headers show identified column attributes. You can edit them to manually specify or correct them.</small></h3>`;
      t2 = space();
      div3 = element("div");
      div1 = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      th = element("th");
      th.textContent = "index";
      t4 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t5 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t6 = space();
      div2 = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t8 = space();
      button1 = element("button");
      t9 = text("Next - configure options and actions");
      t10 = space();
      if (if_block0)
        if_block0.c();
      t11 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "py-2");
      attr(th, "class", "max-w-[150px] p-[5px]");
      set_style(th, "border", "solid 1px #ccc");
      set_style(tr, "border-top", "solid 1px #ccc");
      attr(div1, "class", "max-h-[500px] overflow-scroll");
      attr(button0, "class", "btn btn-default");
      attr(button1, "class", "btn btn-primary");
      button1.disabled = button1_disabled_value = !!ctx[4];
      attr(div2, "class", "actions");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, table);
      append(table, thead);
      append(thead, tr);
      append(tr, th);
      append(tr, t4);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(tr, null);
        }
      }
      append(table, t5);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      ctx[15](tbody);
      append(div3, t6);
      append(div3, div2);
      append(div2, button0);
      append(div2, t8);
      append(div2, button1);
      append(button1, t9);
      append(div3, t10);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t11);
      if (if_block1)
        if_block1.m(div3, null);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[9]),
          listen(button1, "click", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 130) {
        each_value_2 = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$2(ctx2, each_value_2, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
          } else {
            each_blocks_1[i2] = create_each_block_2$2(child_ctx);
            each_blocks_1[i2].c();
            each_blocks_1[i2].m(tr, null);
          }
        }
        for (; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty[0] & 297) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$w(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$w(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tbody, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & 16 && button1_disabled_value !== (button1_disabled_value = !!ctx2[4])) {
        button1.disabled = button1_disabled_value;
      }
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$F(ctx2);
          if_block0.c();
          if_block0.m(div3, t11);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[5] && ctx2[5].size > 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$_(ctx2);
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      ctx[15](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function getIndexesStr(indexes) {
  return indexes.map((idx) => idx + 1).join(", ");
}
function instance$1V($$self, $$props, $$invalidate) {
  let { csv } = $$props;
  const dispatch = createEventDispatcher();
  const KNOWN_COLUMNS = {
    name: "name",
    url: "url",
    labels: "labels",
    "content type": "content_type",
    "datasourceid?": "datasource_id"
  };
  const fields = csv.meta.fields;
  const normalizedFields = fields.map((field) => KNOWN_COLUMNS[field.toLowerCase()]);
  let rows = csv.data;
  const selectFields = structuredClone(normalizedFields);
  let inputFields;
  let errorMap;
  let contentTypeHeader;
  let errRowIdxs = /* @__PURE__ */ new Set();
  let errLen = 0;
  let feedRowIdxs = /* @__PURE__ */ new Set();
  let tbodyEl;
  function createHeaderMap() {
    $$invalidate(12, inputFields = selectFields.reduce((acc, field, index2) => (field && (acc[field] = fields[index2]), acc), {}));
  }
  function onBack() {
    dispatch("back");
  }
  function updateRowHeader() {
    return rows.map((row) => {
      if (row[contentTypeHeader] == C$2.TYPE_FEED) {
        return;
      }
      return Object.entries(inputFields).reduce(
        (newRow, [field, header]) => {
          newRow[field] = row[header];
          return newRow;
        },
        {}
      );
    }).filter((row) => row);
  }
  function onNext() {
    $$invalidate(2, errorMap = null);
    $$invalidate(3, errRowIdxs = /* @__PURE__ */ new Set());
    $$invalidate(4, errLen = 0);
    if (!inputFields.name) {
      $$invalidate(2, errorMap = { key: "name", msg: "Missing column: Name" });
    } else if (!inputFields.url) {
      $$invalidate(2, errorMap = { key: "url", msg: "Missing column: URL" });
    } else {
      $$invalidate(0, rows = rows.filter((row) => !Object.values(row).every((v) => !v)));
      let firstUrlErrEl;
      const urlColumnName = inputFields.url;
      rows.forEach((row, idx) => {
        try {
          if (!feedRowIdxs.has(idx)) {
            new URL(row[urlColumnName]);
          }
        } catch (e) {
          if (!firstUrlErrEl) {
            firstUrlErrEl = tbodyEl.querySelector(`tr:nth-child(${idx})`);
          }
          errRowIdxs.add(idx);
        }
      });
      $$invalidate(4, errLen = errRowIdxs.size);
      if (errLen) {
        console.error(urlColumnName);
        const errMsg = `${errLen} Malformed URL${errLen > 1 ? "s" : ""} at rows: ${getIndexesStr(Array.from(errRowIdxs).slice(0, 10))}${errLen > 10 ? "... " : ""}.`;
        $$invalidate(2, errorMap = { key: "url-validation", msg: errMsg });
        firstUrlErrEl.scrollIntoView();
      }
    }
    if (errorMap) {
      return;
    }
    dispatch("next", { rows: updateRowHeader() });
  }
  function select_change_handler(i2) {
    selectFields[i2] = select_value(this);
    $$invalidate(1, selectFields);
    $$invalidate(7, KNOWN_COLUMNS);
  }
  function tbody_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tbodyEl = $$value;
      $$invalidate(6, tbodyEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("csv" in $$props2)
      $$invalidate(11, csv = $$props2.csv);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 12291) {
      if (selectFields) {
        createHeaderMap();
        $$invalidate(13, contentTypeHeader = inputFields.content_type);
        if (contentTypeHeader) {
          $$invalidate(5, feedRowIdxs = rows.reduce(
            (acc, row, idx) => {
              if (row[contentTypeHeader] == C$2.TYPE_FEED) {
                acc.add(idx);
              }
              return acc;
            },
            /* @__PURE__ */ new Set()
          ));
        }
      }
    }
  };
  return [
    rows,
    selectFields,
    errorMap,
    errRowIdxs,
    errLen,
    feedRowIdxs,
    tbodyEl,
    KNOWN_COLUMNS,
    fields,
    onBack,
    onNext,
    csv,
    inputFields,
    contentTypeHeader,
    select_change_handler,
    tbody_binding
  ];
}
class MarkDataStage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1V, create_fragment$1Y, safe_not_equal, { csv: 11 }, null, [-1, -1]);
  }
}
function create_if_block_5$9(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[20]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block_4$f(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[21]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block_3$o(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[22]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_if_block_2$t(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t1 = space();
      button1 = element("button");
      button1.textContent = `${T("a_import")}`;
      attr(button0, "class", "btn btn-default");
      attr(button1, "class", "btn btn-primary");
      attr(div, "class", "d-flex gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[23]),
          listen(button1, "click", ctx[14])
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$E(ctx) {
  let div;
  let t0;
  let span0;
  let t1;
  let t2;
  let span1;
  let t3;
  return {
    c() {
      div = element("div");
      t0 = text("Imported: ");
      span0 = element("span");
      t1 = text(ctx[6]);
      t2 = text(" of ");
      span1 = element("span");
      t3 = text(ctx[7]);
      attr(div, "class", "text-success text-lg ps-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, span0);
      append(span0, t1);
      append(div, t2);
      append(div, span1);
      append(span1, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data(t1, ctx2[6]);
      if (dirty[0] & 128)
        set_data(t3, ctx2[7]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$Z(ctx) {
  let div;
  let t_value = (ctx[8] || "") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "text-lg ps-2");
      toggle_class(div, "text-success", ctx[0] === ctx[9].COMPLETE);
      toggle_class(div, "text-danger", ctx[0] === ctx[9].ERROR);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256 && t_value !== (t_value = (ctx2[8] || "") + ""))
        set_data(t, t_value);
      if (dirty[0] & 513) {
        toggle_class(div, "text-success", ctx2[0] === ctx2[9].COMPLETE);
      }
      if (dirty[0] & 513) {
        toggle_class(div, "text-danger", ctx2[0] === ctx2[9].ERROR);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1X(ctx) {
  let div0;
  let t1;
  let div10;
  let div2;
  let label0;
  let t3;
  let div1;
  let clientselector;
  let t4;
  let div4;
  let label1;
  let t6;
  let div3;
  let scheduleeditor;
  let t7;
  let div6;
  let label2;
  let t9;
  let div5;
  let actionseditor;
  let updating_actions;
  let t10;
  let t11;
  let t12;
  let t13;
  let div8;
  let label3;
  let t15;
  let div7;
  let tagseditor;
  let t16;
  let t17;
  let div9;
  let t18;
  let current;
  clientselector = new ClientSelector({
    props: {
      model: ctx[12],
      showAllClients: true
    }
  });
  scheduleeditor = new ScheduleEditor({
    props: { formModel: ctx[13] }
  });
  function actionseditor_actions_binding(value) {
    ctx[18](value);
  }
  let actionseditor_props = {};
  if (ctx[2] !== void 0) {
    actionseditor_props.actions = ctx[2];
  }
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  ctx[17](actionseditor);
  binding_callbacks.push(() => bind$2(actionseditor, "actions", actionseditor_actions_binding));
  actionseditor.$on("globalaction", ctx[19]);
  actionseditor.$on("manage", ctx[15]);
  let if_block0 = ctx[3] && create_if_block_5$9(ctx);
  let if_block1 = ctx[4] && create_if_block_4$f(ctx);
  let if_block2 = ctx[5] && create_if_block_3$o(ctx);
  tagseditor = new TagsEditor({ props: { model: ctx[12] } });
  let if_block3 = ctx[0] === ctx[9].INIT && create_if_block_2$t(ctx);
  let if_block4 = ctx[6] && create_if_block_1$E(ctx);
  let if_block5 = ctx[8] && create_if_block$Z(ctx);
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<h3>Options</h3>`;
      t1 = space();
      div10 = element("div");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Device";
      t3 = space();
      div1 = element("div");
      create_component(clientselector.$$.fragment);
      t4 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = "Schedule";
      t6 = space();
      div3 = element("div");
      create_component(scheduleeditor.$$.fragment);
      t7 = space();
      div6 = element("div");
      label2 = element("label");
      label2.textContent = "Actions";
      t9 = space();
      div5 = element("div");
      create_component(actionseditor.$$.fragment);
      t10 = space();
      if (if_block0)
        if_block0.c();
      t11 = space();
      if (if_block1)
        if_block1.c();
      t12 = space();
      if (if_block2)
        if_block2.c();
      t13 = space();
      div8 = element("div");
      label3 = element("label");
      label3.textContent = "Labels";
      t15 = space();
      div7 = element("div");
      create_component(tagseditor.$$.fragment);
      t16 = space();
      if (if_block3)
        if_block3.c();
      t17 = space();
      div9 = element("div");
      if (if_block4)
        if_block4.c();
      t18 = space();
      if (if_block5)
        if_block5.c();
      attr(div0, "class", "py-2 border-bottom");
      attr(label0, "class", "xoption-label");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "flex gap-x-6");
      attr(label1, "class", "xoption-label");
      attr(div3, "class", "flex-1");
      attr(div4, "class", "flex gap-x-6");
      attr(label2, "class", "xoption-label");
      attr(div5, "class", "flex-1");
      attr(div6, "class", "flex gap-x-6");
      attr(label3, "class", "xoption-label");
      attr(div7, "class", "flex-1");
      attr(div8, "class", "flex gap-x-6");
      attr(div10, "class", "flex flex-col gap-y-6 p-[10px]");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div10, anchor);
      append(div10, div2);
      append(div2, label0);
      append(div2, t3);
      append(div2, div1);
      mount_component(clientselector, div1, null);
      append(div10, t4);
      append(div10, div4);
      append(div4, label1);
      append(div4, t6);
      append(div4, div3);
      mount_component(scheduleeditor, div3, null);
      append(div10, t7);
      append(div10, div6);
      append(div6, label2);
      append(div6, t9);
      append(div6, div5);
      mount_component(actionseditor, div5, null);
      append(div6, t10);
      if (if_block0)
        if_block0.m(div6, null);
      append(div6, t11);
      if (if_block1)
        if_block1.m(div6, null);
      append(div6, t12);
      if (if_block2)
        if_block2.m(div6, null);
      append(div10, t13);
      append(div10, div8);
      append(div8, label3);
      append(div8, t15);
      append(div8, div7);
      mount_component(tagseditor, div7, null);
      append(div10, t16);
      if (if_block3)
        if_block3.m(div10, null);
      append(div10, t17);
      append(div10, div9);
      if (if_block4)
        if_block4.m(div9, null);
      append(div9, t18);
      if (if_block5)
        if_block5.m(div9, null);
      current = true;
    },
    p(ctx2, dirty) {
      const actionseditor_changes = {};
      if (!updating_actions && dirty[0] & 4) {
        updating_actions = true;
        actionseditor_changes.actions = ctx2[2];
        add_flush_callback(() => updating_actions = false);
      }
      actionseditor.$set(actionseditor_changes);
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$9(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div6, t11);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$f(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div6, t12);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3$o(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div6, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[0] === ctx2[9].INIT) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_2$t(ctx2);
          if_block3.c();
          if_block3.m(div10, t17);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (ctx2[6]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_1$E(ctx2);
          if_block4.c();
          if_block4.m(div9, t18);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (ctx2[8]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block$Z(ctx2);
          if_block5.c();
          if_block5.m(div9, null);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(clientselector.$$.fragment, local);
      transition_in(scheduleeditor.$$.fragment, local);
      transition_in(actionseditor.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(tagseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientselector.$$.fragment, local);
      transition_out(scheduleeditor.$$.fragment, local);
      transition_out(actionseditor.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(tagseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div10);
      destroy_component(clientselector);
      destroy_component(scheduleeditor);
      ctx[17](null);
      destroy_component(actionseditor);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(tagseditor);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
    }
  };
}
function createCustomError(msg, e) {
  const err = new Error(msg);
  err.cause = e;
  return err;
}
function sanitizeCSVFields(sieveRequest) {
  if (sieveRequest.datasource_id === "") {
    sieveRequest.datasource_id = null;
  }
}
function instance$1U($$self, $$props, $$invalidate) {
  let $clients;
  let { rows } = $$props;
  const IMPORT_STATUS = {
    INIT: 0,
    IMPORTING: 1,
    COMPLETE: 2,
    ERROR: 3
  };
  const labels = getContext("labels");
  const clients = getContext("clients");
  component_subscribe($$self, clients, (value) => $$invalidate(25, $clients = value));
  const dispatch = createEventDispatcher();
  let status = IMPORT_STATUS.INIT;
  let actionEditor;
  let actions;
  let labelMap;
  let showGlobalActionEditor2;
  let showManageEmailsModal;
  let showManagePhonesModal;
  let index2 = 0;
  let total;
  let message = "";
  const model = new Model$2.Sieve();
  const formModel = new SieveFormModel(model);
  async function checkConstraint() {
    let constraint;
    try {
      constraint = await checkSieveConstraint(rows.length);
    } catch (e) {
      console.error("error while checking constraints", e);
      constraint = { isOverLimit: false };
    }
    return constraint;
  }
  async function onImport() {
    try {
      const options = model.toJSON();
      const constraint = await checkConstraint();
      if (constraint.isOverLimit) {
        throw new Error("Monitor limit exceeded");
      }
      await importAll(rows, options);
    } catch (e) {
      console.error(e);
      $$invalidate(0, status = IMPORT_STATUS.ERROR);
      $$invalidate(8, message = e.message || e.msg);
    }
  }
  async function importAll(sieves, options) {
    $$invalidate(6, index2 = 0);
    $$invalidate(0, status = IMPORT_STATUS.IMPORTING);
    $$invalidate(7, total = sieves.length);
    await populateLabelMap(sieves);
    for (let i2 = 0; i2 < sieves.length; i2 += 1) {
      const sieve = sieves[i2];
      $$invalidate(8, message = `Importing ${sieve.url}`);
      await importOne(sieve, options, i2);
      $$invalidate(6, index2 += 1);
    }
    $$invalidate(8, message = "Import Complete");
    $$invalidate(0, status = IMPORT_STATUS.COMPLETE);
  }
  async function populateLabelMap(sieves) {
    try {
      const names = sieves.reduce(
        (acc, { labels: labels2 }) => {
          if ((labels2 == null ? void 0 : labels2.length) > 0) {
            acc = [...acc, ...labels2.split(",")];
          }
          return acc;
        },
        []
      );
      const labelList = await labels.getOrCreateLabels(names);
      labelMap = labelList.reduce((acc, { id: id2, name }) => (acc[name] = id2, acc), {});
    } catch (e) {
      throw createCustomError("Import failed: Error while creating labels", e);
    }
  }
  async function importOne(sieve, { tags, client_id, ...sieveOptions }, idx) {
    try {
      if (sieve.rule) {
        try {
          const rule = await Api.api("/rules", "POST", { config: sieve.rule });
          sieve.rule_id = rule.id;
        } catch (e) {
          throw createCustomError("Error while saving rules", e);
        }
      }
      let labelIds = [];
      const labelsStr = sieve.labels || "";
      delete sieve.label;
      if (labelsStr.length > 0) {
        const labelNames = labelsStr.split(",");
        labelIds = labelNames.map((name) => labelMap[name]);
      }
      if (tags && tags.length > 0) {
        labelIds = [...labelIds, ...tags.split(",")];
      }
      sieve.tags = Array.from(new Set(labelIds)).join(",");
      const doc = {
        client_id: client_id || clients.defaultId,
        content_type: 2,
        ...sieve,
        ...sieveOptions
      };
      sanitizeCSVFields(doc);
      const sieveModel = new Model$2.Sieve({ ...doc, uri: sieve.url, config: {} }, { parse: true });
      if (!validateClient(sieveModel)) {
        sieveModel.set("client_id", C$2.CLIENT_ID_WEB);
      }
      try {
        await sieveModel.save();
      } catch (e) {
        throw createCustomError("Error while saving sieve", e);
      }
      const sieveId = sieveModel.get("id");
      await saveActions(sieveId);
    } catch (e) {
      e.message = `Import failed at row ${idx + 1} : ${e.message} for url - ${sieve.url}`;
      throw e;
    }
  }
  function validateClient(sieve) {
    const selectedClientId = sieve.get("client_id");
    const accessibleClients = sieve.getAccessibleClients($clients);
    return !!accessibleClients.find((client) => selectedClientId === client.id);
  }
  async function saveActions(sieve_id) {
    try {
      actionEditor.migrateChanges();
      const actionList = actions.toJSON();
      for (let i2 = 0; i2 < actionList.length; i2 += 1) {
        await Api.api(`/sieves/${sieve_id}/actions`, "POST", { sieve_id, ...actionList[i2] });
      }
    } catch (e) {
      throw createCustomError("Error while saving actions", e);
    }
  }
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(4, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(5, showManagePhonesModal = true);
    }
  }
  function actionseditor_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionEditor = $$value;
      $$invalidate(1, actionEditor);
    });
  }
  function actionseditor_actions_binding(value) {
    actions = value;
    $$invalidate(2, actions);
  }
  const globalaction_handler = () => {
    $$invalidate(3, showGlobalActionEditor2 = true);
  };
  const close_handler = () => $$invalidate(3, showGlobalActionEditor2 = false);
  const close_handler_1 = () => $$invalidate(4, showManageEmailsModal = false);
  const close_handler_2 = () => $$invalidate(5, showManagePhonesModal = false);
  const click_handler = () => dispatch("back");
  $$self.$$set = ($$props2) => {
    if ("rows" in $$props2)
      $$invalidate(16, rows = $$props2.rows);
  };
  return [
    status,
    actionEditor,
    actions,
    showGlobalActionEditor2,
    showManageEmailsModal,
    showManagePhonesModal,
    index2,
    total,
    message,
    IMPORT_STATUS,
    clients,
    dispatch,
    model,
    formModel,
    onImport,
    showModal,
    rows,
    actionseditor_binding,
    actionseditor_actions_binding,
    globalaction_handler,
    close_handler,
    close_handler_1,
    close_handler_2,
    click_handler
  ];
}
class OptionsStage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1U, create_fragment$1X, safe_not_equal, { rows: 16 }, null, [-1, -1]);
  }
}
function create_if_block_2$s(ctx) {
  let optionsstage;
  let current;
  optionsstage = new OptionsStage({ props: { rows: ctx[3] } });
  optionsstage.$on("back", ctx[6]);
  return {
    c() {
      create_component(optionsstage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(optionsstage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const optionsstage_changes = {};
      if (dirty & 8)
        optionsstage_changes.rows = ctx2[3];
      optionsstage.$set(optionsstage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(optionsstage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(optionsstage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(optionsstage, detaching);
    }
  };
}
function create_if_block_1$D(ctx) {
  let markdatastage;
  let current;
  markdatastage = new MarkDataStage({ props: { csv: ctx[2] } });
  markdatastage.$on("back", ctx[6]);
  markdatastage.$on("next", ctx[9]);
  return {
    c() {
      create_component(markdatastage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(markdatastage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const markdatastage_changes = {};
      if (dirty & 4)
        markdatastage_changes.csv = ctx2[2];
      markdatastage.$set(markdatastage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(markdatastage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdatastage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(markdatastage, detaching);
    }
  };
}
function create_if_block$Y(ctx) {
  let pickfilestage;
  let current;
  pickfilestage = new PickFileStage({});
  pickfilestage.$on("next", ctx[7]);
  pickfilestage.$on("error", ctx[8]);
  return {
    c() {
      create_component(pickfilestage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pickfilestage, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pickfilestage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pickfilestage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pickfilestage, detaching);
    }
  };
}
function create_fragment$1W(ctx) {
  let div0;
  let h2;
  let t2;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$Y, create_if_block_1$D, create_if_block_2$s];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === ctx2[4].PICK_FILE)
      return 0;
    if (ctx2[0] === ctx2[4].MARK_DATA)
      return 1;
    if (ctx2[0] === ctx2[4].OPTIONS)
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = `${T("a_import")} - CSV`;
      t2 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      attr(div0, "class", "xpage-header");
      attr(div1, "class", "p-2 bg-white");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, h2);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div1, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$1T($$self, $$props, $$invalidate) {
  const STAGE = { PICK_FILE: 1, MARK_DATA: 2, OPTIONS: 3 };
  function nextStage() {
    $$invalidate(0, stage += 1);
  }
  function prevStage() {
    $$invalidate(0, stage -= 1);
  }
  let stage = STAGE.PICK_FILE;
  let errMsg;
  let csv;
  let updatedRows;
  const next_handler = (e) => {
    $$invalidate(2, { csv } = e.detail, csv);
    nextStage();
  };
  const error_handler = (e) => {
    $$invalidate(1, errMsg = e.detail.error);
  };
  const next_handler_1 = (e) => {
    $$invalidate(3, { rows: updatedRows } = e.detail, updatedRows);
    nextStage();
  };
  return [
    stage,
    errMsg,
    csv,
    updatedRows,
    STAGE,
    nextStage,
    prevStage,
    next_handler,
    error_handler,
    next_handler_1
  ];
}
class Import_csv extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1T, create_fragment$1W, safe_not_equal, {});
  }
}
function create_else_block$E(ctx) {
  let importjson;
  let current;
  importjson = new Import_json({});
  return {
    c() {
      create_component(importjson.$$.fragment);
    },
    m(target, anchor) {
      mount_component(importjson, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(importjson.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(importjson.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(importjson, detaching);
    }
  };
}
function create_if_block$X(ctx) {
  let importcsv;
  let current;
  importcsv = new Import_csv({});
  return {
    c() {
      create_component(importcsv.$$.fragment);
    },
    m(target, anchor) {
      mount_component(importcsv, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(importcsv.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(importcsv.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(importcsv, detaching);
    }
  };
}
function create_fragment$1V(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$X, create_else_block$E];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].prefix == "csv")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1S($$self, $$props, $$invalidate) {
  let { route: route2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$invalidate(0, route2 = $$props2.route);
  };
  return [route2];
}
class Import extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1S, create_fragment$1V, safe_not_equal, { route: 0 });
  }
}
function create_default_slot$V(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$1U(ctx) {
  let menuitem;
  let current;
  const menuitem_spread_levels = [
    {
      disabled: ctx[0].readOnly
    },
    ctx[2]
  ];
  let menuitem_props = {
    $$slots: { default: [create_default_slot$V] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < menuitem_spread_levels.length; i2 += 1) {
    menuitem_props = assign$1(menuitem_props, menuitem_spread_levels[i2]);
  }
  menuitem = new MenuItem$1({ props: menuitem_props });
  menuitem.$on("click", ctx[4]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menuitem_changes = dirty & 5 ? get_spread_update(menuitem_spread_levels, [
        dirty & 1 && {
          disabled: ctx2[0].readOnly
        },
        dirty & 4 && get_spread_object(ctx2[2])
      ]) : {};
      if (dirty & 32) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function instance$1R($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $permissionsModel;
  let { $$slots: slots = {}, $$scope } = $$props;
  const permissionsModel = App.user.permissionsModel;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(0, $permissionsModel = value));
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    $permissionsModel,
    permissionsModel,
    $$restProps,
    slots,
    click_handler,
    $$scope
  ];
}
class MenuItemWithPermissions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1R, create_fragment$1U, safe_not_equal, {});
  }
}
function create_action_slot$d(ctx) {
  let a0;
  let t0_value = ctx[2].name + "";
  let t0;
  let a0_class_value;
  let a0_href_value;
  let a0_title_value;
  let t1;
  let a1;
  let span;
  let a1_class_value;
  let a1_id_value;
  let mounted;
  let dispose;
  return {
    c() {
      a0 = element("a");
      t0 = text(t0_value);
      t1 = space();
      a1 = element("a");
      span = element("span");
      span.textContent = "Toggle Dropdown";
      attr(a0, "class", a0_class_value = "align-items-center w-70 flex-1 text-nowrap overflow-hidden d-inline " + (ctx[5] ? "text-white" : ""));
      attr(a0, "href", a0_href_value = "#/w/" + ctx[1].team + "/list/label/" + ctx[10]() + ".d/");
      attr(a0, "title", a0_title_value = ctx[2].name);
      attr(span, "class", "visually-hidden");
      attr(a1, "class", a1_class_value = "dropdown-toggle " + (ctx[5] ? "text-white" : "text-secondary-emphasis"));
      attr(a1, "id", a1_id_value = ctx[2].id);
      attr(a1, "data-bs-toggle", "dropdown");
    },
    m(target, anchor) {
      insert(target, a0, anchor);
      append(a0, t0);
      insert(target, t1, anchor);
      insert(target, a1, anchor);
      append(a1, span);
      if (!mounted) {
        dispose = listen(a1, "click", function() {
          if (is_function(ctx[14]))
            ctx[14].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t0_value !== (t0_value = ctx[2].name + ""))
        set_data(t0, t0_value);
      if (dirty & 32 && a0_class_value !== (a0_class_value = "align-items-center w-70 flex-1 text-nowrap overflow-hidden d-inline " + (ctx[5] ? "text-white" : ""))) {
        attr(a0, "class", a0_class_value);
      }
      if (dirty & 2 && a0_href_value !== (a0_href_value = "#/w/" + ctx[1].team + "/list/label/" + ctx[10]() + ".d/")) {
        attr(a0, "href", a0_href_value);
      }
      if (dirty & 4 && a0_title_value !== (a0_title_value = ctx[2].name)) {
        attr(a0, "title", a0_title_value);
      }
      if (dirty & 32 && a1_class_value !== (a1_class_value = "dropdown-toggle " + (ctx[5] ? "text-white" : "text-secondary-emphasis"))) {
        attr(a1, "class", a1_class_value);
      }
      if (dirty & 4 && a1_id_value !== (a1_id_value = ctx[2].id)) {
        attr(a1, "id", a1_id_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(a1);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$5(ctx) {
  let i2;
  let t0;
  let t1_value = T("a_rename") + "";
  let t1;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fa fa-pencil");
      attr(i2, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i2);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot_2$8(ctx) {
  let i2;
  let t0;
  let t1_value = T("a_del") + "";
  let t1;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fa fa-trash-o");
      attr(i2, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i2);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot_1$o(ctx) {
  let menuitemwithpermissions0;
  let t;
  let menuitemwithpermissions1;
  let current;
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions0.$on("click", ctx[8]);
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_2$8] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1.$on("click", ctx[7]);
  return {
    c() {
      create_component(menuitemwithpermissions0.$$.fragment);
      t = space();
      create_component(menuitemwithpermissions1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions0, target, anchor);
      insert(target, t, anchor);
      mount_component(menuitemwithpermissions1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions0_changes = {};
      if (dirty & 32768) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 32768) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions0, detaching);
      if (detaching)
        detach(t);
      destroy_component(menuitemwithpermissions1, detaching);
    }
  };
}
function create_if_block$W(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      onSave: ctx[9],
      title: T("Rename Label"),
      $$slots: { default: [create_default_slot$U] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[13]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 32784) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$U(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-control");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[4]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && input.value !== ctx2[4]) {
        set_input_value(input, ctx2[4]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1T(ctx) {
  let li;
  let menu;
  let t;
  let if_block_anchor;
  let current;
  menu = new Menu$1({
    props: {
      class: "d-flex " + (ctx[5] ? "nav-link active" : "text-secondary-emphasis nav-link") + " ",
      $$slots: {
        default: [create_default_slot_1$o],
        action: [
          create_action_slot$d,
          ({ onClick }) => ({ 14: onClick }),
          ({ onClick }) => onClick ? 16384 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[3] && create_if_block$W(ctx);
  return {
    c() {
      li = element("li");
      create_component(menu.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(li, "class", "nav-item w-100");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(menu, li, null);
      ctx[11](li);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 32)
        menu_changes.class = "d-flex " + (ctx2[5] ? "nav-link active" : "text-secondary-emphasis nav-link") + " ";
      if (dirty & 49190) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$W(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(menu);
      ctx[11](null);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1Q($$self, $$props, $$invalidate) {
  let $route;
  let $label, $$unsubscribe_label = noop, $$subscribe_label = () => ($$unsubscribe_label(), $$unsubscribe_label = subscribe(label, ($$value) => $$invalidate(2, $label = $$value)), label);
  component_subscribe($$self, route, ($$value) => $$invalidate(1, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_label());
  let { label } = $$props;
  $$subscribe_label();
  let renameModal = false;
  let newLabelName = $label.name;
  let active = false;
  let labelEl = null;
  async function onDel(e) {
    e.preventDefault();
    await label.destroy();
  }
  async function onRename(e) {
    e.preventDefault();
    $$invalidate(3, renameModal = true);
  }
  async function onSaveName() {
    let name = newLabelName;
    await label.save({ name }, { patch: true, wait: true });
    $$invalidate(3, renameModal = false);
  }
  function getPath2() {
    return $label.id;
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      labelEl = $$value;
      $$invalidate(6, labelEl);
    });
  }
  function input_input_handler() {
    newLabelName = this.value;
    $$invalidate(4, newLabelName);
  }
  const close_handler = (e) => $$invalidate(3, renameModal = false);
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$subscribe_label($$invalidate(0, label = $$props2.label));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      $$invalidate(5, active = $route.prefix === "label" && $label.id == $route.data);
    }
  };
  return [
    label,
    $route,
    $label,
    renameModal,
    newLabelName,
    active,
    labelEl,
    onDel,
    onRename,
    onSaveName,
    getPath2,
    li_binding,
    input_input_handler,
    close_handler
  ];
}
class Label extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Q, create_fragment$1T, safe_not_equal, { label: 0 });
  }
}
function get_each_context$v(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function create_default_slot_8$2(ctx) {
  let t_value = T("l_webpage") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7$3(ctx) {
  let t_value = T("l_feed") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$3(ctx) {
  let t_value = T("l_json") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$4(ctx) {
  let t_value = T("l_pdf") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$4(ctx) {
  let t_value = T("l_uptime") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$4(ctx) {
  let t_value = T("l_doc") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$7(ctx) {
  let t_value = T("l_xml") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$n(ctx) {
  let t_value = T("l_sitemap") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$r(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[3]);
      attr(span, "class", "badge rounded-pill bg-primary float-end");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$C(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[2]);
      attr(span, "class", "badge rounded-pill bg-danger float-end");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$v(key_1, ctx) {
  let first;
  let label;
  let current;
  label = new Label({ props: { label: ctx[16] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(label.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(label, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const label_changes = {};
      if (dirty & 64)
        label_changes.label = ctx[16];
      label.$set(label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(label, detaching);
    }
  };
}
function create_if_block$V(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Add Label",
      onSave: ctx[11],
      $$slots: { default: [create_default_slot$T] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[13]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 524320) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$T(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "form-control");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[5]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32 && input.value !== ctx2[5]) {
        set_input_value(input, ctx2[5]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1S(ctx) {
  let div1;
  let div0;
  let button0;
  let t1;
  let ul0;
  let menuitemwithpermissions0;
  let t2;
  let menuitemwithpermissions1;
  let t3;
  let menuitemwithpermissions2;
  let t4;
  let menuitemwithpermissions3;
  let t5;
  let menuitemwithpermissions4;
  let t6;
  let menuitemwithpermissions5;
  let t7;
  let menuitemwithpermissions6;
  let t8;
  let menuitemwithpermissions7;
  let t9;
  let ul1;
  let li0;
  let a0;
  let t10_value = T("l_all") + "";
  let t10;
  let a0_href_value;
  let t11;
  let li1;
  let a1;
  let t12_value = T("l_unread") + "";
  let t12;
  let t13;
  let a1_href_value;
  let t14;
  let li2;
  let a2;
  let t15_value = T("l_error") + "";
  let t15;
  let t16;
  let a2_href_value;
  let t17;
  let li3;
  let a3;
  let t18_value = T("l_trash") + "";
  let t18;
  let a3_href_value;
  let t19;
  let hr;
  let t20;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t21;
  let div2;
  let button1;
  let t22_value = T("a_add_label") + "";
  let t22;
  let button1_disabled_value;
  let t23;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      href: "#/w/" + ctx[0] + "/sieve/add/page.d",
      $$slots: { default: [create_default_slot_8$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      href: "#/w/" + ctx[0] + "/sieve/add/feed.d",
      $$slots: { default: [create_default_slot_7$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions2 = new MenuItemWithPermissions({
    props: {
      href: "#/w/" + ctx[0] + "/sieve/add/json.d?type=" + C$2.DS_TYPE_JSON,
      $$slots: { default: [create_default_slot_6$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions3 = new MenuItemWithPermissions({
    props: {
      href: "#/w/" + ctx[0] + "/sieve/add/pdf.d",
      $$slots: { default: [create_default_slot_5$4] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions4 = new MenuItemWithPermissions({
    props: {
      href: "#/w/" + ctx[0] + "/sieve/add/json.d?type=" + C$2.DS_TYPE_UPTIME,
      $$slots: { default: [create_default_slot_4$4] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions5 = new MenuItemWithPermissions({
    props: {
      href: "#/w/" + ctx[0] + "/sieve/add/doc.d",
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions6 = new MenuItemWithPermissions({
    props: {
      href: "#/w/" + ctx[0] + "/sieve/add/xml.d",
      $$slots: { default: [create_default_slot_2$7] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions7 = new MenuItemWithPermissions({
    props: {
      href: "#/w/" + ctx[0] + "/sieve/add/sitemap.d",
      $$slots: { default: [create_default_slot_1$n] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[3] > 0 && create_if_block_2$r(ctx);
  let if_block1 = ctx[2] > 0 && create_if_block_1$C(ctx);
  let each_value = ctx[6].models;
  const get_key = (ctx2) => ctx2[16].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$v(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$v(key, child_ctx));
  }
  let if_block2 = ctx[4] && create_if_block$V(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.textContent = `${T("l_add_monitor")}`;
      t1 = space();
      ul0 = element("ul");
      create_component(menuitemwithpermissions0.$$.fragment);
      t2 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      t3 = space();
      create_component(menuitemwithpermissions2.$$.fragment);
      t4 = space();
      create_component(menuitemwithpermissions3.$$.fragment);
      t5 = space();
      create_component(menuitemwithpermissions4.$$.fragment);
      t6 = space();
      create_component(menuitemwithpermissions5.$$.fragment);
      t7 = space();
      create_component(menuitemwithpermissions6.$$.fragment);
      t8 = space();
      create_component(menuitemwithpermissions7.$$.fragment);
      t9 = space();
      ul1 = element("ul");
      li0 = element("li");
      a0 = element("a");
      t10 = text(t10_value);
      t11 = space();
      li1 = element("li");
      a1 = element("a");
      t12 = text(t12_value);
      t13 = space();
      if (if_block0)
        if_block0.c();
      t14 = space();
      li2 = element("li");
      a2 = element("a");
      t15 = text(t15_value);
      t16 = space();
      if (if_block1)
        if_block1.c();
      t17 = space();
      li3 = element("li");
      a3 = element("a");
      t18 = text(t18_value);
      t19 = space();
      hr = element("hr");
      t20 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t21 = space();
      div2 = element("div");
      button1 = element("button");
      t22 = text(t22_value);
      t23 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr(button0, "class", "btn btn-success rounded-end");
      attr(button0, "data-bs-toggle", "dropdown");
      attr(ul0, "class", "dropdown-menu w-100");
      attr(ul0, "role", "menu");
      attr(div0, "class", "btn-group btn-block mb-3 w-100");
      attr(a0, "class", "nav-link");
      attr(a0, "href", a0_href_value = "#/w/" + ctx[0] + "/list/all/");
      toggle_class(a0, "active", ctx[1].prefix === "all");
      attr(li0, "class", "nav-item");
      attr(a1, "class", "nav-link");
      attr(a1, "href", a1_href_value = "#/w/" + ctx[0] + "/list/unread/");
      toggle_class(a1, "active", ctx[1].prefix === "unread");
      attr(li1, "class", "nav-item");
      attr(a2, "class", "nav-link");
      attr(a2, "href", a2_href_value = "#/w/" + ctx[0] + "/list/error/");
      toggle_class(a2, "active", ctx[1].prefix === "error");
      attr(li2, "class", "nav-item");
      attr(a3, "class", "nav-link");
      attr(a3, "href", a3_href_value = "#/w/" + ctx[0] + "/list/trash/");
      toggle_class(a3, "active", ctx[1].prefix === "trash");
      attr(li3, "class", "nav-item");
      attr(hr, "class", "p-0 m-0");
      attr(ul1, "class", "nav nav-pills watchlist-nav-spacing flex-column mb-4");
      attr(div1, "class", "flex-shrink-0");
      attr(button1, "class", "btn btn-default w-100 mt-2");
      button1.disabled = button1_disabled_value = ctx[7].readOnly;
      attr(div2, "class", "sticky-bottom z-0");
      attr(div2, "style", "");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, ul0);
      mount_component(menuitemwithpermissions0, ul0, null);
      append(ul0, t2);
      mount_component(menuitemwithpermissions1, ul0, null);
      append(ul0, t3);
      mount_component(menuitemwithpermissions2, ul0, null);
      append(ul0, t4);
      mount_component(menuitemwithpermissions3, ul0, null);
      append(ul0, t5);
      mount_component(menuitemwithpermissions4, ul0, null);
      append(ul0, t6);
      mount_component(menuitemwithpermissions5, ul0, null);
      append(ul0, t7);
      mount_component(menuitemwithpermissions6, ul0, null);
      append(ul0, t8);
      mount_component(menuitemwithpermissions7, ul0, null);
      append(div1, t9);
      append(div1, ul1);
      append(ul1, li0);
      append(li0, a0);
      append(a0, t10);
      append(ul1, t11);
      append(ul1, li1);
      append(li1, a1);
      append(a1, t12);
      append(a1, t13);
      if (if_block0)
        if_block0.m(a1, null);
      append(ul1, t14);
      append(ul1, li2);
      append(li2, a2);
      append(a2, t15);
      append(a2, t16);
      if (if_block1)
        if_block1.m(a2, null);
      append(ul1, t17);
      append(ul1, li3);
      append(li3, a3);
      append(a3, t18);
      append(ul1, t19);
      append(ul1, hr);
      append(ul1, t20);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul1, null);
        }
      }
      insert(target, t21, anchor);
      insert(target, div2, anchor);
      append(div2, button1);
      append(button1, t22);
      insert(target, t23, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button1, "click", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const menuitemwithpermissions0_changes = {};
      if (dirty & 1)
        menuitemwithpermissions0_changes.href = "#/w/" + ctx2[0] + "/sieve/add/page.d";
      if (dirty & 524288) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 1)
        menuitemwithpermissions1_changes.href = "#/w/" + ctx2[0] + "/sieve/add/feed.d";
      if (dirty & 524288) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
      const menuitemwithpermissions2_changes = {};
      if (dirty & 1)
        menuitemwithpermissions2_changes.href = "#/w/" + ctx2[0] + "/sieve/add/json.d?type=" + C$2.DS_TYPE_JSON;
      if (dirty & 524288) {
        menuitemwithpermissions2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions2.$set(menuitemwithpermissions2_changes);
      const menuitemwithpermissions3_changes = {};
      if (dirty & 1)
        menuitemwithpermissions3_changes.href = "#/w/" + ctx2[0] + "/sieve/add/pdf.d";
      if (dirty & 524288) {
        menuitemwithpermissions3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions3.$set(menuitemwithpermissions3_changes);
      const menuitemwithpermissions4_changes = {};
      if (dirty & 1)
        menuitemwithpermissions4_changes.href = "#/w/" + ctx2[0] + "/sieve/add/json.d?type=" + C$2.DS_TYPE_UPTIME;
      if (dirty & 524288) {
        menuitemwithpermissions4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions4.$set(menuitemwithpermissions4_changes);
      const menuitemwithpermissions5_changes = {};
      if (dirty & 1)
        menuitemwithpermissions5_changes.href = "#/w/" + ctx2[0] + "/sieve/add/doc.d";
      if (dirty & 524288) {
        menuitemwithpermissions5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions5.$set(menuitemwithpermissions5_changes);
      const menuitemwithpermissions6_changes = {};
      if (dirty & 1)
        menuitemwithpermissions6_changes.href = "#/w/" + ctx2[0] + "/sieve/add/xml.d";
      if (dirty & 524288) {
        menuitemwithpermissions6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions6.$set(menuitemwithpermissions6_changes);
      const menuitemwithpermissions7_changes = {};
      if (dirty & 1)
        menuitemwithpermissions7_changes.href = "#/w/" + ctx2[0] + "/sieve/add/sitemap.d";
      if (dirty & 524288) {
        menuitemwithpermissions7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions7.$set(menuitemwithpermissions7_changes);
      if (!current || dirty & 1 && a0_href_value !== (a0_href_value = "#/w/" + ctx2[0] + "/list/all/")) {
        attr(a0, "href", a0_href_value);
      }
      if (!current || dirty & 2) {
        toggle_class(a0, "active", ctx2[1].prefix === "all");
      }
      if (ctx2[3] > 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$r(ctx2);
          if_block0.c();
          if_block0.m(a1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & 1 && a1_href_value !== (a1_href_value = "#/w/" + ctx2[0] + "/list/unread/")) {
        attr(a1, "href", a1_href_value);
      }
      if (!current || dirty & 2) {
        toggle_class(a1, "active", ctx2[1].prefix === "unread");
      }
      if (ctx2[2] > 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$C(ctx2);
          if_block1.c();
          if_block1.m(a2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 1 && a2_href_value !== (a2_href_value = "#/w/" + ctx2[0] + "/list/error/")) {
        attr(a2, "href", a2_href_value);
      }
      if (!current || dirty & 2) {
        toggle_class(a2, "active", ctx2[1].prefix === "error");
      }
      if (!current || dirty & 1 && a3_href_value !== (a3_href_value = "#/w/" + ctx2[0] + "/list/trash/")) {
        attr(a3, "href", a3_href_value);
      }
      if (!current || dirty & 2) {
        toggle_class(a3, "active", ctx2[1].prefix === "trash");
      }
      if (dirty & 64) {
        each_value = ctx2[6].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul1, outro_and_destroy_block, create_each_block$v, null, get_each_context$v);
        check_outros();
      }
      if (!current || dirty & 128 && button1_disabled_value !== (button1_disabled_value = ctx2[7].readOnly)) {
        button1.disabled = button1_disabled_value;
      }
      if (ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$V(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      transition_in(menuitemwithpermissions2.$$.fragment, local);
      transition_in(menuitemwithpermissions3.$$.fragment, local);
      transition_in(menuitemwithpermissions4.$$.fragment, local);
      transition_in(menuitemwithpermissions5.$$.fragment, local);
      transition_in(menuitemwithpermissions6.$$.fragment, local);
      transition_in(menuitemwithpermissions7.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      transition_out(menuitemwithpermissions2.$$.fragment, local);
      transition_out(menuitemwithpermissions3.$$.fragment, local);
      transition_out(menuitemwithpermissions4.$$.fragment, local);
      transition_out(menuitemwithpermissions5.$$.fragment, local);
      transition_out(menuitemwithpermissions6.$$.fragment, local);
      transition_out(menuitemwithpermissions7.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(menuitemwithpermissions0);
      destroy_component(menuitemwithpermissions1);
      destroy_component(menuitemwithpermissions2);
      destroy_component(menuitemwithpermissions3);
      destroy_component(menuitemwithpermissions4);
      destroy_component(menuitemwithpermissions5);
      destroy_component(menuitemwithpermissions6);
      destroy_component(menuitemwithpermissions7);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (detaching)
        detach(t21);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t23);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$1P($$self, $$props, $$invalidate) {
  let $route;
  let $labels;
  let $permissionsModel;
  component_subscribe($$self, route, ($$value) => $$invalidate(1, $route = $$value));
  let labels = getContext("labels");
  component_subscribe($$self, labels, (value) => $$invalidate(6, $labels = value));
  const user = getContext("user");
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(7, $permissionsModel = value));
  let nError = 0;
  let nUnread = 0;
  let addLabel = false;
  let newLabelName = "";
  let team = 0;
  onMount(() => {
    instance$4s.on("user_states", onChangeUnreadError);
  });
  onDestroy(() => {
    instance$4s.off("user_states", onChangeUnreadError);
  });
  async function onAddLabel() {
    $$invalidate(4, addLabel = true);
  }
  async function onAddLabelSave() {
    if (_.isEmpty(newLabelName)) {
      throw new Error("e_value_incorrect_check");
    } else {
      await labels.create({ name: newLabelName }, { wait: true });
      $$invalidate(5, newLabelName = "");
      $$invalidate(4, addLabel = false);
    }
  }
  function onChangeUnreadError({ error, unread }) {
    $$invalidate(2, nError = error);
    $$invalidate(3, nUnread = unread);
  }
  function input_input_handler() {
    newLabelName = this.value;
    $$invalidate(5, newLabelName);
  }
  const close_handler = (e) => $$invalidate(4, addLabel = false);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      {
        $$invalidate(0, team = $route.team);
      }
    }
    if ($$self.$$.dirty & 1) {
      labels.fetch();
    }
  };
  return [
    team,
    $route,
    nError,
    nUnread,
    addLabel,
    newLabelName,
    $labels,
    $permissionsModel,
    labels,
    permissionsModel,
    onAddLabel,
    onAddLabelSave,
    input_input_handler,
    close_handler
  ];
}
class Sidebar$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1P, create_fragment$1S, safe_not_equal, {});
  }
}
function create_action_slot$c(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "type", "button");
      attr(button, "class", "xbtn-light dropdown-toggle");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[5]))
            ctx[5].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$S(ctx) {
  let li0;
  let a0;
  let t1;
  let li1;
  let a1;
  let t3;
  let li2;
  let a2;
  let t5;
  let li3;
  let a3;
  let mounted;
  let dispose;
  return {
    c() {
      li0 = element("li");
      a0 = element("a");
      a0.textContent = `${T("l_all")}`;
      t1 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = `${T("l_none")}`;
      t3 = space();
      li2 = element("li");
      a2 = element("a");
      a2.textContent = `${T("l_read")}`;
      t5 = space();
      li3 = element("li");
      a3 = element("a");
      a3.textContent = `${T("l_unread")}`;
      attr(a0, "class", "dropdown-item");
      attr(a1, "class", "dropdown-item");
      attr(a2, "class", "dropdown-item");
      attr(a3, "class", "dropdown-item");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      append(li0, a0);
      insert(target, t1, anchor);
      insert(target, li1, anchor);
      append(li1, a1);
      insert(target, t3, anchor);
      insert(target, li2, anchor);
      append(li2, a2);
      insert(target, t5, anchor);
      insert(target, li3, anchor);
      append(li3, a3);
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[1]),
          listen(a1, "click", ctx[2]),
          listen(a2, "click", ctx[3]),
          listen(a3, "click", ctx[4])
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(li1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(li2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(li3);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$1R(ctx) {
  let menu;
  let current;
  menu = new Menu$1({
    props: {
      showCaret: false,
      $$slots: {
        default: [create_default_slot$S],
        action: [
          create_action_slot$c,
          ({ onClick }) => ({ 5: onClick }),
          ({ onClick }) => onClick ? 32 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 97) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1O($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const click_handler = () => sieves.toggleSieveSelection(true);
  const click_handler_1 = () => sieves.toggleSieveSelection(false);
  const click_handler_2 = () => sieves.toggleSieveSelection((sieve) => sieve.isRead());
  const click_handler_3 = () => sieves.toggleSieveSelection((sieve) => !sieve.isRead());
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(0, sieves = $$props2.sieves);
  };
  return [sieves, click_handler, click_handler_1, click_handler_2, click_handler_3];
}
class SieveSelectMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1O, create_fragment$1R, safe_not_equal, { sieves: 0 });
  }
}
function create_action_slot$b(ctx) {
  let div;
  let a;
  let i0;
  let t;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      a = element("a");
      i0 = element("i");
      t = space();
      button = element("button");
      button.innerHTML = `<i class="caret"></i>`;
      attr(i0, "class", "fa fa-check");
      attr(a, "class", "btn btn-default min-w-[60px]");
      attr(a, "title", T("a_mark_read"));
      toggle_class(a, "disabled", ctx[0]);
      attr(button, "class", "btn btn-default dropdown-toggle");
      attr(button, "data-toggle", "dropdown");
      set_style(button, "min-width", "20px");
      attr(div, "class", "btn-group flex nowrap");
      attr(div, "disabled", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, i0);
      append(div, t);
      append(div, button);
      if (!mounted) {
        dispose = [
          listen(a, "click", prevent_default(ctx[3])),
          listen(button, "click", function() {
            if (is_function(ctx[4]))
              ctx[4].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1) {
        toggle_class(a, "disabled", ctx[0]);
      }
      if (dirty & 1) {
        attr(div, "disabled", ctx[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_1$m(ctx) {
  let t_value = T("Mark as unread") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$R(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      tabindex: "-1",
      $$slots: { default: [create_default_slot_1$m] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", ctx[2]);
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 32) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_fragment$1Q(ctx) {
  let menu;
  let current;
  menu = new Menu$1({
    props: {
      $$slots: {
        default: [create_default_slot$R],
        action: [
          create_action_slot$b,
          ({ onClick }) => ({ 4: onClick }),
          ({ onClick }) => onClick ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 51) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1N($$self, $$props, $$invalidate) {
  let { disabled: disabled2 = false } = $$props;
  let { sieves } = $$props;
  const click_handler = () => sieves.markAsRead(false);
  const click_handler_1 = () => !disabled2 && sieves.markAsRead();
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(0, disabled2 = $$props2.disabled);
    if ("sieves" in $$props2)
      $$invalidate(1, sieves = $$props2.sieves);
  };
  return [disabled2, sieves, click_handler, click_handler_1];
}
class MarkSieveReadMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1N, create_fragment$1Q, safe_not_equal, { disabled: 0, sieves: 1 });
  }
}
function get_each_context$u(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_action_slot$a(ctx) {
  let button;
  let i2;
  let t;
  let span;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t = space();
      span = element("span");
      attr(i2, "class", "fa fa-tags");
      attr(span, "class", "caret");
      attr(button, "class", "btn btn-default");
      button.disabled = button_disabled_value = ctx[0].length === 0;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t);
      append(button, span);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[9]))
            ctx[9].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && button_disabled_value !== (button_disabled_value = ctx[0].length === 0)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$l(ctx) {
  let t0_value = ctx[6].get("name") + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[6].get("name") + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_each_block$u(key_1, ctx) {
  let first;
  let menuitemwithpermissions;
  let current;
  function click_handler() {
    return ctx[5](ctx[6]);
  }
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_1$l] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", click_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(menuitemwithpermissions.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitemwithpermissions_changes = {};
      if (dirty & 1025) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot$Q(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[0].models;
  const get_key = (ctx2) => ctx2[6].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$u(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$u(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[0].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$u, each_1_anchor, get_each_context$u);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$1P(ctx) {
  let menu;
  let current;
  menu = new Menu$1({
    props: {
      showCaret: false,
      dropDownStyle: `overflow-y:auto;max-height:'+ ${window.$(window).height() - 120 + "px"}`,
      $$slots: {
        default: [create_default_slot$Q],
        action: [
          create_action_slot$a,
          ({ onClick }) => ({ 9: onClick }),
          ({ onClick }) => onClick ? 512 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 1537) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1M($$self, $$props, $$invalidate) {
  let $labels;
  let { sieves } = $$props;
  let { disabled: disabled2 = false } = $$props;
  const labels = getContext("labels");
  component_subscribe($$self, labels, (value) => $$invalidate(0, $labels = value));
  async function applyLabel(id2) {
    const models = sieves.getSelectedSieves();
    Msg.info("l_loading");
    try {
      for (let i2 = 0; i2 < models.length; i2++) {
        let model = models[i2];
        let tags = model.get("tags");
        if (tags) {
          if (tags.indexOf(id2) >= 0) {
            continue;
          }
          tags += "," + id2;
        } else {
          tags = id2;
        }
        await model.save("tags", tags, { patch: true });
      }
      Msg.reset();
    } catch (e) {
      Msg.error("e_req");
    }
  }
  const click_handler = (label) => applyLabel(label.id);
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(3, sieves = $$props2.sieves);
    if ("disabled" in $$props2)
      $$invalidate(4, disabled2 = $$props2.disabled);
  };
  return [$labels, labels, applyLabel, sieves, disabled2, click_handler];
}
class LabelListMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1M, create_fragment$1P, safe_not_equal, { sieves: 3, disabled: 4 });
  }
}
function create_if_block_1$B(ctx) {
  let div;
  let raw_value = ctx[4].helpText + "";
  return {
    c() {
      div = element("div");
      attr(div, "class", "alert alert-info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$U(ctx) {
  let div2;
  let div0;
  let input0;
  let t0;
  let label0;
  let t2;
  let div1;
  let input1;
  let t3;
  let label1;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(ctx[12][0]);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      input0 = element("input");
      t0 = space();
      label0 = element("label");
      label0.textContent = "Download Selected Sieves";
      t2 = space();
      div1 = element("div");
      input1 = element("input");
      t3 = space();
      label1 = element("label");
      label1.textContent = "Download All Sieves";
      attr(input0, "class", "form-check-input");
      attr(input0, "type", "radio");
      input0.__value = true;
      input0.value = input0.__value;
      attr(label0, "class", "form-check-label text-lg");
      attr(div0, "class", "form-check");
      attr(input1, "class", "form-check-input");
      attr(input1, "type", "radio");
      input1.__value = false;
      input1.value = input1.__value;
      attr(label1, "class", "form-check-label text-lg");
      attr(div1, "class", "form-check");
      attr(div2, "class", "ps-3");
      binding_group.p(input0, input1);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, input0);
      input0.checked = input0.__value === ctx[3];
      append(div0, t0);
      append(div0, label0);
      append(div2, t2);
      append(div2, div1);
      append(div1, input1);
      input1.checked = input1.__value === ctx[3];
      append(div1, t3);
      append(div1, label1);
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[11]),
          listen(input1, "change", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8) {
        input0.checked = input0.__value === ctx2[3];
      }
      if (dirty & 8) {
        input1.checked = input1.__value === ctx2[3];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$P(ctx) {
  let t0;
  let t1;
  let a;
  let t2;
  let textarea_1;
  let if_block0 = ctx[4].helpText && create_if_block_1$B(ctx);
  let if_block1 = ctx[5].length && create_if_block$U(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      a = element("a");
      t2 = space();
      textarea_1 = element("textarea");
      a.hidden = true;
      textarea_1.hidden = true;
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, a, anchor);
      ctx[14](a);
      insert(target, t2, anchor);
      insert(target, textarea_1, anchor);
      ctx[15](textarea_1);
    },
    p(ctx2, dirty) {
      if (ctx2[4].helpText)
        if_block0.p(ctx2, dirty);
      if (ctx2[5].length)
        if_block1.p(ctx2, dirty);
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(a);
      ctx[14](null);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(textarea_1);
      ctx[15](null);
    }
  };
}
function create_header_slot$b(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `Export - ${ctx[4].title}`;
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_catch_block$e(ctx) {
  return { c: noop, m: noop, d: noop };
}
function create_then_block$e(ctx) {
  let t;
  return {
    c() {
      t = text("Download");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block$e(ctx) {
  let div;
  let t1;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="sr-only">Loading...</span>`;
      t1 = text("\n        Downloading...");
      attr(div, "class", "spinner-border text-light spinner-border-sm");
      attr(div, "role", "status");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
    }
  };
}
function create_buttons_slot$2(ctx) {
  let button;
  let promise;
  let mounted;
  let dispose;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$e,
    then: create_then_block$e,
    catch: create_catch_block$e
  };
  handle_promise(promise = ctx[2], info);
  return {
    c() {
      button = element("button");
      info.block.c();
      attr(button, "class", "btn btn-primary btn-md");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      info.block.m(button, info.anchor = null);
      info.mount = () => button;
      info.anchor = null;
      if (!mounted) {
        dispose = listen(button, "click", ctx[10]);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      dirty & 4 && promise !== (promise = ctx[2]) && handle_promise(promise, info);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      info.block.d();
      info.token = null;
      info = null;
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1O(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      $$slots: {
        buttons: [create_buttons_slot$2],
        header: [create_header_slot$b],
        default: [create_default_slot$P]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[7]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 1073741839) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
const limit = 5;
function instance$1L($$self, $$props, $$invalidate) {
  let { format: format$1 } = $$props;
  let { sieves } = $$props;
  const labels = getContext("labels");
  const FORMATS = {
    json: {
      type: "json",
      title: "JSON",
      fields: [
        "name",
        "uri",
        "config",
        "tags",
        "content_type",
        "state",
        "rule_id",
        "schedule",
        "ts",
        "datasource_id"
      ],
      helpText: `
                You can import the exported monitors later.<br>
                Note: Actions are not exported. You can create actions for all monitors while importing them.<br>
                <a href="https://distill.io/docs/web-monitor/how-export-and-import-monitors/" target="_blank" rel="noopener">Learn More</a>
              `
    },
    csv: {
      type: "csv",
      title: "CSV",
      fields: [
        "id",
        "uri",
        "name",
        "tags",
        "content_type",
        "text",
        "err",
        "ts",
        "ts_mod",
        "datasource_id"
      ],
      helpText: `
                If you want to import monitors later, we recommend exporting as JSON.<br>
                <a href="https://distill.io/docs/web-monitor/how-export-and-import-monitors/" target="_blank" rel="noopener">Learn More</a>
                `,
      columnHeaders: [
        "Name",
        "URL",
        "Labels",
        "Content Type",
        "Created On",
        "Changed On",
        "Text",
        "Error?",
        "DatasourceID?"
      ]
    }
  };
  const formatOpts = FORMATS[format$1];
  const dispatch = createEventDispatcher();
  let textarea;
  let downloadHref;
  let exportContent;
  let fileUrl;
  let downloadPromise = Promise.resolve();
  let sieveData = [];
  let offset = 0;
  let downloadSelected = true;
  let selectedSieveIds = sieves.getSelectedSieveIds();
  async function downloadSieves() {
    try {
      if (!exportContent) {
        exportContent = await createContent();
      }
      await downloadContent(exportContent);
      Msg.info("Exported successfully");
      closeModal();
    } catch (e) {
      console.error(e);
      Msg.error("Error while exporting, Please try again later");
    }
  }
  async function createContent() {
    offset = 0;
    await fetchSieveData();
    if (format$1 === "json") {
      return await createJSONContent();
    } else if (format$1 === "csv") {
      return await createCSVContent();
    }
  }
  async function createJSONContent() {
    let data = [];
    for (let i2 = 0, len = sieveData.length; i2 < len; i2 += 5) {
      data = data.concat(await Promise.all(sieveData.slice(i2, i2 + 5).map(async (sieve) => {
        if (sieve.rule_id) {
          sieve.rule = await fetchRules(sieve);
        }
        if (typeof sieve.tags === "string") {
          sieve.tags = getTags(sieve.tags);
        }
        ["id", "rule_id", "ts_mod", "_state"].forEach((key) => {
          delete sieve[key];
        });
        return sieve;
      })));
    }
    return JSON.stringify({ client: Supports.agents, data });
  }
  function createCSVContent() {
    const data = sieveData.map((sieve) => {
      let tags = sieve.tags;
      if (typeof tags === "string") {
        tags = getTags(tags).join(",");
      }
      return [
        sieve.name,
        sieve.uri,
        tags || "",
        sieve.content_type,
        sieve.ts,
        sieve.ts_mod,
        sieve.text,
        sieve.err || "",
        sieve.datasource_id || ""
      ];
    });
    return Papa.unparse([FORMATS.csv.columnHeaders, ...data]);
  }
  async function fetchRules(sieve) {
    try {
      return (await Api.api(`/rules/${sieve.rule_id}`, "GET", { _opt: { only: ["config"] } })).config;
    } catch (err) {
      console.error("error importing rule", err);
    }
  }
  function getTags(tagsStr = "") {
    return tagsStr.split(",").map((id2) => {
      const tag = labels.get(id2);
      if (tag) {
        return tag.get("name");
      }
    }).filter((tag) => tag);
  }
  function downloadContent(content) {
    const blob = new Blob([content], { type: "text/plain" });
    fileUrl = URL.createObjectURL(blob);
    $$invalidate(1, downloadHref.href = fileUrl, downloadHref);
    $$invalidate(1, downloadHref.download = `export - ${format(new Date(), "hh-mm_yyyy-MM-dd")}.${formatOpts.type}`, downloadHref);
    downloadHref.click();
  }
  async function fetchSieveData() {
    const { fields } = formatOpts;
    const opts = {
      "state.in": [40, 45],
      _opt: {
        order: ["ts"],
        limit,
        offset,
        only: fields
      }
    };
    if (selectedSieveIds.length && downloadSelected) {
      opts["id.in"] = selectedSieveIds;
    }
    const res = await Api.api("/sieves", "GET", opts);
    sieveData = sieveData.concat(res.data);
    offset += res.count;
    if (res.count === limit) {
      await fetchSieveData();
    }
  }
  function closeModal() {
    if (fileUrl) {
      URL.revokeObjectURL(fileUrl);
    }
    dispatch("close");
  }
  const $$binding_groups = [[]];
  const click_handler = () => $$invalidate(2, downloadPromise = downloadSieves());
  function input0_change_handler() {
    downloadSelected = this.__value;
    $$invalidate(3, downloadSelected);
  }
  function input1_change_handler() {
    downloadSelected = this.__value;
    $$invalidate(3, downloadSelected);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      downloadHref = $$value;
      $$invalidate(1, downloadHref);
    });
  }
  function textarea_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      textarea = $$value;
      $$invalidate(0, textarea);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("format" in $$props2)
      $$invalidate(8, format$1 = $$props2.format);
    if ("sieves" in $$props2)
      $$invalidate(9, sieves = $$props2.sieves);
  };
  return [
    textarea,
    downloadHref,
    downloadPromise,
    downloadSelected,
    formatOpts,
    selectedSieveIds,
    downloadSieves,
    closeModal,
    format$1,
    sieves,
    click_handler,
    input0_change_handler,
    $$binding_groups,
    input1_change_handler,
    a_binding,
    textarea_1_binding
  ];
}
class ExportModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1L, create_fragment$1O, safe_not_equal, { format: 8, sieves: 9 });
  }
}
function create_action_slot$9(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-bars"></i> 
        <span class="caret"></span>`;
      attr(button, "class", "btn btn-default dropdown-toggle");
      attr(button, "data-bs-toggle", "dropdown");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[15]))
            ctx[15].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_8$1(ctx) {
  let t;
  return {
    c() {
      t = text("JSON");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7$2(ctx) {
  let t;
  return {
    c() {
      t = text("CSV");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$2(ctx) {
  let t_value = T("Crawlers") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$3(ctx) {
  let t_value = T("Macros") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$3(ctx) {
  let t_value = T("Profiles") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let t_value = T("Proxies") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$6(ctx) {
  let t_value = T("Global Actions") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$k(ctx) {
  let t_value = T("Global Conditions") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$O(ctx) {
  let li2;
  let a0;
  let t1;
  let ul0;
  let li0;
  let a1;
  let t3;
  let li1;
  let a2;
  let t5;
  let li3;
  let a3;
  let t7;
  let ul1;
  let menuitemwithpermissions0;
  let t8;
  let menuitemwithpermissions1;
  let t9;
  let menuitemwithpermissions2;
  let t10;
  let menuitemwithpermissions3;
  let t11;
  let menuitemwithpermissions4;
  let t12;
  let menuitemwithpermissions5;
  let t13;
  let li4;
  let t14;
  let menuitemwithpermissions6;
  let t15;
  let menuitemwithpermissions7;
  let current;
  let mounted;
  let dispose;
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/import/json/`,
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/import/csv/`,
      $$slots: { default: [create_default_slot_7$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions2 = new MenuItemWithPermissions({
    props: {
      href: `#/u/${ctx[1]}/crawlers/`,
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions3 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/macros/`,
      $$slots: { default: [create_default_slot_5$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions4 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/profiles/`,
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions5 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/proxies/`,
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions6 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions6.$on("click", ctx[10]);
  menuitemwithpermissions7 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_1$k] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions7.$on("click", ctx[11]);
  return {
    c() {
      li2 = element("li");
      a0 = element("a");
      a0.textContent = `${T("a_export")}`;
      t1 = space();
      ul0 = element("ul");
      li0 = element("li");
      a1 = element("a");
      a1.textContent = "JSON";
      t3 = space();
      li1 = element("li");
      a2 = element("a");
      a2.textContent = "CSV";
      t5 = space();
      li3 = element("li");
      a3 = element("a");
      a3.textContent = `${T("a_import")}`;
      t7 = space();
      ul1 = element("ul");
      create_component(menuitemwithpermissions0.$$.fragment);
      t8 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      t9 = space();
      create_component(menuitemwithpermissions2.$$.fragment);
      t10 = space();
      create_component(menuitemwithpermissions3.$$.fragment);
      t11 = space();
      create_component(menuitemwithpermissions4.$$.fragment);
      t12 = space();
      create_component(menuitemwithpermissions5.$$.fragment);
      t13 = space();
      li4 = element("li");
      t14 = space();
      create_component(menuitemwithpermissions6.$$.fragment);
      t15 = space();
      create_component(menuitemwithpermissions7.$$.fragment);
      attr(a0, "class", "dropdown-item");
      attr(a1, "class", "dropdown-item");
      attr(a2, "class", "dropdown-item");
      attr(ul0, "class", "dropdown-menu");
      attr(li2, "class", "dropdown-submenu pe-2");
      attr(a3, "class", "dropdown-item");
      attr(ul1, "class", "dropdown-menu");
      attr(li3, "class", "dropdown-submenu pe-2");
      attr(li4, "class", "divider");
    },
    m(target, anchor) {
      insert(target, li2, anchor);
      append(li2, a0);
      append(li2, t1);
      append(li2, ul0);
      append(ul0, li0);
      append(li0, a1);
      append(ul0, t3);
      append(ul0, li1);
      append(li1, a2);
      insert(target, t5, anchor);
      insert(target, li3, anchor);
      append(li3, a3);
      append(li3, t7);
      append(li3, ul1);
      mount_component(menuitemwithpermissions0, ul1, null);
      append(ul1, t8);
      mount_component(menuitemwithpermissions1, ul1, null);
      insert(target, t9, anchor);
      mount_component(menuitemwithpermissions2, target, anchor);
      insert(target, t10, anchor);
      mount_component(menuitemwithpermissions3, target, anchor);
      insert(target, t11, anchor);
      mount_component(menuitemwithpermissions4, target, anchor);
      insert(target, t12, anchor);
      mount_component(menuitemwithpermissions5, target, anchor);
      insert(target, t13, anchor);
      insert(target, li4, anchor);
      insert(target, t14, anchor);
      mount_component(menuitemwithpermissions6, target, anchor);
      insert(target, t15, anchor);
      mount_component(menuitemwithpermissions7, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a1, "click", ctx[8]),
          listen(a2, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions0_changes = {};
      if (dirty & 2)
        menuitemwithpermissions0_changes.href = `#/w/${ctx2[1]}/import/json/`;
      if (dirty & 65536) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 2)
        menuitemwithpermissions1_changes.href = `#/w/${ctx2[1]}/import/csv/`;
      if (dirty & 65536) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
      const menuitemwithpermissions2_changes = {};
      if (dirty & 2)
        menuitemwithpermissions2_changes.href = `#/u/${ctx2[1]}/crawlers/`;
      if (dirty & 65536) {
        menuitemwithpermissions2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions2.$set(menuitemwithpermissions2_changes);
      const menuitemwithpermissions3_changes = {};
      if (dirty & 2)
        menuitemwithpermissions3_changes.href = `#/w/${ctx2[1]}/macros/`;
      if (dirty & 65536) {
        menuitemwithpermissions3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions3.$set(menuitemwithpermissions3_changes);
      const menuitemwithpermissions4_changes = {};
      if (dirty & 2)
        menuitemwithpermissions4_changes.href = `#/w/${ctx2[1]}/profiles/`;
      if (dirty & 65536) {
        menuitemwithpermissions4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions4.$set(menuitemwithpermissions4_changes);
      const menuitemwithpermissions5_changes = {};
      if (dirty & 2)
        menuitemwithpermissions5_changes.href = `#/w/${ctx2[1]}/proxies/`;
      if (dirty & 65536) {
        menuitemwithpermissions5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions5.$set(menuitemwithpermissions5_changes);
      const menuitemwithpermissions6_changes = {};
      if (dirty & 65536) {
        menuitemwithpermissions6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions6.$set(menuitemwithpermissions6_changes);
      const menuitemwithpermissions7_changes = {};
      if (dirty & 65536) {
        menuitemwithpermissions7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions7.$set(menuitemwithpermissions7_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      transition_in(menuitemwithpermissions2.$$.fragment, local);
      transition_in(menuitemwithpermissions3.$$.fragment, local);
      transition_in(menuitemwithpermissions4.$$.fragment, local);
      transition_in(menuitemwithpermissions5.$$.fragment, local);
      transition_in(menuitemwithpermissions6.$$.fragment, local);
      transition_in(menuitemwithpermissions7.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      transition_out(menuitemwithpermissions2.$$.fragment, local);
      transition_out(menuitemwithpermissions3.$$.fragment, local);
      transition_out(menuitemwithpermissions4.$$.fragment, local);
      transition_out(menuitemwithpermissions5.$$.fragment, local);
      transition_out(menuitemwithpermissions6.$$.fragment, local);
      transition_out(menuitemwithpermissions7.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(li3);
      destroy_component(menuitemwithpermissions0);
      destroy_component(menuitemwithpermissions1);
      if (detaching)
        detach(t9);
      destroy_component(menuitemwithpermissions2, detaching);
      if (detaching)
        detach(t10);
      destroy_component(menuitemwithpermissions3, detaching);
      if (detaching)
        detach(t11);
      destroy_component(menuitemwithpermissions4, detaching);
      if (detaching)
        detach(t12);
      destroy_component(menuitemwithpermissions5, detaching);
      if (detaching)
        detach(t13);
      if (detaching)
        detach(li4);
      if (detaching)
        detach(t14);
      destroy_component(menuitemwithpermissions6, detaching);
      if (detaching)
        detach(t15);
      destroy_component(menuitemwithpermissions7, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$q(ctx) {
  let exportmodal;
  let current;
  exportmodal = new ExportModal({
    props: {
      sieves: ctx[0],
      format: ctx[5]
    }
  });
  exportmodal.$on("close", ctx[12]);
  return {
    c() {
      create_component(exportmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exportmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exportmodal_changes = {};
      if (dirty & 1)
        exportmodal_changes.sieves = ctx2[0];
      if (dirty & 32)
        exportmodal_changes.format = ctx2[5];
      exportmodal.$set(exportmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(exportmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exportmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exportmodal, detaching);
    }
  };
}
function create_if_block_1$A(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[13]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block$T(ctx) {
  let globalruleeditormodal;
  let current;
  globalruleeditormodal = new GlobalRuleEditorModal({});
  globalruleeditormodal.$on("close", ctx[14]);
  return {
    c() {
      create_component(globalruleeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalruleeditormodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(globalruleeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalruleeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalruleeditormodal, detaching);
    }
  };
}
function create_fragment$1N(ctx) {
  let menu;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  menu = new Menu$1({
    props: {
      $$slots: {
        default: [create_default_slot$O],
        action: [
          create_action_slot$9,
          ({ onClick }) => ({ 15: onClick }),
          ({ onClick }) => onClick ? 32768 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[4] && create_if_block_2$q(ctx);
  let if_block1 = ctx[2] && create_if_block_1$A(ctx);
  let if_block2 = ctx[3] && create_if_block$T(ctx);
  return {
    c() {
      create_component(menu.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 98366) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$q(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$A(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$T(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance$1K($$self, $$props, $$invalidate) {
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(7, $route = $$value));
  let { sieves } = $$props;
  const fileFormats = { JSON: "json", CSV: "csv" };
  let team;
  let showGlobalActionEditor2 = false;
  let showGlobalRuleEditor2 = false;
  let showExportModal = false;
  let exportFormat = fileFormats.JSON;
  const click_handler = () => {
    $$invalidate(4, showExportModal = true);
    $$invalidate(5, exportFormat = fileFormats.JSON);
  };
  const click_handler_1 = () => {
    $$invalidate(4, showExportModal = true);
    $$invalidate(5, exportFormat = fileFormats.CSV);
  };
  const click_handler_2 = () => $$invalidate(2, showGlobalActionEditor2 = true);
  const click_handler_3 = () => $$invalidate(3, showGlobalRuleEditor2 = true);
  const close_handler = () => $$invalidate(4, showExportModal = false);
  const close_handler_1 = () => $$invalidate(2, showGlobalActionEditor2 = false);
  const close_handler_2 = () => $$invalidate(3, showGlobalRuleEditor2 = false);
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(0, sieves = $$props2.sieves);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(1, { team } = $route, team);
    }
  };
  return [
    sieves,
    team,
    showGlobalActionEditor2,
    showGlobalRuleEditor2,
    showExportModal,
    exportFormat,
    fileFormats,
    $route,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    close_handler,
    close_handler_1,
    close_handler_2
  ];
}
class AdditionalOptionsMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1K, create_fragment$1N, safe_not_equal, { sieves: 0 });
  }
}
function create_default_slot$N(ctx) {
  let actionseditor;
  let current;
  let actionseditor_props = { sieve: ctx[1] };
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  ctx[4](actionseditor);
  return {
    c() {
      create_component(actionseditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actionseditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actionseditor_changes = {};
      actionseditor.$set(actionseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[4](null);
      destroy_component(actionseditor, detaching);
    }
  };
}
function create_fragment$1M(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: false,
      title: "Add Actions - Batch Editor",
      onSave: ctx[2],
      $$slots: { default: [create_default_slot$N] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[5]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 257) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$1J($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  const sieve = new Model$2.Sieve();
  let actionEditor;
  function close() {
    dispatch("close");
  }
  async function save() {
    const ids = sieves.getSelectedSieveIds();
    actionEditor.migrateChanges();
    const actions = actionEditor.getPosts();
    try {
      for (let i2 = 0; i2 < actions.length; i2 += 1) {
        const doc = actions[i2].toJSON();
        await Api.api("/batch/sieves/actions", "POST", { ...doc, ids });
      }
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function actionseditor_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionEditor = $$value;
      $$invalidate(0, actionEditor);
    });
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(3, sieves = $$props2.sieves);
  };
  return [actionEditor, sieve, save, sieves, actionseditor_binding, close_handler];
}
class BatchActionsEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1J, create_fragment$1M, safe_not_equal, { sieves: 3 });
  }
}
function create_default_slot$M(ctx) {
  let label;
  return {
    c() {
      label = element("label");
      label.textContent = "This action will remove all actions for selected monitors. Remove all actions?";
    },
    m(target, anchor) {
      insert(target, label, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_buttons_slot$1(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "Remove";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-danger");
      attr(div, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[0]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1L(ctx) {
  let confirmmodal;
  let current;
  confirmmodal = new ConfirmModal({
    props: {
      title: "Remove Actions - Batch Edit",
      $$slots: {
        buttons: [create_buttons_slot$1],
        default: [create_default_slot$M]
      },
      $$scope: { ctx }
    }
  });
  confirmmodal.$on("close", ctx[2]);
  return {
    c() {
      create_component(confirmmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmmodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const confirmmodal_changes = {};
      if (dirty & 32) {
        confirmmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmmodal.$set(confirmmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmmodal, detaching);
    }
  };
}
function instance$1I($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  function close() {
    dispatch("close");
  }
  async function remove() {
    const ids = sieves.getSelectedSieveIds();
    try {
      await Api.api("/batch/sieves/actions", "PUT", { ids, state: C$2.STATE_DEL });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(1, sieves = $$props2.sieves);
  };
  return [remove, sieves, close_handler];
}
class BatchRemoveActionsModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1I, create_fragment$1L, safe_not_equal, { sieves: 1 });
  }
}
function create_fragment$1K(ctx) {
  let backbonewrapper;
  let updating_renderedView;
  let current;
  const backbonewrapper_spread_levels = [{ view: JSONEdit }, ctx[1]];
  function backbonewrapper_renderedView_binding(value) {
    ctx[2](value);
  }
  let backbonewrapper_props = {};
  for (let i2 = 0; i2 < backbonewrapper_spread_levels.length; i2 += 1) {
    backbonewrapper_props = assign$1(backbonewrapper_props, backbonewrapper_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    backbonewrapper_props.renderedView = ctx[0];
  }
  backbonewrapper = new BackboneWrapper({ props: backbonewrapper_props });
  binding_callbacks.push(() => bind$2(backbonewrapper, "renderedView", backbonewrapper_renderedView_binding));
  return {
    c() {
      create_component(backbonewrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(backbonewrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const backbonewrapper_changes = dirty & 2 ? get_spread_update(backbonewrapper_spread_levels, [
        dirty & 0 && { view: JSONEdit },
        dirty & 2 && get_spread_object(ctx2[1])
      ]) : {};
      if (!updating_renderedView && dirty & 1) {
        updating_renderedView = true;
        backbonewrapper_changes.renderedView = ctx2[0];
        add_flush_callback(() => updating_renderedView = false);
      }
      backbonewrapper.$set(backbonewrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(backbonewrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(backbonewrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(backbonewrapper, detaching);
    }
  };
}
function instance$1H($$self, $$props, $$invalidate) {
  const omit_props_names = ["configEditor"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { configEditor } = $$props;
  function backbonewrapper_renderedView_binding(value) {
    configEditor = value;
    $$invalidate(0, configEditor);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("configEditor" in $$new_props)
      $$invalidate(0, configEditor = $$new_props.configEditor);
  };
  return [configEditor, $$restProps, backbonewrapper_renderedView_binding];
}
class ConfigEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1H, create_fragment$1K, safe_not_equal, { configEditor: 0 });
  }
}
function create_default_slot$L(ctx) {
  let configeditor;
  let updating_configEditor;
  let current;
  function configeditor_configEditor_binding(value) {
    ctx[5](value);
  }
  let configeditor_props = {
    param: ctx[1],
    model: ctx[2]
  };
  if (ctx[0] !== void 0) {
    configeditor_props.configEditor = ctx[0];
  }
  configeditor = new ConfigEditor({ props: configeditor_props });
  binding_callbacks.push(() => bind$2(configeditor, "configEditor", configeditor_configEditor_binding));
  return {
    c() {
      create_component(configeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(configeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const configeditor_changes = {};
      if (!updating_configEditor && dirty & 1) {
        updating_configEditor = true;
        configeditor_changes.configEditor = ctx2[0];
        add_flush_callback(() => updating_configEditor = false);
      }
      configeditor.$set(configeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(configeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(configeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(configeditor, detaching);
    }
  };
}
function create_fragment$1J(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Config - Batch Edit",
      onSave: ctx[3],
      $$slots: { default: [create_default_slot$L] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[6]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 513) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$1G($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  const param = {
    label: "l_selection_config",
    must: false,
    name: "config",
    type: "json"
  };
  const model = new Backbone.Model({
    config: sieves.getSelectedSieves()[0].get("config").clone()
  });
  let configEditor;
  function close() {
    dispatch("close");
  }
  async function save() {
    Msg.info("l_loading");
    const ids = sieves.getSelectedSieveIds();
    try {
      await Api.api("/batch/sieves", "PUT", {
        ids,
        config: JSON.stringify(model.get("config"))
      });
      Msg.reset();
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function configeditor_configEditor_binding(value) {
    configEditor = value;
    $$invalidate(0, configEditor);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(4, sieves = $$props2.sieves);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (configEditor) {
        configEditor.$el.find("textarea").css("height", 300);
      }
    }
  };
  return [
    configEditor,
    param,
    model,
    save,
    sieves,
    configeditor_configEditor_binding,
    close_handler
  ];
}
class BatchConfigEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1G, create_fragment$1J, safe_not_equal, { sieves: 4 });
  }
}
function create_default_slot$K(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "m-[5px]");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[3](div);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[3](null);
    }
  };
}
function create_fragment$1I(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: false,
      title: "Device - Batch Editor",
      onSave: ctx[1],
      $$slots: { default: [create_default_slot$K] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[4]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 1025) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$1F($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  let el;
  let model;
  let clientSelector;
  function render2() {
    const selectedModels = sieves.getSelectedSieves();
    if (selectedModels.length == 0) {
      return;
    }
    const modelOne = selectedModels[0];
    model = new Model$2.Sieve({
      content_type: C$2.TYPE_HTML,
      client_id: modelOne.get("client_id")
    });
    clientSelector = new ViewClients.ClientSelector({ model });
    el.appendChild(clientSelector.el);
  }
  function close() {
    dispatch("close");
  }
  async function save() {
    try {
      const ids = sieves.getSelectedSieveIds();
      const client_id = model.get("client_id");
      const proxy_id = model.get("proxy_id");
      const session_id = model.get("session_id");
      await Api.api("/batch/sieves", "PUT", { ids, client_id, proxy_id, session_id });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(2, sieves = $$props2.sieves);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (el) {
        render2();
      }
    }
  };
  return [el, save, sieves, div_binding, close_handler];
}
class BatchClientSelectorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1F, create_fragment$1I, safe_not_equal, { sieves: 2 });
  }
}
function create_default_slot$J(ctx) {
  let scheduleeditor;
  let current;
  scheduleeditor = new ScheduleEditor({
    props: { formModel: ctx[0] }
  });
  return {
    c() {
      create_component(scheduleeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scheduleeditor, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(scheduleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scheduleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scheduleeditor, detaching);
    }
  };
}
function create_fragment$1H(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: false,
      title: "Schedule - Batch Editor",
      onSave: ctx[1],
      $$slots: { default: [create_default_slot$J] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[3]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 128) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$1E($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  let model = new Model$2.Sieve({ schedule: new Model$2.Schedule() });
  const formModel = new SieveFormModel(model);
  function close() {
    dispatch("close");
  }
  async function save() {
    const ids = sieves.getSelectedSieveIds();
    try {
      await Api.api("/batch/sieves", "PUT", {
        ids,
        schedule: JSON.stringify(model.get("schedule"))
      });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(2, sieves = $$props2.sieves);
  };
  return [formModel, save, sieves, close_handler];
}
class BatchScheduleEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1E, create_fragment$1H, safe_not_equal, { sieves: 2 });
  }
}
function create_default_slot$I(ctx) {
  let strong;
  let t0;
  let t1;
  let t2_value = ctx[1] === 1 ? "monitor" : "monitors";
  let t2;
  let t3;
  let t4_value = ctx[0] ? "ON" : "OFF";
  let t4;
  let t5;
  return {
    c() {
      strong = element("strong");
      t0 = text(ctx[1]);
      t1 = space();
      t2 = text(t2_value);
      t3 = text(" will be switched ");
      t4 = text(t4_value);
      t5 = text(".");
    },
    m(target, anchor) {
      insert(target, strong, anchor);
      append(strong, t0);
      append(strong, t1);
      append(strong, t2);
      append(strong, t3);
      append(strong, t4);
      append(strong, t5);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t4_value !== (t4_value = ctx2[0] ? "ON" : "OFF"))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(strong);
    }
  };
}
function create_fragment$1G(ctx) {
  let confirmmodal;
  let current;
  confirmmodal = new ConfirmModal({
    props: {
      title: ctx[0] ? "Switch On Monitors - Batch Edit" : "Switch Off Monitors - Batch Edit",
      $$slots: { default: [create_default_slot$I] },
      $$scope: { ctx }
    }
  });
  confirmmodal.$on("click", ctx[2]);
  confirmmodal.$on("close", ctx[4]);
  return {
    c() {
      create_component(confirmmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmmodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const confirmmodal_changes = {};
      if (dirty & 1)
        confirmmodal_changes.title = ctx2[0] ? "Switch On Monitors - Batch Edit" : "Switch Off Monitors - Batch Edit";
      if (dirty & 257) {
        confirmmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmmodal.$set(confirmmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmmodal, detaching);
    }
  };
}
function instance$1D($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  let { switchOn } = $$props;
  const dispatch = createEventDispatcher();
  const ids = sieves.getSelectedSieveIds();
  const noSelected = ids == null ? void 0 : ids.length;
  function close() {
    dispatch("close");
  }
  async function updateSieveState() {
    try {
      await Api.api("/batch/sieves", "PUT", {
        ids,
        state: switchOn ? C$2.STATE_READY : C$2.STATE_PAUSED
      });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(3, sieves = $$props2.sieves);
    if ("switchOn" in $$props2)
      $$invalidate(0, switchOn = $$props2.switchOn);
  };
  return [switchOn, noSelected, updateSieveState, sieves, close_handler];
}
class BatchSieveStateEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1D, create_fragment$1G, safe_not_equal, { sieves: 3, switchOn: 0 });
  }
}
function create_action_slot$8(ctx) {
  let button;
  let t0_value = T("a_bulk_edit") + "";
  let t0;
  let t1;
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      attr(span, "class", "caret");
      attr(button, "class", "btn btn-default dropdown-toggle");
      attr(button, "data-bs-toggle", "dropdown");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, span);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[23]))
            ctx[23].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$D(ctx) {
  let li1;
  let a;
  let t1;
  let ul;
  let menuitemwithpermissions0;
  let t2;
  let li0;
  let t3;
  let menuitemwithpermissions1;
  let current;
  let mounted;
  let dispose;
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions0.$on("click", ctx[9]);
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      style: "color:red;",
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1.$on("click", ctx[10]);
  return {
    c() {
      li1 = element("li");
      a = element("a");
      a.textContent = "Actions";
      t1 = space();
      ul = element("ul");
      create_component(menuitemwithpermissions0.$$.fragment);
      t2 = space();
      li0 = element("li");
      t3 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      attr(a, "class", "dropdown-item");
      attr(li0, "class", "divider");
      attr(ul, "class", "dropdown-menu");
      attr(li1, "class", "dropdown-submenu pe-2");
      attr(li1, "role", "menu");
    },
    m(target, anchor) {
      insert(target, li1, anchor);
      append(li1, a);
      append(li1, t1);
      append(li1, ul);
      mount_component(menuitemwithpermissions0, ul, null);
      append(ul, t2);
      append(ul, li0);
      append(ul, t3);
      mount_component(menuitemwithpermissions1, ul, null);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[8]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions0_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li1);
      destroy_component(menuitemwithpermissions0);
      destroy_component(menuitemwithpermissions1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7$3(ctx) {
  let li;
  let a;
  return {
    c() {
      li = element("li");
      a = element("a");
      a.textContent = `${T("Sign in")}`;
      attr(a, "href", "/ui/settings.html#general");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let t;
  return {
    c() {
      t = text("Add");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$1(ctx) {
  let t;
  return {
    c() {
      t = text("Remove All");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let t_value = T("Config") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let t_value = T("l_device") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let t_value = T("l_schedule") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let t_value = T("Switch ON") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$j(ctx) {
  let t_value = T("Switch OFF") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$H(ctx) {
  let current_block_type_index;
  let if_block;
  let t0;
  let menuitemwithpermissions0;
  let t1;
  let menuitemwithpermissions1;
  let t2;
  let menuitemwithpermissions2;
  let t3;
  let menuitemwithpermissions3;
  let t4;
  let menuitemwithpermissions4;
  let current;
  const if_block_creators = [create_if_block_7$3, create_else_block$D];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!USER.id)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type();
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions0.$on("click", ctx[11]);
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1.$on("click", ctx[12]);
  menuitemwithpermissions2 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions2.$on("click", ctx[13]);
  menuitemwithpermissions3 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions3.$on("click", ctx[14]);
  menuitemwithpermissions4 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_1$j] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions4.$on("click", ctx[15]);
  return {
    c() {
      if_block.c();
      t0 = space();
      create_component(menuitemwithpermissions0.$$.fragment);
      t1 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      t2 = space();
      create_component(menuitemwithpermissions2.$$.fragment);
      t3 = space();
      create_component(menuitemwithpermissions3.$$.fragment);
      t4 = space();
      create_component(menuitemwithpermissions4.$$.fragment);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitemwithpermissions0, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitemwithpermissions1, target, anchor);
      insert(target, t2, anchor);
      mount_component(menuitemwithpermissions2, target, anchor);
      insert(target, t3, anchor);
      mount_component(menuitemwithpermissions3, target, anchor);
      insert(target, t4, anchor);
      mount_component(menuitemwithpermissions4, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
      const menuitemwithpermissions0_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
      const menuitemwithpermissions2_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions2.$set(menuitemwithpermissions2_changes);
      const menuitemwithpermissions3_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions3.$set(menuitemwithpermissions3_changes);
      const menuitemwithpermissions4_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions4.$set(menuitemwithpermissions4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      transition_in(menuitemwithpermissions2.$$.fragment, local);
      transition_in(menuitemwithpermissions3.$$.fragment, local);
      transition_in(menuitemwithpermissions4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      transition_out(menuitemwithpermissions2.$$.fragment, local);
      transition_out(menuitemwithpermissions3.$$.fragment, local);
      transition_out(menuitemwithpermissions4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitemwithpermissions0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitemwithpermissions1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(menuitemwithpermissions2, detaching);
      if (detaching)
        detach(t3);
      destroy_component(menuitemwithpermissions3, detaching);
      if (detaching)
        detach(t4);
      destroy_component(menuitemwithpermissions4, detaching);
    }
  };
}
function create_if_block_6$5(ctx) {
  let batchactionseditormodal;
  let current;
  batchactionseditormodal = new BatchActionsEditorModal({ props: { sieves: ctx[0] } });
  batchactionseditormodal.$on("close", ctx[16]);
  return {
    c() {
      create_component(batchactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchactionseditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchactionseditormodal_changes = {};
      if (dirty & 1)
        batchactionseditormodal_changes.sieves = ctx2[0];
      batchactionseditormodal.$set(batchactionseditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchactionseditormodal, detaching);
    }
  };
}
function create_if_block_5$8(ctx) {
  let batchremoveactionsmodal;
  let current;
  batchremoveactionsmodal = new BatchRemoveActionsModal({ props: { sieves: ctx[0] } });
  batchremoveactionsmodal.$on("close", ctx[17]);
  return {
    c() {
      create_component(batchremoveactionsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchremoveactionsmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchremoveactionsmodal_changes = {};
      if (dirty & 1)
        batchremoveactionsmodal_changes.sieves = ctx2[0];
      batchremoveactionsmodal.$set(batchremoveactionsmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchremoveactionsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchremoveactionsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchremoveactionsmodal, detaching);
    }
  };
}
function create_if_block_4$e(ctx) {
  let batchconfigeditormodal;
  let current;
  batchconfigeditormodal = new BatchConfigEditorModal({ props: { sieves: ctx[0] } });
  batchconfigeditormodal.$on("close", ctx[18]);
  return {
    c() {
      create_component(batchconfigeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchconfigeditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchconfigeditormodal_changes = {};
      if (dirty & 1)
        batchconfigeditormodal_changes.sieves = ctx2[0];
      batchconfigeditormodal.$set(batchconfigeditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchconfigeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchconfigeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchconfigeditormodal, detaching);
    }
  };
}
function create_if_block_3$n(ctx) {
  let batchclientselectormodal;
  let current;
  batchclientselectormodal = new BatchClientSelectorModal({ props: { sieves: ctx[0] } });
  batchclientselectormodal.$on("close", ctx[19]);
  return {
    c() {
      create_component(batchclientselectormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchclientselectormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchclientselectormodal_changes = {};
      if (dirty & 1)
        batchclientselectormodal_changes.sieves = ctx2[0];
      batchclientselectormodal.$set(batchclientselectormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchclientselectormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchclientselectormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchclientselectormodal, detaching);
    }
  };
}
function create_if_block_2$p(ctx) {
  let batchscheduleeditormodal;
  let current;
  batchscheduleeditormodal = new BatchScheduleEditorModal({ props: { sieves: ctx[0] } });
  batchscheduleeditormodal.$on("close", ctx[20]);
  return {
    c() {
      create_component(batchscheduleeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchscheduleeditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchscheduleeditormodal_changes = {};
      if (dirty & 1)
        batchscheduleeditormodal_changes.sieves = ctx2[0];
      batchscheduleeditormodal.$set(batchscheduleeditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchscheduleeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchscheduleeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchscheduleeditormodal, detaching);
    }
  };
}
function create_if_block_1$z(ctx) {
  let batchsievestateeditormodal;
  let current;
  batchsievestateeditormodal = new BatchSieveStateEditorModal({
    props: {
      sieves: ctx[0],
      switchOn: true
    }
  });
  batchsievestateeditormodal.$on("close", ctx[21]);
  return {
    c() {
      create_component(batchsievestateeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchsievestateeditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchsievestateeditormodal_changes = {};
      if (dirty & 1)
        batchsievestateeditormodal_changes.sieves = ctx2[0];
      batchsievestateeditormodal.$set(batchsievestateeditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchsievestateeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchsievestateeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchsievestateeditormodal, detaching);
    }
  };
}
function create_if_block$S(ctx) {
  let batchsievestateeditormodal;
  let current;
  batchsievestateeditormodal = new BatchSieveStateEditorModal({
    props: {
      sieves: ctx[0],
      switchOn: false
    }
  });
  batchsievestateeditormodal.$on("close", ctx[22]);
  return {
    c() {
      create_component(batchsievestateeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchsievestateeditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchsievestateeditormodal_changes = {};
      if (dirty & 1)
        batchsievestateeditormodal_changes.sieves = ctx2[0];
      batchsievestateeditormodal.$set(batchsievestateeditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchsievestateeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchsievestateeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchsievestateeditormodal, detaching);
    }
  };
}
function create_fragment$1F(ctx) {
  let menu;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let if_block6_anchor;
  let current;
  menu = new Menu$1({
    props: {
      $$slots: {
        default: [create_default_slot$H],
        action: [
          create_action_slot$8,
          ({ onClick }) => ({ 23: onClick }),
          ({ onClick }) => onClick ? 8388608 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[1] && create_if_block_6$5(ctx);
  let if_block1 = ctx[2] && create_if_block_5$8(ctx);
  let if_block2 = ctx[3] && create_if_block_4$e(ctx);
  let if_block3 = ctx[4] && create_if_block_3$n(ctx);
  let if_block4 = ctx[5] && create_if_block_2$p(ctx);
  let if_block5 = ctx[6] && create_if_block_1$z(ctx);
  let if_block6 = ctx[7] && create_if_block$S(ctx);
  return {
    c() {
      create_component(menu.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert(target, t6, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert(target, if_block6_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 25166078) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5$8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4$e(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3$n(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t4.parentNode, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2$p(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t5.parentNode, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (ctx2[6]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1$z(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t6.parentNode, t6);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (ctx2[7]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block$S(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(t4);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach(t5);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach(t6);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach(if_block6_anchor);
    }
  };
}
function instance$1C($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  let showAddActionModal = false;
  let showRemoveActionModal = false;
  let showEditConfigModal = false;
  let showEditDevicesModal = false;
  let showEditScheduleModal = false;
  let showSieveOnModal = false;
  let showSieveOffModal = false;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = () => $$invalidate(1, showAddActionModal = true);
  const click_handler_2 = () => $$invalidate(2, showRemoveActionModal = true);
  const click_handler_3 = () => $$invalidate(3, showEditConfigModal = true);
  const click_handler_4 = () => $$invalidate(4, showEditDevicesModal = true);
  const click_handler_5 = () => $$invalidate(5, showEditScheduleModal = true);
  const click_handler_6 = () => $$invalidate(6, showSieveOnModal = true);
  const click_handler_7 = () => $$invalidate(7, showSieveOffModal = true);
  const close_handler = () => $$invalidate(1, showAddActionModal = false);
  const close_handler_1 = () => $$invalidate(2, showRemoveActionModal = false);
  const close_handler_2 = () => $$invalidate(3, showEditConfigModal = false);
  const close_handler_3 = () => $$invalidate(4, showEditDevicesModal = false);
  const close_handler_4 = () => $$invalidate(5, showEditScheduleModal = false);
  const close_handler_5 = () => $$invalidate(6, showSieveOnModal = false);
  const close_handler_6 = () => $$invalidate(7, showSieveOffModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(0, sieves = $$props2.sieves);
  };
  return [
    sieves,
    showAddActionModal,
    showRemoveActionModal,
    showEditConfigModal,
    showEditDevicesModal,
    showEditScheduleModal,
    showSieveOnModal,
    showSieveOffModal,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    close_handler,
    close_handler_1,
    close_handler_2,
    close_handler_3,
    close_handler_4,
    close_handler_5,
    close_handler_6
  ];
}
class BatchOptionsMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1C, create_fragment$1F, safe_not_equal, { sieves: 0 });
  }
}
function create_default_slot$G(ctx) {
  let div;
  let li0;
  let label0;
  let t2;
  let select0;
  let option0;
  let option1;
  let option2;
  let t6;
  let li1;
  let label1;
  let t9;
  let select1;
  let option3;
  let option4;
  let option5;
  let option6;
  let option7;
  let option8;
  let t16;
  let li2;
  let label2;
  let t19;
  let select2;
  let option9;
  let option10;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      li0 = element("li");
      label0 = element("label");
      label0.textContent = `${T("l_sort_by")}:`;
      t2 = space();
      select0 = element("select");
      option0 = element("option");
      option0.textContent = `${T("l_time_changed_on")}`;
      option1 = element("option");
      option1.textContent = `${T("l_name")}`;
      option2 = element("option");
      option2.textContent = `${T("l_device")}`;
      t6 = space();
      li1 = element("li");
      label1 = element("label");
      label1.textContent = `${T("l_page_size")}:`;
      t9 = space();
      select1 = element("select");
      option3 = element("option");
      option3.textContent = "5";
      option4 = element("option");
      option4.textContent = "20";
      option5 = element("option");
      option5.textContent = "50";
      option6 = element("option");
      option6.textContent = "100";
      option7 = element("option");
      option7.textContent = "200!!";
      option8 = element("option");
      option8.textContent = "500!!";
      t16 = space();
      li2 = element("li");
      label2 = element("label");
      label2.textContent = `${T("l_device_filter")}:`;
      t19 = space();
      select2 = element("select");
      option9 = element("option");
      option9.textContent = `${T("l_devices_all")}`;
      option10 = element("option");
      option10.textContent = `${T("l_device_this")}`;
      attr(label0, "class", "whitespace-nowrap");
      option0.__value = "-ts_data";
      option0.value = option0.__value;
      option1.__value = "name";
      option1.value = option1.__value;
      option2.__value = "client_id";
      option2.value = option2.__value;
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[3].call(select0));
      attr(li0, "class", "px-3 py-1 flex gap-1 justify-between items-center");
      attr(label1, "class", "whitespace-nowrap");
      option3.__value = 5;
      option3.value = option3.__value;
      option4.__value = 20;
      option4.value = option4.__value;
      option5.__value = 50;
      option5.value = option5.__value;
      option6.__value = 100;
      option6.value = option6.__value;
      option7.__value = 200;
      option7.value = option7.__value;
      option8.__value = 500;
      option8.value = option8.__value;
      if (ctx[1] === void 0)
        add_render_callback(() => ctx[4].call(select1));
      attr(li1, "class", "px-3 py-1 flex gap-1 justify-between items-center");
      attr(label2, "class", "whitespace-nowrap");
      option9.__value = 1;
      option9.value = option9.__value;
      option10.__value = 2;
      option10.value = option10.__value;
      if (ctx[2] === void 0)
        add_render_callback(() => ctx[5].call(select2));
      attr(li2, "class", "px-3 py-1 flex gap-1 justify-between items-center");
      attr(div, "class", "flex flex-column gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, li0);
      append(li0, label0);
      append(li0, t2);
      append(li0, select0);
      append(select0, option0);
      append(select0, option1);
      append(select0, option2);
      select_option(select0, ctx[0], true);
      append(div, t6);
      append(div, li1);
      append(li1, label1);
      append(li1, t9);
      append(li1, select1);
      append(select1, option3);
      append(select1, option4);
      append(select1, option5);
      append(select1, option6);
      append(select1, option7);
      append(select1, option8);
      select_option(select1, ctx[1], true);
      append(div, t16);
      append(div, li2);
      append(li2, label2);
      append(li2, t19);
      append(li2, select2);
      append(select2, option9);
      append(select2, option10);
      select_option(select2, ctx[2], true);
      if (!mounted) {
        dispose = [
          listen(select0, "change", ctx[3]),
          listen(select1, "change", ctx[4]),
          listen(select2, "change", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        select_option(select0, ctx2[0]);
      }
      if (dirty & 2) {
        select_option(select1, ctx2[1]);
      }
      if (dirty & 4) {
        select_option(select2, ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_action_slot$7(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-cog"></i> 
      <span class="caret"></span>`;
      attr(button, "class", "btn btn-default");
      attr(button, "data-bs-toggle", "dropdown");
      attr(button, "type", "button");
      attr(button, "aria-expanded", "false");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[6]))
            ctx[6].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1E(ctx) {
  let menu;
  let current;
  menu = new Menu$1({
    props: {
      dropDownClass: "dropdown-menu-right",
      class: "mr-6",
      toggle: false,
      $$slots: {
        action: [
          create_action_slot$7,
          ({ onClick }) => ({ 6: onClick }),
          ({ onClick }) => onClick ? 64 : 0
        ],
        default: [create_default_slot$G]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 199) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1B($$self, $$props, $$invalidate) {
  let sort = App.store.get("ui.list.sortby") || "-ts_data";
  let pagesize = App.store.get("ui.list.pagesize") || 50;
  let clientfilter = App.store.get("ui.list.clientfilter") || 1;
  function select0_change_handler() {
    sort = select_value(this);
    $$invalidate(0, sort);
  }
  function select1_change_handler() {
    pagesize = select_value(this);
    $$invalidate(1, pagesize);
  }
  function select2_change_handler() {
    clientfilter = select_value(this);
    $$invalidate(2, clientfilter);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      sort && App.store.set("ui.list.sortby", sort);
    }
    if ($$self.$$.dirty & 2) {
      pagesize && App.store.set("ui.list.pagesize", pagesize);
    }
    if ($$self.$$.dirty & 4) {
      clientfilter && App.store.set("ui.list.clientfilter", clientfilter);
    }
  };
  return [
    sort,
    pagesize,
    clientfilter,
    select0_change_handler,
    select1_change_handler,
    select2_change_handler
  ];
}
class TableSettingsMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1B, create_fragment$1E, safe_not_equal, {});
  }
}
function create_if_block_3$m(ctx) {
  let button0;
  let i0;
  let button0_disabled_value;
  let t0;
  let marksievereadmenu;
  let t1;
  let button1;
  let i1;
  let button1_disabled_value;
  let t2;
  let labellist;
  let current;
  let mounted;
  let dispose;
  marksievereadmenu = new MarkSieveReadMenu({
    props: {
      sieves: ctx[4],
      disabled: ctx[3].readOnly
    }
  });
  labellist = new LabelListMenu({
    props: {
      sieves: ctx[4],
      disabled: ctx[3].readOnly
    }
  });
  return {
    c() {
      button0 = element("button");
      i0 = element("i");
      t0 = space();
      create_component(marksievereadmenu.$$.fragment);
      t1 = space();
      button1 = element("button");
      i1 = element("i");
      t2 = space();
      create_component(labellist.$$.fragment);
      attr(i0, "class", "im-run");
      attr(button0, "class", "btn btn-default");
      attr(button0, "title", T("a_check_changes"));
      button0.disabled = button0_disabled_value = ctx[3].readOnly;
      attr(i1, "class", "im-trash");
      attr(button1, "class", "btn btn-default");
      attr(button1, "title", T("a_move_to_trash"));
      button1.disabled = button1_disabled_value = ctx[3].readOnly;
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, i0);
      insert(target, t0, anchor);
      mount_component(marksievereadmenu, target, anchor);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, i1);
      insert(target, t2, anchor);
      mount_component(labellist, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[8]),
          listen(button1, "click", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 8 && button0_disabled_value !== (button0_disabled_value = ctx2[3].readOnly)) {
        button0.disabled = button0_disabled_value;
      }
      const marksievereadmenu_changes = {};
      if (dirty & 8)
        marksievereadmenu_changes.disabled = ctx2[3].readOnly;
      marksievereadmenu.$set(marksievereadmenu_changes);
      if (!current || dirty & 8 && button1_disabled_value !== (button1_disabled_value = ctx2[3].readOnly)) {
        button1.disabled = button1_disabled_value;
      }
      const labellist_changes = {};
      if (dirty & 8)
        labellist_changes.disabled = ctx2[3].readOnly;
      labellist.$set(labellist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(marksievereadmenu.$$.fragment, local);
      transition_in(labellist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(marksievereadmenu.$$.fragment, local);
      transition_out(labellist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button0);
      if (detaching)
        detach(t0);
      destroy_component(marksievereadmenu, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(button1);
      if (detaching)
        detach(t2);
      destroy_component(labellist, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$o(ctx) {
  let button0;
  let t0_value = T("a_restore") + "";
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2_value = T("a_del_permanent") + "";
  let t2;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      attr(button0, "class", "btn btn-default");
      button0.disabled = button0_disabled_value = ctx[3].readOnly;
      attr(button1, "class", "btn btn-default");
      button1.disabled = button1_disabled_value = ctx[3].readOnly;
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, t0);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[9]),
          listen(button1, "click", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && button0_disabled_value !== (button0_disabled_value = ctx2[3].readOnly)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & 8 && button1_disabled_value !== (button1_disabled_value = ctx2[3].readOnly)) {
        button1.disabled = button1_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(button1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$y(ctx) {
  let button;
  let i2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fa fa-refresh");
      toggle_class(i2, "fa-spin", ctx[0]);
      attr(button, "class", "btn btn-default");
      attr(button, "title", T("l_sync"));
      button.disabled = button_disabled_value = ctx[3].readOnly;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        toggle_class(i2, "fa-spin", ctx2[0]);
      }
      if (dirty & 8 && button_disabled_value !== (button_disabled_value = ctx2[3].readOnly)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$R(ctx) {
  let batchoptions;
  let current;
  batchoptions = new BatchOptionsMenu({ props: { sieves: ctx[4] } });
  return {
    c() {
      create_component(batchoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchoptions, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(batchoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchoptions, detaching);
    }
  };
}
function create_fragment$1D(ctx) {
  let div;
  let input;
  let t0;
  let sieveselectmenu;
  let t1;
  let t2;
  let t3;
  let t4;
  let additionaloptions;
  let t5;
  let t6;
  let i2;
  let t7;
  let listpager;
  let t8;
  let tablesettings;
  let current;
  let mounted;
  let dispose;
  sieveselectmenu = new SieveSelectMenu({ props: { sieves: ctx[4] } });
  let if_block0 = ctx[2] && !ctx[1] && create_if_block_3$m(ctx);
  let if_block1 = ctx[1] && create_if_block_2$o(ctx);
  let if_block2 = ctx[6] && create_if_block_1$y(ctx);
  additionaloptions = new AdditionalOptionsMenu({ props: { sieves: ctx[4] } });
  let if_block3 = ctx[2] && create_if_block$R(ctx);
  listpager = new ListPager({ props: { store: ctx[4] } });
  tablesettings = new TableSettingsMenu({});
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      create_component(sieveselectmenu.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      create_component(additionaloptions.$$.fragment);
      t5 = space();
      if (if_block3)
        if_block3.c();
      t6 = space();
      i2 = element("i");
      t7 = space();
      create_component(listpager.$$.fragment);
      t8 = space();
      create_component(tablesettings.$$.fragment);
      attr(input, "class", "xselect-all");
      attr(input, "type", "checkbox");
      set_style(input, "margin", "0 6px 0 0");
      set_style(i2, "flex", "1 1 0%");
      attr(div, "class", "flex justify-end items-center gap-1 pl-2 xtbar flex-nowrap");
      toggle_class(div, "xlocal", ctx[6]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      append(div, t0);
      mount_component(sieveselectmenu, div, null);
      append(div, t1);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t4);
      mount_component(additionaloptions, div, null);
      append(div, t5);
      if (if_block3)
        if_block3.m(div, null);
      append(div, t6);
      append(div, i2);
      append(div, t7);
      mount_component(listpager, div, null);
      append(div, t8);
      mount_component(tablesettings, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[14]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[2] && !ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 6) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$m(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$o(ctx2);
          if_block1.c();
          if_block1.m(div, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[6])
        if_block2.p(ctx2, dirty);
      if (ctx2[2]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$R(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, t6);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveselectmenu.$$.fragment, local);
      transition_in(if_block0);
      transition_in(additionaloptions.$$.fragment, local);
      transition_in(if_block3);
      transition_in(listpager.$$.fragment, local);
      transition_in(tablesettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveselectmenu.$$.fragment, local);
      transition_out(if_block0);
      transition_out(additionaloptions.$$.fragment, local);
      transition_out(if_block3);
      transition_out(listpager.$$.fragment, local);
      transition_out(tablesettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(sieveselectmenu);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(additionaloptions);
      if (if_block3)
        if_block3.d();
      destroy_component(listpager);
      destroy_component(tablesettings);
      mounted = false;
      dispose();
    }
  };
}
function instance$1A($$self, $$props, $$invalidate) {
  let $route;
  let $isSieveSelected;
  let $permissionsModel;
  component_subscribe($$self, route, ($$value) => $$invalidate(13, $route = $$value));
  const { sieves } = getContext("watchlist:stores");
  let isSieveSelected = derived(sieves, () => sieves.getSelectedSieveIds().length > 0);
  component_subscribe($$self, isSieveSelected, (value) => $$invalidate(2, $isSieveSelected = value));
  let isLocal = Supports.agents.local;
  let syncing = false;
  let isTrash;
  const { permissionsModel } = App.user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(3, $permissionsModel = value));
  onMount(() => {
    if (!isLocal) {
      return;
    }
    instance$4s.on("user_states", toggleSync);
    return () => {
      instance$4s.off("user_states", toggleSync);
    };
  });
  function toggleSync({ sync }) {
    if (isLocal && sync) {
      setTimeout(() => $$invalidate(0, { syncing } = sync, syncing), 200);
    }
  }
  async function checkForChanges() {
    const models = sieves.getSelectedSieves();
    if (!isLocal) {
      runCloudSieves(models);
      return;
    }
    const ids = _.pluck(_.filter(models, (model) => !model.isDeviceWeb()), "id");
    serviceProxy.service.checkNow(ids);
    if (models.length > ids.length) {
      Msg.info("m_check_local_only");
    }
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  }
  async function runCloudSieves(models) {
    Msg.info("l_loading");
    const cloudIds = _.pluck(_.filter(models, (model) => model.isDeviceWeb()), "id");
    if (cloudIds.length > 0) {
      try {
        await Api.utils("/sieve/run", "POST", { ids: cloudIds });
        Msg.info("m_started_check_for_changes");
      } catch (err) {
        console.error("Could not check for changes", err);
        Msg.error("m_check_for_changes_failed");
      }
    }
  }
  async function restoreSieves() {
    const models = sieves.getSelectedSieves();
    let sieveConstraint = {};
    try {
      sieveConstraint = await checkSieveConstraint(models.length);
    } catch (e) {
      console.error(e);
      sieveConstraint = { isOverLimit: false };
    }
    if (sieveConstraint.isOverLimit) {
      Msg.error("m_monitor_limit");
      return;
    }
    try {
      for (let i2 = 0; i2 < models.length; i2++) {
        let model = models[i2];
        await model.save("state", C$2.STATE_READY, {
          patch: true,
          success() {
            model.collection.remove(model);
          }
        });
      }
      Msg.info("m_restored_from_trash");
    } catch (err) {
      Msg.error("sieve:restore:err");
    }
  }
  async function deleteSieve() {
    const models = sieves.getSelectedSieves();
    try {
      await Promise.all(models.map((model) => model.save("state", C$2.STATE_DISCARD, {
        patch: true,
        success() {
          model.collection.remove(model);
        }
      })));
    } catch (err) {
      Msg.error("sieve:del:err");
    }
    return true;
  }
  async function deleteSievePermanently() {
    const models = sieves.getSelectedSieves();
    try {
      for (let i2 = 0; i2 < models.length; i2 += 5) {
        await Promise.all(models.slice(i2, i2 + 5).map((model) => model.destroy()));
      }
      Msg.info("Permanently deleted selected items.");
    } catch (e) {
      Msg.error("sieve:del:err");
    }
  }
  async function syncLocalSieve() {
    if (!Supports.agents.local)
      return;
    Msg.info("l_syncing");
    let complete = false;
    try {
      await serviceProxy.SyncMan.sync(true);
      complete = true;
      Msg.reset();
    } catch (err) {
      console.error(JSON.stringify(err));
      try {
        complete = true;
        await serviceProxy.service.initSync();
      } catch (err2) {
        console.error(JSON.stringify(err2));
        Msg.error(err2.msg || err2.message || JSON.stringify(err2));
      }
    }
    setTimeout(
      function() {
        if (!complete) {
          Msg.info("l_syncing_wait");
        }
      },
      5e3
    );
  }
  const change_handler = (e) => sieves.toggleSieveSelection(e.target.checked);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8192) {
      $$invalidate(1, isTrash = $route.prefix === "trash");
    }
  };
  return [
    syncing,
    isTrash,
    $isSieveSelected,
    $permissionsModel,
    sieves,
    isSieveSelected,
    isLocal,
    permissionsModel,
    checkForChanges,
    restoreSieves,
    deleteSieve,
    deleteSievePermanently,
    syncLocalSieve,
    $route,
    change_handler
  ];
}
class Toolbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1A, create_fragment$1D, safe_not_equal, {});
  }
}
function create_topbar_slot$4(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({});
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_if_block_1$x(ctx) {
  let wltoolbar;
  let current;
  wltoolbar = new Toolbar({});
  return {
    c() {
      create_component(wltoolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(wltoolbar, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(wltoolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(wltoolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(wltoolbar, detaching);
    }
  };
}
function create_if_block$Q(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-chevron-left"></i> Back`;
      attr(button, "class", "btn btn-default w-min whitespace-nowrap");
      attr(button, "data-action", "go_back");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
    }
  };
}
function create_default_slot$F(ctx) {
  let div3;
  let div0;
  let sidebar;
  let t0;
  let div2;
  let current_block_type_index;
  let if_block;
  let t1;
  let div1;
  let current;
  let mounted;
  let dispose;
  sidebar = new Sidebar$1({});
  const if_block_creators = [create_if_block$Q, create_if_block_1$x];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    if (ctx2[3].module === "list")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(sidebar.$$.fragment);
      t0 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "sidebar");
      attr(div1, "class", "flex-1 overflow-y-auto");
      attr(div2, "class", "flex-1 flex flex-column gap-2 items-stretch");
      attr(div3, "class", "flex h-full w-full");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(sidebar, div0, null);
      append(div3, t0);
      append(div3, div2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      append(div2, t1);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[6](div1);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "scroll", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          }
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        } else {
          if_block = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(sidebar);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1C(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      contentScrollTop: ctx[1],
      $$slots: {
        default: [create_default_slot$F],
        topbar: [create_topbar_slot$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 2)
        layout_changes.contentScrollTop = ctx2[1];
      if (dirty & 141) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$1z($$self, $$props, $$invalidate) {
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(3, $route = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { renderDefaultToolbar = false } = $$props;
  let { contentScrollTop = 0 } = $$props;
  let elContent;
  function setScroll() {
    setTimeout(() => {
      elContent && $$invalidate(2, elContent.scrollTop = contentScrollTop, elContent);
    });
  }
  function scroll_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elContent = $$value;
      $$invalidate(2, elContent);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("renderDefaultToolbar" in $$props2)
      $$invalidate(0, renderDefaultToolbar = $$props2.renderDefaultToolbar);
    if ("contentScrollTop" in $$props2)
      $$invalidate(1, contentScrollTop = $$props2.contentScrollTop);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      {
        contentScrollTop !== void 0 && setScroll();
      }
    }
  };
  return [
    renderDefaultToolbar,
    contentScrollTop,
    elContent,
    $route,
    slots,
    scroll_handler,
    div1_binding,
    $$scope
  ];
}
class WatchListLayout extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1z, create_fragment$1C, safe_not_equal, {
      renderDefaultToolbar: 0,
      contentScrollTop: 1
    });
  }
}
function create_action_slot$6(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-caret-down"></i>`;
      attr(button, "class", "xtd xbtn xaction margin-0");
      attr(button, "data-bs-auto-close", "outside");
      attr(button, "data-bs-toggle", "dropdown");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[28]))
            ctx[28].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_6$4(ctx) {
  let menuitemwithpermissions;
  let current;
  function click_handler() {
    return ctx[18](ctx[27]);
  }
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", click_handler);
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitemwithpermissions_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot_8(ctx) {
  let t_value = T("a_check_changes") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Options");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6(ctx) {
  let t;
  return {
    c() {
      t = text("Duplicate");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_5$7(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      href: urlCfg.crawlerDetail(ctx[7].team || 0, ctx[6].crawler_id),
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 192)
        menuitemwithpermissions_changes.href = urlCfg.crawlerDetail(ctx2[7].team || 0, ctx2[6].crawler_id);
      if (dirty & 536870912) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let t;
  return {
    c() {
      t = text("View Crawler");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_4$d(ctx) {
  let li0;
  let t0;
  let menuitemwithpermissions;
  let t1;
  let li1;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      class: "xview",
      menuItemStyle: "--bs-dropdown-link-hover-bg: transparent;\n                               --bs-dropdown-link-active-bg: transparent;\n                               --bs-dropdown-link-active-color: var(--bs-body-color)",
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      li0 = element("li");
      li0.innerHTML = `<hr class="dropdown-divider"/>`;
      t0 = space();
      create_component(menuitemwithpermissions.$$.fragment);
      t1 = space();
      li1 = element("li");
      li1.innerHTML = `<hr class="dropdown-divider"/>`;
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t0, anchor);
      mount_component(menuitemwithpermissions, target, anchor);
      insert(target, t1, anchor);
      insert(target, li1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 536870925) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t0);
      destroy_component(menuitemwithpermissions, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(li1);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let actionseditor;
  let current;
  let actionseditor_props = { sieve: ctx[0] };
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  ctx[19](actionseditor);
  actionseditor.$on("globalaction", ctx[20]);
  actionseditor.$on("manage", ctx[11]);
  return {
    c() {
      create_component(actionseditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actionseditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actionseditor_changes = {};
      if (dirty & 1)
        actionseditor_changes.sieve = ctx2[0];
      actionseditor.$set(actionseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[19](null);
      destroy_component(actionseditor, detaching);
    }
  };
}
function create_else_block$C(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", ctx[14]);
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_if_block_3$l(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", ctx[17]);
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot_3$1(ctx) {
  let t;
  return {
    c() {
      t = text("Move to Trash");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$4(ctx) {
  let t;
  return {
    c() {
      t = text("Restore");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$i(ctx) {
  let t;
  return {
    c() {
      t = text("Delete forever");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$E(ctx) {
  let t0;
  let menuitemwithpermissions0;
  let t1;
  let menuitemwithpermissions1;
  let t2;
  let t3;
  let t4;
  let current_block_type_index;
  let if_block3;
  let t5;
  let menuitemwithpermissions2;
  let current;
  let if_block0 = Supports.agents.local && create_if_block_6$4(ctx);
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions0.$on("click", ctx[12]);
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1.$on("click", ctx[13]);
  let if_block1 = ctx[6].content_type === C$2.TYPE_SITEMAP && create_if_block_5$7(ctx);
  let if_block2 = !ctx[8].readOnly && create_if_block_4$d(ctx);
  const if_block_creators = [create_if_block_3$l, create_else_block$C];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[9].prefix === "trash")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  menuitemwithpermissions2 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_1$i] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions2.$on("click", ctx[15]);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(menuitemwithpermissions0.$$.fragment);
      t1 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if_block3.c();
      t5 = space();
      create_component(menuitemwithpermissions2.$$.fragment);
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitemwithpermissions0, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitemwithpermissions1, target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t4, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t5, anchor);
      mount_component(menuitemwithpermissions2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (Supports.agents.local)
        if_block0.p(ctx2, dirty);
      const menuitemwithpermissions0_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
      if (ctx2[6].content_type === C$2.TYPE_SITEMAP) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5$7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!ctx2[8].readOnly) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4$d(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block3 = if_blocks[current_block_type_index];
        if (!if_block3) {
          if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block3.c();
        } else {
          if_block3.p(ctx2, dirty);
        }
        transition_in(if_block3, 1);
        if_block3.m(t5.parentNode, t5);
      }
      const menuitemwithpermissions2_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions2.$set(menuitemwithpermissions2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(menuitemwithpermissions2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(menuitemwithpermissions2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitemwithpermissions0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitemwithpermissions1, detaching);
      if (detaching)
        detach(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t4);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t5);
      destroy_component(menuitemwithpermissions2, detaching);
    }
  };
}
function create_if_block_2$n(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[22]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block_1$w(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[23]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block$P(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[24]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_fragment$1B(ctx) {
  let menu;
  let updating_show;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  function menu_show_binding(value) {
    ctx[21](value);
  }
  let menu_props = {
    toggle: false,
    dropDownStyle: "",
    $$slots: {
      default: [
        create_default_slot$E,
        ({ close }) => ({ 27: close }),
        ({ close }) => close ? 134217728 : 0
      ],
      action: [
        create_action_slot$6,
        ({ onClick }) => ({ 28: onClick }),
        ({ onClick }) => onClick ? 268435456 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    menu_props.show = ctx[1];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "show", menu_show_binding));
  let if_block0 = ctx[3] && create_if_block_2$n(ctx);
  let if_block1 = ctx[4] && create_if_block_1$w(ctx);
  let if_block2 = ctx[5] && create_if_block$P(ctx);
  return {
    c() {
      create_component(menu.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 939525069) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_show && dirty & 2) {
        updating_show = true;
        menu_changes.show = ctx2[1];
        add_flush_callback(() => updating_show = false);
      }
      menu.$set(menu_changes);
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$n(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$w(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$P(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance$1y($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(6, $sieve = $$value)), sieve);
  let $params;
  let $permissionsModel;
  let $route;
  component_subscribe($$self, params, ($$value) => $$invalidate(7, $params = $$value));
  component_subscribe($$self, route, ($$value) => $$invalidate(9, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const { permissionsModel } = App.user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(8, $permissionsModel = value));
  let showMenu;
  let actionEditor;
  let showGlobalActionEditor2 = false;
  let showManageEmailsModal = false;
  let showManagePhonesModal = false;
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(4, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(5, showManagePhonesModal = true);
    }
  }
  function sieveEdit() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/sieve/edit/${$sieve.id}.id`);
  }
  function duplicateSieve() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/sieve/dup/${$sieve.id}.id`);
  }
  function deleteSieve() {
    Msg.start("discard", "l_loading");
    sieve.save("state", C$2.STATE_DISCARD, {
      patch: true,
      error() {
        Msg.stop("discard", { error: "e_req" });
      },
      success: () => {
        sieve.collection.remove(sieve);
        Msg.stop("discard");
      }
    });
  }
  function deleteSievePermanently() {
    Msg.start("destroy", "l_loading");
    sieve.destroy({
      error: () => {
        Msg.stop("destroy", { error: "e_req" });
      },
      success: () => {
        Msg.stop("destroy");
      }
    });
  }
  async function checkForChanges() {
    const ids = [$sieve.id];
    if (sieve.isDeviceWeb()) {
      Msg.info("m_check_local_only");
    } else {
      serviceProxy.service.checkNow(ids);
    }
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  }
  async function saveSieveActions() {
    const changes = actionEditor.getChanges();
    await base.syncBatch(changes);
  }
  async function restoreSieve() {
    let sieveConstraint = {};
    try {
      sieveConstraint = await checkSieveConstraint(1);
    } catch (e) {
      console.error(e);
      sieveConstraint = { isOverLimit: false };
    }
    if (sieveConstraint.isOverLimit) {
      Msg.error("m_monitor_limit");
      return;
    }
    try {
      await sieve.save("state", C$2.STATE_READY, {
        patch: true,
        success() {
          sieve.collection.remove(sieve);
        }
      });
      Msg.info("m_restored_from_trash");
    } catch (err) {
      Msg.error("sieve:restore:err");
    }
  }
  const click_handler = (close) => {
    checkForChanges();
    close();
  };
  function actionseditor_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionEditor = $$value;
      $$invalidate(2, actionEditor);
    });
  }
  const globalaction_handler = () => {
    $$invalidate(3, showGlobalActionEditor2 = true);
  };
  function menu_show_binding(value) {
    showMenu = value;
    $$invalidate(1, showMenu);
  }
  const close_handler = () => $$invalidate(3, showGlobalActionEditor2 = false);
  const close_handler_1 = () => $$invalidate(4, showManageEmailsModal = false);
  const close_handler_2 = () => $$invalidate(5, showManagePhonesModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      {
        if (!showMenu && actionEditor) {
          saveSieveActions();
        }
      }
    }
  };
  return [
    sieve,
    showMenu,
    actionEditor,
    showGlobalActionEditor2,
    showManageEmailsModal,
    showManagePhonesModal,
    $sieve,
    $params,
    $permissionsModel,
    $route,
    permissionsModel,
    showModal,
    sieveEdit,
    duplicateSieve,
    deleteSieve,
    deleteSievePermanently,
    checkForChanges,
    restoreSieve,
    click_handler,
    actionseditor_binding,
    globalaction_handler,
    menu_show_binding,
    close_handler,
    close_handler_1,
    close_handler_2
  ];
}
class SieveContextMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1y, create_fragment$1B, safe_not_equal, { sieve: 0 });
  }
}
function create_action_slot$5(ctx) {
  let a;
  let small;
  let t0_value = (ctx[2].schedule ? getShortDisplayText(ctx[2].schedule.toJSON()) : "err: unset") + "";
  let t0;
  let t1;
  let i2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      small = element("small");
      t0 = text(t0_value);
      t1 = space();
      i2 = element("i");
      attr(i2, "class", "xcaret fa fa-caret-down");
      attr(a, "title", "Click to edit schedule");
      attr(a, "data-bs-toggle", "dropdown");
      attr(a, "type", "button");
      attr(a, "aria-expanded", "false");
      attr(a, "data-bs-auto-close", "outside");
      attr(a, "class", "text-decoration-none xtd xdata xaction");
      toggle_class(a, "disabled", ctx[3].readOnly);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, small);
      append(small, t0);
      append(a, t1);
      append(a, i2);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[9]))
            ctx[9].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t0_value !== (t0_value = (ctx[2].schedule ? getShortDisplayText(ctx[2].schedule.toJSON()) : "err: unset") + ""))
        set_data(t0, t0_value);
      if (dirty & 8) {
        toggle_class(a, "disabled", ctx[3].readOnly);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_top_slot$2(ctx) {
  let li;
  let i0;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      i0 = element("i");
      i0.textContent = `${T("l_schedule")}`;
      t1 = space();
      button = element("button");
      button.innerHTML = `<i class="fa fa-times"></i>`;
      set_style(i0, "margin-left", "18px");
      attr(button, "class", "btn xbtn-light");
      attr(li, "class", "flex justify-between gap-2");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, i0);
      append(li, t1);
      append(li, button);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(function() {
          if (is_function(ctx[8]))
            ctx[8].apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$O(ctx) {
  let scheduleeditor;
  let current;
  const scheduleeditor_spread_levels = [
    { formModel: ctx[1] },
    { autoSync: true },
    ctx[5]
  ];
  let scheduleeditor_props = {};
  for (let i2 = 0; i2 < scheduleeditor_spread_levels.length; i2 += 1) {
    scheduleeditor_props = assign$1(scheduleeditor_props, scheduleeditor_spread_levels[i2]);
  }
  scheduleeditor = new ScheduleEditor({ props: scheduleeditor_props });
  return {
    c() {
      create_component(scheduleeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scheduleeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const scheduleeditor_changes = dirty & 34 ? get_spread_update(scheduleeditor_spread_levels, [
        dirty & 2 && { formModel: ctx2[1] },
        scheduleeditor_spread_levels[1],
        dirty & 32 && get_spread_object(ctx2[5])
      ]) : {};
      scheduleeditor.$set(scheduleeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scheduleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scheduleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scheduleeditor, detaching);
    }
  };
}
function create_default_slot$D(ctx) {
  let li;
  let current;
  let if_block = ctx[1] && create_if_block$O(ctx);
  return {
    c() {
      li = element("li");
      if (if_block)
        if_block.c();
      attr(li, "class", "xview");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (if_block)
        if_block.m(li, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$O(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(li, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block)
        if_block.d();
    }
  };
}
function create_fragment$1A(ctx) {
  let menu;
  let current;
  menu = new Menu$1({
    props: {
      dropDownClass: "dropdown-menu-end",
      toggle: false,
      disabled: ctx[3].readOnly,
      $$slots: {
        default: [create_default_slot$D],
        top: [
          create_top_slot$2,
          ({ close }) => ({ 8: close }),
          ({ close }) => close ? 256 : 0
        ],
        action: [
          create_action_slot$5,
          ({ onClick }) => ({ 9: onClick }),
          ({ onClick }) => onClick ? 512 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  menu.$on("open", ctx[6]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 8)
        menu_changes.disabled = ctx2[3].readOnly;
      if (dirty & 1806) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1x($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(2, $sieve = $$value)), sieve);
  let $permissionsModel;
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(3, $permissionsModel = value));
  let formModel;
  let sitemapAttributes = $sieve.content_type === C$2.TYPE_SITEMAP ? {
    editors: {
      AUTO: {
        name: "Auto",
        component: AutoScheduleMessage
      }
    },
    id: $sieve.crawler_id
  } : {};
  function onOpen() {
    $$invalidate(1, formModel = new SieveFormModel(sieve));
  }
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  return [
    sieve,
    formModel,
    $sieve,
    $permissionsModel,
    permissionsModel,
    sitemapAttributes,
    onOpen
  ];
}
class ScheduleMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1x, create_fragment$1A, safe_not_equal, { sieve: 0 });
  }
}
function create_fragment$1z(ctx) {
  let clientlist;
  let current;
  clientlist = new ClientList({ props: { clients: ctx[0] } });
  return {
    c() {
      create_component(clientlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientlist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(clientlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientlist, detaching);
    }
  };
}
function instance$1w($$self) {
  let clients = getContext("clients");
  return [clients];
}
class ClientManager extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1w, create_fragment$1z, safe_not_equal, {});
  }
}
function create_default_slot$C(ctx) {
  let clientmanager;
  let current;
  clientmanager = new ClientManager({});
  return {
    c() {
      create_component(clientmanager.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientmanager, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(clientmanager.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientmanager.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientmanager, detaching);
    }
  };
}
function create_header_slot$a(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${T("l_devices")}`;
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1y(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      bodyStyle: "--bs-modal-padding:0",
      $$slots: {
        header: [create_header_slot$a],
        default: [create_default_slot$C]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[0]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 2) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$1v($$self) {
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [close_handler];
}
class ClientManagerModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1v, create_fragment$1y, safe_not_equal, {});
  }
}
function get_each_context$t(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  return child_ctx;
}
function create_action_slot$4(ctx) {
  let a;
  let i0;
  let i0_class_value;
  let t;
  let i1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      i0 = element("i");
      t = space();
      i1 = element("i");
      attr(i0, "class", i0_class_value = App.clients.get(ctx[3].client_id) ? App.clients.get(ctx[3].client_id).getIcon() : "fa fa-lg error fa-question");
      set_style(i0, "margin", "auto");
      attr(i1, "class", "xcaret fa fa-caret-down");
      attr(a, "class", "xtd xdata xaction xbtn text-decoration-none");
      attr(a, "title", "Click to edit device");
      attr(a, "data-bs-toggle", "dropdown");
      set_style(a, "text-align", "center");
      toggle_class(a, "disabled", ctx[2].readOnly);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i0);
      append(a, t);
      append(a, i1);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[13]))
            ctx[13].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && i0_class_value !== (i0_class_value = App.clients.get(ctx[3].client_id) ? App.clients.get(ctx[3].client_id).getIcon() : "fa fa-lg error fa-question")) {
        attr(i0, "class", i0_class_value);
      }
      if (dirty & 4) {
        toggle_class(a, "disabled", ctx[2].readOnly);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_top_slot$1(ctx) {
  let li0;
  let span;
  let t1;
  let li1;
  return {
    c() {
      li0 = element("li");
      span = element("span");
      span.textContent = `${T("a_select_device")}`;
      t1 = space();
      li1 = element("li");
      li1.innerHTML = `<hr class="dropdown-divider"/>`;
      attr(li0, "class", "xview");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      append(li0, span);
      insert(target, t1, anchor);
      insert(target, li1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(li1);
    }
  };
}
function create_else_block$B(ctx) {
  let a;
  let i2;
  let i_class_value;
  let t0;
  let t1_value = ctx[10].getInfo() + "";
  let t1;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[7](ctx[10]);
  }
  return {
    c() {
      a = element("a");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", i_class_value = ctx[10].getIcon());
      attr(a, "class", "dropdown-item");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i2);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && i_class_value !== (i_class_value = ctx[10].getIcon())) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & 1 && t1_value !== (t1_value = ctx[10].getInfo() + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$v(ctx) {
  let a;
  let i2;
  let t0;
  let t1_value = ctx[10].getInfo() + "";
  let t1;
  return {
    c() {
      a = element("a");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fa fa-check");
      attr(a, "class", "dropdown-item");
      set_style(a, "font-weight", "bold");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i2);
      append(a, t0);
      append(a, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[10].getInfo() + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_each_block$t(key_1, ctx) {
  let li;
  let t;
  function select_block_type(ctx2, dirty) {
    if (ctx2[10].id === ctx2[3].client_id)
      return create_if_block_1$v;
    return create_else_block$B;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      if_block.c();
      t = space();
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if_block.m(li, null);
      append(li, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(li, t);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if_block.d();
    }
  };
}
function create_default_slot$B(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[0].getAccessibleClients(App.clients);
  const get_key = (ctx2) => ctx2[10].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$t(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$t(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 41) {
        each_value = ctx2[0].getAccessibleClients(App.clients);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$t, each_1_anchor, get_each_context$t);
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_bottom_slot$1(ctx) {
  let li0;
  let t0;
  let li1;
  let a;
  let i2;
  let t1;
  let t2_value = T("a_edit") + "";
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      li0 = element("li");
      li0.innerHTML = `<hr class="dropdown-divider"/>`;
      t0 = space();
      li1 = element("li");
      a = element("a");
      i2 = element("i");
      t1 = space();
      t2 = text(t2_value);
      attr(i2, "class", "fa fa-edit");
      attr(a, "class", "dropdown-item");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t0, anchor);
      insert(target, li1, anchor);
      append(li1, a);
      append(a, i2);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[6]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(li1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$N(ctx) {
  let clientmanagermodal;
  let current;
  clientmanagermodal = new ClientManagerModal({});
  clientmanagermodal.$on("close", ctx[8]);
  return {
    c() {
      create_component(clientmanagermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientmanagermodal, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(clientmanagermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientmanagermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientmanagermodal, detaching);
    }
  };
}
function create_fragment$1x(ctx) {
  let menu;
  let t;
  let if_block_anchor;
  let current;
  menu = new Menu$1({
    props: {
      dropDownClass: "dropdown-menu-end",
      disabled: ctx[2].readOnly,
      $$slots: {
        bottom: [create_bottom_slot$1],
        default: [create_default_slot$B],
        top: [create_top_slot$1],
        action: [
          create_action_slot$4,
          ({ onClick }) => ({ 13: onClick }),
          ({ onClick }) => onClick ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[1] && create_if_block$N(ctx);
  return {
    c() {
      create_component(menu.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 4)
        menu_changes.disabled = ctx2[2].readOnly;
      if (dirty & 24591) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$N(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1u($$self, $$props, $$invalidate) {
  let $permissionsModel;
  let $sieve, $$unsubscribe_sieve = noop, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(3, $sieve = $$value)), sieve);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(2, $permissionsModel = value));
  let showModal = false;
  function changeClient(id2) {
    Msg.start("save", "l_loading");
    sieve.save("client_id", id2, {
      wait: true,
      error() {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save");
      }
    });
  }
  const click_handler = () => $$invalidate(1, showModal = true);
  const click_handler_1 = (client) => changeClient(client.id);
  const close_handler = () => $$invalidate(1, showModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  return [
    sieve,
    showModal,
    $permissionsModel,
    $sieve,
    permissionsModel,
    changeClient,
    click_handler,
    click_handler_1,
    close_handler
  ];
}
class ClientManagerMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1u, create_fragment$1x, safe_not_equal, { sieve: 0 });
  }
}
function get_each_context$s(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  return child_ctx;
}
function create_action_slot$3(ctx) {
  let a;
  let small;
  let t0;
  let t1;
  let i2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      small = element("small");
      t0 = text(ctx[4]);
      t1 = space();
      i2 = element("i");
      attr(i2, "class", "xcaret fa fa-caret-down");
      attr(a, "title", "Click to view check/error log");
      attr(a, "class", "text-decoration-none xtd xdata xaction");
      attr(a, "data-bs-auto-close", "outside");
      attr(a, "data-bs-toggle", "dropdown");
      toggle_class(a, "xsieve-err", ctx[1].err);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, small);
      append(small, t0);
      append(a, t1);
      append(a, i2);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[16]))
            ctx[16].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16)
        set_data(t0, ctx[4]);
      if (dirty & 2) {
        toggle_class(a, "xsieve-err", ctx[1].err);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_top_slot(ctx) {
  let li;
  let span;
  let i0;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      span = element("span");
      i0 = element("i");
      i0.textContent = `${T("l_changed_on")}`;
      t1 = space();
      button = element("button");
      button.innerHTML = `<i class="fa fa-times"></i>`;
      set_style(span, "margin-left", "18px");
      attr(button, "class", "btn xbtn-light");
      attr(li, "class", "flex justify-between gap-2");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span);
      append(span, i0);
      append(li, t1);
      append(li, button);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(function() {
          if (is_function(ctx[15]))
            ctx[15].apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_catch_block$d(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$d(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_1$u;
    return create_else_block$A;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$A(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[5].models;
  const get_key = (ctx2) => ctx2[12].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$s(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$s(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 544) {
        each_value = ctx2[5].models;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$s, each_1_anchor, get_each_context$s);
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$u(ctx) {
  let t_value = T(ctx[3]) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = T(ctx2[3]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block_1$c(ctx) {
  let span;
  let t_value = formatTime(ctx[12].get("ts")) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = formatTime(ctx2[12].get("ts")) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$m(ctx) {
  let div1;
  let div0;
  let span0;
  let t0_value = formatTime(ctx[12].get("ts")) + "";
  let t0;
  let t1;
  let span1;
  let t2_value = (ctx[12].get("err").code || "EUNKNOWN") + "";
  let t2;
  let t3;
  let a;
  let t4;
  let a_href_value;
  let t5;
  let initPopover_action;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      a = element("a");
      t4 = text("View Details");
      t5 = space();
      attr(a, "href", a_href_value = ctx[9](ctx[12]));
      attr(a, "target", "_blank");
      attr(a, "type", "button");
      attr(a, "class", "ml1");
      attr(div1, "class", "flex justify-between error hover:grey gap-1");
      attr(div1, "tabindex", "0");
      attr(div1, "data-bs-toggle", "popover");
      attr(div1, "data-bs-trigger", "hover focus");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span0);
      append(span0, t0);
      append(div0, t1);
      append(div0, span1);
      append(span1, t2);
      append(div1, t3);
      append(div1, a);
      append(a, t4);
      append(div1, t5);
      if (!mounted) {
        dispose = action_destroyer(initPopover_action = initPopover.call(null, div1, ctx[12]));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && t0_value !== (t0_value = formatTime(ctx[12].get("ts")) + ""))
        set_data(t0, t0_value);
      if (dirty & 32 && t2_value !== (t2_value = (ctx[12].get("err").code || "EUNKNOWN") + ""))
        set_data(t2, t2_value);
      if (dirty & 32 && a_href_value !== (a_href_value = ctx[9](ctx[12]))) {
        attr(a, "href", a_href_value);
      }
      if (initPopover_action && is_function(initPopover_action.update) && dirty & 32)
        initPopover_action.update.call(null, ctx[12]);
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$s(key_1, ctx) {
  let first;
  let show_if;
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (dirty & 32)
      show_if = null;
    if (show_if == null)
      show_if = !!ctx2[12].get("err");
    if (show_if)
      return create_if_block_2$m;
    return create_else_block_1$c;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$d(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${T("l_loading")}`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$A(ctx) {
  let div1;
  let li0;
  let span0;
  let t0_value = formatTime(ctx[1].ts_data) + "";
  let t0;
  let t1;
  let li1;
  let span1;
  let i2;
  let t3;
  let div0;
  let promise;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$d,
    then: create_then_block$d,
    catch: create_catch_block$d
  };
  handle_promise(promise = ctx[2], info);
  return {
    c() {
      div1 = element("div");
      li0 = element("li");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      li1 = element("li");
      span1 = element("span");
      i2 = element("i");
      i2.textContent = `${T("l_check_log")}`;
      t3 = space();
      div0 = element("div");
      info.block.c();
      attr(span1, "class", "mb-2");
      attr(div0, "class", "flex flex-column");
      attr(li1, "class", "py-[3px]");
      attr(div1, "class", "px-[20px]");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li0);
      append(li0, span0);
      append(span0, t0);
      append(div1, t1);
      append(div1, li1);
      append(li1, span1);
      append(span1, i2);
      append(li1, t3);
      append(li1, div0);
      info.block.m(div0, info.anchor = null);
      info.mount = () => div0;
      info.anchor = null;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = formatTime(ctx[1].ts_data) + ""))
        set_data(t0, t0_value);
      info.ctx = ctx;
      if (dirty & 4 && promise !== (promise = ctx[2]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_if_block$M(ctx) {
  let li;
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      a = element("a");
      a.textContent = `${T("a_clear_error")}`;
      set_style(a, "padding", "0");
      attr(li, "class", "px-[20px] py-[3px]");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[8]));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_bottom_slot(ctx) {
  let if_block_anchor;
  let if_block = ctx[1].err && create_if_block$M(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[1].err) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$M(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$1w(ctx) {
  let menu;
  let current;
  menu = new Menu$1({
    props: {
      dropDownClass: "dropdown-menu-end",
      toggle: false,
      $$slots: {
        bottom: [create_bottom_slot],
        default: [create_default_slot$A],
        top: [
          create_top_slot,
          ({ close }) => ({ 15: close }),
          ({ close }) => close ? 32768 : 0
        ],
        action: [
          create_action_slot$3,
          ({ onClick }) => ({ 16: onClick }),
          ({ onClick }) => onClick ? 65536 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  menu.$on("open", ctx[10]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 229438) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function getSuggestions(err) {
  let suggestion = "";
  switch (err.code || "NA") {
    case "SELECTION_EMPTY":
      suggestion = `<ul style="padding-left:14px;">
            <li>Ensure that selected elements has text content.</li>
            <li>If website needs login, make sure that you are logged in.</li>
            </ul>`;
    case "TIMEOUT":
    case "ENOTFOUND":
    case "EREQUEST":
    case "ETIMEDOUT":
    case "ECONNREFUSED":
      suggestion = `<div>Please ensure that the webpage is accessible.</div>`;
    case "JAVASCRIPT":
      suggestion = `<div>Ensure that JavaScript is working in the page.</div>`;
    default:
      if (err.status === 0) {
        suggestion = `<div>Ensure that internet connection is working.</div>`;
      }
      suggestion = `<div>There is no information about this error.</div>`;
  }
  return suggestion;
}
function initPopover(el, work) {
  const err = work.get("err");
  const content = `<div class='overflow-y-auto max-h-[300px]'>
            <div><label>Code:</label> <span>${err.code || "NA"}</span></div>
            <div><label>Msg:</label> <span>${err.msg || err.message || JSON.stringify(err)}</span></div>
            <div style="padding-top: 5px;"><strong>Recommended Actions</strong> ${getSuggestions(err)}</div>
            <div style="padding-top: 5px;"> <strong>Need help?</strong><div>Contact us at support@distill.io</div></div>
            </div>`;
  window.$(el).popover({
    placement: "left",
    html: true,
    container: "body",
    content
  });
}
function instance$1t($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(1, $sieve = $$value)), sieve);
  let $works;
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const works = new Model$2.Works(null, { sieve });
  component_subscribe($$self, works, (value) => $$invalidate(5, $works = value));
  let worksPromise;
  let msg;
  let runState;
  async function fetchWorks() {
    await works.fetch();
    if (works.length === 0) {
      if ($sieve.client_id == App.clients.defaultId) {
        $$invalidate(3, msg = "m_log_na");
      } else {
        $$invalidate(3, msg = "Log for this monitor will be available on device that runs this monitor");
      }
    }
  }
  onMount(() => {
    const keyList = `sieves:run_state:${$sieve.id}  sieves:on_demand_run_status:${$sieve.id}`;
    instance$4s.on(keyList, getSieveState);
    return () => instance$4s.off(keyList, getSieveState);
  });
  function getSieveState(e = {}) {
    var _a;
    const state = e.state || ((_a = e.doc) == null ? void 0 : _a.state) || 0;
    if (state == C$2.RUN_STATE_WAIT) {
      $$invalidate(4, runState = "Waiting");
    } else if (state == C$2.RUN_STATE_WIP) {
      $$invalidate(4, runState = "Checking");
    } else {
      $$invalidate(4, runState = formatTime($sieve.ts_data, true) || "" || "NA");
    }
  }
  function clearError() {
    sieve.save("err", null, {
      error() {
        Msg.error("e_err");
      }
    });
  }
  function url(work) {
    if (work.get("err")) {
      const team = get_store_value(params).team;
      let err = work.get("err");
      if ($sieve.crawler_id && err) {
        return `${urlCfg.crawlerDetail(team, $sieve.crawler_id)}/${err.jobId || ""}`;
      }
      return `#/checks/${team}/${$sieve.id}?work=${work.get("id")}`;
    } else {
      return "#";
    }
  }
  const open_handler = () => $$invalidate(2, worksPromise = fetchWorks());
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      getSieveState();
    }
  };
  return [
    sieve,
    $sieve,
    worksPromise,
    msg,
    runState,
    $works,
    works,
    fetchWorks,
    clearError,
    url,
    open_handler
  ];
}
class LogMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1t, create_fragment$1w, safe_not_equal, { sieve: 0 });
  }
}
function get_each_context$r(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function create_if_block$L(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Deleted";
      attr(span, "class", "badge rounded-pill text-bg-danger");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$r(key_1, ctx) {
  let span;
  let t_value = ctx[13].get("name") + "";
  let t;
  let span_title_value;
  return {
    key: key_1,
    first: null,
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "badge rounded-pill bg-primary mr-1 text-truncate");
      attr(span, "title", span_title_value = ctx[13].get("name"));
      set_style(span, "max-width", "100px");
      this.first = span;
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t_value !== (t_value = ctx[13].get("name") + ""))
        set_data(t, t_value);
      if (dirty & 1 && span_title_value !== (span_title_value = ctx[13].get("name"))) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$1v(ctx) {
  let tr;
  let td0;
  let label;
  let input;
  let input_checked_value;
  let t0;
  let td1;
  let sievecontextmenu;
  let t1;
  let td2;
  let a;
  let img;
  let img_src_value;
  let t2;
  let t3_value = (ctx[1].name || SPRINTF("l_untitled")) + "";
  let t3;
  let a_href_value;
  let a_title_value;
  let t4;
  let td3;
  let div;
  let i2;
  let t5;
  let t6;
  let span0;
  let t7;
  let span1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t8;
  let span2;
  let t9_value = (ctx[1].text != null ? ctx[1].text || "<" + SPRINTF("h_sieve_empty") + ">" : "<" + SPRINTF("h_sieve_new") + ">") + "";
  let t9;
  let t10;
  let td4;
  let schedulemenu;
  let td4_class_value;
  let t11;
  let td5;
  let logmenu;
  let t12;
  let td6;
  let clientmenu;
  let t13;
  let td7;
  let button;
  let t14_value = ctx[1].state === C$2.STATE_READY ? "ON " : "OFF";
  let t14;
  let button_class_value;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  sievecontextmenu = new SieveContextMenu({ props: { sieve: ctx[0] } });
  let if_block = (ctx[1].state === C$2.STATE_DISCARD || ctx[1].state === C$2.STATE_DEL) && create_if_block$L();
  let each_value = ctx[0].getTags(App.labels);
  const get_key = (ctx2) => ctx2[13].id;
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    let child_ctx = get_each_context$r(ctx, each_value, i3);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i3] = create_each_block$r(key, child_ctx));
  }
  schedulemenu = new ScheduleMenu({ props: { sieve: ctx[0] } });
  logmenu = new LogMenu({ props: { sieve: ctx[0] } });
  clientmenu = new ClientManagerMenu({ props: { sieve: ctx[0] } });
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      label = element("label");
      input = element("input");
      t0 = space();
      td1 = element("td");
      create_component(sievecontextmenu.$$.fragment);
      t1 = space();
      td2 = element("td");
      a = element("a");
      img = element("img");
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      td3 = element("td");
      div = element("div");
      i2 = element("i");
      t5 = space();
      if (if_block)
        if_block.c();
      t6 = space();
      span0 = element("span");
      t7 = space();
      span1 = element("span");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t8 = space();
      span2 = element("span");
      t9 = text(t9_value);
      t10 = space();
      td4 = element("td");
      create_component(schedulemenu.$$.fragment);
      t11 = space();
      td5 = element("td");
      create_component(logmenu.$$.fragment);
      t12 = space();
      td6 = element("td");
      create_component(clientmenu.$$.fragment);
      t13 = space();
      td7 = element("td");
      button = element("button");
      t14 = text(t14_value);
      attr(input, "type", "checkbox");
      set_style(input, "margin", "0");
      set_style(input, "vertical-align", "middle");
      input.checked = input_checked_value = ctx[1].selected;
      attr(label, "class", "xtd xdata xaction");
      attr(img, "width", "14");
      attr(img, "loading", "lazy");
      if (!src_url_equal(img.src, img_src_value = URL_ROOT + "/v1/getfavicon?url=" + escape(ctx[4]())))
        attr(img, "src", img_src_value);
      attr(a, "class", "xtd xdata text-decoration-none monitor-link");
      attr(a, "rel", "noopener");
      attr(a, "target", "_blank");
      attr(a, "href", a_href_value = ctx[1].uri);
      attr(a, "title", a_title_value = ctx[1].name);
      attr(td2, "class", "overflow-hidden");
      attr(i2, "class", "xcaret fa fa-angle-double-down fa-lg");
      attr(div, "class", "xtd xdata xaction");
      attr(div, "title", "Click to view history");
      attr(td3, "class", "overflow-hidden");
      attr(td4, "class", td4_class_value = ctx[1].schedule ? ctx[1].schedule.getFrequencyClass() : "error");
      set_style(td6, "padding", "0");
      attr(button, "class", button_class_value = "xtd btn " + (ctx[1].state === C$2.STATE_READY ? "btn-success" : "btn-default") + " btn-sm border-end border-start");
      set_style(button, "border-radius", "0");
      set_style(button, "height", "100%");
      attr(button, "title", "Turn monitor ON or OFF");
      attr(button, "data-placement", "left");
      button.disabled = button_disabled_value = ctx[2].readOnly;
      toggle_class(button, "disabled", ctx[1].state === C$2.STATE_DISCARD);
      set_style(td7, "padding", "0");
      attr(tr, "class", "xitem");
      toggle_class(tr, "xunread", !ctx[0].isRead());
      toggle_class(tr, "xfade", ctx[0].isRead());
      toggle_class(tr, "active", ctx[1].selected);
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, label);
      append(label, input);
      append(tr, t0);
      append(tr, td1);
      mount_component(sievecontextmenu, td1, null);
      append(tr, t1);
      append(tr, td2);
      append(td2, a);
      append(a, img);
      append(a, t2);
      append(a, t3);
      append(tr, t4);
      append(tr, td3);
      append(td3, div);
      append(div, i2);
      append(div, t5);
      if (if_block)
        if_block.m(div, null);
      append(div, t6);
      append(div, span0);
      append(div, t7);
      append(div, span1);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(span1, null);
        }
      }
      append(div, t8);
      append(div, span2);
      append(span2, t9);
      append(tr, t10);
      append(tr, td4);
      mount_component(schedulemenu, td4, null);
      append(tr, t11);
      append(tr, td5);
      mount_component(logmenu, td5, null);
      append(tr, t12);
      append(tr, td6);
      mount_component(clientmenu, td6, null);
      append(tr, t13);
      append(tr, td7);
      append(td7, button);
      append(button, t14);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[9]),
          listen(a, "click", ctx[10]),
          listen(div, "click", ctx[5]),
          listen(button, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 2 && input_checked_value !== (input_checked_value = ctx2[1].selected)) {
        input.checked = input_checked_value;
      }
      const sievecontextmenu_changes = {};
      if (dirty & 1)
        sievecontextmenu_changes.sieve = ctx2[0];
      sievecontextmenu.$set(sievecontextmenu_changes);
      if ((!current || dirty & 2) && t3_value !== (t3_value = (ctx2[1].name || SPRINTF("l_untitled")) + ""))
        set_data(t3, t3_value);
      if (!current || dirty & 2 && a_href_value !== (a_href_value = ctx2[1].uri)) {
        attr(a, "href", a_href_value);
      }
      if (!current || dirty & 2 && a_title_value !== (a_title_value = ctx2[1].name)) {
        attr(a, "title", a_title_value);
      }
      if (ctx2[1].state === C$2.STATE_DISCARD || ctx2[1].state === C$2.STATE_DEL) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$L();
          if_block.c();
          if_block.m(div, t6);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 1) {
        each_value = ctx2[0].getTags(App.labels);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, span1, destroy_block, create_each_block$r, null, get_each_context$r);
      }
      if ((!current || dirty & 2) && t9_value !== (t9_value = (ctx2[1].text != null ? ctx2[1].text || "<" + SPRINTF("h_sieve_empty") + ">" : "<" + SPRINTF("h_sieve_new") + ">") + ""))
        set_data(t9, t9_value);
      const schedulemenu_changes = {};
      if (dirty & 1)
        schedulemenu_changes.sieve = ctx2[0];
      schedulemenu.$set(schedulemenu_changes);
      if (!current || dirty & 2 && td4_class_value !== (td4_class_value = ctx2[1].schedule ? ctx2[1].schedule.getFrequencyClass() : "error")) {
        attr(td4, "class", td4_class_value);
      }
      const logmenu_changes = {};
      if (dirty & 1)
        logmenu_changes.sieve = ctx2[0];
      logmenu.$set(logmenu_changes);
      const clientmenu_changes = {};
      if (dirty & 1)
        clientmenu_changes.sieve = ctx2[0];
      clientmenu.$set(clientmenu_changes);
      if ((!current || dirty & 2) && t14_value !== (t14_value = ctx2[1].state === C$2.STATE_READY ? "ON " : "OFF"))
        set_data(t14, t14_value);
      if (!current || dirty & 2 && button_class_value !== (button_class_value = "xtd btn " + (ctx2[1].state === C$2.STATE_READY ? "btn-success" : "btn-default") + " btn-sm border-end border-start")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & 4 && button_disabled_value !== (button_disabled_value = ctx2[2].readOnly)) {
        button.disabled = button_disabled_value;
      }
      if (!current || dirty & 2) {
        toggle_class(button, "disabled", ctx2[1].state === C$2.STATE_DISCARD);
      }
      if (!current || dirty & 1) {
        toggle_class(tr, "xunread", !ctx2[0].isRead());
      }
      if (!current || dirty & 1) {
        toggle_class(tr, "xfade", ctx2[0].isRead());
      }
      if (!current || dirty & 2) {
        toggle_class(tr, "active", ctx2[1].selected);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sievecontextmenu.$$.fragment, local);
      transition_in(schedulemenu.$$.fragment, local);
      transition_in(logmenu.$$.fragment, local);
      transition_in(clientmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievecontextmenu.$$.fragment, local);
      transition_out(schedulemenu.$$.fragment, local);
      transition_out(logmenu.$$.fragment, local);
      transition_out(clientmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_component(sievecontextmenu);
      if (if_block)
        if_block.d();
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].d();
      }
      destroy_component(schedulemenu);
      destroy_component(logmenu);
      destroy_component(clientmenu);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1s($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(1, $sieve = $$value)), sieve);
  let $permissionsModel;
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(8, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(2, $permissionsModel = value));
  let expanded = false;
  onMount(() => {
    const evt = `sieves:${sieve.id}`;
    instance$4s.on(evt, onSieveUpdate);
    return () => instance$4s.off(evt, onSieveUpdate);
  });
  function getHost2() {
    let url = $sieve.uri;
    let host = "";
    try {
      host = "//" + new URL(url).host;
    } catch (e) {
    }
    return host;
  }
  function toggleExpanded() {
    let path = getBasePath();
    if ($route.id !== $sieve.id) {
      path += `${sieve.id}.id`;
    }
    let queryStr = lib.stringify($route.query);
    if (queryStr.length > 0) {
      path += `?${queryStr}`;
    }
    if (!sieve.isRead() && !$permissionsModel.readOnly) {
      sieve.markRead();
    }
    push$1(path);
  }
  function toggleSieve() {
    const toggledState = $sieve.state == C$2.STATE_READY ? C$2.STATE_PAUSED : C$2.STATE_READY;
    Msg.start("sieve:save", { info: "l_saving" });
    sieve.save(null, {
      data: { state: toggledState },
      patch: true,
      err(err, res) {
        Msg.stop("sieve:save", { error: "e_req" });
      },
      success() {
        Msg.stop("sieve:save");
        sieve.set("state", toggledState);
      }
    });
  }
  function onSieveUpdate(e) {
    if (e.doc) {
      sieve.set(sieve.parse(e.doc), { silent: true });
      sieve.trigger("change");
    } else {
      sieve.fetch();
    }
  }
  const change_handler = (e) => sieve.set("selected", e.target.checked);
  const click_handler = () => sieve.markRead();
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 385) {
      {
        let _expanded = $route.id === sieve.id;
        if (expanded !== _expanded) {
          $$invalidate(7, expanded = _expanded);
          sieve.set("selected", expanded);
        }
      }
    }
  };
  return [
    sieve,
    $sieve,
    $permissionsModel,
    permissionsModel,
    getHost2,
    toggleExpanded,
    toggleSieve,
    expanded,
    $route,
    change_handler,
    click_handler
  ];
}
class SieveRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1s, create_fragment$1v, safe_not_equal, { sieve: 0 });
  }
}
function get_each_context$q(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_catch_block$c(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$c(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Email",
      onSave: ctx[3],
      saveLabel: "Send",
      $$slots: { default: [create_default_slot$z] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[8]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 131075) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_each_block$q(key_1, ctx) {
  let option;
  let t0_value = ctx[14].value + "";
  let t0;
  let t1;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value = ctx[14].value;
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[14].value + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && option_value_value !== (option_value_value = ctx[14].value)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot$z(ctx) {
  let select;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[14].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$q(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$q(key, child_ctx));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(select, "class", "w-100");
      if (ctx[1] === void 0)
        add_render_callback(() => ctx[7].call(select));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[1], true);
      if (!mounted) {
        dispose = listen(select, "change", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = ctx2[0];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$q, null, get_each_context$q);
      }
      if (dirty & 3) {
        select_option(select, ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function create_pending_block$c(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$1u(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$c,
    then: create_then_block$c,
    catch: create_catch_block$c,
    value: 13,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function setStyle(els, name, value) {
  els.forEach(function(el) {
    el.style[name] = value;
  });
}
function setDiffStyle(doc) {
  setStyle(doc.querySelectorAll(".removed"), "background-color", "#ff9494");
  setStyle(doc.querySelectorAll(".inserted"), "background-color", "#b7fdcb");
  setStyle(doc.querySelectorAll("span.inserted, span.removed"), "padding", "1px 4px");
  setStyle(doc.querySelectorAll("a.removed, a .removed"), "color", "#008");
  setStyle(doc.querySelectorAll("img.removed"), "border", "solid 2px red");
  setStyle(doc.querySelectorAll("img.removed"), "background-color", "transparent");
  setStyle(doc.querySelectorAll("img.removed"), "padding", "2px");
  setStyle(doc.querySelectorAll("img.inserted"), "border", "solid 2px green");
  setStyle(doc.querySelectorAll("img.inserted"), "background-color", "transparent");
  setStyle(doc.querySelectorAll("img.inserted"), "padding", "2px");
}
function instance$1r($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { diffView = null } = $$props;
  let { sieve } = $$props;
  let { model } = $$props;
  const type = model.get("data_type");
  let emails = [];
  let selectedEmail;
  function close() {
    dispatch("close");
  }
  async function fetchData() {
    Msg.info("loading");
    const res = await Api.api("/users/attrs", { name: "email", state: 40 });
    $$invalidate(0, emails = res.data);
    Msg.reset();
  }
  function getEmailContent() {
    let content;
    if (type === C$2.TYPE_JSON) {
      content = diffView.innerHTML;
    } else {
      let doc = diffView.contentDocument.cloneNode(true);
      if (type === C$2.TYPE_HTML) {
        setDiffStyle(doc);
      } else if (type === C$2.TYPE_XML) {
        content = `<pre>${content}</pre>`;
      }
      content = doc.body.innerHTML;
    }
    return content;
  }
  async function save() {
    try {
      await Api.api("/agents/actions/email", "POST", {
        action: { config: { email: selectedEmail } },
        sieve: sieve.pick("id", "name", "uri", "ts"),
        sieve_data: model.pick("id", "text", "ts"),
        emailContent: `
          <div id="highlighted-inlined"
            style="padding: 10px; background-color: #fff">
            ${getEmailContent()}
          </div>`,
        hasDiff: true
      });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function select_change_handler() {
    selectedEmail = select_value(this);
    $$invalidate(1, selectedEmail);
    $$invalidate(0, emails);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("diffView" in $$props2)
      $$invalidate(4, diffView = $$props2.diffView);
    if ("sieve" in $$props2)
      $$invalidate(5, sieve = $$props2.sieve);
    if ("model" in $$props2)
      $$invalidate(6, model = $$props2.model);
  };
  return [
    emails,
    selectedEmail,
    fetchData,
    save,
    diffView,
    sieve,
    model,
    select_change_handler,
    close_handler
  ];
}
class EmailSelectModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1r, create_fragment$1u, safe_not_equal, { diffView: 4, sieve: 5, model: 6 });
  }
}
function create_action_slot$2(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-cog"></i>`;
      attr(button, "class", "btn btn-default btn-sm");
      set_style(button, "--bs-btn-padding-y", ".20rem");
      set_style(button, "--bs-btn-padding-x", ".45rem");
      set_style(button, "--bs-btn-font-size", ".75rem");
      attr(button, "data-bs-toggle", "dropdown");
      attr(button, "data-bs-auto-close", "outside");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[11]))
            ctx[11].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_catch_block$b(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.innerHTML = `<div>Couldn&#39;t get prefs.
          <a href="/ui/settings.html#general">Sign in to account.</a></div>`;
      attr(li, "class", "dropdown-item xview error");
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_then_block$b(ctx) {
  let li0;
  let t1;
  let li1;
  let div1;
  let div0;
  let input0;
  let t2;
  let label0;
  let t4;
  let li2;
  let div3;
  let div2;
  let input1;
  let t5;
  let label1;
  let t7;
  let li3;
  let t8;
  let li4;
  let a;
  let t9_value = T("l_explore_diff_in_a_new_page") + "";
  let t9;
  let t10;
  let i2;
  let mounted;
  let dispose;
  return {
    c() {
      li0 = element("li");
      li0.innerHTML = `<h6 class="dropdown-header">Defaults</h6>`;
      t1 = space();
      li1 = element("li");
      div1 = element("div");
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      label0 = element("label");
      label0.textContent = "Deleted";
      t4 = space();
      li2 = element("li");
      div3 = element("div");
      div2 = element("div");
      input1 = element("input");
      t5 = space();
      label1 = element("label");
      label1.textContent = "Snipped";
      t7 = space();
      li3 = element("li");
      li3.innerHTML = `<hr class="dropdown-divider"/>`;
      t8 = space();
      li4 = element("li");
      a = element("a");
      t9 = text(t9_value);
      t10 = space();
      i2 = element("i");
      attr(input0, "type", "checkbox");
      attr(input0, "class", "form-check-input");
      attr(input0, "id", "showDeletedID");
      attr(label0, "class", "form-check-label");
      attr(label0, "for", "showDeletedID");
      attr(div0, "class", "form-check");
      attr(div1, "class", "");
      attr(li1, "class", "dropdown-item");
      attr(input1, "type", "checkbox");
      attr(input1, "class", "form-check-input");
      attr(input1, "id", "showSnippedID");
      attr(label1, "class", "form-check-label");
      attr(label1, "for", "showSnippedID");
      attr(div2, "class", "form-check");
      attr(div3, "class", "");
      attr(li2, "class", "dropdown-item");
      attr(i2, "class", "fa fa-external-link");
      attr(a, "href", ctx[0]);
      attr(a, "target", "_blank");
      attr(a, "class", "dropdown-item fw1 f5 lh-copy");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t1, anchor);
      insert(target, li1, anchor);
      append(li1, div1);
      append(div1, div0);
      append(div0, input0);
      input0.checked = ctx[1];
      append(div0, t2);
      append(div0, label0);
      insert(target, t4, anchor);
      insert(target, li2, anchor);
      append(li2, div3);
      append(div3, div2);
      append(div2, input1);
      input1.checked = ctx[2];
      append(div2, t5);
      append(div2, label1);
      insert(target, t7, anchor);
      insert(target, li3, anchor);
      insert(target, t8, anchor);
      insert(target, li4, anchor);
      append(li4, a);
      append(a, t9);
      append(a, t10);
      append(a, i2);
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[6]),
          listen(input0, "change", ctx[4]),
          listen(input1, "change", ctx[7]),
          listen(input1, "change", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        input0.checked = ctx2[1];
      }
      if (dirty & 4) {
        input1.checked = ctx2[2];
      }
      if (dirty & 1) {
        attr(a, "href", ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(li1);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(li2);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(li3);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(li4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_pending_block$b(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.textContent = "Loading...";
      attr(li, "class", "xview text-center dropdown-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_default_slot$y(ctx) {
  let await_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$b,
    then: create_then_block$b,
    catch: create_catch_block$b,
    value: 10,
    error: 10
  };
  handle_promise(ctx[3](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$1t(ctx) {
  let menu;
  let current;
  menu = new Menu$1({
    props: {
      dropDownClass: "dropdown-menu-end",
      toggle: false,
      $$slots: {
        default: [create_default_slot$y],
        action: [
          create_action_slot$2,
          ({ onClick }) => ({ 11: onClick }),
          ({ onClick }) => onClick ? 2048 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 6151) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1q($$self, $$props, $$invalidate) {
  let { exploreDiffPath } = $$props;
  let { contentType } = $$props;
  let removed = false;
  let snipped = false;
  const user = getContext("user");
  createEventDispatcher();
  async function fetchDiffPrefs() {
    const res = await Api.api("/users/prefs/ui_diff", "GET");
    if (res) {
      $$invalidate(1, { removed, snipped } = res, removed, $$invalidate(2, snipped));
    }
  }
  async function save() {
    try {
      const diffPrefs = {
        removed: removed ? 1 : 0,
        snipped: snipped ? 1 : 0
      };
      await Api.api("/users/prefs/ui_diff", "PUT", diffPrefs);
      user.setDiffPrefs(diffPrefs);
      if (Supports.agents.local) {
        await serviceProxy.SyncMan.get(serviceProxy.store.UserStore);
      }
    } catch (err) {
      Msg.error("e_req");
    }
  }
  function input0_change_handler() {
    removed = this.checked;
    $$invalidate(1, removed);
  }
  function input1_change_handler() {
    snipped = this.checked;
    $$invalidate(2, snipped);
  }
  $$self.$$set = ($$props2) => {
    if ("exploreDiffPath" in $$props2)
      $$invalidate(0, exploreDiffPath = $$props2.exploreDiffPath);
    if ("contentType" in $$props2)
      $$invalidate(5, contentType = $$props2.contentType);
  };
  return [
    exploreDiffPath,
    removed,
    snipped,
    fetchDiffPrefs,
    save,
    contentType,
    input0_change_handler,
    input1_change_handler
  ];
}
class DiffPrefsMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1q, create_fragment$1t, safe_not_equal, { exploreDiffPath: 0, contentType: 5 });
  }
}
function create_if_block_10(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "No conditions were set.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_5$6(ctx) {
  let accordion;
  let current;
  accordion = new Accordion({
    props: {
      id: "Global",
      show: true,
      $$slots: {
        header: [create_header_slot_1$2],
        default: [create_default_slot_1$h]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion_changes = {};
      if (dirty & 16393) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordion, detaching);
    }
  };
}
function create_if_block_9$1(ctx) {
  let sieveruleseditorv2;
  let current;
  sieveruleseditorv2 = new SieveRulesEditorV2$1({
    props: {
      config: ctx[3].config,
      disabled
    }
  });
  return {
    c() {
      create_component(sieveruleseditorv2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv2_changes = {};
      if (dirty & 8)
        sieveruleseditorv2_changes.config = ctx2[3].config;
      sieveruleseditorv2.$set(sieveruleseditorv2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv2, detaching);
    }
  };
}
function create_if_block_8$1(ctx) {
  let sieveruleseditorv1;
  let current;
  sieveruleseditorv1 = new SieveRulesEditorV1({
    props: {
      config: ctx[3].config,
      disabled
    }
  });
  return {
    c() {
      create_component(sieveruleseditorv1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv1_changes = {};
      if (dirty & 8)
        sieveruleseditorv1_changes.config = ctx2[3].config;
      sieveruleseditorv1.$set(sieveruleseditorv1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv1, detaching);
    }
  };
}
function create_default_slot_1$h(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_8$1, create_if_block_9$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0] === V1$1)
      return 0;
    if (ctx2[0] === V2$1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "overflow-auto max-h-[200px] px-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_7$2(ctx) {
  let t;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      classes: ctx[6],
      result: ctx[3].config.rule.result
    }
  });
  return {
    c() {
      t = text("(V2) ");
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 8)
        ruleresult_changes.result = ctx2[3].config.rule.result;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_if_block_6$3(ctx) {
  let t;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      classes: ctx[6],
      result: ctx[3].config.fields.result.get()
    }
  });
  return {
    c() {
      t = text("(V1) ");
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 8)
        ruleresult_changes.result = ctx2[3].config.fields.result.get();
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_header_slot_1$2(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_6$3, create_if_block_7$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === V1$1)
      return 0;
    if (ctx2[0] === V2$1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      t = text("Global\n        ");
      if (if_block)
        if_block.c();
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block$K(ctx) {
  let div;
  let t;
  let accordion;
  let current;
  accordion = new Accordion({
    props: {
      id: "Monitor",
      show: true,
      $$slots: {
        header: [create_header_slot$9],
        default: [create_default_slot$x]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      t = space();
      create_component(accordion.$$.fragment);
      attr(div, "class", "border-top my-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t, anchor);
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion_changes = {};
      if (dirty & 16400) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t);
      destroy_component(accordion, detaching);
    }
  };
}
function create_if_block_4$c(ctx) {
  let sieveruleseditorv2;
  let current;
  sieveruleseditorv2 = new SieveRulesEditorV2$1({
    props: {
      config: ctx[4].config,
      disabled
    }
  });
  return {
    c() {
      create_component(sieveruleseditorv2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv2_changes = {};
      if (dirty & 16)
        sieveruleseditorv2_changes.config = ctx2[4].config;
      sieveruleseditorv2.$set(sieveruleseditorv2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv2, detaching);
    }
  };
}
function create_if_block_3$k(ctx) {
  let sieveruleseditorv1;
  let current;
  sieveruleseditorv1 = new SieveRulesEditorV1({
    props: {
      config: ctx[4].config,
      disabled
    }
  });
  return {
    c() {
      create_component(sieveruleseditorv1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv1_changes = {};
      if (dirty & 16)
        sieveruleseditorv1_changes.config = ctx2[4].config;
      sieveruleseditorv1.$set(sieveruleseditorv1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv1, detaching);
    }
  };
}
function create_default_slot$x(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_3$k, create_if_block_4$c];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (ctx2[5] === V1$1)
      return 0;
    if (ctx2[5] === V2$1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_3(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "overflow-auto max-h-[200px] px-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_2$l(ctx) {
  let t;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      classes: ctx[6],
      result: ctx[4].config.rule.result
    }
  });
  return {
    c() {
      t = text("(V2) ");
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 16)
        ruleresult_changes.result = ctx2[4].config.rule.result;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_if_block_1$t(ctx) {
  let t;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      classes: ctx[6],
      result: ctx[4].config.fields.result.get()
    }
  });
  return {
    c() {
      t = text("(V1) ");
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 16)
        ruleresult_changes.result = ctx2[4].config.fields.result.get();
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_header_slot$9(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_1$t, create_if_block_2$l];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[5] === V1$1)
      return 0;
    if (ctx2[5] === V2$1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_2(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      t = text("Monitor\n        ");
      if (if_block)
        if_block.c();
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_fragment$1s(ctx) {
  var _a, _b, _c, _d;
  let div0;
  let t1;
  let t2;
  let div1;
  let t3;
  let current;
  let if_block0 = !((_a = ctx[3]) == null ? void 0 : _a.config) && !((_b = ctx[4]) == null ? void 0 : _b.config) && create_if_block_10();
  let if_block1 = ((_c = ctx[3]) == null ? void 0 : _c.config) && create_if_block_5$6(ctx);
  let if_block2 = ((_d = ctx[4]) == null ? void 0 : _d.config) && create_if_block$K(ctx);
  return {
    c() {
      div0 = element("div");
      div0.textContent = "Conditions";
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "fw-bold f5 mt2 mb2");
      attr(div1, "class", "col-md-12");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2;
      if (!((_a2 = ctx2[3]) == null ? void 0 : _a2.config) && !((_b2 = ctx2[4]) == null ? void 0 : _b2.config)) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_10();
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((_c2 = ctx2[3]) == null ? void 0 : _c2.config) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if ((_d2 = ctx2[4]) == null ? void 0 : _d2.config) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$K(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
let disabled = true;
function instance$1p($$self, $$props, $$invalidate) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  let $globalRule, $$unsubscribe_globalRule = noop, $$subscribe_globalRule = () => ($$unsubscribe_globalRule(), $$unsubscribe_globalRule = subscribe(globalRule, ($$value) => $$invalidate(3, $globalRule = $$value)), globalRule);
  let $sieveRule, $$unsubscribe_sieveRule = noop, $$subscribe_sieveRule = () => ($$unsubscribe_sieveRule(), $$unsubscribe_sieveRule = subscribe(sieveRule, ($$value) => $$invalidate(4, $sieveRule = $$value)), sieveRule);
  $$self.$$.on_destroy.push(() => $$unsubscribe_globalRule());
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieveRule());
  let { model } = $$props;
  let { context } = $$props;
  const meta = model.get("meta");
  const ruleData = meta.rule || meta.rules;
  const sieveConfig = (_b = (_a = ruleData == null ? void 0 : ruleData.sieve) == null ? void 0 : _a.rules) != null ? _b : null;
  const sieveVersion = (_d = (_c = ruleData == null ? void 0 : ruleData.sieve) == null ? void 0 : _c.version) != null ? _d : null;
  const globalConfig = (_g = (_f = (_e = ruleData == null ? void 0 : ruleData.global) == null ? void 0 : _e.rules) == null ? void 0 : _f.rule) != null ? _g : null;
  let globalVersion;
  if (globalConfig) {
    globalVersion = (_i = (_h = ruleData == null ? void 0 : ruleData.global) == null ? void 0 : _h.version) != null ? _i : V1$1;
  }
  let sieveRule = null;
  $$subscribe_sieveRule();
  let globalRule = null;
  $$subscribe_globalRule();
  const vars = {
    "$diff.new": context.inserts,
    "$diff.old": context.dels,
    $new: context.sieve_data.text,
    $old: ((_j = context.old_sieve_data) == null ? void 0 : _j.text) || ""
  };
  if (sieveConfig && sieveVersion) {
    const defaultRule2 = sieveVersion === V1$1 ? sieveConfig.rules.length > 0 : sieveConfig.rules.length > 1;
    if (defaultRule2) {
      $$subscribe_sieveRule(sieveRule = new Model$2.SieveRule(
        {
          config: sieveConfig,
          version: sieveVersion
        },
        { parse: true }
      ));
      if (sieveVersion === V1$1) {
        $sieveRule.config.evaluate(context, sieveConfig.numberFormat);
      } else if (sieveVersion === V2$1) {
        $sieveRule.config.evaluate(vars, sieveConfig.numberFormat);
      }
    }
  }
  if (globalConfig && globalVersion) {
    const defaultRule2 = globalVersion === V1$1 ? globalConfig.rules.length > 0 : globalConfig.rules.length > 1;
    if (defaultRule2) {
      $$subscribe_globalRule(globalRule = new Model$2.SieveRule(
        {
          config: globalConfig,
          version: globalVersion
        },
        { parse: true }
      ));
      if (globalVersion === V1$1) {
        $globalRule.config.evaluate(context, globalConfig.numberFormat);
      } else if (globalVersion === V2$1) {
        $globalRule.config.evaluate(vars, globalConfig.numberFormat);
      }
    }
  }
  const classes2 = {
    true: "text-bg-success",
    false: "text-bg-danger"
  };
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(7, model = $$props2.model);
    if ("context" in $$props2)
      $$invalidate(8, context = $$props2.context);
  };
  return [
    globalVersion,
    sieveRule,
    globalRule,
    $globalRule,
    $sieveRule,
    sieveVersion,
    classes2,
    model,
    context
  ];
}
class Preview extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1p, create_fragment$1s, safe_not_equal, { model: 7, context: 8 });
  }
}
var browser = Worker;
class DiffWorker {
  constructor({ url, module = true } = {}) {
    this.url = url;
    this.module = module;
    this.promises = {};
    this.ready = false;
  }
  async init() {
    this.worker = new browser(this.url, { type: this.module ? "module" : "classic" });
    this.attachListener();
    await this.ping();
    this.ready = true;
  }
  attachListener() {
    this.worker.addEventListener("message", (event) => {
      const [id2, result] = event.data;
      const { resolve, reject } = this.promises[id2];
      delete this.promises[id2];
      if (result.error) {
        return reject(new Error(result.error));
      }
      resolve(result);
    });
  }
  async postMessage(args) {
    const id2 = Date.now();
    args.push(id2);
    this.worker.postMessage(args);
    return new Promise((resolve, reject) => this.promises[id2] = { resolve, reject });
  }
  async diff(data1, data2, opts) {
    return this.postMessage(["diff", [data1, data2, opts]]);
  }
  async diffAndRender(data1, data2, opts) {
    return this.postMessage(["diffAndRender", [data1, data2, opts]]);
  }
  async diffAndRenderEmail(data1, data2, opts) {
    return this.postMessage(["diffAndRenderEmail", [data1, data2, opts]]);
  }
  async ping() {
    return this.postMessage(["ping", null]);
  }
}
globalThis.DiffWorker = DiffWorker;
let _$2 = window._;
const worker = new DiffWorker({ url: `/lib/worker.mjs` });
async function getDiff(previousText, newText) {
  if (!worker.ready) {
    await worker.init();
  }
  let addedText = "";
  let deletedText = "";
  let context;
  const DIFF_DELETE = -1;
  const DIFF_INSERT = 1;
  const diff2 = await worker.diff(previousText, newText, { type: "text" });
  addedText = _$2.reduce(
    diff2,
    function(buff, aDiff) {
      if (aDiff[0] == DIFF_INSERT) {
        buff.push(aDiff[1]);
      }
      return buff;
    },
    []
  ).join(" ");
  deletedText = _$2.reduce(
    diff2,
    function(buff, aDiff) {
      if (aDiff[0] == DIFF_DELETE) {
        buff.push(aDiff[1]);
      }
      return buff;
    },
    []
  ).join(" ");
  context = {
    sieve_data: { text: newText },
    old_sieve_data: { text: previousText },
    inserts: addedText,
    dels: deletedText
  };
  return { addedText, deletedText, context };
}
function create_catch_block$a(ctx) {
  let p;
  let t0;
  let t1_value = ctx[16].message + "";
  let t1;
  return {
    c() {
      p = element("p");
      t0 = text("Cannot generate the diff: ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_then_block$a(ctx) {
  let div6;
  let div1;
  let div0;
  let span0;
  let t1;
  let span1;
  let t3;
  let textarea0;
  let t4;
  let div3;
  let div2;
  let span2;
  let t6;
  let span3;
  let t8;
  let textarea1;
  let t9;
  let div5;
  let h6;
  let t11;
  let div4;
  let t12;
  let accordion0;
  let t13;
  let accordion1;
  let t14;
  let div7;
  let t15;
  let if_block_anchor;
  let current;
  accordion0 = new Accordion({
    props: {
      id: "AddedText",
      show: true,
      class: "pb-1",
      $$slots: {
        header: [create_header_slot_1$1],
        default: [create_default_slot_1$g]
      },
      $$scope: { ctx }
    }
  });
  accordion1 = new Accordion({
    props: {
      id: "DeletedText",
      show: true,
      $$slots: {
        header: [create_header_slot$8],
        default: [create_default_slot$w]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[3] && create_if_block$J(ctx);
  return {
    c() {
      div6 = element("div");
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "Previous Text";
      t1 = space();
      span1 = element("span");
      span1.textContent = `${new Date(ctx[6]).toLocaleString()}`;
      t3 = space();
      textarea0 = element("textarea");
      t4 = space();
      div3 = element("div");
      div2 = element("div");
      span2 = element("span");
      span2.textContent = "Text";
      t6 = space();
      span3 = element("span");
      span3.textContent = `${new Date(ctx[7]).toLocaleString()}`;
      t8 = space();
      textarea1 = element("textarea");
      t9 = space();
      div5 = element("div");
      h6 = element("h6");
      h6.textContent = "Variables";
      t11 = space();
      div4 = element("div");
      t12 = space();
      create_component(accordion0.$$.fragment);
      t13 = space();
      create_component(accordion1.$$.fragment);
      t14 = space();
      div7 = element("div");
      t15 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span0, "class", "f5 px-2 fw-bold");
      attr(span1, "class", "f6 px-2");
      attr(div0, "class", "flex pb1 border-bottom justify-content-between");
      attr(textarea0, "class", "pa2 w-100 border-0 f6 h-[200px]");
      textarea0.disabled = true;
      textarea0.value = ctx[4];
      attr(div1, "class", "col-md-4 border-end px-0");
      attr(span2, "class", "f5 px-2 fw-bold");
      attr(span3, "class", "f6 px-2");
      attr(div2, "class", "flex pb1 border-bottom justify-content-between");
      attr(textarea1, "class", "pa2 w-100 border-0 f6 h-[200px]");
      textarea1.disabled = true;
      textarea1.value = ctx[5];
      attr(div3, "class", "col-md-4 border-end px-0");
      attr(h6, "class", "f5 px-2 fw-bold");
      attr(div4, "class", "border-top");
      attr(div5, "class", "col-md-4 px-1");
      attr(div6, "class", "row");
      attr(div7, "class", "border-top");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div1);
      append(div1, div0);
      append(div0, span0);
      append(div0, t1);
      append(div0, span1);
      append(div1, t3);
      append(div1, textarea0);
      append(div6, t4);
      append(div6, div3);
      append(div3, div2);
      append(div2, span2);
      append(div2, t6);
      append(div2, span3);
      append(div3, t8);
      append(div3, textarea1);
      append(div6, t9);
      append(div6, div5);
      append(div5, h6);
      append(div5, t11);
      append(div5, div4);
      append(div5, t12);
      mount_component(accordion0, div5, null);
      append(div5, t13);
      mount_component(accordion1, div5, null);
      insert(target, t14, anchor);
      insert(target, div7, anchor);
      insert(target, t15, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion0_changes = {};
      if (dirty & 131074) {
        accordion0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion0.$set(accordion0_changes);
      const accordion1_changes = {};
      if (dirty & 131076) {
        accordion1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion1.$set(accordion1_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$J(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion0.$$.fragment, local);
      transition_in(accordion1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(accordion0.$$.fragment, local);
      transition_out(accordion1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component(accordion0);
      destroy_component(accordion1);
      if (detaching)
        detach(t14);
      if (detaching)
        detach(div7);
      if (detaching)
        detach(t15);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_3(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "<Empty>";
      attr(span, "class", "alert alert-light p-0 px-1 code");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_3$j(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[1].length > 120)
      return create_if_block_4$b;
    return create_else_block_2$1;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_2$1(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_4$b(ctx) {
  let t0_value = ctx[1].substring(0, 120) + "";
  let t0;
  let t1;
  let a;
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      t2 = text("Show more");
      attr(a, "tabindex", "0");
      attr(a, "class", "d-block");
      attr(a, "role", "button");
      attr(a, "data-bs-toggle", "popover");
      attr(a, "data-bs-custom-class", "scrollable-popover");
      attr(a, "data-bs-title", "Added Text");
      attr(a, "data-bs-placement", "right");
      attr(a, "data-bs-content", ctx[1]);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, a, anchor);
      append(a, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].substring(0, 120) + ""))
        set_data(t0, t0_value);
      if (dirty & 2) {
        attr(a, "data-bs-content", ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(a);
    }
  };
}
function create_default_slot_1$g(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block_3$j;
    return create_else_block_3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "pa1 f6 w-100 overflow-hidden");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_header_slot_1$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Added Text";
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block_1$b(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "<Empty>";
      attr(span, "class", "alert alert-light p-0 px-1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$s(ctx) {
  let if_block_anchor;
  function select_block_type_3(ctx2, dirty) {
    if (ctx2[2].length > 120)
      return create_if_block_2$k;
    return create_else_block$z;
  }
  let current_block_type = select_block_type_3(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$z(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$k(ctx) {
  let t0_value = ctx[2].substring(0, 120) + "";
  let t0;
  let t1;
  let a;
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      t2 = text("Show more");
      attr(a, "tabindex", "0");
      attr(a, "class", "d-block");
      attr(a, "role", "button");
      attr(a, "data-bs-toggle", "popover");
      attr(a, "data-bs-custom-class", "scrollable-popover");
      attr(a, "data-bs-title", "Deleted Text");
      attr(a, "data-bs-placement", "right");
      attr(a, "data-bs-content", ctx[2]);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, a, anchor);
      append(a, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[2].substring(0, 120) + ""))
        set_data(t0, t0_value);
      if (dirty & 4) {
        attr(a, "data-bs-content", ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(a);
    }
  };
}
function create_default_slot$w(ctx) {
  let div;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block_1$s;
    return create_else_block_1$b;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "pa1 f6 w-100 overflow-hidden");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_header_slot$8(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Deleted Text";
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$J(ctx) {
  let sieverules;
  let current;
  sieverules = new Preview({
    props: {
      model: ctx[0],
      context: ctx[3]
    }
  });
  return {
    c() {
      create_component(sieverules.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieverules, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieverules_changes = {};
      if (dirty & 1)
        sieverules_changes.model = ctx2[0];
      if (dirty & 8)
        sieverules_changes.context = ctx2[3];
      sieverules.$set(sieverules_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieverules.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieverules.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieverules, detaching);
    }
  };
}
function create_pending_block$a(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$1r(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$a,
    then: create_then_block$a,
    catch: create_catch_block$a,
    value: 15,
    error: 16,
    blocks: [, , ,]
  };
  handle_promise(ctx[8], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1o($$self, $$props, $$invalidate) {
  let { model } = $$props;
  let { oldModel } = $$props;
  const previousText = oldModel.get("text");
  const newText = model.get("text");
  const oldSieveDate = oldModel.get("ts_mod");
  const newSieveDate = model.get("ts_mod");
  let addedText = "";
  let deletedText = "";
  let context;
  let res, rej;
  let diffResponsePromise = new Promise((_res, _rej) => {
    res = _res;
    rej = _rej;
  });
  async function loadDiff() {
    try {
      const diffResult = await getDiff(previousText, newText);
      $$invalidate(1, addedText = diffResult.addedText);
      $$invalidate(2, deletedText = diffResult.deletedText);
      $$invalidate(3, context = diffResult.context);
      res();
    } catch (e) {
      console.error("cannot get the diff", oldModel.id, model.id, e);
      rej(e);
    }
  }
  loadDiff();
  let popoverTriggerList = [];
  function clickEvent(event) {
    const target = event.target;
    popoverTriggerList.forEach((popoverInstance) => {
      if (popoverInstance._isShown() && !popoverInstance.tip.contains(target)) {
        popoverInstance.hide();
      }
    });
  }
  onMount(async () => {
    try {
      await diffResponsePromise;
      popoverTriggerList = Array.from(document.querySelectorAll('[data-bs-toggle="popover"]')).map((popoverTriggerEl) => new bootstrap.Popover(popoverTriggerEl, { container: ".modal" }));
      document.addEventListener("click", clickEvent);
    } catch (e) {
      console.error("error in onMount", e);
    }
  });
  onDestroy(() => {
    document.removeEventListener("click", clickEvent);
  });
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
    if ("oldModel" in $$props2)
      $$invalidate(9, oldModel = $$props2.oldModel);
  };
  return [
    model,
    addedText,
    deletedText,
    context,
    previousText,
    newText,
    oldSieveDate,
    newSieveDate,
    diffResponsePromise,
    oldModel
  ];
}
class SieveRuleDebugger extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1o, create_fragment$1r, safe_not_equal, { model: 0, oldModel: 9 });
  }
}
function create_fragment$1q(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { fill: "none" },
    { viewBox: "0 0 24 24" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M9.35442 21C10.0596 21.6224 10.9858 22 12.0002 22C13.0147 22 13.9409 21.6224 14.6461 21M2.29414 5.81989C2.27979 4.36854 3.06227 3.01325 4.32635 2.3M21.7024 5.8199C21.7167 4.36855 20.9342 3.01325 19.6702 2.3M18.0002 8C18.0002 6.4087 17.3681 4.88258 16.2429 3.75736C15.1177 2.63214 13.5915 2 12.0002 2C10.4089 2 8.88283 2.63214 7.75761 3.75736C6.63239 4.88258 6.00025 6.4087 6.00025 8C6.00025 11.0902 5.22072 13.206 4.34991 14.6054C3.61538 15.7859 3.24811 16.3761 3.26157 16.5408C3.27649 16.7231 3.31511 16.7926 3.46203 16.9016C3.59471 17 4.19284 17 5.3891 17H18.6114C19.8077 17 20.4058 17 20.5385 16.9016C20.6854 16.7926 20.724 16.7231 20.7389 16.5408C20.7524 16.3761 20.3851 15.7859 19.6506 14.6054C18.7798 13.206 18.0002 11.0902 18.0002 8Z");
      attr(path, "stroke", "#000000");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        { viewBox: "0 0 24 24" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$1n($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class BellOn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1n, create_fragment$1q, safe_not_equal, {});
  }
}
function create_fragment$1p(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 24 24" },
    { fill: "none" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M8.63306 3.03371C9.61959 2.3649 10.791 2 12 2C13.5913 2 15.1174 2.63214 16.2426 3.75736C17.3679 4.88258 18 6.4087 18 8C18 10.1008 18.2702 11.7512 18.6484 13.0324M6.25867 6.25724C6.08866 6.81726 6 7.40406 6 8C6 11.0902 5.22047 13.206 4.34966 14.6054C3.61513 15.7859 3.24786 16.3761 3.26132 16.5408C3.27624 16.7231 3.31486 16.7926 3.46178 16.9016C3.59446 17 4.19259 17 5.38885 17H17M9.35418 21C10.0593 21.6224 10.9856 22 12 22C13.0144 22 13.9407 21.6224 14.6458 21M21 21L3 3");
      attr(path, "stroke", "#000000");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 24 24" },
        { fill: "none" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$1m($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class BellOff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1m, create_fragment$1p, safe_not_equal, {});
  }
}
function create_default_slot$v(ctx) {
  let sieveruledebugger;
  let current;
  sieveruledebugger = new SieveRuleDebugger({
    props: {
      model: ctx[0],
      oldModel: ctx[1]
    }
  });
  return {
    c() {
      create_component(sieveruledebugger.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruledebugger, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruledebugger_changes = {};
      if (dirty & 1)
        sieveruledebugger_changes.model = ctx2[0];
      if (dirty & 2)
        sieveruledebugger_changes.oldModel = ctx2[1];
      sieveruledebugger.$set(sieveruledebugger_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruledebugger.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruledebugger.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruledebugger, detaching);
    }
  };
}
function create_else_block$y(ctx) {
  let t;
  let belloff;
  let current;
  belloff = new BellOff({ props: { class: "h-5 w-5" } });
  return {
    c() {
      t = text("Notification not triggered\n        ");
      create_component(belloff.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(belloff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(belloff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(belloff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(belloff, detaching);
    }
  };
}
function create_if_block$I(ctx) {
  let t;
  let bellon;
  let current;
  bellon = new BellOn({ props: { class: "h-5 w-5" } });
  return {
    c() {
      t = text("Notification triggered\n        ");
      create_component(bellon.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(bellon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(bellon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bellon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(bellon, detaching);
    }
  };
}
function create_sub_header_slot(ctx) {
  let h4;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$I, create_else_block$y];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      h4 = element("h4");
      if_block.c();
      attr(h4, "class", "mb-0");
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      if_blocks[current_block_type_index].m(h4, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h4);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_fragment$1o(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      isDialog: false,
      labelClose: ctx[2],
      scrollable: true,
      $$slots: {
        "sub-header": [create_sub_header_slot],
        default: [create_default_slot$v]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[4]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 35) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$1l($$self, $$props, $$invalidate) {
  let { model } = $$props;
  let { oldModel } = $$props;
  let labelClose = T("a_close");
  const triggered = model.get("triggered");
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
    if ("oldModel" in $$props2)
      $$invalidate(1, oldModel = $$props2.oldModel);
  };
  return [model, oldModel, labelClose, triggered, close_handler];
}
class SieveRuleDebuggerModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1l, create_fragment$1o, safe_not_equal, { model: 0, oldModel: 1 });
  }
}
var DiffBar_svelte_svelte_type_style_lang = "";
function create_else_block_1$a(ctx) {
  let belloff;
  let current;
  belloff = new BellOff({ props: { class: "h-4 w-4" } });
  return {
    c() {
      create_component(belloff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(belloff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(belloff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(belloff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(belloff, detaching);
    }
  };
}
function create_if_block_4$a(ctx) {
  let bellon;
  let current;
  bellon = new BellOn({ props: { class: "h-4 w-4" } });
  return {
    c() {
      create_component(bellon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bellon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(bellon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bellon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(bellon, detaching);
    }
  };
}
function create_else_block$x(ctx) {
  let div0;
  let span0;
  let t0;
  let t1;
  let t2;
  let span1;
  let t3;
  let t4;
  let t5;
  let div1;
  let input;
  let t6;
  let label;
  let mounted;
  let dispose;
  return {
    c() {
      div0 = element("div");
      span0 = element("span");
      t0 = text(ctx[2]);
      t1 = text(" new,");
      t2 = space();
      span1 = element("span");
      t3 = text(ctx[3]);
      t4 = text(" updated");
      t5 = space();
      div1 = element("div");
      input = element("input");
      t6 = space();
      label = element("label");
      label.textContent = `${T("Deleted")}`;
      attr(span0, "class", "text-[0.9em]");
      set_style(span0, "font-weight", "bold");
      attr(span1, "class", "text-[0.9em]");
      set_style(span1, "font-weight", "bold");
      attr(span1, "title", "Shows the number of new and updated feeds");
      attr(div0, "class", "btn px-[6px] xpopup self-center");
      attr(div0, "title", "Shows the number of new and updated feeds");
      attr(input, "class", "xremoved");
      set_style(input, "margin", "0px");
      attr(input, "type", "checkbox");
      input.disabled = ctx[10];
      attr(label, "class", "text-[0.9em] select-none m-0");
      attr(div1, "class", "flex items-center gap-1");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, span0);
      append(span0, t0);
      append(span0, t1);
      append(div0, t2);
      append(div0, span1);
      append(span1, t3);
      append(span1, t4);
      insert(target, t5, anchor);
      insert(target, div1, anchor);
      append(div1, input);
      input.checked = ctx[0];
      append(div1, t6);
      append(div1, label);
      if (!mounted) {
        dispose = listen(input, "change", ctx[21]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t0, ctx2[2]);
      if (dirty & 8)
        set_data(t3, ctx2[3]);
      if (dirty & 1024) {
        input.disabled = ctx2[10];
      }
      if (dirty & 1) {
        input.checked = ctx2[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$j(ctx) {
  let a;
  let t0;
  let span0;
  let t1;
  let t2;
  let t3;
  let span1;
  let t4;
  let t5;
  let t6;
  let show_if = [C$2.TYPE_DOC, C$2.TYPE_HTML, C$2.TYPE_PDF_HTML].includes(ctx[5].get("data_type"));
  let t7;
  let label0;
  let input0;
  let t8;
  let t9_value = T("Deleted") + "";
  let t9;
  let t10;
  let label1;
  let input1;
  let t11;
  let t12_value = T("Snipped") + "";
  let t12;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block_3$i(ctx);
  return {
    c() {
      a = element("a");
      t0 = text("Explore diff\n      ");
      span0 = element("span");
      t1 = text(ctx[2]);
      t2 = text("+");
      t3 = space();
      span1 = element("span");
      t4 = text(ctx[3]);
      t5 = text("\u2212");
      t6 = space();
      if (if_block)
        if_block.c();
      t7 = space();
      label0 = element("label");
      input0 = element("input");
      t8 = space();
      t9 = text(t9_value);
      t10 = space();
      label1 = element("label");
      input1 = element("input");
      t11 = space();
      t12 = text(t12_value);
      attr(span0, "class", "text-green-700 font-bold");
      attr(span1, "class", "text-red-700 font-bold");
      attr(a, "class", "btn btn-default btn-sm xpopup py-0 self-center px-2");
      attr(a, "target", "_blank");
      attr(a, "aria-disabled", ctx[10]);
      toggle_class(a, "disabled", ctx[10]);
      attr(input0, "class", "xremoved");
      set_style(input0, "vertical-align", "top");
      attr(input0, "type", "checkbox");
      input0.disabled = ctx[10];
      attr(label0, "class", "text-[0.9em] select-none m-0 flex items-center gap-1");
      attr(input1, "class", "xsnipped");
      set_style(input1, "vertical-align", "top");
      attr(input1, "type", "checkbox");
      input1.disabled = ctx[10];
      attr(label1, "class", "text-[0.9em] select-none m-0 flex items-center gap-1");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, span0);
      append(span0, t1);
      append(span0, t2);
      append(a, t3);
      append(a, span1);
      append(span1, t4);
      append(span1, t5);
      insert(target, t6, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t7, anchor);
      insert(target, label0, anchor);
      append(label0, input0);
      input0.checked = ctx[0];
      append(label0, t8);
      append(label0, t9);
      insert(target, t10, anchor);
      insert(target, label1, anchor);
      append(label1, input1);
      input1.checked = ctx[1];
      append(label1, t11);
      append(label1, t12);
      if (!mounted) {
        dispose = [
          listen(a, "click", ctx[15]),
          listen(input0, "change", ctx[19]),
          listen(input1, "change", ctx[20])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t1, ctx2[2]);
      if (dirty & 8)
        set_data(t4, ctx2[3]);
      if (dirty & 1024) {
        attr(a, "aria-disabled", ctx2[10]);
      }
      if (dirty & 1024) {
        toggle_class(a, "disabled", ctx2[10]);
      }
      if (dirty & 32)
        show_if = [C$2.TYPE_DOC, C$2.TYPE_HTML, C$2.TYPE_PDF_HTML].includes(ctx2[5].get("data_type"));
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$i(ctx2);
          if_block.c();
          if_block.m(t7.parentNode, t7);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 1024) {
        input0.disabled = ctx2[10];
      }
      if (dirty & 1) {
        input0.checked = ctx2[0];
      }
      if (dirty & 1024) {
        input1.disabled = ctx2[10];
      }
      if (dirty & 2) {
        input1.checked = ctx2[1];
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (detaching)
        detach(t6);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(label0);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(label1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3$i(ctx) {
  let div;
  let button0;
  let t0_value = T("l_visual") + "";
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2_value = T("l_text") + "";
  let t2;
  let button1_class_value;
  let t3;
  let button2;
  let t4_value = T("l_source") + "";
  let t4;
  let button2_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      button2 = element("button");
      t4 = text(t4_value);
      attr(button0, "class", button0_class_value = "btn btn-default btn-sm xpopup py-0 self-center ml1 " + (C$2.DIFF_MODE_VISUAL === ctx[7] ? "btn-primary min-w-0 active" : ""));
      attr(button1, "class", button1_class_value = "btn btn-default btn-sm xpopup py-0 self-center " + (C$2.DIFF_MODE_TEXT === ctx[7] ? "btn-primary min-w-0 active" : ""));
      toggle_class(button1, "active", C$2.DIFF_MODE_TEXT === ctx[7]);
      attr(button2, "class", button2_class_value = "btn btn-default btn-sm xpopup py-0 self-center " + (C$2.DIFF_MODE_SOURCE === ctx[7] ? "btn-primary min-w-0 active" : ""));
      toggle_class(button2, "active", C$2.DIFF_MODE_SOURCE === ctx[7]);
      attr(div, "class", "btn-group btn-toggle flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      append(div, t3);
      append(div, button2);
      append(button2, t4);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[16]),
          listen(button1, "click", ctx[17]),
          listen(button2, "click", ctx[18])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 128 && button0_class_value !== (button0_class_value = "btn btn-default btn-sm xpopup py-0 self-center ml1 " + (C$2.DIFF_MODE_VISUAL === ctx2[7] ? "btn-primary min-w-0 active" : ""))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty & 128 && button1_class_value !== (button1_class_value = "btn btn-default btn-sm xpopup py-0 self-center " + (C$2.DIFF_MODE_TEXT === ctx2[7] ? "btn-primary min-w-0 active" : ""))) {
        attr(button1, "class", button1_class_value);
      }
      if (dirty & 128) {
        toggle_class(button1, "active", C$2.DIFF_MODE_TEXT === ctx2[7]);
      }
      if (dirty & 128 && button2_class_value !== (button2_class_value = "btn btn-default btn-sm xpopup py-0 self-center " + (C$2.DIFF_MODE_SOURCE === ctx2[7] ? "btn-primary min-w-0 active" : ""))) {
        attr(button2, "class", button2_class_value);
      }
      if (dirty & 128) {
        toggle_class(button2, "active", C$2.DIFF_MODE_SOURCE === ctx2[7]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$r(ctx) {
  let explorediffmodal;
  let current;
  explorediffmodal = new ExploreDiffModal({ props: { model: ctx[5] } });
  explorediffmodal.$on("close", ctx[23]);
  return {
    c() {
      create_component(explorediffmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorediffmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorediffmodal_changes = {};
      if (dirty & 32)
        explorediffmodal_changes.model = ctx2[5];
      explorediffmodal.$set(explorediffmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorediffmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorediffmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorediffmodal, detaching);
    }
  };
}
function create_if_block$H(ctx) {
  let sieveruledebuggermodal;
  let current;
  sieveruledebuggermodal = new SieveRuleDebuggerModal({
    props: {
      model: ctx[5],
      oldModel: ctx[4]
    }
  });
  sieveruledebuggermodal.$on("close", ctx[24]);
  return {
    c() {
      create_component(sieveruledebuggermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruledebuggermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruledebuggermodal_changes = {};
      if (dirty & 32)
        sieveruledebuggermodal_changes.model = ctx2[5];
      if (dirty & 16)
        sieveruledebuggermodal_changes.oldModel = ctx2[4];
      sieveruledebuggermodal.$set(sieveruledebuggermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruledebuggermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruledebuggermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruledebuggermodal, detaching);
    }
  };
}
function create_fragment$1n(ctx) {
  let div;
  let button;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let diffprefsmenu;
  let t2;
  let t3;
  let if_block3_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_4$a, create_else_block_1$a];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[13])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[12])
      return create_if_block_2$j;
    return create_else_block$x;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  diffprefsmenu = new DiffPrefsMenu({
    props: {
      selectedDiffContentMode: ctx[7],
      contentType: ctx[5].get("data_type"),
      exploreDiffPath: ctx[6]
    }
  });
  diffprefsmenu.$on("applySelectedDiffContentMode", ctx[22]);
  let if_block2 = ctx[8] && create_if_block_1$r(ctx);
  let if_block3 = ctx[9] && create_if_block$H(ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      create_component(diffprefsmenu.$$.fragment);
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      attr(button, "class", "btn btn-default btn-sm px-1 py-0");
      attr(button, "title", ctx[13] ? "Notification Triggered" : "Notification Not Triggered");
      toggle_class(button, "disabled", ctx[10]);
      attr(div, "class", "xDiffBar flex items-center gap-1 h-[24px] br3 svelte-1ayg2i7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if_blocks[current_block_type_index].m(button, null);
      append(div, t0);
      if_block1.m(div, null);
      append(div, t1);
      mount_component(diffprefsmenu, div, null);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[14]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1024) {
        toggle_class(button, "disabled", ctx2[10]);
      }
      if_block1.p(ctx2, dirty);
      const diffprefsmenu_changes = {};
      if (dirty & 128)
        diffprefsmenu_changes.selectedDiffContentMode = ctx2[7];
      if (dirty & 32)
        diffprefsmenu_changes.contentType = ctx2[5].get("data_type");
      if (dirty & 64)
        diffprefsmenu_changes.exploreDiffPath = ctx2[6];
      diffprefsmenu.$set(diffprefsmenu_changes);
      if (ctx2[8]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$r(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[9]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 512) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$H(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(diffprefsmenu.$$.fragment, local);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(diffprefsmenu.$$.fragment, local);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if_block1.d();
      destroy_component(diffprefsmenu);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$1k($$self, $$props, $$invalidate) {
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { oldModel } = $$props;
  let { model } = $$props;
  let { removed } = $$props;
  let { snipped } = $$props;
  let { exploreDiffPath } = $$props;
  let { selectedDiffContentMode = C$2.DIFF_MODE_VISUAL } = $$props;
  getContext("api");
  const dispatch = createEventDispatcher();
  const feed = model.get("data_type") === C$2.TYPE_FEED;
  const triggered = model.get("triggered");
  let showExploreDiff = false;
  let showSieveRuleDebuggerModal = false;
  let disabled2 = false;
  const click_handler = () => $$invalidate(9, showSieveRuleDebuggerModal = true);
  const click_handler_1 = () => $$invalidate(8, showExploreDiff = true);
  const click_handler_2 = () => {
    dispatch("diffContentModeUpdate", { diffContentMode: C$2.DIFF_MODE_VISUAL });
  };
  const click_handler_3 = () => {
    dispatch("diffContentModeUpdate", { diffContentMode: C$2.DIFF_MODE_TEXT });
  };
  const click_handler_4 = () => {
    dispatch("diffContentModeUpdate", { diffContentMode: C$2.DIFF_MODE_SOURCE });
  };
  function input0_change_handler() {
    removed = this.checked;
    $$invalidate(0, removed);
  }
  function input1_change_handler() {
    snipped = this.checked;
    $$invalidate(1, snipped);
  }
  function input_change_handler() {
    removed = this.checked;
    $$invalidate(0, removed);
  }
  function applySelectedDiffContentMode_handler(event) {
    bubble.call(this, $$self, event);
  }
  const close_handler = () => $$invalidate(8, showExploreDiff = false);
  const close_handler_1 = () => $$invalidate(9, showSieveRuleDebuggerModal = false);
  $$self.$$set = ($$props2) => {
    if ("additions" in $$props2)
      $$invalidate(2, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(3, deletions = $$props2.deletions);
    if ("oldModel" in $$props2)
      $$invalidate(4, oldModel = $$props2.oldModel);
    if ("model" in $$props2)
      $$invalidate(5, model = $$props2.model);
    if ("removed" in $$props2)
      $$invalidate(0, removed = $$props2.removed);
    if ("snipped" in $$props2)
      $$invalidate(1, snipped = $$props2.snipped);
    if ("exploreDiffPath" in $$props2)
      $$invalidate(6, exploreDiffPath = $$props2.exploreDiffPath);
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(7, selectedDiffContentMode = $$props2.selectedDiffContentMode);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      $$invalidate(10, disabled2 = !additions && !deletions);
    }
  };
  return [
    removed,
    snipped,
    additions,
    deletions,
    oldModel,
    model,
    exploreDiffPath,
    selectedDiffContentMode,
    showExploreDiff,
    showSieveRuleDebuggerModal,
    disabled2,
    dispatch,
    feed,
    triggered,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    input0_change_handler,
    input1_change_handler,
    input_change_handler,
    applySelectedDiffContentMode_handler,
    close_handler,
    close_handler_1
  ];
}
class DiffBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1k, create_fragment$1n, safe_not_equal, {
      additions: 2,
      deletions: 3,
      oldModel: 4,
      model: 5,
      removed: 0,
      snipped: 1,
      exploreDiffPath: 6,
      selectedDiffContentMode: 7
    });
  }
}
function create_fragment$1m(ctx) {
  let div;
  let iframe_1;
  let iframe_1_class_value;
  let iframe_1_scrolling_value;
  return {
    c() {
      div = element("div");
      iframe_1 = element("iframe");
      attr(iframe_1, "class", iframe_1_class_value = "w-full border-none " + ctx[1]);
      attr(iframe_1, "style", ctx[3]);
      attr(iframe_1, "scrolling", iframe_1_scrolling_value = ctx[2] ? "" : "no");
      attr(iframe_1, "srcdoc", `<html><head><style class="xdistill"></style></head><body></body></html>`);
      set_style(iframe_1, "height", ctx[5]);
      attr(div, "class", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, iframe_1);
      ctx[14](iframe_1);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && iframe_1_class_value !== (iframe_1_class_value = "w-full border-none " + ctx2[1])) {
        attr(iframe_1, "class", iframe_1_class_value);
      }
      if (dirty & 8) {
        attr(iframe_1, "style", ctx2[3]);
      }
      if (dirty & 4 && iframe_1_scrolling_value !== (iframe_1_scrolling_value = ctx2[2] ? "" : "no")) {
        attr(iframe_1, "scrolling", iframe_1_scrolling_value);
      }
      const style_changed = dirty & 8;
      if (style_changed || dirty & 40) {
        set_style(iframe_1, "height", ctx2[5]);
      }
      if (dirty & 16) {
        attr(div, "class", ctx2[4]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[14](null);
    }
  };
}
function instance$1j($$self, $$props, $$invalidate) {
  const feeddiff2 = window.feeddiff;
  if (!feeddiff2) {
    throw new Error("ADD feeddiff");
  }
  let { oldData } = $$props;
  let { newData } = $$props;
  let { context } = $$props;
  let { diff: diff2 } = $$props;
  let { hideRemoved = false } = $$props;
  let { newFeedCount = 0 } = $$props;
  let { updatedFeedCount = 0 } = $$props;
  let { iframe } = $$props;
  let { iframeClass = "" } = $$props;
  let { showScrollBar } = $$props;
  let { iframeStyle = "" } = $$props;
  const dispatch = createEventDispatcher();
  let iframeDocEl;
  let loaded = false;
  let feedView;
  let height;
  let loadOff;
  let { class: classes2 = "" } = $$props;
  onMount(() => {
    $$invalidate(0, iframe.onload = onLoad, iframe);
    return () => {
      loadOff && loadOff();
      feedView && feedView.$destroy();
    };
  });
  function setIframeHeight() {
    const doc = iframe.contentWindow.document;
    const html2 = doc.documentElement;
    const body = doc.body;
    $$invalidate(5, height = Math.max(body.scrollHeight, body.offsetHeight, html2.clientHeight, html2.scrollHeight, html2.offsetHeight) + "px");
  }
  function showDiff() {
    feedView = new FeedList({
      target: iframeDocEl.querySelector("body"),
      props: { feedItems: diff2.changes }
    });
    setIframeHeight();
    loadOff = feedView.$on("load", setIframeHeight);
  }
  async function getDiff2(oldData2, newData2) {
    if (typeof oldData2 === "string") {
      oldData2 = JSON.parse(oldData2);
    }
    if (typeof newData2 === "string") {
      newData2 = JSON.parse(newData2);
    }
    const feedDict = {
      oldHashedFeed: oldData2,
      newHashedFeed: newData2
    };
    try {
      $$invalidate(6, diff2 = await feeddiff2.getUpdatedEntries(Diff.diffHtml, feedDict, context));
      if (diff2.changes.length == 0) {
        $$invalidate(6, diff2.changes = feedDict.newHashedFeed.entries, diff2);
      } else {
        $$invalidate(6, diff2.changes = diff2.newEntries.concat(diff2.updatedEntries), diff2);
      }
      $$invalidate(7, newFeedCount = diff2.newEntries.length);
      $$invalidate(8, updatedFeedCount = diff2.updatedEntries.length);
    } catch (e) {
      console.error("Error in update feed: ", e);
      Msg.error("Error finding changes in feed");
    }
  }
  function setDiffStyles() {
    const style = iframeDocEl.querySelector("style.xdistill");
    const styles = `
      ${diffStyles}
      body,h4{
        margin: 0;
        padding: 0;
      }
      img{
        margin-top:2px;
        margin-bottom:5px;
      }
      body{
        width:700px;
        margin:0 auto;
        padding:10px 10px;
      }
      .summary{
        padding-top:5px;
      }
      .wrapper{
       margin-bottom: 1rem;
       border-color: rgba(0,0,0,.2);
       border-bottom-style: solid;
       border-bottom-width: 1px;
      }
      .wrapper:last-child{
        border: none;
      }
      .mb2{
        margin-bottom: .5rem;
      }
      .black-80{
        color: rgba(0,0,0,.8);
      }
      .black-40{
        color: rgba(0,0,0,.4);
      }

      ${hideRemoved ? ".removed{display:none;}" : ""}
      `;
    style.innerHTML = styles;
    setIframeHeight();
  }
  async function onLoad() {
    iframeDocEl = iframe.contentDocument.documentElement;
    $$invalidate(13, loaded = true);
    dispatch("load");
  }
  function iframe_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframe = $$value;
      $$invalidate(0, iframe);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("oldData" in $$props2)
      $$invalidate(9, oldData = $$props2.oldData);
    if ("newData" in $$props2)
      $$invalidate(10, newData = $$props2.newData);
    if ("context" in $$props2)
      $$invalidate(11, context = $$props2.context);
    if ("diff" in $$props2)
      $$invalidate(6, diff2 = $$props2.diff);
    if ("hideRemoved" in $$props2)
      $$invalidate(12, hideRemoved = $$props2.hideRemoved);
    if ("newFeedCount" in $$props2)
      $$invalidate(7, newFeedCount = $$props2.newFeedCount);
    if ("updatedFeedCount" in $$props2)
      $$invalidate(8, updatedFeedCount = $$props2.updatedFeedCount);
    if ("iframe" in $$props2)
      $$invalidate(0, iframe = $$props2.iframe);
    if ("iframeClass" in $$props2)
      $$invalidate(1, iframeClass = $$props2.iframeClass);
    if ("showScrollBar" in $$props2)
      $$invalidate(2, showScrollBar = $$props2.showScrollBar);
    if ("iframeStyle" in $$props2)
      $$invalidate(3, iframeStyle = $$props2.iframeStyle);
    if ("class" in $$props2)
      $$invalidate(4, classes2 = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1536) {
      getDiff2(oldData, newData);
    }
    if ($$self.$$.dirty & 8256) {
      (diff2 == null ? void 0 : diff2.changes) && loaded && showDiff();
    }
    if ($$self.$$.dirty & 12352) {
      loaded && setDiffStyles();
    }
  };
  return [
    iframe,
    iframeClass,
    showScrollBar,
    iframeStyle,
    classes2,
    height,
    diff2,
    newFeedCount,
    updatedFeedCount,
    oldData,
    newData,
    context,
    hideRemoved,
    loaded,
    iframe_1_binding
  ];
}
class DiffFeedView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1j, create_fragment$1m, safe_not_equal, {
      oldData: 9,
      newData: 10,
      context: 11,
      diff: 6,
      hideRemoved: 12,
      newFeedCount: 7,
      updatedFeedCount: 8,
      iframe: 0,
      iframeClass: 1,
      showScrollBar: 2,
      iframeStyle: 3,
      class: 4
    });
  }
}
function create_else_block$w(ctx) {
  let label;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_1$q, create_if_block_2$i, create_if_block_3$h];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0].type == "bool")
      return 0;
    if (ctx2[0].type == "text" && ctx2[0].other)
      return 1;
    if (ctx2[0].type == "text")
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      label = element("label");
      if (if_block)
        if_block.c();
      attr(label, "class", "feedback-form-field-label font-normal items-center");
      set_style(label, "width", "100%");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(label, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(label, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(label);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block$G(ctx) {
  let enumgroup;
  let current;
  enumgroup = new EnumGroup({
    props: {
      def: ctx[0],
      field: ctx[1]
    }
  });
  return {
    c() {
      create_component(enumgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(enumgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const enumgroup_changes = {};
      if (dirty & 1)
        enumgroup_changes.def = ctx2[0];
      if (dirty & 2)
        enumgroup_changes.field = ctx2[1];
      enumgroup.$set(enumgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(enumgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(enumgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(enumgroup, detaching);
    }
  };
}
function create_if_block_3$h(ctx) {
  let t0_value = ctx[0].label + "";
  let t0;
  let t1;
  let div;
  let fieldwrapper;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[1],
      class: "form-control",
      $$slots: {
        default: [
          create_default_slot_1$f,
          ({ inputClasses, action, showError }) => ({ 4: inputClasses, 5: action, 6: showError }),
          ({ inputClasses, action, showError }) => (inputClasses ? 16 : 0) | (action ? 32 : 0) | (showError ? 64 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      div = element("div");
      create_component(fieldwrapper.$$.fragment);
      attr(div, "class", "flex flex-grow-1");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      mount_component(fieldwrapper, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].label + ""))
        set_data(t0, t0_value);
      const fieldwrapper_changes = {};
      if (dirty & 2)
        fieldwrapper_changes.field = ctx2[1];
      if (dirty & 210) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      destroy_component(fieldwrapper);
    }
  };
}
function create_if_block_2$i(ctx) {
  let div0;
  let input;
  let input_checked_value;
  let t0;
  let t1_value = ctx[0].label + "";
  let t1;
  let t2;
  let div1;
  let fieldwrapper;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[1],
      class: "form-control",
      $$slots: {
        default: [
          create_default_slot$u,
          ({ inputClasses, action, showError }) => ({ 4: inputClasses, 5: action, 6: showError }),
          ({ inputClasses, action, showError }) => (inputClasses ? 16 : 0) | (action ? 32 : 0) | (showError ? 64 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      create_component(fieldwrapper.$$.fragment);
      attr(input, "type", "checkbox");
      input.checked = input_checked_value = !!ctx[2];
      set_style(input, "border", "3px solid red");
      attr(div0, "class", "flex");
      attr(div1, "class", "flex flex-grow-1");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, input);
      append(div0, t0);
      append(div0, t1);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      mount_component(fieldwrapper, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 4 && input_checked_value !== (input_checked_value = !!ctx2[2])) {
        input.checked = input_checked_value;
      }
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0].label + ""))
        set_data(t1, t1_value);
      const fieldwrapper_changes = {};
      if (dirty & 2)
        fieldwrapper_changes.field = ctx2[1];
      if (dirty & 208) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
      destroy_component(fieldwrapper);
    }
  };
}
function create_if_block_1$q(ctx) {
  let input;
  let t0;
  let t1_value = ctx[0].label + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      attr(input, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[2];
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[3]),
          listen(input, "input", function() {
            if (is_function(ctx[1].setTouched))
              ctx[1].setTouched.apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4) {
        input.checked = ctx[2];
      }
      if (dirty & 1 && t1_value !== (t1_value = ctx[0].label + ""))
        set_data(t1, t1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_1$f(ctx) {
  let textarea;
  let textarea_class_value;
  let textarea_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "class", textarea_class_value = "flex-grow-1 " + ctx[4]);
      attr(textarea, "rows", "5");
      textarea.disabled = textarea_disabled_value = ctx[1].def.disabled;
      toggle_class(textarea, "is-invalid", ctx[6]);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (!mounted) {
        dispose = action_destroyer(ctx[5].call(null, textarea));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && textarea_class_value !== (textarea_class_value = "flex-grow-1 " + ctx2[4])) {
        attr(textarea, "class", textarea_class_value);
      }
      if (dirty & 2 && textarea_disabled_value !== (textarea_disabled_value = ctx2[1].def.disabled)) {
        textarea.disabled = textarea_disabled_value;
      }
      if (dirty & 80) {
        toggle_class(textarea, "is-invalid", ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$u(ctx) {
  let textarea;
  let textarea_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "class", textarea_class_value = "flex-grow-1 " + ctx[4]);
      attr(textarea, "rows", "2");
      toggle_class(textarea, "is-invalid", ctx[6]);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (!mounted) {
        dispose = action_destroyer(ctx[5].call(null, textarea));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && textarea_class_value !== (textarea_class_value = "flex-grow-1 " + ctx2[4])) {
        attr(textarea, "class", textarea_class_value);
      }
      if (dirty & 80) {
        toggle_class(textarea, "is-invalid", ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1l(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$G, create_else_block$w];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].type == "enum")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "feedback-form-field");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$1i($$self, $$props, $$invalidate) {
  let $field, $$unsubscribe_field = noop, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(2, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { def } = $$props;
  let { field } = $$props;
  $$subscribe_field();
  if (def.multi && def.dropdown) {
    def.options = def.options.map((el) => {
      return {
        ...el,
        selected: def.default === el.value
      };
    });
  }
  if (!def.label) {
    def.label = "";
  }
  function input_change_handler() {
    $field = this.checked;
    field.set($field);
  }
  $$self.$$set = ($$props2) => {
    if ("def" in $$props2)
      $$invalidate(0, def = $$props2.def);
    if ("field" in $$props2)
      $$subscribe_field($$invalidate(1, field = $$props2.field));
  };
  return [def, field, $field, input_change_handler];
}
class Field extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1i, create_fragment$1l, safe_not_equal, { def: 0, field: 1 });
  }
}
function get_each_context$p(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2][0];
  child_ctx[8] = list[i2][1];
  return child_ctx;
}
function create_if_block$F(ctx) {
  let small;
  let t_value = ctx[4].message + "";
  let t;
  return {
    c() {
      small = element("small");
      t = text(t_value);
      attr(small, "class", "error");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = ctx2[4].message + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_each_block$p(ctx) {
  let field;
  let current;
  field = new Field({
    props: {
      def: ctx[0].fields[ctx[7]],
      field: ctx[8]
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 3)
        field_changes.def = ctx2[0].fields[ctx2[7]];
      if (dirty & 2)
        field_changes.field = ctx2[8];
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
    }
  };
}
function create_fragment$1k(ctx) {
  let div;
  let h6;
  let t0_value = ctx[2] + 1 + "";
  let t0;
  let t1;
  let t2_value = ctx[0].label + "";
  let t2;
  let t3;
  let t4;
  let current;
  let if_block = ctx[3] && ctx[4] && create_if_block$F(ctx);
  let each_value = [...Object.entries(ctx[1].fields)];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$p(get_each_context$p(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      h6 = element("h6");
      t0 = text(t0_value);
      t1 = text(". ");
      t2 = text(t2_value);
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h6, "class", "d-flex justify-between font-bold leading-relaxed");
      attr(div, "class", "feedback-form ph3 pv2 xbg-2");
      set_style(div, "border-left", "1px solid " + (ctx[3] ? "red" : "transparent"));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h6);
      append(h6, t0);
      append(h6, t1);
      append(h6, t2);
      append(h6, t3);
      if (if_block)
        if_block.m(h6, null);
      append(div, t4);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 4) && t0_value !== (t0_value = ctx2[2] + 1 + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].label + ""))
        set_data(t2, t2_value);
      if (ctx2[3] && ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$F(ctx2);
          if_block.c();
          if_block.m(h6, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 3) {
        each_value = [...Object.entries(ctx2[1].fields)];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$p(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$p(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & 8) {
        set_style(div, "border-left", "1px solid " + (ctx2[3] ? "red" : "transparent"));
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1h($$self, $$props, $$invalidate) {
  let $showError;
  let $error;
  let { def } = $$props;
  let { model } = $$props;
  let { index: index2 } = $$props;
  const showError = model.showError;
  component_subscribe($$self, showError, (value) => $$invalidate(3, $showError = value));
  const error = model.error;
  component_subscribe($$self, error, (value) => $$invalidate(4, $error = value));
  $$self.$$set = ($$props2) => {
    if ("def" in $$props2)
      $$invalidate(0, def = $$props2.def);
    if ("model" in $$props2)
      $$invalidate(1, model = $$props2.model);
    if ("index" in $$props2)
      $$invalidate(2, index2 = $$props2.index);
  };
  return [def, model, index2, $showError, $error, showError, error];
}
class Form extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1h, create_fragment$1k, safe_not_equal, { def: 0, model: 1, index: 2 });
  }
}
const routeModuleList = [
  { id: "/teams/", label: "Teams" },
  { id: "/usage/", label: "Usage" },
  { id: "/crawlers/", label: "Crawlers" },
  { id: "/checks/", label: "Check Logs" },
  { id: "/settings/", label: "Settings" },
  { id: "/w/", label: "Watchlist" }
];
const feedbackOptions = [
  { id: "very positive", label: "Very Positive." },
  { id: "positive", label: "Positive." },
  { id: "neutral", label: "Neutral." },
  { id: "negative", label: "Negative." },
  { id: "very negative", label: "Very Negative." }
];
const suggestProductOptions = [
  { id: "extremely likely", label: "Extremely Likely." },
  { id: "very likely", label: "Very Likely." },
  { id: "neutral", label: "Neutral." },
  { id: "slightly likely", label: "Slightly likely." },
  { id: "not likely", label: "Not likely at all." }
];
const changeSummaryFeedbackOptions = {
  accurate: {
    type: "bool",
    label: "It does not present the original change accurately."
  },
  concise: {
    type: "bool",
    label: "It is not concise and clear."
  },
  hallucinate: {
    type: "bool",
    label: "It contains unrelated information."
  }
};
const other = {
  other: {
    type: "text",
    other: true,
    label: "Other"
  }
};
const product_recommend = {
  label: "How likely are you to recommend our product to others?",
  fields: {
    selected: {
      type: "enum",
      multi: false,
      dropdown: false,
      options: suggestProductOptions
    }
  },
  required: true
};
const commonfields = {
  didnt_work: {
    type: "bool",
    label: "Distill failed to perform as anticipated"
  },
  dont_need: {
    type: "bool",
    label: "I no longer need Distill"
  },
  ...other
};
const optionalFeedback = {
  likes: {
    label: "What did you like about Distill?",
    fields: {
      notes: {
        type: "text"
      }
    }
  }
};
const feedbackforms = {
  [C$2.FORM_DOWNGRADE]: {
    downgrade_reason: {
      label: "We're glad to know that you're staying with us! We'd like to understand why you decided to switch to a lower tier subscription and if there's anything we can do to improve your experience with Distill.",
      fields: {
        ...commonfields
      },
      required: true
    }
  },
  [C$2.FORM_CANCEL]: {
    cancel_reason: {
      label: "We're sorry to hear that you're considering cancelling your subscription. To help us improve our service, could you please let us know the reason for your cancellation by selecting from the options below?",
      fields: {
        ...commonfields
      },
      required: true
    },
    ...optionalFeedback
  },
  [C$2.FORM_ACCOUNT_CLOSE]: {
    close_reason: {
      label: "We're sorry to hear that you're considering closing your account. To help us improve our service, could you please let us know the reason for your decision to close your account?",
      fields: {
        ...commonfields
      },
      required: true
    },
    ...optionalFeedback
  },
  [C$2.FORM_EMAIL_ALERT]: {
    alert_issues: {
      label: "What issue are you facing with this email alert?",
      fields: {
        false_positive: {
          type: "bool",
          label: "It is a false alert."
        },
        late: {
          type: "bool",
          label: "Alert is late."
        },
        frequent: {
          type: "bool",
          label: "Alert is too frequent."
        },
        ...other
      },
      required: true
    },
    improvements: {
      label: "Would you like to make any suggestion that could enhance the dependability of email alerts?",
      fields: {
        notes: {
          type: "text"
        }
      }
    }
  },
  [C$2.FORM_APP_FEEDBACK]: {
    rating: {
      label: "How would you describe your overall satisfaction with Distill?",
      fields: {
        selected: {
          type: "enum",
          name: "rating",
          dropdown: false,
          multi: false,
          options: feedbackOptions
        }
      },
      required: true
    },
    module: {
      label: "My feedback is for:",
      fields: {
        context: {
          type: "enum",
          name: "module",
          dropdown: true,
          multi: false,
          options: routeModuleList,
          default: getCurrentRoute
        }
      }
    },
    improvements: {
      label: "Do you have any other feedback or suggestions for improving Distill?",
      fields: {
        notes: {
          type: "text"
        }
      }
    }
  },
  [C$2.FORM_CHANGELOG]: {
    feature_interest: {
      label: "Which new feature or update are you most excited about?",
      fields: {
        feature: {
          type: "text"
        }
      },
      required: true
    },
    feature_desc: {
      label: "Have you used any of the new features or updates? If so, what did you think of them?",
      fields: {
        feature: {
          type: "text"
        }
      },
      required: true
    },
    feature_suggest: {
      label: "Are there any features that you would like to see added or improved in future releases?",
      fields: {
        feature: {
          type: "text"
        }
      },
      required: true
    },
    feature_help: {
      label: "Were there any features that you found difficult to use or understand, or experienced any issues or bugs with? If so, please describe them",
      fields: {
        feature: {
          type: "text"
        }
      },
      required: true
    }
  },
  [C$2.FORM_DOCS]: {
    doc_help: {
      label: "Are there any areas of our product documentation that you find confusing or difficult to follow?",
      fields: {
        feature: {
          type: "text"
        }
      },
      required: true
    },
    docs_missing: {
      label: "Are there any topics or features that you feel are missing from our product documentation?",
      fields: {
        feature: {
          type: "text"
        }
      },
      required: true
    },
    docs_improvements: {
      label: "How can we improve our product documentation to better meet your needs?",
      fields: {
        feature: {
          type: "text"
        }
      },
      required: true
    },
    product_recommend
  },
  [C$2.FORM_CHANGE_SUMMARY]: ({ sieveData }) => ({
    rating: {
      label: "Please rate the summary",
      fields: {
        ...changeSummaryFeedbackOptions
      },
      required: true
    },
    suggested_change_summary: {
      label: "You can also provide a better summary for this change",
      fields: {
        original_change_summary: {
          label: "Change summary",
          type: "text",
          disabled: true,
          default: sieveData.change_summary
        },
        suggested_change_summary: {
          label: "Suggested change summary",
          type: "text"
        }
      },
      required: false
    }
  })
};
class Model$1 extends FormModel {
  constructor(defs2, required = false) {
    super(defs2);
    this.required = required;
  }
  validate(values) {
    if (this.required) {
      return !values.find((val) => !!val) ? { message: "*required" } : null;
    }
    return false;
  }
}
class FormGroupModel {
  constructor(formId, context) {
    this.initModel(formId, context);
  }
  initModel(formId, context) {
    this.formId = formId;
    this.formDef = feedbackforms[this.formId];
    if (_.isFunction(this.formDef)) {
      this.formDef = this.formDef(context);
    }
    this.forms = {};
    for (let formKey in this.formDef) {
      const fieldDefs = this.formDef[formKey].fields;
      this.forms[formKey] = new Model$1(fieldDefs, !!this.formDef[formKey].required);
    }
  }
  toJSON() {
    const json = {};
    Object.keys(this.formDef).forEach((key) => {
      json[key] = this.forms[key].toJSON();
    });
    return json;
  }
  async submit(_doc = {}) {
    let error;
    Object.values(this.forms).forEach((model) => {
      model.setTouched();
      error = error != null ? error : get_store_value(model.error);
    });
    if (error) {
      throw new Error(error);
    }
    let clientDetails = {
      type: C$2.CLIENT_WEB
    };
    if (Supports.agents.local) {
      clientDetails = {
        type: await Supports.agents.type(),
        clientId: await serviceProxy.clientId
      };
    }
    const doc = {
      params: {
        ..._doc,
        clientDetails,
        ...this.toJSON()
      }
    };
    await Api.api(`/public/forms/${this.formId}/submissions`, "POST", doc);
  }
}
function get_each_context$o(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2][0];
  child_ctx[5] = list[i2][1];
  child_ctx[7] = i2;
  return child_ctx;
}
function create_if_block$E(ctx) {
  let div;
  let current;
  let each_value = [...Object.entries(ctx[0].forms)];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$o(get_each_context$o(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "feedback-form-group flex flex-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = [...Object.entries(ctx2[0].forms)];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$o(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$o(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$o(ctx) {
  let form;
  let current;
  form = new Form({
    props: {
      def: ctx[0].formDef[ctx[4]],
      model: ctx[5],
      index: ctx[7]
    }
  });
  return {
    c() {
      create_component(form.$$.fragment);
    },
    m(target, anchor) {
      mount_component(form, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const form_changes = {};
      if (dirty & 1)
        form_changes.def = ctx2[0].formDef[ctx2[4]];
      if (dirty & 1)
        form_changes.model = ctx2[5];
      form.$set(form_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(form.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(form.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(form, detaching);
    }
  };
}
function create_fragment$1j(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block$E(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$E(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1g($$self, $$props, $$invalidate) {
  let { id: id2 } = $$props;
  let { model } = $$props;
  let { context } = $$props;
  const isFormEnabled = async () => {
    return await Api.api(`/public/forms/${id2}`, "GET");
  };
  model = null;
  isFormEnabled().then((res) => {
    $$invalidate(0, model = new FormGroupModel(id2, context));
    $$invalidate(0, model.formName = res.name, model);
  }).catch((err) => {
    console.error("Cannot fetch form:", id2, err);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(1, id2 = $$props2.id);
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
    if ("context" in $$props2)
      $$invalidate(2, context = $$props2.context);
  };
  return [model, id2, context];
}
class FormGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1g, create_fragment$1j, safe_not_equal, { id: 1, model: 0, context: 2 });
  }
}
function create_action_slot$1(ctx) {
  let a;
  let i2;
  let t0;
  let t1_value = ctx[17].format("MMM DD") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fa fa-caret-down f4");
      attr(a, "href", "#");
      attr(a, "data-bs-toggle", "dropdown");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i2);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[55]))
            ctx[55].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$e(ctx) {
  let li;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      li.textContent = `${T("Email")}`;
      attr(li, "class", "dropdown-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (!mounted) {
        dispose = listen(li, "click", ctx[21]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_6$2(ctx) {
  let div1;
  let strong;
  let t1;
  let div0;
  let t2_value = ctx[0].change_summary + "";
  let t2;
  let t3;
  let a;
  let t5;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[8] && create_if_block_7$1(ctx);
  return {
    c() {
      div1 = element("div");
      strong = element("strong");
      strong.textContent = "Change Summary";
      t1 = space();
      div0 = element("div");
      t2 = text(t2_value);
      t3 = space();
      a = element("a");
      a.textContent = "Feedback";
      t5 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(a, "class", "btn btn-sm btn-default");
      attr(div0, "class", "text-wrap");
      attr(div1, "class", "mt-8 x-callout x-callout-info");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, strong);
      append(div1, t1);
      append(div1, div0);
      append(div0, t2);
      append(div0, t3);
      append(div0, a);
      insert(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", ctx[28]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 1) && t2_value !== (t2_value = ctx2[0].change_summary + ""))
        set_data(t2, t2_value);
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t5);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7$1(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: T("l_feedback_form"),
      onSave: ctx[30],
      saveLabel: "Submit",
      $$slots: { default: [create_default_slot$t] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[31]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty[0] & 513 | dirty[1] & 33554432) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$t(ctx) {
  let formgroup;
  let updating_model;
  let current;
  function formgroup_model_binding(value) {
    ctx[29](value);
  }
  let formgroup_props = {
    context: { sieveData: ctx[0] },
    id: C$2.FORM_CHANGE_SUMMARY
  };
  if (ctx[9] !== void 0) {
    formgroup_props.model = ctx[9];
  }
  formgroup = new FormGroup({ props: formgroup_props });
  binding_callbacks.push(() => bind$2(formgroup, "model", formgroup_model_binding));
  return {
    c() {
      create_component(formgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formgroup_changes = {};
      if (dirty[0] & 1)
        formgroup_changes.context = { sieveData: ctx2[0] };
      if (!updating_model && dirty[0] & 512) {
        updating_model = true;
        formgroup_changes.model = ctx2[9];
        add_flush_callback(() => updating_model = false);
      }
      formgroup.$set(formgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formgroup, detaching);
    }
  };
}
function create_else_block$v(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "ERR! Unknown data type";
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_5$5(ctx) {
  let diffsitemapview;
  let updating_additions;
  let updating_deletions;
  let updating_diffView;
  let current;
  function diffsitemapview_additions_binding(value) {
    ctx[48](value);
  }
  function diffsitemapview_deletions_binding(value) {
    ctx[49](value);
  }
  function diffsitemapview_diffView_binding(value) {
    ctx[50](value);
  }
  let diffsitemapview_props = {
    newData: ctx[0].data,
    oldData: ctx[1].data,
    class: "max-h-[40vh] overflow-scroll max-w-[100%]",
    urlClass: "truncate max-w-[20vw]",
    pruneDeletions: !ctx[13],
    snipped: ctx[14]
  };
  if (ctx[4] !== void 0) {
    diffsitemapview_props.additions = ctx[4];
  }
  if (ctx[5] !== void 0) {
    diffsitemapview_props.deletions = ctx[5];
  }
  if (ctx[6] !== void 0) {
    diffsitemapview_props.diffView = ctx[6];
  }
  diffsitemapview = new DiffSitemapView({ props: diffsitemapview_props });
  binding_callbacks.push(() => bind$2(diffsitemapview, "additions", diffsitemapview_additions_binding));
  binding_callbacks.push(() => bind$2(diffsitemapview, "deletions", diffsitemapview_deletions_binding));
  binding_callbacks.push(() => bind$2(diffsitemapview, "diffView", diffsitemapview_diffView_binding));
  diffsitemapview.$on("load", ctx[51]);
  return {
    c() {
      create_component(diffsitemapview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffsitemapview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffsitemapview_changes = {};
      if (dirty[0] & 1)
        diffsitemapview_changes.newData = ctx2[0].data;
      if (dirty[0] & 2)
        diffsitemapview_changes.oldData = ctx2[1].data;
      if (dirty[0] & 8192)
        diffsitemapview_changes.pruneDeletions = !ctx2[13];
      if (dirty[0] & 16384)
        diffsitemapview_changes.snipped = ctx2[14];
      if (!updating_additions && dirty[0] & 16) {
        updating_additions = true;
        diffsitemapview_changes.additions = ctx2[4];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 32) {
        updating_deletions = true;
        diffsitemapview_changes.deletions = ctx2[5];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_diffView && dirty[0] & 64) {
        updating_diffView = true;
        diffsitemapview_changes.diffView = ctx2[6];
        add_flush_callback(() => updating_diffView = false);
      }
      diffsitemapview.$set(diffsitemapview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffsitemapview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffsitemapview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffsitemapview, detaching);
    }
  };
}
function create_if_block_4$9(ctx) {
  let diffjsonview;
  let updating_additions;
  let updating_deletions;
  let updating_diffView;
  let current;
  function diffjsonview_additions_binding(value) {
    ctx[44](value);
  }
  function diffjsonview_deletions_binding(value) {
    ctx[45](value);
  }
  function diffjsonview_diffView_binding(value) {
    ctx[46](value);
  }
  let diffjsonview_props = {
    newData: ctx[0].data,
    oldData: ctx[1].data,
    diffNavigation: false,
    full: !ctx[14],
    pruneDeletions: !ctx[13],
    showDirty: !ctx[14],
    class: "ml-20 pr-10 my-10 w-auto max-h-[40vh] overflow-scroll"
  };
  if (ctx[4] !== void 0) {
    diffjsonview_props.additions = ctx[4];
  }
  if (ctx[5] !== void 0) {
    diffjsonview_props.deletions = ctx[5];
  }
  if (ctx[6] !== void 0) {
    diffjsonview_props.diffView = ctx[6];
  }
  diffjsonview = new DiffJsonView({ props: diffjsonview_props });
  binding_callbacks.push(() => bind$2(diffjsonview, "additions", diffjsonview_additions_binding));
  binding_callbacks.push(() => bind$2(diffjsonview, "deletions", diffjsonview_deletions_binding));
  binding_callbacks.push(() => bind$2(diffjsonview, "diffView", diffjsonview_diffView_binding));
  diffjsonview.$on("load", ctx[47]);
  return {
    c() {
      create_component(diffjsonview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffjsonview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffjsonview_changes = {};
      if (dirty[0] & 1)
        diffjsonview_changes.newData = ctx2[0].data;
      if (dirty[0] & 2)
        diffjsonview_changes.oldData = ctx2[1].data;
      if (dirty[0] & 16384)
        diffjsonview_changes.full = !ctx2[14];
      if (dirty[0] & 8192)
        diffjsonview_changes.pruneDeletions = !ctx2[13];
      if (dirty[0] & 16384)
        diffjsonview_changes.showDirty = !ctx2[14];
      if (!updating_additions && dirty[0] & 16) {
        updating_additions = true;
        diffjsonview_changes.additions = ctx2[4];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 32) {
        updating_deletions = true;
        diffjsonview_changes.deletions = ctx2[5];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_diffView && dirty[0] & 64) {
        updating_diffView = true;
        diffjsonview_changes.diffView = ctx2[6];
        add_flush_callback(() => updating_diffView = false);
      }
      diffjsonview.$set(diffjsonview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffjsonview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffjsonview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffjsonview, detaching);
    }
  };
}
function create_if_block_3$g(ctx) {
  let diffxmlview;
  let updating_additions;
  let updating_deletions;
  let updating_iframe;
  let current;
  function diffxmlview_additions_binding(value) {
    ctx[40](value);
  }
  function diffxmlview_deletions_binding(value) {
    ctx[41](value);
  }
  function diffxmlview_iframe_binding(value) {
    ctx[42](value);
  }
  let diffxmlview_props = {
    newData: ctx[0].data,
    oldData: ctx[1].data,
    hideRemoved: !ctx[13],
    showScrollBar: true,
    snipped: ctx[14],
    iframeStyle: "max-height: calc(100vh - 200px);"
  };
  if (ctx[4] !== void 0) {
    diffxmlview_props.additions = ctx[4];
  }
  if (ctx[5] !== void 0) {
    diffxmlview_props.deletions = ctx[5];
  }
  if (ctx[6] !== void 0) {
    diffxmlview_props.iframe = ctx[6];
  }
  diffxmlview = new DiffXmlView({ props: diffxmlview_props });
  binding_callbacks.push(() => bind$2(diffxmlview, "additions", diffxmlview_additions_binding));
  binding_callbacks.push(() => bind$2(diffxmlview, "deletions", diffxmlview_deletions_binding));
  binding_callbacks.push(() => bind$2(diffxmlview, "iframe", diffxmlview_iframe_binding));
  diffxmlview.$on("load", ctx[43]);
  return {
    c() {
      create_component(diffxmlview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffxmlview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffxmlview_changes = {};
      if (dirty[0] & 1)
        diffxmlview_changes.newData = ctx2[0].data;
      if (dirty[0] & 2)
        diffxmlview_changes.oldData = ctx2[1].data;
      if (dirty[0] & 8192)
        diffxmlview_changes.hideRemoved = !ctx2[13];
      if (dirty[0] & 16384)
        diffxmlview_changes.snipped = ctx2[14];
      if (!updating_additions && dirty[0] & 16) {
        updating_additions = true;
        diffxmlview_changes.additions = ctx2[4];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 32) {
        updating_deletions = true;
        diffxmlview_changes.deletions = ctx2[5];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_iframe && dirty[0] & 64) {
        updating_iframe = true;
        diffxmlview_changes.iframe = ctx2[6];
        add_flush_callback(() => updating_iframe = false);
      }
      diffxmlview.$set(diffxmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffxmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffxmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffxmlview, detaching);
    }
  };
}
function create_if_block_2$h(ctx) {
  let difffeedview;
  let updating_iframe;
  let updating_newFeedCount;
  let updating_updatedFeedCount;
  let current;
  function difffeedview_iframe_binding(value) {
    ctx[36](value);
  }
  function difffeedview_newFeedCount_binding(value) {
    ctx[37](value);
  }
  function difffeedview_updatedFeedCount_binding(value) {
    ctx[38](value);
  }
  let difffeedview_props = {
    newData: ctx[0].data,
    oldData: ctx[1].data,
    context: ctx[10].id,
    hideRemoved: !ctx[13],
    showScrollBar: true,
    iframeStyle: "max-height: calc(100vh - 200px);"
  };
  if (ctx[6] !== void 0) {
    difffeedview_props.iframe = ctx[6];
  }
  if (ctx[5] !== void 0) {
    difffeedview_props.newFeedCount = ctx[5];
  }
  if (ctx[4] !== void 0) {
    difffeedview_props.updatedFeedCount = ctx[4];
  }
  difffeedview = new DiffFeedView({ props: difffeedview_props });
  binding_callbacks.push(() => bind$2(difffeedview, "iframe", difffeedview_iframe_binding));
  binding_callbacks.push(() => bind$2(difffeedview, "newFeedCount", difffeedview_newFeedCount_binding));
  binding_callbacks.push(() => bind$2(difffeedview, "updatedFeedCount", difffeedview_updatedFeedCount_binding));
  difffeedview.$on("load", ctx[39]);
  return {
    c() {
      create_component(difffeedview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(difffeedview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const difffeedview_changes = {};
      if (dirty[0] & 1)
        difffeedview_changes.newData = ctx2[0].data;
      if (dirty[0] & 2)
        difffeedview_changes.oldData = ctx2[1].data;
      if (dirty[0] & 1024)
        difffeedview_changes.context = ctx2[10].id;
      if (dirty[0] & 8192)
        difffeedview_changes.hideRemoved = !ctx2[13];
      if (!updating_iframe && dirty[0] & 64) {
        updating_iframe = true;
        difffeedview_changes.iframe = ctx2[6];
        add_flush_callback(() => updating_iframe = false);
      }
      if (!updating_newFeedCount && dirty[0] & 32) {
        updating_newFeedCount = true;
        difffeedview_changes.newFeedCount = ctx2[5];
        add_flush_callback(() => updating_newFeedCount = false);
      }
      if (!updating_updatedFeedCount && dirty[0] & 16) {
        updating_updatedFeedCount = true;
        difffeedview_changes.updatedFeedCount = ctx2[4];
        add_flush_callback(() => updating_updatedFeedCount = false);
      }
      difffeedview.$set(difffeedview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(difffeedview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(difffeedview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(difffeedview, detaching);
    }
  };
}
function create_if_block_1$p(ctx) {
  let diffhtmlview;
  let updating_additions;
  let updating_deletions;
  let updating_iframe;
  let current;
  function diffhtmlview_additions_binding(value) {
    ctx[32](value);
  }
  function diffhtmlview_deletions_binding(value) {
    ctx[33](value);
  }
  function diffhtmlview_iframe_binding(value) {
    ctx[34](value);
  }
  let diffhtmlview_props = {
    selectedDiffContentMode: ctx[3],
    newData: ctx[0],
    oldData: ctx[1],
    context: ctx[10].id,
    hideRemoved: !ctx[13],
    dynamicHeight: false,
    showScrollBar: true,
    iframeStyle: "max-height: calc(100vh - 200px);",
    snipped: ctx[14]
  };
  if (ctx[4] !== void 0) {
    diffhtmlview_props.additions = ctx[4];
  }
  if (ctx[5] !== void 0) {
    diffhtmlview_props.deletions = ctx[5];
  }
  if (ctx[6] !== void 0) {
    diffhtmlview_props.iframe = ctx[6];
  }
  diffhtmlview = new DiffHtmlView({ props: diffhtmlview_props });
  binding_callbacks.push(() => bind$2(diffhtmlview, "additions", diffhtmlview_additions_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview, "deletions", diffhtmlview_deletions_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview, "iframe", diffhtmlview_iframe_binding));
  diffhtmlview.$on("load", ctx[35]);
  return {
    c() {
      create_component(diffhtmlview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffhtmlview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffhtmlview_changes = {};
      if (dirty[0] & 8)
        diffhtmlview_changes.selectedDiffContentMode = ctx2[3];
      if (dirty[0] & 1)
        diffhtmlview_changes.newData = ctx2[0];
      if (dirty[0] & 2)
        diffhtmlview_changes.oldData = ctx2[1];
      if (dirty[0] & 1024)
        diffhtmlview_changes.context = ctx2[10].id;
      if (dirty[0] & 8192)
        diffhtmlview_changes.hideRemoved = !ctx2[13];
      if (dirty[0] & 16384)
        diffhtmlview_changes.snipped = ctx2[14];
      if (!updating_additions && dirty[0] & 16) {
        updating_additions = true;
        diffhtmlview_changes.additions = ctx2[4];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 32) {
        updating_deletions = true;
        diffhtmlview_changes.deletions = ctx2[5];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_iframe && dirty[0] & 64) {
        updating_iframe = true;
        diffhtmlview_changes.iframe = ctx2[6];
        add_flush_callback(() => updating_iframe = false);
      }
      diffhtmlview.$set(diffhtmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffhtmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffhtmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffhtmlview, detaching);
    }
  };
}
function create_if_block$D(ctx) {
  let emailselectmodal;
  let current;
  emailselectmodal = new EmailSelectModal({
    props: {
      sieve: ctx[2],
      model: ctx[10],
      diffView: ctx[6]
    }
  });
  emailselectmodal.$on("close", ctx[52]);
  return {
    c() {
      create_component(emailselectmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(emailselectmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const emailselectmodal_changes = {};
      if (dirty[0] & 4)
        emailselectmodal_changes.sieve = ctx2[2];
      if (dirty[0] & 1024)
        emailselectmodal_changes.model = ctx2[10];
      if (dirty[0] & 64)
        emailselectmodal_changes.diffView = ctx2[6];
      emailselectmodal.$set(emailselectmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(emailselectmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(emailselectmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(emailselectmodal, detaching);
    }
  };
}
function create_fragment$1i(ctx) {
  let div3;
  let div0;
  let a;
  let i2;
  let t0;
  let t1_value = ctx[17].format("hh:mm A") + "";
  let t1;
  let t2;
  let menu;
  let t3;
  let div2;
  let diffbar;
  let updating_additions;
  let updating_deletions;
  let updating_removed;
  let updating_snipped;
  let t4;
  let t5;
  let div1;
  let current_block_type_index;
  let if_block1;
  let t6;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  menu = new Menu$1({
    props: {
      $$slots: {
        default: [create_default_slot_1$e],
        action: [
          create_action_slot$1,
          ({ onClick }) => ({ 55: onClick }),
          ({ onClick }) => [0, onClick ? 16777216 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  function diffbar_additions_binding(value) {
    ctx[22](value);
  }
  function diffbar_deletions_binding(value) {
    ctx[23](value);
  }
  function diffbar_removed_binding(value) {
    ctx[24](value);
  }
  function diffbar_snipped_binding(value) {
    ctx[25](value);
  }
  let diffbar_props = {
    exploreDiffPath: ctx[15],
    model: ctx[10],
    oldModel: ctx[11],
    selectedDiffContentMode: ctx[3]
  };
  if (ctx[4] !== void 0) {
    diffbar_props.additions = ctx[4];
  }
  if (ctx[5] !== void 0) {
    diffbar_props.deletions = ctx[5];
  }
  if (ctx[13] !== void 0) {
    diffbar_props.removed = ctx[13];
  }
  if (ctx[14] !== void 0) {
    diffbar_props.snipped = ctx[14];
  }
  diffbar = new DiffBar({ props: diffbar_props });
  binding_callbacks.push(() => bind$2(diffbar, "additions", diffbar_additions_binding));
  binding_callbacks.push(() => bind$2(diffbar, "deletions", diffbar_deletions_binding));
  binding_callbacks.push(() => bind$2(diffbar, "removed", diffbar_removed_binding));
  binding_callbacks.push(() => bind$2(diffbar, "snipped", diffbar_snipped_binding));
  diffbar.$on("diffContentModeUpdate", ctx[26]);
  diffbar.$on("applySelectedDiffContentMode", ctx[27]);
  let if_block0 = ctx[0].change_summary && create_if_block_6$2(ctx);
  const if_block_creators = [
    create_if_block_1$p,
    create_if_block_2$h,
    create_if_block_3$g,
    create_if_block_4$9,
    create_if_block_5$5,
    create_else_block$v
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if ([C$2.TYPE_DOC, C$2.TYPE_HTML, C$2.TYPE_PDF_HTML].includes(ctx2[16]))
      return 0;
    if (ctx2[16] === C$2.TYPE_FEED)
      return 1;
    if (ctx2[16] === C$2.TYPE_XML)
      return 2;
    if (ctx2[16] === C$2.TYPE_JSON)
      return 3;
    if (ctx2[16] === C$2.TYPE_SITEMAP)
      return 4;
    return 5;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = ctx[7] && create_if_block$D(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      a = element("a");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      create_component(menu.$$.fragment);
      t3 = space();
      div2 = element("div");
      create_component(diffbar.$$.fragment);
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div1 = element("div");
      if_block1.c();
      t6 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr(i2, "class", "fa f4");
      toggle_class(i2, "fa-caret-down", ctx[12]);
      toggle_class(i2, "fa-caret-right", !ctx[12]);
      attr(a, "href", "#");
      attr(div0, "class", "mr-[10px]");
      attr(div0, "title", ctx[17].format());
      attr(div1, "class", "mt3");
      toggle_class(div1, "hidden", !ctx[12]);
      attr(div2, "class", "flex-1 bg-white");
      set_style(div2, "border-bottom", "solid 1px #ccc");
      attr(div3, "class", "relative flex");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, a);
      append(a, i2);
      append(a, t0);
      append(a, t1);
      append(div0, t2);
      mount_component(menu, div0, null);
      append(div3, t3);
      append(div3, div2);
      mount_component(diffbar, div2, null);
      append(div2, t4);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t5);
      append(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      insert(target, t6, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[20]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 4096) {
        toggle_class(i2, "fa-caret-down", ctx2[12]);
      }
      if (!current || dirty[0] & 4096) {
        toggle_class(i2, "fa-caret-right", !ctx2[12]);
      }
      const menu_changes = {};
      if (dirty[0] & 128 | dirty[1] & 50331648) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      const diffbar_changes = {};
      if (dirty[0] & 1024)
        diffbar_changes.model = ctx2[10];
      if (dirty[0] & 2048)
        diffbar_changes.oldModel = ctx2[11];
      if (dirty[0] & 8)
        diffbar_changes.selectedDiffContentMode = ctx2[3];
      if (!updating_additions && dirty[0] & 16) {
        updating_additions = true;
        diffbar_changes.additions = ctx2[4];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 32) {
        updating_deletions = true;
        diffbar_changes.deletions = ctx2[5];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_removed && dirty[0] & 8192) {
        updating_removed = true;
        diffbar_changes.removed = ctx2[13];
        add_flush_callback(() => updating_removed = false);
      }
      if (!updating_snipped && dirty[0] & 16384) {
        updating_snipped = true;
        diffbar_changes.snipped = ctx2[14];
        add_flush_callback(() => updating_snipped = false);
      }
      diffbar.$set(diffbar_changes);
      if (ctx2[0].change_summary) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t5);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if_block1.p(ctx2, dirty);
      if (!current || dirty[0] & 4096) {
        toggle_class(div1, "hidden", !ctx2[12]);
      }
      if (ctx2[7]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$D(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(diffbar.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(diffbar.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(menu);
      destroy_component(diffbar);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t6);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$1f($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { oldData } = $$props;
  let { sieve } = $$props;
  let selectedDiffContentMode = sieve.get("meta").diffContentMode;
  const Backbone2 = window.Backbone;
  const user = getContext("user");
  const exploreDiffPath = urlCfg.diffPage(sieve.id, data == null ? void 0 : data.id, oldData == null ? void 0 : oldData.id);
  let additions;
  let deletions;
  let diffView;
  let showEmailModal = false;
  let showFeedbackModal = false;
  let feedbackModel;
  const model = new Backbone2.Model(data);
  model.parent = sieve;
  let oldModel;
  if (oldData) {
    oldModel = new Backbone2.Model(oldData);
  }
  let type = model.get("data_type");
  let ts_mod = moment(model.get("ts_mod"));
  let showDiff = true;
  let { removed, snipped } = user.getPref("ui_diff");
  sieve.on("applySelectedDiffContentMode", () => {
    $$invalidate(3, selectedDiffContentMode = sieve.get("meta").diffContentMode);
  });
  onMount(() => {
    user.on("change:ui_diff", (diffPrefs) => {
      $$invalidate(13, { removed, snipped } = diffPrefs, removed, $$invalidate(14, snipped));
    });
    return () => {
      user.off("change:ui_diff");
      sieve.off("applySelectedDiffContentMode");
    };
  });
  function onDiffContentModeUpdate(e) {
    if (sieve.get("meta").diffContentMode !== e.detail.diffContentMode) {
      sieve.set("meta", {
        ...sieve.get("meta"),
        diffContentMode: e.detail.diffContentMode
      });
      sieve.save("meta", sieve.get("meta"), { patch: true });
    }
    $$invalidate(3, selectedDiffContentMode = sieve.get("meta").diffContentMode);
  }
  async function onFeedbackFormSave() {
    let doc = { text: data.text };
    try {
      await feedbackModel.submit(doc);
      $$invalidate(8, showFeedbackModal = false);
    } catch (e) {
      console.error("error while validating/submitting the form", e);
    }
  }
  const click_handler = () => $$invalidate(12, showDiff = !showDiff);
  const click_handler_1 = () => $$invalidate(7, showEmailModal = true);
  function diffbar_additions_binding(value) {
    additions = value;
    $$invalidate(4, additions);
  }
  function diffbar_deletions_binding(value) {
    deletions = value;
    $$invalidate(5, deletions);
  }
  function diffbar_removed_binding(value) {
    removed = value;
    $$invalidate(13, removed);
  }
  function diffbar_snipped_binding(value) {
    snipped = value;
    $$invalidate(14, snipped);
  }
  const diffContentModeUpdate_handler = (e) => onDiffContentModeUpdate(e);
  const applySelectedDiffContentMode_handler = () => {
    sieve.trigger("applySelectedDiffContentMode");
  };
  const click_handler_2 = (e) => {
    $$invalidate(8, showFeedbackModal = true);
  };
  function formgroup_model_binding(value) {
    feedbackModel = value;
    $$invalidate(9, feedbackModel);
  }
  const func2 = () => onFeedbackFormSave();
  const close_handler = () => {
    $$invalidate(8, showFeedbackModal = false);
  };
  function diffhtmlview_additions_binding(value) {
    additions = value;
    $$invalidate(4, additions);
  }
  function diffhtmlview_deletions_binding(value) {
    deletions = value;
    $$invalidate(5, deletions);
  }
  function diffhtmlview_iframe_binding(value) {
    diffView = value;
    $$invalidate(6, diffView);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function difffeedview_iframe_binding(value) {
    diffView = value;
    $$invalidate(6, diffView);
  }
  function difffeedview_newFeedCount_binding(value) {
    deletions = value;
    $$invalidate(5, deletions);
  }
  function difffeedview_updatedFeedCount_binding(value) {
    additions = value;
    $$invalidate(4, additions);
  }
  function load_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function diffxmlview_additions_binding(value) {
    additions = value;
    $$invalidate(4, additions);
  }
  function diffxmlview_deletions_binding(value) {
    deletions = value;
    $$invalidate(5, deletions);
  }
  function diffxmlview_iframe_binding(value) {
    diffView = value;
    $$invalidate(6, diffView);
  }
  function load_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function diffjsonview_additions_binding(value) {
    additions = value;
    $$invalidate(4, additions);
  }
  function diffjsonview_deletions_binding(value) {
    deletions = value;
    $$invalidate(5, deletions);
  }
  function diffjsonview_diffView_binding(value) {
    diffView = value;
    $$invalidate(6, diffView);
  }
  function load_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function diffsitemapview_additions_binding(value) {
    additions = value;
    $$invalidate(4, additions);
  }
  function diffsitemapview_deletions_binding(value) {
    deletions = value;
    $$invalidate(5, deletions);
  }
  function diffsitemapview_diffView_binding(value) {
    diffView = value;
    $$invalidate(6, diffView);
  }
  function load_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  const close_handler_1 = () => $$invalidate(7, showEmailModal = false);
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("oldData" in $$props2)
      $$invalidate(1, oldData = $$props2.oldData);
    if ("sieve" in $$props2)
      $$invalidate(2, sieve = $$props2.sieve);
  };
  return [
    data,
    oldData,
    sieve,
    selectedDiffContentMode,
    additions,
    deletions,
    diffView,
    showEmailModal,
    showFeedbackModal,
    feedbackModel,
    model,
    oldModel,
    showDiff,
    removed,
    snipped,
    exploreDiffPath,
    type,
    ts_mod,
    onDiffContentModeUpdate,
    onFeedbackFormSave,
    click_handler,
    click_handler_1,
    diffbar_additions_binding,
    diffbar_deletions_binding,
    diffbar_removed_binding,
    diffbar_snipped_binding,
    diffContentModeUpdate_handler,
    applySelectedDiffContentMode_handler,
    click_handler_2,
    formgroup_model_binding,
    func2,
    close_handler,
    diffhtmlview_additions_binding,
    diffhtmlview_deletions_binding,
    diffhtmlview_iframe_binding,
    load_handler,
    difffeedview_iframe_binding,
    difffeedview_newFeedCount_binding,
    difffeedview_updatedFeedCount_binding,
    load_handler_1,
    diffxmlview_additions_binding,
    diffxmlview_deletions_binding,
    diffxmlview_iframe_binding,
    load_handler_2,
    diffjsonview_additions_binding,
    diffjsonview_deletions_binding,
    diffjsonview_diffView_binding,
    load_handler_3,
    diffsitemapview_additions_binding,
    diffsitemapview_deletions_binding,
    diffsitemapview_diffView_binding,
    load_handler_4,
    close_handler_1
  ];
}
class SieveData extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1f, create_fragment$1i, safe_not_equal, { data: 0, oldData: 1, sieve: 2 }, null, [-1, -1]);
  }
}
function create_fragment$1h(ctx) {
  let div;
  let button0;
  let t0_value = T("Show More") + "";
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2_value = T("a_edit_options") + "";
  let t2;
  let button1_disabled_value;
  let t3;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      button2 = element("button");
      button2.textContent = `${T("Close")}`;
      attr(button0, "class", "btn btn-default");
      button0.disabled = button0_disabled_value = ctx[0] || ctx[1];
      attr(button1, "class", "btn btn-default ml-1");
      button1.disabled = button1_disabled_value = ctx[2].readOnly;
      attr(button2, "class", "btn btn-default ml-1");
      attr(div, "class", "form-actions flex align-item justify-center pa3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      append(div, t3);
      append(div, button2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[9]),
          listen(button1, "click", ctx[6]),
          listen(button2, "click", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 3 && button0_disabled_value !== (button0_disabled_value = ctx2[0] || ctx2[1])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & 4 && button1_disabled_value !== (button1_disabled_value = ctx2[2].readOnly)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1e($$self, $$props, $$invalidate) {
  let $route;
  let $params;
  let $permissionsModel;
  component_subscribe($$self, route, ($$value) => $$invalidate(12, $route = $$value));
  component_subscribe($$self, params, ($$value) => $$invalidate(8, $params = $$value));
  const dispatch = createEventDispatcher();
  let { sieve } = $$props;
  let { disableShowMore = false } = $$props;
  let { loading: loading2 = false } = $$props;
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(2, $permissionsModel = value));
  let { module, team } = $params;
  function showListView() {
    let path = getBasePath();
    let queryStr = lib.stringify($route.query);
    if (queryStr.length > 0) {
      path += `?${queryStr}`;
    }
    push$1(path);
  }
  function onClose() {
    if (module === "list") {
      showListView();
    } else {
      push$1(`/w/${team}/list/all/`);
    }
  }
  function editSieve() {
    push$1(`/w/${team}/sieve/edit/${sieve.id}.id`);
  }
  const click_handler = () => dispatch("showMore");
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$invalidate(7, sieve = $$props2.sieve);
    if ("disableShowMore" in $$props2)
      $$invalidate(0, disableShowMore = $$props2.disableShowMore);
    if ("loading" in $$props2)
      $$invalidate(1, loading2 = $$props2.loading);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      if ($params) {
        module = $params.module;
        team = $params.team;
      }
    }
  };
  return [
    disableShowMore,
    loading2,
    $permissionsModel,
    dispatch,
    permissionsModel,
    onClose,
    editSieve,
    sieve,
    $params,
    click_handler
  ];
}
class SieveToolbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1e, create_fragment$1h, safe_not_equal, { sieve: 7, disableShowMore: 0, loading: 1 });
  }
}
function get_each_context$n(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  child_ctx[16] = i2;
  return child_ctx;
}
function create_if_block_4$8(ctx) {
  let loader;
  let current;
  loader = new Loader({ props: { class: "absolute mt-[-2px]" } });
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_catch_block$9(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$9(ctx) {
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let if_block = ctx[2] && create_if_block_3$f();
  let each_value = ctx[1];
  const get_key = (ctx2) => ctx2[14].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$n(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$n(key, child_ctx));
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$f();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 27) {
        each_value = ctx2[1];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$n, each_1_anchor, get_each_context$n);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_3$f(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${T("m_history_empty")}`;
      attr(div, "class", "xinfo");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$g(ctx) {
  let sievedata;
  let current;
  sievedata = new SieveData({
    props: {
      data: ctx[1][ctx[16]],
      oldData: ctx[1][ctx[16]],
      sieve: ctx[0]
    }
  });
  sievedata.$on("load", ctx[10]);
  return {
    c() {
      create_component(sievedata.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sievedata, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sievedata_changes = {};
      if (dirty & 2)
        sievedata_changes.data = ctx2[1][ctx2[16]];
      if (dirty & 2)
        sievedata_changes.oldData = ctx2[1][ctx2[16]];
      if (dirty & 1)
        sievedata_changes.sieve = ctx2[0];
      sievedata.$set(sievedata_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievedata.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedata.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sievedata, detaching);
    }
  };
}
function create_if_block_1$o(ctx) {
  let sievedata;
  let current;
  sievedata = new SieveData({
    props: {
      data: ctx[1][ctx[16]],
      oldData: ctx[1][ctx[16] + 1],
      sieve: ctx[0]
    }
  });
  sievedata.$on("load", ctx[9]);
  return {
    c() {
      create_component(sievedata.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sievedata, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sievedata_changes = {};
      if (dirty & 2)
        sievedata_changes.data = ctx2[1][ctx2[16]];
      if (dirty & 2)
        sievedata_changes.oldData = ctx2[1][ctx2[16] + 1];
      if (dirty & 1)
        sievedata_changes.sieve = ctx2[0];
      sievedata.$set(sievedata_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievedata.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedata.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sievedata, detaching);
    }
  };
}
function create_each_block$n(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$o, create_if_block_2$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[16] !== ctx2[1].length - 1)
      return 0;
    if (ctx2[16] === ctx2[3] - 1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$9(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_if_block$C(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[5]);
      attr(div, "class", "xmsg centered");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1g(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let sievetoolbar;
  let current;
  let if_block0 = ctx[4] && !ctx[2] && create_if_block_4$8();
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$9,
    then: create_then_block$9,
    catch: create_catch_block$9,
    value: 13,
    blocks: [, , ,]
  };
  handle_promise(ctx[6](), info);
  let if_block1 = ctx[5] && create_if_block$C(ctx);
  sievetoolbar = new SieveToolbar({
    props: {
      sieve: ctx[0],
      disableShowMore: ctx[3] === 0 || ctx[1].length === ctx[3],
      loading: ctx[4]
    }
  });
  sievetoolbar.$on("showMore", ctx[6]);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      info.block.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      create_component(sievetoolbar.$$.fragment);
      attr(div, "class", "flex flex-column");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t1;
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t2);
      mount_component(sievetoolbar, div, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[4] && !ctx[2]) {
        if (if_block0) {
          if (dirty & 20) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$8();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      update_await_block_branch(info, ctx, dirty);
      if (ctx[5]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block$C(ctx);
          if_block1.c();
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      const sievetoolbar_changes = {};
      if (dirty & 1)
        sievetoolbar_changes.sieve = ctx[0];
      if (dirty & 10)
        sievetoolbar_changes.disableShowMore = ctx[3] === 0 || ctx[1].length === ctx[3];
      if (dirty & 16)
        sievetoolbar_changes.loading = ctx[4];
      sievetoolbar.$set(sievetoolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(info.block);
      transition_in(sievetoolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      transition_out(sievetoolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      info.block.d();
      info.token = null;
      info = null;
      if (if_block1)
        if_block1.d();
      destroy_component(sievetoolbar);
    }
  };
}
function instance$1d($$self, $$props, $$invalidate) {
  let { sieve } = $$props;
  let { route: route2 } = $$props;
  let { initialFetchCount = 3 } = $$props;
  let data = [];
  let historyEmpty = false;
  let totalCount;
  let loading2;
  let lastTs;
  let msg;
  onMount(() => {
    sieve.on("change:ts_data", updateView);
    return () => {
      sieve.off("change:ts_data", updateView);
    };
  });
  function updateView() {
    $$invalidate(5, msg = "Updated. Reloading now...");
    setTimeout(
      () => {
        fetch2({ reset: true });
      },
      200
    );
  }
  async function fetch2({ reset = false } = {}) {
    const init2 = !lastTs || reset;
    const limit2 = init2 ? initialFetchCount || 2 : 2;
    const query = { _opt: { limit: limit2 } };
    if (!init2) {
      query["ts.lt"] = lastTs;
    }
    Msg.start("sieve:data:fetch", { info: "l_loading" });
    try {
      $$invalidate(4, loading2 = true);
      let res = await Api.api(`/sieves/${sieve.id}/data`, "GET", query);
      const newData = res.data;
      Msg.stop("sieve:data:fetch");
      if (init2) {
        if (res.count == 0) {
          $$invalidate(2, historyEmpty = true);
          return;
        }
        $$invalidate(3, totalCount = res.total_count);
      }
      lastTs = newData[newData.length - 1].ts;
      if (init2) {
        $$invalidate(1, data = []);
      }
      $$invalidate(1, data = data.concat(newData));
    } catch (err) {
      Msg.stop("sieve:data:fetch", { error: "err:sieve:data:fetch" });
    }
    $$invalidate(5, msg = null);
  }
  const load_handler = () => $$invalidate(4, loading2 = false);
  const load_handler_1 = () => $$invalidate(4, loading2 = false);
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$invalidate(0, sieve = $$props2.sieve);
    if ("route" in $$props2)
      $$invalidate(7, route2 = $$props2.route);
    if ("initialFetchCount" in $$props2)
      $$invalidate(8, initialFetchCount = $$props2.initialFetchCount);
  };
  return [
    sieve,
    data,
    historyEmpty,
    totalCount,
    loading2,
    msg,
    fetch2,
    route2,
    initialFetchCount,
    load_handler,
    load_handler_1
  ];
}
class SieveDataList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1d, create_fragment$1g, safe_not_equal, { sieve: 0, route: 7, initialFetchCount: 8 });
  }
}
function get_each_context$m(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  return child_ctx;
}
function create_catch_block$8(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$B, create_else_block$u];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[3].models) == null ? void 0 : _a.length)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$u(ctx) {
  let h4;
  return {
    c() {
      h4 = element("h4");
      h4.textContent = "No monitor found.";
    },
    m(target, anchor) {
      insert(target, h4, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(h4);
    }
  };
}
function create_if_block$B(ctx) {
  let table;
  let colgroup;
  let t7;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let initTooltip_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[3].models;
  const get_key = (ctx2) => ctx2[19].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$m(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$m(key, child_ctx));
  }
  return {
    c() {
      table = element("table");
      colgroup = element("colgroup");
      colgroup.innerHTML = `<col style="width:28px"/> 
          <col style="width:28px"/> 
          <col class="w-[152px] lg:w-[304px]" style="padding: 0 10px;"/> 
          <col style=""/> 
          <col style="width:72px; padding: 0 10px;"/> 
          <col style="width:72px"/> 
          <col style="width:42px"/> 
          <col style="width:40px"/>`;
      t7 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(table, "class", "xlist xlist-shadow cursor-pointer");
      attr(table, "cellpadding", "0");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, colgroup);
      append(table, t7);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(initTooltip_action = initTooltip.call(null, table, ctx[3]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 12) {
        each_value = ctx2[3].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$m, null, get_each_context$m);
        check_outros();
      }
      if (initTooltip_action && is_function(initTooltip_action.update) && dirty & 8)
        initTooltip_action.update.call(null, ctx2[3]);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$n(ctx) {
  let tr;
  let td;
  let sievedatalist;
  let t;
  let current;
  sievedatalist = new SieveDataList({ props: { sieve: ctx[19] } });
  return {
    c() {
      tr = element("tr");
      td = element("td");
      create_component(sievedatalist.$$.fragment);
      t = space();
      attr(td, "colspan", 8);
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      mount_component(sievedatalist, td, null);
      append(tr, t);
      current = true;
    },
    p(ctx2, dirty) {
      const sievedatalist_changes = {};
      if (dirty & 8)
        sievedatalist_changes.sieve = ctx2[19];
      sievedatalist.$set(sievedatalist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievedatalist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedatalist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_component(sievedatalist);
    }
  };
}
function create_each_block$m(key_1, ctx) {
  let first;
  let sieverow;
  let t;
  let if_block_anchor;
  let current;
  sieverow = new SieveRow({ props: { sieve: ctx[19] } });
  let if_block = ctx[2].module === "list" && ctx[2].id === ctx[19].id && create_if_block_1$n(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(sieverow.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(sieverow, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const sieverow_changes = {};
      if (dirty & 8)
        sieverow_changes.sieve = ctx[19];
      sieverow.$set(sieverow_changes);
      if (ctx[2].module === "list" && ctx[2].id === ctx[19].id) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$n(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sieverow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(sieverow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(sieverow, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$8(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$1f(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$8,
    then: create_then_block$8,
    catch: create_catch_block$8,
    value: 18,
    blocks: [, , ,]
  };
  handle_promise(ctx[4](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "pb-[75px] flex-1");
      set_style(div, "scrollbar-gutter", "stable");
      toggle_class(div, "d-none", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (!current || dirty & 1) {
        toggle_class(div, "d-none", ctx[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function initTooltip(node2, sieves) {
  return {
    update(sieves2) {
      window.$('[data-toggle="tooltip"]').tooltip({ delay: { show: 400 } });
    }
  };
}
function instance$1c($$self, $$props, $$invalidate) {
  let $route;
  let $sieves;
  component_subscribe($$self, route, ($$value) => $$invalidate(2, $route = $$value));
  let { hidden = false } = $$props;
  let dirty = false;
  let { sieves } = getContext("watchlist:stores");
  component_subscribe($$self, sieves, (value) => $$invalidate(3, $sieves = value));
  let oldRoute;
  let reloadImmediately = true;
  const errorUnreadModel = new Backbone.Model();
  onMount(() => {
    const keyList = "change:ui.list.sortby change:ui.list.pagesize change:ui.list.clientfilter";
    App.store.on(keyList, resetAndShow);
    instance$4s.on("sieves", onSieveUpdate);
    instance$4s.on("user_states", onUserStateChange);
    const unsubscribe = route.subscribe(show);
    return () => {
      App.store.off(keyList, resetAndShow);
      instance$4s.off("sieves", onSieveUpdate);
      instance$4s.off("user_states", onUserStateChange);
      unsubscribe();
    };
  });
  function onUserStateChange(data) {
    const oldError = errorUnreadModel.get("error");
    const oldUnread = errorUnreadModel.get("unread");
    const { error, unread, sync } = data;
    errorUnreadModel.set(data);
    let { currentPage } = sieves.info();
    if (oldError < error && $route.prefix == "error" && currentPage == 0) {
      recentFetchAndShow();
    }
    if (oldUnread < unread && $route.prefix == "unread" && currentPage == 0) {
      recentFetchAndShow();
    }
  }
  function recentFetchAndShow(id2) {
    const tsModMax = sieves.length > 0 ? sieves.max((model) => new Date(model.get("ts_mod")).valueOf()).get("ts_mod") : new Date(0).toISOString();
    const tCollection = new Model$2.Sieves();
    Msg.start("fetch", { info: "l_loading" });
    tCollection.fetch({
      data: _.extend({ "ts_mod.gt": tsModMax }, getQuery($route)),
      success: () => {
        Msg.stop("fetch");
        sieves.add(tCollection["models"], { merge: true, at: 0 });
      }
    });
  }
  function onSieveUpdate({ op, id: id2 }) {
    if (op == "I") {
      if (!sieves.get(id2)) {
        onSieveInsert();
      }
    }
  }
  function onSieveInsert() {
    if (reloadImmediately) {
      reload();
      reloadImmediately = false;
    } else {
      onSieveInsertDebounced();
    }
  }
  function onSieveInsertDebounced() {
    _.debounce(
      () => {
        reload();
        reloadImmediately = true;
      },
      2 * 1e3
    )();
  }
  function reload(resetCurrentPage) {
    if (resetCurrentPage && $route.query.page > 1) {
      push$1(getBasePath());
    } else {
      fetchAndShow($route, { force: true });
    }
  }
  function getSortField() {
    const field = App.store.get("ui.list.sortby") || "-ts_data";
    $$invalidate(1, sieves.sortField = field, sieves);
    if (field == "name" && Supports.agents.local) {
      return "name nocase";
    }
    return field;
  }
  async function show() {
    await fetchAndShow($route);
  }
  async function resetAndShow() {
    await fetchAndShow($route, { force: true, resetPage: true });
  }
  async function fetchAndShow(route2, { force = false, resetPage = false } = {}) {
    if (route2.module !== "list") {
      $$invalidate(5, dirty = true);
      return;
    }
    const limit2 = App.store.get("ui.list.pagesize") || 50;
    let routeKeys = ["team", "prefix", "data", "query"];
    let reloadList = force || !oldRoute || routeKeys.filter((key) => !_.isEqual(route2[key], oldRoute[key])).length > 0;
    oldRoute = { ...route2 };
    if (reloadList) {
      Msg.start("fetch", { info: "l_loading" });
      $$invalidate(1, sieves.limit = limit2, sieves);
      let currentPage = resetPage ? 0 : parseInt(route2.query.page || "1") - 1;
      sieves.setOpt({ order: [getSortField()], limit: limit2, a: "a" });
      sieves.setQuery(getQuery(route2));
      await sieves.goto(currentPage, {
        sort: false,
        success: (collection, resp, options) => {
          _.each(options.previousModels, function(model) {
            model.trigger("remove");
          });
        }
      });
      Msg.stop("fetch");
    }
  }
  $$self.$$set = ($$props2) => {
    if ("hidden" in $$props2)
      $$invalidate(0, hidden = $$props2.hidden);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 33) {
      if (!hidden && dirty) {
        reload();
        $$invalidate(5, dirty = false);
      }
    }
  };
  return [hidden, sieves, $route, $sieves, show, dirty];
}
class List$7 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1c, create_fragment$1f, safe_not_equal, { hidden: 0 });
  }
}
var C$1 = {
  STRING: "string",
  NUMBER: "number",
  BOOLEAN: "boolean",
  "JSON": "json",
  ARRAY: "array",
  FUNCTION: "function",
  VOID: "void",
  NULL: "null",
  UNDEFINED: "undefined",
  STATEMENT_LIST: "STATEMENT_LIST",
  VARIABLE_DECLARATION: "VARIABLE_DECLARATION",
  COND: "COND",
  ASSIGNMENT: "ASSIGNMENT",
  VARIABLE_REFERENCE: "VARIABLE_REFERENCE",
  ERROR: "ERROR",
  CLAUSE: "CLAUSE",
  FUNCTION_CALL: "FUNCTION_CALL",
  LITERAL: "LITERAL",
  STRUCT: "STRUCT",
  ENUM: "ENUM",
  UNSET: "UNSET",
  DUPLICATE_DECLARATION: "duplicate_declaration",
  MISSING_ARGUMENT: "missing_argument",
  INVALID_SYNTAX: "invalid_syntax",
  TYPE_MISMATCH: "type_mismatch",
  UNDEFINED_TYPE: "undefined_type",
  INVALID_VARIABLE_NAME: "invalid_variable_name",
  INVALID_VARIABLE_REFERENCE: "invalid_variable_reference",
  INVALID_VARIABLE_TYPE: "invalid_variable_type",
  CHANGE: "change",
  EVALUATE_START: "evaluate_start",
  EVALUATE_END: "evaluate_end",
  EVALUATE_ERROR: "evaluate_error"
};
function wait$3(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function containsText(text1, text2) {
  return text1.toLowerCase().includes(text2.toLowerCase());
}
let timeLimit = 30 * 1e3;
const stepDefs = {};
stepDefs["click"] = {
  name: "click",
  args: {
    selector: {
      types: ["selector"]
    },
    pos: {
      types: ["position"]
    },
    options: {
      types: ["click_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (selector, pos, opts) => {
    await wait$3(1e3);
    await context.browser.click(selector, pos, opts);
  }
};
stepDefs["wait_doc"] = {
  name: "wait_doc",
  args: {
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (opts) => {
    await context.browser.waitForDoc(opts);
  }
};
stepDefs["select"] = {
  name: "select",
  args: {
    selector: {
      types: ["selector"]
    },
    value: {
      types: [C$1.STRING]
    },
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (selector, value, opts) => {
    await wait$3(1e3);
    await context.browser.select(selector, value, opts);
  }
};
stepDefs["keypress"] = {
  name: "keypress",
  args: {
    code: {
      types: ["keypress_code"]
    },
    count: {
      types: [C$1.NUMBER]
    },
    options: {
      types: ["keypress_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (code, count2, opts) => {
    await wait$3(1e3);
    await context.browser.keypress(code, count2, opts);
  }
};
stepDefs["mousemove"] = {
  name: "mousemove",
  args: {
    selector: {
      types: ["selector"]
    },
    pos: {
      types: ["position"]
    },
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (selector, pos, opts) => {
    await wait$3(1e3);
    await context.browser.mousemove(selector, pos, opts);
  }
};
stepDefs["drag"] = {
  name: "drag",
  args: {
    selector: {
      types: ["selector"]
    },
    pos: {
      types: ["position"]
    },
    targetSelector: {
      types: ["selector"]
    },
    targetPos: {
      types: ["position"]
    },
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (selector, pos, targetSelector, targetPos, opts) => {
    await wait$3(1e3);
    await context.browser.drag(selector, pos, targetSelector, targetPos, opts);
  }
};
stepDefs["focus"] = {
  name: "focus",
  args: {
    selector: {
      types: ["selector"]
    },
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (selector, opts) => {
    await wait$3(1e3);
    await context.browser.focus(selector, opts);
  }
};
stepDefs["type"] = {
  name: "type",
  args: {
    selector: {
      types: ["selector"]
    },
    text: {
      types: [C$1.STRING]
    },
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (selector, value, opts) => {
    await wait$3(1e3);
    await context.browser.type(selector, value, opts);
  }
};
stepDefs["scroll"] = {
  name: "scroll",
  args: {
    selector: {
      types: ["selector"]
    },
    left: {
      types: [C$1.NUMBER]
    },
    top: {
      types: [C$1.NUMBER]
    },
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (selector, left, top, opts) => {
    await wait$3(1e3);
    await context.browser.scroll(selector, left, top, opts);
  }
};
stepDefs["wait_for_duration"] = {
  name: "wait_for_duration",
  args: {
    duration: {
      types: [C$1.NUMBER]
    }
  },
  returnType: C$1.VOID,
  fn: (_context) => async (duration) => {
    await wait$3(duration * 1e3);
  }
};
stepDefs["wait_for_element"] = {
  name: "wait_for_element",
  args: {
    selector: {
      types: ["selector"]
    },
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (selector, opts) => {
    let elementsCount = await context.browser.getElementsCount(selector, opts);
    let timeOut = Date.now() + timeLimit;
    while (elementsCount === 0 && timeOut > Date.now()) {
      await wait$3(500);
      elementsCount = await context.browser.getElementsCount(selector, opts);
    }
    if (elementsCount === 0) {
      throw new Error(`Element ${selector.value} not found`);
    }
  }
};
stepDefs["open"] = {
  name: "open",
  args: {
    url: {
      types: [C$1.STRING]
    },
    options: {
      types: ["open_opts"],
      optional: true
    }
  },
  returnType: C$1.VOID,
  fn: (context) => async (url, opts) => {
    await context.browser.open(url, opts);
  }
};
const structDefs = {};
structDefs["selector"] = {
  name: "selector",
  fields: {
    value: {
      types: [C$1.STRING]
    },
    type: {
      types: ["selector_type"]
    },
    meta: {
      types: [C$1.JSON],
      optional: true
    }
  }
};
structDefs["position"] = {
  name: "position",
  fields: {
    x: {
      types: [C$1.NUMBER]
    },
    y: {
      types: [C$1.NUMBER]
    }
  }
};
structDefs["frame_locator"] = {
  name: "frame_locator",
  fields: {
    index: {
      types: [C$1.NUMBER],
      optional: true
    },
    name: {
      types: [C$1.STRING],
      optional: true
    },
    page: {
      types: [C$1.NUMBER],
      optional: true
    }
  }
};
structDefs["default_opts"] = {
  name: "options",
  fields: {
    frame: {
      types: [C$1.NUMBER, "frame_locator"],
      optional: true
    },
    timeout: {
      types: [C$1.NUMBER],
      optional: true
    }
  }
};
structDefs["click_opts"] = {
  name: "options",
  fields: {
    frame: {
      types: [C$1.NUMBER, "frame_locator"],
      optional: true
    },
    timeout: {
      types: [C$1.NUMBER],
      optional: true
    },
    button: {
      types: ["mouse_button"],
      optional: true
    },
    clickCount: {
      types: [C$1.NUMBER],
      optional: true
    },
    delay: {
      types: [C$1.NUMBER],
      optional: true
    }
  }
};
structDefs["keypress_opts"] = {
  name: "options",
  fields: {
    page: {
      types: [C$1.NUMBER],
      optional: true
    },
    timeout: {
      types: [C$1.NUMBER],
      optional: true
    }
  }
};
structDefs["open_opts"] = {
  name: "options",
  fields: {
    page: {
      types: [C$1.NUMBER],
      optional: true
    },
    timeout: {
      types: [C$1.NUMBER],
      optional: true
    }
  }
};
const enumDefs = {};
enumDefs["selector_type"] = {
  name: "selector_type",
  enumType: "string",
  values: ["css", "xpath"]
};
enumDefs["keypress_code"] = {
  name: "keypress_code",
  enumType: "string",
  values: ["Enter", "Backspace"]
};
enumDefs["mouse_button"] = {
  name: "mouse_button",
  enumType: "string",
  values: ["left", "right", "middle", "forward", "back"]
};
const conditionDefs = {};
conditionDefs["element_exists"] = {
  name: "element_exists",
  args: {
    selector: {
      types: ["selector"]
    },
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.BOOLEAN,
  fn: (context) => async (selector, opts) => {
    let elementsCount = await context.browser.getElementsCount(selector, opts);
    return elementsCount > 0;
  }
};
conditionDefs["element_has_text"] = {
  name: "element_has_text",
  args: {
    selector: {
      types: ["selector"]
    },
    text: {
      types: [C$1.STRING]
    },
    options: {
      types: ["default_opts"],
      optional: true
    }
  },
  returnType: C$1.BOOLEAN,
  fn: (context) => async (selector, text2, opts) => {
    let elementText = await context.browser.getElementText(selector, opts);
    return containsText(elementText, text2);
  }
};
class EventEmitter$1 {
  constructor() {
    this.__ee_listeners = {};
  }
  emit(name, ...args) {
    (this.__ee_listeners[name] || []).forEach((l) => l(...args));
  }
  hasListener(name) {
    return (this.__ee_listeners[name] || []).length > 0;
  }
  off(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    let index2 = listeners.indexOf(listener);
    while (index2 >= 0) {
      listeners.splice(index2, 1);
      index2 = listeners.indexOf(listener);
    }
    return this;
  }
  on(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    listeners.push(listener);
    return this;
  }
  once(name, listener) {
    const l2 = (...args) => {
      this.off(name, l2);
      listener(...args);
    };
    this.on(name, l2);
    return this;
  }
  reset() {
    this.__ee_listeners = {};
  }
  waitForEvent(name, ...selectors) {
    return new Promise((resolve) => {
      const l2 = (...args) => {
        for (let i2 = 0, length = selectors.length; i2 < length; i2 += 1) {
          if (selectors[i2] !== args[i2]) {
            return;
          }
        }
        resolve(args[0]);
      };
      this.on(name, l2);
    });
  }
}
const BuiltInTypes = {};
BuiltInTypes[C$1.NUMBER] = {
  name: C$1.NUMBER,
  default: () => 0
};
BuiltInTypes[C$1.STRING] = {
  name: C$1.STRING,
  default: () => ""
};
BuiltInTypes[C$1.BOOLEAN] = {
  name: C$1.BOOLEAN,
  default: () => false
};
BuiltInTypes[C$1.JSON] = {
  name: C$1.JSON,
  default: () => ({})
};
const RESERVED = [
  C$1.STRING,
  C$1.NUMBER,
  C$1.BOOLEAN,
  C$1.JSON,
  C$1.ARRAY,
  C$1.STRUCT,
  C$1.FUNCTION,
  C$1.NULL,
  C$1.UNDEFINED
];
class Registry {
  get types() {
    return { ...this.builtinTypes, ...this.structs, ...this.enums };
  }
  constructor(params2 = {}) {
    this.builtinTypes = { ...BuiltInTypes };
    this.funcs = {};
    this.structs = {};
    this.enums = {};
    if (params2.enums) {
      this.addEnums(params2.enums);
    }
    if (params2.structs) {
      this.addStructs(params2.structs);
    }
    if (params2.funcs) {
      this.addFuncs(params2.funcs);
    }
  }
  addFunc(name, funcDef) {
    if (RESERVED.includes(name)) {
      throw new Error(`Cannot use reserved word ${name} as function name`);
    }
    if (this.hasDef(name)) {
      throw new Error(`name "${name}" already exists in registry`);
    }
    for (let argDef of Object.values(funcDef.args)) {
      for (let type of argDef.types) {
        if (!this.hasType(type)) {
          throw new Error(`type "${type}" not found in registry`);
        }
      }
    }
    if (funcDef.returnType !== "void" && !this.hasType(funcDef.returnType)) {
      throw new Error(`Type "${funcDef.returnType}" not found in registry`);
    }
    this.funcs[name] = funcDef;
  }
  addFuncs(funcDefs) {
    for (const [key, value] of Object.entries(funcDefs)) {
      this.addFunc(key, value);
    }
  }
  addStruct(name, typeDef) {
    if (RESERVED.includes(name)) {
      throw new Error(`Cannot use reserved word ${name} as type name`);
    }
    if (this.hasDef(name)) {
      throw new Error(`type "${name}" already exists in registry`);
    }
    this.structs[name] = typeDef;
  }
  addEnum(name, enumDef) {
    if (RESERVED.includes(name)) {
      throw new Error(`Cannot use reserved word ${name} as type name`);
    }
    if (this.hasDef(name)) {
      throw new Error(`type "${name}" already exists in registry`);
    }
    this.enums[name] = enumDef;
  }
  addStructs(typeDefs) {
    for (const [key, value] of Object.entries(typeDefs)) {
      this.addStruct(key, value);
    }
  }
  addEnums(typeDefs) {
    for (const [key, value] of Object.entries(typeDefs)) {
      this.addEnum(key, value);
    }
  }
  clone() {
    return new Registry({
      funcs: this.funcs,
      structs: this.structs,
      enums: this.enums
    });
  }
  getFunc(name) {
    if (this.hasFunc(name)) {
      return this.funcs[name];
    } else {
      throw new Error(`Function ${name} not found in registry`);
    }
  }
  hasDef(name) {
    return this.hasFunc(name) || this.hasType(name);
  }
  hasFunc(name) {
    return name in this.funcs;
  }
  hasBuiltinType(name) {
    return name in this.builtinTypes;
  }
  hasType(name) {
    return this.hasBuiltinType(name) || this.hasStruct(name) || this.hasEnum(name);
  }
  hasEnum(name) {
    return name in this.enums;
  }
  hasStruct(name) {
    return name in this.structs;
  }
  getStruct(name) {
    if (this.hasStruct(name)) {
      return this.structs[name];
    } else {
      throw new Error(`Struct ${name} not found in registry`);
    }
  }
  getEnum(name) {
    if (this.hasEnum(name)) {
      return this.enums[name];
    } else {
      throw new Error(`Enum ${name} not found in registry`);
    }
  }
  getBuiltinType(type) {
    if (this.hasBuiltinType(type)) {
      return this.builtinTypes[type];
    } else {
      throw new Error(`Type ${type} not found in registry`);
    }
  }
}
function parseList(statements, registry, parent2) {
  if (!Array.isArray(statements)) {
    return new SyntaxError$1("Invalid statement list", { expr: statements });
  }
  let statementList = new StatementList$1(registry, [], parent2);
  for (let statement of statements) {
    statementList.append(parseStatement(statement, registry));
  }
  return statementList;
}
function parseStatement(statement, registry, parent2) {
  if (Array.isArray(statement)) {
    if (statement.length === 0) {
      return new SyntaxError$1("Invalid statement", { expr: statement });
    } else if (statement[0] === "var") {
      return new SyntaxError$1("Invalid statement", { expr: statement });
    } else if (statement[0] === "cond") {
      return new SyntaxError$1("Invalid statement", { expr: statement });
    } else if (statement[0] === "=") {
      return new SyntaxError$1("Invalid statement", { expr: statement });
    }
  }
  return parseExpression(statement, registry, parent2);
}
function parseExpression(expr, registry, parent2) {
  if (expr === void 0 || expr === null) {
    return new SyntaxError$1("invalid expression", { expr });
  }
  if (typeof expr === "string" && expr.length > 1 && expr[0] === "$") {
    return new SyntaxError$1("invalid expression", { expr });
  } else if (Array.isArray(expr) && expr.length > 0 && typeof expr[0] === "string") {
    if (expr[0] === "ERROR") {
      return _parseError(expr, registry, parent2);
    } else if (registry.hasFunc(expr[0])) {
      return _parseFunctionCall(expr, registry, parent2);
    } else if (registry.hasStruct(expr[0])) {
      return parseStruct(expr, registry, parent2);
    } else {
      return new UndefinedTypeError(`Type ${expr[0]} not found in registry`, { expr });
    }
  } else if (isPlainObject(expr) || Array.isArray(expr) && expr[0] === "array" || isPrimitive(expr)) {
    return _parseLiteral(expr, registry, parent2);
  } else {
    return new SyntaxError$1("Invalid expression", { expr });
  }
}
function parseStruct(expr, registry, parent2) {
  if (!Array.isArray(expr) || typeof expr[0] !== "string") {
    return new SyntaxError$1("Invalid struct", { expr });
  }
  if (!registry.hasStruct(expr[0])) {
    return new VariableReferenceError("Struct not found in registry", { expr });
  }
  let fieldsObj = expr[1];
  let fields = /* @__PURE__ */ new Map();
  for (let fieldName of Object.keys(fieldsObj)) {
    fields.set(fieldName, parseExpression(fieldsObj[fieldName], registry, parent2));
  }
  return new StructNode$1(registry, expr[0], fields, parent2);
}
function _parseLiteral(expr, registry, parent2) {
  if (!isPrimitive(expr) && (!Array.isArray(expr) || expr[0] !== "array") && !isPlainObject(expr)) {
    return new SyntaxError$1("Invalid literal", { expr });
  }
  return new Literal$1(registry, expr, parent2);
}
function _parseFunctionCall(expr, registry, parent2) {
  let args = expr.slice(1).map((arg) => parseExpression(arg, registry, parent2));
  return new FunctionCall$1(registry, expr[0], args, parent2);
}
function _parseError(expr, registry, parent2) {
  let ErrorMap = {};
  ErrorMap[C$1.DUPLICATE_DECLARATION] = DuplicateDeclarationError;
  ErrorMap[C$1.MISSING_ARGUMENT] = MissingArgumentError;
  ErrorMap[C$1.INVALID_SYNTAX] = SyntaxError$1;
  ErrorMap[C$1.TYPE_MISMATCH] = TypeMismatchError;
  ErrorMap[C$1.UNDEFINED_TYPE] = UndefinedTypeError;
  ErrorMap[C$1.INVALID_VARIABLE_NAME] = VariableNameError;
  ErrorMap[C$1.INVALID_VARIABLE_REFERENCE] = VariableReferenceError;
  ErrorMap[C$1.INVALID_VARIABLE_TYPE] = VariableTypeError;
  if (!Array.isArray(expr) || expr.length === 0 || typeof expr[0] !== "string" || expr[0] !== "ERROR") {
    return new SyntaxError$1("Invalid error node", { expr });
  }
  if (ErrorMap.hasOwnProperty(expr[1])) {
    return new ErrorMap[expr[1]](registry, expr[2], parent2);
  } else {
    return new SyntaxError$1("Invalid error node", { expr });
  }
}
function getDefault$1(registry, type) {
  if (registry.hasStruct(type)) {
    return new StructNode$1(registry, type);
  } else if (registry.hasEnum(type)) {
    return new EnumNode$1(registry, type, registry.getEnum(type).values[0]);
  } else if (registry.hasBuiltinType(type)) {
    return new Literal$1(registry, registry.getBuiltinType(type).default());
  } else if (registry.hasFunc(type)) {
    return new FunctionCall$1(registry, type);
  } else {
    throw new Error(`Type ${type} not found in registry`);
  }
}
function isPlainObject(value) {
  if (typeof value !== "object" || value.toString() !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function getLiteralType(literal) {
  if (Array.isArray(literal)) {
    return C$1.ARRAY;
  } else if (isPlainObject(literal)) {
    return C$1.JSON;
  } else if (typeof literal === "string") {
    return C$1.STRING;
  } else if (typeof literal === "number") {
    return C$1.NUMBER;
  } else if (typeof literal === "boolean") {
    return C$1.BOOLEAN;
  } else {
    throw new Error(`Unknown literal type ${typeof literal}`);
  }
}
function isPrimitive(value) {
  return value !== Object(value);
}
function isValidType(value) {
  return isPrimitive(value) || isPlainObject(value) || Array.isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function castToTypeOrError(registry, originalNode, type) {
  if (!(originalNode instanceof Literal$1)) {
    return new TypeMismatchError(`the node has a return type of ${originalNode.returnType}, which is different from the type expected: "${JSON.stringify(type)}"`);
  }
  if (Array.isArray(type)) {
    for (let t of type) {
      let newNode = castToTypeOrError(registry, originalNode, t);
      if (!(newNode instanceof ErrorNode$1)) {
        return newNode;
      }
    }
  } else {
    if (registry.hasStruct(type) && originalNode.returnType === C$1.JSON) {
      let newNode = parseStruct([type, originalNode.value], registry);
      if (!(newNode instanceof ErrorNode$1)) {
        return newNode;
      }
    } else if (registry.hasEnum(type) && (originalNode.returnType === C$1.STRING || originalNode.returnType === C$1.NUMBER) && registry.getEnum(type).values.includes(originalNode.value)) {
      return new EnumNode$1(registry, type, originalNode.value);
    }
  }
  return new TypeMismatchError(`the node has a return type of ${originalNode.returnType}, which is different from the type expected: "${JSON.stringify(type)}"`);
}
class EvalError$1 {
  constructor(error, node2) {
    this.error = error;
    this.node = node2;
  }
  get message() {
    return this.error.message;
  }
}
class Node$2 extends EventEmitter$1 {
  get variables() {
    let variables = /* @__PURE__ */ new Map();
    let ancestor = this.parent;
    let prevAncestor = this;
    while (ancestor) {
      if (ancestor instanceof StatementList$1) {
        for (let node2 of ancestor.nodes) {
          if (node2 === prevAncestor) {
            break;
          }
          if (node2 instanceof VariableDeclaration$1) {
            variables.set(node2.name, node2);
          }
        }
      }
      prevAncestor = ancestor;
      ancestor = ancestor.parent;
    }
    return variables;
  }
  constructor(nodeType, parent2) {
    super();
    this.type = nodeType;
    this.parent = parent2;
    this._stopEval = false;
  }
  _clearInterrupt() {
    this._stopEval = false;
    if (isParentNode(this)) {
      for (let subtree of this.subtrees) {
        subtree._clearInterrupt();
      }
    }
  }
  emitChange() {
    var _a;
    this.emit(C$1.CHANGE);
    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.emitChange();
  }
  async evaluate(variableSpace, context) {
    if (this._stopEval) {
      throw new Error("Evaluation interrupted");
    }
    this.emit(C$1.EVALUATE_START, this);
    try {
      let res = await this._evaluate(variableSpace, context);
      this.emit(C$1.EVALUATE_END, this);
      return res;
    } catch (e) {
      if (!(e instanceof EvalError$1)) {
        e = new EvalError$1(e, this);
      }
      throw e;
    }
  }
  *iterator() {
    yield this;
    if (isParentNode(this)) {
      for (let subtree of this.subtrees) {
        yield* subtree.iterator();
      }
    }
  }
  interrupt() {
    this._stopEval = true;
    if (isParentNode(this)) {
      for (let subtree of this.subtrees) {
        subtree.interrupt();
      }
    }
  }
  _updateRefs(variables) {
    if (isParentNode(this)) {
      for (let subtree of this.subtrees) {
        subtree._updateRefs(variables);
      }
    }
  }
}
class ValidNode extends Node$2 {
  constructor(nodeType, registry, parent2) {
    super(nodeType, parent2);
    this.registry = registry;
  }
}
class StatementList$1 extends ValidNode {
  constructor(registry, nodes, parent2) {
    super(C$1.STATEMENT_LIST, registry, parent2);
    this.nodes = [];
    nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node2) => this.append(node2));
  }
  append(newNode) {
    if (newNode instanceof VariableDeclaration$1 && this.getDeclarations().some((n) => n.name === newNode.name)) {
      newNode = new DuplicateDeclarationError("Variable already exists", { nodeRef: newNode });
    }
    this.nodes.push(newNode);
    newNode.parent = this;
    this.updateRefs();
    this.emitChange();
  }
  clearStatements() {
    this.nodes = [];
    this.emitChange();
  }
  async _evaluate(variableSpace, context) {
    let result;
    for (let node2 of this.nodes) {
      if (node2 instanceof ValidNode) {
        result = await node2.evaluate(variableSpace, context);
      } else {
        throw new Error("ErrorNode cannot be evaluated");
      }
    }
    return result;
  }
  getDeclarations(before) {
    let len = this.nodes.length;
    if (before) {
      if (typeof before === "number") {
        len = before;
      } else if (this.nodes.includes(before)) {
        len = this.nodes.indexOf(before);
      }
    }
    return this.nodes.filter((node2, index2) => index2 < len && node2 instanceof VariableDeclaration$1);
  }
  getDefaults() {
    return [];
  }
  pop() {
    let node2 = this.nodes.pop();
    if (node2) {
      node2.parent = void 0;
      this.updateRefs();
      this.emitChange();
      return node2;
    } else {
      throw new Error("the statement-list is empty. Cannot Pop");
    }
  }
  getChildSignature() {
    return { matchingClasses: [Node$2], matchingTypes: [] };
  }
  removeChild(node2) {
    let index2 = this.nodes.indexOf(node2);
    if (index2 !== -1) {
      this.nodes.splice(index2, 1);
      node2.parent = void 0;
      this.updateRefs();
    }
    this.emitChange();
  }
  insertAt(index2, newNode) {
    if (newNode instanceof VariableDeclaration$1 && this.getDeclarations(index2).some((n) => n.name === newNode.name)) {
      newNode = new DuplicateDeclarationError("Variable already exists", { nodeRef: newNode });
    }
    this.nodes.splice(index2, 0, newNode);
    newNode.parent = this;
    this.updateRefs();
    this.emitChange();
  }
  replaceChild(oldChild, newChild) {
    let index2 = this.nodes.indexOf(oldChild);
    if (index2 === -1) {
      throw new Error("Node not found in the list");
    }
    if (newChild instanceof VariableDeclaration$1 && this.getDeclarations(oldChild).some((n) => n.name === newChild.name)) {
      newChild = new DuplicateDeclarationError("Variable already exists", { nodeRef: newChild });
    }
    this.nodes[index2] = newChild;
    newChild.parent = this;
    this.updateRefs();
    this.emitChange();
  }
  get subtrees() {
    return this.nodes;
  }
  get subtreeLabels() {
    return this.nodes.map((_node, index2) => index2.toString());
  }
  get detail() {
    return `Statements(${this.nodes.length} items)`;
  }
  _updateRefs(variables) {
    for (let subtree of this.subtrees) {
      subtree._updateRefs(new Map([...variables]));
      if (subtree instanceof VariableDeclaration$1) {
        variables.set(subtree.name, subtree);
      }
    }
  }
  get title() {
    return "STATEMENTS";
  }
  toJSON() {
    return this.nodes.map((node2) => {
      return node2.toJSON();
    });
  }
  updateRefs() {
    let variables = this.variables;
    this._updateRefs(variables);
  }
}
class VariableDeclaration$1 extends ValidNode {
  get name() {
    return this._name;
  }
  get value() {
    return this._value;
  }
  set value(newValue) {
    if (newValue instanceof ErrorNode$1) {
      this._value = newValue;
    } else if (newValue instanceof Expression$1 && newValue.returnType === this.dataType) {
      this._value = newValue;
    } else if (newValue instanceof Expression$1 && newValue.returnType !== this.dataType) {
      this._value = castToTypeOrError(this.registry, newValue, this.dataType);
    } else {
      this._value = new TypeMismatchError("Invalid type", { nodeRef: newValue });
    }
    this._value.parent = this;
  }
  get detail() {
    return `VAR ${this.name} = ${this.value.detail}`;
  }
  constructor(registry, name, type, value, parent2) {
    super(C$1.VARIABLE_DECLARATION, registry, parent2);
    let defaults2 = this.getDefaults({ type });
    this._name = name !== null && name !== void 0 ? name : defaults2.name;
    this.dataType = type !== null && type !== void 0 ? type : defaults2.type;
    if (value === void 0) {
      value = defaults2.value;
    }
    if (value instanceof Expression$1 && value.returnType !== this.dataType) {
      value = castToTypeOrError(this.registry, value, this.dataType);
    }
    this._value = value;
    this._value.parent = this;
  }
  changeType(newType) {
    var _a;
    if (newType === this.dataType)
      return;
    this.dataType = newType;
    this._value = this.getDefaults({ type: newType }).value;
    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.updateRefs();
    this.emitChange();
  }
  async _evaluate(variableSpace, context) {
    let value = await this.value.evaluate(variableSpace, context);
    variableSpace.set(this.name, value);
    return value;
  }
  getDefaults(opts) {
    var _a;
    let type = (_a = opts.type) !== null && _a !== void 0 ? _a : C$1.STRING;
    return {
      name: "_",
      type,
      value: getDefault$1(this.registry, type)
    };
  }
  getChildSignature(child) {
    if (child === this._value) {
      return { matchingClasses: [Expression$1], matchingTypes: [this.dataType] };
    } else {
      throw new Error("the incoming node is not a child of this node");
    }
  }
  rename(newName) {
    var _a;
    this._name = newName;
    if (this.parent && this.parent.getDeclarations(this).some((n) => n.name === this.name)) {
      this.parent.replaceChild(this, new DuplicateDeclarationError("Variable already exists", { nodeRef: this }));
    } else {
      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.updateRefs();
      this.emitChange();
    }
  }
  replaceChild(oldChild, newChild) {
    if (oldChild !== this.value) {
      throw new Error("No child matching the given node");
    }
    this.value = newChild;
    this.emitChange();
  }
  get subtrees() {
    return [this.value];
  }
  get subtreeLabels() {
    return ["value"];
  }
  get title() {
    return `VAR ${this.name}`;
  }
  toJSON() {
    let json = ["var", this.name, this.dataType];
    if (this.value) {
      json.push(this.value.toJSON());
    }
    return json;
  }
  _updateRefs(variables) {
    var _a, _b;
    if ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.getDeclarations(this).some((n) => n.name === this.name)) {
      this.parent.replaceChild(this, new DuplicateDeclarationError("Duplicate declaration", { nodeRef: this }));
    } else {
      (_b = this.value) === null || _b === void 0 ? void 0 : _b._updateRefs(variables);
      variables.set(this.name, this);
    }
  }
}
class Conditional$1 extends ValidNode {
  get detail() {
    return `${C$1.COND}(${this.clauses.length} clause${this.clauses.length === 1 ? "" : "s"})`;
  }
  get subtrees() {
    return this.clauses;
  }
  get subtreeLabels() {
    return this.clauses.map((_clause, index2) => index2.toString());
  }
  constructor(registry, clauses, parent2) {
    super(C$1.COND, registry, parent2);
    this.clauses = clauses !== null && clauses !== void 0 ? clauses : this.getDefaults();
    this.clauses.forEach((clause) => clause.parent = this);
  }
  appendClause(clause) {
    this.clauses.push(clause);
    clause.parent = this;
    this.emitChange();
  }
  async _evaluate(variableSpace, context) {
    for (let clause of this.clauses) {
      let { condition, bodyVal } = await clause.evaluate(variableSpace, context);
      if (condition) {
        return bodyVal;
      }
    }
    return void 0;
  }
  getChildSignature(_node) {
    return { matchingClasses: [Clause], matchingTypes: [] };
  }
  getDefaults() {
    return [];
  }
  insertAt(index2, node2) {
    if (!(node2 instanceof ErrorNode$1) && !(node2 instanceof Clause)) {
      node2 = new TypeMismatchError("the new node is not of type clause", { nodeRef: node2 });
    }
    this.clauses.splice(index2, 0, node2);
    node2.parent = this;
    this.emitChange();
  }
  removeChild(child) {
    let index2 = this.clauses.indexOf(child);
    if (index2 > -1) {
      this.clauses.splice(index2, 1);
      this.emitChange();
    }
  }
  replaceChild(oldChild, newChild) {
    let index2 = this.clauses.indexOf(oldChild);
    if (index2 === -1) {
      throw new Error("Node not found in the list");
    }
    if (!(newChild instanceof ErrorNode$1) && !(newChild instanceof Clause)) {
      newChild = new TypeMismatchError("the new value is not of type clause", { nodeRef: newChild });
    }
    this.clauses[index2] = newChild;
    newChild.parent = this;
    this.emitChange();
  }
  get title() {
    return C$1.COND;
  }
  toJSON() {
    return ["cond", ...this.clauses.map((clause) => {
      return clause.toJSON();
    })];
  }
}
class Clause extends ValidNode {
  get detail() {
    return `if(${this.condition.detail})`;
  }
  get subtrees() {
    return [this.condition, this.body];
  }
  get subtreeLabels() {
    return ["condition", "body"];
  }
  constructor(registry, condition, body, parent2) {
    super(C$1.CLAUSE, registry, parent2);
    if (condition instanceof Expression$1 && condition.returnType !== C$1.BOOLEAN) {
      condition = new TypeMismatchError("condition's return-type must be boolean", {
        nodeRef: condition
      });
    }
    let defaults2 = this.getDefaults();
    this.condition = condition !== null && condition !== void 0 ? condition : defaults2[0];
    this.condition.parent = this;
    this.body = body !== null && body !== void 0 ? body : defaults2[1];
    this.body.parent = this;
  }
  async _evaluate(variableSpace, context) {
    let condition = await this.condition.evaluate(variableSpace, context);
    let bodyVal;
    if (condition) {
      bodyVal = await this.body.evaluate(variableSpace, context);
    }
    return { condition, bodyVal };
  }
  getChildSignature(node2) {
    if (node2 === this.condition) {
      return { matchingClasses: [Expression$1], matchingTypes: [C$1.BOOLEAN] };
    } else if (node2 === this.body) {
      return { matchingClasses: [StatementList$1], matchingTypes: [] };
    } else {
      throw new Error("the incoming node is not a child of this node");
    }
  }
  getDefaults() {
    return [
      new Literal$1(this.registry, true, this.parent),
      new StatementList$1(this.registry, [], this.parent)
    ];
  }
  replaceChild(oldChild, newChild) {
    if (oldChild === this.condition) {
      if (!(newChild instanceof ErrorNode$1) && !(newChild instanceof Expression$1)) {
        newChild = new TypeMismatchError("the new value is not of type Expression", { nodeRef: newChild });
      } else if (!(newChild instanceof ErrorNode$1) && newChild.returnType !== C$1.BOOLEAN) {
        newChild = new TypeMismatchError("the new expression's return type is different from the expected arg type", { nodeRef: newChild });
      }
      this.condition = newChild;
      newChild.parent = this;
    } else if (oldChild === this.body) {
      if (!(newChild instanceof ErrorNode$1) && !(newChild instanceof StatementList$1)) {
        newChild = new TypeMismatchError("the new value is not of type StatementList", { nodeRef: newChild });
      }
      this.body = newChild;
      newChild.parent = this;
    } else {
      throw new Error("first argument is not a child of this clause");
    }
    this.emitChange();
  }
  get title() {
    return "Clause";
  }
  toJSON() {
    return [this.condition.toJSON(), this.body.toJSON()];
  }
}
class Assignment$1 extends ValidNode {
  get reference() {
    return this._reference;
  }
  set reference(node2) {
    if (!(node2 instanceof ErrorNode$1) && !(node2 instanceof VariableReference$1)) {
      node2 = new TypeMismatchError("the new reference is not of type VariableReference", { nodeRef: node2 });
    }
    this._reference = node2;
    this._reference.parent = this;
    if (this._reference instanceof VariableReference$1 && this.value instanceof Expression$1 && this._reference.returnType !== this.value.returnType) {
      this.value = getDefault$1(this.registry, this._reference.returnType);
      this.value.parent = this;
    }
    this.emitChange();
  }
  get detail() {
    return `${this.reference.detail} = ${this.value.detail}`;
  }
  get subtrees() {
    return [this.reference, this.value];
  }
  get subtreeLabels() {
    return ["variable", "value"];
  }
  get title() {
    return "ASSIGNMENT";
  }
  constructor(registry, reference, value, parent2) {
    super(C$1.ASSIGNMENT, registry, parent2);
    let defaults2 = this.getDefaults({ reference });
    this._reference = reference !== null && reference !== void 0 ? reference : defaults2.variable;
    this._reference.parent = this;
    this.value = value !== null && value !== void 0 ? value : defaults2.value;
    this.value.parent = this;
    if (this.value instanceof Expression$1 && this.reference instanceof VariableReference$1 && this.reference.returnType !== this.value.returnType) {
      this.value = castToTypeOrError(this.registry, this.value, this.reference.returnType);
    }
  }
  async _evaluate(variableSpace, context) {
    let val = await this.value.evaluate(variableSpace, context);
    let varName = await this.reference.evaluate(variableSpace, context);
    variableSpace.update(varName, val);
    return val;
  }
  getChildSignature(node2) {
    if (node2 === this.reference) {
      return { matchingClasses: [VariableReference$1], matchingTypes: [] };
    } else if (node2 === this.value) {
      return {
        matchingClasses: [Expression$1],
        matchingTypes: this.reference instanceof VariableReference$1 && this.reference.returnType ? [this.reference.returnType] : []
      };
    } else {
      throw new Error("the incoming node is not a child of this node");
    }
  }
  getDefaults(opts) {
    var _a;
    let variable = (_a = opts.reference) !== null && _a !== void 0 ? _a : new VariableReferenceError("variable is not defined", { expr: "$_" });
    let valType = variable instanceof VariableReference$1 && variable.returnType ? variable.returnType : C$1.STRING;
    return {
      variable,
      value: getDefault$1(this.registry, valType)
    };
  }
  replaceChild(oldChild, newChild) {
    if (oldChild === this.reference) {
      if (!(newChild instanceof ErrorNode$1) && !(newChild instanceof VariableReference$1)) {
        newChild = new TypeMismatchError("the new value is not of type VariableReference", { nodeRef: newChild });
      }
      this.reference = newChild;
      newChild.parent = this;
    } else if (oldChild === this.value) {
      if (!(newChild instanceof ErrorNode$1) && !(newChild instanceof Expression$1)) {
        newChild = new TypeMismatchError("the new value is not of type Expression", { nodeRef: newChild });
      } else if (this.reference instanceof VariableReference$1 && !(newChild instanceof ErrorNode$1) && newChild.returnType !== this.reference.returnType) {
        newChild = castToTypeOrError(this.registry, newChild, this.reference.returnType);
      }
      this.value = newChild;
      newChild.parent = this;
    } else {
      throw new Error("No child matching the given node");
    }
    this.emitChange();
  }
  toJSON() {
    return ["=", this.reference.toJSON(), this.value.toJSON()];
  }
}
class Expression$1 extends ValidNode {
  constructor(type, registry, parent2) {
    super(type, registry, parent2);
  }
}
class FunctionCall$1 extends Expression$1 {
  get argList() {
    return this._argList;
  }
  set argList(newArgList) {
    let funcDef = this.registry.getFunc(this.name);
    this._argList = [];
    let argNames = Object.keys(funcDef.args);
    for (let i2 = 0; i2 < argNames.length; i2++) {
      let argDef = funcDef.args[argNames[i2]];
      if (i2 >= newArgList.length) {
        if (argDef.optional) {
          this._argList.push(new Unset$1(this.registry, this));
        } else {
          this._argList.push(new MissingArgumentError(`Missing argument at position ${i2}`));
        }
      } else if (newArgList[i2] instanceof ErrorNode$1) {
        this._argList.push(newArgList[i2]);
      } else if (newArgList[i2] instanceof Expression$1) {
        let expr = newArgList[i2];
        if (!argDef.types.includes(expr.returnType)) {
          expr = castToTypeOrError(this.registry, expr, argDef.types);
        }
        this._argList.push(expr);
      } else {
        throw new Error(`Invalid argument type at position ${i2}. Expected Expression or ErrorNode, got ${newArgList[i2].constructor.name}`);
      }
      this._argList[i2].parent = this;
    }
  }
  get returnType() {
    return this.registry.getFunc(this.name).returnType;
  }
  get subtrees() {
    return this.argList;
  }
  get subtreeLabels() {
    return Object.keys(this.registry.getFunc(this.name).args);
  }
  get detail() {
    return `${this.title}(${this.argList.map((arg) => arg.detail).join(", ")})`;
  }
  constructor(registry, name, argList, parent2) {
    super(C$1.FUNCTION_CALL, registry, parent2);
    this._argList = [];
    if (name && !this.registry.hasFunc(name))
      throw new Error(`Function ${name} not found in registry`);
    let defaults2 = this.getDefaults({ name });
    this.name = name !== null && name !== void 0 ? name : defaults2.name;
    this.argList = argList !== null && argList !== void 0 ? argList : defaults2.argList;
  }
  async _evaluate(variableSpace, context) {
    if (!variableSpace.has(this.name)) {
      variableSpace.set(this.name, this.registry.getFunc(this.name).fn(context));
    }
    let argValArr = [];
    for (let arg of this.argList) {
      argValArr.push(await arg.evaluate(variableSpace, context));
    }
    let func2 = variableSpace.get(this.name);
    return await func2(...argValArr);
  }
  getChildSignature(node2) {
    let index2 = this.argList.indexOf(node2);
    if (index2 === -1) {
      throw new Error("the incoming node is not a child of this node");
    }
    let argTypes = Object.values(this.registry.getFunc(this.name).args)[index2].types;
    return { matchingClasses: [Expression$1], matchingTypes: argTypes };
  }
  getDefaults(opts) {
    var _a;
    let name = (_a = opts === null || opts === void 0 ? void 0 : opts.name) !== null && _a !== void 0 ? _a : Object.keys(this.registry.funcs)[0];
    let funcDef = this.registry.funcs[name];
    return {
      name,
      argList: Object.values(funcDef.args).map((argDef) => getDefault$1(this.registry, argDef.types[0]))
    };
  }
  replaceChild(oldChild, newChild) {
    let index2 = this.argList.indexOf(oldChild);
    let funcDef = this.registry.getFunc(this.name);
    let argDef = Object.values(funcDef.args)[index2];
    if (index2 === -1) {
      throw new Error("oldChild is not an argument of this function call");
    }
    if (newChild instanceof ErrorNode$1) {
      this.argList[index2] = newChild;
    } else if (newChild instanceof Expression$1) {
      if (argDef.types.includes(newChild.returnType)) {
        this.argList[index2] = newChild;
      } else {
        this.argList[index2] = castToTypeOrError(this.registry, newChild, argDef.types);
      }
    } else if (newChild instanceof Unset$1) {
      if (argDef.optional) {
        this.argList[index2] = newChild;
      } else {
        throw new Error("Cannot replace a required argument with an unset");
      }
    } else {
      throw new Error("Invalid node type for replacement");
    }
    this.argList[index2].parent = this;
    this.emitChange();
  }
  get title() {
    return this.registry.getFunc(this.name).name;
  }
  toJSON() {
    return [this.name, ...this.argList.map((arg) => {
      return arg.toJSON();
    })].filter((arg) => arg !== void 0 && arg !== null);
  }
}
class VariableReference$1 extends Expression$1 {
  get detail() {
    return "$" + this.name;
  }
  get name() {
    return this._ref.name;
  }
  get returnType() {
    return this._ref.dataType;
  }
  get subtrees() {
    return [];
  }
  get subtreeLabels() {
    return [];
  }
  constructor(registry, ref, parent2) {
    super(C$1.VARIABLE_REFERENCE, registry, parent2);
    this._ref = ref;
  }
  async _evaluate(variableSpace, _context) {
    if (!variableSpace.has(this._ref.name)) {
      throw new Error(`Variable ${this._ref.name} not found in variable space`);
    } else {
      return this._ref.name;
    }
  }
  getChildSignature(_node) {
    throw new Error("VariableReference has no children");
  }
  getDefaults() {
    throw new Error("no defaults for VariableReference");
  }
  replaceChild(_oldChild, _newChild) {
    throw new Error("VariableReference has no children");
  }
  get title() {
    return `$${this.name}`;
  }
  toJSON() {
    return this.title;
  }
  _updateRefs(variables) {
    var _a;
    if (!variables.has(this.name)) {
      let expr = this.toJSON();
      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.replaceChild(this, new VariableReferenceError(`Variable Not found: ${expr}`, { expr }));
    } else if (variables.get(this.name) !== this._ref) {
      this._ref = variables.get(this.name);
      this.emitChange();
    }
  }
}
class Literal$1 extends Expression$1 {
  get detail() {
    return JSON.stringify(this.value);
  }
  get returnType() {
    return this._returnType;
  }
  get subtrees() {
    return [];
  }
  get subtreeLabels() {
    return [];
  }
  get title() {
    return this.returnType.toUpperCase();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.emitChange();
  }
  constructor(registry, value, parent2) {
    super(C$1.LITERAL, registry, parent2);
    this._value = value;
    this._returnType = getLiteralType(this.value);
  }
  async _evaluate(_variableSpace, _context) {
    return this.value;
  }
  getDefaults() {
    return {
      value: 0
    };
  }
  getChildSignature(_node) {
    throw new Error("Literal has no children");
  }
  replaceChild(_oldChild, _newChild) {
    throw new Error("Literal has no children");
  }
  toJSON() {
    return this.value;
  }
}
class StructNode$1 extends Expression$1 {
  get detail() {
    let fieldsDetail = Array.from(this.fields.entries()).filter(([_key, value]) => {
      return !(value instanceof Unset$1);
    }).map(([key, value]) => {
      return `${key}: ${value.detail}`;
    }).join(", ");
    return `${this.title}{${fieldsDetail}}`;
  }
  get fields() {
    return this._fields;
  }
  set fields(fields) {
    this._fields = /* @__PURE__ */ new Map();
    for (let key of Object.keys(this.registry.getStruct(this.name).fields)) {
      if (fields.has(key)) {
        let node2 = fields.get(key);
        let types2 = this.registry.getStruct(this.name).fields[key].types;
        if (node2 instanceof Expression$1 && !types2.includes(node2.returnType)) {
          node2 = castToTypeOrError(this.registry, node2, types2);
        }
        this._fields.set(key, node2);
      } else if (this.registry.getStruct(this.name).fields[key].optional) {
        this._fields.set(key, new Unset$1(this.registry, this));
      } else {
        this._fields.set(key, new MissingArgumentError(`Missing field ${key}`));
      }
    }
  }
  get returnType() {
    return this.name;
  }
  get subtrees() {
    return Array.from(this.fields.values());
  }
  get subtreeLabels() {
    return Object.keys(this.registry.getStruct(this.name).fields);
  }
  get title() {
    return this.registry.getStruct(this.name).name;
  }
  constructor(registry, name, fields, parent2) {
    super(C$1.STRUCT, registry, parent2);
    this._fields = /* @__PURE__ */ new Map();
    if (name && !this.registry.hasStruct(name))
      throw new Error(`Struct ${name} not found in registry`);
    let defaults2 = this.getDefaults({ name });
    this.name = name !== null && name !== void 0 ? name : defaults2.name;
    this.fields = fields !== null && fields !== void 0 ? fields : defaults2.fields;
    this.fields.forEach((field) => field.parent = this);
  }
  async _evaluate(variableSpace, context) {
    let struct = {};
    for (let [key, value] of this.fields) {
      if (value instanceof Expression$1) {
        struct[key] = await value.evaluate(variableSpace, context);
      } else if (value instanceof ErrorNode$1) {
        throw new Error("StructNode has an error in one of its fields");
      }
    }
    return struct;
  }
  get(name) {
    if (!this.fields.has(name)) {
      throw new Error("No field with that name");
    }
    return this.fields.get(name);
  }
  getChildSignature(node2) {
    let key;
    for (let [k, v] of this.fields) {
      if (v === node2) {
        key = k;
        break;
      }
    }
    if (!key) {
      throw new Error("the incoming node is not a child of this node");
    }
    let fieldTypes = this.registry.getStruct(this.name).fields[key].types;
    let res = { matchingClasses: [Expression$1], matchingTypes: fieldTypes };
    if (this.registry.getStruct(this.name).fields[key].optional) {
      res.matchingClasses.push(Unset$1);
    }
    return res;
  }
  getDefaults(opts) {
    var _a;
    let name = (_a = opts === null || opts === void 0 ? void 0 : opts.name) !== null && _a !== void 0 ? _a : Object.keys(this.registry.structs)[0];
    let structDef = this.registry.structs[name];
    let fields = /* @__PURE__ */ new Map();
    for (let key of Object.keys(structDef.fields)) {
      if (!structDef.fields[key].optional) {
        let fieldType = structDef.fields[key].types[0];
        fields.set(key, getDefault$1(this.registry, fieldType));
      }
    }
    return { name, fields };
  }
  replaceChild(oldChild, newChild) {
    let key = void 0;
    for (let [k, v] of this.fields) {
      if (v === oldChild) {
        key = k;
        break;
      }
    }
    if (!key)
      throw new Error("oldChild not found in fields");
    this.set(key, newChild);
  }
  set(name, value) {
    if (!this.fields.has(name))
      throw new Error("No field with that name");
    let types2 = this.registry.getStruct(this.name).fields[name].types;
    if (value instanceof Expression$1 && !types2.includes(value.returnType)) {
      value = castToTypeOrError(this.registry, value, types2);
    } else if (value instanceof Unset$1 && !this.registry.getStruct(this.name).fields[name].optional) {
      throw new Error("Cannot unset a required field");
    }
    this.fields.set(name, value);
    value.parent = this;
    this.emitChange();
  }
  toJSON() {
    let fieldObj = {};
    for (let key of this.fields.keys()) {
      let value = this.fields.get(key);
      if (value && !(value instanceof Unset$1)) {
        fieldObj[key] = value.toJSON();
      }
    }
    if (this.name === "selector") {
      return [this.name, fieldObj];
    } else {
      return fieldObj;
    }
  }
}
class Unset$1 extends Node$2 {
  get detail() {
    return "This optional value is not set";
  }
  get subtrees() {
    return [];
  }
  get subtreeLabels() {
    return [];
  }
  get title() {
    return "UNSET";
  }
  constructor(_registry, parent2) {
    super(C$1.UNSET, parent2);
  }
  async _evaluate(_variableSpace, _context) {
    return void 0;
  }
  toJSON() {
    return void 0;
  }
}
class EnumNode$1 extends Expression$1 {
  get detail() {
    return this.value.toString();
  }
  get returnType() {
    return this.name;
  }
  get subtrees() {
    return [];
  }
  get subtreeLabels() {
    return [];
  }
  get title() {
    return this.name.toUpperCase();
  }
  constructor(registry, name, value, parent2) {
    super(C$1.ENUM, registry, parent2);
    if (name && !this.registry.hasEnum(name))
      throw new Error(`Enum ${name} not found in registry`);
    let defaults2 = this.getDefaults({ name });
    this.name = name !== null && name !== void 0 ? name : defaults2.name;
    this.value = value !== null && value !== void 0 ? value : defaults2.value;
  }
  async _evaluate(_variableSpace, _context) {
    return this.value;
  }
  getChildSignature(_node) {
    throw new Error("Enums have no children");
  }
  getDefaults(opts) {
    var _a;
    let name = (_a = opts === null || opts === void 0 ? void 0 : opts.name) !== null && _a !== void 0 ? _a : Object.keys(this.registry.enums)[0];
    let value = this.registry.enums[name].values[0];
    return { name, value };
  }
  replaceChild(_oldChild, _newChild) {
    throw new Error("Enums have no children");
  }
  toJSON() {
    return this.value;
  }
}
class ErrorNode$1 extends Node$2 {
  get msg() {
    return `${this.code}: ${this.description}`;
  }
  get subtrees() {
    return [];
  }
  get subtreeLabels() {
    return [];
  }
  get title() {
    return this.code;
  }
  get detail() {
    return `${this.code}(${this.description})`;
  }
  constructor(code, description, opt) {
    var _a;
    super(C$1.ERROR, (_a = opt === null || opt === void 0 ? void 0 : opt.nodeRef) === null || _a === void 0 ? void 0 : _a.parent);
    this.code = code;
    this.description = description;
    this.expr = opt === null || opt === void 0 ? void 0 : opt.expr;
    this.nodeRef = opt === null || opt === void 0 ? void 0 : opt.nodeRef;
    if (this.nodeRef) {
      this.nodeRef.parent = void 0;
    }
  }
  async _evaluate(_variableSpace, _context) {
    throw new Error("Error nodes cannot be evaluated");
  }
  toJSON() {
    if (this.nodeRef) {
      return this.nodeRef.toJSON();
    } else if (this.expr) {
      return this.expr;
    } else {
      return ["ERROR", this.code, this.description];
    }
  }
}
class DuplicateDeclarationError extends ErrorNode$1 {
  constructor(msg, opt) {
    super(C$1.DUPLICATE_DECLARATION, msg, opt);
  }
  _updateRefs(_variables) {
    if (this.nodeRef && this.parent && this.parent instanceof StatementList$1 && !this.parent.getDeclarations(this).some((n) => n.name === this.nodeRef.name)) {
      this.parent.replaceChild(this, this.nodeRef);
    }
  }
}
class MissingArgumentError extends ErrorNode$1 {
  constructor(msg, opt) {
    super(C$1.MISSING_ARGUMENT, msg, opt);
  }
}
class SyntaxError$1 extends ErrorNode$1 {
  constructor(msg, opt) {
    super(C$1.INVALID_SYNTAX, msg, opt);
  }
}
class TypeMismatchError extends ErrorNode$1 {
  constructor(msg, opt) {
    super(C$1.TYPE_MISMATCH, msg, opt);
  }
}
class UndefinedTypeError extends ErrorNode$1 {
  constructor(msg, opt) {
    super(C$1.UNDEFINED_TYPE, msg, opt);
  }
}
class VariableNameError extends ErrorNode$1 {
  constructor(msg, opt) {
    super(C$1.INVALID_VARIABLE_NAME, msg, opt);
  }
}
class VariableReferenceError extends ErrorNode$1 {
  constructor(msg, opt) {
    super(C$1.INVALID_VARIABLE_REFERENCE, msg, opt);
  }
  _updateRefs(variables) {
    if (this.expr && typeof this.expr === "string" && this.expr.slice(1).length > 0) {
      let name = this.expr.slice(1);
      if (this.parent && variables.has(name)) {
        this.parent.replaceChild(this, new VariableReference$1(this.parent.registry, variables.get(name)));
      }
    }
  }
}
class VariableTypeError extends ErrorNode$1 {
  constructor(msg, opt) {
    super(C$1.INVALID_VARIABLE_TYPE, msg, opt);
  }
}
function isParentNode(node2) {
  return "subtrees" in node2 && Array.isArray(node2.subtrees);
}
class VariableSpace {
  constructor() {
    this._space = {};
    this._space = {};
  }
  set(name, value) {
    if (RESERVED.includes(name)) {
      throw new Error(`Cannot use reserved word ${name} as variable name`);
    }
    if (name in this._space) {
      throw new Error(`Variable ${name} already exists`);
    }
    if (!isValidType(value) && !isFunction(value)) {
      throw new Error(`Error setting variable: "${name}". Value: "${JSON.stringify(value)}" doesn't match any valid type.`);
    }
    this._space[name] = value;
  }
  get(name) {
    if (name in this._space) {
      return this._space[name];
    } else {
      throw new Error(`Variable ${name} does not exist`);
    }
  }
  update(name, value) {
    if (!this.has(name)) {
      throw new Error(`Variable ${name} does not exist`);
    }
    if (!isValidType(value)) {
      throw new Error(`Error updating variable: "${name}". Value: "${JSON.stringify(value)}" doesn't match any valid type.`);
    }
    this._space[name] = value;
  }
  has(name) {
    return name in this._space;
  }
}
class VM$1 extends EventEmitter$1 {
  get tree() {
    return this._tree;
  }
  constructor(registry, context, source) {
    super();
    this._registry = registry;
    this._context = context;
    this._variables = new VariableSpace();
    if (source) {
      if (source instanceof Node$2) {
        this._tree = source;
      } else if (Array.isArray(source)) {
        this._tree = parseList(source, this._registry);
      } else {
        throw new Error("Invalid source");
      }
    }
  }
  interrupt() {
    var _a;
    (_a = this._tree) === null || _a === void 0 ? void 0 : _a.interrupt();
  }
  async run() {
    if (!this._tree) {
      console.error("source not set");
      return;
    }
    try {
      this._tree._clearInterrupt();
      return await this._tree.evaluate(this._variables, this._context);
    } finally {
      this._tree._clearInterrupt();
    }
  }
}
const VERSION = 2;
class Player$1 extends EventEmitter$1 {
  constructor(source, browser2) {
    super();
    this.emitChange = (node2) => {
      this.emit("statusChange", { step: node2 });
    };
    this.onStatusChange = (tree) => {
      if ((tree === null || tree === void 0 ? void 0 : tree.type) === C$1.STATEMENT_LIST) {
        for (let subtree of tree.nodes) {
          subtree.on(C$1.EVALUATE_START, this.emitChange);
        }
      }
    };
    this.offStatusChange = (tree) => {
      if ((tree === null || tree === void 0 ? void 0 : tree.type) === C$1.STATEMENT_LIST) {
        for (let subtree of tree.nodes) {
          subtree.off(C$1.EVALUATE_START, this.emitChange);
        }
      }
    };
    let registry;
    if (source instanceof ValidNode) {
      registry = source.registry;
    } else {
      registry = new Registry({
        funcs: { ...stepDefs, ...conditionDefs },
        structs: structDefs,
        enums: enumDefs
      });
    }
    let context = { browser: browser2 };
    this.vm = new VM$1(registry, context, source);
  }
  interrupt() {
    this.vm.interrupt();
  }
  async play() {
    let tree = this.vm.tree;
    this.onStatusChange(tree);
    let res = await this.vm.run();
    this.offStatusChange(tree);
    return res;
  }
}
function create_fragment$1e(ctx) {
  let svg;
  let g;
  let path;
  let svg_levels = [
    { fill: ctx[0] },
    { "stroke-width": ctx[1] },
    { viewBox: "0 0 24 24" },
    { xmlns: "http://www.w3.org/2000/svg" },
    ctx[2]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path = svg_element("path");
      attr(path, "d", "m4.8 21.57 2.422 2.43 11.978-12-11.978-12-2.422 2.43 9.547 9.57z");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & 1 && { fill: ctx2[0] },
        dirty & 2 && { "stroke-width": ctx2[1] },
        { viewBox: "0 0 24 24" },
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & 4 && ctx2[2]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$1b($$self, $$props, $$invalidate) {
  const omit_props_names = ["strokeColor", "strokeWidth"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 4 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("strokeColor" in $$new_props)
      $$invalidate(0, strokeColor = $$new_props.strokeColor);
    if ("strokeWidth" in $$new_props)
      $$invalidate(1, strokeWidth = $$new_props.strokeWidth);
  };
  return [strokeColor, strokeWidth, $$restProps];
}
class AngleRight extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1b, create_fragment$1e, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
const get_tip_slot_changes = (dirty) => ({});
const get_tip_slot_context = (ctx) => ({});
function create_else_block$t(ctx) {
  let current;
  const tip_slot_template = ctx[8].tip;
  const tip_slot = create_slot(tip_slot_template, ctx, ctx[7], get_tip_slot_context);
  return {
    c() {
      if (tip_slot)
        tip_slot.c();
    },
    m(target, anchor) {
      if (tip_slot) {
        tip_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tip_slot) {
        if (tip_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            tip_slot,
            tip_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(tip_slot_template, ctx2[7], dirty, get_tip_slot_changes),
            get_tip_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tip_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tip_slot, local);
      current = false;
    },
    d(detaching) {
      if (tip_slot)
        tip_slot.d(detaching);
    }
  };
}
function create_if_block$A(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$1d(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block;
  let div0_style_value;
  let t;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$A, create_else_block$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "bbx-tooltip-text bbx-pad-x");
      attr(div0, "style", div0_style_value = `top: ${ctx[1]}px; left: ${ctx[2]}px; visibility: ${ctx[3] ? "visible" : "hidden"}`);
      attr(div1, "class", "bbx-tooltip");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div1, t);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "mouseenter", ctx[4]),
          listen(div1, "mouseleave", ctx[6]),
          listen(div1, "mousemove", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
      if (!current || dirty & 14 && div0_style_value !== (div0_style_value = `top: ${ctx2[1]}px; left: ${ctx2[2]}px; visibility: ${ctx2[3] ? "visible" : "hidden"}`)) {
        attr(div0, "style", div0_style_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1a($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { tip } = $$props;
  let top = 0;
  let left = 0;
  let visible = false;
  let timer;
  function mouseEnter(e) {
    $$invalidate(1, top = e.clientY + 20);
    $$invalidate(2, left = e.clientX + -20);
    timer = setTimeout(
      () => {
        $$invalidate(3, visible = true);
      },
      1e3
    );
  }
  function mouseMove(e) {
    clearTimeout(timer);
    $$invalidate(3, visible = false);
    $$invalidate(1, top = e.clientY + 20);
    $$invalidate(2, left = e.clientX + -20);
    timer = setTimeout(
      () => {
        $$invalidate(3, visible = true);
      },
      1e3
    );
  }
  function mouseLeave(e) {
    clearTimeout(timer);
    $$invalidate(1, top = 0);
    $$invalidate(2, left = 0);
    $$invalidate(3, visible = false);
  }
  $$self.$$set = ($$props2) => {
    if ("tip" in $$props2)
      $$invalidate(0, tip = $$props2.tip);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [tip, top, left, visible, mouseEnter, mouseMove, mouseLeave, $$scope, slots];
}
class Tooltip extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1a, create_fragment$1d, safe_not_equal, { tip: 0 });
  }
}
function create_fragment$1c(ctx) {
  let svg;
  let g;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path = svg_element("path");
      attr(path, "d", "M31.449 6.748c-0.337-0.155-0.737-0.096-1.017 0.152l-5.041 4.528-4.551-4.669 4.506-5.204c0.245-0.283 0.305-0.673 0.152-1.016s-0.489-0.553-0.86-0.553h-0.271c-2.785 0-7.593 0.239-9.739 2.417l-0.433 0.43c-2.29 2.337-2.697 6.168-1.49 9.081l-11.54 11.778c-1.556 1.578-1.556 4.135 0 5.713l1.409 1.428c0.778 0.788 1.798 1.183 2.818 1.183s2.040-0.395 2.817-1.183l11.71-11.804c1.107 0.599 2.625 0.989 3.899 0.989 2.043 0 3.98-0.824 5.454-2.32l0.427-0.433c2.331-2.364 2.296-7.416 2.306-9.638 0.001-0.378-0.216-0.721-0.554-0.878zM28.302 15.906l-0.371 0.433c-1.117 1.134-2.578 1.677-4.114 1.677-0.76 0-1.784-0.143-2.476-0.431-0.625-0.259-1.206-0.634-1.725-1.107l-12.818 12.925c-0.376 0.382-0.876 0.592-1.408 0.592s-1.032-0.21-1.409-0.592l-1.408-1.427c-0.777-0.788-0.777-2.070-0.001-2.857l12.524-12.777c-0.42-0.611-0.706-1.278-0.877-1.968h-0.001c-0.482-1.95-0.201-4.644 1.313-6.189l0.431-0.435c1.298-1.317 4.67-1.707 6.537-1.822l-3.668 4.236c-0.328 0.379-0.311 0.95 0.038 1.309l5.798 5.948c0.352 0.362 0.92 0.383 1.299 0.047l4.082-3.676c-0.122 1.98-0.506 4.856-1.748 6.115z");
      attr(svg, "fill", "#000000");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", ctx[1]);
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "stroke-width", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$19($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class Wrench extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$19, create_fragment$1c, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function getSelectorNode(n) {
  let selector;
  for (let subtree of n.subtrees) {
    if (subtree.type === "STRUCT" && subtree.name === "selector") {
      selector = subtree.toJSON()[1];
      break;
    }
  }
  return selector;
}
function getFrameNode(n) {
  let frame;
  for (let subtree of n.iterator()) {
    if (subtree.type === "STRUCT" && (subtree.name === "default_opts" || subtree.name === "click_opts") && subtree.fields.has("frame")) {
      frame = subtree.fields.get("frame").toJSON();
      break;
    }
  }
  return frame;
}
function setSelector(n, selector) {
  for (let subtree of n.subtrees) {
    if (subtree.type === "STRUCT" && subtree.name === "selector") {
      subtree.parent.replaceChild(subtree, parseExpression(selector, n.registry));
      break;
    }
  }
}
function setFrame(n, frame) {
  let optsNode;
  for (let subtree of n.iterator()) {
    if (subtree.type === "STRUCT" && (subtree.name === "default_opts" || subtree.name === "click_opts")) {
      optsNode = subtree;
      break;
    }
  }
  if (!optsNode) {
    let funcDef = n.registry.getFunc(n.name);
    if (funcDef.optionalArgs > 0) {
      for (let i2 = Object.keys(funcDef.args).length - funcDef.optionalArgs; i2 < Object.keys(funcDef.args).length; i2++) {
        let argName = Object.keys(funcDef.args)[i2];
        if (funcDef.args[argName].types.includes("click_opts")) {
          optsNode = new StructNode$1(n.registry, "click_opts");
          n.replaceChild(n.argList[i2], optsNode);
          break;
        } else if (funcDef.args[argName].includes("default_opts")) {
          optsNode = new StructNode$1(n.registry, "default_opts");
          n.replaceChild(n.argList[i2], optsNode);
          break;
        }
      }
    }
  }
  if (optsNode) {
    optsNode.fields.set("frame", parseExpression(frame, n.registry));
  }
}
function create_fragment$1b(ctx) {
  let svg;
  let g0;
  let g1;
  let g2;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path, "d", "M19 5L4.99998 19M5.00001 5L19 19");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", ctx[1]);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g0);
      append(svg, g1);
      append(svg, g2);
      append(g2, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "stroke-width", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$18($$self, $$props, $$invalidate) {
  let { strokeColor = "black" } = $$props;
  let { strokeWidth = 4 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class Cross extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$18, create_fragment$1b, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function create_fragment$1a(ctx) {
  let svg;
  let path;
  let animateTransform;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      animateTransform = svg_element("animateTransform");
      attr(animateTransform, "attributeName", "transform");
      attr(animateTransform, "attributeType", "XML");
      attr(animateTransform, "type", "rotate");
      attr(animateTransform, "dur", "1s");
      attr(animateTransform, "from", "0 50 50");
      attr(animateTransform, "to", "360 50 50");
      attr(animateTransform, "repeatCount", "indefinite");
      attr(path, "fill", ctx[0]);
      attr(path, "d", "M31.6,3.5C5.9,13.6-6.6,42.7,3.5,68.4c10.1,25.7,39.2,38.3,64.9,28.1l-3.1-7.9c-21.3,8.4-45.4-2-53.8-23.3\n  c-8.4-21.3,2-45.4,23.3-53.8L31.6,3.5z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "x", "0px");
      attr(svg, "y", "0px");
      attr(svg, "viewBox", "0 0 100 100");
      attr(svg, "xml:space", "preserve");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(path, animateTransform);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(path, "fill", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$17($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 4 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class Loading$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$17, create_fragment$1a, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function create_fragment$19(ctx) {
  let svg;
  let g4;
  let g3;
  let g1;
  let g0;
  let path;
  let g2;
  let polygon;
  return {
    c() {
      svg = svg_element("svg");
      g4 = svg_element("g");
      g3 = svg_element("g");
      g1 = svg_element("g");
      g0 = svg_element("g");
      path = svg_element("path");
      g2 = svg_element("g");
      polygon = svg_element("polygon");
      attr(path, "d", "M181.512,363.024C81.43,363.024,0,281.601,0,181.513C0,81.424,81.43,0,181.512,0 c100.083,0,181.513,81.424,181.513,181.513C363.025,281.601,281.595,363.024,181.512,363.024z M181.512,11.71 C87.88,11.71,11.71,87.886,11.71,181.513s76.17,169.802,169.802,169.802c93.633,0,169.803-76.175,169.803-169.802 S275.145,11.71,181.512,11.71z");
      attr(polygon, "points", "147.957,258.935 83.068,194.046 91.348,185.767 147.957,242.375 271.171,119.166 279.451,127.445 ");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg, "viewBox", "-18.15 -18.15 399.32 399.32");
      attr(svg, "fill", ctx[0]);
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", ctx[1]);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g4);
      append(g4, g3);
      append(g3, g1);
      append(g1, g0);
      append(g0, path);
      append(g3, g2);
      append(g2, polygon);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "fill", ctx2[0]);
      }
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "stroke-width", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$16($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 8 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class TickCircle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$16, create_fragment$19, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function create_if_block_2$f(ctx) {
  let tooltip;
  let current;
  tooltip = new Tooltip({
    props: {
      tip: "Error",
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tooltip.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tooltip, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(tooltip.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tooltip.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tooltip, detaching);
    }
  };
}
function create_if_block_1$m(ctx) {
  let tooltip;
  let current;
  tooltip = new Tooltip({
    props: {
      tip: "Done",
      $$slots: { default: [create_default_slot_1$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tooltip.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tooltip, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(tooltip.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tooltip.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tooltip, detaching);
    }
  };
}
function create_if_block$z(ctx) {
  let tooltip;
  let current;
  tooltip = new Tooltip({
    props: {
      tip: "Running",
      $$slots: { default: [create_default_slot$s] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tooltip.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tooltip, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(tooltip.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tooltip.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tooltip, detaching);
    }
  };
}
function create_default_slot_2$3(ctx) {
  let cross;
  let current;
  cross = new Cross({ props: { strokeColor: "red" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_default_slot_1$d(ctx) {
  let tickcircle;
  let current;
  tickcircle = new TickCircle({
    props: { strokeColor: "green", strokeWidth: "18" }
  });
  return {
    c() {
      create_component(tickcircle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tickcircle, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tickcircle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tickcircle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tickcircle, detaching);
    }
  };
}
function create_default_slot$s(ctx) {
  let loading2;
  let current;
  loading2 = new Loading$1({
    props: { strokeColor: "blue", strokeWidth: "18" }
  });
  return {
    c() {
      create_component(loading2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading2, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loading2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading2, detaching);
    }
  };
}
function create_fragment$18(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$z, create_if_block_1$m, create_if_block_2$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === "playing")
      return 0;
    if (ctx2[1] === "completed")
      return 1;
    if (ctx2[1] === "error")
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let div_levels = [{ style: "width: 2rem; height: 2rem" }, ctx[4]];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { style: "width: 2rem; height: 2rem" },
        dirty & 16 && ctx2[4]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$15($$self, $$props, $$invalidate) {
  var _a;
  const omit_props_names = ["node"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $statusStore;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(6, $node = $$value)), node2);
  let $errorStore;
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  const errorStore = getContext("errorStore");
  component_subscribe($$self, errorStore, (value) => $$invalidate(7, $errorStore = value));
  const statusStore = getContext("statusStore");
  component_subscribe($$self, statusStore, (value) => $$invalidate(5, $statusStore = value));
  let replayStatus = $errorStore.nodeStack.includes($node) ? "error" : "ready";
  function replayStart() {
    $$invalidate(1, replayStatus = "playing");
  }
  function replayEnd() {
    $$invalidate(1, replayStatus = "completed");
  }
  if (((_a = node2.parent) == null ? void 0 : _a.type) === "STATEMENT_LIST") {
    node2.on(C$1.EVALUATE_START, replayStart);
    node2.on(C$1.EVALUATE_END, replayEnd);
  }
  onDestroy(() => {
    var _a2;
    if (((_a2 = node2.parent) == null ? void 0 : _a2.type) === "STATEMENT_LIST") {
      node2.off(C$1.EVALUATE_START, replayStart);
      node2.off(C$1.EVALUATE_END, replayEnd);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("node" in $$new_props)
      $$subscribe_node($$invalidate(0, node2 = $$new_props.node));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 192) {
      if ($errorStore.nodeStack.includes($node))
        $$invalidate(1, replayStatus = "error");
    }
    if ($$self.$$.dirty & 32) {
      if ($statusStore !== "ready")
        $$invalidate(1, replayStatus = "ready");
    }
  };
  return [
    node2,
    replayStatus,
    errorStore,
    statusStore,
    $$restProps,
    $statusStore,
    $node,
    $errorStore
  ];
}
class ReplayStatus extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$15, create_fragment$18, safe_not_equal, { node: 0 });
  }
}
function create_fragment$17(ctx) {
  let a;
  let a_href_value;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let a_levels = [
    { href: a_href_value = "#" },
    {
      class: a_class_value = "bbx-menu-item bbx-pad-2 bbx-pad-y " + ctx[0]
    },
    { role: "menuitem" },
    { tabindex: "-1" },
    ctx[1]
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[4]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { href: a_href_value },
        (!current || dirty & 1 && a_class_value !== (a_class_value = "bbx-menu-item bbx-pad-2 bbx-pad-y " + ctx2[0])) && { class: a_class_value },
        { role: "menuitem" },
        { tabindex: "-1" },
        dirty & 2 && ctx2[1]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$14($$self, $$props, $$invalidate) {
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: clazz = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, clazz = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  return [clazz, $$restProps, $$scope, slots, click_handler];
}
class MenuItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$14, create_fragment$17, safe_not_equal, { class: 0 });
  }
}
function keypressEscape(node2) {
  const handleKey = (event) => {
    if (event.key == "Escape") {
      node2.dispatchEvent(new CustomEvent("escape"));
    }
  };
  document.body.addEventListener("keydown", handleKey, true);
  return {
    destroy() {
      document.body.removeEventListener("keydown", handleKey, true);
    }
  };
}
function clickOutside(node2) {
  const handleClick = (event) => {
    if (!node2.contains(event.target)) {
      node2.dispatchEvent(new CustomEvent("outclick"));
    }
  };
  document.addEventListener("click", handleClick, true);
  return {
    destroy() {
      document.removeEventListener("click", handleClick, true);
    }
  };
}
function create_fragment$16(ctx) {
  let div1;
  let div0;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "role", "none");
      attr(div1, "class", "bbx-menu");
      attr(div1, "role", "menu");
      attr(div1, "aria-orientation", "vertical");
      attr(div1, "aria-labelledby", "menu-button");
      attr(div1, "tabindex", "-1");
      attr(div1, "style", div1_style_value = `top: ${ctx[0] - ctx[3]}px; right: ${ctx[1]}px;`);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[9](div1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(keypressEscape.call(null, div1)),
          action_destroyer(clickOutside.call(null, div1)),
          listen(div1, "click", ctx[6]),
          listen(div1, "escape", ctx[7]),
          listen(div1, "outclick", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 11 && div1_style_value !== (div1_style_value = `top: ${ctx2[0] - ctx2[3]}px; right: ${ctx2[1]}px;`)) {
        attr(div1, "style", div1_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { top } = $$props;
  let { right } = $$props;
  let menuElement;
  function updateMenuPosition(menuElement2) {
    if (!menuElement2)
      return 0;
    const menuBottom = parseFloat(menuElement2.style.top) + menuElement2.offsetHeight;
    return menuBottom > window.innerHeight ? menuBottom - window.innerHeight : topOffset;
  }
  let topOffset = 0;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function escape_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuElement = $$value;
      $$invalidate(2, menuElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("top" in $$props2)
      $$invalidate(0, top = $$props2.top);
    if ("right" in $$props2)
      $$invalidate(1, right = $$props2.right);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(3, topOffset = updateMenuPosition(menuElement));
    }
  };
  return [
    top,
    right,
    menuElement,
    topOffset,
    $$scope,
    slots,
    click_handler,
    escape_handler,
    outclick_handler,
    div1_binding
  ];
}
class Menu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$13, create_fragment$16, safe_not_equal, { top: 0, right: 1 });
  }
}
function create_fragment$15(ctx) {
  let a;
  let a_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      var _a, _b;
      a = element("a");
      if (default_slot)
        default_slot.c();
      attr(a, "href", "javascript:void(0)");
      attr(a, "class", "bbx-action-icon");
      attr(a, "style", a_style_value = `width: ${(_a = ctx[0]) != null ? _a : ctx[2]}; height: ${(_b = ctx[1]) != null ? _b : ctx[2]}`);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a, _b;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 7 && a_style_value !== (a_style_value = `width: ${(_a = ctx2[0]) != null ? _a : ctx2[2]}; height: ${(_b = ctx2[1]) != null ? _b : ctx2[2]}`)) {
        attr(a, "style", a_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { width = null } = $$props;
  let { height = null } = $$props;
  let { size = "14px" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("size" in $$props2)
      $$invalidate(2, size = $$props2.size);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [width, height, size, $$scope, slots, click_handler];
}
class IconBtn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$12, create_fragment$15, safe_not_equal, { width: 0, height: 1, size: 2 });
  }
}
function create_fragment$14(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M3 9.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z");
      attr(svg, "fill", "black");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 16 16");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class Ellipsis extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$14, safe_not_equal, {});
  }
}
const get_items_slot_changes = (dirty) => ({});
const get_items_slot_context = (ctx) => ({});
function create_default_slot_2$2(ctx) {
  let ellipsis;
  let current;
  ellipsis = new Ellipsis({});
  return {
    c() {
      create_component(ellipsis.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ellipsis, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(ellipsis.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ellipsis.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ellipsis, detaching);
    }
  };
}
function create_default_slot_1$c(ctx) {
  let iconbtn;
  let current;
  iconbtn = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  iconbtn.$on("click", ctx[4]);
  return {
    c() {
      create_component(iconbtn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbtn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const iconbtn_changes = {};
      if (dirty & 128) {
        iconbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn.$set(iconbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbtn, detaching);
    }
  };
}
function create_if_block$y(ctx) {
  let menu;
  let current;
  menu = new Menu({
    props: {
      top: ctx[1],
      right: ctx[2],
      $$slots: { default: [create_default_slot$r] },
      $$scope: { ctx }
    }
  });
  menu.$on("click", ctx[3]);
  menu.$on("escape", ctx[3]);
  menu.$on("outclick", ctx[3]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menu_changes = {};
      if (dirty & 2)
        menu_changes.top = ctx2[1];
      if (dirty & 4)
        menu_changes.right = ctx2[2];
      if (dirty & 128) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function create_default_slot$r(ctx) {
  let current;
  const items_slot_template = ctx[6].items;
  const items_slot = create_slot(items_slot_template, ctx, ctx[7], get_items_slot_context);
  return {
    c() {
      if (items_slot)
        items_slot.c();
    },
    m(target, anchor) {
      if (items_slot) {
        items_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (items_slot) {
        if (items_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            items_slot,
            items_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(items_slot_template, ctx2[7], dirty, get_items_slot_changes),
            get_items_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(items_slot, local);
      current = true;
    },
    o(local) {
      transition_out(items_slot, local);
      current = false;
    },
    d(detaching) {
      if (items_slot)
        items_slot.d(detaching);
    }
  };
}
function create_fragment$13(ctx) {
  let tooltip;
  let t;
  let if_block_anchor;
  let current;
  tooltip = new Tooltip({
    props: {
      tip: "Menu",
      $$slots: { default: [create_default_slot_1$c] },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[0] && create_if_block$y(ctx);
  return {
    c() {
      create_component(tooltip.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(tooltip, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tooltip_changes = {};
      if (dirty & 128) {
        tooltip_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip.$set(tooltip_changes);
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tooltip.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(tooltip.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(tooltip, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { open = false } = $$props;
  let { class: clazz = "" } = $$props;
  const dispatch = createEventDispatcher();
  let top;
  let right;
  function close() {
    $$invalidate(0, open = false);
    dispatch("close");
  }
  function onClick(e) {
    $$invalidate(0, open = !open);
    let rect = e.target.parentElement.getBoundingClientRect();
    $$invalidate(1, top = rect.top);
    $$invalidate(2, right = window.innerWidth - rect.right - 12);
    dispatch("open");
  }
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("class" in $$props2)
      $$invalidate(5, clazz = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [open, top, right, close, onClick, clazz, slots, $$scope];
}
class MenuBtn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$11, create_fragment$13, safe_not_equal, { open: 0, class: 5 });
  }
}
function create_fragment$12(ctx) {
  let div1;
  let div0;
  let div0_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "bbx-modal-item");
      attr(div0, "style", div0_style_value = `top: ${ctx[1].top - ctx[3] + 2}px; right: ${window.innerWidth - ctx[1].right}px;`);
      attr(div1, "class", "bbx-modal bbx-flex bbx-justify-center bbx-border");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[6](div0);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(keypressEscape.call(null, div0)),
          listen(div0, "escape", function() {
            if (is_function(ctx[0]))
              ctx[0].apply(this, arguments);
          }),
          action_destroyer(clickOutside.call(null, div0)),
          listen(div0, "outclick", function() {
            if (is_function(ctx[0]))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[4],
            !current ? get_all_dirty_from_scope(ctx[4]) : get_slot_changes(default_slot_template, ctx[4], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 10 && div0_style_value !== (div0_style_value = `top: ${ctx[1].top - ctx[3] + 2}px; right: ${window.innerWidth - ctx[1].right}px;`)) {
        attr(div0, "style", div0_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { close = () => {
  } } = $$props;
  let { rect = {
    top: window.innerHeight * 0.2,
    right: window.innerWidth - 20
  } } = $$props;
  let modalElement;
  function updateMenuPosition(modalElement2) {
    if (!modalElement2)
      return 0;
    const menuBottom = parseFloat(modalElement2.style.top) + modalElement2.offsetHeight;
    return menuBottom > window.innerHeight ? menuBottom - window.innerHeight : topOffset;
  }
  let topOffset = 0;
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modalElement = $$value;
      $$invalidate(2, modalElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("close" in $$props2)
      $$invalidate(0, close = $$props2.close);
    if ("rect" in $$props2)
      $$invalidate(1, rect = $$props2.rect);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(3, topOffset = updateMenuPosition(modalElement));
    }
  };
  return [close, rect, modalElement, topOffset, $$scope, slots, div0_binding];
}
class Modal$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$10, create_fragment$12, safe_not_equal, { close: 0, rect: 1 });
  }
}
function create_default_slot_1$b(ctx) {
  let cross;
  let current;
  cross = new Cross({ props: { strokeColor: "#666" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_default_slot$q(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let iconbtn;
  let t2;
  let div3;
  let t3;
  let div4;
  let a;
  let t5;
  let button;
  let t6;
  let current;
  let mounted;
  let dispose;
  iconbtn = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_1$b] },
      $$scope: { ctx }
    }
  });
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      div1 = element("div");
      create_component(iconbtn.$$.fragment);
      t2 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div4 = element("div");
      a = element("a");
      a.textContent = "Cancel";
      t5 = space();
      button = element("button");
      t6 = text(ctx[2]);
      attr(div0, "class", "bbx-header");
      attr(div2, "class", "bbx-modal-title");
      attr(div3, "class", "bbx-pad-2");
      attr(a, "class", "");
      attr(a, "href", "#");
      attr(button, "class", "bbx-primary");
      button.disabled = ctx[3];
      attr(div4, "class", "bbx-flex bbx-pad-2 bbx-gap-2x bbx-align-center");
      set_style(div4, "justify-content", "right");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      mount_component(iconbtn, div1, null);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      insert(target, t3, anchor);
      insert(target, div4, anchor);
      append(div4, a);
      append(div4, t5);
      append(div4, button);
      append(button, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "click", ctx[6]),
          listen(a, "click", prevent_default(ctx[7])),
          listen(button, "click", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 1)
        set_data(t0, ctx2[0]);
      const iconbtn_changes = {};
      if (dirty & 1024) {
        iconbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn.$set(iconbtn_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4)
        set_data(t6, ctx2[2]);
      if (!current || dirty & 8) {
        button.disabled = ctx2[3];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(iconbtn);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$11(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      rect: ctx[1],
      close: ctx[9],
      $$slots: { default: [create_default_slot$q] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 2)
        modal_changes.rect = ctx2[1];
      if (dirty & 1037) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$$($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { title } = $$props;
  let { rect } = $$props;
  let { actionLabel = "Save" } = $$props;
  let { disableAction = false } = $$props;
  const click_handler = () => dispatch("cancel");
  const click_handler_1 = () => dispatch("cancel");
  const click_handler_2 = () => dispatch("save");
  const func2 = () => dispatch("cancel");
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("rect" in $$props2)
      $$invalidate(1, rect = $$props2.rect);
    if ("actionLabel" in $$props2)
      $$invalidate(2, actionLabel = $$props2.actionLabel);
    if ("disableAction" in $$props2)
      $$invalidate(3, disableAction = $$props2.disableAction);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    title,
    rect,
    actionLabel,
    disableAction,
    dispatch,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    func2,
    $$scope
  ];
}
class SaveCancelModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$$, create_fragment$11, safe_not_equal, {
      title: 0,
      rect: 1,
      actionLabel: 2,
      disableAction: 3
    });
  }
}
function create_default_slot$p(ctx) {
  let textarea;
  let textarea_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      textarea.value = ctx[0];
      attr(textarea, "style", textarea_style_value = "width: 60vw; height: 20vh;" + (ctx[2] ? "" : "color: red;"));
      textarea.autofocus = true;
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      textarea.focus();
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        textarea.value = ctx2[0];
      }
      if (dirty & 4 && textarea_style_value !== (textarea_style_value = "width: 60vw; height: 20vh;" + (ctx2[2] ? "" : "color: red;"))) {
        attr(textarea, "style", textarea_style_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$10(ctx) {
  let savecancelmodal;
  let current;
  savecancelmodal = new SaveCancelModal({
    props: {
      title: "Source Editor",
      rect: ctx[1],
      disableAction: !ctx[2],
      $$slots: { default: [create_default_slot$p] },
      $$scope: { ctx }
    }
  });
  savecancelmodal.$on("cancel", ctx[5]);
  savecancelmodal.$on("save", ctx[6]);
  return {
    c() {
      create_component(savecancelmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savecancelmodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savecancelmodal_changes = {};
      if (dirty & 2)
        savecancelmodal_changes.rect = ctx2[1];
      if (dirty & 4)
        savecancelmodal_changes.disableAction = !ctx2[2];
      if (dirty & 133) {
        savecancelmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savecancelmodal.$set(savecancelmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savecancelmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savecancelmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savecancelmodal, detaching);
    }
  };
}
function instance$_($$self, $$props, $$invalidate) {
  let { newSource } = $$props;
  let { rect } = $$props;
  const dispatch = createEventDispatcher();
  let jsonIsValid = true;
  function changeSource(e) {
    $$invalidate(0, newSource = e.target.value);
    try {
      JSON.parse(newSource);
      $$invalidate(2, jsonIsValid = true);
    } catch (e2) {
      $$invalidate(2, jsonIsValid = false);
    }
  }
  const cancel_handler = () => dispatch("cancel");
  const save_handler = () => dispatch("save", newSource);
  $$self.$$set = ($$props2) => {
    if ("newSource" in $$props2)
      $$invalidate(0, newSource = $$props2.newSource);
    if ("rect" in $$props2)
      $$invalidate(1, rect = $$props2.rect);
  };
  return [
    newSource,
    rect,
    jsonIsValid,
    dispatch,
    changeSource,
    cancel_handler,
    save_handler
  ];
}
class SourceEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$_, create_fragment$10, safe_not_equal, { newSource: 0, rect: 1 });
  }
}
const get_default_slot_changes = (dirty) => ({ getRect: dirty & 4 });
const get_default_slot_context = (ctx) => ({ getRect: ctx[2] });
function create_default_slot_5(ctx) {
  let t;
  return {
    c() {
      t = text("Replace");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$e(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[19]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 33554432) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let t;
  return {
    c() {
      t = text("Unset Optional Field");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$e(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[11]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 33554432) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$l(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let current;
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", ctx[20]);
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$a] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[21]);
  menuitem2 = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$o] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", ctx[22]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & 33554432) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 33554432) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & 33554432) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let t;
  return {
    c() {
      t = text("InsertBefore");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$a(ctx) {
  let t;
  return {
    c() {
      t = text("InsertAfter");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$o(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot$1(ctx) {
  var _a;
  let t0;
  let menuitem;
  let t1;
  let show_if = isOptionalNode(ctx[7]) && ctx[7].type !== "UNSET";
  let t2;
  let t3;
  let if_block2_anchor;
  let current;
  const default_slot_template = ctx[17].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[25], get_default_slot_context);
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[18]);
  let if_block0 = show_if && create_if_block_3$e(ctx);
  let if_block1 = ctx[7].type !== "STATEMENT_LIST" && ctx[7].type !== "CLAUSE" && create_if_block_2$e(ctx);
  let if_block2 = ((_a = ctx[7].parent) == null ? void 0 : _a.type) === "STATEMENT_LIST" && create_if_block_1$l(ctx);
  return {
    c() {
      if (default_slot)
        default_slot.c();
      t0 = space();
      create_component(menuitem.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      mount_component(menuitem, target, anchor);
      insert(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 33554436)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(default_slot_template, ctx2[25], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      }
      const menuitem_changes = {};
      if (dirty & 33554432) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
      if (dirty & 128)
        show_if = isOptionalNode(ctx2[7]) && ctx2[7].type !== "UNSET";
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$e(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[7].type !== "STATEMENT_LIST" && ctx2[7].type !== "CLAUSE") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$e(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (((_a2 = ctx2[7].parent) == null ? void 0 : _a2.type) === "STATEMENT_LIST") {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$l(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(menuitem.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(menuitem.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t1);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function create_if_block$x(ctx) {
  let sourceeditor;
  let current;
  sourceeditor = new SourceEditor({
    props: {
      newSource: ctx[4],
      rect: ctx[2]()
    }
  });
  sourceeditor.$on("cancel", ctx[24]);
  sourceeditor.$on("save", ctx[12]);
  return {
    c() {
      create_component(sourceeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sourceeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sourceeditor_changes = {};
      if (dirty & 16)
        sourceeditor_changes.newSource = ctx2[4];
      if (dirty & 4)
        sourceeditor_changes.rect = ctx2[2]();
      sourceeditor.$set(sourceeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sourceeditor, detaching);
    }
  };
}
function create_fragment$$(ctx) {
  let div1;
  let div0;
  let menubtn;
  let t;
  let if_block_anchor;
  let current;
  menubtn = new MenuBtn({
    props: {
      $$slots: { items: [create_items_slot$1] },
      $$scope: { ctx }
    }
  });
  menubtn.$on("open", ctx[15]);
  menubtn.$on("close", ctx[23]);
  let div1_levels = [{ style: "width: 1.75rem; height: 1.75rem" }, ctx[16]];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign$1(div_data_1, div1_levels[i2]);
  }
  let if_block = ctx[5] && create_if_block$x(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(menubtn.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      set_style(div0, "visibility", (ctx[6] === "ready" || ctx[6] === "record") && (ctx[1] || ctx[3]) ? "visible" : "hidden");
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(menubtn, div0, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menubtn_changes = {};
      if (dirty & 33554564) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
      if (!current || dirty & 74) {
        set_style(div0, "visibility", (ctx2[6] === "ready" || ctx2[6] === "record") && (ctx2[1] || ctx2[3]) ? "visible" : "hidden");
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        { style: "width: 1.75rem; height: 1.75rem" },
        dirty & 65536 && ctx2[16]
      ]));
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$x(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menubtn.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menubtn.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(menubtn);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function isOptionalNode(child) {
  if (child.parent.type === "STRUCT") {
    let fields = child.parent.registry.getStruct(child.parent.name).fields;
    let key;
    for (let [k, v] of child.parent.fields.entries()) {
      if (v === child)
        key = k;
    }
    if (key) {
      return fields[key].optional;
    }
  } else if (child.parent.type === "FUNCTION_CALL") {
    let funcDef = child.parent.registry.getFunc(child.parent.name);
    let index2 = child.parent.argList.indexOf(child);
    return Object.values(funcDef.args)[index2].optional;
  }
  return false;
}
function instance$Z($$self, $$props, $$invalidate) {
  const omit_props_names = ["node", "hoveringMenu", "getRect"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $statusStore;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(7, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { hoveringMenu } = $$props;
  let { getRect: getRect2 } = $$props;
  const statusStore = getContext("statusStore");
  component_subscribe($$self, statusStore, (value) => $$invalidate(6, $statusStore = value));
  const createNode = getContext("createNode");
  let menuActive = false;
  let newSource = JSON.stringify($node.toJSON());
  let sourceEditMode = false;
  async function replace2(e) {
    var _a;
    if (!$node.parent)
      return;
    let { matchingClasses, matchingTypes } = (_a = $node.parent) == null ? void 0 : _a.getChildSignature($node);
    let newNode = await createNode(e.target.parentElement.getBoundingClientRect(), node2.variables, (_name, obj) => (matchingClasses.length === 0 || matchingClasses.map((cls) => isAncestor(obj.cls, cls)).includes(true)) && (matchingTypes.length === 0 || matchingTypes.includes(obj.returnType)));
    if (newNode) {
      $node.parent.replaceChild($node, newNode);
    }
  }
  function unsetField(curChild) {
    curChild.parent.replaceChild(curChild, new Unset$1(curChild.registry, curChild.parent));
  }
  function editSource(e) {
    $$invalidate(4, newSource = JSON.stringify($node.toJSON()));
    $$invalidate(5, sourceEditMode = true);
  }
  function saveSource({ detail }) {
    var _a;
    let subtree = $node.type === "STATEMENT_LIST" ? parseList(JSON.parse(detail), $node.registry) : parseStatement(JSON.parse(detail), $node.registry);
    if ($node.parent) {
      (_a = $node.parent) == null ? void 0 : _a.replaceChild($node, subtree);
    } else {
      console.error("no parent found for the node to be replaced", $node);
    }
    $$invalidate(5, sourceEditMode = false);
  }
  async function insertBefore(e, curChild) {
    let index2 = curChild.parent.nodes.indexOf(curChild);
    if (index2 > -1) {
      let newChild = await createNode(getRect2(), curChild.variables);
      if (newChild) {
        curChild.parent.insertAt(index2, newChild);
      }
    }
  }
  async function insertAfter(e, curChild) {
    let index2 = curChild.parent.nodes.indexOf(curChild);
    if (index2 > -1) {
      let variables = curChild.variables;
      if (curChild instanceof VariableDeclaration$1) {
        variables.set(curChild.name, curChild);
      }
      let newChild = await createNode(getRect2(), variables);
      if (newChild) {
        curChild.parent.insertAt(index2 + 1, newChild);
      }
    }
  }
  function onMenuOpen() {
    $$invalidate(3, menuActive = true);
    set_store_value(statusStore, $statusStore = "ready", $statusStore);
  }
  const click_handler = (e) => replace2(e);
  const click_handler_1 = () => unsetField($node);
  const click_handler_2 = (e) => insertBefore(e, $node);
  const click_handler_3 = (e) => insertAfter(e, $node);
  const click_handler_4 = () => $node.parent.removeChild($node);
  const close_handler = () => $$invalidate(3, menuActive = false);
  const cancel_handler = () => $$invalidate(5, sourceEditMode = false);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("node" in $$new_props)
      $$subscribe_node($$invalidate(0, node2 = $$new_props.node));
    if ("hoveringMenu" in $$new_props)
      $$invalidate(1, hoveringMenu = $$new_props.hoveringMenu);
    if ("getRect" in $$new_props)
      $$invalidate(2, getRect2 = $$new_props.getRect);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  return [
    node2,
    hoveringMenu,
    getRect2,
    menuActive,
    newSource,
    sourceEditMode,
    $statusStore,
    $node,
    statusStore,
    replace2,
    unsetField,
    editSource,
    saveSource,
    insertBefore,
    insertAfter,
    onMenuOpen,
    $$restProps,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    close_handler,
    cancel_handler,
    $$scope
  ];
}
class NodeMenuItems extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Z, create_fragment$$, safe_not_equal, { node: 0, hoveringMenu: 1, getRect: 2 });
  }
}
const get_children_slot_changes = (dirty) => ({
  node: dirty & 2,
  level: dirty & 4,
  expanded: dirty & 64
});
const get_children_slot_context = (ctx) => ({
  node: ctx[1],
  level: ctx[2],
  expanded: ctx[6]
});
const get_menu_items_slot_changes = (dirty) => ({});
const get_menu_items_slot_context = (ctx) => ({ getRect: ctx[12] });
const get_summary_slot_changes = (dirty) => ({});
const get_summary_slot_context = (ctx) => ({ getRect: ctx[12] });
const get_title_slot_changes = (dirty) => ({ expanded: dirty & 64 });
const get_title_slot_context = (ctx) => ({ expanded: ctx[6] });
function create_if_block_1$k(ctx) {
  let div5;
  let div3;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div2;
  let div1;
  let div0;
  let tooltip;
  let t1;
  let t2;
  let t3;
  let div4;
  let replaystatus;
  let t4;
  let nodemenuitems;
  let div5_style_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_6$1, create_else_block_1$9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4].subtrees.length > 0)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  tooltip = new Tooltip({
    props: {
      tip: getSyntax(ctx[4]),
      $$slots: { default: [create_default_slot_1$9] },
      $$scope: { ctx }
    }
  });
  let if_block1 = !ctx[6] && create_if_block_4$7(ctx);
  let if_block2 = ctx[5].nodeStack[0] === ctx[4] && create_if_block_2$d(ctx);
  replaystatus = new ReplayStatus({
    props: {
      node: ctx[1],
      class: "bbx-flex-no-shrink bbx-pad"
    }
  });
  nodemenuitems = new NodeMenuItems({
    props: {
      node: ctx[1],
      getRect: ctx[12],
      hoveringMenu: ctx[7],
      class: "bbx-flex-no-shrink bbx-pad",
      $$slots: { default: [create_default_slot$n] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div5 = element("div");
      div3 = element("div");
      if_block0.c();
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(tooltip.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      div4 = element("div");
      create_component(replaystatus.$$.fragment);
      t4 = space();
      create_component(nodemenuitems.$$.fragment);
      attr(div1, "class", "bbx-flex bbx-align-center");
      attr(div2, "class", "bbx-node-content");
      attr(div3, "class", "bbx-flex bbx-flex-grow");
      attr(div4, "class", "bbx-flex");
      attr(div5, "class", "bbx-tree-row");
      attr(div5, "style", div5_style_value = "padding-left: calc(var(--bbx-gap) * 2 * " + (ctx[2] - 1) + "); " + (ctx[6] ? `background-color: rgba(224, 224, 224, ${Math.pow(0.8, ctx[2])});` : ""));
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div3);
      if_blocks[current_block_type_index].m(div3, null);
      append(div3, t0);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      mount_component(tooltip, div0, null);
      append(div2, t1);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      append(div5, t3);
      append(div5, div4);
      mount_component(replaystatus, div4, null);
      append(div4, t4);
      mount_component(nodemenuitems, div4, null);
      ctx[17](div5);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div5, "mouseenter", ctx[18]),
          listen(div5, "mouseleave", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div3, t0);
      }
      const tooltip_changes = {};
      if (dirty & 16)
        tooltip_changes.tip = getSyntax(ctx2[4]);
      if (dirty & 1048648) {
        tooltip_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip.$set(tooltip_changes);
      if (!ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[5].nodeStack[0] === ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 48) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$d(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const replaystatus_changes = {};
      if (dirty & 2)
        replaystatus_changes.node = ctx2[1];
      replaystatus.$set(replaystatus_changes);
      const nodemenuitems_changes = {};
      if (dirty & 2)
        nodemenuitems_changes.node = ctx2[1];
      if (dirty & 128)
        nodemenuitems_changes.hoveringMenu = ctx2[7];
      if (dirty & 1048576) {
        nodemenuitems_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nodemenuitems.$set(nodemenuitems_changes);
      if (!current || dirty & 68 && div5_style_value !== (div5_style_value = "padding-left: calc(var(--bbx-gap) * 2 * " + (ctx2[2] - 1) + "); " + (ctx2[6] ? `background-color: rgba(224, 224, 224, ${Math.pow(0.8, ctx2[2])});` : ""))) {
        attr(div5, "style", div5_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(tooltip.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(replaystatus.$$.fragment, local);
      transition_in(nodemenuitems.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(tooltip.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(replaystatus.$$.fragment, local);
      transition_out(nodemenuitems.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if_blocks[current_block_type_index].d();
      destroy_component(tooltip);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(replaystatus);
      destroy_component(nodemenuitems);
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_1$9(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "bbx-expand-angle bbx-pad");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_6$1(ctx) {
  let div;
  let angleright;
  let current;
  let mounted;
  let dispose;
  angleright = new AngleRight({
    props: {
      strokeColor: "var(--bbx-color-gray)",
      class: ctx[6] ? "bbx-rotate-90" : "",
      width: "10px",
      height: "10px"
    }
  });
  return {
    c() {
      div = element("div");
      create_component(angleright.$$.fragment);
      attr(div, "class", "bbx-expand-angle bbx-pad");
      set_style(div, "align-self", "self-start");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(angleright, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const angleright_changes = {};
      if (dirty & 64)
        angleright_changes.class = ctx2[6] ? "bbx-rotate-90" : "";
      angleright.$set(angleright_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(angleright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(angleright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(angleright);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$s(ctx) {
  let current;
  const title_slot_template = ctx[16].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[20], get_title_slot_context);
  return {
    c() {
      if (title_slot)
        title_slot.c();
    },
    m(target, anchor) {
      if (title_slot) {
        title_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 1048640)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(title_slot_template, ctx2[20], dirty, get_title_slot_changes),
            get_title_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (title_slot)
        title_slot.d(detaching);
    }
  };
}
function create_if_block_5$4(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[3]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$9(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_5$4, create_else_block$s];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "bbx-step__header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_if_block_4$7(ctx) {
  let code;
  let current;
  const summary_slot_template = ctx[16].summary;
  const summary_slot = create_slot(summary_slot_template, ctx, ctx[20], get_summary_slot_context);
  return {
    c() {
      code = element("code");
      if (summary_slot)
        summary_slot.c();
    },
    m(target, anchor) {
      insert(target, code, anchor);
      if (summary_slot) {
        summary_slot.m(code, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            summary_slot,
            summary_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(summary_slot_template, ctx2[20], dirty, get_summary_slot_changes),
            get_summary_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(summary_slot, local);
      current = true;
    },
    o(local) {
      transition_out(summary_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(code);
      if (summary_slot)
        summary_slot.d(detaching);
    }
  };
}
function create_if_block_2$d(ctx) {
  let div;
  let t0_value = ctx[5].message + "";
  let t0;
  let t1;
  let show_if = ctx[5].message.startsWith("Timeout 30000ms exceeded.") && !ctx[8];
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_3$d(ctx);
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "bbx-error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 32) && t0_value !== (t0_value = ctx2[5].message + ""))
        set_data(t0, t0_value);
      if (dirty & 288)
        show_if = ctx2[5].message.startsWith("Timeout 30000ms exceeded.") && !ctx2[8];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 288) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$d(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$d(ctx) {
  let a;
  let div1;
  let t;
  let div0;
  let wrench;
  let current;
  let mounted;
  let dispose;
  wrench = new Wrench({});
  return {
    c() {
      a = element("a");
      div1 = element("div");
      t = text("Fix Selector\n                ");
      div0 = element("div");
      create_component(wrench.$$.fragment);
      set_style(div0, "width", "10px");
      set_style(div0, "height", "10px");
      attr(div1, "class", "bbx-recommend bbx-editable active");
      attr(a, "href", "javascript:void(0)");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, div1);
      append(div1, t);
      append(div1, div0);
      mount_component(wrench, div0, null);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", ctx[14]);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(wrench.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(wrench.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      destroy_component(wrench);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$n(ctx) {
  let current;
  const menu_items_slot_template = ctx[16]["menu-items"];
  const menu_items_slot = create_slot(menu_items_slot_template, ctx, ctx[20], get_menu_items_slot_context);
  return {
    c() {
      if (menu_items_slot)
        menu_items_slot.c();
    },
    m(target, anchor) {
      if (menu_items_slot) {
        menu_items_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (menu_items_slot) {
        if (menu_items_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            menu_items_slot,
            menu_items_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(menu_items_slot_template, ctx2[20], dirty, get_menu_items_slot_changes),
            get_menu_items_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu_items_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menu_items_slot, local);
      current = false;
    },
    d(detaching) {
      if (menu_items_slot)
        menu_items_slot.d(detaching);
    }
  };
}
function create_if_block$w(ctx) {
  let current;
  const children_slot_template = ctx[16].children;
  const children_slot = create_slot(children_slot_template, ctx, ctx[20], get_children_slot_context);
  return {
    c() {
      if (children_slot)
        children_slot.c();
    },
    m(target, anchor) {
      if (children_slot) {
        children_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (children_slot) {
        if (children_slot.p && (!current || dirty & 1048646)) {
          update_slot_base(
            children_slot,
            children_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(children_slot_template, ctx2[20], dirty, get_children_slot_changes),
            get_children_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(children_slot, local);
      current = true;
    },
    o(local) {
      transition_out(children_slot, local);
      current = false;
    },
    d(detaching) {
      if (children_slot)
        children_slot.d(detaching);
    }
  };
}
function create_fragment$_(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = !(ctx[1].type === "STATEMENT_LIST" && ctx[0]) && create_if_block_1$k(ctx);
  let if_block1 = ctx[6] && create_if_block$w(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!(ctx2[1].type === "STATEMENT_LIST" && ctx2[0])) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 3) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$k(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$w(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function getSyntax(node2) {
  if (node2.type === "FUNCTION_CALL") {
    let argTypes = Object.values(node2.registry.getFunc(node2.name).args).map((arg) => arg.types);
    let argTypeStr = argTypes.map((argType) => argType.join("|")).filter((s) => s !== "json").join(", ");
    return `${node2.name}(${argTypeStr})`;
  } else if (node2.type === "STRUCT") {
    let fields = node2.registry.getStruct(node2.name).fields;
    let fieldsStr = Object.entries(fields).map(([key, obj]) => `${key}: ${obj.types.join("|")}`).join(", ");
    return `${node2.name}{${fieldsStr}}`;
  }
  return node2.type.toLowerCase();
}
function instance$Y($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(4, $node = $$value)), node2);
  let $errorStore;
  let $statusStore;
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { root = false } = $$props;
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label = void 0 } = $$props;
  getContext("createNode");
  const statusStore = getContext("statusStore");
  component_subscribe($$self, statusStore, (value) => $$invalidate(15, $statusStore = value));
  const openPickerPanel = getContext("openPickerPanel");
  const errorStore = getContext("errorStore");
  component_subscribe($$self, errorStore, (value) => $$invalidate(5, $errorStore = value));
  let expanded = root;
  let hoveringMenu = false;
  let fixedSelector = false;
  let rowComponent;
  function getRect2() {
    return rowComponent.getBoundingClientRect();
  }
  function toggleExpansion() {
    if ($node.subtrees.length === 0)
      $$invalidate(6, expanded = false);
    else
      $$invalidate(6, expanded = !expanded);
  }
  async function pickElement() {
    if (!openPickerPanel)
      return;
    let selector = getSelectorNode($node);
    let frame = getFrameNode($node);
    if (selector) {
      let res = await openPickerPanel(selector, frame);
      if (!res)
        return;
      if (res.hasOwnProperty("selector"))
        setSelector($node, res.selector);
      if (res.hasOwnProperty("frame"))
        setFrame($node, res.frame);
      $$invalidate(8, fixedSelector = true);
    }
  }
  function div5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rowComponent = $$value;
      $$invalidate(9, rowComponent);
    });
  }
  const mouseenter_handler = () => $$invalidate(7, hoveringMenu = true);
  const mouseleave_handler = () => $$invalidate(7, hoveringMenu = false);
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(0, root = $$props2.root);
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(1, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(3, label = $$props2.label);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32768) {
      if ($statusStore !== "ready")
        $$invalidate(8, fixedSelector = false);
    }
    if ($$self.$$.dirty & 48) {
      if ($errorStore.nodeStack.indexOf($node) > 0)
        $$invalidate(6, expanded = true);
    }
  };
  return [
    root,
    node2,
    level,
    label,
    $node,
    $errorStore,
    expanded,
    hoveringMenu,
    fixedSelector,
    rowComponent,
    statusStore,
    errorStore,
    getRect2,
    toggleExpansion,
    pickElement,
    $statusStore,
    slots,
    div5_binding,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
class Node$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Y, create_fragment$_, safe_not_equal, { root: 0, node: 1, level: 2, label: 3 });
  }
}
function get_each_context$l(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  child_ctx[11] = i2;
  return child_ctx;
}
function create_title_slot$9(ctx) {
  let t_value = ctx[3].title + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].title + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_summary_slot$a(ctx) {
  let t_value = ctx[3].subtrees.filter(ctx[6]).map(ctx[7]).filter(ctx[8]).join(", ") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 24 && t_value !== (t_value = ctx2[3].subtrees.filter(ctx2[6]).map(ctx2[7]).filter(ctx2[8]).join(", ") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$l(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ComponentByType[ctx[9].type];
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[9],
        level: ctx2[1] + 1,
        label: ctx2[5][ctx2[11]]
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & 8)
        switch_instance_changes.node = ctx[9];
      if (dirty & 2)
        switch_instance_changes.level = ctx[1] + 1;
      if (dirty & 40)
        switch_instance_changes.label = ctx[5][ctx[11]];
      if (dirty & 8 && switch_value !== (switch_value = ComponentByType[ctx[9].type])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_children_slot$6(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[3].argList;
  const get_key = (ctx2) => ctx2[9];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$l(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$l(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 42) {
        each_value = ctx2[3].argList;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$l, each_1_anchor, get_each_context$l);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$Z(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      label: ctx[2],
      $$slots: {
        children: [create_children_slot$6],
        summary: [create_summary_slot$a],
        title: [create_title_slot$9]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 4)
        node_1_changes.label = ctx2[2];
      if (dirty & 4154) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$X($$self, $$props, $$invalidate) {
  let argNames;
  let optionals;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(3, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label = void 0 } = $$props;
  const func2 = (_2, i2) => !optionals[i2];
  const func_1 = (subtree) => getSummary(subtree);
  const func_2 = (v) => typeof v === "number" || Boolean(v);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $$invalidate(5, argNames = Object.keys($node.registry.getFunc($node.name).args));
    }
    if ($$self.$$.dirty & 8) {
      $$invalidate(4, optionals = Object.values($node.registry.getFunc($node.name).args).map((arg) => {
        var _a;
        return (_a = arg.optional) != null ? _a : false;
      }));
    }
  };
  return [node2, level, label, $node, optionals, argNames, func2, func_1, func_2];
}
class FunctionCall extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$X, create_fragment$Z, safe_not_equal, { node: 0, level: 1, label: 2 });
  }
}
function keypressEnter(node2) {
  const handleKey = (event) => {
    if (event.key == "Enter") {
      node2.dispatchEvent(new CustomEvent("enter"));
    }
  };
  document.body.addEventListener("keydown", handleKey, true);
  return {
    destroy() {
      document.body.removeEventListener("keydown", handleKey, true);
    }
  };
}
function create_fragment$Y(ctx) {
  let svg;
  let g1;
  let g0;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      g1 = svg_element("g");
      g0 = svg_element("g");
      polyline = svg_element("polyline");
      attr(polyline, "fill", "none");
      attr(polyline, "points", "3.7 14.3 9.6 19 20.3 5");
      attr(polyline, "stroke-linecap", "round");
      attr(polyline, "stroke-linejoin", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "stroke-width", ctx[1]);
      attr(svg, "stroke", ctx[0]);
      set_style(svg, "display", "block");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g1);
      append(g1, g0);
      append(g0, polyline);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(svg, "stroke-width", ctx2[1]);
      }
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$W($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 4 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class Tick extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$W, create_fragment$Y, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function get_each_context$k(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_if_block_4$6(ctx) {
  let select;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$k(get_each_context$k(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      set_style(select, "width", "100%");
      if (ctx[2] === void 0)
        add_render_callback(() => ctx[10].call(select));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[2], true);
      if (!mounted) {
        dispose = listen(select, "change", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$k(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$k(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 6) {
        select_option(select, ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$c(ctx) {
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      set_style(textarea, "width", "100%");
      set_style(textarea, "height", "20px");
      textarea.value = ctx[2];
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (!mounted) {
        dispose = listen(textarea, "change", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 6) {
        textarea.value = ctx2[2];
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$c(ctx) {
  let select;
  let option0;
  let option1;
  let select_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      select = element("select");
      option0 = element("option");
      option0.textContent = "true";
      option1 = element("option");
      option1.textContent = "false";
      option0.__value = "true";
      option0.value = option0.__value;
      option1.__value = "false";
      option1.value = option1.__value;
      set_style(select, "width", "100%");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option0);
      append(select, option1);
      select_option(select, ctx[2] ? "true" : "false");
      if (!mounted) {
        dispose = listen(select, "change", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 6 && select_value_value !== (select_value_value = ctx2[2] ? "true" : "false")) {
        select_option(select, ctx2[2] ? "true" : "false");
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$j(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "number");
      set_style(input, "width", "100%");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[2]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 6 && to_number(input.value) !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$v(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      set_style(input, "width", "100%");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[2]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 6 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$k(ctx) {
  let option;
  let t_value = ctx[14] + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[14];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[14] + ""))
        set_data(t, t_value);
      if (dirty & 2 && option_value_value !== (option_value_value = ctx2[14])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot_1$8(ctx) {
  let tick_1;
  let current;
  tick_1 = new Tick({ props: { strokeColor: "blue" } });
  return {
    c() {
      create_component(tick_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tick_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tick_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tick_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tick_1, detaching);
    }
  };
}
function create_default_slot$m(ctx) {
  let cross;
  let current;
  cross = new Cross({ props: { strokeColor: "red" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_fragment$X(ctx) {
  let div2;
  let t0;
  let div0;
  let iconbtn0;
  let t1;
  let div1;
  let iconbtn1;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === "string")
      return create_if_block$v;
    if (ctx2[0] === "number")
      return create_if_block_1$j;
    if (ctx2[0] === "boolean")
      return create_if_block_2$c;
    if (ctx2[0] === "json" || ctx2[0] === "array")
      return create_if_block_3$c;
    if (ctx2[0] === "select")
      return create_if_block_4$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  iconbtn0 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  iconbtn0.$on("click", ctx[4]);
  iconbtn1 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot$m] },
      $$scope: { ctx }
    }
  });
  iconbtn1.$on("click", ctx[11]);
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      create_component(iconbtn0.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(iconbtn1.$$.fragment);
      attr(div0, "class", "bbx-icon-container");
      attr(div1, "class", "bbx-icon-container");
      attr(div2, "class", "bbx-inline-editor");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t0);
      append(div2, div0);
      mount_component(iconbtn0, div0, null);
      append(div2, t1);
      append(div2, div1);
      mount_component(iconbtn1, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(keypressEscape.call(null, div2)),
          listen(div2, "escape", ctx[12]),
          action_destroyer(clickOutside.call(null, div2)),
          listen(div2, "outclick", ctx[13]),
          action_destroyer(keypressEnter.call(null, div2)),
          listen(div2, "enter", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, t0);
        }
      }
      const iconbtn0_changes = {};
      if (dirty & 131072) {
        iconbtn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn0.$set(iconbtn0_changes);
      const iconbtn1_changes = {};
      if (dirty & 131072) {
        iconbtn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn1.$set(iconbtn1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn0.$$.fragment, local);
      transition_in(iconbtn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn0.$$.fragment, local);
      transition_out(iconbtn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block) {
        if_block.d();
      }
      destroy_component(iconbtn0);
      destroy_component(iconbtn1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$V($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { value } = $$props;
  let { type } = $$props;
  let { options = [] } = $$props;
  let newValue = type === "json" || type === "array" ? JSON.stringify(value) : value;
  function saveValue() {
    if (type === "number") {
      $$invalidate(2, newValue = Number(newValue));
    } else if (type === "boolean") {
      $$invalidate(2, newValue = Boolean(newValue));
    } else if (type === "json" || type === "array") {
      $$invalidate(2, newValue = JSON.parse(newValue));
    }
    dispatch("save", newValue);
  }
  function input_input_handler() {
    newValue = this.value;
    $$invalidate(2, newValue);
    $$invalidate(1, options);
  }
  function input_input_handler_1() {
    newValue = to_number(this.value);
    $$invalidate(2, newValue);
    $$invalidate(1, options);
  }
  const change_handler = (e) => $$invalidate(2, newValue = e.target.value === "true");
  const change_handler_1 = (e) => $$invalidate(2, newValue = e.target.value);
  function select_change_handler() {
    newValue = select_value(this);
    $$invalidate(2, newValue);
    $$invalidate(1, options);
  }
  const click_handler = () => dispatch("cancel");
  const escape_handler = () => dispatch("cancel");
  const outclick_handler = () => dispatch("cancel");
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(5, value = $$props2.value);
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
  };
  return [
    type,
    options,
    newValue,
    dispatch,
    saveValue,
    value,
    input_input_handler,
    input_input_handler_1,
    change_handler,
    change_handler_1,
    select_change_handler,
    click_handler,
    escape_handler,
    outclick_handler
  ];
}
class EditLiteral extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$V, create_fragment$X, safe_not_equal, { value: 5, type: 0, options: 1 });
  }
}
function get_each_context$j(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2][0];
  child_ctx[12] = list[i2][1];
  return child_ctx;
}
function create_title_slot$8(ctx) {
  let t_value = ctx[5].title + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5].title + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block_1$8(ctx) {
  let t_value = getSummary(ctx[5]) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = getSummary(ctx2[5]) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$u(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$i, create_else_block$r];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$r(ctx) {
  let div;
  let t_value = getSummary(ctx[5]) + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-editable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = [
          listen(div, "mouseenter", ctx[9]),
          listen(div, "mouseleave", ctx[10]),
          listen(div, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = getSummary(ctx2[5]) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$i(ctx) {
  let editliteral;
  let current;
  editliteral = new EditLiteral({
    props: {
      value: ctx[5].get("value").value,
      type: "string"
    }
  });
  editliteral.$on("save", ctx[7]);
  editliteral.$on("cancel", ctx[8]);
  return {
    c() {
      create_component(editliteral.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editliteral, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editliteral_changes = {};
      if (dirty & 32)
        editliteral_changes.value = ctx2[5].get("value").value;
      editliteral.$set(editliteral_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editliteral.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editliteral.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editliteral, detaching);
    }
  };
}
function create_summary_slot$9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$u, create_else_block_1$8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].name === "selector")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_each_block$j(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ComponentByType[ctx[12].type];
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[12],
        level: ctx2[1] + 1,
        label: ctx2[2]
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & 32)
        switch_instance_changes.node = ctx[12];
      if (dirty & 2)
        switch_instance_changes.level = ctx[1] + 1;
      if (dirty & 32)
        switch_instance_changes.label = ctx[2];
      if (dirty & 32 && switch_value !== (switch_value = ComponentByType[ctx[12].type])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_children_slot$5(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = [...ctx[5].fields.entries()];
  const get_key = (ctx2) => ctx2[12];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$j(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$j(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 34) {
        each_value = [...ctx2[5].fields.entries()];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$j, each_1_anchor, get_each_context$j);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$W(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      label: ctx[2],
      $$slots: {
        children: [create_children_slot$5],
        summary: [create_summary_slot$9],
        title: [create_title_slot$8]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 4)
        node_1_changes.label = ctx2[2];
      if (dirty & 32827) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$U($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(5, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  const openPickerPanel = getContext("openPickerPanel");
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label } = $$props;
  let editMode = false;
  let hovering = false;
  async function pickElement() {
    if (openPickerPanel) {
      let selector = $node.toJSON()[1];
      let frame;
      if ($node.parent)
        frame = getFrameNode($node);
      let res = await openPickerPanel(selector, frame);
      if (!res)
        return;
      if ($node.parent) {
        if (res.hasOwnProperty("frame"))
          setFrame($node.parent, res.frame);
        if (res.hasOwnProperty("selector")) {
          $node.parent.replaceChild($node, parseExpression(["selector", res.selector], $node.registry));
        }
      }
    } else {
      $$invalidate(3, editMode = true);
    }
  }
  function saveSelectorValue(e) {
    $$invalidate(3, editMode = false);
    let selectorValue = $node.get("value");
    selectorValue.value = e.detail;
  }
  const cancel_handler = () => $$invalidate(3, editMode = false);
  const mouseenter_handler = () => $$invalidate(4, hovering = true);
  const mouseleave_handler = () => $$invalidate(4, hovering = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
  };
  return [
    node2,
    level,
    label,
    editMode,
    hovering,
    $node,
    pickElement,
    saveSelectorValue,
    cancel_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
class StructNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$U, create_fragment$W, safe_not_equal, { node: 0, level: 1, label: 2 });
  }
}
function create_else_block$q(ctx) {
  let div;
  let t_value = getSummary(ctx[4]) + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-editable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = listen(div, "click", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = getSummary(ctx2[4]) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$t(ctx) {
  let editliteral;
  let current;
  editliteral = new EditLiteral({
    props: {
      value: ctx[4].value,
      type: ctx[4].returnType
    }
  });
  editliteral.$on("save", ctx[5]);
  editliteral.$on("cancel", ctx[6]);
  return {
    c() {
      create_component(editliteral.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editliteral, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editliteral_changes = {};
      if (dirty & 16)
        editliteral_changes.value = ctx2[4].value;
      if (dirty & 16)
        editliteral_changes.type = ctx2[4].returnType;
      editliteral.$set(editliteral_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editliteral.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editliteral.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editliteral, detaching);
    }
  };
}
function create_summary_slot$8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$t, create_else_block$q];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$V(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      label: ctx[2],
      $$slots: { summary: [create_summary_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 4)
        node_1_changes.label = ctx2[2];
      if (dirty & 280) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$T($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(4, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label } = $$props;
  let editMode = false;
  function saveLiteral(e) {
    $$invalidate(3, editMode = false);
    $$invalidate(0, node2.value = e.detail, node2);
  }
  const cancel_handler = () => $$invalidate(3, editMode = false);
  const click_handler = () => $$invalidate(3, editMode = true);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
  };
  return [
    node2,
    level,
    label,
    editMode,
    $node,
    saveLiteral,
    cancel_handler,
    click_handler
  ];
}
class Literal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$T, create_fragment$V, safe_not_equal, { node: 0, level: 1, label: 2 });
  }
}
function get_each_context$i(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  return child_ctx;
}
function create_else_block$p(ctx) {
  let div;
  let t_value = ctx[6].name + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-editable bbx-pad-x");
      set_style(div, "color", "var(--bbx-color-primary)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = listen(div, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6].name + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$h(ctx) {
  let editliteral;
  let current;
  editliteral = new EditLiteral({
    props: {
      value: ctx[6].name,
      type: "string"
    }
  });
  editliteral.$on("save", ctx[7]);
  editliteral.$on("cancel", ctx[11]);
  return {
    c() {
      create_component(editliteral.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editliteral, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editliteral_changes = {};
      if (dirty & 64)
        editliteral_changes.value = ctx2[6].name;
      editliteral.$set(editliteral_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editliteral.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editliteral.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editliteral, detaching);
    }
  };
}
function create_title_slot$7(ctx) {
  let div1;
  let div0;
  let t1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_1$h, create_else_block$p];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "Variable";
      t1 = space();
      if_block.c();
      attr(div1, "class", "bbx-flex bbx-align-center bbx-gap");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t1);
      if_blocks[current_block_type_index].m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_summary_slot$7(ctx) {
  let t_value = `$${ctx[6].name} = ${getSummary(ctx[6].value)}`;
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = `$${ctx2[6].name} = ${getSummary(ctx2[6].value)}`))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let t;
  return {
    c() {
      t = text("Change Type");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$3(ctx) {
  let menuitem;
  let current;
  function click_handler() {
    return ctx[10](ctx[18]);
  }
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 524288) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_children_slot$4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ComponentByType[ctx[6].value.type];
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[6].value,
        level: ctx2[1] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 64)
        switch_instance_changes.node = ctx2[6].value;
      if (dirty & 2)
        switch_instance_changes.level = ctx2[1] + 1;
      if (dirty & 64 && switch_value !== (switch_value = ComponentByType[ctx2[6].value.type])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block$s(ctx) {
  let savecancelmodal;
  let current;
  savecancelmodal = new SaveCancelModal({
    props: {
      rect: ctx[5],
      title: "Change Type",
      $$slots: { default: [create_default_slot$l] },
      $$scope: { ctx }
    }
  });
  savecancelmodal.$on("save", ctx[9]);
  savecancelmodal.$on("cancel", ctx[14]);
  return {
    c() {
      create_component(savecancelmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savecancelmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savecancelmodal_changes = {};
      if (dirty & 32)
        savecancelmodal_changes.rect = ctx2[5];
      if (dirty & 524368) {
        savecancelmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savecancelmodal.$set(savecancelmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savecancelmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savecancelmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savecancelmodal, detaching);
    }
  };
}
function create_each_block$i(ctx) {
  let option;
  let t_value = ctx[15] + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[15];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[15] + ""))
        set_data(t, t_value);
      if (dirty & 64 && option_value_value !== (option_value_value = ctx2[15])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot$l(ctx) {
  let select;
  let mounted;
  let dispose;
  let each_value = Object.keys(ctx[6].registry.types);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$i(get_each_context$i(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[4]);
      if (!mounted) {
        dispose = listen(select, "change", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64) {
        each_value = Object.keys(ctx2[6].registry.types);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$i(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$i(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 80) {
        select_option(select, ctx2[4]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$U(ctx) {
  let node_1;
  let t;
  let if_block_anchor;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      $$slots: {
        children: [create_children_slot$4],
        "menu-items": [
          create_menu_items_slot$3,
          ({ getRect: getRect2 }) => ({ 18: getRect2 }),
          ({ getRect: getRect2 }) => getRect2 ? 262144 : 0
        ],
        summary: [create_summary_slot$7],
        title: [create_title_slot$7]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[3] && create_if_block$s(ctx);
  return {
    c() {
      create_component(node_1.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 786502) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$s(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$S($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(6, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let renameMode = false;
  let typeChangeMode = false;
  let selectedType = $node.dataType;
  let rect;
  function renameVariable({ detail }) {
    $node.rename(detail);
    $$invalidate(2, renameMode = false);
  }
  function changeType(getRect2) {
    $$invalidate(5, rect = getRect2());
    $$invalidate(3, typeChangeMode = true);
  }
  function saveType() {
    $node.changeType(selectedType);
    $$invalidate(3, typeChangeMode = false);
  }
  const click_handler = (getRect2) => changeType(getRect2);
  const cancel_handler = () => $$invalidate(2, renameMode = false);
  const click_handler_1 = () => $$invalidate(2, renameMode = true);
  const change_handler = (e) => $$invalidate(4, selectedType = e.target.value);
  const cancel_handler_1 = () => $$invalidate(3, typeChangeMode = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
  };
  return [
    node2,
    level,
    renameMode,
    typeChangeMode,
    selectedType,
    rect,
    $node,
    renameVariable,
    changeType,
    saveType,
    click_handler,
    cancel_handler,
    click_handler_1,
    change_handler,
    cancel_handler_1
  ];
}
class VariableDeclaration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$S, create_fragment$U, safe_not_equal, { node: 0, level: 1 });
  }
}
function create_title_slot$6(ctx) {
  let t_value = "$" + ctx[3]._ref.name;
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = "$" + ctx2[3]._ref.name))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$T(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      label: ctx[2],
      $$slots: { title: [create_title_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 4)
        node_1_changes.label = ctx2[2];
      if (dirty & 24) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$R($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(3, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
  };
  return [node2, level, label, $node];
}
class VariableReference extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$R, create_fragment$T, safe_not_equal, { node: 0, level: 1, label: 2 });
  }
}
function get_each_context$h(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_title_slot$5(ctx) {
  let t;
  return {
    c() {
      t = text("Conditional");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_summary_slot$6(ctx) {
  let t_value = getSummary(ctx[2]) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = getSummary(ctx2[2]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$k(ctx) {
  let t;
  return {
    c() {
      t = text("Add Clause");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$2(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$k] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[3]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 256) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_each_block$h(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ComponentByType[ctx[4].type];
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[4],
        level: ctx2[1] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & 4)
        switch_instance_changes.node = ctx[4];
      if (dirty & 2)
        switch_instance_changes.level = ctx[1] + 1;
      if (dirty & 4 && switch_value !== (switch_value = ComponentByType[ctx[4].type])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_children_slot$3(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[2].clauses;
  const get_key = (ctx2) => ctx2[4];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$h(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$h(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 6) {
        each_value = ctx2[2].clauses;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$h, each_1_anchor, get_each_context$h);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$S(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      $$slots: {
        children: [create_children_slot$3],
        "menu-items": [
          create_menu_items_slot$2,
          ({ getRect: getRect2 }) => ({ 7: getRect2 }),
          ({ getRect: getRect2 }) => getRect2 ? 128 : 0
        ],
        summary: [create_summary_slot$6],
        title: [create_title_slot$5]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 262) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$Q($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(2, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  const click_handler = () => $node.appendClause(new Clause());
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
  };
  return [node2, level, $node, click_handler];
}
class Conditional extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Q, create_fragment$S, safe_not_equal, { node: 0, level: 1 });
  }
}
function create_title_slot$4(ctx) {
  let t0;
  let t1_value = ctx[2].parent.clauses.indexOf(ctx[2]) + "";
  let t1;
  return {
    c() {
      t0 = text("Clause ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t1_value !== (t1_value = ctx2[2].parent.clauses.indexOf(ctx2[2]) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_summary_slot$5(ctx) {
  let t_value = getSummary(ctx[2].condition) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = getSummary(ctx2[2].condition) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$6(ctx) {
  let t;
  return {
    c() {
      t = text("InsertBefore");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$j(ctx) {
  let t;
  return {
    c() {
      t = text("InsertAfter");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$1(ctx) {
  let menuitem0;
  let t;
  let menuitem1;
  let current;
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", ctx[5]);
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[6]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t = space();
      create_component(menuitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t, anchor);
      mount_component(menuitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & 256) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 256) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t);
      destroy_component(menuitem1, detaching);
    }
  };
}
function create_children_slot$2(ctx) {
  let switch_instance0;
  let t;
  let switch_instance1;
  let switch_instance1_anchor;
  let current;
  var switch_value = ComponentByType[ctx[2].condition.type];
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[2].condition,
        level: ctx2[1] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
  }
  var switch_value_1 = ComponentByType[ctx[2].body.type];
  function switch_props_1(ctx2) {
    return {
      props: {
        node: ctx2[2].body,
        level: ctx2[1] + 1
      }
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
  }
  return {
    c() {
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t = space();
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      switch_instance1_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance0)
        mount_component(switch_instance0, target, anchor);
      insert(target, t, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, target, anchor);
      insert(target, switch_instance1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance0_changes = {};
      if (dirty & 4)
        switch_instance0_changes.node = ctx2[2].condition;
      if (dirty & 2)
        switch_instance0_changes.level = ctx2[1] + 1;
      if (dirty & 4 && switch_value !== (switch_value = ComponentByType[ctx2[2].condition.type])) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t.parentNode, t);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        switch_instance0.$set(switch_instance0_changes);
      }
      const switch_instance1_changes = {};
      if (dirty & 4)
        switch_instance1_changes.node = ctx2[2].body;
      if (dirty & 2)
        switch_instance1_changes.level = ctx2[1] + 1;
      if (dirty & 4 && switch_value_1 !== (switch_value_1 = ComponentByType[ctx2[2].body.type])) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, switch_instance1_anchor.parentNode, switch_instance1_anchor);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        switch_instance1.$set(switch_instance1_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(switch_instance1_anchor);
      if (switch_instance1)
        destroy_component(switch_instance1, detaching);
    }
  };
}
function create_fragment$R(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      $$slots: {
        children: [create_children_slot$2],
        "menu-items": [
          create_menu_items_slot$1,
          ({ getRect: getRect2 }) => ({ 7: getRect2 }),
          ({ getRect: getRect2 }) => getRect2 ? 128 : 0
        ],
        summary: [create_summary_slot$5],
        title: [create_title_slot$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 262) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$P($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(2, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  async function insertClauseBefore(e) {
    var _a, _b;
    let index2 = (_a = $node.parent) == null ? void 0 : _a.clauses.indexOf(node2);
    if (index2 > -1) {
      (_b = $node.parent) == null ? void 0 : _b.insertAt(index2, new Clause());
    }
  }
  async function insertClauseAfter(e) {
    var _a, _b;
    let index2 = (_a = $node.parent) == null ? void 0 : _a.clauses.indexOf(node2);
    if (index2 > -1) {
      (_b = $node.parent) == null ? void 0 : _b.insertAt(index2 + 1, new Clause());
    }
  }
  const click_handler = (e) => insertClauseBefore();
  const click_handler_1 = (e) => insertClauseAfter();
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
  };
  return [
    node2,
    level,
    $node,
    insertClauseBefore,
    insertClauseAfter,
    click_handler,
    click_handler_1
  ];
}
class Clause_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$P, create_fragment$R, safe_not_equal, { node: 0, level: 1 });
  }
}
function get_each_context$g(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_title_slot$3(ctx) {
  let t_value = ctx[3].parent && ctx[3].parent.type === "CLAUSE" ? "BODY" : "StatementList";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].parent && ctx2[3].parent.type === "CLAUSE" ? "BODY" : "StatementList"))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_summary_slot$4(ctx) {
  let t_value = getSummary(ctx[3]) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = getSummary(ctx2[3]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$i(ctx) {
  let t;
  return {
    c() {
      t = text("Add Statement");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot(ctx) {
  let menuitem;
  let current;
  function click_handler(...args) {
    return ctx[5](ctx[11], ...args);
  }
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 4096) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_each_block$g(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ComponentByType[ctx[8].type];
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[8],
        level: ctx2[2] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & 8)
        switch_instance_changes.node = ctx[8];
      if (dirty & 4)
        switch_instance_changes.level = ctx[2] + 1;
      if (dirty & 8 && switch_value !== (switch_value = ComponentByType[ctx[8].type])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_children_slot$1(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[3].subtrees;
  const get_key = (ctx2) => ctx2[8];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$g(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$g(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 12) {
        each_value = ctx2[3].subtrees;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$g, each_1_anchor, get_each_context$g);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$Q(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[1],
      level: ctx[2],
      root: ctx[0],
      $$slots: {
        children: [create_children_slot$1],
        "menu-items": [
          create_menu_items_slot,
          ({ getRect: getRect2 }) => ({ 11: getRect2 }),
          ({ getRect: getRect2 }) => getRect2 ? 2048 : 0
        ],
        summary: [create_summary_slot$4],
        title: [create_title_slot$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 2)
        node_1_changes.node = ctx2[1];
      if (dirty & 4)
        node_1_changes.level = ctx2[2];
      if (dirty & 1)
        node_1_changes.root = ctx2[0];
      if (dirty & 6156) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$O($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(3, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { root = false } = $$props;
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  const createNode = getContext("createNode");
  async function addStatement(e, getRect2) {
    let curNode = $node;
    if (curNode.subtrees.length > 0) {
      curNode = curNode.subtrees[curNode.subtrees.length - 1];
    }
    let variables = curNode.variables;
    if (curNode instanceof VariableDeclaration$1) {
      variables.set(curNode.name, curNode);
    }
    let child = await createNode(getRect2(), variables);
    if (child) {
      $node.append(child);
    }
  }
  const click_handler = (getRect2, e) => addStatement(e, getRect2);
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(0, root = $$props2.root);
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(1, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
  };
  return [root, node2, level, $node, addStatement, click_handler];
}
class StatementList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$O, create_fragment$Q, safe_not_equal, { root: 0, node: 1, level: 2 });
  }
}
function create_title_slot$2(ctx) {
  let t;
  return {
    c() {
      t = text("Assign");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$o(ctx) {
  let t_value = `${getSummary(ctx[2].reference)} = ${getSummary(ctx[2].value)}`;
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = `${getSummary(ctx2[2].reference)} = ${getSummary(ctx2[2].value)}`))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$r(ctx) {
  let t_value = getSummary(ctx[2].reference) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = getSummary(ctx2[2].reference) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_summary_slot$3(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].reference.type === "ERROR")
      return create_if_block$r;
    return create_else_block$o;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_children_slot(ctx) {
  let switch_instance0;
  let t;
  let switch_instance1;
  let switch_instance1_anchor;
  let current;
  var switch_value = ComponentByType[ctx[2].reference.type];
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[2].reference,
        level: ctx2[1] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
  }
  var switch_value_1 = ComponentByType[ctx[2].value.type];
  function switch_props_1(ctx2) {
    return {
      props: {
        node: ctx2[2].value,
        level: ctx2[1] + 1
      }
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
  }
  return {
    c() {
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t = space();
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      switch_instance1_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance0)
        mount_component(switch_instance0, target, anchor);
      insert(target, t, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, target, anchor);
      insert(target, switch_instance1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance0_changes = {};
      if (dirty & 4)
        switch_instance0_changes.node = ctx2[2].reference;
      if (dirty & 2)
        switch_instance0_changes.level = ctx2[1] + 1;
      if (dirty & 4 && switch_value !== (switch_value = ComponentByType[ctx2[2].reference.type])) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t.parentNode, t);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        switch_instance0.$set(switch_instance0_changes);
      }
      const switch_instance1_changes = {};
      if (dirty & 4)
        switch_instance1_changes.node = ctx2[2].value;
      if (dirty & 2)
        switch_instance1_changes.level = ctx2[1] + 1;
      if (dirty & 4 && switch_value_1 !== (switch_value_1 = ComponentByType[ctx2[2].value.type])) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, switch_instance1_anchor.parentNode, switch_instance1_anchor);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        switch_instance1.$set(switch_instance1_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(switch_instance1_anchor);
      if (switch_instance1)
        destroy_component(switch_instance1, detaching);
    }
  };
}
function create_fragment$P(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      $$slots: {
        children: [create_children_slot],
        summary: [create_summary_slot$3],
        title: [create_title_slot$2]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 14) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$N($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(2, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
  };
  return [node2, level, $node];
}
class Assignment extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$N, create_fragment$P, safe_not_equal, { node: 0, level: 1 });
  }
}
function create_title_slot$1(ctx) {
  let t_value = ctx[2].code + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[2].code + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_summary_slot$2(ctx) {
  let t_value = ctx[2].description + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[2].description + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$O(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      $$slots: {
        summary: [create_summary_slot$2],
        title: [create_title_slot$1]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 12) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$M($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(2, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
  };
  return [node2, level, $node];
}
class ErrorNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$M, create_fragment$O, safe_not_equal, { node: 0, level: 1 });
  }
}
function create_else_block$n(ctx) {
  let div;
  let t_value = getSummary(ctx[4]) + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-editable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = listen(div, "click", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = getSummary(ctx2[4]) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$q(ctx) {
  let editliteral;
  let current;
  editliteral = new EditLiteral({
    props: {
      value: ctx[4].value,
      type: "select",
      options: ctx[4].registry.getEnum(ctx[4].name).values
    }
  });
  editliteral.$on("save", ctx[5]);
  editliteral.$on("cancel", ctx[6]);
  return {
    c() {
      create_component(editliteral.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editliteral, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editliteral_changes = {};
      if (dirty & 16)
        editliteral_changes.value = ctx2[4].value;
      if (dirty & 16)
        editliteral_changes.options = ctx2[4].registry.getEnum(ctx2[4].name).values;
      editliteral.$set(editliteral_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editliteral.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editliteral.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editliteral, detaching);
    }
  };
}
function create_summary_slot$1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$q, create_else_block$n];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$N(ctx) {
  let node_1;
  let current;
  node_1 = new Node$1({
    props: {
      node: ctx[0],
      level: ctx[1],
      label: ctx[2],
      $$slots: { summary: [create_summary_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 4)
        node_1_changes.label = ctx2[2];
      if (dirty & 280) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function instance$L($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(4, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label } = $$props;
  let editMode = false;
  function saveLiteral(e) {
    $$invalidate(3, editMode = false);
    $$invalidate(0, node2.value = e.detail, node2);
  }
  const cancel_handler = () => $$invalidate(3, editMode = false);
  const click_handler = () => $$invalidate(3, editMode = true);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
  };
  return [
    node2,
    level,
    label,
    editMode,
    $node,
    saveLiteral,
    cancel_handler,
    click_handler
  ];
}
class EnumNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$L, create_fragment$N, safe_not_equal, { node: 0, level: 1, label: 2 });
  }
}
function create_title_slot(ctx) {
  let t;
  return {
    c() {
      t = text("Optional: Not set");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_summary_slot(ctx) {
  let div2;
  let div0;
  let t1;
  let div1;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[5](ctx[10]);
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "(Optional)";
      t1 = space();
      div1 = element("div");
      div1.textContent = "Set";
      attr(div1, "class", "bbx-editable active");
      attr(div2, "class", "bbx-flex");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      if (!mounted) {
        dispose = listen(div1, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$M(ctx) {
  let node_1;
  let current;
  let node_1_props = {
    node: ctx[0],
    level: ctx[1],
    label: ctx[2],
    $$slots: {
      summary: [
        create_summary_slot,
        ({ getRect: getRect2 }) => ({ 10: getRect2 }),
        ({ getRect: getRect2 }) => getRect2 ? 1024 : 0
      ],
      title: [create_title_slot]
    },
    $$scope: { ctx }
  };
  node_1 = new Node$1({ props: node_1_props });
  ctx[6](node_1);
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 1)
        node_1_changes.node = ctx2[0];
      if (dirty & 2)
        node_1_changes.level = ctx2[1];
      if (dirty & 4)
        node_1_changes.label = ctx2[2];
      if (dirty & 3072) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[6](null);
      destroy_component(node_1, detaching);
    }
  };
}
function instance$K($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(8, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  const createNode = getContext("createNode");
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label } = $$props;
  let component;
  async function setExpression(getRect2) {
    var _a;
    let { matchingClasses, matchingTypes } = (_a = $node.parent) == null ? void 0 : _a.getChildSignature($node);
    let newChild = await createNode(getRect2(), $node.variables, (_name, obj) => (matchingClasses.length === 0 || matchingClasses.map((cls) => isAncestor(obj.cls, cls)).includes(true)) && (matchingTypes.length === 0 || matchingTypes.includes(obj.returnType)));
    if (newChild) {
      $node.parent.replaceChild($node, newChild);
    }
  }
  const click_handler = (getRect2) => setExpression(getRect2);
  function node_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(3, component);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
  };
  return [node2, level, label, component, setExpression, click_handler, node_1_binding];
}
class Unset extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$K, create_fragment$M, safe_not_equal, { node: 0, level: 1, label: 2 });
  }
}
const ComponentByType = {
  "FUNCTION_CALL": FunctionCall,
  "STRUCT": StructNode,
  "LITERAL": Literal,
  "VARIABLE_DECLARATION": VariableDeclaration,
  "VARIABLE_REFERENCE": VariableReference,
  "COND": Conditional,
  "CLAUSE": Clause_1,
  "STATEMENT_LIST": StatementList,
  "ASSIGNMENT": Assignment,
  "ERROR": ErrorNode,
  "ENUM": EnumNode,
  "UNSET": Unset
};
function wait$2(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function getDefault(type) {
  switch (type) {
    case "number":
      return 0;
    case "string":
      return "";
    case "boolean":
      return false;
    case "selector":
      return {
        value: "",
        type: "css",
        meta: {}
      };
    case "position":
      return { x: 0, y: 0 };
    case "keycode":
      return "Enter";
    default:
      return "";
  }
}
function getSummary(node2) {
  if (node2.type === "STRUCT" && node2.name === "selector") {
    return getSummary(node2.subtrees[0]);
  }
  if (node2.type === "STRUCT" && node2.name === "position") {
    return `(${getSummary(node2.subtrees[0])}, ${getSummary(node2.subtrees[1])})`;
  }
  if (node2.type === "LITERAL") {
    let literal = node2;
    if (literal.returnType === "json") {
      return JSON.stringify(literal.value);
    }
    if (literal.returnType === "array") {
      return JSON.stringify(literal.value);
    }
    if (literal.returnType === "number") {
      return Math.round(literal.value * 100) / 100;
    }
    if (literal.value === "") {
      return '""';
    }
    return literal.value;
  }
  if (node2.type === "COND") {
    let conditional = node2;
    return conditional.clauses.length.toString() + " clause" + (conditional.clauses.length === 1 ? "" : "s");
  }
  if (node2.type === "FUNCTION_CALL") {
    let fnCall = node2;
    let optionals = Object.values(fnCall.registry.getFunc(fnCall.name).args).map((arg) => {
      var _a;
      return (_a = arg.optional) != null ? _a : false;
    });
    return fnCall.name + "(" + fnCall.argList.filter((_2, i2) => !optionals[i2]).map((arg) => getSummary(arg)).join(", ") + ")";
  }
  if (node2.type === "STATEMENT_LIST") {
    let statementList = node2;
    return statementList.nodes.length.toString() + " statement" + (statementList.nodes.length === 1 ? "" : "s");
  }
  if (node2.type === "VARIABLE_REFERENCE") {
    let varRef = node2;
    return "$" + varRef.name;
  }
  if (node2.type === "UNSET") {
    return "";
  }
  if (node2.type === "ERROR") {
    let error = node2;
    return error.msg;
  }
  return node2.detail;
}
function getSequentialVarName(variables) {
  if (!variables.has("myVar")) {
    return "myVar";
  }
  let i2 = 0;
  while (variables.has("myVar" + i2)) {
    i2++;
  }
  return "myVar" + i2;
}
function isAncestor(cls, candidateAncestor) {
  if (!candidateAncestor || !cls)
    return false;
  if (cls === candidateAncestor)
    return true;
  return isAncestor(cls.__proto__, candidateAncestor);
}
function parseSteps(initialSteps) {
  let registry = new Registry({
    funcs: { ...stepDefs, ...conditionDefs },
    structs: structDefs,
    enums: enumDefs
  });
  Node$2.prototype.initListening = function() {
    this._listeners = [];
    this.on("change", () => {
      this._listeners.forEach((listener) => {
        listener(this);
      });
    });
    this._listening = true;
  };
  Node$2.prototype.subscribe = function(listener) {
    if (!this._listening) {
      this.initListening();
    }
    this._listeners.push(listener);
    listener(this);
    return () => {
      this._listeners = this._listeners.splice(this._listeners.indexOf(listener), 1);
    };
  };
  let tree = parseList(initialSteps, registry);
  tree.initListening();
  return tree;
}
function get_each_context$f(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i2];
  return child_ctx;
}
function get_each_context_2$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i2];
  return child_ctx;
}
function create_else_block_1$7(ctx) {
  let select;
  let mounted;
  let dispose;
  let each_value_2 = ctx[8];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      set_style(select, "width", "10rem");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[2]);
      if (!mounted) {
        dispose = listen(select, "change", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256) {
        each_value_2 = ctx2[8];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$1(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty[0] & 260) {
        select_option(select, ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$b(ctx) {
  let input;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      set_style(input, "width", "9.5rem");
      input.value = ctx[2];
      input.disabled = true;
    },
    m(target, anchor) {
      insert(target, input, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 260 && input.value !== ctx2[2]) {
        input.value = ctx2[2];
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
    }
  };
}
function create_each_block_2$1(ctx) {
  let option;
  let t_value = ctx[31] + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[31];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_2$b(ctx) {
  let tr0;
  let td0;
  let t1;
  let td1;
  let input;
  let t2;
  let tr1;
  let td2;
  let t4;
  let td3;
  let select;
  let mounted;
  let dispose;
  let each_value_1 = Object.keys(ctx[1].types);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i2));
  }
  return {
    c() {
      tr0 = element("tr");
      td0 = element("td");
      td0.textContent = "Name";
      t1 = space();
      td1 = element("td");
      input = element("input");
      t2 = space();
      tr1 = element("tr");
      td2 = element("td");
      td2.textContent = "Type";
      t4 = space();
      td3 = element("td");
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(input, "type", "text");
      set_style(select, "width", "10rem");
      if (ctx[6] === void 0)
        add_render_callback(() => ctx[15].call(select));
    },
    m(target, anchor) {
      insert(target, tr0, anchor);
      append(tr0, td0);
      append(tr0, t1);
      append(tr0, td1);
      append(td1, input);
      set_input_value(input, ctx[5]);
      insert(target, t2, anchor);
      insert(target, tr1, anchor);
      append(tr1, td2);
      append(tr1, t4);
      append(tr1, td3);
      append(td3, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[6], true);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[14]),
          listen(select, "change", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32 && input.value !== ctx2[5]) {
        set_input_value(input, ctx2[5]);
      }
      if (dirty[0] & 2) {
        each_value_1 = Object.keys(ctx2[1].types);
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & 66) {
        select_option(select, ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(tr1);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block_1$2(ctx) {
  let option;
  let t_value = ctx[28] + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[28];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t_value !== (t_value = ctx2[28] + ""))
        set_data(t, t_value);
      if (dirty[0] & 2 && option_value_value !== (option_value_value = ctx2[28])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block$p(ctx) {
  let tr;
  let td0;
  let t1;
  let td1;
  let show_if;
  function select_block_type_1(ctx2, dirty) {
    if (dirty[0] & 8)
      show_if = null;
    if (show_if == null)
      show_if = !!(Object.keys(ctx2[3]).length === 1);
    if (show_if)
      return create_if_block_1$g;
    return create_else_block$m;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      td0.textContent = "Option";
      t1 = space();
      td1 = element("td");
      if_block.c();
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(tr, t1);
      append(tr, td1);
      if_block.m(td1, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(td1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block.d();
    }
  };
}
function create_else_block$m(ctx) {
  let select;
  let mounted;
  let dispose;
  let each_value = Object.keys(ctx[3]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$f(get_each_context$f(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      set_style(select, "width", "10rem");
      if (ctx[4] === void 0)
        add_render_callback(() => ctx[16].call(select));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[4], true);
      if (!mounted) {
        dispose = listen(select, "change", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8) {
        each_value = Object.keys(ctx2[3]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$f(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$f(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & 24) {
        select_option(select, ctx2[4]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$g(ctx) {
  let input;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      set_style(input, "width", "9.5rem");
      input.value = ctx[4];
      input.disabled = true;
    },
    m(target, anchor) {
      insert(target, input, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 24 && input.value !== ctx2[4]) {
        input.value = ctx2[4];
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
    }
  };
}
function create_each_block$f(ctx) {
  let option;
  let t_value = ctx[25] + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[25];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8 && t_value !== (t_value = ctx2[25] + ""))
        set_data(t, t_value);
      if (dirty[0] & 8 && option_value_value !== (option_value_value = ctx2[25])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot$h(ctx) {
  let table;
  let tbody;
  let tr;
  let td0;
  let t1;
  let td1;
  let t2;
  let t3;
  let show_if = [
    ctx[7].ASSIGNMENT,
    ctx[7].ENUM,
    ctx[7].LITERAL,
    ctx[7].FUNCTION_CALL,
    ctx[7].STRUCT,
    ctx[7].VARIABLE_REFERENCE
  ].includes(ctx[2]);
  function select_block_type(ctx2, dirty) {
    if (ctx2[8].length === 1)
      return create_if_block_3$b;
    return create_else_block_1$7;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[2] === ctx[7].DECLARATION && create_if_block_2$b(ctx);
  let if_block2 = show_if && create_if_block$p(ctx);
  return {
    c() {
      table = element("table");
      tbody = element("tbody");
      tr = element("tr");
      td0 = element("td");
      td0.textContent = "Category";
      t1 = space();
      td1 = element("td");
      if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, tbody);
      append(tbody, tr);
      append(tr, td0);
      append(tr, t1);
      append(tr, td1);
      if_block0.m(td1, null);
      append(tbody, t2);
      if (if_block1)
        if_block1.m(tbody, null);
      append(tbody, t3);
      if (if_block2)
        if_block2.m(tbody, null);
    },
    p(ctx2, dirty) {
      if_block0.p(ctx2, dirty);
      if (ctx2[2] === ctx2[7].DECLARATION) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$b(ctx2);
          if_block1.c();
          if_block1.m(tbody, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 4)
        show_if = [
          ctx2[7].ASSIGNMENT,
          ctx2[7].ENUM,
          ctx2[7].LITERAL,
          ctx2[7].FUNCTION_CALL,
          ctx2[7].STRUCT,
          ctx2[7].VARIABLE_REFERENCE
        ].includes(ctx2[2]);
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$p(ctx2);
          if_block2.c();
          if_block2.m(tbody, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(table);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_fragment$L(ctx) {
  let savecancelmodal;
  let current;
  savecancelmodal = new SaveCancelModal({
    props: {
      title: "Create Expression",
      rect: ctx[0],
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  savecancelmodal.$on("cancel", ctx[17]);
  savecancelmodal.$on("save", ctx[10]);
  return {
    c() {
      create_component(savecancelmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savecancelmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savecancelmodal_changes = {};
      if (dirty[0] & 1)
        savecancelmodal_changes.rect = ctx2[0];
      if (dirty[0] & 126 | dirty[1] & 8) {
        savecancelmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savecancelmodal.$set(savecancelmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savecancelmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savecancelmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savecancelmodal, detaching);
    }
  };
}
function instance$J($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { rect } = $$props;
  let { registry } = $$props;
  let { filterCallback = () => true } = $$props;
  let { variables } = $$props;
  const CATEGORY = {
    DECLARATION: "Declaration",
    ASSIGNMENT: "Assignment",
    COND: "Cond",
    ENUM: "Enum",
    FUNCTION_CALL: "FunctionCall",
    LITERAL: "Literal",
    STRUCT: "Struct",
    VARIABLE_REFERENCE: "VariableReference"
  };
  let statementOptions = {};
  for (let key of Object.keys(statementOptions)) {
    if (!filterCallback(key, statementOptions[key])) {
      delete statementOptions[key];
    }
  }
  let enumOptions = Object.keys(registry.enums).reduce(
    (acc, enumName) => {
      let obj = {
        cls: EnumNode$1,
        clsArgs: [registry, enumName],
        returnType: enumName
      };
      if (filterCallback(enumName, obj)) {
        acc[enumName] = obj;
      }
      return acc;
    },
    {}
  );
  let functionCallOptions = Object.keys(registry.funcs).reduce(
    (acc, funcName) => {
      let obj = {
        cls: FunctionCall$1,
        clsArgs: [registry, funcName],
        returnType: registry.getFunc(funcName).returnType
      };
      if (filterCallback(funcName, obj)) {
        acc[funcName] = obj;
      }
      return acc;
    },
    {}
  );
  let literalOptions = ["number", "string", "boolean", "json"].reduce(
    (acc, literalName) => {
      let obj = {
        cls: Literal$1,
        clsArgs: [registry, registry.builtinTypes[literalName].default()],
        returnType: literalName
      };
      if (filterCallback(literalName, obj)) {
        acc[literalName] = obj;
      }
      return acc;
    },
    {}
  );
  let referenceOptions = {};
  for (let key of variables.keys()) {
    let obj = {
      cls: VariableReference$1,
      clsArgs: [registry, variables.get(key)],
      returnType: variables.get(key).dataType
    };
    if (filterCallback(key, obj)) {
      referenceOptions[key] = obj;
    }
  }
  if (Object.keys(referenceOptions).length === 0) {
    delete statementOptions["Assignment"];
  }
  let structOptions = Object.keys(registry.structs).reduce(
    (acc, structName) => {
      let obj = {
        cls: StructNode$1,
        clsArgs: [registry, structName],
        returnType: structName
      };
      if (filterCallback(structName, obj)) {
        acc[structName] = obj;
      }
      return acc;
    },
    {}
  );
  const categories = [];
  for (let statementOption of Object.keys(statementOptions)) {
    categories.push(statementOption);
  }
  if (Object.keys(enumOptions).length > 0) {
    categories.push(CATEGORY.ENUM);
  }
  if (Object.keys(functionCallOptions).length > 0) {
    categories.push(CATEGORY.FUNCTION_CALL);
  }
  if (Object.keys(literalOptions).length > 0) {
    categories.push(CATEGORY.LITERAL);
  }
  if (Object.keys(structOptions).length > 0) {
    categories.push(CATEGORY.STRUCT);
  }
  if (Object.keys(referenceOptions).length > 0) {
    categories.push(CATEGORY.VARIABLE_REFERENCE);
  }
  let selectedCategory = categories.includes(CATEGORY.FUNCTION_CALL) ? CATEGORY.FUNCTION_CALL : categories[0];
  let possibleOptions;
  let selectedOption;
  let varName = getSequentialVarName(variables);
  let varType = "number";
  function updateCategory(newCategory) {
    $$invalidate(2, selectedCategory = newCategory);
    if (selectedCategory === CATEGORY.FUNCTION_CALL) {
      $$invalidate(3, possibleOptions = functionCallOptions);
    } else if (selectedCategory === CATEGORY.LITERAL) {
      $$invalidate(3, possibleOptions = literalOptions);
    } else if (selectedCategory === CATEGORY.VARIABLE_REFERENCE || selectedCategory === CATEGORY.ASSIGNMENT) {
      $$invalidate(3, possibleOptions = referenceOptions);
    } else if (selectedCategory === CATEGORY.STRUCT) {
      $$invalidate(3, possibleOptions = structOptions);
    } else if (selectedCategory === CATEGORY.ENUM) {
      $$invalidate(3, possibleOptions = enumOptions);
    } else {
      $$invalidate(3, possibleOptions = void 0);
    }
    if (possibleOptions) {
      $$invalidate(4, selectedOption = Object.keys(possibleOptions)[0]);
    } else {
      $$invalidate(4, selectedOption = void 0);
    }
  }
  updateCategory(selectedCategory);
  function handleSave() {
    let obj;
    if (selectedCategory === CATEGORY.DECLARATION) {
      dispatch("save", new VariableDeclaration$1(registry, varName, varType));
      return;
    } else if (selectedCategory === CATEGORY.ASSIGNMENT) {
      let newNode = new Assignment$1(registry, new VariableReference$1(registry, variables.get(selectedOption)));
      dispatch("save", newNode);
      return;
    } else if (selectedCategory === CATEGORY.COND) {
      dispatch("save", new Conditional$1(registry));
      return;
    } else if (statementOptions.hasOwnProperty(selectedCategory)) {
      obj = statementOptions[selectedOption];
    } else if (selectedCategory === CATEGORY.FUNCTION_CALL) {
      obj = functionCallOptions[selectedOption];
    } else if (selectedCategory === CATEGORY.LITERAL) {
      obj = literalOptions[selectedOption];
    } else if (selectedCategory === CATEGORY.VARIABLE_REFERENCE) {
      obj = referenceOptions[selectedOption];
    } else if (selectedCategory === CATEGORY.STRUCT) {
      obj = structOptions[selectedOption];
    } else if (selectedCategory === CATEGORY.ENUM) {
      obj = enumOptions[selectedOption];
    } else {
      throw new Error("Unknown category and option: " + selectedCategory + " " + selectedOption);
    }
    let { cls, clsArgs } = obj;
    dispatch("save", new cls(...clsArgs));
  }
  const change_handler = (e) => updateCategory(e.target.value);
  function input_input_handler() {
    varName = this.value;
    $$invalidate(5, varName);
  }
  function select_change_handler() {
    varType = select_value(this);
    $$invalidate(6, varType);
    $$invalidate(1, registry);
  }
  function select_change_handler_1() {
    selectedOption = select_value(this);
    $$invalidate(4, selectedOption);
    $$invalidate(3, possibleOptions);
  }
  function cancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("rect" in $$props2)
      $$invalidate(0, rect = $$props2.rect);
    if ("registry" in $$props2)
      $$invalidate(1, registry = $$props2.registry);
    if ("filterCallback" in $$props2)
      $$invalidate(11, filterCallback = $$props2.filterCallback);
    if ("variables" in $$props2)
      $$invalidate(12, variables = $$props2.variables);
  };
  return [
    rect,
    registry,
    selectedCategory,
    possibleOptions,
    selectedOption,
    varName,
    varType,
    CATEGORY,
    categories,
    updateCategory,
    handleSave,
    filterCallback,
    variables,
    change_handler,
    input_input_handler,
    select_change_handler,
    select_change_handler_1,
    cancel_handler
  ];
}
class CreateNode extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$J,
      create_fragment$L,
      safe_not_equal,
      {
        rect: 0,
        registry: 1,
        filterCallback: 11,
        variables: 12
      },
      null,
      [-1, -1]
    );
  }
}
function create_if_block$o(ctx) {
  let createnode;
  let current;
  createnode = new CreateNode({
    props: {
      rect: ctx[4],
      registry: ctx[0].registry,
      filterCallback: ctx[2],
      variables: ctx[3]
    }
  });
  createnode.$on("save", ctx[5]);
  createnode.$on("cancel", ctx[6]);
  return {
    c() {
      create_component(createnode.$$.fragment);
    },
    m(target, anchor) {
      mount_component(createnode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const createnode_changes = {};
      if (dirty & 16)
        createnode_changes.rect = ctx2[4];
      if (dirty & 1)
        createnode_changes.registry = ctx2[0].registry;
      if (dirty & 4)
        createnode_changes.filterCallback = ctx2[2];
      if (dirty & 8)
        createnode_changes.variables = ctx2[3];
      createnode.$set(createnode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(createnode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(createnode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(createnode, detaching);
    }
  };
}
function create_fragment$K(ctx) {
  let div1;
  let div0;
  let switch_instance;
  let t;
  let if_block_anchor;
  let current;
  var switch_value = ComponentByType[ctx[0].type];
  function switch_props(ctx2) {
    return {
      props: { node: ctx2[0], root: true }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  let if_block = ctx[1] && create_if_block$o(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "bbx-tree-view");
      set_style(div1, "overflow-x", "auto");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & 1)
        switch_instance_changes.node = ctx2[0];
      if (dirty & 1 && switch_value !== (switch_value = ComponentByType[ctx2[0].type])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$o(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (switch_instance)
        destroy_component(switch_instance);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$I($$self, $$props, $$invalidate) {
  let { tree } = $$props;
  let showNodeCreationWizard = false;
  let resolve;
  let filterCallback;
  let variables;
  function createNode(_rect, _variables, _filterCallback) {
    $$invalidate(4, rect = _rect);
    $$invalidate(2, filterCallback = _filterCallback);
    $$invalidate(3, variables = _variables);
    $$invalidate(1, showNodeCreationWizard = true);
    return new Promise((_resolve) => {
      resolve = _resolve;
    });
  }
  function saveNewNode({ detail }) {
    $$invalidate(1, showNodeCreationWizard = false);
    if (typeof resolve === "function") {
      resolve(detail);
    }
    resolve = null;
    $$invalidate(2, filterCallback = void 0);
  }
  function cancelNewNode() {
    $$invalidate(1, showNodeCreationWizard = false);
    if (typeof resolve === "function") {
      resolve(void 0);
    }
    resolve = null;
    $$invalidate(2, filterCallback = void 0);
  }
  setContext("createNode", createNode);
  let rect = { top: 0, right: 0 };
  $$self.$$set = ($$props2) => {
    if ("tree" in $$props2)
      $$invalidate(0, tree = $$props2.tree);
  };
  return [
    tree,
    showNodeCreationWizard,
    filterCallback,
    variables,
    rect,
    saveNewNode,
    cancelNewNode
  ];
}
class TreeView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$K, safe_not_equal, { tree: 0 });
  }
}
function create_fragment$J(ctx) {
  let bbxtreeview;
  let current;
  bbxtreeview = new TreeView({ props: { tree: ctx[0] } });
  return {
    c() {
      create_component(bbxtreeview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bbxtreeview, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const bbxtreeview_changes = {};
      if (dirty & 1)
        bbxtreeview_changes.tree = ctx2[0];
      bbxtreeview.$set(bbxtreeview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bbxtreeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bbxtreeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(bbxtreeview, detaching);
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let { tree } = $$props;
  setContext("statusStore", writable("ready"));
  setContext("errorStore", writable({ message: void 0, nodeStack: [] }));
  $$self.$$set = ($$props2) => {
    if ("tree" in $$props2)
      $$invalidate(0, tree = $$props2.tree);
  };
  return [tree];
}
class Expression extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$J, safe_not_equal, { tree: 0 });
  }
}
class Selector$1 {
  constructor(value, meta = {}) {
    this.value = value;
    this.meta = meta;
  }
  toJSON() {
    return {
      type: this.getType(),
      meta: this.meta,
      value: this.value
    };
  }
}
class CSSSelector extends Selector$1 {
  select(doc) {
    return Promise.resolve([...doc.querySelectorAll(this.value)]);
  }
  getType() {
    return "css";
  }
}
class XPathSelector extends Selector$1 {
  select(doc) {
    let resultSet = doc.evaluate(this.value, doc, null, XPathResult.ANY_TYPE, null);
    let aResult = resultSet.iterateNext(), results = [];
    while (aResult && aResult.nodeType == document.ELEMENT_NODE) {
      results.push(aResult);
      aResult = resultSet.iterateNext();
    }
    return Promise.resolve(results);
  }
  getType() {
    return "xpath";
  }
}
var Feature;
(function(Feature2) {
  Feature2["command"] = "command";
  Feature2["stream_dom"] = "stream_dom";
  Feature2["state"] = "state";
  Feature2["stream_video"] = "video";
})(Feature || (Feature = {}));
var EventNames;
(function(EventNames2) {
  EventNames2["BROADCAST"] = "BS";
  EventNames2["ALL"] = "all";
  EventNames2["DOM_STREAM"] = "DS";
  EventNames2["WEBRTC_STREAM"] = "WS";
  EventNames2["FRAME_DEL"] = "frame:del";
  EventNames2["FRAME_NEW"] = "frame:new";
  EventNames2["FRAME_UPDATE"] = "frame:update";
  EventNames2["PAGE_DEL"] = "page:del";
  EventNames2["PAGE_NEW"] = "page:new";
  EventNames2["VIEWPORT"] = "viewport";
  EventNames2["MSG_EVENT"] = "EV";
  EventNames2["MSG_REQUEST"] = "RQ";
  EventNames2["MSG_RESPONSE"] = "RS";
  EventNames2["MSG_STATE"] = "ST";
  EventNames2["NET_RESPONSE"] = "NETRS";
  EventNames2["TOPIC_SUBSCRIBE"] = "topic:subscribe";
  EventNames2["TOPIC_UNSUBSCRIBE"] = "topic:unsubscribe";
  EventNames2["CHANGE"] = "change";
})(EventNames || (EventNames = {}));
var OPS;
(function(OPS2) {
  OPS2["CREATE"] = "create";
  OPS2["UPDATE"] = "update";
  OPS2["DELETE"] = "delete";
})(OPS || (OPS = {}));
var StreamTypes;
(function(StreamTypes2) {
  StreamTypes2["AUDIO"] = "audio";
  StreamTypes2["VIDEO"] = "video";
  StreamTypes2["CANVAS"] = "canvas";
})(StreamTypes || (StreamTypes = {}));
var SignalEvent;
(function(SignalEvent2) {
  SignalEvent2["STREAM_VIDEO"] = "stream-video";
  SignalEvent2["MAP_ELEMENT"] = "map-element";
  SignalEvent2["ADD_PEER"] = "add-peer";
  SignalEvent2["CLIENT_CANDIDATE"] = "client-candidate";
  SignalEvent2["CLIENT_DESCRIPTION"] = "client-description";
  SignalEvent2["SERVER_CANDIDATE"] = "server-candidate";
  SignalEvent2["SERVER_DESCRIPTION"] = "server-description";
  SignalEvent2["REMOVE_PEER"] = "remove-peer";
  SignalEvent2["DISCONNECT_ALL"] = "disconnect-all";
})(SignalEvent || (SignalEvent = {}));
var DiffOp;
(function(DiffOp2) {
  DiffOp2[DiffOp2["DEL"] = -1] = "DEL";
  DiffOp2[DiffOp2["INS"] = 1] = "INS";
  DiffOp2[DiffOp2["NOOP"] = 0] = "NOOP";
})(DiffOp || (DiffOp = {}));
var DocumentContentType;
(function(DocumentContentType2) {
  DocumentContentType2["JSON"] = "application/json";
  DocumentContentType2["HTML"] = "text/html";
})(DocumentContentType || (DocumentContentType = {}));
var Severity;
(function(Severity2) {
  Severity2["Fatal"] = "fatal";
  Severity2["Error"] = "error";
  Severity2["Warning"] = "warning";
  Severity2["Log"] = "log";
  Severity2["Info"] = "info";
  Severity2["Debug"] = "debug";
  Severity2["Critical"] = "critical";
})(Severity || (Severity = {}));
class BBXErrorEvent {
  constructor(e, type) {
    this.name = "BBXErrorEvent";
    this.metadata = {};
    this.source = "bbx-client";
    this.breadcrumbs = [];
    this.message = e.message;
    if (e.stack) {
      this.stack = e.stack;
    }
    if (type) {
      this.type = type;
    }
  }
  setPreviousEvents(crumbs) {
    this.breadcrumbs = crumbs.flatten();
    this.breadcrumbs.sort((a, b) => {
      return a.timestamp > b.timestamp ? 1 : -1;
    });
  }
}
class DOMEventError extends BBXErrorEvent {
  constructor(e, type, url, isMainFrame = false) {
    super(e, type);
    this.name = "DOMEventError";
    if (url) {
      this.metadata["url"] = url;
    }
    this.metadata["isMainFrame"] = isMainFrame;
  }
}
class AppliedDOMStreamEvent {
  constructor(event, start, err) {
    this.executions = [];
    this.event = event;
    this.add(start, err);
  }
  add(start, err) {
    this.executions.push({
      start,
      end: new Date(),
      err
    });
  }
  toBreadCrumb() {
    const breadcrumb = {
      category: this.event.name,
      timestamp: this.executions[0].start.getTime() / 1e3,
      data: {
        count: this.executions.length,
        start: this.executions[0].start,
        end: this.executions[this.executions.length - 1].end
      }
    };
    for (let i2 = 0; i2 < this.executions.length; i2++) {
      let exec2 = this.executions[i2];
      if (exec2.err) {
        breadcrumb.message || (breadcrumb.message = exec2.err.message);
        breadcrumb.data[i2] = exec2.err.message;
        breadcrumb.level || (breadcrumb.level = Severity.Error);
      }
    }
    return breadcrumb;
  }
}
class AppliedDOMStreamEvents {
  constructor(maxLength) {
    this.maxLength = 15;
    this.events = [];
    this.maxLength = maxLength;
  }
  push(event, startTime, err = void 0) {
    const lastAppliedEvent = this.events[this.events.length - 1];
    if (lastAppliedEvent && lastAppliedEvent.event.name === event.name) {
      lastAppliedEvent.add(startTime, err);
      return;
    }
    if (this.events.length === this.maxLength) {
      this.events.shift();
    }
    this.events.push(new AppliedDOMStreamEvent(event, startTime, err));
  }
  flatten() {
    const breadcrumbs = [];
    this.events.map((e) => {
      return e.toBreadCrumb();
    }).forEach((crumb) => {
      breadcrumbs.push(crumb);
    });
    return breadcrumbs;
  }
}
function id(prefix = "", seed = 0) {
  return () => `${prefix}${seed++}`;
}
class EventEmitter {
  constructor() {
    this.__ee_listeners = {};
  }
  emit(name, ...args) {
    (this.__ee_listeners[name] || []).forEach((l) => l(...args));
  }
  hasListener(name) {
    return (this.__ee_listeners[name] || []).length > 0;
  }
  off(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    let index2 = listeners.indexOf(listener);
    while (index2 >= 0) {
      listeners.splice(index2, 1);
      index2 = listeners.indexOf(listener);
    }
    return this;
  }
  on(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    listeners.push(listener);
    return this;
  }
  once(name, listener) {
    const l2 = (...args) => {
      this.off(name, l2);
      listener(...args);
    };
    this.on(name, l2);
    return this;
  }
  reset() {
    this.__ee_listeners = [];
  }
  waitForEvent(name, ...selectors) {
    return new Promise((resolve) => {
      const l2 = (...args) => {
        for (let i2 = 0, length = selectors.length; i2 < length; i2 += 1) {
          if (selectors[i2] !== args[i2]) {
            return;
          }
        }
        resolve(args[0]);
      };
      this.on(name, l2);
    });
  }
}
const CLIENT_VERSION = "2.2.3";
const idFn = id("_");
class APIError extends Error {
  constructor(e) {
    var _a;
    super((_a = e.message) != null ? _a : e.msg);
    this.code = e.code;
  }
}
class APIClient extends EventEmitter {
  constructor(options) {
    super();
    this.messageListeners = [];
    this.messageQueue = [];
    this._responseListeners = /* @__PURE__ */ new Map();
    if (!options.basePath) {
      options.basePath = "";
    }
    this.options = options;
    this.onMessage = this.onMessage.bind(this);
    this.onSocketClose = this.onSocketClose.bind(this);
    this.onSocketError = this.onSocketError.bind(this);
    this.onSocketOpen = this.onSocketOpen.bind(this);
    this._isS = !(location.protocol == "http:" && options.host.startsWith("localhost:"));
  }
  addMessageListener(messageListener) {
    this.messageListeners.push(messageListener);
  }
  removeMessageListener(messageListener) {
    let index2 = this.messageListeners.indexOf(messageListener);
    if (index2 >= 0) {
      this.messageListeners.splice(index2, 1);
    }
  }
  close() {
    if (this.socket) {
      this.removeSocketListeners();
      if (this.socket.readyState != WebSocket.CLOSED) {
        this.socket.close(1e3);
      }
    }
  }
  async connect() {
    if (this.socket) {
      this.removeSocketListeners();
    }
    let url;
    if (this.options.host) {
      url = `ws${this._isS ? "s" : ""}://${this.options.host + this.options.basePath}`;
      let checkReady = this.options.checkReady == void 0 ? true : this.options.checkReady;
      if (checkReady) {
        await this.waitForInstanceToBeReady();
      }
    } else {
      if (this.options.url) {
        console.warn(`Browser-box has deprecated Url as connect option, host can be given as option
 Eg: {host:abc.bbx.net}  `);
      } else {
        console.error(`Host was not given as option, host can be given as option
  Eg: {host:abc.bbx.net}  `);
      }
    }
    this.socket = new WebSocket(url);
    this.addSocketListeners();
  }
  async waitForInstanceToBeReady() {
    let retryCount = 22, ready = false;
    while (retryCount > 0 && !ready) {
      try {
        await this.api("about");
        ready = true;
      } catch (e) {
        console.error("bbx runner not ready?", e);
        await wait$1(2400);
      }
      retryCount--;
    }
    if (!ready) {
      this.emit("socket:error", { message: "Browser server not ready" });
      throw new Error("Browser server not ready");
    }
  }
  addSocketListeners() {
    this.socket.addEventListener("open", this.onSocketOpen);
    this.socket.addEventListener("error", this.onSocketError);
    this.socket.addEventListener("close", this.onSocketClose);
    this.socket.addEventListener("message", this.onMessage);
  }
  removeSocketListeners() {
    this.socket.removeEventListener("open", this.onSocketOpen);
    this.socket.removeEventListener("error", this.onSocketError);
    this.socket.removeEventListener("close", this.onSocketClose);
    this.socket.removeEventListener("message", this.onMessage);
  }
  getBaseURL() {
    return `http${this._isS ? "s" : ""}://${this.options.host}${this.options.basePath}`;
  }
  async api(path, method = "GET", data = void 0) {
    let { host, key, basePath } = this.options;
    let hasData = !!data;
    let url = `http${this._isS ? "s" : ""}://${host}${basePath}/${path}`;
    let headers = {
      "content-type": "application/json",
      "x-auth": key,
      "x-client-id": this.clientId
    };
    let res = await fetch(url, {
      method,
      mode: "cors",
      headers,
      body: hasData ? JSON.stringify(data) : void 0
    });
    switch (res.status) {
      case 200:
        return await res.json();
      case 401:
        throw new Error("Invalid authentication credentials");
      default:
        console.error("invalid response", res);
        throw new Error("Error response received.");
    }
  }
  async call(name, ...args) {
    let id2 = idFn();
    try {
      this.send(JSON.stringify({
        type: EventNames.MSG_REQUEST,
        id: id2,
        name,
        args
      }));
      return this._waitForResponse(id2);
    } catch (e) {
      this.emit("api:error", e);
      throw e;
    }
  }
  async callPup(path, method, ...args) {
    return this.call("pup", path, method, ...args);
  }
  async _waitForResponse(id2) {
    return new Promise((resolve, reject) => {
      this._responseListeners.set(id2, (res) => {
        let err = res.err;
        if (err) {
          reject(new APIError(err));
        } else {
          resolve(res.data);
        }
      });
    });
  }
  onMessage(msg) {
    let data = JSON.parse(msg.data);
    if (data.type == EventNames.MSG_RESPONSE) {
      this.onResponse(data);
      return;
    }
    this.messageListeners.forEach((l) => l.onMessage(data));
  }
  onResponse(response) {
    let { id: id2 } = response;
    let handler = this._responseListeners.get(id2);
    if (handler) {
      this._responseListeners.delete(id2);
      handler(response);
    } else {
      console.error("Unhandled response", response);
      throw new Error("Unhandled response: " + id2);
    }
  }
  onSocketClose(e) {
    this.emit("socket:close", { code: e.code });
  }
  onSocketError(e) {
    this.emit("socket:error", e);
  }
  async onSocketOpen(_e) {
    let resp = await this.register();
    this.clientId = resp.clientId;
    this.messageQueue.forEach((msg) => this.send(msg));
    this.messageQueue = [];
  }
  async register() {
    let data = {
      features: this.options.features,
      key: this.options.key,
      clientVersion: CLIENT_VERSION,
      allowJSON: true
    };
    return await this.call("register", data);
  }
  send(msg) {
    let socket = this.socket;
    if (socket && socket.readyState == WebSocket.OPEN) {
      this.socket.send(msg);
    } else {
      this.messageQueue.push(msg);
    }
  }
  async sendError(e) {
    await this.api("errors", "POST", e);
  }
}
async function wait$1(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function connect(options) {
  let apiClient = new APIClient(options);
  apiClient.connect().catch((e) => {
    apiClient.sendError(new BBXErrorEvent(e, "connect"));
  });
  return apiClient;
}
const TOPIC_ORIGIN = "t";
class BaseItem extends EventEmitter {
  constructor(data, collection) {
    super();
    this.collection = collection;
    this.id = data.id;
    this.set(data);
  }
  set(data) {
    this.data = { ...this.data, ...data };
    this.collection.emit(EventNames.ALL, {
      name: OPS.UPDATE,
      event: { data }
    });
    this.collection.emit(OPS.UPDATE, { data });
  }
}
class BaseCollection extends EventEmitter {
  constructor(name, store2, options = {}) {
    super();
    this.items = [];
    this.onTopicEvent = async (event) => {
      let resp, item;
      let id2 = event.result.id;
      switch (event.operation) {
        case OPS.CREATE:
        case OPS.UPDATE:
          resp = await this._api(`/${id2}`);
          item = this.get(resp.id);
          item ? item.set(resp) : this._add(resp);
          break;
        case OPS.DELETE:
          item = this.get(id2);
          if (item) {
            this._remove(item);
          } else {
            console.error("the item is already deleted", event.result);
          }
          break;
      }
    };
    this.name = name;
    this.store = store2;
    this.options = options;
    if (this.options.autoSync) {
      this.enableSync();
    }
  }
  async getCurrentItems() {
    let resp = await this.fetch();
    (resp.data || []).forEach((it) => {
      let item = this.get(it.id);
      item ? item.set(it) : this._add(it);
    });
  }
  enableSync() {
    if (!this._unSubscribe) {
      this._unSubscribe = this.store.subscribe(this.name, this.onTopicEvent);
    }
  }
  disableSync() {
    this._unSubscribe();
  }
  _api(path, method = "GET", data = null) {
    const url = `${TOPIC_ORIGIN}/${this.name}` + path;
    return this.store.apiClient.api(url, method, data);
  }
  get(id2) {
    return this.items.find((item) => item.id === id2);
  }
  setQuery(query) {
    this.query = new URLSearchParams(query).toString();
  }
  async fetch() {
    let path = this.query ? "?" + this.query : "";
    let resp = await this._api(path);
    return resp;
  }
  async _add(data) {
    let item = this.newItem(data);
    this.emit(OPS.CREATE, { data });
    this.emit(EventNames.ALL, {
      name: OPS.CREATE,
      event: { data }
    });
    this.items.push(item);
    return item;
  }
  async _remove(item) {
    let index2 = this.items.indexOf(item);
    this.items.splice(index2, 1);
    this.emit(OPS.DELETE, { data: item.id });
    this.emit(EventNames.ALL, {
      name: OPS.DELETE,
      event: { data: item.id }
    });
  }
}
class Clients extends BaseCollection {
  constructor(store2, options = {}) {
    super("client", store2, options);
    this.name = "client";
  }
  newItem(data) {
    return new BaseItem(data, this);
  }
}
class Base$1 extends EventEmitter {
  constructor(caller, id2) {
    super();
    this.caller = caller;
    this.id = id2;
  }
  async call(method, ...args) {
    this.emit("call", this, { method, args });
    return this.caller.call(this.getPath(), method, ...args);
  }
  getPath() {
    let parent2 = this.getParent();
    let path = parent2 ? parent2.getPath() : [];
    path.push(this.getNodeId());
    return path;
  }
}
class Frame extends Base$1 {
  constructor(page, state) {
    super(page.caller, state.id);
    this.page = page;
  }
  getIndex() {
    return this.page.frames.indexOf(this);
  }
  getNodeId() {
    return { name: "frame", id: this.id };
  }
  getParent() {
    return this.page;
  }
  isMain() {
    return this.page.mainFrame == this;
  }
  update(state) {
    Object.assign(this, state);
    this.emit("change", state);
  }
}
class Page extends Base$1 {
  constructor(browser2, state) {
    super(browser2.caller, state.id);
    this.frames = [];
    this.browser = browser2;
    for (let i2 = 0; i2 < state.frames.length; i2 += 1) {
      let frame = new Frame(this, state.frames[i2]);
      this.frames.push(frame);
    }
    this.mainFrame = this.frames[0];
    this.mainFrame.on("change", (e) => this.emit("change", e));
  }
  addFrame(state) {
    let frame = new Frame(this, state);
    this.frames.push(frame);
    this.emit("frameadded", frame);
    return frame;
  }
  delFrame(frameId) {
    let frame = this.getFrame(frameId);
    if (frame) {
      let index2 = this.frames.indexOf(frame);
      this.frames.splice(index2, 1);
      this.emit("framedetached", frame);
    } else {
      console.warn("warn: failed to delete frame");
    }
    return frame;
  }
  async close() {
    return this.call("close");
  }
  async goto(url, options) {
    return this.call("goto", url, options);
  }
  async goBack() {
    return this.call("goBack", ...arguments);
  }
  async goForward() {
    return this.call("goForward", ...arguments);
  }
  async reload() {
    return this.goto(this.mainFrame.url);
  }
  async trigger(name, params2) {
    this.emit("trigger", name, params2);
    return this.browser.call("trigger", this.id, name, params2);
  }
  getFrame(frameId) {
    let frames = this.frames;
    let len = frames.length;
    for (let i2 = 0; i2 < len; i2 += 1) {
      let frame = frames[i2];
      if (frame.id == frameId) {
        return frame;
      }
    }
  }
  getNodeId() {
    return { name: "page", id: this.id };
  }
  getParent() {
    return this.browser;
  }
}
class Browser$2 extends Base$1 {
  constructor(caller, state) {
    super(caller, "0");
    this.pages = [];
    for (let i2 = 0; i2 < state.pages.length; i2 += 1) {
      this.pages.push(new Page(this, state.pages[i2]));
    }
    this.viewport = state.viewport;
  }
  async newPage() {
    let res = await this.call("newPage");
    let pageState = res;
    let page = this.getPage(pageState.id);
    if (page) {
      return page;
    }
    return await this.waitForEvent("pageadded");
  }
  onNewPage(state) {
    let page = new Page(this, state);
    this.pages.push(page);
    this.emit("pageadded", page);
    return page;
  }
  onDelPage(pageId) {
    let page = this.getPage(pageId);
    if (page) {
      let index2 = this.pages.indexOf(page);
      this.pages.splice(index2, 1);
      this.emit("pagedeleted", page);
    } else {
      console.warn("warn: failed to delete page");
    }
    return page;
  }
  onViewport(viewport) {
    this.viewport = viewport;
    this.emit("viewport", viewport);
  }
  getNodeId() {
    return { name: "browser", id: this.id };
  }
  getActivePage() {
    return this.pages[this.pages.length - 1];
  }
  async setActivePage(_id) {
    throw new Error("Not implemented");
  }
  getPage(id2) {
    let pages = this.pages;
    let len = pages.length;
    for (let i2 = 0; i2 < len; i2 += 1) {
      let page = pages[i2];
      if (page.id == id2) {
        return page;
      }
    }
  }
  getParent() {
    return null;
  }
}
class StoreManager extends EventEmitter {
  constructor(apiClient) {
    super();
    this.connectedClients = [];
    this._domStreamListeners = [];
    this._webrtcStreamListeners = [];
    this.apiClient = apiClient;
    this.apiClient.addMessageListener(this);
    this.clients = new Clients(this, { autoSync: true });
  }
  subscribe(name, callback = (_event) => {
  }) {
    if (!this.hasListener(`broadcast:${name}`)) {
      this.apiClient.call(EventNames.TOPIC_SUBSCRIBE, {
        name
      });
    }
    this.on(`broadcast:${name}`, callback);
    return () => {
      this.off(`broadcast:${name}`, callback);
      if (!this.hasListener(`broadcast:${name}`)) {
        this.apiClient.call(EventNames.TOPIC_UNSUBSCRIBE, {
          name
        });
      }
    };
  }
  addDOMStreamListener(listener) {
    this._domStreamListeners.push(listener);
  }
  removeDOMStreamListener(listener) {
    let index2 = this._domStreamListeners.indexOf(listener);
    while (index2 >= 0) {
      this._domStreamListeners.splice(index2, 1);
      index2 = this._domStreamListeners.indexOf(listener);
    }
  }
  addWEBRTCStreamListener(listener) {
    this._webrtcStreamListeners.push(listener);
  }
  removeWEBRTCStreamListener(listener) {
    let index2 = this._webrtcStreamListeners.indexOf(listener);
    while (index2 >= 0) {
      this._webrtcStreamListeners.splice(index2, 1);
      index2 = this._webrtcStreamListeners.indexOf(listener);
    }
  }
  onMessage(data) {
    let { type } = data;
    switch (type) {
      case EventNames.MSG_EVENT:
        this.onEvent(data);
        break;
      case EventNames.MSG_STATE:
        this.onState(data.data);
        break;
      case EventNames.BROADCAST:
        this.onBroadcast(data);
        break;
    }
  }
  onBroadcast(event) {
    let { name, data } = event;
    this.emit(`broadcast:${name}`, data);
  }
  onEvent(event) {
    let { name, data } = event;
    let obj;
    switch (name) {
      case EventNames.WEBRTC_STREAM: {
        let [pageId2, frameId2, peerId, webrtcEvent] = data;
        const event2 = webrtcEvent;
        this._webrtcStreamListeners.forEach((l) => l.onWEBRTCEvent(pageId2, frameId2, peerId, event2));
        let frame2 = this.browser.getPage(pageId2).getFrame(frameId2);
        frame2.emit(EventNames.WEBRTC_STREAM, event2);
        break;
      }
      case EventNames.DOM_STREAM:
        let [pageId, frameId, domEvent] = data;
        this._domStreamListeners.forEach((l) => l.onDOMEvent(pageId, frameId, domEvent));
        let page = this.browser.getPage(pageId);
        let frame = obj = page.getFrame(frameId);
        frame.emit(EventNames.DOM_STREAM, domEvent);
        break;
      case EventNames.FRAME_DEL: {
        let [pageId2, frameId2] = data;
        let page2 = obj = this.browser.getPage(pageId2);
        page2.delFrame(frameId2);
        break;
      }
      case EventNames.FRAME_NEW: {
        let [pageId2, frameState] = data;
        let page2 = this.browser.getPage(pageId2);
        obj = page2.addFrame(frameState);
        break;
      }
      case EventNames.FRAME_UPDATE: {
        let [pageId2, frameState] = data;
        let page2 = this.browser.getPage(pageId2);
        let frame2 = obj = page2.getFrame(frameState.id);
        frame2.update(frameState);
        break;
      }
      case EventNames.PAGE_DEL: {
        let [pageId2] = data;
        obj = this.browser.onDelPage(pageId2);
        break;
      }
      case EventNames.PAGE_NEW: {
        let [pageState] = data;
        obj = this.browser.onNewPage(pageState);
        break;
      }
      case EventNames.VIEWPORT: {
        let [viewport] = data;
        this.browser.onViewport(viewport);
        obj = this.browser;
        break;
      }
      default:
        console.warn("Unhandled event:", name, data);
    }
    this.emit("bbx", name, obj, data);
  }
  onState(state) {
    this.browser = new Browser$2(this, state);
    this.emit("ready");
  }
  async call(path, method, ...args) {
    this.emit("api", path, method, ...args);
    return await this.apiClient.callPup(getNodePath(path), method, ...args);
  }
}
function getNodePath(nodes) {
  return nodes.map((node2) => node2.id).join("/");
}
function debounce(func2, wait2, immediate = false) {
  let timeout;
  return function(...args) {
    let context = this;
    let callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      if (!immediate) {
        func2.apply(context, args);
      }
    }, wait2);
    if (callNow)
      func2.apply(context, args);
  };
}
function findPath(child, root = null, pathArr = []) {
  let parent2 = child.parentElement;
  if (parent2 === null || root == child) {
    let shadow = getHost(child);
    if (!shadow) {
      pathArr.reverse();
      return pathArr;
    } else {
      let i2 = getNodeIndex(shadow.shadowRoot, child);
      if (i2 > -1) {
        pathArr.push(i2);
      }
      pathArr.push(-1);
      return findPath(shadow, root, pathArr);
    }
  }
  let index2 = getNodeIndex(parent2, child);
  pathArr.push(index2);
  return findPath(parent2, root, pathArr);
}
function getHost(child) {
  let root = child.getRootNode();
  if (root.nodeType == document.DOCUMENT_FRAGMENT_NODE) {
    return root.host;
  }
  return null;
}
function getNodeIndex(parent2, child) {
  let childList = parent2.childNodes;
  for (let i2 = 0; i2 < childList.length; ++i2) {
    if (childList[i2] === child) {
      return i2;
    }
  }
  return -1;
}
function getNode(path, doc) {
  let next2 = doc.documentElement;
  for (let i2 = 0, len = path.length; i2 < len; i2++) {
    let ind = path[i2], child;
    if (ind == -1) {
      child = next2.shadowRoot;
    } else {
      child = next2.childNodes[path[i2]];
    }
    if (!child) {
      throw new Error(`Failed to find node at: ${i2} for path: ${path}. Last parent found is: ${next2.nodeName}`);
    }
    next2 = child;
  }
  return next2;
}
function createElement(node2, parentNamespace) {
  if (!!node2[4]) {
    if ("http://www.w3.org/1999/xhtml" === node2[4]) {
      return document.createElementNS(node2[4], node2[1].toLowerCase());
    }
    return document.createElementNS(node2[4], node2[1]);
  } else if (!!parentNamespace && parentNamespace.length > 0) {
    if ("http://www.w3.org/1999/xhtml" === parentNamespace) {
      return document.createElementNS(parentNamespace, node2[1].toLowerCase());
    }
    return document.createElementNS(parentNamespace, node2[1]);
  } else {
    return document.createElement(node2[1].toLowerCase());
  }
}
function setAttributes(elem, attributes2) {
  for (let i2 = 0; !!attributes2 && i2 < attributes2.length; i2++) {
    let attribute = attributes2[i2];
    setAttribute(attribute, elem);
  }
}
function setAttribute(attribute, elem) {
  let keys = Object.keys(attribute);
  let namespace, qualifiedName, value;
  try {
    if (!!keys && keys.length === 2) {
      if ("namespaceURI" === keys[0]) {
        namespace = attribute[keys[0]];
        qualifiedName = keys[1];
        value = attribute[keys[1]];
      } else {
        namespace = attribute[keys[1]];
        qualifiedName = keys[0];
        value = attribute[keys[0]];
      }
      elem.setAttributeNS(namespace, qualifiedName, value);
    } else if (keys.length === 1) {
      qualifiedName = keys[0];
      value = attribute[keys[0]];
      elem.setAttribute(qualifiedName, value);
    }
  } catch (err) {
    if (namespace) {
      console.error("error while setting attributesNs", namespace, qualifiedName, value);
    } else {
      console.error("error while setting attributes", qualifiedName, value);
    }
  }
}
function appendDOM(elem, child) {
  if (child) {
    if (elem.nodeType === Node.COMMENT_NODE) {
      if (child.nodeType === Node.TEXT_NODE) {
        elem.nodeValue += child.nodeValue;
      }
    } else {
      elem.appendChild(child);
    }
  }
}
function patch(elem, jsonNode) {
  let childNodes = jsonNode[3];
  for (let i2 = 0; !!childNodes && i2 < childNodes.length; i2++) {
    if (!!childNodes[i2]) {
      appendDOM(elem, toDOM(childNodes[i2], elem.namespaceURI));
    }
  }
  let attributes2 = jsonNode[2];
  if (!!attributes2 && attributes2.length > 0) {
    setAttributes(elem, attributes2);
  }
  return elem;
}
function toDOM(jsonNode, parentNamespace) {
  if (!jsonNode) {
    return null;
  }
  if (jsonNode[0] === Node.TEXT_NODE) {
    jsonNode = jsonNode;
    return document.createTextNode(jsonNode[1]);
  }
  if (jsonNode[0] === Node.CDATA_SECTION_NODE) {
    jsonNode = jsonNode;
    return document.createCDATASection(jsonNode[1]);
  }
  if (jsonNode[0] === Node.COMMENT_NODE) {
    jsonNode = jsonNode;
    return document.createComment(jsonNode[1]);
  }
  jsonNode = jsonNode;
  return patch(createElement(jsonNode, parentNamespace), jsonNode);
}
function parseHTML(documentContent, doc = document) {
  let node2;
  if (typeof documentContent == "string") {
    let parser = new DOMParser();
    node2 = parser.parseFromString(documentContent, "text/html").documentElement;
  } else if (documentContent.type === DocumentContentType.JSON) {
    node2 = toDOM(documentContent.content, null);
  }
  if (node2.nodeType === Node.ELEMENT_NODE) {
    let el = node2;
    revertTextNodes(el);
  }
  return node2;
}
function parseHTMLFrag(documentContent, doc) {
  let node2;
  if (typeof documentContent == "string") {
    node2 = parseHTMLUsingTemplate(documentContent, doc);
  } else if (documentContent.type === DocumentContentType.JSON) {
    node2 = toDOM(documentContent.content, null);
  }
  if (node2.nodeType == doc.ELEMENT_NODE) {
    revertTextNodes(node2);
  }
  return node2;
}
function parseHTMLUsingTemplate(html2, doc) {
  if (html2[0] == "#") {
    return doc.createTextNode(html2.slice(1));
  }
  if (html2.slice(0, 4) == "<!--") {
    return doc.createComment("");
  }
  const template = doc.createElement("template");
  template.innerHTML = html2;
  let clone = doc.importNode(template.content, true);
  return clone.childNodes[0];
}
function revertTextNodes(el) {
  const elTextNodes = Array.from(el.querySelectorAll("text-node"));
  for (let i2 = 0, len = elTextNodes.length; i2 < len; i2 += 1) {
    const tEl = elTextNodes[i2];
    tEl.replaceWith(document.createTextNode(tEl.innerHTML));
  }
}
function applyPatch(doc, path, diffs) {
  let currentInd = 0;
  const parentNode = getNode(path, doc);
  if (!parentNode) {
    throw new Error("Failed to find node for path: " + JSON.stringify(path));
  }
  diffs.forEach((diff2) => {
    let op = diff2[0];
    switch (op) {
      case DiffOp.NOOP: {
        let count2 = diff2[1];
        currentInd += count2;
        break;
      }
      case DiffOp.DEL: {
        diff2[1];
        for (let _i = 0; _i < diff2[1]; _i++) {
          parentNode.childNodes[currentInd].remove();
        }
        break;
      }
      case DiffOp.INS: {
        let nodes = diff2[1];
        let refNode = parentNode.childNodes[currentInd];
        for (let _i = 0; _i < nodes.length; _i++) {
          let newNode = parseHTMLFrag(nodes[_i], doc);
          parentNode.insertBefore(newNode, refNode);
        }
        currentInd += nodes.length;
        break;
      }
      default:
        throw new Error();
    }
  });
}
class WebrtcClient extends EventEmitter {
  constructor(id2, frame, rtcConfig) {
    super();
    this._rtcEvents = [];
    this.controllers = /* @__PURE__ */ new Map();
    this.rtcConfig = {
      "iceServers": [{
        "urls": "stun:stun.l.google.com:19302"
      }],
      "sdpSemantics": "unified-plan"
    };
    this.id = id2;
    this.frame = frame;
  }
  connect() {
    this.peer = new RTCPeerConnection(this.rtcConfig);
    this.peer.ontrack = (track) => {
      const controller = this.controllers.get(track.streams[0].id);
      if (!controller.isTrackEmpty()) {
        controller.initializeTrack(track);
      } else {
        controller.appendTrack(track);
      }
    };
    this.peer.oniceconnectionstatechange = () => {
      if (this.peer.iceConnectionState === "disconnected") {
        this.close();
      }
    };
    this.peer.onnegotiationneeded = async () => {
    };
    this.trigger(SignalEvent.ADD_PEER, {
      id: this.id,
      initiator: false,
      frameId: this.frame.store.id
    });
  }
  close() {
    this.peer.close();
  }
  clientCandidate(ev) {
    this.trigger(SignalEvent.CLIENT_CANDIDATE, {
      id: this.id,
      initiator: false,
      candidate: ev.candidate,
      frameId: this.frame.store.id
    });
  }
  clientDescription(sdp) {
    this.trigger(SignalEvent.CLIENT_DESCRIPTION, {
      id: this.id,
      initiator: false,
      sdp,
      frameId: this.frame.store.id
    });
  }
  async onServerCandidate(candidate) {
    if (candidate) {
      await this.peer.addIceCandidate(candidate);
      this.peer.onicecandidate = this.clientCandidate.bind(this);
    }
  }
  async onServerDescription(sdp) {
    if (sdp) {
      await this.peer.setRemoteDescription(sdp);
      const answer = await this.peer.createAnswer();
      await this.peer.setLocalDescription(answer);
      this.clientDescription(answer);
    }
  }
  onMapElement(event) {
    try {
      let element2 = getNode(event.path, this.frame.getDoc());
      if (event.mappingType === StreamTypes.CANVAS) {
        const canvasController = new CanvasController(event.mappedId, this.frame, element2);
        this.controllers.set(event.mappedId, canvasController);
      } else if (event.mappingType === StreamTypes.VIDEO) {
        const videoController = new VideoController(event.mappedId, this.frame, element2);
        this.controllers.set(event.mappedId, videoController);
      } else if (event.mappingType === StreamTypes.AUDIO) {
        const audioController = new AudioController(event.mappedId, this.frame, element2);
        this.controllers.set(event.mappedId, audioController);
      }
    } catch (e) {
      console.error("stream element not found ", e);
    }
  }
  async onWEBRTCEvent(id2, event) {
    if (id2 !== this.id)
      return;
    if (event.initiator) {
      switch (event.name) {
        case SignalEvent.SERVER_CANDIDATE: {
          await this.onServerCandidate(event.candidate);
          break;
        }
        case SignalEvent.SERVER_DESCRIPTION: {
          await this.onServerDescription(event.sdp);
          break;
        }
        case SignalEvent.MAP_ELEMENT: {
          this.onMapElement(event);
          break;
        }
      }
    }
  }
  trigger(name, params2) {
    this.frame.triggerSignallingServer(name, params2);
  }
}
class StreamController {
  constructor(frame) {
    this.frame = frame;
    this.istrackInitialized = false;
  }
}
class VideoController extends StreamController {
  constructor(streamId, frame, element2) {
    super(frame);
    this.streamId = streamId;
    this.video = element2;
  }
  getController(id2) {
    return this;
  }
  isTrackEmpty() {
    return this.istrackInitialized;
  }
  initializeTrack(event) {
    this.video.srcObject = event.streams[0];
    this.video.addEventListener("loadeddata", () => {
      if (this.video.readyState == 4) {
        this.video.muted = true;
        this.video.autoplay = true;
        this.video.play();
      }
    });
    this.video.addEventListener("playing", (ev) => {
      this.video.muted = false;
    });
    this.video.onerror = (e) => {
      console.error("error ", e);
    };
    this.istrackInitialized = true;
  }
  appendTrack(event) {
    if (event.track.kind === "audio") {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getAudioTracks().forEach((audioTrack) => {
        if (audioTrack.id !== event.track.id) {
          this.video.srcObject.removeTrack(audioTrack);
        }
      });
    } else {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getVideoTracks().forEach((videoTrack) => {
        if (videoTrack.id !== event.track.id)
          this.video.srcObject.removeTrack(videoTrack);
      });
    }
  }
}
class CanvasController extends StreamController {
  constructor(streamId, frame, element2) {
    super(frame);
    this.streamId = streamId;
    this.element = element2;
    this.video = this._getCanvasVideo(this.element);
  }
  getController(id2) {
    return this;
  }
  isTrackEmpty() {
    return this.istrackInitialized;
  }
  initializeTrack(event) {
    this.video.srcObject = event.streams[0];
    this.video.addEventListener("loadeddata", () => {
      if (this.video.readyState == 4) {
        this.video.muted = true;
        this.video.autoplay = true;
        this.video.play();
      }
    });
    this.video.onerror = (e) => {
      console.error("error ", e);
    };
    this.istrackInitialized = true;
  }
  appendTrack(event) {
    if (event.track.kind === "audio") {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getAudioTracks().forEach((audioTrack) => {
        if (audioTrack.id !== event.track.id) {
          this.video.srcObject.removeTrack(audioTrack);
        }
      });
    } else {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getVideoTracks().forEach((videoTrack) => {
        if (videoTrack.id !== event.track.id)
          this.video.srcObject.removeTrack(videoTrack);
      });
    }
  }
  _getCanvasVideo(canvas) {
    if (canvas) {
      return this._createVideoElement(canvas);
    }
    return;
  }
  _createVideoElement(canvas) {
    const video = document.createElement("video");
    canvas.classList.forEach((value) => video.classList.add(value));
    video.setAttribute("hidden", "true");
    video.setAttribute("loop", "true");
    this.frame.elMeta.appendChild(video);
    video.addEventListener("play", () => {
      const context = canvas.getContext("2d");
      requestAnimationFrame((time2) => {
        this._runVideoInCanvas(context, video);
      });
    });
    return video;
  }
  _runVideoInCanvas(context, video) {
    if (video.paused || video.ended) {
      return;
    }
    this._computeFrame(context, video);
    requestAnimationFrame((time2) => {
      this._runVideoInCanvas(context, video);
    });
  }
  _computeFrame(context, video) {
    const width = context.canvas.width;
    const height = context.canvas.height;
    context.drawImage(video, 0, 0, width, height);
    return;
  }
}
class AudioController extends StreamController {
  constructor(streamId, frame, element2) {
    super(frame);
    this.streamId = streamId;
    this.audio = element2;
  }
  getController(id2) {
    return this;
  }
  isTrackEmpty() {
    return this.istrackInitialized;
  }
  initializeTrack(event) {
    this.audio.srcObject = event.streams[0];
    this.audio.addEventListener("loadeddata", () => {
      if (this.audio.readyState == 4) {
        this.audio.autoplay = true;
      }
    });
    this.audio.addEventListener("playing", (ev) => {
      this.audio.muted = false;
    });
    this.audio.onerror = (e) => {
      console.error("error ", e);
    };
    this.istrackInitialized = true;
  }
  appendTrack(event) {
    if (event.track.kind === "audio") {
      this.audio.srcObject.addTrack(event.track);
      this.audio.srcObject.getAudioTracks().forEach((audioTrack) => {
        if (audioTrack.id !== event.track.id) {
          this.audio.srcObject.removeTrack(audioTrack);
        }
      });
    } else {
      this.audio.srcObject.addTrack(event.track);
      this.audio.srcObject.getVideoTracks().forEach((videoTrack) => {
        if (videoTrack.id !== event.track.id)
          this.audio.srcObject.removeTrack(videoTrack);
      });
    }
  }
}
class ResolvablePromise extends Promise {
  constructor(executor) {
    let resolve;
    super(executor != null ? executor : (res, rej) => {
      resolve = res;
    });
    this.resolve = resolve;
  }
  getValue() {
    return this.value;
  }
  setValue(value) {
    this.value = value;
    this.resolve();
  }
}
const BASE_GLOBALS = {
  Float32Array,
  Uint8Array,
  Uint16Array,
  Uint32Array,
  Image,
  Promise: ResolvablePromise,
  Path2D
};
class VM {
  constructor(fv) {
    this.cmds = [];
    this.globals = {
      ...BASE_GLOBALS,
      $0: {
        createCSS: (...args) => {
          const win = this.fv.getDoc().defaultView;
          return win.createCSS(...args);
        },
        defineElement: (name) => {
          const win = this.fv.getDoc().defaultView;
          return win.defineElement(name, class extends HTMLElement {
          });
        },
        getNode: (...path) => getNode(path, this.fv.getDoc()),
        getImageDataFromDataURL(dataURL) {
          let promise = new ResolvablePromise();
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const img = new Image();
          img.src = dataURL;
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            promise.setValue(ctx.getImageData(0, 0, img.width, img.height));
          };
          return promise;
        }
      },
      $doc: null
    };
    this.getValue = (valueOrCmd) => {
      if (typeof valueOrCmd === "string" && valueOrCmd.startsWith("$")) {
        return this.globals[valueOrCmd];
      } else if (Array.isArray(valueOrCmd)) {
        return this.handleCmd(valueOrCmd);
      }
      return valueOrCmd;
    };
    this.fv = fv;
    Object.defineProperty(this.globals, "$doc", {
      get: () => this.fv.getDoc()
    });
    this.promiseTick = Promise.resolve();
    window.globals = this.globals;
  }
  run(cmds) {
    this.cmds.push(...cmds);
    this.promiseTick = this.promiseTick.then(() => this.tick());
  }
  async tick() {
    if (this.cmds.length == 0) {
      return;
    }
    const cmds = this.cmds.splice(0, this.cmds.length);
    for (let cmd of cmds) {
      try {
        let res = this.handleCmd(cmd);
        if (res instanceof ResolvablePromise) {
          res = await res;
        }
      } catch (e) {
        console.error("error running cmd", cmd, e);
        throw Error("error running cmd", { cause: e });
      }
    }
    requestAnimationFrame(() => this.tick());
  }
  handleCmd(cmd) {
    const [name, ...args] = cmd;
    switch (name) {
      case "get": {
        const [varRef, key] = args;
        return this.getValue(varRef)[key];
      }
      case "var": {
        const [name2, valueOrCmd] = args;
        this.globals[name2] = this.getValue(valueOrCmd);
        return;
      }
      case "call": {
        const [varRef, func2, ...params2] = args;
        const ref = this.getValue(varRef);
        return ref[func2](...params2.map(this.getValue));
      }
      case "list":
        return args.map(this.getValue);
      case "new": {
        const [name2, ...params2] = args;
        const clazz = this.globals[name2];
        return new clazz(...params2.map(this.getValue));
      }
      case "set": {
        const [varRef, key, valueOrCmd] = args;
        const ref = this.getValue(varRef);
        ref[key] = this.getValue(valueOrCmd);
        break;
      }
      case "fn": {
        const [params2, ...fnCmds] = args;
        return () => {
          fnCmds.forEach((cmd2) => this.handleCmd(cmd2));
        };
      }
      case "await": {
        const [varRef] = args;
        return this.getValue(varRef);
      }
      case "free": {
        const [varRef] = args;
        delete this.globals[varRef];
        break;
      }
      default:
        throw new Error("unknown cmd:" + cmd);
    }
  }
}
var FrameLoadState;
(function(FrameLoadState2) {
  FrameLoadState2[FrameLoadState2["INIT"] = 0] = "INIT";
  FrameLoadState2[FrameLoadState2["LOADING"] = 1] = "LOADING";
  FrameLoadState2[FrameLoadState2["LOADED"] = 2] = "LOADED";
  FrameLoadState2[FrameLoadState2["LOADED_DOCTYPE"] = 3] = "LOADED_DOCTYPE";
  FrameLoadState2[FrameLoadState2["LOADED_DOC"] = 4] = "LOADED_DOC";
})(FrameLoadState || (FrameLoadState = {}));
const MaxReportableErrors = 50;
class FrameView extends EventEmitter {
  constructor(store2, pageView) {
    super();
    this._altDown = null;
    this._localFrameLoadState = FrameLoadState.INIT;
    this._events = [];
    this._streamEvents = [];
    this._data = /* @__PURE__ */ new Map();
    this._scrollsSent = /* @__PURE__ */ new Set();
    this._scrollsReceived = /* @__PURE__ */ new Set();
    this._listenersActive = false;
    this._isDraggingBar = false;
    this._wheeling = false;
    this.clearWheeling = debounce(() => {
      this._wheeling = false;
    }, 2e3);
    this.syncScrollAfterWheeling = debounce((el) => this._dispatchEventScroll(el), 200);
    this.dispatchEventScroll = async (e) => {
      let target = e.target;
      if (target.nodeType == document.DOCUMENT_NODE) {
        target = target.documentElement;
      }
      this._scrollingElement = target;
      if (this._isDraggingBar) {
        await this._dispatchEventScroll(target);
      }
    };
    this.pageView = pageView;
    this.store = store2;
    this.onFrameLoad = this.onFrameLoad.bind(this);
    this.elMeta = this.createMetaElement();
    this.streamMap = /* @__PURE__ */ new Map();
    this.appliedDOMEvents = new AppliedDOMStreamEvents(15);
    this._maxErrors = MaxReportableErrors;
    this._listeners = {
      blur: () => this.onBlur(),
      mousedown: (e) => this.dispatchEvent(e, "mousedown", "button"),
      mouseup: (e) => this.dispatchEvent(e, "mouseup", "button"),
      mousemove: (e) => this.dispatchEventMousemove(e),
      keydown: (e) => this.dispatchEvent(e, "keydown", "code", "keyCode"),
      keyup: (e) => this.dispatchEvent(e, "keyup", "code", "keyCode"),
      wheel: (e) => this.dispatchEventWheel(e),
      change: (e) => this.dispatchEventChange(e),
      input: (e) => this.dispatchEventInput(e),
      scroll: (e) => this.dispatchEventScroll(e),
      click: (e) => {
        e.preventDefault();
        e.stopPropagation();
      }
    };
  }
  onBlur() {
    if (!!this._altDown) {
      this.trigger("keyup", {
        code: this._altDown,
        keyCode: 18
      }, this.getDoc().documentElement);
      this._altDown = null;
    }
  }
  addDocListeners() {
    const doc = this.getDoc();
    if (!doc) {
      console.error("FIXME trying to add listener for null document");
      return;
    }
    for (let name in this._listeners) {
      doc.addEventListener(name, this._listeners[name], true);
    }
    this._listenersActive = true;
  }
  appendHost() {
    this.getDoc().documentElement.appendChild(this.elMeta);
  }
  removeHost() {
    this.getDoc().documentElement.removeChild(this.elMeta);
  }
  createMetaElement() {
    if (!customElements.get("bbx-d")) {
      customElements.define("bbx-d", class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
      });
    } else {
      console.warn("a copy of @bbx/client has already been loaded; loading different versions can result in conflicts");
    }
    const elMeta = document.createElement("bbx-d");
    return elMeta;
  }
  createVM() {
    this._vm = new VM(this);
  }
  destroy() {
    if (this._localFrameLoadState == FrameLoadState.LOADING) {
      this.removeDocListners();
    }
    this.elMeta.remove();
    this.emit("destroy");
    this.reset();
  }
  _dispatchEventMousemove(el, x, y) {
    if (el != this._currentMouseTarget) {
      this.dispatchEventMouseover(el);
    }
    const offset = this.getFrameOffset();
    this.trigger("mousemove", {
      path: findPath(el),
      clientX: x + offset[0],
      clientY: y + offset[1],
      frameId: this.store.id
    }, el);
    this._currentMouseTarget = el;
  }
  dispatchEventMousemove(e) {
    const originalTarget = e.composedPath()[0];
    this._dispatchEventMousemove(originalTarget, e.clientX, e.clientY);
  }
  dispatchEventMousemove2(selector, x, y) {
    let doc = this.getDoc();
    let el = doc.querySelector(selector);
    this._dispatchEventMousemove(el, x, y);
  }
  getClientR(el) {
    if (el.nodeType != document.ELEMENT_NODE) {
      return null;
    }
    let bcr = el.getBoundingClientRect();
    let offset = this.frameOffSet(this.elFrame, this.store.parentId);
    return {
      top: bcr.top + offset.top,
      left: bcr.left + offset.left,
      bottom: bcr.bottom + offset.top,
      right: bcr.right + offset.left
    };
  }
  frameOffSet(el, parentId) {
    let mainFrameOffset = {
      top: 0,
      left: 0
    };
    let offset = this.pageView.elMainFrame == el ? mainFrameOffset : el.getBoundingClientRect();
    if (!parentId) {
      return offset;
    }
    let parentView = this.pageView.getFrame(parentId);
    let parentFrame = parentView.elFrame;
    parentId = parentView.store.parentId;
    return this.addRect(offset, this.frameOffSet(parentFrame, parentId));
  }
  addRect(a, b) {
    return {
      left: a.left + b.left,
      top: a.top + b.top
    };
  }
  dispatchEventMouseover(el) {
    this.trigger("syncsize", {
      path: findPath(el),
      rect: this.getClientR(el),
      frameId: this.store.id
    }, el);
  }
  dispatchEventChange(e) {
    let path;
    let value;
    let el = e.target;
    let name = "change";
    if (el.tagName == "INPUT") {
      let inputTarget = el;
      if (inputTarget.type == "date" || inputTarget.type == "text" || inputTarget.type == "password" || inputTarget.type == "email") {
        path = findPath(inputTarget);
        value = inputTarget.value;
      }
    } else if (el.tagName == "SELECT") {
      let selectTarget = el;
      path = findPath(selectTarget);
      value = selectTarget.value;
      name = "select";
    }
    this.trigger(name, {
      path,
      value,
      frameId: this.store.id
    }, el);
  }
  dispatchEventChange2(selector, value) {
    let doc = this.getDoc();
    let el = doc.querySelector(selector);
    this.trigger(el.tagName == "SELECT" ? "select" : "change", {
      path: findPath(el),
      value,
      frameId: this.store.id
    }, el);
  }
  dispatchEventInput(e) {
    let path;
    let value;
    let target = e.target;
    if (target.tagName == "INPUT") {
      path = findPath(target);
      value = target.value;
    }
    this.trigger("input", {
      path,
      value,
      frameId: this.store.id
    }, target);
  }
  async _dispatchEventScroll(el) {
    let event = {
      path: findPath(el),
      top: el.scrollTop,
      left: el.scrollLeft,
      frameId: this.store.id
    };
    const scrollEventStr = `${event.left}:${event.top}`;
    if (!this._scrollsReceived.has(scrollEventStr)) {
      let res = await this.trigger("scroll", event, el);
      if (!res.noop) {
        this._scrollsSent.add(`${res.scrollLeft}:${res.scrollTop}`);
      }
    } else {
      this._scrollsReceived.delete(scrollEventStr);
    }
  }
  dispatchEventScroll2(selector, left, top) {
    let el = this.getDoc().querySelector(selector);
    el.scrollTo(left, top);
    this._dispatchEventScroll(el);
  }
  dispatchEventWheel(e) {
    let scrollEvent = e;
    let target = e.target;
    const offset = this.getFrameOffset();
    if (target instanceof Document) {
      target = target.documentElement;
    }
    let event = {
      deltaX: scrollEvent.deltaX,
      deltaY: scrollEvent.deltaY,
      path: findPath(target),
      x: scrollEvent.x + offset[0],
      y: scrollEvent.y + offset[1],
      frameId: this.store.id
    };
    this.trigger("wheel", event, target);
    this._wheeling = true;
    this.clearWheeling();
    this.syncScrollAfterWheeling(this._scrollingElement);
  }
  dispatchEvent(e, name, ...keys) {
    if (keys.length == 0)
      console.log(name);
    if (name === "mousedown") {
      if (isClickingOnScrollbar(e)) {
        this._isDraggingBar = true;
        return;
      }
    } else if (name === "mouseup") {
      if (this._isDraggingBar) {
        this._isDraggingBar = false;
        return;
      }
    }
    let target = e.target;
    let originalTarget = e.composedPath()[0];
    if ((originalTarget == null ? void 0 : originalTarget.tagName) !== "SELECT" && name != "wheel") {
      e.preventDefault();
      e.stopPropagation();
    }
    let params2 = {};
    keys.forEach((key) => params2[key] = e[key]);
    params2.frameId = this.store.id;
    if (name == "keydown") {
      if (params2.code == "AltLeft" || params2.code == "AltRight") {
        this._altDown = params2.code;
      }
    }
    if (!((name == "keyup" || name == "keydown") && !params2.keyCode)) {
      this.trigger(name, params2, target);
    } else {
      console.error("Chrome bug!");
    }
  }
  getDoc() {
    return this.elFrame.contentDocument;
  }
  getMetaEl() {
    return this.elMeta;
  }
  getFrameOffset() {
    return this.pageView.getOffset(this.elFrame);
  }
  getNode(path) {
    return getNode(path, this.getDoc());
  }
  getState() {
    return this._localFrameLoadState;
  }
  isDocReady() {
    return this.getState() == FrameLoadState.LOADED_DOC;
  }
  on_change_attributes({ path, patch: patch2 }) {
    let el = getNode(path, this.getDoc());
    if (!patch2.ns) {
      if (patch2.value === null) {
        el.removeAttribute(patch2.name);
      } else {
        el.setAttribute(patch2.name, patch2.value);
      }
    } else {
      if (patch2.value === null) {
        el.removeAttributeNS(patch2.ns, patch2.name);
      } else {
        el.setAttributeNS(patch2.ns, patch2.name, patch2.value);
      }
    }
  }
  on_change_childlist({ path, patches }) {
    const canAffectHost = path.length == 1;
    canAffectHost && this.removeHost();
    try {
      applyPatch(this.getDoc(), path, patches);
    } finally {
      canAffectHost && this.appendHost();
    }
  }
  on_change_checked({ path, checked }) {
    let input = getNode(path, this.getDoc());
    input.checked = checked;
  }
  on_change_value({ path, value }) {
    let dateInput = getNode(path, this.getDoc());
    dateInput.value = value;
  }
  on_change_text({ path, patch: patch2 }) {
    let node2 = getNode(path, this.getDoc());
    node2.nodeValue = patch2;
  }
  on_bbx_debug({ value }) {
    value && console.log("ignored on_bbx_debug");
  }
  on_bbx_debug_default({ value }) {
    console.log("on_bbx_debug", new Date(), "start comparing HTML", this.store.id);
    let nodeFromServer = parseHTML(value);
    if (nodeFromServer.nodeType === Node.ELEMENT_NODE) {
      let elementFromServer = nodeFromServer;
      let elementFromClient = this.getDoc().documentElement.cloneNode(true);
      let styleElements = elementFromClient.querySelectorAll("style");
      for (let i2 = 0; i2 < styleElements.length; i2++) {
        styleElements[i2].textContent = "";
      }
      let metaElements = elementFromClient.querySelectorAll("meta");
      for (let i2 = 0; i2 < metaElements.length; i2++) {
        metaElements[i2].outerHTML = "<meta/>";
      }
      let bbxElements = elementFromClient.querySelectorAll("bbx-d");
      for (let i2 = 0; i2 < bbxElements.length; i2++) {
        bbxElements[i2].remove();
      }
      styleElements = elementFromServer.querySelectorAll("style");
      for (let i2 = 0; i2 < styleElements.length; i2++) {
        styleElements[i2].textContent = "";
      }
      metaElements = elementFromServer.querySelectorAll("meta");
      for (let i2 = 0; i2 < metaElements.length; i2++) {
        metaElements[i2].outerHTML = "<meta/>";
      }
      const isEqual = elementFromServer.isEqualNode(elementFromClient);
      if (!isEqual) {
        console.log("on_bbx_debug", new Date(), "end comparing HTML", this.store.id, "isEqual", isEqual, elementFromClient.outerHTML === elementFromServer.outerHTML);
        this.pageView.browserView.manager.emit("frame_content_mismatch", elementFromClient, elementFromServer);
      }
    } else {
      console.error("on_bbx_debug", "Invalid Node sent from server");
    }
  }
  on_content_cmds({ data: cmds }) {
    this._vm.run(cmds);
  }
  on_document({ value }) {
    this.setState(FrameLoadState.LOADED_DOC);
    const doc = this.getDoc();
    doc.documentElement.replaceWith(parseHTML(value, doc));
    this.appendHost();
    this._streamEvents.forEach(async (stream, _index) => {
      await this.addPeerToFrame(stream);
    });
    this._streamEvents = [];
    this.emit("document_ready", this);
    this.on_bbx_debug = this.on_bbx_debug_default;
  }
  on_document_start({ doctype }) {
    this._maxErrors = MaxReportableErrors;
    this.setState(FrameLoadState.LOADING);
    const baseURL = this.pageView.browserView.client.getBaseURL();
    const scriptConstructedStylesheet = `<script src="${baseURL}/static/frame.js"><\/script>`;
    const html2 = (doctype ? `<!doctype ${doctype}>` : "") + `<html><body>${scriptConstructedStylesheet}</body></html>`;
    this.elFrame.setAttribute("srcdoc", html2);
    this.appendHost();
    this.createVM();
  }
  on_shadow_root({ path }) {
    let el = getNode(path, this.getDoc());
    if (!el.shadowRoot) {
      el.attachShadow({ mode: "open" });
    }
  }
  on_text_patch({ path, diff: diff2 }) {
    let el = getNode(path, this.getDoc());
    let oldStr = el.nodeValue;
    let newStr = this.apply_text_patch(oldStr, diff2);
    el.nodeValue = newStr;
  }
  apply_text_patch(oldStr, diff2) {
    let result = "";
    let currentInd = 0;
    diff2.forEach((d) => {
      switch (d[0]) {
        case DiffOp.NOOP:
          let subStr = oldStr.slice(currentInd, currentInd + d[1]);
          result = result + subStr;
          currentInd = currentInd + d[1];
          break;
        case DiffOp.DEL:
          currentInd = currentInd + d[1];
          break;
        case DiffOp.INS:
          result = result + d[1];
          break;
      }
    });
    return result;
  }
  on_focus({ path }) {
    let el = getNode(path, this.getDoc());
    el.focus();
  }
  on_frame_src({ path, childFrameId }) {
    let childFrameView = this.pageView.getFrame(childFrameId);
    let iframe = getNode(path, this.getDoc());
    if (!iframe || !iframe.nodeName.endsWith("FRAME")) {
      console.error("on_frame_src", path, childFrameId, iframe);
      throw new Error("on_frame_src: mismatched path to iframe");
    }
    if (childFrameView)
      childFrameView.setIFrame(iframe);
  }
  on_input({ path, value }) {
    let el = getNode(path, this.getDoc());
    el.value = value;
  }
  on_navigated({ url }) {
    this.url = url;
  }
  on_select_input({ path, start, end }) {
    let el = getNode(path, this.getDoc());
    if (!el.type || el.type == "text" || el.type == "search" || el.type == "url" || el.type == "tel" || el.type == "password") {
      el.setSelectionRange(start, end);
    }
  }
  on_select_range({ ranges }) {
    const doc = this.getDoc();
    const s = doc.getSelection();
    s.empty();
    ranges.forEach((rangeObj) => {
      let range = doc.createRange();
      let { start, end } = rangeObj;
      range.setStart(getNode(start[0], doc), start[1]);
      range.setEnd(getNode(end[0], doc), end[1]);
      s.addRange(range);
    });
  }
  on_scroll(event) {
    if (this._wheeling) {
      return;
    }
    let path = event.path;
    let el = getNode(path, this.getDoc());
    let left = event.left;
    let top = event.top;
    const scrollEventStr = `${left}:${top}`;
    if (!this._scrollsSent.has(scrollEventStr)) {
      let oldCords = { scrollTop: el.scrollTop, scrollLeft: el.scrollLeft };
      el.scrollTo(left, top);
      let newCords = { scrollTop: el.scrollTop, scrollLeft: el.scrollLeft };
      if (this._listenersActive && (oldCords.scrollTop != newCords.scrollTop || oldCords.scrollLeft != newCords.scrollLeft)) {
        this._scrollsReceived.add(`${el.scrollLeft}:${el.scrollTop}`);
      }
    } else {
      this._scrollsSent.delete(scrollEventStr);
    }
  }
  onDOMEvent(domStreamEvent) {
    if (domStreamEvent.name != "navigated" && !this._isReadyForEvents(domStreamEvent.name)) {
      this._events.push({ ...domStreamEvent });
      return;
    }
    domStreamEvent.name = domStreamEvent.name.replace(/:/g, "_");
    let method = `on_${domStreamEvent.name}`;
    let startTime = new Date();
    if (this[method]) {
      try {
        this[method](domStreamEvent);
      } catch (e) {
        console.warn(`error while processing the DOMEvent ${domStreamEvent.name}`, this.store.id, domStreamEvent, e);
        const domEventError = new DOMEventError(e, method, this.url, this.store.isMain());
        domEventError.setPreviousEvents(this.appliedDOMEvents);
        this.sendError(domEventError);
        this.appliedDOMEvents.push(domStreamEvent, startTime, e);
      }
      this.appliedDOMEvents.push(domStreamEvent, startTime);
      this.emit(domStreamEvent.name, domStreamEvent, this);
      this.emit("bbx", domStreamEvent.name, domStreamEvent, this);
    } else {
      console.warn("TODO: unhandled event:", this.store.id, domStreamEvent.name, domStreamEvent);
    }
  }
  async onWEBRTCEvent(peerId, event) {
    if (event.name === SignalEvent.STREAM_VIDEO) {
      await this.addPeerToFrame(event);
      return;
    }
    await this.webrtcClient.onWEBRTCEvent(peerId, event);
  }
  async addPeerToFrame(event) {
    if (event.name === SignalEvent.STREAM_VIDEO) {
      if (this.webrtcClient) {
        this.webrtcClient.close();
        this.webrtcClient = void 0;
      }
      if (this._isReadyForStreaming()) {
        this.webrtcClient = new WebrtcClient(Math.random().toString(36), this);
        this.webrtcClient.connect();
      } else {
        this._streamEvents.push(event);
      }
    }
  }
  _isReadyForEvents(name) {
    if (name == "document_start") {
      return this._localFrameLoadState >= FrameLoadState.LOADED;
    } else {
      return this._localFrameLoadState >= FrameLoadState.LOADED_DOCTYPE;
    }
  }
  _isReadyForStreaming() {
    return this._localFrameLoadState >= FrameLoadState.LOADED_DOC;
  }
  onFrameLoad() {
    this.setState(FrameLoadState.LOADED);
    this.elFrame.removeEventListener("load", this.onFrameLoad);
    this.elFrame.addEventListener("load", () => this.onFrameLoadDoctype());
    this.appendHost();
    let eDocStart = this._events.find((e) => e.name == "document_start");
    if (eDocStart) {
      let index2 = this._events.indexOf(eDocStart);
      this._events = this._events.slice(index2 + 1);
      this.onDOMEvent(eDocStart);
    }
  }
  onFrameLoadDoctype() {
    this.setState(FrameLoadState.LOADED_DOCTYPE);
    let pendingEvents = this._events;
    this._events = [];
    let eDoc = pendingEvents.find((e) => e.name == "document");
    if (eDoc) {
      let index2 = pendingEvents.indexOf(eDoc);
      pendingEvents = pendingEvents.slice(index2);
    }
    pendingEvents.forEach((e) => this.onDOMEvent(e));
    this.removeDocListners();
    !this._paused && this.addDocListeners();
    this.appendHost();
    this.emit("ready", this);
  }
  pause() {
    this._paused = true;
    if (this._localFrameLoadState >= FrameLoadState.LOADED_DOCTYPE) {
      this.removeDocListners();
    }
  }
  resume() {
    this._paused = false;
    if (this._localFrameLoadState >= FrameLoadState.LOADED_DOCTYPE) {
      this.addDocListeners();
    }
  }
  removeDocListners() {
    const doc = this.getDoc();
    if (!doc) {
      console.error("FIXME trying to remove listener for null document");
      return;
    }
    for (let name in this._listeners) {
      doc.removeEventListener(name, this._listeners[name], true);
    }
    this._listenersActive = false;
  }
  setState(state) {
    this._localFrameLoadState = state;
  }
  setIFrame(iframe) {
    this.elFrame = iframe;
    if (iframe.contentDocument) {
      this.onFrameLoad();
    } else {
      this.elFrame.addEventListener("load", this.onFrameLoad);
    }
  }
  trigger(name, params2, target) {
    let res = this.pageView.store.trigger(name, params2);
    this.emit("trigger", name, params2, target, this);
    return res;
  }
  triggerSignallingServer(name, params2) {
    this.pageView.store.browser.call("signalEvent", this.pageView.store.id, name, params2);
  }
  delData(key) {
    return this._data.delete(key);
  }
  getData(key) {
    return this._data.get(key);
  }
  setData(key, value) {
    return this._data.set(key, value);
  }
  sendError(e) {
    this._maxErrors--;
    if (this._maxErrors > 0) {
      this.pageView.sendError(e);
    } else {
      console.warn("error limit exceeded, max limit is configured to:", MaxReportableErrors, e);
    }
  }
}
class PageView extends EventEmitter {
  constructor(store2, browserView) {
    super();
    this.frameViews = /* @__PURE__ */ new Map();
    this.overlays = [];
    this.store = store2;
    this.browserView = browserView;
    this.onFrameAdded = this.onFrameAdded.bind(this);
    this.onFrameDetached = this.onFrameDetached.bind(this);
    this.addListeners();
    this.mainFrameView = this.onFrameAdded(this.store.mainFrame);
    this.store.frames.slice(1).forEach((frame) => this.onFrameAdded(frame));
    this.elMainFrame = document.createElement("iframe");
    this.elMainFrame.setAttribute("frameborder", "0");
    this.mainFrameView.setIFrame(this.elMainFrame);
  }
  addListeners() {
    this.store.on("frameadded", this.onFrameAdded);
    this.store.on("framedetached", this.onFrameDetached);
  }
  addOverlay(overlay) {
    this.overlays.push(overlay);
    for (let fv of this.frameViews.values()) {
      overlay.onFrameInit(fv);
    }
  }
  removeOverlay(overlay) {
    let index2 = this.overlays.indexOf(overlay);
    this.overlays.splice(index2, 1);
    for (let fv of this.frameViews.values()) {
      overlay.onFrameUninit(fv);
    }
  }
  destroy() {
    let fvs = [...this.frameViews.values()];
    for (let fv of fvs) {
      this.onFrameDetached(fv.store);
    }
    this.elMainFrame.remove();
    this.store.off("frameadded", this.onFrameAdded);
    this.store.off("framedetached", this.onFrameDetached);
  }
  getOffset(el) {
    if (el == this.elMainFrame) {
      return [0, 0];
    }
    let rect = el.getBoundingClientRect();
    const offset = [rect.left, rect.top];
    const elWin = el.ownerDocument.defaultView;
    const parentOffset = this.getOffset(elWin.frameElement);
    return [offset[0] + parentOffset[0], offset[1] + parentOffset[1]];
  }
  getFrame(frameId) {
    return this.frameViews.get(frameId);
  }
  onDOMEvent(frameId, event) {
    let frameView = this.getFrame(frameId);
    frameView.onDOMEvent(event);
  }
  async onWEBRTCEvent(frameId, peerId, event) {
    await this.getFrame(frameId).onWEBRTCEvent(peerId, event);
  }
  onFrameAdded(frame) {
    const fv = new FrameView(frame, this);
    this.frameViews.set(frame.id, fv);
    this.overlays.forEach((o) => o.onFrameInit(fv));
    this.emit("frameadded", fv);
    return fv;
  }
  onFrameDetached(frame) {
    let fv = this.frameViews.get(frame.id);
    if (fv) {
      for (let overlay of this.overlays) {
        overlay.onFrameUninit(fv);
      }
      fv.destroy();
      this.frameViews.delete(frame.id);
      this.emit("framedetached", fv);
    }
  }
  pause() {
    for (const fv of this.frameViews.values()) {
      fv.pause();
    }
  }
  resume() {
    for (const fv of this.frameViews.values()) {
      fv.resume();
    }
  }
  render() {
    return this.elMainFrame;
  }
  sendError(e) {
    this.browserView.sendError(e);
  }
}
class BrowserView extends EventEmitter {
  constructor(options) {
    super();
    this.overlays = [];
    this.pageViews = /* @__PURE__ */ new Map();
    Object.assign(this, options);
    this.manager.addDOMStreamListener(this);
    this.manager.addWEBRTCStreamListener(this);
    this.addListeners();
  }
  async addListeners() {
    if (!this.manager.browser) {
      await this.manager.waitForEvent("ready");
    }
    this.store = this.manager.browser;
    this.client = this.manager.apiClient;
    this.store.on("pageadded", (e) => this.onPageAdded(e));
    this.store.on("pagedeleted", (e) => this.onPageDeleted(e));
    this.store.pages.forEach((page) => this.onPageAdded(page));
    this.resizeObserver = new ResizeObserver((_2) => {
      this.syncSize();
    });
    this.resizeObserver.observe(this.container);
  }
  addPageOverlay(overlay) {
    this.overlays.push(overlay);
    for (let pv of this.pageViews.values()) {
      pv.addOverlay(overlay);
    }
  }
  getPage(id2) {
    if (typeof id2 == "number") {
      let size = this.pageViews.size;
      let index2 = id2;
      if (index2 < 0) {
        index2 += size;
      }
      if (index2 >= size) {
        throw new Error("Page index out of bounds: " + index2);
      }
      let pages = this.pageViews.values();
      let i2 = 0;
      for (let page of pages) {
        if (i2 == index2) {
          return page;
        }
        i2 += 1;
      }
      throw new Error("(unreachable code) Page not found: " + id2);
    } else {
      return this.pageViews.get(id2);
    }
  }
  onDOMEvent(pageId, frameId, event) {
    this.getPage(pageId).onDOMEvent(frameId, event);
  }
  async onWEBRTCEvent(pageId, frameId, peerId, event) {
    await this.getPage(pageId).onWEBRTCEvent(frameId, peerId, event);
  }
  onPageAdded(page) {
    let pageView = new PageView(page, this);
    this.pageViews.set(page.id, pageView);
    this.overlays.forEach((o) => pageView.addOverlay(o));
    let el = pageView.render();
    this.setPageElStyle(el);
    this.container.appendChild(el);
    this.emit("pageadded", pageView);
  }
  onPageDeleted(page) {
    let pageView = this.getPage(page.id);
    pageView.destroy();
    this.pageViews.delete(page.id);
    this.emit("pagedeleted", pageView);
  }
  setPageElStyle(el) {
    Object.assign(el.style, {
      position: "absolute",
      height: "100%",
      width: "100%",
      backgroundColor: "#fff"
    });
  }
  getNode(pageId, frameId, path) {
    return this.getPage(pageId).getFrame(frameId).getNode(path);
  }
  async syncSize() {
    let r = this.container.getBoundingClientRect();
    await this.store.call("setViewport", {
      width: Math.trunc(r.width),
      height: Math.trunc(r.height)
    });
  }
  sendError(e) {
    this.client.sendError(e);
  }
  close() {
    this.resizeObserver.unobserve(this.container);
    this.client.close();
  }
}
function isClickingOnScrollbar(e) {
  const el = e.target;
  const rect = el.getBoundingClientRect();
  const doc = el.ownerDocument;
  const isRoot = el === doc.documentElement || el === doc.body;
  const x = e.clientX - (isRoot ? 0 : rect.left);
  const y = e.clientY - (isRoot ? 0 : rect.top);
  const inVerticalScrollbarRange = x >= el.clientWidth && (isRoot || x <= el.offsetWidth);
  const inHorizontalScrollbarRange = y >= el.clientHeight && (isRoot || y <= el.offsetHeight);
  const inScrollbarV = el.scrollHeight > el.clientHeight && y < el.offsetHeight && inVerticalScrollbarRange;
  const inScrollbarH = el.scrollWidth > el.clientWidth && x < el.offsetWidth && inHorizontalScrollbarRange;
  return inScrollbarV || inScrollbarH;
}
class PageOverlayBase extends EventEmitter {
  constructor() {
    super(...arguments);
    this._views = /* @__PURE__ */ new Map();
  }
  onFrameInit(fv) {
    let el = this.createEl(fv);
    if (el) {
      el.dataset.name = this.constructor.name;
      this._views.set(fv.store.id, el);
      fv.elMeta.shadowRoot.appendChild(el);
      this.afterViewCreated(fv, el);
    }
    this.afterInit(fv, el);
  }
  onFrameUninit(fv) {
    this.afterUninit(fv);
    this.removeEl(fv);
  }
  afterViewCreated(fv, el) {
  }
  createEl(fv) {
    return document.createElement("div");
  }
  getEl(fv) {
    return this._views.get(fv.store.id);
  }
  removeEl(fv) {
    let el = this.getEl(fv);
    el.parentNode.removeChild(el);
    this._views.delete(fv.store.id);
  }
}
async function createView({ key, host, basePath, container }) {
  let apiClient = connect({
    key,
    host,
    basePath,
    features: [Feature.command, Feature.state, Feature.stream_dom, Feature.stream_video]
  });
  let manager = new StoreManager(apiClient);
  await manager.waitForEvent("ready");
  await manager.browser.call("setContentConfig", "stream_dom", true);
  let view = new BrowserView({
    manager,
    container
  });
  view.syncSize();
  return view;
}
const KEY_FV_DATA$1 = "bbx:fr:overlay";
class PageOverlay extends PageOverlayBase {
  constructor(page, options = {}) {
    super();
    this.active = false;
    this.onFrameNavigated = (_event, fv) => {
      this.removeFrameOverlay(fv);
    };
    this.onFrameReady = (_event, fv) => {
      let oldOverlay = fv.getData(KEY_FV_DATA$1);
      if (oldOverlay) {
        this.removeFrameOverlay(fv);
      }
      let frameOverlay = this.createFrameOverlay(fv, this.getEl(fv));
      fv.setData(KEY_FV_DATA$1, frameOverlay);
    };
    this.page = page;
    this.options = options;
  }
  afterInit(fv) {
    fv.on("document", this.onFrameReady);
    fv.on("navigated", this.onFrameNavigated);
    if (fv.isDocReady()) {
      this.onFrameReady(null, fv);
    }
  }
  afterViewCreated(fv) {
    let { stylesheet } = this.options;
    let root = fv.getMetaEl().shadowRoot;
    if (root && stylesheet) {
      let link = document.createElement("link");
      link.setAttribute("rel", "stylesheet");
      link.setAttribute("href", stylesheet);
      root.appendChild(link);
    }
  }
  afterUninit(fv) {
    fv.off("document_ready", this.onFrameReady);
    this.removeFrameOverlay(fv);
  }
  removeFrameOverlay(fv) {
    let frameOverlay = fv.getData(KEY_FV_DATA$1);
    if (frameOverlay) {
      frameOverlay.uninit();
      fv.delData(KEY_FV_DATA$1);
    }
  }
  setActive(active) {
    if (active !== this.active) {
      this.active = active;
      active ? this.page.addOverlay(this) : this.page.removeOverlay(this);
    }
  }
}
function getPath(child, root = child.ownerDocument.documentElement, pathArr = []) {
  let parent2 = child.parentElement;
  if (parent2 === null || root == child) {
    pathArr.reverse();
    return pathArr;
  }
  let childList = parent2.childNodes;
  let index2 = 0;
  for (let i2 = 0; i2 < childList.length; ++i2) {
    if (childList[i2] === child) {
      index2 = i2;
      break;
    }
  }
  pathArr.push(index2);
  return getPath(parent2, root, pathArr);
}
function isAfter(lPath, rPath) {
  let lLen = lPath.length, rLen = rPath.length;
  for (let x = 0, len = Math.min(lLen, rLen); x < len; x += 1) {
    let lI = lPath[x];
    let rI = rPath[x];
    if (lI == rI) {
      continue;
    }
    return lI > rI;
  }
  return lLen > rLen;
}
class TargetBase extends EventEmitter {
  constructor(el) {
    super();
    this._path = null;
    this.el = el;
    this.addListeners();
  }
  addListeners() {
    let io = new IntersectionObserver((_entries) => {
      this.emit("change");
    });
    io.observe(this.el);
    if (typeof ResizeObserver != "undefined") {
      let ro = new ResizeObserver((_entries) => {
        this.emit("change");
      });
      ro.observe(this.el);
    }
  }
  create(_overlay) {
  }
  destroy(_overlay) {
  }
  get() {
    return this.el;
  }
  _getPath() {
    if (!this._path) {
      this._path = getPath(this.el);
    }
    return this._path;
  }
  isAfter(rTarget) {
    return isAfter(this._getPath(), rTarget._getPath());
  }
  setActive(_active) {
  }
  setEl(el) {
    this.el = el;
    this.emit("change");
  }
  update(_rect, _overlay) {
  }
}
class FrameOverlayBase extends EventEmitter {
  constructor(fv, el) {
    super();
    this.hoverTarget = null;
    this._qRender = true;
    this._lastAnimId = 0;
    this.isTouchMoved = false;
    this.fv = fv;
    this.doc = fv.getDoc();
    fv.pause();
    let win = this.doc.defaultView;
    if (win == null) {
      throw new Error("Invalid state - window not found");
    }
    this.win = win;
    this.el = el;
    this.targets = [];
    this.listeners = this.createListeners();
    this.render = this.render.bind(this);
    this.init().then();
  }
  isMeta(el) {
    let meta = this.fv.getMetaEl();
    return meta == el || meta.contains(el);
  }
  createListeners() {
    let win = this.win;
    if (win == null) {
      throw new Error("Unknown window");
    }
    return {
      click: (e) => this._onClick(e),
      touchstart: (e) => this._onTouchStart(e),
      touchmove: (e) => this._onTouchMove(e),
      touchend: (e) => this._onTouchEnd(e),
      pointerdown: (e) => this._onMouseDown(e),
      pointerover: (e) => this._onMouseOver(e),
      pointerout: (e) => this._onMouseOut(e),
      pointerup: (e) => this._onMouseUp(e),
      resize: [win, (e) => this._onResize(e)],
      scroll: [win, (e) => this._onScroll(e)]
    };
  }
  addListeners() {
    let doc = this.fv.getDoc();
    for (let name in this.listeners) {
      let listenerData = this.listeners[name];
      if (typeof listenerData == "function") {
        doc.addEventListener(name, listenerData, true);
      } else {
        listenerData[0].addEventListener(name, listenerData[1], true);
      }
    }
  }
  removeListeners() {
    let doc = this.fv.getDoc();
    for (let name in this.listeners) {
      let listenerData = this.listeners[name];
      if (typeof listenerData == "function") {
        doc.removeEventListener(name, listenerData, true);
      } else {
        listenerData[0].removeEventListener(name, listenerData[1], true);
      }
    }
  }
  async init() {
    this.addListeners();
  }
  uninit() {
    this.fv.resume();
    this.removeListeners();
  }
  _onClick(e) {
    if (this.isMeta(e.target))
      return;
    e.preventDefault();
    e.stopPropagation();
  }
  _onTouchStart(e) {
    if (this.isMeta(e.target))
      return;
    e.preventDefault();
    e.stopPropagation();
    this.isTouchMoved = false;
  }
  _onTouchMove(e) {
    if (this.isMeta(e.target))
      return;
    e.preventDefault();
    e.stopPropagation();
    this.isTouchMoved = true;
  }
  _onTouchEnd(e) {
    if (this.isMeta(e.target))
      return;
    e.preventDefault();
    e.stopPropagation();
    if (!this.isTouchMoved) {
      this.onClick(e.target, this._getEventData(e.target));
    }
  }
  _onMouseDown(e) {
    if (this.isMeta(e.target))
      return;
    e.preventDefault();
    e.stopPropagation();
    this.setHoverTarget(null);
    let el = e.target;
    if (e.pageX >= el.getBoundingClientRect().right)
      return;
    this.onClick(el, this._getEventData(el));
  }
  _onMouseOver(e) {
    if (this.isMeta(e.target))
      return;
    let el = e.target;
    this.onHover(el, this._getEventData(el));
  }
  _onMouseOut(e) {
    if (this.isMeta(e.target))
      return;
    if (e.relatedTarget == null) {
      this.setHoverTarget(null);
    }
  }
  _onMouseUp(e) {
    if (this.isMeta(e.target))
      return;
  }
  _onResize(_2) {
    this.render();
  }
  _onScroll(_2) {
    this.render();
  }
  _getEventData(el) {
    let parents = [];
    let children = [];
    let target;
    for (let aTarget of this.targets) {
      let anEl = aTarget.get();
      if (anEl == el) {
        target = aTarget;
      } else if (anEl.contains(el)) {
        parents.push(aTarget);
      } else if (el.contains(anEl)) {
        children.push(aTarget);
      }
    }
    if (!target && parents.length > 0) {
      target = parents[parents.length - 1];
    }
    return {
      target,
      parents,
      children
    };
  }
  setHoverTarget(target, meta = {}) {
    if (target == null) {
      this.hoverTarget = null;
    } else {
      this.hoverTarget = [target, meta];
    }
    this.render();
  }
  addTarget(target) {
    let targets = this.targets;
    let insertAt = 0;
    for (let i2 = 0, len = targets.length; i2 < len; i2 += 1) {
      let aTarget = targets[i2];
      if (aTarget.isAfter(target)) {
        insertAt = i2;
        break;
      }
    }
    this.targets.splice(insertAt, 0, target);
    target.create(this);
    this.render();
    target.on("change", this.render);
  }
  clearTargets() {
    this.targets.forEach((t) => t.destroy(this));
    this.targets = [];
    this.reset();
  }
  removeTarget(target) {
    target.destroy(this);
    this.targets = this.targets.filter((t) => t !== target);
    this.render();
  }
  removeTargetBy(fn) {
    this.targets = this.targets.filter((target) => !fn(target));
    this.render();
  }
  render() {
    if (this._qRender) {
      cancelAnimationFrame(this._lastAnimId);
      this._lastAnimId = requestAnimationFrame(() => {
        this._qRender = false;
        this.render();
      });
      return;
    }
    this.reset();
    this.targets.forEach((target) => {
      this.renderTarget(target);
    });
    if (this.hoverTarget) {
      this.renderHoverTarget(...this.hoverTarget);
    }
    this._qRender = true;
  }
}
function getRect(el) {
  let { x, y, width, height } = el.getBoundingClientRect();
  if (width == 0 && height == 0) {
    let { previousElementSibling, parentElement } = el;
    if (previousElementSibling) {
      let r2 = getRect(previousElementSibling);
      x = r2.x;
      y = r2.y + r2.height;
      width = r2.width;
    } else if (parentElement) {
      let r2 = getRect(parentElement);
      x = r2.x;
      y = r2.y;
      width = r2.width;
    }
  }
  return { x, y, width, height };
}
class CanvasFrameOverlay extends FrameOverlayBase {
  constructor(fv, el) {
    super(fv, el);
    this.canvas = this.createCanvas(fv.getDoc());
    let ctx = this.canvas.getContext("2d");
    if (ctx == null)
      throw new Error("Invalid state - context is null");
    this.ctx = ctx;
    el.appendChild(this.canvas);
  }
  createCanvas(doc) {
    let canvas = doc.createElement("canvas");
    Object.assign(canvas.style, this.getCanvasStyles());
    return canvas;
  }
  renderHoverTarget(target, meta) {
    let { ctx } = this;
    let { x, y, width, height } = getRect(target);
    let x1 = x + 0.5;
    let y1 = y + 0.5;
    let x2 = x + width - 0.5;
    let y2 = y + height - 0.5;
    let hoverStyles = this.getHoverStyles(target, meta);
    ctx.fillStyle = hoverStyles.fillStyle;
    ctx.fillRect(x, y, width, height);
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    ctx.strokeStyle = hoverStyles.strokeStyle;
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y1);
    ctx.moveTo(x1, y2);
    ctx.lineTo(x2, y2);
    ctx.moveTo(x1, y1);
    ctx.lineTo(x1, y2);
    ctx.moveTo(x2, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.closePath();
    ctx.setLineDash([]);
  }
  renderTarget(target) {
    let rect = getRect(target.get());
    let { ctx } = this;
    let styles = this.getTargetStyles(target);
    Object.assign(ctx, styles);
    ctx.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.width - 0.5, rect.height - 0.5);
    if (styles.fillStyle) {
      ctx.fillStyle = styles.fillStyle;
      ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
    }
    target.update(rect, this);
  }
  reset() {
    this.resetCanvasSize();
    let { ctx } = this;
    ctx.clearRect(0, 0, this.win.innerWidth, this.win.innerHeight);
    Object.assign(ctx, this.getOverlayStyles());
    ctx.fillRect(0, 0, this.win.innerWidth, this.win.innerHeight);
    this.targets.forEach((target) => {
      let rect = getRect(target.get());
      ctx.clearRect(rect.x + 0.5, rect.y + 0.5, rect.width - 0.5, rect.height - 0.5);
    });
  }
  getCanvasStyles() {
    return {
      pointerEvents: "none",
      position: "fixed",
      left: 0,
      top: 0,
      width: "100vw",
      height: "100vh",
      zIndex: 999999
    };
  }
  getHoverStyles(_target, _meta) {
    return {
      fillStyle: "rgba(0, 100, 255, .1)",
      strokeStyle: "rgba(0, 0, 250, .5)",
      lineWidth: 1
    };
  }
  getOverlayStyles() {
    return {
      fillStyle: "rgba(0, 0, 0, .2)"
    };
  }
  getTargetStyles(_target) {
    return {
      strokeStyle: "rgba(40, 120, 220, 1)",
      lineWidth: 1
    };
  }
  resetCanvasSize() {
    this.canvas.setAttribute("width", this.win.innerWidth + "");
    this.canvas.setAttribute("height", this.win.innerHeight + "");
  }
  uninit() {
    super.uninit();
    this.canvas.remove();
  }
}
class BrowserListener extends EventEmitter {
  constructor(view) {
    super();
    this.view = view;
    this.mgr = view.manager;
    [
      "onAction",
      "onEffect",
      "onFrameAdded",
      "onFrameDetached",
      "onPageAdded",
      "onPageDeleted"
    ].forEach((name) => this[name] = this[name].bind(this));
  }
  onFrameAdded(fv) {
    fv.on("bbx", this.onEffect);
    fv.on("trigger", this.onAction);
  }
  onFrameDetached(fv) {
    fv.off("bbx", this.onEffect);
    fv.off("trigger", this.onAction);
  }
  onPageAdded(pv) {
    pv.on("frameadded", this.onFrameAdded);
    pv.on("framedetached", this.onFrameDetached);
    pv.frameViews.forEach(this.onFrameAdded);
  }
  onPageDeleted(pv) {
    pv.off("frameadded", this.onFrameAdded);
    pv.off("framedetached", this.onFrameDetached);
    pv.frameViews.forEach(this.onFrameDetached);
  }
  start() {
    this.view.on("pageadded", this.onPageAdded);
    this.view.on("pagedeleted", this.onPageDeleted);
    this.view.pageViews.forEach(this.onPageAdded);
  }
  stop() {
    this.view.off("pageadded", this.onPageAdded);
    this.view.off("pagedeleted", this.onPageDeleted);
    this.view.pageViews.forEach(this.onPageDeleted);
  }
}
function getFrameView(view, frameLocator) {
  let pageId = -1, frameId = 0;
  if (frameLocator) {
    if (typeof frameLocator === "number") {
      frameId = frameLocator;
    } else {
      if (frameLocator.page) {
        pageId = frameLocator.page;
      }
      if (frameLocator.hasOwnProperty("index") && typeof frameLocator.index === "number") {
        frameId = frameLocator.index;
      }
    }
  }
  let pageView = view.getPage(pageId);
  let page = pageView.store;
  let frame = page.frames[frameId];
  return pageView.getFrame(frame.id);
}
function getPageView(view, pageLocator) {
  return view.getPage(pageLocator || -1);
}
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const keyCodeMap = {
  "Enter": 13,
  "Backspace": 8
};
function isSameSelector(selectorStruct, selector) {
  let value = selectorStruct.get("value");
  return value instanceof Literal$1 && value.returnType === "string" && value.value === selector;
}
class BrowserWrapper {
  constructor(browserView) {
    this.browserView = browserView;
  }
  async click(selector, _pos, opts) {
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    await frameView.store.call("click", selector.value);
  }
  async waitForDoc(opts) {
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    await frameView.waitForEvent("document");
    await wait(2e3);
  }
  async select(selector, value, opts) {
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    await frameView.store.call("select", selector.value, value);
  }
  async keypress(code, count2, opts) {
    let pageView = getPageView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.page);
    let page = pageView.store;
    let data = {
      code,
      count: count2,
      keyCode: keyCodeMap[code]
    };
    await page.trigger("keypress", data);
  }
  async mousemove(selector, pos, opts) {
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    frameView.dispatchEventMousemove2(selector.value, pos.x, pos.y);
  }
  async drag(selector, pos, targetSelector, targetPos, opts) {
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    let page = frameView.pageView.store;
    frameView.dispatchEventMousemove2(selector.value, pos.x, pos.y);
    await wait(100);
    await page.call("mousedown");
    await wait(100);
    frameView.dispatchEventMousemove2(targetSelector.value, targetPos.x, targetPos.y);
    await wait(100);
    await page.call("mouseup");
  }
  async focus(selector, opts) {
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    await frameView.store.call("focus", selector.value);
  }
  async type(selector, value, opts) {
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    await frameView.store.call("type", selector.value, value);
  }
  async scroll(selector, left, top, opts) {
    var _a;
    let timeout = ((_a = opts === null || opts === void 0 ? void 0 : opts.timeout) !== null && _a !== void 0 ? _a : 30) * 1e3;
    let startTime = Date.now();
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    let el = await this.waitAndGetElement({ selector }, frameView.getDoc(), opts);
    let scrollDiff = Math.max(top - el.scrollTop, left - el.scrollLeft);
    while (scrollDiff > 10 && Date.now() - startTime < timeout) {
      frameView.dispatchEventScroll2(selector.value, left, top);
      await wait(1e3);
      scrollDiff = Math.max(top - el.scrollTop, left - el.scrollLeft);
    }
  }
  async open(url, opts) {
    let pageView = getPageView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.page);
    await pageView.store.goto(url);
  }
  async getElementsCount(selector, opts) {
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    let els = frameView.getDoc().querySelectorAll(selector.value);
    return els.length;
  }
  async getElementText(selector, opts) {
    let frameView = getFrameView(this.browserView, opts === null || opts === void 0 ? void 0 : opts.frame);
    let el = await this.waitAndGetElement({ selector }, frameView.getDoc());
    return (el === null || el === void 0 ? void 0 : el.textContent) || "";
  }
  async waitAndGetElement({ selector }, doc, options) {
    var _a;
    let cutoffTime = Date.now() + ((_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : 30) * 1e3;
    while (cutoffTime > Date.now()) {
      const el = doc.querySelector(selector.value);
      if (el) {
        return el;
      }
      await wait(500);
    }
    throw new Error(`timed out waiting for element ${selector.value}`);
  }
}
let textInputTypes = ["color", "date", "datetime-local", "email", "file", "image", "month", "number", "password", "search", "tel", "text", "time", "url", "week"];
class Base extends BrowserListener {
  get registry() {
    return this.statementList.registry;
  }
  get steps() {
    return this.statementList.nodes;
  }
  constructor(view, find, statementList) {
    super(view);
    this._latestMousePosition = { x: 0, y: 0 };
    this._mouseActionBuffer = [];
    this.find = find;
    this.statementList = statementList;
  }
  _addMouseAction(type, selector, position, opts = {}) {
    if (type === "move")
      ;
    else if (type === "down") {
      this._mouseActionBuffer = [];
      this._mouseActionBuffer.push([type, selector, position, opts]);
    } else if (type === "up") {
      if (this._mouseActionBuffer.length === 0)
        return;
      let [startType, startSelector, startPosition, startOpts] = this._mouseActionBuffer.pop();
      this._mouseActionBuffer = [];
      if (startType !== "down" || startOpts.frame !== opts.frame)
        return;
      if (startSelector.value === selector.value && Math.abs(startPosition.x - position.x) <= 3 && Math.abs(startPosition.y - position.y) <= 3) {
        this._recordStep(["click", ["selector", selector.toJSON()], { ...startPosition }, opts]);
      } else {
        this._recordStep(["drag", ["selector", selector.toJSON()], { ...startPosition }, ["selector", selector.toJSON()], { ...position }, opts]);
      }
    }
  }
  _getTargetPos(el, { clientX, clientY }) {
    let elRect = el.getBoundingClientRect();
    let x = clientX - elRect.left;
    let y = clientY - elRect.top;
    return { x, y };
  }
  async onAction(name, params2, target, fv) {
    if (name == "select") {
      let selector2 = await this.find(target);
      this._recordStep(["select", ["selector", selector2.toJSON()], params2.value, { frame: fv.store.getIndex() }]);
      return;
    }
    let isKey = name.startsWith("key");
    let isMouse = name.startsWith("mouse");
    let selector = await this.find(target);
    this.lastEl = target;
    this.lastElSelector = selector;
    if (isKey) {
      let lastEl = this.lastEl;
      let lastAction = this.steps[this.steps.length - 1];
      let { code } = params2;
      if (name == "keydown" && (code == "Enter" || code == "Backspace")) {
        if (lastEl == this.lastEl && lastAction instanceof FunctionCall$1 && lastAction.name === "keypress" && lastAction.subtrees[0] instanceof Literal$1 && lastAction.subtrees[0].value === code && lastAction.subtrees[1] instanceof Literal$1 && lastAction.subtrees[1].returnType === "number") {
          lastAction.subtrees[1].value = lastAction.subtrees[1].value + 1;
          this.emit("change");
        } else {
          this._recordStep(["keypress", code, 1, { frame: fv.store.getIndex() }]);
        }
      }
      return;
    }
    if (isMouse) {
      let pos = this._getTargetPos(target, params2);
      if (pos.x && pos.y) {
        this._latestMousePosition = pos;
      }
      let suffix = name.split("mouse")[1];
      this._addMouseAction(suffix, selector, { ...this._latestMousePosition }, { frame: fv.store.getIndex() });
    } else {
      this._mouseActionBuffer = [];
    }
  }
  async onEffect(name, event, fv) {
    switch (name) {
      case "navigated":
        if (fv.store.isMain())
          ;
        break;
      case "document":
        if (fv.store.isMain()) {
          this._recordStep(["wait_doc", { frame: fv.store.getIndex() }]);
        }
        break;
      case "input": {
        let el2 = fv.getNode(event.path);
        if (el2.tagName.toLowerCase() === "input" && textInputTypes.includes(el2.type) || el2.tagName.toLowerCase() === "textarea") {
          let selector2 = await this.find(el2);
          let lastStep2 = this.steps[this.steps.length - 1];
          if (lastStep2 instanceof FunctionCall$1 && lastStep2.name === "type" && lastStep2.subtrees[0] instanceof StructNode$1 && lastStep2.subtrees[0].name === "selector" && isSameSelector(lastStep2.subtrees[0], selector2.value) && lastStep2.subtrees[1] instanceof Literal$1 && lastStep2.subtrees[1].returnType === "string") {
            lastStep2.subtrees[1].value = event.value;
            this.emit("change");
          } else {
            this._recordStep(["type", ["selector", selector2.toJSON()], event.value, { frame: fv.store.getIndex() }]);
          }
        }
        break;
      }
      case "scroll":
        let { path, left, top } = event;
        let el = fv.getNode(path);
        let selector = await this.find(el);
        let lastStep = this.steps[this.steps.length - 1];
        if (lastStep instanceof FunctionCall$1 && lastStep.name === "scroll" && lastStep.subtrees[0] instanceof StructNode$1 && lastStep.subtrees[0].name === "selector" && isSameSelector(lastStep.subtrees[0], selector.value) && lastStep.subtrees[1] instanceof Literal$1 && lastStep.subtrees[1].returnType === "number" && lastStep.subtrees[2] instanceof Literal$1 && lastStep.subtrees[2].returnType === "number") {
          lastStep.subtrees[1].value = left;
          lastStep.subtrees[2].value = top;
          this.emit("change");
        } else {
          this._recordStep(["scroll", ["selector", selector.toJSON()], left, top, { frame: fv.store.getIndex() }]);
        }
        break;
    }
  }
  _recordStep(newStep) {
    let statement = parseStatement(newStep, this.registry);
    this.statementList.append(statement);
    this._removeRedundant();
    this.emit("change");
  }
  replaceStep(step, idx) {
    if (idx < 0 || idx > this.steps.length - 1) {
      throw new Error("step index out of bounds");
    }
    let statement = parseStatement(step, this.registry);
    this.statementList.replaceChild(this.statementList.nodes[idx], statement);
    this._mouseActionBuffer = [];
    this.emit("change");
  }
  async reset() {
    this.statementList.clearStatements();
    this._mouseActionBuffer = [];
    this._latestMousePosition = { x: 0, y: 0 };
    this.lastEl = void 0;
    this.emit("change");
  }
  _removeRedundant() {
    let hasRedundancy = true;
    while (hasRedundancy) {
      if (this.steps.length < 2)
        return;
      let lastStep = this.steps[this.steps.length - 1];
      let secondLastStep = this.steps[this.steps.length - 2];
      hasRedundancy = false;
      if (isOfStepType(lastStep, "wait_doc") && isOfStepType(secondLastStep, "wait_doc")) {
        this.statementList.pop();
      } else if (lastStep instanceof FunctionCall$1 && lastStep.name === "keypress" && secondLastStep instanceof FunctionCall$1 && secondLastStep.name === "keypress" && (lastStep.subtrees[0] instanceof Literal$1 && lastStep.subtrees[0].returnType === "string") && (secondLastStep.subtrees[0] instanceof Literal$1 && secondLastStep.subtrees[0].returnType === "string") && (lastStep.subtrees[1] instanceof Literal$1 && lastStep.subtrees[1].returnType === "number") && (secondLastStep.subtrees[1] instanceof Literal$1 && secondLastStep.subtrees[1].returnType === "number")) {
        hasRedundancy = true;
        secondLastStep.subtrees[1].value = secondLastStep.subtrees[1].value + lastStep.subtrees[1].value;
        this.statementList.pop();
      } else if (lastStep instanceof FunctionCall$1 && lastStep.name === "keypress" && lastStep.subtrees[0] instanceof Literal$1 && lastStep.subtrees[0].value === "Backspace" && secondLastStep instanceof FunctionCall$1 && secondLastStep.name === "type" && secondLastStep.subtrees[0] instanceof StructNode$1 && secondLastStep.subtrees[0].name === "selector") {
        let valueNode = secondLastStep.subtrees[0].get("value");
        if (valueNode instanceof Literal$1 && typeof valueNode.value === "string" && secondLastStep.subtrees[1] instanceof Literal$1 && typeof secondLastStep.subtrees[1].value === "string") {
          hasRedundancy = true;
          secondLastStep.subtrees[1].value = secondLastStep.subtrees[1].value.slice(0, -1);
          this.statementList.pop();
        }
      } else if (lastStep instanceof FunctionCall$1 && lastStep.name === "keypress" && secondLastStep instanceof FunctionCall$1 && secondLastStep.name === "click" && lastStep.subtrees[0] instanceof Literal$1 && lastStep.subtrees[0].value === "Backspace" && this.lastEl && this.lastEl.tagName === "INPUT" && textInputTypes.includes(this.lastEl.getAttribute("type") || "text")) {
        hasRedundancy = true;
        this.statementList.pop();
      } else if (lastStep instanceof FunctionCall$1 && lastStep.name === "select" && secondLastStep instanceof FunctionCall$1 && secondLastStep.name === "click" && lastStep.subtrees[0] instanceof StructNode$1 && lastStep.subtrees[0].name === "selector" && secondLastStep.subtrees[0] instanceof StructNode$1 && secondLastStep.subtrees[0].name === "selector") {
        let lastSelector = lastStep.subtrees[0].get("value");
        let secondLastSelector = secondLastStep.subtrees[0].get("value");
        if (lastSelector instanceof Literal$1 && secondLastSelector instanceof Literal$1 && lastSelector.value === secondLastSelector.value) {
          hasRedundancy = true;
          this.statementList.removeChild(secondLastStep);
        }
      } else if (lastStep instanceof FunctionCall$1 && lastStep.name === "keypress" && secondLastStep instanceof FunctionCall$1 && secondLastStep.name === "keypress" && lastStep.subtrees[0] instanceof Literal$1 && secondLastStep.subtrees[0] instanceof Literal$1 && lastStep.subtrees[0].value === secondLastStep.subtrees[0].value) {
        let lastCount = lastStep.subtrees[1];
        let secondLastCount = secondLastStep.subtrees[1];
        if (lastCount instanceof Literal$1 && secondLastCount instanceof Literal$1) {
          hasRedundancy = true;
          secondLastCount.value = lastCount.value + secondLastCount.value;
          this.statementList.pop();
        }
      } else if (lastStep instanceof FunctionCall$1 && lastStep.name === "type" && secondLastStep instanceof FunctionCall$1 && secondLastStep.name === "type" && lastStep.subtrees[0] instanceof StructNode$1 && lastStep.subtrees[0].name === "selector" && secondLastStep.subtrees[0] instanceof StructNode$1 && secondLastStep.subtrees[0].name === "selector") {
        let lastSelector = lastStep.subtrees[0].get("value");
        let secondLastSelector = secondLastStep.subtrees[0].get("value");
        if (lastSelector instanceof Literal$1 && secondLastSelector instanceof Literal$1 && lastSelector.value === secondLastSelector.value && lastStep.subtrees[1] instanceof Literal$1 && secondLastStep.subtrees[1] instanceof Literal$1) {
          hasRedundancy = true;
          secondLastStep.subtrees[1].value = lastStep.subtrees[1].value;
          this.statementList.pop();
        }
      } else if (lastStep instanceof FunctionCall$1 && lastStep.name === "scroll" && secondLastStep instanceof FunctionCall$1 && secondLastStep.name === "scroll" && lastStep.subtrees[0] instanceof StructNode$1 && lastStep.subtrees[0].name === "selector" && secondLastStep.subtrees[0] instanceof StructNode$1 && secondLastStep.subtrees[0].name === "selector") {
        let lastSelector = lastStep.subtrees[0].get("value");
        let secondLastSelector = secondLastStep.subtrees[0].get("value");
        if (lastSelector instanceof Literal$1 && secondLastSelector instanceof Literal$1 && lastSelector.value === secondLastSelector.value && lastStep.subtrees[1] instanceof Literal$1 && secondLastStep.subtrees[1] instanceof Literal$1) {
          hasRedundancy = true;
          secondLastStep.subtrees[1].value = secondLastStep.subtrees[1].value + lastStep.subtrees[1].value;
          this.statementList.pop();
        }
        if (lastSelector instanceof Literal$1 && secondLastSelector instanceof Literal$1 && lastSelector.value === secondLastSelector.value && lastStep.subtrees[2] instanceof Literal$1 && secondLastStep.subtrees[2] instanceof Literal$1) {
          hasRedundancy = true;
          secondLastStep.subtrees[2].value = secondLastStep.subtrees[2].value + lastStep.subtrees[2].value;
          this.statementList.pop();
        }
      }
    }
  }
}
class Player extends Player$1 {
  constructor(source, browserView) {
    super(source, new BrowserWrapper(browserView));
  }
}
function isOfStepType(node2, type) {
  return node2 instanceof FunctionCall$1 && node2.name === type;
}
function create_else_block_1$6(ctx) {
  let div0;
  let t0_value = ctx[10].name + "";
  let t0;
  let t1;
  let div1;
  let t2_value = (ctx[10].meta.url || "") + "";
  let t2;
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      attr(div0, "class", "truncate");
      attr(div1, "class", "truncate");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && t0_value !== (t0_value = ctx2[10].name + ""))
        set_data(t0, t0_value);
      if (dirty & 1024 && t2_value !== (t2_value = (ctx2[10].meta.url || "") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_3$a(ctx) {
  let div;
  let input0;
  let t0;
  let input1;
  let t1;
  let button0;
  let t3;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      button0 = element("button");
      button0.textContent = "Save";
      t3 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(input0, "type", "text");
      attr(input0, "class", "w-1/3");
      attr(input0, "placeholder", "Macro Name");
      attr(input1, "type", "text");
      attr(input1, "class", "w-1/3");
      attr(input1, "placeholder", "Start URL");
      attr(div, "class", "flex gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      set_input_value(input0, ctx[8]);
      append(div, t0);
      append(div, input1);
      set_input_value(input1, ctx[9]);
      append(div, t1);
      append(div, button0);
      append(div, t3);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[21]),
          listen(input1, "input", ctx[22]),
          listen(button0, "click", ctx[18]),
          listen(button1, "click", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 256 && input0.value !== ctx2[8]) {
        set_input_value(input0, ctx2[8]);
      }
      if (dirty & 512 && input1.value !== ctx2[9]) {
        set_input_value(input1, ctx2[9]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$a(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-pencil"></i>`;
      attr(button, "class", "btn btn-default btn-sm");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[16]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$l(ctx) {
  let t0;
  let a;
  let t1_value = ctx[10].steps.length + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  let if_block = ctx[4] && create_if_block_1$f();
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      a = element("a");
      t1 = text(t1_value);
      t2 = text(" steps");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, a, anchor);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[14]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$f();
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 1024 && t1_value !== (t1_value = ctx2[10].steps.length + ""))
        set_data(t1, t1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$n(ctx) {
  let div2;
  let div0;
  let button0;
  let t1;
  let button1;
  let t3;
  let div1;
  let expression;
  let current;
  let mounted;
  let dispose;
  expression = new Expression({ props: { tree: ctx[5] } });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Save";
      t1 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      t3 = space();
      div1 = element("div");
      create_component(expression.$$.fragment);
      attr(div0, "class", "flex gap-2 ml-2");
      attr(div1, "class", "w-4/5");
      attr(div2, "class", "w-full");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, button1);
      append(div2, t3);
      append(div2, div1);
      mount_component(expression, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[11]),
          listen(button1, "click", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const expression_changes = {};
      if (dirty & 32)
        expression_changes.tree = ctx2[5];
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(expression);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$f(ctx) {
  let t;
  return {
    c() {
      t = text("Saving...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$g(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-trash-o error");
      set_style(i2, "font-size", "1.5em");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_fragment$I(ctx) {
  let tr;
  let td0;
  let div1;
  let div0;
  let t0;
  let t1;
  let td1;
  let div2;
  let current_block_type_index;
  let if_block2;
  let t2;
  let td2;
  let div3;
  let button0;
  let t4;
  let button1;
  let t6;
  let button2;
  let t8;
  let td3;
  let div4;
  let confirmbtn;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[7])
      return create_if_block_3$a;
    return create_else_block_1$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[6] && !ctx[7] && create_if_block_2$a(ctx);
  const if_block_creators = [create_if_block$n, create_else_block$l];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  confirmbtn = new ConfirmBtn({
    props: {
      alignRight: "1",
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[27]);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      td1 = element("td");
      div2 = element("div");
      if_block2.c();
      t2 = space();
      td2 = element("td");
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Open Recorder";
      t4 = space();
      button1 = element("button");
      button1.textContent = "View Monitors";
      t6 = space();
      button2 = element("button");
      button2.textContent = "Export Macro";
      t8 = space();
      td3 = element("td");
      div4 = element("div");
      create_component(confirmbtn.$$.fragment);
      attr(div0, "class", "w-11/12 mr-2");
      attr(div1, "class", "flex items-center flex-wrap");
      set_style(div1, "min-height", "3em");
      attr(div2, "class", "flex items-center flex-wrap");
      set_style(div2, "min-height", "3em");
      attr(button0, "class", "btn btn-default btn-sm");
      attr(button1, "class", "btn btn-default btn-sm");
      attr(button2, "class", "btn btn-default btn-sm");
      attr(div3, "class", "flex items-center flex-wrap gap-1");
      set_style(div3, "min-height", "3em");
      attr(div4, "class", "flex items-center flex-wrap gap-1");
      set_style(div4, "min-height", "3em");
      attr(td3, "title", "Delete");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, div1);
      append(div1, div0);
      if_block0.m(div0, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(tr, t1);
      append(tr, td1);
      append(td1, div2);
      if_blocks[current_block_type_index].m(div2, null);
      append(tr, t2);
      append(tr, td2);
      append(td2, div3);
      append(div3, button0);
      append(div3, t4);
      append(div3, button1);
      append(div3, t6);
      append(div3, button2);
      append(tr, t8);
      append(tr, td3);
      append(td3, div4);
      mount_component(confirmbtn, div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "mouseenter", ctx[23]),
          listen(div1, "mouseleave", ctx[24]),
          listen(button0, "click", ctx[13]),
          listen(button1, "click", ctx[25]),
          listen(button2, "click", ctx[26])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (ctx2[6] && !ctx2[7]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$a(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div2, null);
      }
      const confirmbtn_changes = {};
      if (dirty & 1073741824) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      destroy_component(confirmbtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$G($$self, $$props, $$invalidate) {
  let $macro, $$unsubscribe_macro = noop, $$subscribe_macro = () => ($$unsubscribe_macro(), $$unsubscribe_macro = subscribe(macro, ($$value) => $$invalidate(10, $macro = $$value)), macro);
  $$self.$$.on_destroy.push(() => $$unsubscribe_macro());
  let { macro } = $$props;
  $$subscribe_macro();
  let { onSaveSteps: onSaveSteps2 } = $$props;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let { onDelete } = $$props;
  let expanded = false;
  let saving = false;
  let msgTimeout = null;
  let tree = parseSteps($macro.steps);
  async function onSave() {
    $$invalidate(3, expanded = false);
    $$invalidate(4, saving = true);
    await macro.save({ steps: tree.toJSON() });
    $$invalidate(5, tree = parseSteps($macro.steps));
    $$invalidate(4, saving = false);
  }
  function onCancel() {
    $$invalidate(5, tree = parseSteps($macro.steps));
    $$invalidate(3, expanded = false);
  }
  function openRecorder() {
    if ($macro.version > VERSION) {
      showMacroVersionError();
      return;
    }
    onCancel();
    openBrowser(macro);
  }
  function expandMacro() {
    if ($macro.version > VERSION) {
      showMacroVersionError();
      return;
    }
    $$invalidate(3, expanded = true);
  }
  function showMacroVersionError() {
    clearTimeout(msgTimeout);
    Msg.error("This macro was created with a newer version of the recorder. Please update the app to the latest version to use this macro.");
    msgTimeout = setTimeout(() => Msg.reset(), 5e3);
  }
  function exportMacro() {
    let exportFields = ["meta", "name", "spec", "steps", "version"];
    let macroJSON = {
      ...macro.attributes,
      version: VERSION
    };
    download(
      JSON.stringify({
        macros: [_.pick(macroJSON, ...exportFields)]
      }),
      macro.attributes.name + "-" + macro.attributes.id + ".json"
    );
  }
  let showEditIcon = false;
  let editNameURL = false;
  let newName = $macro.name;
  let newURL = $macro.meta.url;
  function onEditNameURL() {
    $$invalidate(7, editNameURL = true);
  }
  function onCancelEditNameURL() {
    $$invalidate(7, editNameURL = false);
    $$invalidate(8, newName = $macro.name);
    $$invalidate(9, newURL = $macro.meta.url);
  }
  async function saveNameURL() {
    $$invalidate(7, editNameURL = false);
    await macro.save({ name: newName, meta: { url: newURL } });
  }
  function input0_input_handler() {
    newName = this.value;
    $$invalidate(8, newName);
  }
  function input1_input_handler() {
    newURL = this.value;
    $$invalidate(9, newURL);
  }
  const mouseenter_handler = () => $$invalidate(6, showEditIcon = true);
  const mouseleave_handler = () => $$invalidate(6, showEditIcon = false);
  const click_handler = (e) => showMonitors($macro);
  const click_handler_1 = () => exportMacro();
  const click_handler_2 = (e) => onDelete(macro);
  $$self.$$set = ($$props2) => {
    if ("macro" in $$props2)
      $$subscribe_macro($$invalidate(0, macro = $$props2.macro));
    if ("onSaveSteps" in $$props2)
      $$invalidate(19, onSaveSteps2 = $$props2.onSaveSteps);
    if ("openBrowser" in $$props2)
      $$invalidate(20, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(1, showMonitors = $$props2.showMonitors);
    if ("onDelete" in $$props2)
      $$invalidate(2, onDelete = $$props2.onDelete);
  };
  return [
    macro,
    showMonitors,
    onDelete,
    expanded,
    saving,
    tree,
    showEditIcon,
    editNameURL,
    newName,
    newURL,
    $macro,
    onSave,
    onCancel,
    openRecorder,
    expandMacro,
    exportMacro,
    onEditNameURL,
    onCancelEditNameURL,
    saveNameURL,
    onSaveSteps2,
    openBrowser,
    input0_input_handler,
    input1_input_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class Macro extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$I, safe_not_equal, {
      macro: 0,
      onSaveSteps: 19,
      openBrowser: 20,
      showMonitors: 1,
      onDelete: 2
    });
  }
}
function get_each_context$e(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function create_catch_block$7(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$7(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_pending_block$7(ctx) {
  let td;
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      td = element("td");
      create_component(loader.$$.fragment);
      attr(td, "colspan", "4");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      mount_component(loader, td, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      destroy_component(loader);
    }
  };
}
function create_else_block$k(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No macro found.
        </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$e(key_1, ctx) {
  let first;
  let macro;
  let current;
  macro = new Macro({
    props: {
      macro: ctx[11],
      onSaveSteps,
      openBrowser: ctx[1],
      showMonitors: ctx[2],
      onDelete: ctx[0]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(macro.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(macro, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const macro_changes = {};
      if (dirty & 16)
        macro_changes.macro = ctx[11];
      if (dirty & 2)
        macro_changes.openBrowser = ctx[1];
      if (dirty & 4)
        macro_changes.showMonitors = ctx[2];
      if (dirty & 1)
        macro_changes.onDelete = ctx[0];
      macro.$set(macro_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(macro.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(macro.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(macro, detaching);
    }
  };
}
function create_fragment$H(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t1;
  let small;
  let t2;
  let a;
  let t3;
  let t4;
  let div1;
  let t5;
  let searchbar;
  let t6;
  let listpager;
  let t7;
  let sortby;
  let t8;
  let table;
  let colgroup;
  let t12;
  let tbody;
  let tr0;
  let td;
  let t13;
  let tr1;
  let t20;
  let promise;
  let t21;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[6]);
  listpager = new ListPager({ props: { store: ctx[3] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[7],
      sortingFields: ctx[5],
      currentFieldName: ctx[4].orderBy
    }
  });
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$7,
    then: create_then_block$7,
    catch: create_catch_block$7,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[4].fetchPromise, info);
  let each_value = ctx[4].models;
  const get_key = (ctx2) => ctx2[11].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$e(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$e(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$k();
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = "Macros (beta)";
      t1 = space();
      small = element("small");
      t2 = text("Create and use macros to perform automated actions.\n      ");
      a = element("a");
      t3 = text("Learn More");
      t4 = space();
      div1 = element("div");
      t5 = space();
      create_component(searchbar.$$.fragment);
      t6 = space();
      create_component(listpager.$$.fragment);
      t7 = space();
      create_component(sortby.$$.fragment);
      t8 = space();
      table = element("table");
      colgroup = element("colgroup");
      colgroup.innerHTML = `<col style="width: 50%"/> 
      <col style="width: auto"/> 
      <col style="width: auto"/> 
      <col style="width: 5%"/>`;
      t12 = space();
      tbody = element("tbody");
      tr0 = element("tr");
      td = element("td");
      if (default_slot)
        default_slot.c();
      t13 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<th>Name</th> 
        <th>Recorded Steps</th> 
        <th>Actions</th> 
        <th></th>`;
      t20 = space();
      info.block.c();
      t21 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(a, "href", window.URL_WEBSITE + "/docs/web-monitor/macro-to-record-replay-actions");
      attr(a, "target", "_blank");
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "card-header flex items-center");
      attr(td, "colspan", "4");
      set_style(td, "background-color", "#eee");
      attr(tr1, "class", "bg-gray-200");
      attr(table, "class", "table table-fixed");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(div0, t1);
      append(div0, small);
      append(small, t2);
      append(small, a);
      append(a, t3);
      append(div2, t4);
      append(div2, div1);
      append(div2, t5);
      mount_component(searchbar, div2, null);
      append(div2, t6);
      mount_component(listpager, div2, null);
      append(div2, t7);
      mount_component(sortby, div2, null);
      append(div3, t8);
      append(div3, table);
      append(table, colgroup);
      append(table, t12);
      append(table, tbody);
      append(tbody, tr0);
      append(tr0, td);
      if (default_slot) {
        default_slot.m(td, null);
      }
      append(tbody, t13);
      append(tbody, tr1);
      append(tbody, t20);
      info.block.m(tbody, info.anchor = null);
      info.mount = () => tbody;
      info.anchor = t21;
      append(tbody, t21);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const listpager_changes = {};
      if (dirty & 8)
        listpager_changes.store = ctx[3];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 16)
        sortby_changes.currentFieldName = ctx[4].orderBy;
      sortby.$set(sortby_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[8],
            !current ? get_all_dirty_from_scope(ctx[8]) : get_slot_changes(default_slot_template, ctx[8], dirty, null),
            null
          );
        }
      }
      info.ctx = ctx;
      dirty & 16 && promise !== (promise = ctx[4].fetchPromise) && handle_promise(promise, info);
      if (dirty & 23) {
        each_value = ctx[4].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$e, null, get_each_context$e);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$k();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(info.block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      transition_out(default_slot, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      if (default_slot)
        default_slot.d(detaching);
      info.block.d();
      info.token = null;
      info = null;
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
async function onSaveSteps(e) {
  let macro = e.detail;
  await macro.save();
}
function instance$F($$self, $$props, $$invalidate) {
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { onDelete } = $$props;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let searchQuery = "";
  let sortingFields = [
    { value: "-ts", label: "Newest First" },
    { value: "ts", label: "Oldest First" },
    { value: "name", label: "Name" },
    {
      value: "-name",
      label: "Name - Descending"
    }
  ];
  let store2 = getContext("store");
  component_subscribe($$self, store2, (value) => $$invalidate(4, $store = value));
  async function onSearch2(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      store2.setQuery({});
      return await store2.fetch({ reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({
      $or: {
        "name.ilike": searchQuery,
        "meta:->>'url'.ilike": searchQuery
      }
    });
    return await store2.goto(0, { reset: true });
  }
  async function onSort(by) {
    $$invalidate(3, store2.orderBy = by, store2);
    await store2.fetch({ reset: true });
  }
  $$self.$$set = ($$props2) => {
    if ("onDelete" in $$props2)
      $$invalidate(0, onDelete = $$props2.onDelete);
    if ("openBrowser" in $$props2)
      $$invalidate(1, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(2, showMonitors = $$props2.showMonitors);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    onDelete,
    openBrowser,
    showMonitors,
    store2,
    $store,
    sortingFields,
    onSearch2,
    onSort,
    $$scope,
    slots
  ];
}
class List$6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$F, create_fragment$H, safe_not_equal, {
      onDelete: 0,
      openBrowser: 1,
      showMonitors: 2
    });
  }
}
var Modal_svelte_svelte_type_style_lang = "";
function create_fragment$G(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "modal-body p-0");
      attr(div1, "class", "modal-content");
      attr(div2, "class", div2_class_value = "modal-dialog " + ctx[0] + " svelte-17wlcl9");
      attr(div2, "role", "document");
      attr(div3, "class", "modal");
      attr(div3, "tabindex", "-1");
      attr(div3, "role", "dialog");
      set_style(div3, "display", "block");
      set_style(div3, "background-color", "#fffc");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[5](div3);
      current = true;
      if (!mounted) {
        dispose = listen(window, "keydown", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && div2_class_value !== (div2_class_value = "modal-dialog " + ctx2[0] + " svelte-17wlcl9")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$E($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { widthClass = "" } = $$props;
  let elModal;
  createEventDispatcher();
  const handle_keydown = (e) => {
    if (e.key === "Tab") {
      const nodes = elModal.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((n) => n.tabIndex >= 0);
      let index2 = tabbable.indexOf(document.activeElement);
      if (index2 === -1 && e.shiftKey)
        index2 = 0;
      index2 += tabbable.length + (e.shiftKey ? -1 : 1);
      index2 %= tabbable.length;
      tabbable[index2].focus();
      e.preventDefault();
    }
  };
  const lastFocued = document.activeElement;
  if (lastFocued) {
    onDestroy(() => {
      lastFocued.focus();
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elModal = $$value;
      $$invalidate(1, elModal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("widthClass" in $$props2)
      $$invalidate(0, widthClass = $$props2.widthClass);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [widthClass, elModal, handle_keydown, $$scope, slots, div3_binding];
}
class Modal$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$G, safe_not_equal, { widthClass: 0 });
  }
}
var index = "";
const MAX_NAME_LENGTH = 20;
const MAX_VALUE_LENGTH = 30;
const MAX_ATTRIBS = 15;
const MAX_PARTIAL_COUNT = 10;
function toMean(cum, curr, i2, _2) {
  return cum + (curr - cum) / (i2 + 1);
}
function toMin(cum, curr) {
  return curr > cum ? cum : curr;
}
function getPartialTokenValues(word, options) {
  let wordArr = [];
  if (!/([a-z][A-Z])|[\-\_\s]/.test(word))
    return wordArr;
  if (options && options.multi && word.length > 3) {
    wordArr = wordArr.concat(getMultiWordArr(word));
  }
  wordArr = wordArr.concat(getWordArr(word));
  wordArr = wordArr.filter((w) => w.length > 3);
  return wordArr.slice(0, (options === null || options === void 0 ? void 0 : options.maxCount) || MAX_PARTIAL_COUNT);
}
function getWordArr(word) {
  word = word.replace(/(.+)([A-Z][a-z])/g, "$1 $2");
  word = word.replace(/([a-z])([A-Z])/, "$1 $2");
  let wordArr = word.split(/[\s\,\_\-\(\)\[\]\=]+/);
  return wordArr;
}
function getMultiWordArr(value) {
  let regexp = /^[a-zA-Z0-9]+[\-\_\s]{1,2}[a-zA-Z0-9]+/;
  let regexp2 = /^[a-zA-Z0-9]+[\-\_\s]{1,2}[a-zA-Z0-9]+[\-\_\s]{1,2}[a-zA-Z-0-9]+/;
  let regexp3 = /\b[a-z]+[A-Z][a-z]{2,}/g;
  let matches = [...value.match(regexp) || []].concat([...value.match(regexp2) || []]).concat([...value.matchAll(regexp3)].map((m) => m[0]));
  return matches;
}
class XSet extends Set {
  static flatten(set2d) {
    let newSet = new XSet();
    for (let es of set2d) {
      for (let x of es) {
        newSet.add(x);
      }
    }
    return newSet;
  }
  constructor(arr) {
    super(arr);
  }
  get length() {
    return this.size;
  }
  get first() {
    let x;
    for (x of this) {
      break;
    }
    return x;
  }
  map(mapMethod) {
    return [...this].map(mapMethod);
  }
  mapToSet(mapMethod) {
    return new XSet(this.map(mapMethod));
  }
  filter(filterMethod) {
    return new XSet([...this].filter(filterMethod));
  }
  intersects(anotherSet) {
    for (let item of this) {
      if (anotherSet.has(item))
        return true;
    }
    return false;
  }
  intersection(anotherSet) {
    let newSet = new XSet();
    for (let x of this) {
      if (anotherSet.has(x))
        newSet.add(x);
    }
    return newSet;
  }
  isSubsetOf(anotherSet) {
    return [...this].every((item) => anotherSet.has(item));
  }
  isEqualTo(anotherSet) {
    return this.isSubsetOf(anotherSet) && anotherSet.isSubsetOf(this);
  }
  difference(anotherSet) {
    let diffList = [];
    for (let item of this) {
      if (!anotherSet.has(item)) {
        diffList.push(item);
      }
    }
    return new XSet(diffList);
  }
  union(anotherSet) {
    let newSet = new XSet();
    for (let item of this) {
      newSet.add(item);
    }
    for (let item of anotherSet) {
      newSet.add(item);
    }
    return newSet;
  }
  clone() {
    return new XSet([...this]);
  }
  toArray() {
    return [...this];
  }
}
let penalWords = ["false", "true", "blank"];
let stylingWords = ["css", "align", "animation", "delay", "direction", "fill", "mode", "iteration", "name", "@keyframes", "state", "timing", "function", "backface", "visibility", "background", "attachment", "clip", "image", "origin", "position", "repeat", "size", "border", "bottom", "radius", "right", "style", "width", "collapse", "collapsed", "outset", "slice", "source", "spacing", "top", "box", "shadow", "sizing", "caption", "side", "clear", "column", "gap", "rule", "span", "columns", "counter", "increment", "reset", "cursor", "display", "empty", "cell", "flex", "basis", "flow", "wrap", "grow", "shrink", "float", "font", "family", "adjust", "stretch", "variant", "weight", "height", "justify", "letter", "line", "margin", "max", "min", "opacity", "order", "outline", "offset", "overflow", "padding", "break", "after", "before", "inside", "perspective", "quotes", "resize", "tab", "layout", "decoration", "indent", "transform", "transition", "property", "vertical", "white", "space", "word", "index", "foramt", "row", "col", "format", "highlight", "vert", "middle", "large", "down", "small", "overlay", "trigger"];
let cssColorWords = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgrey", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred ", "indigo ", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgrey", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"];
let cssPositionWords = ["top", "left", "right", "bottom", "position"];
let cssLayoutWords = ["flex", "grid", "col", "row", "inline"];
let fontWords = ["xs", "sm", "lg", "md", "semibold", "bold", "medium", "large", "small"];
let metaWords = ["lang"];
let cssWords = penalWords.concat(stylingWords).concat(cssColorWords).concat(cssPositionWords).concat(cssLayoutWords).concat(fontWords).concat(metaWords);
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge2 = function merge3(options, defaults2) {
  if (!options) {
    return defaults2;
  }
  var result = {};
  for (var key in defaults2) {
    result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults2[key];
  }
  return result;
};
var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
var cssesc = function cssesc2(string, options) {
  options = merge2(options, cssesc2.options);
  if (options.quotes != "single" && options.quotes != "double") {
    options.quotes = "single";
  }
  var quote2 = options.quotes == "double" ? '"' : "'";
  var isIdentifier = options.isIdentifier;
  var firstChar = string.charAt(0);
  var output = "";
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var character = string.charAt(counter++);
    var codePoint = character.charCodeAt();
    var value = void 0;
    if (codePoint < 32 || codePoint > 126) {
      if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
        var extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
        } else {
          counter--;
        }
      }
      value = "\\" + codePoint.toString(16).toUpperCase() + " ";
    } else {
      if (options.escapeEverything) {
        if (regexAnySingleEscape.test(character)) {
          value = "\\" + character;
        } else {
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        }
      } else if (/[\t\n\f\r\x0B]/.test(character)) {
        value = "\\" + codePoint.toString(16).toUpperCase() + " ";
      } else if (character == "\\" || !isIdentifier && (character == '"' && quote2 == character || character == "'" && quote2 == character) || isIdentifier && regexSingleEscape.test(character)) {
        value = "\\" + character;
      } else {
        value = character;
      }
    }
    output += value;
  }
  if (isIdentifier) {
    if (/^-[-\d]/.test(output)) {
      output = "\\-" + output.slice(1);
    } else if (/\d/.test(firstChar)) {
      output = "\\3" + firstChar + " " + output.slice(1);
    }
  }
  output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
    if ($1 && $1.length % 2) {
      return $0;
    }
    return ($1 || "") + $2;
  });
  if (!isIdentifier && options.wrap) {
    return quote2 + output + quote2;
  }
  return output;
};
cssesc.options = {
  "escapeEverything": false,
  "isIdentifier": false,
  "quotes": "single",
  "wrap": false
};
cssesc.version = "3.0.0";
var cssesc_1 = cssesc;
function buildQuery(tree) {
  tree = tree.clone();
  removeDanglingTokens(tree);
  if (tree.tokens.length === 0)
    return "*";
  let path = "";
  let tokens = tree.tokens;
  for (let i2 = 0; i2 < tokens.length; i2++) {
    if (i2 > 0 && (tokens[i2].depth !== tokens[i2 - 1].depth || tokens[i2].offset !== tokens[i2 - 1].offset))
      ;
    let tokenString = formatTokens(tokens[i2], tokens[i2].nodeRef);
    path += addConnector(tokens[i2 - 1], tokens[i2], path) + tokenString;
  }
  if (tree.tokens[tokens.length - 1].offset !== 0)
    path += "~ *";
  if (tree.tokens[tokens.length - 1].depth !== tree.maxDepth)
    path += " *";
  return path;
}
function addConnector(prevToken, curToken, path) {
  if (path === "")
    return "";
  if (prevToken.depth === curToken.depth && prevToken.offset === curToken.offset) {
    return "";
  }
  if (prevToken.offset === 0 && curToken.depth - prevToken.depth === 1 && prevToken.type === "immediate" && curToken.type !== "immediate") {
    return "> ";
  }
  if (prevToken.offset === 0 && prevToken.depth !== curToken.depth) {
    return " ";
  }
  if (prevToken.offset - curToken.offset === 1 && prevToken.depth === curToken.depth && prevToken.type === "immediate") {
    return "+ ";
  }
  if (prevToken.offset < curToken.offset && prevToken.depth === curToken.depth) {
    return "~ ";
  }
  if (prevToken.offset !== 0 && prevToken.depth !== curToken.depth) {
    return "~ * ";
  }
  throw new Error(`unmatched condition in add Connector. prevdepth ${prevToken.depth}, prevOffset ${prevToken.offset}, curDept ${curToken.depth}, curOffset ${curToken.offset}`);
}
function formatTokens(token, curr) {
  if (token.type.startsWith("attrib") && (token.name.includes(":") || token.name === "xmlns")) {
    throw new Error("got xmlns token");
  } else if (token.type === "pos") {
    let idx = getNthIndex(curr);
    let resp = idx === 1 ? ":first-child" : `:nth-child(${idx})`;
    return resp;
  } else if (token.type === "tag") {
    return cssesc_1(token.name, { isIdentifier: true });
  } else if (token.type === "attrib" && token.name === "class") {
    if (!/[^a-zA-Z0-9\_\-]/.test(token.value) && token.nodeRef.classList.contains(token.value)) {
      return "." + cssesc_1(token.value, { isIdentifier: true });
    }
    return `[${cssesc_1(token.name, { isIdentifier: true })}*='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attrib" && token.name === "id") {
    return "#" + cssesc_1(token.value, { isIdentifier: true });
  } else if (token.type === "attrib") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attribStart") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}^='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attribEnd") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}$='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attribContain") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}*='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attribOnly") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}]`;
  } else if (token.type === "immediate") {
    return "";
  } else {
    throw new Error("the type " + token.type + " is unhandled");
  }
}
function getNthIndex(node2) {
  let parent2 = node2.parentElement;
  if (parent2) {
    return Array.from(parent2.children).indexOf(node2) + 1;
  } else {
    throw new Error("no parent");
  }
}
function removeDanglingTokens(tree) {
  let danglingPos = [];
  for (let i2 = 0; i2 < tree.tokens.length; i2++) {
    if (tree.tokens[i2].type === "pos") {
      let badPos = true;
      for (let j = i2 - 1; j >= 0; j--) {
        if (tree.tokens[j].depth !== tree.tokens[i2].depth || tree.tokens[j].offset !== tree.tokens[i2].offset) {
          break;
        }
        if (tree.tokens[j].type === "tag") {
          badPos = false;
          break;
        }
      }
      if (badPos) {
        danglingPos.push(tree.tokens[i2]);
      }
    }
  }
  for (let pT of danglingPos) {
    tree.removeToken(pT);
  }
  let danglingImd = [];
  for (let i2 = 0; i2 < tree.tokens.length; i2++) {
    if (tree.tokens[i2].type === "immediate") {
      if (i2 === 0 || i2 === tree.tokens.length - 1 || tree.tokens[i2].depth !== tree.tokens[i2 - 1].depth || tree.tokens[i2].offset !== tree.tokens[i2 - 1].offset || !(tree.tokens[i2 + 1].depth - tree.tokens[i2].depth === 1 || tree.tokens[i2 + 1].depth === tree.tokens[i2].depth && tree.tokens[i2 + 1].offset - tree.tokens[i2].offset === 1)) {
        danglingImd.push(tree.tokens[i2]);
      }
    }
  }
  for (let iT of danglingImd) {
    tree.removeToken(iT);
  }
}
function write$1(...msg) {
  console.log("SELECTORX", ...msg);
}
let excludeTags = ["script", "style", "link", "head", "noscript", "object", "meta"];
let excludeAttribs = ["srcdoc", "style", "onafterprint", "onbeforeprint", "onbeforeunload", "onerror", "onhaschange", "onload", "onmessage", "onoffline", "onpagehide", "onpageshow", "onpopstate", "onredo", "onresize", "onstorage", "onundo", "onunload", "onblur", "onchange", "oncontextmenu", "onfocus", "onformchange", "onforminput", "oninput", "oninvalid", "onreset", "onselect", "onsubmit", "onkeydown", "onkeypress", "onkeyup", "onclick", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onscroll", "onabort", "oncanplay", "oncanplaythrough", "ondurationchange", "onemptied", "onended", "onerror", "onloadeddata", "onloadedmetadata", "onloadstart", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreadystatechange", "onseeked", "onseeking", "onstalled", "onsuspend", "ontimeupdate", "onvolumechange", "onwaiting"];
let priorityNames1 = ["a", "li", "h1", "h2", "h3", "h4", "h5", "title"];
let priorityNames2 = ["td", "tr", "table", "ul", "ol", "header", "footer", "img", "label", "section"];
let priorityPos = ["td", "tr", "li", "a"];
let priorityValues1 = ["result", "upvote", "downvote", "price", "product", "rating", "rated"];
let priorityValues2 = ["feature", "vote", "heading", "rate"];
class SelectorNode {
  static addNewToken(type, name, value, depth, offset, nodeRef, tokens, filterCallback) {
    if (["attrib", "attribContain", "attribStart", "attribEnd", "text"].includes(type) && value && (!Token.isNotRandGen(value) || Token.isUUID(value)))
      return;
    if (typeof filterCallback === "undefined" || filterCallback(type, name, value, depth, offset)) {
      let token = Token.createNew(type, name, value, depth, offset, nodeRef);
      if (!tokens.includes(token))
        tokens.unshift(token);
    }
  }
  static addTextTokens(depth, offset, nodeRef, tokens, coveredNodes, unsatisfied, filterCallback) {
    let textArr = this.getTextArrFromNode(nodeRef, coveredNodes, unsatisfied);
    textArr = textArr.filter((text2) => !text2.includes("'") && text2.length > 3);
    for (let text2 of textArr) {
      this.addNewToken("text", "text", text2, depth, offset, nodeRef, tokens, filterCallback);
    }
  }
  static addPartialTokens(name, value, words, depth, offset, nodeRef, onlyContains, tokens, filterCallback) {
    if (Token.isUUID(value))
      return;
    for (let word of words) {
      let type = "attribContain";
      if (!onlyContains) {
        if (value.indexOf(word) === 0) {
          type = "attribStart";
        } else if (value.indexOf(word) === value.length - word.length) {
          type = "attribEnd";
        }
      }
      this.addNewToken(type, name, word, depth, offset, nodeRef, tokens, filterCallback);
    }
  }
  static buildTree(targetNode, root, options, unsatisfied, filterCallback) {
    let coveredNodes = [];
    let tokens = [];
    let maxDepth = this.getMaxDepth(targetNode, root);
    let depth = maxDepth;
    let currentNode = targetNode;
    if (!currentNode.contains(targetNode)) {
      throw new Error("target is not in subtree");
    }
    while (currentNode && root.contains(currentNode)) {
      this.generateTokens(currentNode, options, depth, 0, tokens, coveredNodes, unsatisfied, filterCallback);
      if (options.siblingNodes) {
        let leftSib = getLeftSibling(currentNode);
        if (leftSib) {
          this.generateTokens(leftSib.node, options, depth, -1, tokens, coveredNodes, unsatisfied, filterCallback);
          let leftSib2 = getLeftSibling(leftSib.node);
          if (leftSib2) {
            this.generateTokens(leftSib2.node, options, depth, -2, tokens, coveredNodes, unsatisfied, filterCallback);
          }
        }
      }
      depth -= 1;
      if (currentNode.parentNode) {
        currentNode = currentNode.parentNode;
      }
    }
    return new SelectorNode(targetNode, root, tokens, maxDepth);
  }
  static generateTokens(nodeRef, options, depth, offset, tokens, coveredNodes, unsatisfied, filterCallback) {
    var _a;
    let element2 = nodeRef;
    this.addNewToken("immediate", null, null, depth, offset, nodeRef, tokens, filterCallback);
    if (element2.parentElement) {
      this.addNewToken("pos", element2.tagName.toLowerCase(), getNthIndex(nodeRef).toString(), depth, offset, nodeRef, tokens, filterCallback);
    }
    if (options.text) {
      this.addTextTokens(depth, offset, nodeRef, tokens, coveredNodes, unsatisfied, filterCallback);
    }
    let attributes2 = Array.from(element2.attributes).slice(0, MAX_ATTRIBS);
    let classList = ((_a = element2.classList) === null || _a === void 0 ? void 0 : _a.length) > 0 ? Array.from(element2.classList).slice(0, MAX_ATTRIBS) : [];
    for (let { name, value } of attributes2) {
      if (name.length > MAX_NAME_LENGTH || name.includes(":") || name.indexOf("xmlns") >= 0 || excludeAttribs.includes(name))
        continue;
      if (value.trim().length > 0) {
        if (name === "class") {
          classList.forEach((className) => this.addNewToken("attrib", name, className, depth, offset, nodeRef, tokens, filterCallback));
        } else {
          if (value.length <= MAX_VALUE_LENGTH)
            this.addNewToken("attrib", name, value, depth, offset, nodeRef, tokens, filterCallback);
        }
      }
      if (name !== "id" && name !== "class")
        this.addNewToken("attribOnly", name, null, depth, offset, nodeRef, tokens, filterCallback);
    }
    if (options.partAttrib) {
      for (let className of classList) {
        let words = getPartialTokenValues(className, { multi: true });
        words = [...new Set(words)];
        this.addPartialTokens("class", className, words, depth, offset, nodeRef, true, tokens, filterCallback);
      }
      for (let { name, value } of attributes2) {
        if (name === "class")
          continue;
        if (name.length > MAX_NAME_LENGTH || name.includes(":") || name.indexOf("xmlns") >= 0 || excludeAttribs.includes(name))
          continue;
        if (value.trim().length > 0) {
          let words = getPartialTokenValues(value, { multi: true });
          words = [...new Set(words)];
          this.addPartialTokens(name, value, words, depth, offset, nodeRef, false, tokens, filterCallback);
        }
      }
    }
    this.addNewToken("tag", element2.tagName.toLowerCase(), null, depth, offset, nodeRef, tokens, filterCallback);
  }
  static getMaxDepth(targetNode, root) {
    let depth = 0;
    let currentNode = root;
    while (currentNode !== targetNode) {
      depth += 1;
      for (let child of Array.from(currentNode.childNodes)) {
        if (child.contains(targetNode)) {
          currentNode = child;
          break;
        }
      }
    }
    return depth;
  }
  static getTextArrFromNode(node2, coveredNodes, unsatisfied) {
    if (coveredNodes.includes(node2)) {
      return [];
    }
    coveredNodes.push(node2);
    if (node2.nodeType === 3) {
      let wordArr = getWordArr(node2.textContent || "");
      if (wordArr.length === 0)
        return [];
      else if (wordArr.length <= 3)
        return [node2.textContent.trim()];
      else if (wordArr.length <= 5)
        return wordArr;
      else
        return [];
    } else if (node2.nodeType === 1) {
      let wordArr = [];
      for (let child of Array.from(node2.childNodes)) {
        if (coveredNodes.includes(child) || unsatisfied.some((u) => child.contains(u)))
          break;
        wordArr = wordArr.concat(this.getTextArrFromNode(child, coveredNodes, unsatisfied));
        if (wordArr.length > MAX_ATTRIBS)
          break;
      }
      return wordArr.slice(0, MAX_ATTRIBS);
    }
    return [];
  }
  addToken(token) {
    if (this.includes(token))
      return;
    this._tokens.push(token);
    this.sortTokens();
  }
  clone(flushTokens = false) {
    let tokens = flushTokens ? [] : this.tokens;
    return new SelectorNode(this.targetNode, this._root, tokens, this.maxDepth);
  }
  constructor(targetNode, root, tokens, maxDepth) {
    this.targetNode = targetNode;
    this._root = root;
    this._tokens = [...tokens];
    this.maxDepth = maxDepth;
  }
  hasSimilarToken(token, isOnlyStem = false) {
    let tokens = this._tokens;
    if (isOnlyStem)
      tokens = tokens.filter((t) => t.offset === 0);
    for (let t of tokens) {
      if (t.equals(token))
        return true;
    }
    return false;
  }
  includes(token, isOnlyStem = false) {
    let tokens = this._tokens;
    if (isOnlyStem)
      tokens = tokens.filter((t) => t.offset === 0);
    for (let t of tokens) {
      if (t.exacts(token))
        return true;
    }
    return false;
  }
  get length() {
    return this._tokens.filter((n) => n.offset === 0).length;
  }
  removeToken(token) {
    let idx = this._tokens.indexOf(token);
    if (idx === -1)
      throw new Error(`token not in current tree: ${token.type}, ${token.name}, ${token.value} `);
    this._tokens.splice(idx, 1);
    return idx;
  }
  sortTokens() {
    this._tokens.sort((t1, t2) => {
      if (t1.depth !== t2.depth)
        return t1.depth - t2.depth;
      else if (t1.offset !== t2.offset)
        return t1.offset - t2.offset;
      else if (t1.internalPriorityNumber != t2.internalPriorityNumber)
        return t1.internalPriorityNumber - t2.internalPriorityNumber;
      else if (t1.name != t2.name)
        return t1.name.localeCompare(t2.name);
      else
        return t1.value.localeCompare(t2.value);
    });
  }
  get tokens() {
    return this._tokens;
  }
}
class Token {
  constructor(type, name, value, depth, offset, nodeRef) {
    this._value = value;
    this._type = type;
    this._name = name;
    this._depth = depth;
    this._offset = offset;
    this.nodeRef = nodeRef;
    this._metrics = null;
    this.internalPriorityNumber = Token.getInternalPriorityNumber(this.type, this.name);
  }
  get depth() {
    return this._depth;
  }
  equals(another) {
    return this.value === another.value && this.type === another.type && this.name === another.name;
  }
  exacts(another) {
    return this.value === another.value && this.type === another.type && this.name === another.name && this.depth === another.depth && this.offset === another.offset;
  }
  getScore(weights) {
    let score = 0;
    let metric;
    for (metric in this.metrics) {
      score += weights[metric] * this.metrics[metric];
    }
    return score;
  }
  get metrics() {
    if (this._metrics)
      return this._metrics;
    else
      throw new Error("metrics not yet updated");
  }
  get name() {
    return this._name || "";
  }
  get offset() {
    return this._offset;
  }
  get type() {
    return this._type;
  }
  get value() {
    return this._value || "";
  }
  updateMetrics(selectorTree, selectorTrees, rejectTrees) {
    let isOnlyStem = this.offset === 0;
    this._metrics = {
      numPaths: selectorTrees.filter((tree) => tree.hasSimilarToken(this, isOnlyStem)).length / selectorTrees.length,
      rightLean: this.depth / selectorTree.maxDepth,
      specificity: Token.getSpecificity(this.type, this.name, this.value),
      isDirectAncestor: this.offset === 0 ? 1 : 0,
      nameCssAttribProb: Token.getCSSAttribProb(this.name),
      valueCssAttribProb: Token.getCSSAttribProb(this.value),
      namePriority: Token.getNamePriority(this.name),
      valuePriority: Token.getValuePriority(this.value),
      rejectPaths: rejectTrees.filter((tree) => tree.hasSimilarToken(this, true)).length / (rejectTrees.length || 1),
      nameContainsNumber: Token.checkIfNameContainsNumber(this.name),
      valueContainsNumber: Token.checkIfContainsNumber(this.value),
      shallowRightLean: Token.getShallowRightLean(this, selectorTree),
      tokensPathsRatio: Token.getTokensPathsRatio(this, selectorTrees),
      numOfSameTokensToRight: Token.getNumOfSameTokensToRight(this, selectorTree),
      valueContainsSpecialChar: /[^a-zA-Z-_\s0-9]/.test(this.value) ? 1 : 0
    };
  }
  static createNew(type, name, value, depth, offset, nodeRef) {
    if (type === "tag") {
      return new TokenTag(type, name, value, depth, offset, nodeRef);
    } else if (type === "pos") {
      return new TokenPos(type, name, value, depth, offset, nodeRef);
    } else if (type === "immediate") {
      return new TokenImmediate(type, name, value, depth, offset, nodeRef);
    } else {
      return new Token(type, name, value, depth, offset, nodeRef);
    }
  }
  static checkIfContainsNumber(value) {
    return value.replace(/\D/g, "").length > 0 ? 1 : 0;
  }
  static checkIfNameContainsNumber(name) {
    let goodTagsList = ["h1", "h2", "h3", "h4", "h5", "h6", "h7"];
    if (goodTagsList.includes(name))
      return 0;
    return Token.checkIfContainsNumber(name);
  }
  static isNotRandGen(value) {
    if (value.length === 0)
      return 1;
    let valueWhiteList = ["txt", "btn"];
    if (/([a-zA-Z]|\b)\d+[a-zA-Z]/.test(value))
      return 0;
    if (/[0-9]{3,}/.test(value))
      return 0;
    let validLen = value.replace(/[^a-zA-Z]/g, "").length;
    if (validLen === 3) {
      if (valueWhiteList.includes(value.toLowerCase()))
        return 1;
      else
        return 0;
    }
    if (validLen < 3)
      return 0;
    let wordArr = getWordArr(value);
    if (wordArr.length === 0)
      return 1;
    let probs = wordArr.map((word) => {
      if (/\b\d{1,2}\b/.test(word)) {
        return 1;
      } else {
        word = word.toLowerCase();
        if (word.length > 2 && !/[aeiouy]/.test(word))
          return 0;
        if (/[^aeiouy]{4,}/.test(word))
          return 0;
        return 1;
      }
    });
    return probs.reduce(toMin);
  }
  static isUUID(value) {
    value = value.toLowerCase();
    if (/[0-9abcdef]{8}-[0-9abcdef]{4}-[0-9abcdef]{4}-[0-9abcdef]{4}-[0-9abcdef]{12}/.test(value)) {
      return 1;
    }
    value = value.replace(/[\-_]/g, "");
    if (value.length === 32 && !/[hijklmnopqrstuvwxyz]/.test(value)) {
      return 1;
    }
    return 0;
  }
  static getCSSAttribProb(value) {
    if (value === "")
      return 0;
    let wordArr = getWordArr(value);
    let scoreArr = wordArr.map((word) => {
      word = word.toLowerCase();
      for (let badWord of cssWords) {
        if (word === badWord)
          return 1;
      }
      return 0;
    });
    return scoreArr.reduce(toMean);
  }
  static getInternalPriorityNumber(type, name) {
    if (type === "tag")
      return 0;
    else if (type === "attrib" && name === "id")
      return 1;
    else if (type === "attrib" && name === "class")
      return 2;
    else if (type === "attrib")
      return 3;
    else if (type === "attribOnly")
      return 4;
    else if (type === "attribStart")
      return 5;
    else if (type === "attribContain")
      return 6;
    else if (type === "attribEnd")
      return 7;
    else if (type === "text")
      return 8;
    else if (type === "pos")
      return 9;
    else if (type === "immediate")
      return 10;
    else
      throw new Error("unhandled case in getInternalPriorityNumber " + type + " " + name + " ");
  }
  static getNamePriority(name) {
    name = name.toLowerCase();
    if (name.startsWith("aria-")) {
      return 1;
    } else if (priorityNames1.includes(name)) {
      return 1;
    } else if (priorityNames2.includes(name)) {
      return 0.7;
    }
    return 0;
  }
  static getNumOfSameTokensToRight(token, tree) {
    let filteredTokens = tree.tokens.filter((t) => {
      return t.equals(token) && (t.depth > token.depth || t.depth === token.depth && t.offset > token.offset);
    });
    return filteredTokens.length;
  }
  static getShallowRightLean(token, selectorTree) {
    let nodeRefs = selectorTree.tokens.filter((t) => t.offset === 0).sort((t1, t2) => t1.depth - t2.depth).map((t) => t.nodeRef);
    let childCountList = [...new Set(nodeRefs)].map((n) => n.childNodes.length);
    let totalShallowDepth = childCountList.slice(0, selectorTree.length).filter((x) => x > 1).length + 1;
    let currentTokenShallowDepth = childCountList.slice(0, token.depth).filter((x) => x > 1).length + 1;
    return currentTokenShallowDepth / totalShallowDepth;
  }
  static getSpecificity(typ, name, value) {
    if (typ === "attrib")
      return 0.8;
    if (typ === "attribStart")
      return 0.75;
    if (typ === "attribEnd")
      return 0.725;
    if (typ === "attribContain")
      return 0.7;
    if (typ === "attribOnly")
      return 0.6;
    if (typ === "text")
      return 0.55;
    if (typ === "tag")
      return 0.5;
    if (typ === "pos")
      return 0.3;
    if (typ === "immediate")
      return 0.2;
    throw new Error(`unknown token: ${typ}, ${name}, ${value}`);
  }
  static getTokensPathsRatio(token, selectorTrees) {
    let count2 = 0;
    for (let tree of selectorTrees) {
      for (let tkn of tree.tokens.filter((t) => t.offset === 0)) {
        if (tkn.equals(token))
          count2++;
      }
    }
    let x = count2 / selectorTrees.length;
    let a = 3.5;
    return Math.exp(a * (1 - x + Math.log(x)));
  }
  static getValuePriority(value) {
    value = value.toLowerCase();
    if (priorityValues1.some((v) => value.includes(v))) {
      return 1;
    }
    if (priorityValues2.some((v) => value.includes(v))) {
      return 0.5;
    }
    return 0;
  }
  static getVowelRatio(value) {
    value = value.toLowerCase().replace(/[^a-z]/g, "");
    if (value.length === 0)
      return 0;
    let vowels = value.replace(/[^aeiou]/g, "");
    return vowels.length / value.length;
  }
  static printTokens(tokens, weights) {
    let writeArr = [];
    let rank = 1;
    for (let token of tokens) {
      writeArr.push(`${rank++}`);
      writeArr.push(`"${token.value}"-"${token.name}"-"${token.type}"-depth ${token.depth}"-offset ${token.offset}"`);
      writeArr.push(`score: ${token.getScore(weights)}`);
      let metric;
      for (metric in token.metrics) {
        writeArr.push(`${metric} ${token.metrics[metric]}`);
      }
      writeArr.push(`
`);
    }
    write$1(writeArr.join("\n"));
  }
}
Token.separator = "<<<---|||--->>>";
class TokenTag extends Token {
  updateMetrics(selectorTree, selectorTrees, rejectTrees) {
    super.updateMetrics(selectorTree, selectorTrees, rejectTrees);
    if (this._metrics) {
      this._metrics.valueCssAttribProb = 0;
      this._metrics.nameContainsNumber = 0;
      this._metrics.valueContainsNumber = 0;
    }
  }
}
class TokenPos extends Token {
  updateMetrics(selectorTree, selectorTrees, rejectTrees) {
    super.updateMetrics(selectorTree, selectorTrees, rejectTrees);
    if (this._metrics) {
      this._metrics.namePriority = this.getNamePriority();
      this._metrics.valueCssAttribProb = 0;
      this._metrics.nameContainsNumber = 0;
      this._metrics.valueContainsNumber = 0;
    }
  }
  getNamePriority() {
    if (priorityPos.includes(this.name.toLocaleLowerCase())) {
      return 0.65;
    }
    return 0;
  }
}
class TokenImmediate extends Token {
  getScore(weights) {
    if (this._metrics) {
      return super.getScore(weights);
    } else {
      return 0;
    }
  }
  updateMetrics(selectorTree, selectorTrees, rejectTrees) {
    super.updateMetrics(selectorTree, selectorTrees, rejectTrees);
    if (this._metrics) {
      this._metrics.valueCssAttribProb = 0;
      this._metrics.nameContainsNumber = 0;
      this._metrics.valueContainsNumber = 0;
    }
  }
}
function getLeftSibling(node2) {
  if (node2.parentNode && node2.parentNode.children.length > 0) {
    let children = Array.from(node2.parentNode.children);
    let node_idx = children.indexOf(node2);
    let i2 = node_idx - 1;
    while (i2 >= 0) {
      if (!excludeTags.includes(children[i2].nodeName.toLowerCase())) {
        return { node: children[i2], immediate: node_idx - i2 === 1 };
      }
      i2--;
    }
  }
  return null;
}
function write(...msg) {
  console.log("SELECTORX", ...msg);
}
let coreWeights = {
  numPaths: 8,
  rightLean: 2,
  specificity: 3,
  isDirectAncestor: 2,
  nameCssAttribProb: -4,
  valueCssAttribProb: -4,
  namePriority: 2,
  valuePriority: 1,
  rejectPaths: 0,
  nameContainsNumber: -2,
  valueContainsNumber: -1,
  shallowRightLean: 1,
  tokensPathsRatio: 1,
  numOfSameTokensToRight: -1,
  valueContainsSpecialChar: -2
};
let similarWeights = {
  numPaths: 8,
  rightLean: 0,
  specificity: 1,
  isDirectAncestor: 0,
  nameCssAttribProb: -2,
  valueCssAttribProb: -2,
  namePriority: 0,
  valuePriority: 0,
  rejectPaths: -2,
  nameContainsNumber: 0,
  valueContainsNumber: -1,
  shallowRightLean: 0,
  tokensPathsRatio: 0,
  numOfSameTokensToRight: 0,
  valueContainsSpecialChar: 0
};
class Core {
  constructor(options) {
    this._selected = new XSet();
    this._rejected = new XSet();
    this._doc = document;
    this._root = document.documentElement;
    this._queryCache = /* @__PURE__ */ new Map();
    this._selectorTrees = new XSet();
    this._startTime = 0;
    this.debug = false;
    this._options = options;
    this._tokenOpts = { text: true, partAttrib: true, immediate: true, siblingNodes: true, selectorType: "CSS" };
    this._weights = coreWeights;
    this._unionSeparator = " , ";
    if (options && options.debug)
      this.debug = options.debug;
  }
  isRejection(node2) {
    return this._rejected.has(node2);
  }
  isSelection(node2) {
    return this._selected.has(node2);
  }
  get rejected() {
    return [...this._rejected];
  }
  reset() {
    this._selected = new XSet();
    this._rejected = new XSet();
    this._selectorTrees = new XSet();
    this._root = this._doc.documentElement;
    this._queryCache = /* @__PURE__ */ new Map();
  }
  get selected() {
    return [...this._selected];
  }
  _buildQuery(_2) {
    throw new Error("Method not Implemented");
  }
  _checkTreeValidity(tree) {
    let queried = this._query(tree);
    return queried.length > 0 && queried.has(tree.targetNode);
  }
  async _getOrderedTokens(selectorTrees) {
    let rejectorTrees = this._getSelectorTreeArr(this._rejected);
    let selectorTree = selectorTrees.first;
    let tokens = [...selectorTree.tokens];
    this._updateTokenMetrics(tokens, selectorTrees, rejectorTrees);
    return await this._orderTokens(tokens);
  }
  _getSelectorTreeArr(unsatisfied) {
    if (this._root) {
      return unsatisfied.mapToSet((node2) => {
        var _a;
        return SelectorNode.buildTree(node2, this._root, this._tokenOpts, unsatisfied.toArray(), (_a = this._options) === null || _a === void 0 ? void 0 : _a.filterCallback);
      });
    } else
      throw new Error("root node not set");
  }
  async _orderTokens(tokens) {
    var _a;
    let tokenSorter = (_a = this._options) === null || _a === void 0 ? void 0 : _a.tokenSorter;
    if (typeof tokenSorter !== "undefined") {
      this.debug && write("token Sorter plugin present");
      tokens = await tokenSorter(tokens);
    } else {
      tokens.sort((t1, t2) => {
        let score1 = t1.getScore(this._weights);
        let score2 = t2.getScore(this._weights);
        if (score1 != score2)
          return score2 - score1;
        else if (t1.type === "text" && t2.type === "text") {
          if (t1.offset != t2.offset)
            return t2.offset - t1.offset;
          return -1;
        } else if (t1.name === t2.name)
          return t2.value.length - t1.value.length;
        else
          return t1.name.length + t1.value.length - (t2.name.length + t2.value.length);
      });
    }
    return tokens;
  }
  async _predict() {
    this._selectorTrees = new XSet();
    let unsatisfied = this._selected.clone();
    let count2 = 0;
    this._startTime = Date.now();
    while (unsatisfied.length > 0) {
      this._timeout();
      let selectorTree = await this._simplify(unsatisfied);
      let preds = this._query(selectorTree);
      unsatisfied = unsatisfied.difference(preds);
      if (unsatisfied.length > 0) {
        selectorTree = await this._simplify(preds);
        preds = this._query(selectorTree);
      }
      this._selectorTrees.add(selectorTree);
      count2 += 1;
      if (count2 > this._selected.length)
        throw new Error("stuck in loop");
    }
    return this._selectorTrees.map((tree) => this._buildQuery(tree)).join(this._unionSeparator);
  }
  _query(selectorTree) {
    let selector = this._buildQuery(selectorTree);
    if (!this._queryCache.has(selector)) {
      this._queryCache.set(selector, this._querySelectorAll(selector));
    }
    return this._queryCache.get(selector);
  }
  _querySelectorAll(_2) {
    throw new Error("method not implemented");
  }
  _removeBadTokens(selectorTree) {
    let tree = selectorTree.clone();
    let tokens = tree.tokens;
    for (let i2 = 0; i2 < tokens.length; i2++) {
      if (tokens[i2].type === "pos" && (i2 === 0 || tokens[i2 - 1].depth !== tokens[i2].depth || tokens[i2 - 1].offset !== tokens[i2].offset)) {
        tokens.splice(i2, 1);
      }
    }
    for (let i2 = 0; i2 < tokens.length; i2++) {
      if (tokens[i2].type === "immediate" && (i2 === 0 || tokens[i2 - 1].depth !== tokens[i2].depth || tokens[i2 - 1].offset !== tokens[i2].offset)) {
        tokens.splice(i2, 1);
      }
    }
    return tree;
  }
  async _simplify(_2) {
    throw new Error("method not implemented");
  }
  _timeout() {
    var _a, _b;
    if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.timeout) && Date.now() - this._startTime > this._options.timeout) {
      this.reset();
      throw new Error(`Time limit exceeded, took more than ${(_b = this._options) === null || _b === void 0 ? void 0 : _b.timeout}ms to generate selectors`);
    }
  }
  _updateTokenMetrics(tokens, selectorTrees, rejectorTrees) {
    for (let token of tokens) {
      token.updateMetrics(selectorTrees.first, selectorTrees.toArray(), rejectorTrees.toArray());
    }
  }
  _updateRoot() {
    if (this.selected.length === 0)
      return;
    this._queryCache = /* @__PURE__ */ new Map();
    this._doc = this._selected.first.ownerDocument;
    this._root = this._doc.documentElement;
    for (let node2 of this._selected) {
      if (node2.ownerDocument !== this._doc)
        throw new Error("elements do not belong to the same document");
    }
    for (let node2 of this._rejected) {
      if (node2.ownerDocument !== this._doc)
        throw new Error("elements do not belong to the same document");
    }
  }
}
class Get extends Core {
  constructor(selected, options) {
    super(options);
    this._selected = new XSet(selected);
    this._updateRoot();
  }
  _checkConvergence(selectorTree, lastQueried, unsatisfied) {
    let queried = this._query(selectorTree);
    if (!this._checkTreeValidity(selectorTree)) {
      console.log("tree", [...selectorTree.tokens]);
      console.log("query", this._buildQuery(selectorTree));
      throw new Error("not a valid tree was built");
    }
    if (queried.isEqualTo(unsatisfied))
      return 2;
    if (queried.isSubsetOf(unsatisfied))
      return 3;
    if (queried.isSubsetOf(lastQueried) && !queried.isEqualTo(lastQueried))
      return 1;
    return 0;
  }
  _addToken(selectorTree, token, unsatisfied) {
    let tree = selectorTree.clone();
    let lastQueried = this._query(tree);
    tree.addToken(token);
    let convergence = this._checkConvergence(tree, lastQueried, unsatisfied);
    return { convergence, tree };
  }
  _shakeTree(tree, tokenBuildOrder) {
    let queried = this._query(tree);
    let tokens = tokenBuildOrder.filter((token) => tree.tokens.includes(token));
    tokens = tokens.reverse();
    for (let token of tokens) {
      this.debug && console.log("removing", token.type, token.name, token.value, token.depth, token.offset);
      tree.removeToken(token);
      let newQueried = this._query(tree);
      if (!newQueried.isSubsetOf(this._selected) || !newQueried.has(tree.targetNode) || !queried.isSubsetOf(newQueried)) {
        this.debug && console.log("added back");
        tree.addToken(token);
      } else {
        this.debug && console.log("query", this._buildQuery(tree));
      }
    }
  }
  async _simplify(unsatisfied) {
    this.debug && console.log("number of unsatisified", unsatisfied.length);
    let selectorTrees = this._getSelectorTreeArr(unsatisfied);
    let tokenBuildOrder = await this._getOrderedTokens(selectorTrees);
    if (!this._checkTreeValidity(selectorTrees.first) || !(this._query(selectorTrees.first).length === 1)) {
      this.reset();
      throw new Error("not a valid tree was built " + this._buildQuery(selectorTrees.first));
    }
    let selectorTree = selectorTrees.first.clone(true);
    this.debug && Token.printTokens(tokenBuildOrder, this._weights);
    let convergence = 0;
    for (let token of tokenBuildOrder) {
      this._timeout();
      this.debug && console.log(token.type, token.name, token.value, token.depth, token.offset);
      let status = this._addToken(selectorTree, token, unsatisfied);
      selectorTree = status.tree;
      convergence = status.convergence;
      this.debug && console.log("status", status.convergence, "selector", this._buildQuery(selectorTree));
      if (convergence >= 2)
        break;
    }
    this.debug && console.log("after loop", this._buildQuery(selectorTree));
    this._shakeTree(selectorTree, tokenBuildOrder);
    this.debug && console.log("after shake tree", this._buildQuery(selectorTree));
    return selectorTree;
  }
}
class GetCSS extends Get {
  constructor(selected, options) {
    super(selected, options);
    this._tokenOpts.text = false;
    this._unionSeparator = " , ";
  }
  _buildQuery(selectorTree) {
    selectorTree = this._removeBadTokens(selectorTree);
    return buildQuery(selectorTree);
  }
  _querySelectorAll(selector) {
    if (!selector)
      return new XSet();
    if (!this._doc)
      throw new Error("document not set");
    return new XSet(Array.from(this._doc.querySelectorAll(selector)));
  }
}
async function getCSS(selected, options) {
  return await new GetCSS(selected, options)._predict();
}
async function getCss(selected, options) {
  console.warn("Deprecated getCss is deprecated and will be discontinued from 1-Jan-2023, please use getCSS");
  return await getCSS(selected, options);
}
class Similar extends Core {
  constructor(options) {
    super();
    this._latestAction = Similar.NO_ACTION;
    this._similar = new XSet();
    this._tokenOpts.partAttrib = false;
    this._tokenOpts.text = false;
    this._tokenOpts.siblingNodes = false;
    this._weights = similarWeights;
    if (options && options.debug)
      this.debug = options.debug;
  }
  async addRejection(node2) {
    await this._add(node2, this._rejected, this._selected, Similar.ADDED_REJECTION);
  }
  async addSelection(node2) {
    await this._add(node2, this._selected, this._rejected, Similar.ADDED_SELECTION);
  }
  async removeRejection(node2) {
    await this._remove(node2, this._rejected, Similar.REMOVED_REJECTION);
  }
  async removeSelection(node2) {
    await this._remove(node2, this._selected, Similar.REMOVED_SELECTION);
  }
  async update() {
    this._updateRoot();
    if (this._selected.length === 0)
      throw new Error("empty list of selected");
    await this._predict();
    let preds = XSet.flatten(this._selectorTrees.mapToSet((tree) => this._query(tree)));
    this._similar = preds.difference(this._selected);
  }
  get similar() {
    return [...this._similar];
  }
  isSimilar(node2) {
    return this._similar.has(node2);
  }
  reset() {
    super.reset();
    this._rejected = new XSet();
    this._similar = new XSet();
    this._latestAction = Similar.NO_ACTION;
  }
  async set(targArr) {
    let target = new XSet(targArr);
    this.reset();
    let match = false;
    let pending = target.clone();
    while (pending.length > 0) {
      let node2 = pending.first;
      await this.addSelection(node2);
      let rejectables = this._similar.difference(target);
      while (rejectables.length > 0) {
        await this.addRejection(rejectables.first);
        rejectables = this._similar.difference(target);
      }
      let preds = this.selected.concat(this.similar);
      pending = target.filter((node3) => !preds.includes(node3));
      if (pending.length === 0 && rejectables.length === 0) {
        match = true;
        break;
      }
    }
    if (!match)
      throw new Error("could not create a set of selection and rejection for the given list of elements");
  }
  async _add(node2, addList, remList, status) {
    if (addList.length > 0 && this._doc != node2.ownerDocument) {
      throw new Error("element not part of document");
    }
    if (remList.length > 0 && this._doc != node2.ownerDocument) {
      throw new Error("element not part of document");
    }
    if (remList.has(node2)) {
      remList.delete(node2);
    }
    if (!addList.has(node2)) {
      addList.add(node2);
      this._latestAction = status;
      await this.update();
    }
  }
  get _additionalUnsatisfied() {
    let lastSimilar = this._latestAction === Similar.ADDED_SELECTION ? this._similar : new XSet();
    let queriedSoFar = XSet.flatten(this._selectorTrees.mapToSet((tree) => this._query(tree)));
    return lastSimilar.difference(queriedSoFar);
  }
  _buildQuery(selectorTree) {
    selectorTree = this._removeBadTokens(selectorTree);
    return buildQuery(selectorTree);
  }
  _isCoveringExtra(queried, lastQueried, unsatisfied) {
    let covered = queried.intersection(unsatisfied);
    let extra = covered.difference(lastQueried);
    return extra.size > 0;
  }
  _isDesiredSimplification(tree, unsatisfied, lastQueried) {
    let alreadyCovered = this._selected.difference(unsatisfied);
    let queried = this._query(tree);
    return this._checkTreeValidity(tree) && !queried.intersects(alreadyCovered) && !queried.intersects(this._rejected) && (this._unAffectingDiscard(queried, lastQueried) || this._isCoveringExtra(queried, lastQueried, unsatisfied));
  }
  _isDoneSimplifying(queried, unsatisfied) {
    return unsatisfied.isSubsetOf(queried);
  }
  _querySelectorAll(selector) {
    if (!selector)
      return new XSet();
    let queried = Array.from(this._root.querySelectorAll(selector));
    return new XSet(queried);
  }
  async _remove(node2, remList, status) {
    if (remList.length > 0 && this._doc != node2.ownerDocument) {
      throw new Error("element not part of document");
    }
    if (remList.has(node2)) {
      remList.delete(node2);
      this._latestAction = status;
      await this.update();
    }
  }
  async _simplify(unsatisfied) {
    unsatisfied = unsatisfied.union(this._additionalUnsatisfied);
    let selectorTrees = this._getSelectorTreeArr(unsatisfied);
    let discardOrder = (await this._getOrderedTokens(selectorTrees)).reverse();
    this.debug && Token.printTokens(discardOrder, this._weights);
    if (!this._checkTreeValidity(selectorTrees.first) || !(this._query(selectorTrees.first).length === 1)) {
      this.reset();
      throw new Error("not a valid tree was built " + this._buildQuery(selectorTrees.first));
    }
    let selectorTree = selectorTrees.first.clone();
    let lastQueried = this._query(selectorTree);
    for (let discardable of discardOrder) {
      this._timeout();
      selectorTree.removeToken(discardable);
      if (this._isDesiredSimplification(selectorTree, unsatisfied, lastQueried)) {
        lastQueried = this._query(selectorTree);
      } else {
        selectorTree.addToken(discardable);
      }
      if (this._isDoneSimplifying(lastQueried, unsatisfied))
        break;
    }
    return selectorTree;
  }
  _unAffectingDiscard(queried, lastQueried) {
    return lastQueried.isEqualTo(queried);
  }
  _updateRoot() {
    super._updateRoot();
    let updated = true;
    while (updated) {
      updated = false;
      for (let child of Array.from(this._root.childNodes)) {
        if (this.selected.every((node2) => child.contains(node2)) && this.selected.every((node2) => node2 != child)) {
          this._root = child;
          updated = true;
        }
      }
    }
  }
}
Similar.ADDED_SELECTION = 1;
Similar.REMOVED_SELECTION = 2;
Similar.ADDED_REJECTION = 3;
Similar.REMOVED_REJECTION = 4;
Similar.NO_ACTION = 0;
var recorder = "";
function create_fragment$F(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  let div1_levels = [
    {
      class: div1_class_value = "bbx-progress " + ctx[0]
    },
    ctx[1]
  ];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign$1(div_data_1, div1_levels[i2]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "bbx-indeterminate");
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, [dirty]) {
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        dirty & 1 && div1_class_value !== (div1_class_value = "bbx-progress " + ctx2[0]) && { class: div1_class_value },
        dirty & 2 && ctx2[1]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  const omit_props_names = ["classes"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { classes: classes2 = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("classes" in $$new_props)
      $$invalidate(0, classes2 = $$new_props.classes);
  };
  return [classes2, $$restProps];
}
class Progress extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$F, safe_not_equal, { classes: 0 });
  }
}
function create_if_block_1$e(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$m(ctx) {
  let progress;
  let current;
  progress = new Progress({});
  return {
    c() {
      create_component(progress.$$.fragment);
    },
    m(target, anchor) {
      mount_component(progress, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(progress.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progress.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(progress, detaching);
    }
  };
}
function create_fragment$E(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let current;
  let if_block0 = ctx[1] && create_if_block_1$e(ctx);
  let if_block1 = ctx[0] && create_if_block$m();
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      attr(div0, "class", "bbx-browser-body bbx-border");
      attr(div1, "class", "bbx-browser");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t1);
      append(div1, div0);
      ctx[4](div0);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$e(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0]) {
        if (if_block1) {
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$m();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[4](null);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let { bbx } = $$props;
  let loading2 = true;
  let loadError2;
  let view;
  const dispatch = createEventDispatcher();
  let container;
  onMount(async () => {
    try {
      view = await createView({ ...bbx, container });
      dispatch("ready", view);
    } catch (e) {
      $$invalidate(1, loadError2 = e);
      dispatch("error", e);
    }
    $$invalidate(0, loading2 = false);
  });
  onDestroy(() => {
    view.close();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(2, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("bbx" in $$props2)
      $$invalidate(3, bbx = $$props2.bbx);
  };
  return [loading2, loadError2, container, bbx, div0_binding];
}
class Browser$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$E, safe_not_equal, { bbx: 3 });
  }
}
function create_fragment$D(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.innerHTML = `<div class="bbx-header bbx-pad bbx-border">Inspector</div> 
  <div class="bbx-pad">Placeholder for DOM Inspector</div>`;
      attr(div2, "class", "bbx-inspector");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
class Inspector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$D, safe_not_equal, {});
  }
}
function create_fragment$C(ctx) {
  let div2;
  let t0;
  let div0;
  let t2;
  let div1;
  let treeview;
  let div2_class_value;
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  treeview = new TreeView({ props: { tree: ctx[1] } });
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      t0 = space();
      div0 = element("div");
      div0.innerHTML = `<span class="bbx-flex-grow">Macro</span>`;
      t2 = space();
      div1 = element("div");
      create_component(treeview.$$.fragment);
      attr(div0, "class", "bbx-subheader bbx-flex");
      set_style(div1, "height", "70%");
      attr(div2, "class", div2_class_value = "bbx-sidebar " + ctx[0]);
      toggle_class(div2, "active", ctx[2] === "replay");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append(div2, t0);
      append(div2, div0);
      append(div2, t2);
      append(div2, div1);
      mount_component(treeview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      const treeview_changes = {};
      if (dirty & 2)
        treeview_changes.tree = ctx2[1];
      treeview.$set(treeview_changes);
      if (!current || dirty & 1 && div2_class_value !== (div2_class_value = "bbx-sidebar " + ctx2[0])) {
        attr(div2, "class", div2_class_value);
      }
      if (!current || dirty & 5) {
        toggle_class(div2, "active", ctx2[2] === "replay");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(treeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(treeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(treeview);
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let $statusStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  const statusStore = getContext("statusStore");
  component_subscribe($$self, statusStore, (value) => $$invalidate(2, $statusStore = value));
  let { class: clazz = "" } = $$props;
  let { tree } = $$props;
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("tree" in $$props2)
      $$invalidate(1, tree = $$props2.tree);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [clazz, tree, $statusStore, statusStore, $$scope, slots];
}
class Sidebar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$C, safe_not_equal, { class: 0, tree: 1 });
  }
}
function create_if_block_5$3(ctx) {
  let select;
  let option0;
  let option1;
  let mounted;
  let dispose;
  return {
    c() {
      select = element("select");
      option0 = element("option");
      option0.textContent = "Enter";
      option1 = element("option");
      option1.textContent = "Backspace";
      option0.__value = "Enter";
      option0.value = option0.__value;
      option1.__value = "Backspace";
      option1.value = option1.__value;
      set_style(select, "width", "100%");
      set_style(select, "box-sizing", "border-box");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option0);
      append(select, option1);
      select_option(select, ctx[0]);
      if (!mounted) {
        dispose = listen(select, "change", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        select_option(select, ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$5(ctx) {
  let div;
  let input0;
  let input0_value_value;
  let t;
  let input1;
  let input1_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t = space();
      input1 = element("input");
      attr(input0, "type", "number");
      attr(input0, "min", "0");
      attr(input0, "max", "99999");
      input0.value = input0_value_value = ctx[0].x;
      set_style(input0, "width", "50%");
      set_style(input0, "box-sizing", "border-box");
      attr(input1, "type", "number");
      attr(input1, "min", "0");
      attr(input1, "max", "99999");
      input1.value = input1_value_value = ctx[0].y;
      set_style(input1, "width", "50%");
      set_style(input1, "box-sizing", "border-box");
      attr(div, "class", "bbx-flex bbx-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      append(div, t);
      append(div, input1);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[7]),
          listen(input1, "input", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input0_value_value !== (input0_value_value = ctx2[0].x) && input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if (dirty & 1 && input1_value_value !== (input1_value_value = ctx2[0].y) && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3$9(ctx) {
  let select;
  let option0;
  let t0;
  let option1;
  let t1;
  let option1_selected_value;
  let mounted;
  let dispose;
  return {
    c() {
      select = element("select");
      option0 = element("option");
      t0 = text("true");
      option1 = element("option");
      t1 = text("false");
      option0.__value = "true";
      option0.value = option0.__value;
      option0.selected = ctx[0];
      option1.__value = "false";
      option1.value = option1.__value;
      option1.selected = option1_selected_value = !ctx[0];
      set_style(select, "width", "100%");
      set_style(select, "box-sizing", "border-box");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option0);
      append(option0, t0);
      append(select, option1);
      append(option1, t1);
      if (!mounted) {
        dispose = listen(select, "change", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        option0.selected = ctx2[0];
      }
      if (dirty & 1 && option1_selected_value !== (option1_selected_value = !ctx2[0])) {
        option1.selected = option1_selected_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$9(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "number");
      input.value = ctx[0];
      set_style(input, "width", "100%");
      set_style(input, "box-sizing", "border-box");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$d(ctx) {
  let input;
  let input_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      input.value = input_value_value = ctx[0].value;
      set_style(input, "width", "100%");
      set_style(input, "box-sizing", "border-box");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input_value_value !== (input_value_value = ctx2[0].value) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$l(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      input.value = ctx[0];
      set_style(input, "width", "100%");
      set_style(input, "box-sizing", "border-box");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$B(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === "string")
      return create_if_block$l;
    if (ctx2[1] === "selector")
      return create_if_block_1$d;
    if (ctx2[1] === "number")
      return create_if_block_2$9;
    if (ctx2[1] === "boolean")
      return create_if_block_3$9;
    if (ctx2[1] === "position")
      return create_if_block_4$5;
    if (ctx2[1] === "keycode")
      return create_if_block_5$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { value } = $$props;
  let { type } = $$props;
  const input_handler = (event) => dispatch("change", { newValue: event.target.value });
  const input_handler_1 = (e) => dispatch("change", {
    newValue: { ...value, value: e.target.value }
  });
  const input_handler_2 = (event) => dispatch("change", { newValue: event.target.valueAsNumber });
  const change_handler = (event) => dispatch("change", { newValue: event.target.value === "true" });
  const input_handler_3 = (e) => dispatch("change", {
    newValue: { ...value, x: e.target.value }
  });
  const input_handler_4 = (e) => dispatch("change", {
    newValue: { ...value, y: e.target.value }
  });
  const change_handler_1 = (e) => dispatch("change", { newValue: e.target.value });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
  };
  return [
    value,
    type,
    dispatch,
    input_handler,
    input_handler_1,
    input_handler_2,
    change_handler,
    input_handler_3,
    input_handler_4,
    change_handler_1
  ];
}
class Input extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$B, safe_not_equal, { value: 0, type: 1 });
  }
}
function get_each_context$d(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  child_ctx[9] = list;
  child_ctx[10] = i2;
  return child_ctx;
}
function create_if_block$k(ctx) {
  let tr;
  let td0;
  let code0;
  let t0_value = ctx[8].name + "";
  let t0;
  let t1;
  let td1;
  let code1;
  let t2_value = ctx[8].type + "";
  let t2;
  let t3;
  let td2;
  let input;
  let t4;
  let current;
  function change_handler(...args) {
    return ctx[5](ctx[8], ctx[9], ctx[10], ...args);
  }
  input = new Input({
    props: {
      value: ctx[8].value,
      type: ctx[8].type
    }
  });
  input.$on("change", change_handler);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      code0 = element("code");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      code1 = element("code");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      create_component(input.$$.fragment);
      t4 = space();
      attr(td0, "class", "bbx-pad-y");
      attr(td1, "class", "bbx-pad-y");
      attr(td2, "class", "bbx-pad-y");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, code0);
      append(code0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, code1);
      append(code1, t2);
      append(tr, t3);
      append(tr, td2);
      mount_component(input, td2, null);
      append(tr, t4);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 2) && t0_value !== (t0_value = ctx[8].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 2) && t2_value !== (t2_value = ctx[8].type + ""))
        set_data(t2, t2_value);
      const input_changes = {};
      if (dirty & 2)
        input_changes.value = ctx[8].value;
      if (dirty & 2)
        input_changes.type = ctx[8].type;
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_component(input);
    }
  };
}
function create_each_block$d(ctx) {
  let show_if = ctx[4].hasVariable(ctx[8].name);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block$k(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        show_if = ctx2[4].hasVariable(ctx2[8].name);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$k(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot$f(ctx) {
  let table;
  let thead;
  let t5;
  let tbody;
  let current;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$d(get_each_context$d(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="bbx-pad-y bbx-text-left">Name</th> 
      <th class="bbx-pad-y bbx-text-left">Type</th> 
      <th class="bbx-pad-y bbx-text-left">Value</th></tr>`;
      t5 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      set_style(table, "width", "50rem");
      set_style(table, "text-align", "left");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, thead);
      append(table, t5);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 18) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$d(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(tbody, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$A(ctx) {
  let savecancelmodal;
  let current;
  savecancelmodal = new SaveCancelModal({
    props: {
      title: "Enter parameters for replay",
      rect: ctx[0],
      actionLabel: "Replay",
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  savecancelmodal.$on("save", ctx[6]);
  savecancelmodal.$on("cancel", ctx[7]);
  return {
    c() {
      create_component(savecancelmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savecancelmodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savecancelmodal_changes = {};
      if (dirty & 1)
        savecancelmodal_changes.rect = ctx2[0];
      if (dirty & 2050) {
        savecancelmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savecancelmodal.$set(savecancelmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savecancelmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savecancelmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savecancelmodal, detaching);
    }
  };
}
function instance$z($$self, $$props, $$invalidate) {
  let $params;
  const dispatch = createEventDispatcher();
  const params2 = getContext("params");
  component_subscribe($$self, params2, (value) => $$invalidate(1, $params = value));
  const steps = getContext("steps");
  let { rect } = $$props;
  const change_handler = (param, each_value, param_index, e) => set_store_value(params2, each_value[param_index].value = e.detail.newValue, $params);
  const save_handler = () => dispatch("save");
  const cancel_handler = () => dispatch("cancel");
  $$self.$$set = ($$props2) => {
    if ("rect" in $$props2)
      $$invalidate(0, rect = $$props2.rect);
  };
  return [
    rect,
    $params,
    dispatch,
    params2,
    steps,
    change_handler,
    save_handler,
    cancel_handler
  ];
}
class Prompt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$A, safe_not_equal, { rect: 0 });
  }
}
class ListStore {
  constructor(initialList = []) {
    __publicField(this, "list");
    __publicField(this, "subscribe");
    __publicField(this, "set");
    __publicField(this, "update");
    this.list = writable([...initialList]);
    this.subscribe = this.list.subscribe;
    this.set = this.list.set;
    this.update = this.list.update;
  }
  get ref() {
    return get_store_value(this.list);
  }
  add(item) {
    this.update((list) => {
      list.push(item);
      return list;
    });
  }
  insert(idx, item) {
    this.update((list) => {
      list.splice(idx, 0, item);
      return list;
    });
  }
  remove(item) {
    this.update((list) => {
      let idx = list.indexOf(item);
      list.splice(idx, 1);
      return list;
    });
  }
  replace(oldItem, newItem) {
    this.update((list) => {
      let idx = list.indexOf(oldItem);
      list[idx] = newItem;
      return list;
    });
  }
  reset() {
    this.update((list) => {
      list.splice(0, list.length);
      return list;
    });
  }
}
class ParamsStore extends ListStore {
  getParam(name) {
    return this.ref.find((param) => param.name === name);
  }
  getReferenced(tree) {
    let references = [];
    for (let node2 of tree.iterator()) {
      if (node2.type === "VARIABLE_REFERENCE") {
        references.push(node2);
      }
    }
    return this.ref.filter((param) => references.includes(param));
  }
  getStatements(steps) {
    return this.getReferenced(steps).map((p) => ["var", p.name, p.value]);
  }
}
function StatusStore() {
  return writable("ready");
}
function ErrorStore() {
  return writable({
    message: "",
    nodeStack: []
  });
}
const KEY_FV_DATA = "bbx:fr:overlay";
class Target extends TargetBase {
  constructor(el, _overlay) {
    super(el);
    __publicField(this, "active", false);
  }
  setActive(active) {
    if (this.active != active) {
      this.active = active;
      this.emit("change");
    }
  }
}
class PickerFrameOverlay extends CanvasFrameOverlay {
  constructor(fv, el, frameIndex, selector) {
    super(fv, el);
    __publicField(this, "selector");
    __publicField(this, "frameIndex");
    __publicField(this, "currentElement");
    __publicField(this, "currentTarget");
    this.selector = selector;
    this.frameIndex = frameIndex;
    this.updateTargets();
    this.onClick = this.onClick.bind(this);
  }
  updateTargets() {
    this.clearTargets();
    this.setTargets();
  }
  async setTargets() {
    if (!this.selector)
      return;
    let els = await this.selector.select(this.fv.getDoc());
    els.forEach((el) => {
      let target = new Target(el, this);
      if (el == this.currentElement) {
        this.setCurrentTarget(target);
      }
      this.addTarget(target);
    });
  }
  removeCurrentTarget() {
    if (this.currentTarget) {
      this.currentTarget.setActive(false);
    }
  }
  setCurrentTarget(target) {
    this.currentTarget = target;
    target.setActive(true);
  }
  async onClick(el) {
    this.selector = new CSSSelector(await getCss([el]));
    this.updateTargets();
    this.emit("change", { selector: this.selector, frameIndex: this.frameIndex });
  }
  onHover(el, { target }) {
    this.currentElement = el;
    if (target && target.get() == el) {
      this.setHoverTarget(null);
    } else {
      this.setHoverTarget(el);
    }
    this.removeCurrentTarget();
    if (target) {
      this.setCurrentTarget(target);
    }
  }
  getTargetStyles(target) {
    let styles = super.getTargetStyles(target);
    if (target.active) {
      styles.lineWidth = 2;
    }
    return styles;
  }
}
class PickerPageOverlay extends PageOverlay {
  constructor(page, selector, selectorFrameIndex) {
    super(page);
    __publicField(this, "selector");
    __publicField(this, "selectorFrameIndex");
    __publicField(this, "onChange", ({ selector, frameIndex }) => {
      this.selector = selector;
      this.emit("change", { selector: selector.toJSON(), frameIndex });
    });
    __publicField(this, "onClose", () => {
      this.setActive(false);
    });
    this.selector = selector;
    this.selectorFrameIndex = selectorFrameIndex;
  }
  createFrameOverlay(fv, el) {
    let index2 = fv.store.getIndex();
    let pickerFrameOverlay;
    if (index2 === this.selectorFrameIndex) {
      pickerFrameOverlay = new PickerFrameOverlay(fv, el, index2, this.selector);
    } else {
      pickerFrameOverlay = new PickerFrameOverlay(fv, el, index2);
    }
    pickerFrameOverlay.on("change", this.onChange);
    pickerFrameOverlay.on("close", this.onClose);
    return pickerFrameOverlay;
  }
  afterUninit(fv) {
    let frameOverlay = fv.getData(KEY_FV_DATA);
    if (frameOverlay) {
      frameOverlay.off("change", this.onChange);
      frameOverlay.off("close", this.onClose);
    }
    super.afterUninit(fv);
  }
}
function create_default_slot_1$5(ctx) {
  let tick_1;
  let current;
  tick_1 = new Tick({ props: { strokeColor: "blue" } });
  return {
    c() {
      create_component(tick_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tick_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tick_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tick_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tick_1, detaching);
    }
  };
}
function create_default_slot$e(ctx) {
  let cross;
  let current;
  cross = new Cross({ props: { strokeColor: "red" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_fragment$z(ctx) {
  let div1;
  let div0;
  let input;
  let input_value_value;
  let t0;
  let iconbtn0;
  let t1;
  let iconbtn1;
  let current;
  iconbtn0 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  iconbtn0.$on("click", ctx[6]);
  iconbtn1 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  iconbtn1.$on("click", ctx[7]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      create_component(iconbtn0.$$.fragment);
      t1 = space();
      create_component(iconbtn1.$$.fragment);
      attr(input, "type", "text");
      input.value = input_value_value = ctx[0].value;
      input.disabled = true;
      attr(div0, "class", "bbx-flex bbx-align-center bbx-justify-center bbx-gap bbx-pad-x");
      set_style(div0, "height", "35px");
      set_style(div0, "background-color", "#888888");
      attr(div1, "class", "bbx-flex bbx-justify-center");
      set_style(div1, "width", "100vw");
      set_style(div1, "position", "fixed");
      set_style(div1, "top", "0");
      set_style(div1, "left", "0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input);
      append(div0, t0);
      mount_component(iconbtn0, div0, null);
      append(div0, t1);
      mount_component(iconbtn1, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1 && input_value_value !== (input_value_value = ctx2[0].value) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      const iconbtn0_changes = {};
      if (dirty & 1024) {
        iconbtn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn0.$set(iconbtn0_changes);
      const iconbtn1_changes = {};
      if (dirty & 1024) {
        iconbtn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn1.$set(iconbtn1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn0.$$.fragment, local);
      transition_in(iconbtn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn0.$$.fragment, local);
      transition_out(iconbtn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(iconbtn0);
      destroy_component(iconbtn1);
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { browserView } = $$props;
  let { selector } = $$props;
  let { frame } = $$props;
  let newSelector;
  let newFrame;
  let pickerOverlay;
  if (browserView) {
    let pageView = browserView.getPage(-1);
    if (selector.type === "css") {
      selector = new CSSSelector(selector.value, selector.meta);
    } else if (selector.type === "xpath") {
      selector = new XPathSelector(selector.value, selector.meta);
    }
    pickerOverlay = new PickerPageOverlay(pageView, selector, frame);
    pickerOverlay.on("change", changeSelector);
    pickerOverlay.setActive(true);
    newSelector = selector;
    newFrame = frame;
  } else {
    throw new Error("browser view is undefined");
  }
  function changeSelector(e) {
    $$invalidate(0, newSelector = e.selector);
    $$invalidate(1, newFrame = e.frameIndex);
  }
  onDestroy(() => {
    pickerOverlay.off("change", changeSelector);
    pickerOverlay == null ? void 0 : pickerOverlay.setActive(false);
    pickerOverlay = null;
  });
  const click_handler = () => dispatch("save", { selector: newSelector, frame: newFrame });
  const click_handler_1 = () => dispatch("cancel");
  $$self.$$set = ($$props2) => {
    if ("browserView" in $$props2)
      $$invalidate(4, browserView = $$props2.browserView);
    if ("selector" in $$props2)
      $$invalidate(3, selector = $$props2.selector);
    if ("frame" in $$props2)
      $$invalidate(5, frame = $$props2.frame);
  };
  return [
    newSelector,
    newFrame,
    dispatch,
    selector,
    browserView,
    frame,
    click_handler,
    click_handler_1
  ];
}
class PickerPanel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$z, safe_not_equal, { browserView: 4, selector: 3, frame: 5 });
  }
}
const get_tb_r_r_slot_changes = (dirty) => ({});
const get_tb_r_r_slot_context = (ctx) => ({});
const get_tb_r_l_slot_changes = (dirty) => ({});
const get_tb_r_l_slot_context = (ctx) => ({});
const get_tb_url_r_slot_changes = (dirty) => ({});
const get_tb_url_r_slot_context = (ctx) => ({});
const get_tb_url_l_slot_changes = (dirty) => ({});
const get_tb_url_l_slot_context = (ctx) => ({});
const get_tb_l_slot_changes = (dirty) => ({});
const get_tb_l_slot_context = (ctx) => ({});
function create_else_block$j(ctx) {
  let button;
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text("Start Recording");
      attr(button, "class", "bbx-btn");
      button.disabled = button_disabled_value = ctx[3] === "replay";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[18]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8 && button_disabled_value !== (button_disabled_value = ctx2[3] === "replay")) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$8(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Stop Recording";
      attr(button, "class", "bbx-btn");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[19]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$4(ctx) {
  let t;
  return {
    c() {
      t = text("Reset Steps");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[22]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty[1] & 512) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot$d(ctx) {
  let div0;
  let t1;
  let div2;
  let t2;
  let div1;
  let t3;
  let button0;
  let t4;
  let button0_disabled_value;
  let t5;
  let button1;
  let t6;
  let button1_disabled_value;
  let t7;
  let menubtn;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3] === "record")
      return create_if_block_3$8;
    return create_else_block$j;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  menubtn = new MenuBtn({
    props: {
      class: "bbx-pad-x",
      $$slots: { items: [create_items_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      div0.textContent = "Recorder";
      t1 = space();
      div2 = element("div");
      if_block.c();
      t2 = space();
      div1 = element("div");
      t3 = space();
      button0 = element("button");
      t4 = text("Replay");
      t5 = space();
      button1 = element("button");
      t6 = text("Stop");
      t7 = space();
      create_component(menubtn.$$.fragment);
      attr(div0, "class", "bbx-header bbx-pad");
      set_style(div1, "flex", "1");
      attr(button0, "class", "bbx-btn");
      button0.disabled = button0_disabled_value = ctx[3] === "replay";
      attr(button1, "class", "bbx-btn");
      button1.disabled = button1_disabled_value = ctx[3] !== "replay";
      attr(div2, "class", "bbx-tb bbx-pad bbx-gap bbx-border-b");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      if_block.m(div2, null);
      append(div2, t2);
      append(div2, div1);
      append(div2, t3);
      append(div2, button0);
      append(button0, t4);
      append(div2, t5);
      append(div2, button1);
      append(button1, t6);
      append(div2, t7);
      mount_component(menubtn, div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[21]),
          listen(button1, "click", ctx[20])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, t2);
        }
      }
      if (!current || dirty[0] & 8 && button0_disabled_value !== (button0_disabled_value = ctx2[3] === "replay")) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty[0] & 8 && button1_disabled_value !== (button1_disabled_value = ctx2[3] !== "replay")) {
        button1.disabled = button1_disabled_value;
      }
      const menubtn_changes = {};
      if (dirty[1] & 512) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menubtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menubtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div2);
      if_block.d();
      destroy_component(menubtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$8(ctx) {
  let inspector_1;
  let current;
  inspector_1 = new Inspector({});
  return {
    c() {
      create_component(inspector_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inspector_1, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(inspector_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inspector_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inspector_1, detaching);
    }
  };
}
function create_if_block_1$c(ctx) {
  let prompt;
  let current;
  prompt = new Prompt({ props: { rect: ctx[7] } });
  prompt.$on("save", ctx[27]);
  prompt.$on("cancel", ctx[28]);
  return {
    c() {
      create_component(prompt.$$.fragment);
    },
    m(target, anchor) {
      mount_component(prompt, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const prompt_changes = {};
      if (dirty[0] & 128)
        prompt_changes.rect = ctx2[7];
      prompt.$set(prompt_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(prompt.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(prompt.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(prompt, detaching);
    }
  };
}
function create_if_block$j(ctx) {
  let pickerpanel;
  let current;
  pickerpanel = new PickerPanel({
    props: {
      browserView: ctx[4],
      frame: ctx[10],
      selector: ctx[9]
    }
  });
  pickerpanel.$on("save", ctx[29]);
  pickerpanel.$on("cancel", ctx[30]);
  return {
    c() {
      create_component(pickerpanel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pickerpanel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pickerpanel_changes = {};
      if (dirty[0] & 16)
        pickerpanel_changes.browserView = ctx2[4];
      if (dirty[0] & 1024)
        pickerpanel_changes.frame = ctx2[10];
      if (dirty[0] & 512)
        pickerpanel_changes.selector = ctx2[9];
      pickerpanel.$set(pickerpanel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pickerpanel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pickerpanel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pickerpanel, detaching);
    }
  };
}
function create_fragment$y(ctx) {
  let div5;
  let div3;
  let div1;
  let button0;
  let t1;
  let button1;
  let t3;
  let t4;
  let div2;
  let svg;
  let image;
  let image_href_value;
  let t5;
  let t6;
  let input;
  let t7;
  let t8;
  let a;
  let t10;
  let t11;
  let t12;
  let button2;
  let t14;
  let button3;
  let t16;
  let div4;
  let browser_1;
  let t17;
  let sidebar;
  let t18;
  let t19;
  let t20;
  let div5_class_value;
  let current;
  let mounted;
  let dispose;
  const tb_l_slot_template = ctx[37]["tb-l"];
  const tb_l_slot = create_slot(tb_l_slot_template, ctx, ctx[40], get_tb_l_slot_context);
  const tb_url_l_slot_template = ctx[37]["tb-url-l"];
  const tb_url_l_slot = create_slot(tb_url_l_slot_template, ctx, ctx[40], get_tb_url_l_slot_context);
  const tb_url_r_slot_template = ctx[37]["tb-url-r"];
  const tb_url_r_slot = create_slot(tb_url_r_slot_template, ctx, ctx[40], get_tb_url_r_slot_context);
  const tb_r_l_slot_template = ctx[37]["tb-r-l"];
  const tb_r_l_slot = create_slot(tb_r_l_slot_template, ctx, ctx[40], get_tb_r_l_slot_context);
  const tb_r_r_slot_template = ctx[37]["tb-r-r"];
  const tb_r_r_slot = create_slot(tb_r_r_slot_template, ctx, ctx[40], get_tb_r_r_slot_context);
  browser_1 = new Browser$1({ props: { bbx: ctx[2] } });
  browser_1.$on("ready", ctx[16]);
  browser_1.$on("error", onBrowserError);
  sidebar = new Sidebar({
    props: {
      tree: ctx[14],
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  sidebar.$on("delete", ctx[23]);
  let if_block0 = ctx[8] && create_if_block_2$8();
  let if_block1 = ctx[5] && create_if_block_1$c(ctx);
  let if_block2 = ctx[6] && create_if_block$j(ctx);
  let div5_levels = [
    {
      class: div5_class_value = "bbx-recorder " + ctx[1]
    },
    ctx[31]
  ];
  let div_data_5 = {};
  for (let i2 = 0; i2 < div5_levels.length; i2 += 1) {
    div_data_5 = assign$1(div_data_5, div5_levels[i2]);
  }
  return {
    c() {
      div5 = element("div");
      div3 = element("div");
      div1 = element("div");
      button0 = element("button");
      button0.innerHTML = `<div style="transform: translateY(-1px)">\u279C</div>`;
      t1 = space();
      button1 = element("button");
      button1.textContent = "\u279C";
      t3 = space();
      if (tb_l_slot)
        tb_l_slot.c();
      t4 = space();
      div2 = element("div");
      svg = svg_element("svg");
      image = svg_element("image");
      t5 = space();
      if (tb_url_l_slot)
        tb_url_l_slot.c();
      t6 = space();
      input = element("input");
      t7 = space();
      if (tb_url_r_slot)
        tb_url_r_slot.c();
      t8 = space();
      a = element("a");
      a.textContent = "Reload";
      t10 = space();
      if (tb_r_l_slot)
        tb_r_l_slot.c();
      t11 = space();
      if (tb_r_r_slot)
        tb_r_r_slot.c();
      t12 = space();
      button2 = element("button");
      button2.textContent = "Save";
      t14 = space();
      button3 = element("button");
      button3.textContent = "Cancel";
      t16 = space();
      div4 = element("div");
      create_component(browser_1.$$.fragment);
      t17 = space();
      create_component(sidebar.$$.fragment);
      t18 = space();
      if (if_block0)
        if_block0.c();
      t19 = space();
      if (if_block1)
        if_block1.c();
      t20 = space();
      if (if_block2)
        if_block2.c();
      attr(button0, "title", "Go Back");
      set_style(button0, "transform", "rotate(180deg)");
      attr(button1, "title", "Go Forward");
      attr(image, "href", image_href_value = "https://monitor.distill.io/v1/getfavicon?url=" + ctx[0]);
      attr(image, "width", "20");
      attr(image, "height", "20");
      attr(svg, "class", "bbx-favicon");
      input.disabled = true;
      attr(input, "class", "bbx-urlbar bbx-pad");
      attr(a, "href", "#");
      attr(a, "class", "bbx-action bbx-pad-x");
      attr(div2, "class", "bbx-urlbar bbx-align-center bbx-pad-x");
      attr(button2, "class", "bbx-primary");
      attr(div3, "class", "bbx-tb bbx-pad bbx-gap");
      attr(div4, "class", "bbx-recorder-body");
      set_attributes(div5, div_data_5);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div3);
      append(div3, div1);
      append(div1, button0);
      append(div1, t1);
      append(div1, button1);
      append(div3, t3);
      if (tb_l_slot) {
        tb_l_slot.m(div3, null);
      }
      append(div3, t4);
      append(div3, div2);
      append(div2, svg);
      append(svg, image);
      append(div2, t5);
      if (tb_url_l_slot) {
        tb_url_l_slot.m(div2, null);
      }
      append(div2, t6);
      append(div2, input);
      set_input_value(input, ctx[0]);
      append(div2, t7);
      if (tb_url_r_slot) {
        tb_url_r_slot.m(div2, null);
      }
      append(div2, t8);
      append(div2, a);
      append(div3, t10);
      if (tb_r_l_slot) {
        tb_r_l_slot.m(div3, null);
      }
      append(div3, t11);
      if (tb_r_r_slot) {
        tb_r_r_slot.m(div3, null);
      }
      append(div3, t12);
      append(div3, button2);
      append(div3, t14);
      append(div3, button3);
      append(div5, t16);
      append(div5, div4);
      mount_component(browser_1, div4, null);
      append(div4, t17);
      mount_component(sidebar, div4, null);
      append(div5, t18);
      if (if_block0)
        if_block0.m(div5, null);
      append(div5, t19);
      if (if_block1)
        if_block1.m(div5, null);
      append(div5, t20);
      if (if_block2)
        if_block2.m(div5, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[24]),
          listen(button1, "click", ctx[25]),
          listen(input, "input", ctx[38]),
          listen(a, "click", prevent_default(ctx[26])),
          listen(button2, "click", ctx[17]),
          listen(button3, "click", ctx[39])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (tb_l_slot) {
        if (tb_l_slot.p && (!current || dirty[1] & 512)) {
          update_slot_base(
            tb_l_slot,
            tb_l_slot_template,
            ctx2,
            ctx2[40],
            !current ? get_all_dirty_from_scope(ctx2[40]) : get_slot_changes(tb_l_slot_template, ctx2[40], dirty, get_tb_l_slot_changes),
            get_tb_l_slot_context
          );
        }
      }
      if (!current || dirty[0] & 1 && image_href_value !== (image_href_value = "https://monitor.distill.io/v1/getfavicon?url=" + ctx2[0])) {
        attr(image, "href", image_href_value);
      }
      if (tb_url_l_slot) {
        if (tb_url_l_slot.p && (!current || dirty[1] & 512)) {
          update_slot_base(
            tb_url_l_slot,
            tb_url_l_slot_template,
            ctx2,
            ctx2[40],
            !current ? get_all_dirty_from_scope(ctx2[40]) : get_slot_changes(tb_url_l_slot_template, ctx2[40], dirty, get_tb_url_l_slot_changes),
            get_tb_url_l_slot_context
          );
        }
      }
      if (dirty[0] & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (tb_url_r_slot) {
        if (tb_url_r_slot.p && (!current || dirty[1] & 512)) {
          update_slot_base(
            tb_url_r_slot,
            tb_url_r_slot_template,
            ctx2,
            ctx2[40],
            !current ? get_all_dirty_from_scope(ctx2[40]) : get_slot_changes(tb_url_r_slot_template, ctx2[40], dirty, get_tb_url_r_slot_changes),
            get_tb_url_r_slot_context
          );
        }
      }
      if (tb_r_l_slot) {
        if (tb_r_l_slot.p && (!current || dirty[1] & 512)) {
          update_slot_base(
            tb_r_l_slot,
            tb_r_l_slot_template,
            ctx2,
            ctx2[40],
            !current ? get_all_dirty_from_scope(ctx2[40]) : get_slot_changes(tb_r_l_slot_template, ctx2[40], dirty, get_tb_r_l_slot_changes),
            get_tb_r_l_slot_context
          );
        }
      }
      if (tb_r_r_slot) {
        if (tb_r_r_slot.p && (!current || dirty[1] & 512)) {
          update_slot_base(
            tb_r_r_slot,
            tb_r_r_slot_template,
            ctx2,
            ctx2[40],
            !current ? get_all_dirty_from_scope(ctx2[40]) : get_slot_changes(tb_r_r_slot_template, ctx2[40], dirty, get_tb_r_r_slot_changes),
            get_tb_r_r_slot_context
          );
        }
      }
      const browser_1_changes = {};
      if (dirty[0] & 4)
        browser_1_changes.bbx = ctx2[2];
      browser_1.$set(browser_1_changes);
      const sidebar_changes = {};
      if (dirty[0] & 8 | dirty[1] & 512) {
        sidebar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sidebar.$set(sidebar_changes);
      if (ctx2[8]) {
        if (if_block0) {
          if (dirty[0] & 256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$8();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div5, t19);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$c(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div5, t20);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[6]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$j(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div5, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      set_attributes(div5, div_data_5 = get_spread_update(div5_levels, [
        (!current || dirty[0] & 2 && div5_class_value !== (div5_class_value = "bbx-recorder " + ctx2[1])) && { class: div5_class_value },
        dirty[1] & 1 && ctx2[31]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_l_slot, local);
      transition_in(tb_url_l_slot, local);
      transition_in(tb_url_r_slot, local);
      transition_in(tb_r_l_slot, local);
      transition_in(tb_r_r_slot, local);
      transition_in(browser_1.$$.fragment, local);
      transition_in(sidebar.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(tb_l_slot, local);
      transition_out(tb_url_l_slot, local);
      transition_out(tb_url_r_slot, local);
      transition_out(tb_r_l_slot, local);
      transition_out(tb_r_r_slot, local);
      transition_out(browser_1.$$.fragment, local);
      transition_out(sidebar.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (tb_l_slot)
        tb_l_slot.d(detaching);
      if (tb_url_l_slot)
        tb_url_l_slot.d(detaching);
      if (tb_url_r_slot)
        tb_url_r_slot.d(detaching);
      if (tb_r_l_slot)
        tb_r_l_slot.d(detaching);
      if (tb_r_r_slot)
        tb_r_r_slot.d(detaching);
      destroy_component(browser_1);
      destroy_component(sidebar);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function onBrowserError(e) {
  console.error("onBrowserError", e.detail);
}
function instance$x($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "class",
    "proxy",
    "session",
    "bbx",
    "findSelector",
    "url",
    "initialSteps",
    "initialParams"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $errorStore;
  let $statusStore;
  let $params;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: clazz = "" } = $$props;
  let { proxy = null } = $$props;
  let { session = null } = $$props;
  let { bbx } = $$props;
  let { findSelector } = $$props;
  let { url } = $$props;
  let { initialSteps = [] } = $$props;
  let { initialParams = [] } = $$props;
  let browser2;
  let browserView;
  let browserContext = {};
  let recorder2;
  let player;
  let showParamsPrompt = false;
  let showPickerPanel = false;
  let modalProps = { top: 0, right: 0 };
  initialParams.forEach((p) => {
    var _a;
    return p.value = (_a = p.value) != null ? _a : getDefault(p.type);
  });
  const statusStore = StatusStore();
  component_subscribe($$self, statusStore, (value) => $$invalidate(3, $statusStore = value));
  const params2 = new ParamsStore([...initialParams]);
  component_subscribe($$self, params2, (value) => $$invalidate(47, $params = value));
  const errorStore = new ErrorStore();
  component_subscribe($$self, errorStore, (value) => $$invalidate(46, $errorStore = value));
  let tree = parseSteps(initialSteps);
  setContext("statusStore", statusStore);
  setContext("params", params2);
  setContext("browserContext", browserContext);
  setContext("openPickerPanel", openPickerPanel);
  setContext("errorStore", errorStore);
  let inspector = false;
  const dispatch = createEventDispatcher();
  async function onBrowserReady(e) {
    $$invalidate(4, browserView = e.detail);
    browser2 = browserView.store;
    browserContext.browser = browser2;
    browserContext.browserView = browserView;
    recorder2 = new Base(browserView, findSelector, tree);
    if (initialSteps.length === 0) {
      await wait$2(1e3);
      await record();
    }
    goto();
  }
  function onSave(e) {
    dispatch("save", {
      steps: tree.toJSON(),
      params: $params.map(({ name, type }) => ({ name, type }))
    });
  }
  async function goto(_url = url) {
    await browser2.pages[0].goto(_url);
  }
  async function record() {
    if ($statusStore !== "ready")
      return;
    recorder2.start();
    set_store_value(statusStore, $statusStore = "record", $statusStore);
  }
  async function stopRecording() {
    recorder2 == null ? void 0 : recorder2.stop();
    set_store_value(statusStore, $statusStore = "ready", $statusStore);
  }
  async function stopReplay() {
    player == null ? void 0 : player.interrupt();
  }
  function replay(e) {
    if ($statusStore === "record") {
      stopRecording();
    }
    if ($statusStore !== "ready")
      return;
    set_store_value(statusStore, $statusStore = "replay", $statusStore);
    $$invalidate(7, modalProps = e.target.getBoundingClientRect());
    if (params2.getReferenced(tree).length > 0) {
      $$invalidate(5, showParamsPrompt = true);
    } else {
      _replay();
    }
  }
  async function _replay() {
    recorder2.stop();
    await resetBBX();
    goto(url);
    player = new Player(tree, browserView);
    try {
      await player.play();
    } catch (e) {
      if (e instanceof EvalError$1) {
        let nodeStack = [];
        let node2 = e.node;
        while (node2) {
          nodeStack.push(node2);
          node2 = node2.parent;
        }
        set_store_value(errorStore, $errorStore = { message: e.message, nodeStack }, $errorStore);
      } else {
        set_store_value(errorStore, $errorStore = { message: "", nodeStack: [] }, $errorStore);
      }
      console.error(e);
    }
    set_store_value(statusStore, $statusStore = "ready", $statusStore);
  }
  async function onReset() {
    recorder2.stop();
    recorder2.reset();
    params2.reset();
    await resetBBX();
    goto();
    recorder2.start();
    set_store_value(statusStore, $statusStore = "record", $statusStore);
  }
  async function resetBBX() {
    let pages = browser2.pages.slice(0);
    await browser2.newPage();
    await Promise.all(pages.map((p) => p.close()));
  }
  function onDeleteStep({ detail }) {
    recorder2.deleteStep(detail);
  }
  function getActivePage() {
    return browser2.getActivePage();
  }
  function goBack() {
    getActivePage().goBack();
  }
  function goForward() {
    getActivePage().goForward();
  }
  function onReload() {
    let page = getActivePage();
    if (page.mainFrame.url && page.mainFrame.url.startsWith("http")) {
      page.reload();
    } else {
      page.goto(url);
    }
  }
  function onPromptApply() {
    $$invalidate(5, showParamsPrompt = false);
    _replay();
  }
  function onPromptCancel() {
    $$invalidate(5, showParamsPrompt = false);
  }
  let pickerSelector = null;
  let pickerFrame = null;
  let resolve;
  function openPickerPanel(_selector, _frame) {
    $$invalidate(6, showPickerPanel = false);
    $$invalidate(9, pickerSelector = _selector);
    $$invalidate(10, pickerFrame = _frame);
    if (pickerSelector.type !== "css" && pickerSelector.type !== "xpath") {
      console.error("unsupported selector type", pickerSelector.type);
      cancelPickedSelector();
      return;
    }
    $$invalidate(6, showPickerPanel = true);
    return new Promise((_resolve, _reject) => {
      resolve = _resolve;
    });
  }
  function savePickedSelector({ detail }) {
    if (typeof resolve === "function") {
      resolve(detail);
    }
    $$invalidate(9, pickerSelector = null);
    $$invalidate(10, pickerFrame = null);
    $$invalidate(6, showPickerPanel = false);
  }
  function cancelPickedSelector() {
    if (typeof resolve === "function") {
      resolve(null);
    }
    $$invalidate(6, showPickerPanel = false);
    $$invalidate(9, pickerSelector = null);
    $$invalidate(10, pickerFrame = null);
  }
  function onProxyChange(proxy2) {
    return browserView == null ? void 0 : browserView.client.api("proxy", "PUT", { id: (proxy2 == null ? void 0 : proxy2.id) || [] });
  }
  function onSessionChange(session2) {
    return browser2 == null ? void 0 : browser2.call("setCookies", (session2 == null ? void 0 : session2.cookies) || []);
  }
  function input_input_handler() {
    url = this.value;
    $$invalidate(0, url);
  }
  const click_handler = (e) => dispatch("cancel");
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(31, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(1, clazz = $$new_props.class);
    if ("proxy" in $$new_props)
      $$invalidate(32, proxy = $$new_props.proxy);
    if ("session" in $$new_props)
      $$invalidate(33, session = $$new_props.session);
    if ("bbx" in $$new_props)
      $$invalidate(2, bbx = $$new_props.bbx);
    if ("findSelector" in $$new_props)
      $$invalidate(34, findSelector = $$new_props.findSelector);
    if ("url" in $$new_props)
      $$invalidate(0, url = $$new_props.url);
    if ("initialSteps" in $$new_props)
      $$invalidate(35, initialSteps = $$new_props.initialSteps);
    if ("initialParams" in $$new_props)
      $$invalidate(36, initialParams = $$new_props.initialParams);
    if ("$$scope" in $$new_props)
      $$invalidate(40, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & 2) {
      onProxyChange(proxy);
    }
    if ($$self.$$.dirty[1] & 4) {
      onSessionChange(session);
    }
    if ($$self.$$.dirty[0] & 8) {
      $statusStore !== "ready" && set_store_value(errorStore, $errorStore = { message: "", nodeStack: [] }, $errorStore);
    }
  };
  return [
    url,
    clazz,
    bbx,
    $statusStore,
    browserView,
    showParamsPrompt,
    showPickerPanel,
    modalProps,
    inspector,
    pickerSelector,
    pickerFrame,
    statusStore,
    params2,
    errorStore,
    tree,
    dispatch,
    onBrowserReady,
    onSave,
    record,
    stopRecording,
    stopReplay,
    replay,
    onReset,
    onDeleteStep,
    goBack,
    goForward,
    onReload,
    onPromptApply,
    onPromptCancel,
    savePickedSelector,
    cancelPickedSelector,
    $$restProps,
    proxy,
    session,
    findSelector,
    initialSteps,
    initialParams,
    slots,
    input_input_handler,
    click_handler,
    $$scope
  ];
}
class Recorder_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$x,
      create_fragment$y,
      safe_not_equal,
      {
        class: 1,
        proxy: 32,
        session: 33,
        bbx: 2,
        findSelector: 34,
        url: 0,
        initialSteps: 35,
        initialParams: 36
      },
      null,
      [-1, -1]
    );
  }
}
function create_else_block$i(ctx) {
  let div;
  let t1;
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      div = element("div");
      div.textContent = "Creating browser...";
      t1 = space();
      create_component(loader.$$.fragment);
      attr(div, "class", "pa2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block$i(ctx) {
  let bbxrecorder;
  let current;
  bbxrecorder = new Recorder_1({
    props: {
      bbx: ctx[3],
      initialSteps: ctx[5],
      initialParams: ctx[6],
      findSelector: ctx[7],
      proxy: ctx[1],
      session: ctx[2],
      url: ctx[4].meta.url,
      $$slots: { "tb-url-r": [create_tb_url_r_slot] },
      $$scope: { ctx }
    }
  });
  bbxrecorder.$on("save", ctx[10]);
  bbxrecorder.$on("cancel", ctx[11]);
  return {
    c() {
      create_component(bbxrecorder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bbxrecorder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const bbxrecorder_changes = {};
      if (dirty & 8)
        bbxrecorder_changes.bbx = ctx2[3];
      if (dirty & 2)
        bbxrecorder_changes.proxy = ctx2[1];
      if (dirty & 4)
        bbxrecorder_changes.session = ctx2[2];
      if (dirty & 16)
        bbxrecorder_changes.url = ctx2[4].meta.url;
      if (dirty & 8198) {
        bbxrecorder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bbxrecorder.$set(bbxrecorder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bbxrecorder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bbxrecorder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(bbxrecorder, detaching);
    }
  };
}
function create_tb_url_r_slot(ctx) {
  let selectproxy;
  let updating_proxy;
  let t;
  let selectsession;
  let updating_session;
  let current;
  function selectproxy_proxy_binding(value) {
    ctx[8](value);
  }
  let selectproxy_props = { class: "bbx-action px-2", title: "Proxy" };
  if (ctx[1] !== void 0) {
    selectproxy_props.proxy = ctx[1];
  }
  selectproxy = new SelectProxy({ props: selectproxy_props });
  binding_callbacks.push(() => bind$2(selectproxy, "proxy", selectproxy_proxy_binding));
  function selectsession_session_binding(value) {
    ctx[9](value);
  }
  let selectsession_props = {
    class: "bbx-action px-2",
    title: "Profile"
  };
  if (ctx[2] !== void 0) {
    selectsession_props.session = ctx[2];
  }
  selectsession = new SelectSession({ props: selectsession_props });
  binding_callbacks.push(() => bind$2(selectsession, "session", selectsession_session_binding));
  return {
    c() {
      create_component(selectproxy.$$.fragment);
      t = space();
      create_component(selectsession.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectproxy, target, anchor);
      insert(target, t, anchor);
      mount_component(selectsession, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectproxy_changes = {};
      if (!updating_proxy && dirty & 2) {
        updating_proxy = true;
        selectproxy_changes.proxy = ctx2[1];
        add_flush_callback(() => updating_proxy = false);
      }
      selectproxy.$set(selectproxy_changes);
      const selectsession_changes = {};
      if (!updating_session && dirty & 4) {
        updating_session = true;
        selectsession_changes.session = ctx2[2];
        add_flush_callback(() => updating_session = false);
      }
      selectsession.$set(selectsession_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectproxy.$$.fragment, local);
      transition_in(selectsession.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectproxy.$$.fragment, local);
      transition_out(selectsession.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectproxy, detaching);
      if (detaching)
        detach(t);
      destroy_component(selectsession, detaching);
    }
  };
}
function create_fragment$x(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$i, create_else_block$i];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  var _a, _b;
  let $macro, $$unsubscribe_macro = noop, $$subscribe_macro = () => ($$unsubscribe_macro(), $$unsubscribe_macro = subscribe(macro, ($$value) => $$invalidate(4, $macro = $$value)), macro);
  $$self.$$.on_destroy.push(() => $$unsubscribe_macro());
  let { macro } = $$props;
  $$subscribe_macro();
  let proxy;
  let session;
  let api = getContext("api");
  let bbx;
  let initialSteps = $macro.steps;
  let initialParams = (_b = (_a = $macro.spec) == null ? void 0 : _a.params) != null ? _b : [];
  onMount(async () => {
    try {
      $$invalidate(3, bbx = await api("/selectors2", "POST"));
    } catch (e) {
      console.error(e);
      loading = false;
      loadError = `Please try again later, failed to load recorder: ${e.message}`;
    }
  });
  async function findSelector(el) {
    let expr = await getCSS([el]);
    return new CSSSelector(expr);
  }
  function selectproxy_proxy_binding(value) {
    proxy = value;
    $$invalidate(1, proxy);
  }
  function selectsession_session_binding(value) {
    session = value;
    $$invalidate(2, session);
  }
  function save_handler(event) {
    bubble.call(this, $$self, event);
  }
  function cancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("macro" in $$props2)
      $$subscribe_macro($$invalidate(0, macro = $$props2.macro));
  };
  return [
    macro,
    proxy,
    session,
    bbx,
    $macro,
    initialSteps,
    initialParams,
    findSelector,
    selectproxy_proxy_binding,
    selectsession_session_binding,
    save_handler,
    cancel_handler
  ];
}
class Recorder extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$x, safe_not_equal, { macro: 0 });
  }
}
function get_each_context$c(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  child_ctx[28] = i2;
  return child_ctx;
}
function create_if_block_5$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Please enter name and a valid start url for the recorder";
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$4(ctx) {
  let span;
  let t0;
  let t1_value = ctx[1].models.length + "";
  let t1;
  let t2;
  let t3;
  let t4;
  return {
    c() {
      span = element("span");
      t0 = text("Used ");
      t1 = text(t1_value);
      t2 = text(" of ");
      t3 = text(ctx[9]);
      t4 = text(" macros.");
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(span, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[1].models.length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_3$7(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Upgrade account to create and use macros in cloud.";
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_2(ctx) {
  let div1;
  let div0;
  let input0;
  let t0;
  let input1;
  let t1;
  let span;
  let button0;
  let t2;
  let button0_disabled_value;
  let t3;
  let button1;
  let t4;
  let button1_disabled_value;
  let t5;
  let t6;
  let mounted;
  let dispose;
  let if_block0 = ctx[5] && create_if_block_5$2();
  function select_block_type(ctx2, dirty) {
    if (ctx2[9] == 0)
      return create_if_block_3$7;
    if (ctx2[2])
      return create_if_block_4$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type && current_block_type(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      span = element("span");
      button0 = element("button");
      t2 = text("Add New Macro");
      t3 = space();
      button1 = element("button");
      t4 = text("Import Macro");
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      attr(input0, "type", "text");
      attr(input0, "class", "form-control w-96");
      attr(input0, "placeholder", "New Macro Name");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control w-96");
      attr(input1, "placeholder", "Start URL");
      attr(button0, "class", "btn btn-default");
      attr(button0, "role", "button");
      button0.disabled = button0_disabled_value = ctx[2] || ctx[7];
      attr(button1, "class", "btn btn-default");
      attr(button1, "role", "button");
      button1.disabled = button1_disabled_value = ctx[2] || ctx[7];
      attr(span, "class", "inline-block");
      attr(div0, "class", "flex gap-2");
      attr(div1, "class", "");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input0);
      set_input_value(input0, ctx[3]);
      append(div0, t0);
      append(div0, input1);
      set_input_value(input1, ctx[4]);
      append(div0, t1);
      append(div0, span);
      append(span, button0);
      append(button0, t2);
      append(span, t3);
      append(span, button1);
      append(button1, t4);
      append(div1, t5);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t6);
      if (if_block1)
        if_block1.m(div1, null);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[19]),
          listen(input1, "input", ctx[20]),
          listen(button0, "click", ctx[11]),
          listen(button1, "click", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && input0.value !== ctx2[3]) {
        set_input_value(input0, ctx2[3]);
      }
      if (dirty & 16 && input1.value !== ctx2[4]) {
        set_input_value(input1, ctx2[4]);
      }
      if (dirty & 132 && button0_disabled_value !== (button0_disabled_value = ctx2[2] || ctx2[7])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & 132 && button1_disabled_value !== (button1_disabled_value = ctx2[2] || ctx2[7])) {
        button1.disabled = button1_disabled_value;
      }
      if (ctx2[5]) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_5$2();
          if_block0.c();
          if_block0.m(div1, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$7(ctx) {
  let recordermodal;
  let current;
  recordermodal = new Modal$1({
    props: {
      widthClass: "modal-fullscreen",
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(recordermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recordermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recordermodal_changes = {};
      if (dirty & 536870976) {
        recordermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recordermodal.$set(recordermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recordermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recordermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recordermodal, detaching);
    }
  };
}
function create_default_slot_1$3(ctx) {
  let recorder2;
  let current;
  recorder2 = new Recorder({
    props: {
      class: "w-full",
      macro: ctx[6]
    }
  });
  recorder2.$on("cancel", ctx[14]);
  recorder2.$on("save", ctx[13]);
  return {
    c() {
      create_component(recorder2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recorder2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recorder_changes = {};
      if (dirty & 64)
        recorder_changes.macro = ctx2[6];
      recorder2.$set(recorder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recorder2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recorder2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recorder2, detaching);
    }
  };
}
function create_if_block$h(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      $$slots: {
        header: [create_header_slot$7],
        default: [create_default_slot$c]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[21]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 536871168) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_else_block$h(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[8].sieves;
  const get_key = (ctx2) => ctx2[26].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$c(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$c(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$5();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 256) {
        each_value = ctx2[8].sieves;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$c, each_1_anchor, get_each_context$c);
        if (each_value.length) {
          if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        } else if (!each_1_else) {
          each_1_else = create_else_block_1$5();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        }
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_if_block_1$b(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block_1$5(ctx) {
  let t;
  return {
    c() {
      t = text("No monitor found using this macro.");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$c(key_1, ctx) {
  let div;
  let t_value = ctx[26].name + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      t = text(t_value);
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 256 && t_value !== (t_value = ctx[26].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$c(ctx) {
  let div;
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[8].sieves)
      return create_if_block_1$b;
    return create_else_block$h;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      set_style(div, "max-height", "70vh");
      set_style(div, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_header_slot$7(ctx) {
  let span;
  let t0;
  let t1_value = ctx[8].name + "";
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("Monitors - ");
      t1 = text(t1_value);
      attr(span, "slot", "header");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 256 && t1_value !== (t1_value = ctx2[8].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$w(ctx) {
  let list;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  list = new List$6({
    props: {
      onDelete: ctx[12],
      openBrowser: ctx[15],
      showMonitors: ctx[16],
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[6] && create_if_block_2$7(ctx);
  let if_block1 = ctx[8] && create_if_block$h(ctx);
  return {
    c() {
      create_component(list.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const list_changes = {};
      if (dirty & 536871102) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
      if (ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[8]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$h(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let $store;
  let $user, $$unsubscribe_user = noop, $$subscribe_user = () => ($$unsubscribe_user(), $$unsubscribe_user = subscribe(user, ($$value) => $$invalidate(22, $user = $$value)), user);
  $$self.$$.on_destroy.push(() => $$unsubscribe_user());
  let { api = getContext("api") } = $$props;
  let { user = getContext("user") } = $$props;
  $$subscribe_user();
  let limit2 = $user.constraint.macro;
  let limitReached = false;
  let newName = "";
  let url = "";
  let missingInfo = false;
  let openMacro;
  let savingMacro = false;
  let showMonitorsForMacro = null;
  let store2 = new Macros([], { orderBy: "-ts" });
  component_subscribe($$self, store2, (value) => $$invalidate(1, $store = value));
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  async function onAdd() {
    if (!newName || !url) {
      $$invalidate(5, missingInfo = true);
      return;
    }
    if (!url.startsWith("http")) {
      $$invalidate(4, url = "https://" + url);
    }
    $$invalidate(5, missingInfo = false);
    $$invalidate(7, savingMacro = true);
    $$invalidate(6, openMacro = await store2.create(
      {
        name: newName || "Untitled",
        meta: { url }
      },
      { wait: true }
    ));
    $$invalidate(3, newName = "");
    $$invalidate(7, savingMacro = false);
    store2.fetch();
  }
  async function onDelete(model) {
    await removeMacroFromSieve(model.id);
    await model.destroy();
  }
  async function removeMacroFromSieve(id2) {
    let res = await api(`/sieves?macro_id=${id2}`, {
      "state.in": [40, 45, 90],
      _opt: { only: ["id"], limit: 100 }
    });
    let ids = res.data.map((s) => s.id);
    if (ids.length == 0) {
      return;
    }
    await api("/batch/sieves", "PUT", { ids, macro_id: null });
    if (res.total_count > res.count) {
      await removeMacroFromSieve(id2);
    }
  }
  async function onSaveMacro(e) {
    let { steps, params: params2 } = e.detail;
    await openMacro.save({ steps, spec: { params: params2 } });
    $$invalidate(6, openMacro = null);
    await store2.fetch();
  }
  function onDiscardMacro() {
    $$invalidate(6, openMacro = null);
  }
  function openBrowser(macro) {
    $$invalidate(6, openMacro = macro);
  }
  async function showMonitors(macro) {
    $$invalidate(8, showMonitorsForMacro = { ...macro, sieves: null });
    $$invalidate(8, showMonitorsForMacro.sieves = (await api(`/sieves?state.in[0]=40&state.in[1]=45&_opt[limit]=500&macro_id=${macro.id}`)).data, showMonitorsForMacro);
  }
  function importMacro() {
    let el = document.createElement("input");
    el.type = "file";
    el.accept = ".json";
    el.addEventListener("change", (e) => {
      let file = e.target.files[0];
      let reader = new FileReader();
      reader.onload = async (e2) => {
        let obj = JSON.parse(e2.target.result);
        let macros = obj.macros;
        for (let macro of macros) {
          await store2.create(macro, { wait: true });
        }
        store2.fetch();
      };
      reader.readAsText(file);
    });
    el.click();
  }
  function input0_input_handler() {
    newName = this.value;
    $$invalidate(3, newName);
  }
  function input1_input_handler() {
    url = this.value;
    $$invalidate(4, url);
  }
  const close_handler = () => $$invalidate(8, showMonitorsForMacro = null);
  $$self.$$set = ($$props2) => {
    if ("api" in $$props2)
      $$invalidate(18, api = $$props2.api);
    if ("user" in $$props2)
      $$subscribe_user($$invalidate(0, user = $$props2.user));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$invalidate(2, limitReached = $store.models.length >= limit2);
    }
  };
  return [
    user,
    $store,
    limitReached,
    newName,
    url,
    missingInfo,
    openMacro,
    savingMacro,
    showMonitorsForMacro,
    limit2,
    store2,
    onAdd,
    onDelete,
    onSaveMacro,
    onDiscardMacro,
    openBrowser,
    showMonitors,
    importMacro,
    api,
    input0_input_handler,
    input1_input_handler,
    close_handler
  ];
}
class Macros_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$w, safe_not_equal, { api: 18, user: 0 });
  }
}
class Session extends base.Model {
}
class Sessions extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "model", Session);
    __publicField(this, "url", "/sessions");
    __publicField(this, "limit", 20);
  }
}
function get_each_context$b(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  return child_ctx;
}
function create_action_slot(ctx) {
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.textContent = "Save Cookies and Close";
      t1 = space();
      button1 = element("button");
      button1.innerHTML = `<span class="visually-hidden">Toggle</span>`;
      attr(button0, "class", "btn btn-default");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-default dropdown-toggle dropdown-toggle-split");
      attr(button1, "data-bs-toggle", "dropdown");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[9]),
          listen(button1, "click", function() {
            if (is_function(ctx[25]))
              ctx[25].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(button1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$b(ctx) {
  let li;
  let a;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      a = element("a");
      t = text("Close (New Cookies not saved)");
      attr(a, "class", "dropdown-item");
      attr(a, "href", href);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t);
      if (!mounted) {
        dispose = listen(a, "click", ctx[10]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$b(key_1, ctx) {
  let option;
  let t_value = ctx[22].name + "";
  let t;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[22].id;
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && t_value !== (t_value = ctx[22].name + ""))
        set_data(t, t_value);
      if (dirty & 32 && option_value_value !== (option_value_value = ctx[22].id)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block$g(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "loading...";
      set_style(div, "padding", "5px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$v(ctx) {
  let div5;
  let div0;
  let h3;
  let t0_value = ctx[6].name + "";
  let t0;
  let t1;
  let t2;
  let menu;
  let t3;
  let div4;
  let div2;
  let div1;
  let input_1;
  let t4;
  let button;
  let t6;
  let select;
  let option;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t8;
  let t9;
  let div3;
  let current;
  let mounted;
  let dispose;
  menu = new Menu$1({
    props: {
      class: "btn-group",
      $$slots: {
        default: [create_default_slot$b],
        action: [
          create_action_slot,
          ({ onClick }) => ({ 25: onClick }),
          ({ onClick }) => onClick ? 33554432 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let each_value = ctx[5];
  const get_key = (ctx2) => ctx2[22].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$b(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$b(key, child_ctx));
  }
  let if_block = ctx[1] && create_if_block$g();
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" - Remote Browser");
      t2 = space();
      create_component(menu.$$.fragment);
      t3 = space();
      div4 = element("div");
      div2 = element("div");
      div1 = element("div");
      input_1 = element("input");
      t4 = space();
      button = element("button");
      button.textContent = "Go";
      t6 = space();
      select = element("select");
      option = element("option");
      option.textContent = "-- Proxy --";
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t8 = space();
      if (if_block)
        if_block.c();
      t9 = space();
      div3 = element("div");
      set_style(h3, "flex", "1");
      attr(div0, "class", "card-header");
      set_style(div0, "display", "flex");
      set_style(div0, "align-items", "center");
      attr(input_1, "class", "form-control");
      attr(input_1, "type", "text");
      attr(button, "class", "btn btn-outline-secondary");
      attr(div1, "class", "input-group flex-1");
      option.__value = "";
      option.value = option.__value;
      attr(div2, "class", "flex gap-2");
      attr(div3, "class", "flex-auto");
      set_style(div3, "position", "relative");
      set_style(div3, "background-color", "#fff");
      attr(div4, "class", "card-body flex-auto flex flex-column");
      set_style(div4, "padding", "0");
      attr(div5, "class", "card panel-default flex-auto flex flex-column");
      set_style(div5, "margin", "0");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, h3);
      append(h3, t0);
      append(h3, t1);
      append(div0, t2);
      mount_component(menu, div0, null);
      append(div5, t3);
      append(div5, div4);
      append(div4, div2);
      append(div2, div1);
      append(div1, input_1);
      set_input_value(input_1, ctx[4]);
      ctx[13](input_1);
      append(div1, t4);
      append(div1, button);
      append(div2, t6);
      append(div2, select);
      append(select, option);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      append(div4, t8);
      if (if_block)
        if_block.m(div4, null);
      append(div4, t9);
      append(div4, div3);
      ctx[14](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input_1, "input", ctx[12]),
          listen(input_1, "keypress", ctx[11]),
          listen(button, "click", ctx[7]),
          listen(select, "change", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 64) && t0_value !== (t0_value = ctx2[6].name + ""))
        set_data(t0, t0_value);
      const menu_changes = {};
      if (dirty & 100663296) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (dirty & 16 && input_1.value !== ctx2[4]) {
        set_input_value(input_1, ctx2[4]);
      }
      if (dirty & 32) {
        each_value = ctx2[5];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$b, null, get_each_context$b);
      }
      if (ctx2[1]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$g();
          if_block.c();
          if_block.m(div4, t9);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(menu);
      ctx[13](null);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block)
        if_block.d();
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
let href = "#";
function instance$u($$self, $$props, $$invalidate) {
  let $session, $$unsubscribe_session = noop, $$subscribe_session = () => ($$unsubscribe_session(), $$unsubscribe_session = subscribe(session, ($$value) => $$invalidate(6, $session = $$value)), session);
  $$self.$$.on_destroy.push(() => $$unsubscribe_session());
  let { session } = $$props;
  $$subscribe_session();
  let api = getContext("api");
  getContext("store");
  let loading2 = true;
  let input;
  let container;
  let bbx;
  let browserView;
  let browser2;
  let url = "https://www.google.com";
  let proxies = [];
  const dispatch = createEventDispatcher();
  onMount(async () => {
    bbx = await api("/selectors2", "POST");
    browserView = await createView({ ...bbx, container });
    browser2 = browserView.store;
    await browser2.call("setCookies", session.get("cookies") || []);
    $$invalidate(1, loading2 = false);
    $$invalidate(5, proxies = await getProxies());
    go();
  });
  onDestroy(() => {
    api("/selectors2/" + bbx.id, "DELETE");
  });
  function go() {
    if (url) {
      browser2.pages[0].goto(url);
    }
  }
  async function onSelectProxy(e) {
    let id2 = e.target.value;
    $$invalidate(1, loading2 = true);
    await browserView.client.api("proxy", "PUT", { id: id2 });
    $$invalidate(1, loading2 = false);
  }
  async function onSaveAndClose() {
    let res = await browser2.call("getCookies");
    let cookies = res;
    dispatch("save", { url, cookies });
  }
  function onDiscard(e) {
    e.preventDefault();
    dispatch("discard");
  }
  function onInputKey(e) {
    if (e.keyCode == 13) {
      go();
      input.blur();
    }
  }
  function input_1_input_handler() {
    url = this.value;
    $$invalidate(4, url);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(3, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("session" in $$props2)
      $$subscribe_session($$invalidate(0, session = $$props2.session));
  };
  return [
    session,
    loading2,
    input,
    container,
    url,
    proxies,
    $session,
    go,
    onSelectProxy,
    onSaveAndClose,
    onDiscard,
    onInputKey,
    input_1_input_handler,
    input_1_binding,
    div3_binding
  ];
}
class Browser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$v, safe_not_equal, { session: 0 });
  }
}
function create_default_slot_1$2(ctx) {
  let t;
  return {
    c() {
      t = text("clear cookies");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$a(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-trash-o error");
      set_style(i2, "font-size", "1.5em");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_fragment$u(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[5].name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = (ctx[5].cookies ? ctx[5].cookies.length : 0) + "";
  let t2;
  let t3;
  let td2;
  let button0;
  let t5;
  let button1;
  let t7;
  let div1;
  let confirmbtn0;
  let t8;
  let div0;
  let t9;
  let td3;
  let confirmbtn1;
  let current;
  let mounted;
  let dispose;
  confirmbtn0 = new ConfirmBtn({
    props: {
      class: "btn-sm",
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  confirmbtn0.$on("click", ctx[8]);
  confirmbtn1 = new ConfirmBtn({
    props: {
      alignRight: "1",
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  confirmbtn1.$on("click", ctx[9]);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      button0 = element("button");
      button0.textContent = "open remote browser";
      t5 = space();
      button1 = element("button");
      button1.textContent = "view monitors";
      t7 = space();
      div1 = element("div");
      create_component(confirmbtn0.$$.fragment);
      t8 = space();
      div0 = element("div");
      t9 = space();
      td3 = element("td");
      create_component(confirmbtn1.$$.fragment);
      attr(button0, "class", "btn btn-default btn-sm");
      attr(button1, "class", "btn btn-default btn-sm");
      attr(div1, "class", "inline");
      attr(td3, "title", "Delete");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, button0);
      append(td2, t5);
      append(td2, button1);
      append(td2, t7);
      append(td2, div1);
      mount_component(confirmbtn0, div1, null);
      append(div1, t8);
      append(div1, div0);
      append(tr, t9);
      append(tr, td3);
      mount_component(confirmbtn1, td3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[6]),
          listen(button1, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 32) && t0_value !== (t0_value = ctx2[5].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 32) && t2_value !== (t2_value = (ctx2[5].cookies ? ctx2[5].cookies.length : 0) + ""))
        set_data(t2, t2_value);
      const confirmbtn0_changes = {};
      if (dirty & 1024) {
        confirmbtn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn0.$set(confirmbtn0_changes);
      const confirmbtn1_changes = {};
      if (dirty & 1024) {
        confirmbtn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn1.$set(confirmbtn1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn0.$$.fragment, local);
      transition_in(confirmbtn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn0.$$.fragment, local);
      transition_out(confirmbtn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_component(confirmbtn0);
      destroy_component(confirmbtn1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let $sess, $$unsubscribe_sess = noop, $$subscribe_sess = () => ($$unsubscribe_sess(), $$unsubscribe_sess = subscribe(sess, ($$value) => $$invalidate(5, $sess = $$value)), sess);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sess());
  let { sess } = $$props;
  $$subscribe_sess();
  let { onClear: onClear2 } = $$props;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let { onDelete } = $$props;
  const click_handler = (e) => openBrowser(sess);
  const click_handler_1 = (e) => showMonitors($sess);
  const click_handler_2 = (e) => onClear2(sess);
  const click_handler_3 = (e) => onDelete(sess);
  $$self.$$set = ($$props2) => {
    if ("sess" in $$props2)
      $$subscribe_sess($$invalidate(0, sess = $$props2.sess));
    if ("onClear" in $$props2)
      $$invalidate(1, onClear2 = $$props2.onClear);
    if ("openBrowser" in $$props2)
      $$invalidate(2, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(3, showMonitors = $$props2.showMonitors);
    if ("onDelete" in $$props2)
      $$invalidate(4, onDelete = $$props2.onDelete);
  };
  return [
    sess,
    onClear2,
    openBrowser,
    showMonitors,
    onDelete,
    $sess,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class Profile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$u, safe_not_equal, {
      sess: 0,
      onClear: 1,
      openBrowser: 2,
      showMonitors: 3,
      onDelete: 4
    });
  }
}
function get_each_context$a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function create_catch_block$6(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$6(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_pending_block$6(ctx) {
  let td;
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      td = element("td");
      create_component(loader.$$.fragment);
      attr(td, "colspan", "4");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      mount_component(loader, td, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      destroy_component(loader);
    }
  };
}
function create_else_block$g(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No profile found.
      </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$a(key_1, ctx) {
  let first;
  let profile;
  let current;
  profile = new Profile({
    props: {
      sess: ctx[12],
      onClear: ctx[2],
      openBrowser: ctx[0],
      showMonitors: ctx[1],
      onDelete: ctx[3]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(profile.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(profile, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const profile_changes = {};
      if (dirty & 32)
        profile_changes.sess = ctx[12];
      if (dirty & 4)
        profile_changes.onClear = ctx[2];
      if (dirty & 1)
        profile_changes.openBrowser = ctx[0];
      if (dirty & 2)
        profile_changes.showMonitors = ctx[1];
      if (dirty & 8)
        profile_changes.onDelete = ctx[3];
      profile.$set(profile_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(profile.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profile.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(profile, detaching);
    }
  };
}
function create_fragment$t(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t1;
  let small;
  let t2;
  let a;
  let t3;
  let t4;
  let div1;
  let t5;
  let searchbar;
  let t6;
  let listpager;
  let t7;
  let sortby;
  let t8;
  let table;
  let tbody;
  let tr0;
  let td;
  let t9;
  let tr1;
  let t16;
  let promise;
  let t17;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[7]);
  listpager = new ListPager({ props: { store: ctx[4] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[8],
      sortingFields: ctx[6],
      currentFieldName: ctx[5].orderBy
    }
  });
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$6,
    then: create_then_block$6,
    catch: create_catch_block$6,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[5].fetchPromise, info);
  let each_value = ctx[5].models;
  const get_key = (ctx2) => ctx2[12].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$a(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$a(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$g();
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = "Profiles";
      t1 = space();
      small = element("small");
      t2 = text("Create and use profiles for checks in cloud that require cookies or authentication.\n      ");
      a = element("a");
      t3 = text("Learn More");
      t4 = space();
      div1 = element("div");
      t5 = space();
      create_component(searchbar.$$.fragment);
      t6 = space();
      create_component(listpager.$$.fragment);
      t7 = space();
      create_component(sortby.$$.fragment);
      t8 = space();
      table = element("table");
      tbody = element("tbody");
      tr0 = element("tr");
      td = element("td");
      if (default_slot)
        default_slot.c();
      t9 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<th>Name</th> 
        <th>Cookies</th> 
        <th>Options</th> 
        <th style="width: 20px"></th>`;
      t16 = space();
      info.block.c();
      t17 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(a, "href", URL_WEBSITE + "/docs/web-monitor/profiles-for-cloud-monitors");
      attr(a, "target", "_blank");
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      set_style(div1, "max-width", "50px");
      attr(div2, "class", "card-header flex items-center");
      attr(td, "colspan", "4");
      set_style(td, "background-color", "#eee");
      attr(tr1, "class", "bg-gray-200");
      attr(table, "class", "table");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(div0, t1);
      append(div0, small);
      append(small, t2);
      append(small, a);
      append(a, t3);
      append(div2, t4);
      append(div2, div1);
      append(div2, t5);
      mount_component(searchbar, div2, null);
      append(div2, t6);
      mount_component(listpager, div2, null);
      append(div2, t7);
      mount_component(sortby, div2, null);
      append(div3, t8);
      append(div3, table);
      append(table, tbody);
      append(tbody, tr0);
      append(tr0, td);
      if (default_slot) {
        default_slot.m(td, null);
      }
      append(tbody, t9);
      append(tbody, tr1);
      append(tbody, t16);
      info.block.m(tbody, info.anchor = null);
      info.mount = () => tbody;
      info.anchor = t17;
      append(tbody, t17);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const listpager_changes = {};
      if (dirty & 16)
        listpager_changes.store = ctx[4];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 32)
        sortby_changes.currentFieldName = ctx[5].orderBy;
      sortby.$set(sortby_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[9],
            !current ? get_all_dirty_from_scope(ctx[9]) : get_slot_changes(default_slot_template, ctx[9], dirty, null),
            null
          );
        }
      }
      info.ctx = ctx;
      dirty & 32 && promise !== (promise = ctx[5].fetchPromise) && handle_promise(promise, info);
      if (dirty & 47) {
        each_value = ctx[5].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$a, null, get_each_context$a);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$g();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(info.block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      transition_out(default_slot, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      if (default_slot)
        default_slot.d(detaching);
      info.block.d();
      info.token = null;
      info = null;
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  let store2 = getContext("store");
  component_subscribe($$self, store2, (value) => $$invalidate(5, $store = value));
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let { onClear: onClear2 } = $$props;
  let { onDelete } = $$props;
  let searchQuery = "";
  let sortingFields = [
    { value: "-ts", label: "Newest First" },
    { value: "ts", label: "Oldest First" },
    { value: "name", label: "Name" },
    {
      value: "-name",
      label: "Name - Descending"
    }
  ];
  async function onSearch2(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      store2.setQuery({});
      return await store2.fetch({ reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({ "name.ilike": searchQuery });
    await store2.goto(0, { reset: true });
  }
  async function onSort(by) {
    $$invalidate(4, store2.orderBy = by, store2);
    await store2.fetch({ reset: true });
  }
  $$self.$$set = ($$props2) => {
    if ("openBrowser" in $$props2)
      $$invalidate(0, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(1, showMonitors = $$props2.showMonitors);
    if ("onClear" in $$props2)
      $$invalidate(2, onClear2 = $$props2.onClear);
    if ("onDelete" in $$props2)
      $$invalidate(3, onDelete = $$props2.onDelete);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    openBrowser,
    showMonitors,
    onClear2,
    onDelete,
    store2,
    $store,
    sortingFields,
    onSearch2,
    onSort,
    $$scope,
    slots
  ];
}
class List$5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$t, safe_not_equal, {
      openBrowser: 0,
      showMonitors: 1,
      onClear: 2,
      onDelete: 3
    });
  }
}
const get_header_slot_changes$2 = (dirty) => ({});
const get_header_slot_context$2 = (ctx) => ({});
function create_fragment$s(ctx) {
  let div5;
  let div4;
  let div3;
  let div0;
  let button0;
  let t1;
  let h4;
  let t2;
  let div1;
  let t3;
  let div2;
  let button1;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = ctx[4].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[3], get_header_slot_context$2);
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.innerHTML = `<span aria-hidden="true">\xD7</span>`;
      t1 = space();
      h4 = element("h4");
      if (header_slot)
        header_slot.c();
      t2 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div2 = element("div");
      button1 = element("button");
      button1.textContent = "close modal";
      attr(button0, "type", "button");
      attr(button0, "class", "close");
      attr(button0, "data-dismiss", "modal");
      attr(button0, "aria-label", "Close");
      attr(h4, "class", "modal-title");
      attr(div0, "class", "modal-header");
      attr(div1, "class", "modal-body");
      attr(button1, "type", "button");
      button1.autofocus = true;
      attr(button1, "class", "btn btn-default");
      attr(div2, "class", "modal-footer");
      attr(div3, "class", "modal-content");
      attr(div4, "class", "modal-dialog");
      attr(div4, "role", "document");
      attr(div5, "class", "modal");
      attr(div5, "tabindex", "-1");
      attr(div5, "role", "dialog");
      set_style(div5, "display", "block");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div3);
      append(div3, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, h4);
      if (header_slot) {
        header_slot.m(h4, null);
      }
      append(div3, t2);
      append(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div3, t3);
      append(div3, div2);
      append(div2, button1);
      ctx[5](div5);
      current = true;
      button1.focus();
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[2]),
          listen(button1, "click", ctx[1]),
          listen(div5, "click", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(header_slot_template, ctx2[3], dirty, get_header_slot_changes$2),
            get_header_slot_context$2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (header_slot)
        header_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  const close = () => dispatch("close");
  let modal;
  const handle_keydown = (e) => {
    if (e.key === "Escape") {
      close();
      return;
    }
    if (e.key === "Tab") {
      const nodes = modal.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((n) => n.tabIndex >= 0);
      let index2 = tabbable.indexOf(document.activeElement);
      if (index2 === -1 && e.shiftKey)
        index2 = 0;
      index2 += tabbable.length + (e.shiftKey ? -1 : 1);
      index2 %= tabbable.length;
      tabbable[index2].focus();
      e.preventDefault();
    }
  };
  const previously_focused = typeof document !== "undefined" && document.activeElement;
  if (previously_focused) {
    onDestroy(() => {
      previously_focused.focus();
    });
  }
  function div5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modal = $$value;
      $$invalidate(0, modal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [modal, close, handle_keydown, $$scope, slots, div5_binding];
}
class Modal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$s, safe_not_equal, {});
  }
}
function get_each_context$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  child_ctx[24] = i2;
  return child_ctx;
}
function create_if_block_4$3(ctx) {
  let span;
  let t0;
  let t1_value = ctx[0].models.length + "";
  let t1;
  let t2;
  let t3;
  let t4;
  return {
    c() {
      span = element("span");
      t0 = text("Used ");
      t1 = text(t1_value);
      t2 = text(" of ");
      t3 = text(ctx[6]);
      t4 = text(" profiles.");
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(span, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0].models.length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_3$6(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Upgrade account to create and use profiles in cloud.";
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let div2;
  let div1;
  let div0;
  let input;
  let t0;
  let button;
  let t1;
  let t2;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[6] == 0)
      return create_if_block_3$6;
    if (ctx2[1])
      return create_if_block_4$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      button = element("button");
      t1 = text("Add New Profile");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", "New Profile Name");
      attr(button, "class", "btn btn-default");
      attr(button, "role", "button");
      button.disabled = ctx[1];
      attr(div0, "class", "input-group mr3");
      attr(div1, "class", "col-6 col-lg-4 ");
      attr(div2, "class", "row");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, input);
      set_input_value(input, ctx[2]);
      append(div0, t0);
      append(div0, button);
      append(button, t1);
      append(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[14]),
          listen(button, "click", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
      if (dirty & 2) {
        button.disabled = ctx2[1];
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block) {
        if_block.d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$6(ctx) {
  let div;
  let browser2;
  let current;
  browser2 = new Browser({
    props: { session: ctx[3] }
  });
  browser2.$on("save", ctx[10]);
  browser2.$on("discard", ctx[11]);
  browser2.$on("clear", ctx[15]);
  return {
    c() {
      div = element("div");
      create_component(browser2.$$.fragment);
      attr(div, "class", "flex");
      set_style(div, "z-index", "10");
      set_style(div, "background-color", "#fff");
      set_style(div, "position", "fixed");
      set_style(div, "right", "0");
      set_style(div, "bottom", "0");
      set_style(div, "width", "70vw");
      set_style(div, "height", "80vh");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(browser2, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const browser_changes = {};
      if (dirty & 8)
        browser_changes.session = ctx2[3];
      browser2.$set(browser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(browser2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(browser2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(browser2);
    }
  };
}
function create_if_block$f(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      $$slots: {
        header: [create_header_slot$6],
        default: [create_default_slot$9]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[16]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 33554448) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_else_block$f(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[4].sieves;
  const get_key = (ctx2) => ctx2[22].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$9(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$9(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$4();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16) {
        each_value = ctx2[4].sieves;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$9, each_1_anchor, get_each_context$9);
        if (each_value.length) {
          if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        } else if (!each_1_else) {
          each_1_else = create_else_block_1$4();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        }
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_if_block_1$a(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block_1$4(ctx) {
  let t;
  return {
    c() {
      t = text("No monitor found");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$9(key_1, ctx) {
  let div;
  let t_value = ctx[22].name + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      t = text(t_value);
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && t_value !== (t_value = ctx[22].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$9(ctx) {
  let div;
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[4].sieves)
      return create_if_block_1$a;
    return create_else_block$f;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      set_style(div, "max-height", "70vh");
      set_style(div, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_header_slot$6(ctx) {
  let span;
  let t0;
  let t1_value = ctx[4].name + "";
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("Monitors - ");
      t1 = text(t1_value);
      attr(span, "slot", "header");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t1_value !== (t1_value = ctx2[4].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$r(ctx) {
  let list;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  list = new List$5({
    props: {
      store: ctx[7],
      openBrowser: ctx[12],
      showMonitors: ctx[13],
      onClear,
      onDelete: ctx[9],
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[3] && create_if_block_2$6(ctx);
  let if_block1 = ctx[4] && create_if_block$f(ctx);
  return {
    c() {
      create_component(list.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const list_changes = {};
      if (dirty & 33554439) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$f(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
async function onClear(session) {
  await session.save({ cookies: [] });
}
function instance$q($$self, $$props, $$invalidate) {
  let $store;
  let $user;
  let api = getContext("api");
  let user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(17, $user = value));
  getContext("labels");
  let limit2 = $user.constraint.session;
  let limitReached = false;
  let newName;
  let openSession;
  let showMonitorsForSession = null;
  let store2 = new Sessions([], { orderBy: "-ts" });
  component_subscribe($$self, store2, (value) => $$invalidate(0, $store = value));
  setContext("api", api);
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  async function onAdd() {
    $$invalidate(3, openSession = await store2.create({ name: newName || "Untitled" }));
    $$invalidate(2, newName = "");
  }
  async function onDelete(model) {
    await removeSessionFromSieve(model.id);
    await model.destroy();
  }
  async function removeSessionFromSieve(id2) {
    let res = await api(`/sieves?session_id=${id2}`, {
      "state.in": [40, 45, 90],
      _opt: { only: ["id"], limit: 100 }
    });
    let ids = res.data.map((s) => s.id);
    if (ids.length == 0) {
      return;
    }
    await api("/batch/sieves", "PUT", { ids, session_id: null });
    if (res.total_count > res.count) {
      await removeSessionFromSieve(id2);
    }
  }
  async function onSaveData(e) {
    let { cookies } = e.detail;
    await openSession.save({ cookies });
    $$invalidate(3, openSession = null);
  }
  function onDiscard() {
    $$invalidate(3, openSession = null);
  }
  function openBrowser(session) {
    $$invalidate(3, openSession = session);
  }
  async function showMonitors(session) {
    $$invalidate(4, showMonitorsForSession = { ...session, sieves: null });
    $$invalidate(4, showMonitorsForSession.sieves = (await api(`/sieves?state.in[0]=40&state.in[1]=45&_opt[limit]=500&session_id=${session.id}`)).data, showMonitorsForSession);
  }
  function input_input_handler() {
    newName = this.value;
    $$invalidate(2, newName);
  }
  const clear_handler = (e) => onClear(openSession.id);
  const close_handler = () => $$invalidate(4, showMonitorsForSession = null);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, limitReached = $store.length >= limit2);
    }
  };
  return [
    $store,
    limitReached,
    newName,
    openSession,
    showMonitorsForSession,
    user,
    limit2,
    store2,
    onAdd,
    onDelete,
    onSaveData,
    onDiscard,
    openBrowser,
    showMonitors,
    input_input_handler,
    clear_handler,
    close_handler
  ];
}
class Profiles extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$r, safe_not_equal, {});
  }
}
function createProxies(api) {
  let fetched = false;
  const { subscribe: subscribe2, set, update } = writable({
    loading: true,
    custom: {
      total_count: 0,
      count: 0,
      offset: 0,
      data: []
    },
    global: {
      total_count: 0,
      count: 0,
      offset: 0,
      data: []
    },
    plan_id: ""
  });
  async function fetch_custom_proxy() {
    const custom = await api("/proxies");
    const constraint = await api("/users/constraints");
    const global = await api("/proxies/global");
    update((old) => ({
      loading: false,
      constraint,
      custom,
      global,
      plan_id: constraint.plan_id
    }));
  }
  async function del(id2) {
    let res = await api("/proxies/" + id2, "DELETE");
    fetch_custom_proxy();
    return res;
  }
  async function add(doc) {
    const res = await api("/proxies", "POST", doc);
    fetch_custom_proxy();
    return res;
  }
  async function patch2(doc) {
    const res = await api("/proxies/" + doc.id, "PATCH", doc);
    await fetch_custom_proxy();
    return res;
  }
  return {
    subscribe: subscribe2,
    async fetch() {
      !fetched && await fetch_custom_proxy();
      fetched = true;
    },
    del,
    add,
    patch: patch2
  };
}
var EditProxy_svelte_svelte_type_style_lang = "";
function create_if_block_1$9(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text(ctx[1]);
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_default_slot$8(ctx) {
  let form;
  let div1;
  let label0;
  let t1;
  let div0;
  let input0;
  let t2;
  let div3;
  let label1;
  let t4;
  let div2;
  let input1;
  let t5;
  let span;
  let t9;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block_1$9(ctx);
  return {
    c() {
      form = element("form");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = "Name";
      t1 = space();
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      div3 = element("div");
      label1 = element("label");
      label1.textContent = "Proxy";
      t4 = space();
      div2 = element("div");
      input1 = element("input");
      t5 = space();
      span = element("span");
      span.innerHTML = `Add a proxy that authenticates using username and password. <br/> 
          Format: username:password@address:port<br/>
          Example: alpha:bravo@my-proxy-host:9000`;
      t9 = space();
      if (if_block)
        if_block.c();
      attr(label0, "for", "name");
      attr(label0, "class", "col-sm-3 col-form-label svelte-va63su");
      attr(input0, "id", "name");
      attr(input0, "type", "text");
      attr(input0, "class", "form-control");
      attr(input0, "placeholder", "A name to identify proxies from dropdowns");
      attr(div0, "class", "col-sm-9");
      attr(div1, "class", "form-group row");
      attr(label1, "for", "proxylist");
      attr(label1, "class", "col-sm-3 col-form-label svelte-va63su");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control");
      attr(input1, "rows", "4");
      attr(span, "class", "help");
      attr(div2, "class", "col-sm-9");
      attr(div3, "class", "form-group row");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, div1);
      append(div1, label0);
      append(div1, t1);
      append(div1, div0);
      append(div0, input0);
      set_input_value(input0, ctx[0].name);
      append(form, t2);
      append(form, div3);
      append(div3, label1);
      append(div3, t4);
      append(div3, div2);
      append(div2, input1);
      set_input_value(input1, ctx[0].gateway);
      append(div2, t5);
      append(div2, span);
      append(form, t9);
      if (if_block)
        if_block.m(form, null);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[5]),
          listen(input1, "input", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input0.value !== ctx2[0].name) {
        set_input_value(input0, ctx2[0].name);
      }
      if (dirty & 1 && input1.value !== ctx2[0].gateway) {
        set_input_value(input1, ctx2[0].gateway);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$9(ctx2);
          if_block.c();
          if_block.m(form, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(form);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$e(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Proxy");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$e(ctx) {
  let t;
  return {
    c() {
      t = text("Add New Proxy");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot$5(ctx) {
  let span;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block$e;
    return create_else_block$e;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      span = element("span");
      if_block.c();
      attr(span, "slot", "header");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if_block.m(span, null);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      if_block.d();
    }
  };
}
function create_buttons_slot(ctx) {
  let span;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      button = element("button");
      button.textContent = "Save";
      attr(button, "class", "btn btn-primary");
      attr(span, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$q(ctx) {
  let modal;
  let current;
  modal = new Modal$3({
    props: {
      $$slots: {
        buttons: [create_buttons_slot],
        header: [create_header_slot$5],
        default: [create_default_slot$8]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[3]);
  modal.$on("submit", ctx[4]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 515) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let { proxy } = $$props;
  const dispatch = createEventDispatcher();
  const store2 = getContext("store");
  let errMsg = "";
  let isNew = !proxy.id;
  function close() {
    dispatch("close");
  }
  async function handleEdit() {
    let gateway = proxy.gateway;
    $$invalidate(1, errMsg = "");
    if (/https*:\/\//.test(gateway)) {
      gateway = gateway.slice(gateway.indexOf(":") + 3);
    }
    try {
      let url = new URL("http://" + gateway);
      if (!url.username || !url.password) {
        throw new Error("Missing username or password");
      }
    } catch (e) {
      $$invalidate(1, errMsg = `Invalid proxy ${gateway} at line #${i + 1} (${e.message})`);
      return;
    }
    try {
      if (isNew) {
        await store2.add({ ...proxy, gateway });
      } else {
        await store2.patch({ ...proxy, gateway });
      }
      close();
    } catch (err) {
      $$invalidate(1, errMsg = err.message);
    }
  }
  function input0_input_handler() {
    proxy.name = this.value;
    $$invalidate(0, proxy);
  }
  function input1_input_handler() {
    proxy.gateway = this.value;
    $$invalidate(0, proxy);
  }
  $$self.$$set = ($$props2) => {
    if ("proxy" in $$props2)
      $$invalidate(0, proxy = $$props2.proxy);
  };
  return [
    proxy,
    errMsg,
    isNew,
    close,
    handleEdit,
    input0_input_handler,
    input1_input_handler
  ];
}
class EditProxy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$q, safe_not_equal, { proxy: 0 });
  }
}
function get_each_context$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_else_block$d(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="4">Click the add button to add your own proxies and use them for checks in cloud.</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block$d(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[6].name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[6].description + "";
  let t2;
  let t3;
  let td2;
  let div;
  let t4_value = ctx[6].gateway + "";
  let t4;
  let t5;
  let td3;
  let t7;
  let td4;
  let button1;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[3](ctx[6], ...args);
  }
  function click_handler_1(...args) {
    return ctx[4](ctx[6], ...args);
  }
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      div = element("div");
      t4 = text(t4_value);
      t5 = space();
      td3 = element("td");
      td3.innerHTML = `<button class="btn btn-default btn-sm btn-slim">Edit</button>`;
      t7 = space();
      td4 = element("td");
      button1 = element("button");
      button1.textContent = "Delete";
      set_style(div, "max-height", "200px");
      set_style(div, "overflow", "hidden");
      attr(button1, "class", "btn btn-danger btn-sm btn-slim");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, div);
      append(div, t4);
      append(tr, t5);
      append(tr, td3);
      append(tr, t7);
      append(tr, td4);
      append(td4, button1);
      if (!mounted) {
        dispose = [
          listen(td3, "click", click_handler),
          listen(button1, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[6].name + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = ctx[6].description + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx[6].gateway + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block$8(key_1, ctx) {
  let first;
  let if_block_anchor;
  let if_block = ctx[6].state == 40 && create_if_block$d(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[6].state == 40) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$d(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$p(ctx) {
  let div2;
  let div1;
  let t1;
  let table;
  let thead;
  let t9;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t10;
  let tr1;
  let td;
  let button;
  let t12;
  let p;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[6].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$8(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$8(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$d();
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<div style="flex: 1"><h3>My Proxies (beta)</h3></div>`;
      t1 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="col-name">Name</th> 
        <th class="col-desc">Description</th> 
        <th class="col-gateway">Proxy</th> 
        <th class="col-edit"></th> 
        <th class="col-del"></th></tr>`;
      t9 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t10 = space();
      tr1 = element("tr");
      td = element("td");
      button = element("button");
      button.textContent = "Add New Proxy";
      t12 = space();
      p = element("p");
      p.textContent = "Custom proxies are available in Flexi in Enterprise plans";
      attr(div1, "class", "card-header flex items-center");
      attr(button, "class", "btn btn-primary");
      attr(p, "class", "help");
      attr(td, "colspan", "5");
      attr(table, "class", "table");
      attr(div2, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div2, t1);
      append(div2, table);
      append(table, thead);
      append(table, t9);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      append(tbody, t10);
      append(tbody, tr1);
      append(tr1, td);
      append(td, button);
      append(td, t12);
      append(td, p);
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[0];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, destroy_block, create_each_block$8, t10, get_each_context$8);
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$d();
          each_1_else.c();
          each_1_else.m(tbody, t10);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let { proxies } = $$props;
  let { onDelete } = $$props;
  let { onEdit } = $$props;
  const click_handler = (proxy, e) => onEdit(proxy);
  const click_handler_1 = (proxy, e) => onDelete(proxy.id);
  const click_handler_2 = (e) => onEdit({
    name: "New Proxy Name",
    gateway: "",
    description: ""
  });
  $$self.$$set = ($$props2) => {
    if ("proxies" in $$props2)
      $$invalidate(0, proxies = $$props2.proxies);
    if ("onDelete" in $$props2)
      $$invalidate(1, onDelete = $$props2.onDelete);
    if ("onEdit" in $$props2)
      $$invalidate(2, onEdit = $$props2.onEdit);
  };
  return [proxies, onDelete, onEdit, click_handler, click_handler_1, click_handler_2];
}
class List$4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$p, safe_not_equal, { proxies: 0, onDelete: 1, onEdit: 2 });
  }
}
function get_each_context$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2];
  child_ctx[3] = i2;
  return child_ctx;
}
function create_else_block_1$3(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="3">We are adding proxies to the inventory. Check back soon to view updated list.</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_else_block$c(ctx) {
  let t;
  return {
    c() {
      t = text("Available");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$c(ctx) {
  let t_value = ctx[1].msgUpgrade + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[1].msgUpgrade + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$7(key_1, ctx) {
  let tr;
  let td0;
  let t0_value = ctx[1].name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = (ctx[1].cost || 2) + "";
  let t2;
  let t3;
  let td2;
  let t4_value = ctx[1].description + "";
  let t4;
  let t5;
  let td3;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].msgUpgrade)
      return create_if_block$c;
    return create_else_block$c;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = space();
      td3 = element("td");
      if_block.c();
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(tr, t5);
      append(tr, td3);
      if_block.m(td3, null);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[1].name + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = (ctx[1].cost || 2) + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx[1].description + ""))
        set_data(t4, t4_value);
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(td3, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block.d();
    }
  };
}
function create_fragment$o(ctx) {
  let div2;
  let div1;
  let t3;
  let table;
  let thead;
  let t11;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t12;
  let tr1;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[1].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$7(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$7(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$3();
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<div style="flex: 1"><h3>Managed Proxies</h3> 
      <small>Distill provided premium proxies available for checks in cloud.</small></div>`;
      t3 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th width="200">Name</th> 
        <th width="100">Cost*</th> 
        <th>Description</th> 
        <th width="200">Availability</th></tr>`;
      t11 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t12 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<td colspan="4">*The cost of using a proxy is accounted as checks in the account. If a proxy&#39;s cost is N, 1 check using that proxy will be counted as N checks.</td>`;
      attr(div1, "class", "card-header flex items-center");
      attr(table, "class", "table");
      attr(div2, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div2, t3);
      append(div2, table);
      append(table, thead);
      append(table, t11);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      append(tbody, t12);
      append(tbody, tr1);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, destroy_block, create_each_block$7, t12, get_each_context$7);
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block_1$3();
          each_1_else.c();
          each_1_else.m(tbody, t12);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let { proxies } = $$props;
  $$self.$$set = ($$props2) => {
    if ("proxies" in $$props2)
      $$invalidate(0, proxies = $$props2.proxies);
  };
  return [proxies];
}
class ListManaged extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$o, safe_not_equal, { proxies: 0 });
  }
}
function create_else_block$b(ctx) {
  let list;
  let t;
  let listmanaged;
  let current;
  list = new List$4({
    props: {
      proxies: ctx[1].custom.data,
      onDelete: ctx[5],
      onEdit: ctx[4]
    }
  });
  listmanaged = new ListManaged({
    props: { proxies: ctx[1].global.data }
  });
  return {
    c() {
      create_component(list.$$.fragment);
      t = space();
      create_component(listmanaged.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      insert(target, t, anchor);
      mount_component(listmanaged, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & 2)
        list_changes.proxies = ctx2[1].custom.data;
      list.$set(list_changes);
      const listmanaged_changes = {};
      if (dirty & 2)
        listmanaged_changes.proxies = ctx2[1].global.data;
      listmanaged.$set(listmanaged_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      transition_in(listmanaged.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      transition_out(listmanaged.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
      if (detaching)
        detach(t);
      destroy_component(listmanaged, detaching);
    }
  };
}
function create_if_block_1$8(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Loading data...";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$b(ctx) {
  let modaleditproxy;
  let current;
  modaleditproxy = new EditProxy({
    props: {
      proxy: ctx[0],
      api: ctx[2]
    }
  });
  modaleditproxy.$on("close", ctx[6]);
  return {
    c() {
      create_component(modaleditproxy.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modaleditproxy, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modaleditproxy_changes = {};
      if (dirty & 1)
        modaleditproxy_changes.proxy = ctx2[0];
      modaleditproxy.$set(modaleditproxy_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modaleditproxy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modaleditproxy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modaleditproxy, detaching);
    }
  };
}
function create_fragment$n(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_1$8, create_else_block$b];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].loading)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[0] != null && create_if_block$b(ctx);
  return {
    c() {
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t.parentNode, t);
      }
      if (ctx2[0] != null) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$b(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let $store;
  let api = getContext("api");
  let store2 = createProxies(api);
  component_subscribe($$self, store2, (value) => $$invalidate(1, $store = value));
  window.store = store2;
  setContext("store", store2);
  let proxy = null;
  onMount(async () => {
    await store2.fetch();
  });
  async function onEdit(_proxy) {
    if ($store.constraint.price < 8e3) {
      alert("Custom proxies are only available in Flexi and higher plans");
      return;
    }
    $$invalidate(0, proxy = _proxy);
  }
  async function onDelete(id2) {
    await store2.del(id2);
  }
  const close_handler = () => $$invalidate(0, proxy = null);
  return [proxy, $store, api, store2, onEdit, onDelete, close_handler];
}
class Proxies extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$n, safe_not_equal, {});
  }
}
const Backbone$2 = window.Backbone;
if (!Backbone$2) {
  throw new Error("ADD Backbone");
}
const Model = base.Model;
const Collection$1 = base.Collection;
const InputParam = Model.extend({
  defaults: {
    name: "",
    type: "text"
  }
});
var Tpl = Model.extend({
  encodedFields: ["params", "sieve_config", "sieve_rule"],
  urlRoot: "/tpls/sieves",
  defaults: function() {
    return {
      desc_name: "Search Result",
      desc_uri: "https://www.domain.tld",
      desc_info: "Selection contains search result containing url and snippet. Does not contain ads.",
      sieve_type: C$2.TYPE_HTML,
      sieve_uri: null,
      sieve_config: {
        selections: [{
          frames: [{
            index: 0,
            excludes: [],
            includes: [{
              type: "css",
              expr: "body"
            }]
          }],
          dynamic: true
        }],
        includeStyle: false,
        dataAttr: "text"
      },
      params: new Collection$1([])
    };
  },
  parse: function(response) {
    var response = Tpl.__super__.parse.call(this, response);
    response.params = new Collection$1(response.params);
    return response;
  }
});
const Tpls = base.PagedCollection.extend({
  model: Tpl,
  url: "/tpls/sieves"
});
var Pattern = Model.extend({
  encodedFields: ["pattern_params"],
  defaults: function() {
    return {
      pattern: null,
      uri_ref: null,
      pattern_params: new Collection$1()
    };
  },
  parse: function(response) {
    var response = Pattern.__super__.parse.call(this, response);
    response.pattern_params = new Collection$1(response.pattern_params);
    return response;
  }
});
const Patterns = Collection$1.extend({
  model: Pattern,
  url: function() {
    return ["/tpls/sieves", this.tpl.id, "patterns"].join("/");
  }
});
var ModelTpl = {
  Pattern,
  Patterns,
  InputParam,
  Tpl,
  Tpls
};
const domo = window.domo;
if (!domo) {
  throw new Error("ADD domo");
}
const $$1 = window.jQuery;
if (!$$1) {
  throw new Error("ADD jQuery");
}
const _$1 = window._;
if (!_$1) {
  throw new Error("ADD _");
}
const async$1 = window.async;
if (!async$1) {
  throw new Error("ADD async");
}
const moment$1 = window.moment;
if (!moment$1) {
  throw new Error("ADD moment");
}
const Backbone$1 = window.Backbone;
if (!Backbone$1) {
  throw new Error("ADD Backbone");
}
function strToRe(str) {
  return str.replace(/[[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function getSearchParams(url) {
  const params2 = {};
  url.searchParams.forEach(function(v, k) {
    params2[k] = v;
  });
  return params2;
}
const Row = View.Base.extend({
  name: "SieveTplRow",
  tagName: "li",
  className: "list-group-item",
  onDel: function() {
    this.model.destroy();
  },
  render: function() {
    const attrs = this.model.attributes;
    let btnDel;
    this.$el.empty().attr({
      "data-id": attrs.id
    }).append(
      DIV(
        DIV(
          { style: "float: left" },
          btnDel = BUTTON(
            {
              "class": "btn btn-default xbtn-light",
              "title": T("a_del")
            },
            I({ "class": "fa fa-trash-o" })
          )
        ),
        DIV(
          DIV(attrs.desc_name),
          DIV(attrs.desc_uri)
        )
      )
    );
    btnDel.onclick = this.onDel;
    return this;
  }
});
const Collection = View.Collection.extend({
  name: "TplCollection",
  tagName: "ul",
  className: "list-group",
  addOne: function(model) {
    const view = new Row({ model, parent: this });
    this.$el.append(view.render().el);
    return view;
  }
});
const TplList = View.ActionProvider.extend({
  postInit: function() {
    if (!App.user.isLoggedIn()) {
      this.view = new Backbone$1.View({ el: DIV("Please sign in to your account and try again") });
    } else {
      this.view = new Collection({
        collection: this.collection = new ModelTpl.Tpls(),
        parent: this
      });
    }
  },
  render: function() {
    this.$el.empty().append(
      DIV(
        { "class": "xpage-header" },
        H3(T("l_sieve_tpl_list"), " ", SMALL("(beta)"))
      ),
      this.view.render().el
    );
    return this;
  },
  showList: function() {
    this.collection && this.collection.fetch({ data: { user_id: USER.id } });
  }
});
const DescEditor = View.ActionProvider.extend({
  postInit: function(options) {
    const model = this.model;
    this.fields = {
      name: Editor.create("text", {
        parent: this,
        model,
        param: {
          name: "desc_name",
          help: "h_tpl_desc_name"
        }
      }),
      info: Editor.create("textarea", {
        parent: this,
        model,
        param: {
          name: "desc_info",
          help: "h_desc"
        }
      })
    };
  },
  render: function() {
    const fields = this.fields;
    this.$el.empty().append(
      _$1.map(["name", "info"], function(key) {
        return DIV(
          { "class": "form-group" },
          LABEL({ "class": "control-label col-md-2" }, T("l_tpl_desc_" + key)),
          DIV(
            { "class": "col-md-10" },
            fields[key].render().el
          )
        );
      })
    );
    return this;
  }
});
const SimpleTplEditor = View.ActionProvider.extend({
  name: "SimpleTplEditor",
  actions: {
    "tpl_save": { fn: "action_save" }
  },
  action_save: function(x, el) {
    const self = this;
    const newModel = this.model.clone();
    $$1(el).button("loading");
    newModel.save({
      sieve_config: JSON.parse(this.sieve.config),
      sieve_type: this.sieve.content_type
    }, {
      error: onError,
      success: function(model) {
        Msg.info("Template saved!");
        setTimeout(savePatterns, 0);
      }
    });
    function savePatterns() {
      self.patterns.tpl = newModel;
      async$1.each(self.patterns.models, savePattern, function(err, res) {
        if (err) {
          onError(err);
        } else {
          onFinish();
        }
      });
    }
    function savePattern(pattern, callback) {
      pattern.save(null, {
        error: function() {
          callback(new Error("Failed to save pattern"));
        },
        success: function() {
          callback();
        }
      });
    }
    function onFinish() {
      $$1(el).button("reset");
      push$1("/w/tpls/all/");
    }
    function onError(err) {
      console.error("Error saving template", err);
      $$1(el).button("reset");
      Msg.error("Failed to save template");
    }
  },
  handleNetworkError: function() {
    let msg = App.user.isLoggedIn() ? "Failed to load data. Please check network connection and try again." : "Please sign in to your account and try again";
    this.$elLoad.addClass("error").text(msg);
  },
  postInit: function(options) {
    const model = this.model;
    this.patterns = new ModelTpl.Patterns();
    this.pattern = new ModelTpl.Pattern();
    this.patterns.add(this.pattern);
    this.views = {
      patternURIEditor: new Editor.create("text", {
        parent: this,
        model: this.pattern,
        param: {
          name: "pattern",
          help: "h_tpl_url_pattern"
        }
      }),
      desc: new DescEditor({ parent: this, model }).render()
    };
    this.$el.addClass("form-horizontal");
    this.$el.empty().append(
      DIV(
        { "class": "xpage-header" },
        H4(T("Match URL"))
      ),
      DIV(
        { "class": "form-group" },
        LABEL({ "class": "control-label col-md-2" }, T("l_uri_pattern")),
        this.elTip = DIV(
          { "class": "col-md-10 hide" },
          this.views.patternURIEditor.render().el
        ),
        this.elLoad = DIV(
          { "class": "col-md-10" },
          "Loading data..."
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL({ "class": "control-label col-md-2" }, T("l_url")),
        DIV(
          { "class": "col-md-10" },
          this.elURL = DIV()
        )
      ),
      this.elDesc = DIV(
        { "class": "hide" },
        DIV(
          { "class": "xpage-header" },
          H4(T("l_desc"))
        ),
        this.views.desc.el,
        DIV(
          { "class": "form-group" },
          DIV(
            { "class": "col-md-offset-2 col-md-10 xtbar-form" },
            BUTTON({
              "class": "btn btn-primary xbtn-default",
              "data-action": "tpl_save"
            }, T("a_save")),
            BUTTON({
              "class": "btn btn-default",
              "data-action": "go_back"
            }, T("a_discard"))
          )
        )
      )
    );
    this.$elLoad = $$1(this.elLoad);
    this.start();
  },
  setPattern: function(pattern) {
    const sieve = this.sieve;
    new URL(sieve.uri);
    $$1(this.elLoad).remove();
    $$1(this.elTip).removeClass("hide");
    $$1(this.elDesc).removeClass("hide");
    if (!pattern) {
      $$1(this.elTip).find("input").focus();
    } else {
      $$1(this.elDesc).find("input").first().focus();
    }
    this.pattern.set({
      pattern: pattern || strToRe(sieve.uri.split("/").slice(2).join("/")) + "$",
      uri_ref: sieve.uri
    });
    this.model.set({
      desc_name: sieve.name,
      desc_info: "",
      desc_uri: sieve.uri.split("/").slice(0, 3).join("/")
    });
  },
  start: function() {
    const self = this;
    Api.api("/sieves/" + this.options.sieveId, "GET", {}, function(err, sieve) {
      if (err) {
        self.handleNetworkError();
        return;
      }
      self.sieve = sieve;
      const uri = sieve.uri;
      self.$elLoad.text("Finding URL pattern...");
      self.elURL.textContent = uri;
      async$1.parallel({
        sieves: function(callback) {
          const host = new URL(uri).host;
          Api.api("/sieves", "GET", {
            "uri.ne": uri,
            "uri.like": "%" + host + "%",
            "state.in": [40, 45]
          }, callback);
        },
        patterns: function(callback) {
          Api.api("/tpls/patterns/search", "GET", {
            url: uri
          }, callback);
        }
      }, function(err2, result) {
        if (err2) {
          console.error("Failed to fetch data: ", err2);
          self.handleNetworkError();
        } else {
          self.suggestOptions(sieve, result.sieves.data, result.patterns.data);
        }
      });
    });
  },
  suggestOptions: function(sieve, sieves, patterns) {
    const self = this;
    const uri = sieve.uri;
    let suggestedPatterns;
    this.$elLoad.empty();
    if (patterns.length > 0) {
      suggestedPatterns = patterns;
    } else if (sieves.length > 0) {
      suggestedPatterns = this.generatePatterns(uri, sieves);
    }
    if (suggestedPatterns) {
      suggestedPatterns = _$1.uniq(suggestedPatterns, function(sp) {
        return sp.pattern;
      });
      this.$elLoad.append(
        DIV(
          { "class": "list-group" },
          _$1.map(suggestedPatterns, function(pattern) {
            return A(
              { "href": "#", "class": "list-group-item" },
              DIV(SAMP(pattern.pattern)),
              SMALL(pattern.uri_ref)
            );
          })
        ),
        P(),
        BUTTON({ "class": "btn btn-default" }, "Or, use custom pattern")
      );
      this.$(".list-group-item").click(".list-group-item", function(e) {
        e.preventDefault();
        self.setPattern($$1(e.currentTarget).find("samp").text());
      });
      this.$elLoad.find("button").click(function() {
        self.setPattern();
      });
    } else {
      this.setPattern();
    }
  },
  generatePatterns: function(uri, sieves) {
    const parts = uri.split("/");
    const url = new URL(uri);
    const pathParts = url.pathname.split("/");
    const searchParams = getSearchParams(url);
    const similarSieves = _$1.filter(sieves, function(sieve) {
      const url2 = new URL(sieve.uri);
      const pathParts2 = url2.pathname.split("/");
      const searchParams2 = getSearchParams(url2);
      return pathParts.length == pathParts2.length && _$1.isEqual(_$1.keys(searchParams), _$1.keys(searchParams2));
    });
    if (similarSieves.length > 0) {
      return _$1.map(similarSieves, function(sieve) {
        const refParts = sieve.uri.split("/");
        const exprParts = _$1.map(parts, function(part, i2) {
          return part === refParts[i2] ? strToRe(part) : part.length > 0 ? "(.*)" : "";
        });
        exprParts[2] = strToRe(parts[2]);
        return {
          pattern: exprParts.slice(2).join("/") + (url.pathname == "/" ? "$" : ""),
          uri_ref: sieve.uri
        };
      });
    }
  }
});
const TplEditor = View.ActionProvider.extend({
  name: "TplEditor",
  create: function(sieveId) {
    if (this.view) {
      this.view.remove();
    }
    this.view = new SimpleTplEditor({
      parent: this,
      sieveId,
      model: new ModelTpl.Tpl()
    });
    this.elView.appendChild(this.view.render().el);
  },
  render: function() {
    this.$el.empty().append(
      DIV(
        { "class": "xtbar  mb-4 ml-2" },
        BUTTON(
          {
            "class": "btn btn-default",
            "data-action": "go_back"
          },
          I({ "class": "fa fa-chevron-left" }),
          " ",
          T("a_discard")
        )
      ),
      DIV(
        { "class": "xpage-header" },
        H3(
          T("l_tpl"),
          " ",
          SMALL("Templates help add monitors using preconfigured selections.")
        )
      ),
      this.elView = DIV()
    );
    return this;
  }
});
var ViewSieveTpls = {
  TplList,
  Editor: TplEditor
};
function create_fragment$m(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[1](div0);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[1](null);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  getContext("api");
  let parent2 = getContext("view:root");
  let el;
  let view;
  onMount(() => {
    view = new ViewSieveTpls.TplList({ el, parent: parent2 }).render();
    view.showList();
    return () => view.remove();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  return [el, div0_binding];
}
class List$3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$m, safe_not_equal, {});
  }
}
function create_fragment$l(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[2](div0);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[2](null);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { route: route2 } = $$props;
  getContext("api");
  let parent2 = getContext("view:root");
  let el;
  let view;
  onMount(() => {
    view = new ViewSieveTpls.Editor({ el, parent: parent2 }).render();
    view.create(route2.id);
    return () => view.remove();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$invalidate(1, route2 = $$props2.route);
  };
  return [el, route2, div0_binding];
}
class AddFrom extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$l, safe_not_equal, { route: 1 });
  }
}
function create_if_block$a(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$5,
    then: create_then_block$5,
    catch: create_catch_block$5,
    value: 4,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 1 && promise !== (promise = ctx[0]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block$5(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$5(ctx) {
  let a;
  let h3;
  let t2;
  let sievedatalist;
  let current;
  sievedatalist = new SieveDataList({ props: { sieve: ctx[1] } });
  return {
    c() {
      a = element("a");
      h3 = element("h3");
      h3.textContent = `${ctx[1].get("name")} | Monitor`;
      t2 = space();
      create_component(sievedatalist.$$.fragment);
      attr(h3, "class", "ph3");
      attr(a, "href", urlCfg.sievePage(ctx[1].id));
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, h3);
      insert(target, t2, anchor);
      mount_component(sievedatalist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(sievedatalist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedatalist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (detaching)
        detach(t2);
      destroy_component(sievedatalist, detaching);
    }
  };
}
function create_pending_block$5(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_default_slot$7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block$a(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$k(ctx) {
  let watchlistlayout;
  let current;
  watchlistlayout = new WatchListLayout({
    props: {
      renderDefaultToolbar: true,
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(watchlistlayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(watchlistlayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const watchlistlayout_changes = {};
      if (dirty & 33) {
        watchlistlayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      watchlistlayout.$set(watchlistlayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(watchlistlayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(watchlistlayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(watchlistlayout, detaching);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let { params: params2 } = $$props;
  let { sieveId = params2 == null ? void 0 : params2.id } = $$props;
  let sieve = new Model$2.Sieve({ id: sieveId });
  let sieveFetchPromise = null;
  if (sieveId) {
    sieveFetchPromise = sieve.fetch();
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(2, params2 = $$props2.params);
    if ("sieveId" in $$props2)
      $$invalidate(3, sieveId = $$props2.sieveId);
  };
  return [sieveFetchPromise, sieve, params2, sieveId];
}
class SieveDetail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$k, safe_not_equal, { params: 2, sieveId: 3 });
  }
}
function create_catch_block$4(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$4(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let list;
  let current;
  const if_block_creators = [
    create_if_block$9,
    create_if_block_2$5,
    create_if_block_3$5,
    create_if_block_6,
    create_if_block_7,
    create_if_block_8,
    create_if_block_9,
    create_else_block$a
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].module == "sieve")
      return 0;
    if (ctx2[0].module == "import")
      return 1;
    if (ctx2[0].module == "tpls")
      return 2;
    if (ctx2[0].module == "macros")
      return 3;
    if (ctx2[0].module == "profiles")
      return 4;
    if (ctx2[0].module == "proxies")
      return 5;
    if (ctx2[0].module == "list")
      return 6;
    return 7;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  list = new List$7({
    props: {
      hidden: ctx[0].module != "list"
    }
  });
  return {
    c() {
      if_block.c();
      t = space();
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
      const list_changes = {};
      if (dirty & 1)
        list_changes.hidden = ctx2[0].module != "list";
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      destroy_component(list, detaching);
    }
  };
}
function create_else_block$a(ctx) {
  let error404;
  let current;
  error404 = new Error404({ props: { useLayout: false } });
  return {
    c() {
      create_component(error404.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error404, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(error404.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error404.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error404, detaching);
    }
  };
}
function create_if_block_9(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_if_block_8(ctx) {
  let proxies;
  let current;
  proxies = new Proxies({});
  return {
    c() {
      create_component(proxies.$$.fragment);
    },
    m(target, anchor) {
      mount_component(proxies, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(proxies.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(proxies.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(proxies, detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let profiles;
  let current;
  profiles = new Profiles({});
  return {
    c() {
      create_component(profiles.$$.fragment);
    },
    m(target, anchor) {
      mount_component(profiles, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(profiles.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profiles.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(profiles, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let macros;
  let current;
  macros = new Macros_1({});
  return {
    c() {
      create_component(macros.$$.fragment);
    },
    m(target, anchor) {
      mount_component(macros, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(macros.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(macros.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(macros, detaching);
    }
  };
}
function create_if_block_3$5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$2, create_if_block_5$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0].prefix == "all")
      return 0;
    if (ctx2[0].prefix == "add-from")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_2$5(ctx) {
  let import_1;
  let current;
  import_1 = new Import({ props: { route: ctx[0] } });
  return {
    c() {
      create_component(import_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(import_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const import_1_changes = {};
      if (dirty & 1)
        import_1_changes.route = ctx2[0];
      import_1.$set(import_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(import_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(import_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(import_1, detaching);
    }
  };
}
function create_if_block$9(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (ctx[0].prefix == "dup" || ctx[0].prefix == "add" || ctx[0].prefix == "edit") && create_if_block_1$7(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0].prefix == "dup" || ctx2[0].prefix == "add" || ctx2[0].prefix == "edit") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_5$1(ctx) {
  let addtplfrom;
  let current;
  addtplfrom = new AddFrom({ props: { route: ctx[0] } });
  return {
    c() {
      create_component(addtplfrom.$$.fragment);
    },
    m(target, anchor) {
      mount_component(addtplfrom, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const addtplfrom_changes = {};
      if (dirty & 1)
        addtplfrom_changes.route = ctx2[0];
      addtplfrom.$set(addtplfrom_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(addtplfrom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(addtplfrom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(addtplfrom, detaching);
    }
  };
}
function create_if_block_4$2(ctx) {
  let tpllist;
  let current;
  tpllist = new List$3({});
  return {
    c() {
      create_component(tpllist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tpllist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tpllist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tpllist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tpllist, detaching);
    }
  };
}
function create_if_block_1$7(ctx) {
  let edit;
  let current;
  edit = new Sieve_options({ props: { route: ctx[0] } });
  return {
    c() {
      create_component(edit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const edit_changes = {};
      if (dirty & 1)
        edit_changes.route = ctx2[0];
      edit.$set(edit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edit, detaching);
    }
  };
}
function create_pending_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$6(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block$4,
    blocks: [, , ,]
  };
  handle_promise(ctx[2], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$j(ctx) {
  let watchlistlayout;
  let current;
  watchlistlayout = new WatchListLayout({
    props: {
      contentScrollTop: ctx[1],
      renderDefaultToolbar: !["list", "sieve", "tpls"].includes(ctx[0].module) || ctx[0].module === "tpls" && ctx[0].prefix !== "add-from",
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  watchlistlayout.$on("scroll", ctx[3]);
  return {
    c() {
      create_component(watchlistlayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(watchlistlayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const watchlistlayout_changes = {};
      if (dirty & 2)
        watchlistlayout_changes.contentScrollTop = ctx2[1];
      if (dirty & 1)
        watchlistlayout_changes.renderDefaultToolbar = !["list", "sieve", "tpls"].includes(ctx2[0].module) || ctx2[0].module === "tpls" && ctx2[0].prefix !== "add-from";
      if (dirty & 131073) {
        watchlistlayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      watchlistlayout.$set(watchlistlayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(watchlistlayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(watchlistlayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(watchlistlayout, detaching);
    }
  };
}
function matchRoute(rParam, path) {
  let i2 = 0, params2 = {};
  let matches = rParam.pattern.exec(path);
  while (i2 < rParam.keys.length) {
    params2[rParam.keys[i2]] = matches[++i2] || null;
  }
  return params2;
}
function hasFolderChanged({ oldRoute, newRoute }) {
  const newPrefix = newRoute.prefix;
  const newWild = newRoute.wild;
  if (oldRoute.prefix === newPrefix && oldRoute.wild && !newWild) {
    return false;
  }
  if (newPrefix !== "label" && !newWild) {
    return true;
  }
  if (newPrefix === "label") {
    if (oldRoute.data !== newRoute.data) {
      return true;
    }
  }
  return false;
}
function instance$i($$self, $$props, $$invalidate) {
  let $route;
  let $querystring;
  component_subscribe($$self, route, ($$value) => $$invalidate(0, $route = $$value));
  component_subscribe($$self, querystring, ($$value) => $$invalidate(7, $querystring = $$value));
  let { params: params2 = {} } = $$props;
  let contentScrollTop = 0;
  let lastListScrollTop = 0;
  const user = getContext("user");
  const labels = getContext("labels");
  const clients = new ModelClient.Clients(user.clients);
  clients.defaultId = getContext("clientId");
  const sieves = new Model$2.Sieves(
    null,
    {
      comparator(model) {
        return -new Date(model.get("ts_data"));
      }
    }
  );
  setContext("clients", clients);
  setContext("watchlist:stores", { clients, sieves });
  const initPromise = fetchAll();
  setTimeout(
    () => {
      if (Supports.agents.local) {
        clientMsgs.fetch();
      }
      if (user.isLoggedIn()) {
        userMsgs.fetch({ data: { ts_viewed: "$null" } });
      }
    },
    2e3
  );
  window.App.clients = clients;
  window.App.sieves = sieves;
  const routes = [":data.d/:id.id", ":data.d/", ":id.id", ""];
  const rParams = routes.map(parse$3);
  function onParamsChange(params3) {
    if (params3.prefix == "error") {
      if (Supports.agents.local) {
        serviceProxy.ErrorActions.clearErrorUnreadList();
      }
    }
    let { prefix, wild } = params3;
    if (wild) {
      let path = "/" + wild;
      for (let rp of rParams) {
        if (rp.pattern.test(path)) {
          params3 = { ...params3, ...matchRoute(rp, path) };
          break;
        }
      }
    }
    params3.query = lib.parse($querystring);
    const oldRoute = $route;
    let oldModule = $route.module;
    let newModule = params3.module;
    let oldTeam = $route.team;
    let newTeam = params3.team;
    if (oldTeam != newTeam) {
      Api.setIdentityId(newTeam == 0 ? null : newTeam);
      fetchAll();
    }
    route.set(params3);
    if (oldModule != newModule) {
      if (oldModule == "list") {
        $$invalidate(1, contentScrollTop = lastListScrollTop);
      } else if (newModule == "list") {
        $$invalidate(1, contentScrollTop += 1);
      }
    } else {
      if (hasFolderChanged({ oldRoute, newRoute: params3 })) {
        if (contentScrollTop === 0) {
          $$invalidate(1, contentScrollTop = 1);
        } else {
          $$invalidate(1, contentScrollTop = 0);
        }
      }
    }
  }
  function onScroll(e) {
    $route.module == "list" && (lastListScrollTop = e.target.scrollTop);
  }
  instance$4s.on("clients", fetchClients);
  instance$4s.on("open", fetchAll);
  instance$4s.on("tags", fetchLabels);
  onDestroy(() => {
    instance$4s.off("clients", fetchClients);
    instance$4s.off("open", fetchAll);
    instance$4s.off("tags", fetchLabels);
  });
  async function fetchClients() {
    await clients.fetch();
  }
  async function fetchAll() {
    await Promise.all([fetchClients()]);
  }
  async function fetchLabels() {
    await labels.fetch();
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(4, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        window.App.route = $route;
      }
    }
    if ($$self.$$.dirty & 16) {
      {
        onParamsChange(params2);
      }
    }
  };
  return [$route, contentScrollTop, initPromise, onScroll, params2];
}
class Watchlist extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$j, safe_not_equal, { params: 4 });
  }
}
function create_else_block$9(ctx) {
  let t;
  return {
    c() {
      t = text("N/A");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$8(ctx) {
  var _a;
  let t0;
  let t1_value = ((_a = ctx[3]) == null ? void 0 : _a.total) + "";
  let t1;
  let t2;
  let t3_value = ctx[3].queued + "";
  let t3;
  let t4;
  let t5_value = ctx[3].crawled + "";
  let t5;
  let t6;
  let t7_value = ctx[3].errorred + "";
  let t7;
  return {
    c() {
      t0 = text("Total: ");
      t1 = text(t1_value);
      t2 = text(", Queued: ");
      t3 = text(t3_value);
      t4 = text(", Crawled: ");
      t5 = text(t5_value);
      t6 = text(", Errorred: ");
      t7 = text(t7_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
      insert(target, t5, anchor);
      insert(target, t6, anchor);
      insert(target, t7, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(t7);
    }
  };
}
function create_fragment$i(ctx) {
  let tr;
  let td0;
  let a;
  let t0_value = ctx[1].name + "";
  let t0;
  let a_href_value;
  let t1;
  let td1;
  let t2_value = (ctx[1].url || "N/A") + "";
  let t2;
  let t3;
  let td2;
  let t4_value = new Date(ctx[1].ts).toLocaleString() + "";
  let t4;
  let t5;
  let td3;
  let t6;
  let td4;
  let span;
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[3]) == null ? void 0 : _a.total)
      return create_if_block$8;
    return create_else_block$9;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = space();
      td3 = element("td");
      if_block.c();
      t6 = space();
      td4 = element("td");
      span = element("span");
      span.textContent = `${ctx[4]() ? "Active" : "Inactive"}`;
      attr(a, "href", a_href_value = "#/u/" + ctx[2] + "/crawlers/" + ctx[1].id);
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, a);
      append(a, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(tr, t5);
      append(tr, td3);
      if_block.m(td3, null);
      append(tr, t6);
      append(tr, td4);
      append(td4, span);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].name + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && a_href_value !== (a_href_value = "#/u/" + ctx2[2] + "/crawlers/" + ctx2[1].id)) {
        attr(a, "href", a_href_value);
      }
      if (dirty & 2 && t2_value !== (t2_value = (ctx2[1].url || "N/A") + ""))
        set_data(t2, t2_value);
      if (dirty & 2 && t4_value !== (t4_value = new Date(ctx2[1].ts).toLocaleString() + ""))
        set_data(t4, t4_value);
      if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block.d();
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let $crawler, $$unsubscribe_crawler = noop, $$subscribe_crawler = () => ($$unsubscribe_crawler(), $$unsubscribe_crawler = subscribe(crawler, ($$value) => $$invalidate(1, $crawler = $$value)), crawler);
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(5, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_crawler());
  let { crawler } = $$props;
  $$subscribe_crawler();
  let team = $params == null ? void 0 : $params.team;
  let meta = $crawler.meta;
  function isReady() {
    return $crawler.state === C$2.STATE_READY;
  }
  $$self.$$set = ($$props2) => {
    if ("crawler" in $$props2)
      $$subscribe_crawler($$invalidate(0, crawler = $$props2.crawler));
  };
  return [crawler, $crawler, team, meta, isReady];
}
class Crawler extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$i, safe_not_equal, { crawler: 0 });
  }
}
function get_each_context$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  child_ctx[17] = i2;
  return child_ctx;
}
const get_header_slot_changes$1 = (dirty) => ({});
const get_header_slot_context$1 = (ctx) => ({ slot: "header" });
function create_if_block$7(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      onSave: ctx[7],
      disableSave: ctx[2],
      isDialog: false,
      $$slots: {
        header: [create_header_slot$4],
        default: [create_default_slot$5]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[13]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 4)
        savemodal_changes.disableSave = ctx2[2];
      if (dirty & 16424) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let crawleditor;
  let updating_crawler;
  let current;
  function crawleditor_crawler_binding(value) {
    ctx[12](value);
  }
  let crawleditor_props = { errorMsg: ctx[3] };
  if (ctx[5] !== void 0) {
    crawleditor_props.crawler = ctx[5];
  }
  crawleditor = new CrawlEditor({ props: crawleditor_props });
  binding_callbacks.push(() => bind$2(crawleditor, "crawler", crawleditor_crawler_binding));
  crawleditor.$on("regex", ctx[8]);
  return {
    c() {
      create_component(crawleditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(crawleditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const crawleditor_changes = {};
      if (dirty & 8)
        crawleditor_changes.errorMsg = ctx2[3];
      if (!updating_crawler && dirty & 32) {
        updating_crawler = true;
        crawleditor_changes.crawler = ctx2[5];
        add_flush_callback(() => updating_crawler = false);
      }
      crawleditor.$set(crawleditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crawleditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crawleditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(crawleditor, detaching);
    }
  };
}
function fallback_block$1(ctx) {
  let t;
  return {
    c() {
      t = text("Configure Crawler");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot$4(ctx) {
  let current;
  const header_slot_template = ctx[11].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[14], get_header_slot_context$1);
  const header_slot_or_fallback = header_slot || fallback_block$1();
  return {
    c() {
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(header_slot_template, ctx2[14], dirty, get_header_slot_changes$1),
            get_header_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
    }
  };
}
function create_else_block$8(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No crawler found</td> 
        `;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$6(key_1, ctx) {
  let first;
  let crawler_1;
  let current;
  crawler_1 = new Crawler({ props: { crawler: ctx[5] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(crawler_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(crawler_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const crawler_1_changes = {};
      if (dirty & 16)
        crawler_1_changes.crawler = ctx[5];
      crawler_1.$set(crawler_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crawler_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crawler_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(crawler_1, detaching);
    }
  };
}
function create_fragment$h(ctx) {
  let div3;
  let div2;
  let div0;
  let t3;
  let div1;
  let t4;
  let searchbar;
  let t5;
  let listpager;
  let t6;
  let sortby;
  let t7;
  let t8;
  let table;
  let thead;
  let t18;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[10]);
  listpager = new ListPager({ props: { store: ctx[0] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[9],
      sortingFields: ctx[6],
      currentFieldName: ctx[4].orderBy
    }
  });
  let if_block = ctx[1] && create_if_block$7(ctx);
  let each_value = ctx[4].models;
  const get_key = (ctx2) => ctx2[5].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$6(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$6(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$8();
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>Crawlers</h3> 
    <small>Manage all available crawlers</small>`;
      t3 = space();
      div1 = element("div");
      t4 = space();
      create_component(searchbar.$$.fragment);
      t5 = space();
      create_component(listpager.$$.fragment);
      t6 = space();
      create_component(sortby.$$.fragment);
      t7 = space();
      if (if_block)
        if_block.c();
      t8 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th>Name</th> 
      <th>Start URL</th> 
      <th>Created On</th> 
      <th>Last Run Summary</th> 
      <th>State</th></tr>`;
      t18 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      set_style(div1, "max-width", "50px");
      attr(div2, "class", "card-header flex items-center");
      attr(thead, "class", "table-light");
      attr(table, "class", "table");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t3);
      append(div2, div1);
      append(div2, t4);
      mount_component(searchbar, div2, null);
      append(div2, t5);
      mount_component(listpager, div2, null);
      append(div2, t6);
      mount_component(sortby, div2, null);
      append(div2, t7);
      if (if_block)
        if_block.m(div2, null);
      append(div3, t8);
      append(div3, table);
      append(table, thead);
      append(table, t18);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const listpager_changes = {};
      if (dirty & 1)
        listpager_changes.store = ctx2[0];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 16)
        sortby_changes.currentFieldName = ctx2[4].orderBy;
      sortby.$set(sortby_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 16) {
        each_value = ctx2[4].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$6, null, get_each_context$6);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$8();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      transition_out(if_block);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      if (if_block)
        if_block.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store2, ($$value) => $$invalidate(4, $store = $$value)), store2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { $$slots: slots = {}, $$scope } = $$props;
  const sortingFields = [
    { value: "ts", label: "Created" },
    {
      value: "-ts",
      label: "Created - Descending"
    },
    { value: "config->url", label: "Url" },
    {
      value: "-config:->url",
      label: "Url - Descending"
    },
    { value: "name", label: "Name" },
    {
      value: "-name",
      label: "Name - Descending"
    }
  ];
  let showEditorModal = false;
  let disableSave = false;
  let errorMsg;
  let searchQuery = "";
  let { store: store2 = new Crawlers() } = $$props;
  $$subscribe_store();
  let crawler;
  async function saveCrawler() {
    try {
      $$invalidate(2, disableSave = true);
      await crawler.save();
      $$invalidate(1, showEditorModal = false);
      $$invalidate(2, disableSave = false);
    } catch (err) {
      $$invalidate(2, disableSave = false);
      $$invalidate(3, errorMsg = err.message);
    }
    await store2.fetch();
  }
  function regexChange(e) {
    if (e.detail.error) {
      $$invalidate(2, disableSave = true);
    } else if (disableSave) {
      $$invalidate(2, disableSave = false);
    }
  }
  async function onSort(by) {
    $$invalidate(0, store2.orderBy = by, store2);
    await store2.fetch();
  }
  async function onSearch2(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      store2.setQuery({});
      return await store2.fetch({ reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({
      $or: {
        "name.ilike": searchQuery,
        "config:->>'url'.ilike": searchQuery
      }
    });
    return await store2.goto(0, { reset: true });
  }
  function crawleditor_crawler_binding(value) {
    crawler = value;
    $$invalidate(5, crawler);
  }
  const close_handler = () => {
    $$invalidate(1, showEditorModal = false);
    store2.fetch();
  };
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(0, store2 = $$props2.store));
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  return [
    store2,
    showEditorModal,
    disableSave,
    errorMsg,
    $store,
    crawler,
    sortingFields,
    saveCrawler,
    regexChange,
    onSort,
    onSearch2,
    slots,
    crawleditor_crawler_binding,
    close_handler,
    $$scope
  ];
}
class List$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$h, safe_not_equal, { store: 0 });
  }
}
function create_catch_block$3(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$3(ctx) {
  let div2;
  let div1;
  let div0;
  let list;
  let current;
  list = new List$2({ props: { store: ctx[1] } });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(list.$$.fragment);
      attr(div0, "class", "col-sm-12");
      attr(div1, "class", "row");
      attr(div2, "class", "container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      mount_component(list, div0, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(list);
    }
  };
}
function create_pending_block$3(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_default_slot$4(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    value: 2,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[0].fetchPromise, info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 1 && promise !== (promise = ctx[0].fetchPromise) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_header_slot$3(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Crawlers</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot$3(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 8) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$g(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      renderDefaultToolbar: true,
      $$slots: {
        topbar: [create_topbar_slot$3],
        default: [create_default_slot$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 9) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let $store;
  let store2 = new Crawlers();
  component_subscribe($$self, store2, (value) => $$invalidate(0, $store = value));
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  return [$store, store2];
}
class Crawlers_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$g, safe_not_equal, {});
  }
}
function create_else_block_1$2(ctx) {
  let td0;
  let t;
  let td1;
  let if_block0 = (ctx[4].ts_start || ctx[4].ts) && create_if_block_5(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[4].ts_end && ctx2[4].state !== C$2.STATE_READY)
      return create_if_block_4$1;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      td0 = element("td");
      if (if_block0)
        if_block0.c();
      t = space();
      td1 = element("td");
      if_block1.c();
    },
    m(target, anchor) {
      insert(target, td0, anchor);
      if (if_block0)
        if_block0.m(td0, null);
      insert(target, t, anchor);
      insert(target, td1, anchor);
      if_block1.m(td1, null);
    },
    p(ctx2, dirty) {
      if (ctx2[4].ts_start || ctx2[4].ts) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          if_block0.m(td0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(td1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach(t);
      if (detaching)
        detach(td1);
      if_block1.d();
    }
  };
}
function create_if_block_3$4(ctx) {
  let td0;
  let t1;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.textContent = "Waiting...";
      t1 = space();
      td1 = element("td");
      td1.textContent = "N/A";
    },
    m(target, anchor) {
      insert(target, td0, anchor);
      insert(target, t1, anchor);
      insert(target, td1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(td1);
    }
  };
}
function create_if_block_5(ctx) {
  let a;
  let t_value = new Date(ctx[4].ts_start || ctx[4].ts).toLocaleString() + "";
  let t;
  let a_href_value;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "href", a_href_value = "#/u/" + ctx[6] + "/crawlers/" + ctx[1] + "/" + ctx[0].id);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = new Date(ctx2[4].ts_start || ctx2[4].ts).toLocaleString() + ""))
        set_data(t, t_value);
      if (dirty & 3 && a_href_value !== (a_href_value = "#/u/" + ctx2[6] + "/crawlers/" + ctx2[1] + "/" + ctx2[0].id)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_else_block_2(ctx) {
  let t;
  return {
    c() {
      t = text("N/A");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_4$1(ctx) {
  let t_value = new Date(ctx[4].ts_end).toLocaleString() + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = new Date(ctx2[4].ts_end).toLocaleString() + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$7(ctx) {
  let t;
  return {
    c() {
      t = text("No meta");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$4(ctx) {
  var _a;
  let t0;
  let t1_value = ((_a = ctx[4].meta) == null ? void 0 : _a.total) + "";
  let t1;
  let t2;
  let t3_value = ctx[4].meta.queued + "";
  let t3;
  let t4;
  let t5_value = ctx[4].meta.crawled + "";
  let t5;
  let t6;
  let t7_value = ctx[4].meta.errorred + "";
  let t7;
  return {
    c() {
      t0 = text("Total: ");
      t1 = text(t1_value);
      t2 = text(", Queued: ");
      t3 = text(t3_value);
      t4 = text(", Crawled: ");
      t5 = text(t5_value);
      t6 = text(", Errorred: ");
      t7 = text(t7_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
      insert(target, t5, anchor);
      insert(target, t6, anchor);
      insert(target, t7, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 16 && t1_value !== (t1_value = ((_a2 = ctx2[4].meta) == null ? void 0 : _a2.total) + ""))
        set_data(t1, t1_value);
      if (dirty & 16 && t3_value !== (t3_value = ctx2[4].meta.queued + ""))
        set_data(t3, t3_value);
      if (dirty & 16 && t5_value !== (t5_value = ctx2[4].meta.crawled + ""))
        set_data(t5, t5_value);
      if (dirty & 16 && t7_value !== (t7_value = ctx2[4].meta.errorred + ""))
        set_data(t7, t7_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(t7);
    }
  };
}
function create_if_block_1$6(ctx) {
  let button;
  let i2;
  let i_class_value;
  let t0;
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t0 = space();
      div = element("div");
      div.textContent = "Stop";
      attr(i2, "class", i_class_value = "fa " + (ctx[3] ? "fa-spinner fa-spin" : "fa-stop"));
      attr(div, "class", "pl-2");
      attr(button, "class", "btn btn-danger btn-sm d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t0);
      append(button, div);
      if (!mounted) {
        dispose = listen(button, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && i_class_value !== (i_class_value = "fa " + (ctx2[3] ? "fa-spinner fa-spin" : "fa-stop"))) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$6(ctx) {
  let button;
  let i2;
  let i_class_value;
  let t0;
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t0 = space();
      div = element("div");
      div.textContent = "Retry";
      attr(i2, "class", i_class_value = "fa fa-refresh " + (ctx[3] ? "fa-spin" : ""));
      attr(div, "class", "pl-2");
      attr(button, "class", "btn btn-primary btn-sm d-flex align-items-center");
      button.disabled = ctx[3];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t0);
      append(button, div);
      if (!mounted) {
        dispose = listen(button, "click", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && i_class_value !== (i_class_value = "fa fa-refresh " + (ctx2[3] ? "fa-spin" : ""))) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & 8) {
        button.disabled = ctx2[3];
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$f(ctx) {
  var _a, _b;
  let tr;
  let t0;
  let td0;
  let t2;
  let td1;
  let t3;
  let td2;
  let t4_value = ctx[5][ctx[4].state] + "";
  let t4;
  let t5_value = ctx[4].state === C$2.STATE_RETRYING ? ` (${((_a = ctx[4].meta) == null ? void 0 : _a.retries) || 0}/2)` : "";
  let t5;
  let t6_value = ((_b = ctx[4].meta) == null ? void 0 : _b.retries) ? `, Attempts: ${ctx[4].meta.retries + 1}` : "";
  let t6;
  let t7;
  let td3;
  let t8;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4].state === C$2.STATE_DEFAULT)
      return create_if_block_3$4;
    return create_else_block_1$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  function select_block_type_2(ctx2, dirty) {
    var _a2;
    if ((_a2 = ctx2[4].meta) == null ? void 0 : _a2.total)
      return create_if_block_2$4;
    return create_else_block$7;
  }
  let current_block_type_1 = select_block_type_2(ctx);
  let if_block1 = current_block_type_1(ctx);
  let if_block2 = ctx[4].state === C$2.STATE_READY && create_if_block_1$6(ctx);
  let if_block3 = (ctx[4].state === C$2.STATE_RETRYING || ctx[4].state === C$2.STATE_ERROR || ctx[4].state === C$2.STATE_DISCARD || ctx[4].state === C$2.STATE_TERMINATED) && ctx[2] && create_if_block$6(ctx);
  return {
    c() {
      tr = element("tr");
      if_block0.c();
      t0 = space();
      td0 = element("td");
      td0.textContent = `${ctx[7]()}`;
      t2 = space();
      td1 = element("td");
      if_block1.c();
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = text(t5_value);
      t6 = text(t6_value);
      t7 = space();
      td3 = element("td");
      if (if_block2)
        if_block2.c();
      t8 = space();
      if (if_block3)
        if_block3.c();
      toggle_class(td2, "text-danger", ctx[4].state === C$2.STATE_ERROR);
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      if_block0.m(tr, null);
      append(tr, t0);
      append(tr, td0);
      append(tr, t2);
      append(tr, td1);
      if_block1.m(td1, null);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(td2, t5);
      append(td2, t6);
      append(tr, t7);
      append(tr, td3);
      if (if_block2)
        if_block2.m(td3, null);
      append(td3, t8);
      if (if_block3)
        if_block3.m(td3, null);
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(tr, t0);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(td1, null);
        }
      }
      if (dirty & 16 && t4_value !== (t4_value = ctx2[5][ctx2[4].state] + ""))
        set_data(t4, t4_value);
      if (dirty & 16 && t5_value !== (t5_value = ctx2[4].state === C$2.STATE_RETRYING ? ` (${((_a2 = ctx2[4].meta) == null ? void 0 : _a2.retries) || 0}/2)` : ""))
        set_data(t5, t5_value);
      if (dirty & 16 && t6_value !== (t6_value = ((_b2 = ctx2[4].meta) == null ? void 0 : _b2.retries) ? `, Attempts: ${ctx2[4].meta.retries + 1}` : ""))
        set_data(t6, t6_value);
      if (dirty & 16) {
        toggle_class(td2, "text-danger", ctx2[4].state === C$2.STATE_ERROR);
      }
      if (ctx2[4].state === C$2.STATE_READY) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$6(ctx2);
          if_block2.c();
          if_block2.m(td3, t8);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if ((ctx2[4].state === C$2.STATE_RETRYING || ctx2[4].state === C$2.STATE_ERROR || ctx2[4].state === C$2.STATE_DISCARD || ctx2[4].state === C$2.STATE_TERMINATED) && ctx2[2]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block$6(ctx2);
          if_block3.c();
          if_block3.m(td3, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block0.d();
      if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let $job, $$unsubscribe_job = noop, $$subscribe_job = () => ($$unsubscribe_job(), $$unsubscribe_job = subscribe(job, ($$value) => $$invalidate(4, $job = $$value)), job);
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(10, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_job());
  const dispatch = createEventDispatcher();
  const jobStates = {
    [C$2.STATE_ERROR]: "Errored",
    [C$2.STATE_DISCARD]: "Cancelled",
    [C$2.STATE_DONE]: "Done",
    [C$2.STATE_READY]: "Running",
    [C$2.STATE_PAUSED]: "Paused",
    [C$2.STATE_DEFAULT]: "Scheduled",
    [C$2.STATE_TERMINATING]: "Terminating",
    [C$2.STATE_TERMINATED]: "Terminated",
    [C$2.STATE_RETRYING]: "Sheduled for Retry"
  };
  let { job } = $$props;
  $$subscribe_job();
  let { crawler_id } = $$props;
  let { isLatest = false } = $$props;
  let loading2 = false;
  let team = $params.team;
  function getJobDuration() {
    if ($job.state === C$2.STATE_DEFAULT || !$job.ts_end) {
      return "N/A";
    }
    if ($job.meta.duration) {
      return getDuration(Date.now(), Date.now() + $job.meta.duration * 1e3);
    }
    const jobEndDate = $job.state === C$2.STATE_READY || $job.state === C$2.STATE_DEFAULT || $job.state === C$2.STATE_TERMINATING ? Date.now() : new Date($job.ts_end).getTime();
    if (isNaN(jobEndDate)) {
      return "N/A";
    }
    const jobDate = new Date($job.ts).getTime();
    return getDuration(jobDate, jobEndDate);
  }
  getJobDuration();
  async function terminateJob() {
    try {
      $$invalidate(3, loading2 = true);
      await Api.api(`/crawlers/${crawler_id}/jobs/${job.id}/terminate`);
      Msg.info("Job terminated");
    } catch (err) {
      Msg.error("Could not terminate job");
      console.error("Could not terminate job", err);
    } finally {
      $$invalidate(3, loading2 = false);
      dispatch("refresh");
    }
  }
  async function retryJob() {
    try {
      $$invalidate(3, loading2 = true);
      Msg.info("Retrying job: Checking if crawler is busy...");
      let res = await Api.api(`/crawlers/${crawler_id}/jobs/${job.id}/retry`);
      if (res.crawler_id) {
        Msg.info("Successfully scheduled job retry");
      }
    } catch (err) {
      let msg = err.msg || "Could not schedule new job";
      if (err.code === "ERR_CRAWLER_BUSY") {
        msg = "Crawler is busy: " + getJobErrFromErr(err);
      }
      Msg.error(msg);
      console.error("Could not retry job", err);
    } finally {
      $$invalidate(3, loading2 = false);
      dispatch("refresh");
    }
  }
  $$self.$$set = ($$props2) => {
    if ("job" in $$props2)
      $$subscribe_job($$invalidate(0, job = $$props2.job));
    if ("crawler_id" in $$props2)
      $$invalidate(1, crawler_id = $$props2.crawler_id);
    if ("isLatest" in $$props2)
      $$invalidate(2, isLatest = $$props2.isLatest);
  };
  return [
    job,
    crawler_id,
    isLatest,
    loading2,
    $job,
    jobStates,
    team,
    getJobDuration,
    terminateJob,
    retryJob
  ];
}
class Job extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$f, safe_not_equal, { job: 0, crawler_id: 1, isLatest: 2 });
  }
}
function get_each_context$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  child_ctx[10] = i2;
  return child_ctx;
}
function create_else_block$6(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No jobs found</td> 
        `;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$5(ctx) {
  let job;
  let current;
  job = new Job({
    props: {
      job: ctx[8],
      crawler_id: ctx[0],
      isLatest: ctx[8].id === ctx[1]
    }
  });
  job.$on("refresh", ctx[5]);
  return {
    c() {
      create_component(job.$$.fragment);
    },
    m(target, anchor) {
      mount_component(job, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const job_changes = {};
      if (dirty & 8)
        job_changes.job = ctx2[8];
      if (dirty & 1)
        job_changes.crawler_id = ctx2[0];
      if (dirty & 10)
        job_changes.isLatest = ctx2[8].id === ctx2[1];
      job.$set(job_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(job.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(job.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(job, detaching);
    }
  };
}
function create_fragment$e(ctx) {
  let div4;
  let div3;
  let div0;
  let t3;
  let div1;
  let t4;
  let button;
  let i2;
  let i_class_value;
  let t5;
  let div2;
  let t7;
  let listpager;
  let t8;
  let table;
  let thead;
  let t20;
  let tbody;
  let current;
  let mounted;
  let dispose;
  listpager = new ListPager({ props: { store: ctx[4] } });
  let each_value = ctx[3].models;
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$5(get_each_context$5(ctx, each_value, i3));
  }
  const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
    each_blocks[i3] = null;
  });
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$6();
  }
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>Jobs</h3> 
    <small>List of jobs started by this crawler</small>`;
      t3 = space();
      div1 = element("div");
      t4 = space();
      button = element("button");
      i2 = element("i");
      t5 = space();
      div2 = element("div");
      div2.textContent = "Run New Job";
      t7 = space();
      create_component(listpager.$$.fragment);
      t8 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th>Started On</th> 
      <th>Ended On</th> 
      <th>Run Duration</th> 
      <th>Summary</th> 
      <th>Status</th> 
      <th>Action</th></tr>`;
      t20 = space();
      tbody = element("tbody");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      set_style(div1, "max-width", "50px");
      attr(i2, "class", i_class_value = "fa " + (ctx[2] ? "fa-spinner fa-spin" : "fa-play"));
      attr(div2, "class", "pl-2");
      attr(button, "class", "btn btn-success btn-sm mx-2 pagination-sm d-flex align-items-center");
      button.disabled = ctx[2];
      attr(button, "title", "New run will cancel any jobs scheduled for retries");
      attr(div3, "class", "card-header flex items-center");
      attr(thead, "class", "table-light");
      attr(table, "class", "table");
      attr(div4, "class", "card panel-default mt-5");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div3, t3);
      append(div3, div1);
      append(div3, t4);
      append(div3, button);
      append(button, i2);
      append(button, t5);
      append(button, div2);
      append(div3, t7);
      mount_component(listpager, div3, null);
      append(div4, t8);
      append(div4, table);
      append(table, thead);
      append(table, t20);
      append(table, tbody);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4 && i_class_value !== (i_class_value = "fa " + (ctx2[2] ? "fa-spinner fa-spin" : "fa-play"))) {
        attr(i2, "class", i_class_value);
      }
      if (!current || dirty & 4) {
        button.disabled = ctx2[2];
      }
      if (dirty & 43) {
        each_value = ctx2[3].models;
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
            transition_in(each_blocks[i3], 1);
          } else {
            each_blocks[i3] = create_each_block$5(child_ctx);
            each_blocks[i3].c();
            transition_in(each_blocks[i3], 1);
            each_blocks[i3].m(tbody, null);
          }
        }
        group_outros();
        for (i3 = each_value.length; i3 < each_blocks.length; i3 += 1) {
          out(i3);
        }
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$6();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(listpager.$$.fragment, local);
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        transition_in(each_blocks[i3]);
      }
      current = true;
    },
    o(local) {
      transition_out(listpager.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        transition_out(each_blocks[i3]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(listpager);
      destroy_each(each_blocks, detaching);
      if (each_1_else)
        each_1_else.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let $store;
  let { crawler_id } = $$props;
  let { latestJobId } = $$props;
  let store2 = getContext("job:store");
  component_subscribe($$self, store2, (value) => $$invalidate(3, $store = value));
  let loading2 = false;
  async function refresh() {
    await store2.fetch();
  }
  let refreshInterval = setInterval(
    () => {
      refresh();
    },
    5e3
  );
  async function runNewJob() {
    try {
      $$invalidate(2, loading2 = true);
      Msg.info("Starting new job: Checking if crawler is busy...");
      let res = await Api.api(`/crawlers/${crawler_id}/jobs`, "POST");
      if (res.crawler_id) {
        $$invalidate(2, loading2 = false);
        Msg.info("Successfully scheduled new job");
      }
    } catch (err) {
      let msg = "Could not schedule new job";
      if (err.code === "ERR_CRAWLER_BUSY") {
        msg = "Crawler is busy: " + getJobErrFromErr(err);
      }
      Msg.error(msg);
      console.error("Could not run new job", err);
    } finally {
      $$invalidate(2, loading2 = false);
      await store2.fetch();
    }
  }
  onDestroy(() => {
    clearInterval(refreshInterval);
  });
  $$self.$$set = ($$props2) => {
    if ("crawler_id" in $$props2)
      $$invalidate(0, crawler_id = $$props2.crawler_id);
    if ("latestJobId" in $$props2)
      $$invalidate(1, latestJobId = $$props2.latestJobId);
  };
  return [crawler_id, latestJobId, loading2, $store, store2, refresh, runNewJob];
}
class List$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$e, safe_not_equal, { crawler_id: 0, latestJobId: 1 });
  }
}
const get_header_slot_changes = (dirty) => ({});
const get_header_slot_context = (ctx) => ({ slot: "header" });
function get_each_context_1$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i2];
  return child_ctx;
}
function get_each_context$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function create_catch_block$2(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$2(ctx) {
  let div1;
  let div0;
  let h3;
  let t0_value = ctx[5].name + "";
  let t0;
  let t1;
  let ul;
  let li0;
  let a0;
  let t3;
  let li1;
  let a1;
  let t5;
  let t6;
  let list;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === ctx2[7].OPTIONS)
      return create_if_block_1$5;
    return create_else_block$5;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  list = new List$1({
    props: {
      crawler_id: ctx[8],
      latestJobId: ctx[5].latest_job_id
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      a0.textContent = "Options";
      t3 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = "Monitors";
      t5 = space();
      if_block.c();
      t6 = space();
      create_component(list.$$.fragment);
      attr(div0, "class", "flex items-center xpage-header");
      attr(a0, "href", "#options_tab");
      attr(a0, "class", "nav-link");
      attr(a0, "data-toggle", "tab");
      toggle_class(a0, "active", ctx[1] == ctx[7].OPTIONS);
      attr(a1, "href", "#monitors_tab");
      attr(a1, "class", "nav-link");
      attr(a1, "data-toggle", "tab");
      toggle_class(a1, "active", ctx[1] == ctx[7].MONITORS);
      attr(ul, "class", "nav nav-tabs mt-2");
      attr(div1, "class", "items-center mt-3");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h3);
      append(h3, t0);
      append(div1, t1);
      append(div1, ul);
      append(ul, li0);
      append(li0, a0);
      append(ul, t3);
      append(ul, li1);
      append(li1, a1);
      append(div1, t5);
      if_block.m(div1, null);
      insert(target, t6, anchor);
      mount_component(list, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a0, "click", prevent_default(ctx[16])),
          listen(a1, "click", prevent_default(ctx[17]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 32) && t0_value !== (t0_value = ctx2[5].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty[0] & 130) {
        toggle_class(a0, "active", ctx2[1] == ctx2[7].OPTIONS);
      }
      if (!current || dirty[0] & 130) {
        toggle_class(a1, "active", ctx2[1] == ctx2[7].MONITORS);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
      const list_changes = {};
      if (dirty[0] & 32)
        list_changes.latestJobId = ctx2[5].latest_job_id;
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_block.d();
      if (detaching)
        detach(t6);
      destroy_component(list, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$5(ctx) {
  let div2;
  let div1;
  let div0;
  let table;
  let thead;
  let t1;
  let tbody;
  let each_value_1 = ctx[4];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i2));
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><td>Linked Sieves</td></tr>`;
      t1 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(table, "class", "table");
      set_style(div0, "width", "50%");
      attr(div1, "class", "flex");
      attr(div2, "class", "tab-pane bg-white bb bl br border-bootstrap-border");
      attr(div2, "id", "options_tab");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, table);
      append(table, thead);
      append(table, t1);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 528) {
        each_value_1 = ctx2[4];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tbody, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$5(ctx) {
  let div4;
  let div3;
  let div2;
  let table;
  let tbody;
  let tr0;
  let th0;
  let t1;
  let td0;
  let div0;
  let t2_value = ctx[5].state === C$2.STATE_READY ? "Active" : "Inactive";
  let t2;
  let t3;
  let tr1;
  let th1;
  let t5;
  let td1;
  let a;
  let t6_value = ctx[5].url + "";
  let t6;
  let a_href_value;
  let t7;
  let tr2;
  let th2;
  let t9;
  let td2;
  let t10_value = getShortDisplayText(ctx[5].schedule) + "";
  let t10;
  let t11;
  let tr3;
  let th3;
  let t13;
  let td3;
  let t14_value = ctx[5].config.maxPages + "";
  let t14;
  let t15;
  let t16;
  let tr4;
  let th4;
  let div1;
  let button;
  let t18;
  let td4;
  let mounted;
  let dispose;
  let if_block = ctx[5].config.excludes.length > 0 && create_if_block_2$3(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      table = element("table");
      tbody = element("tbody");
      tr0 = element("tr");
      th0 = element("th");
      th0.textContent = "State";
      t1 = space();
      td0 = element("td");
      div0 = element("div");
      t2 = text(t2_value);
      t3 = space();
      tr1 = element("tr");
      th1 = element("th");
      th1.textContent = "URL";
      t5 = space();
      td1 = element("td");
      a = element("a");
      t6 = text(t6_value);
      t7 = space();
      tr2 = element("tr");
      th2 = element("th");
      th2.textContent = "Schedule";
      t9 = space();
      td2 = element("td");
      t10 = text(t10_value);
      t11 = space();
      tr3 = element("tr");
      th3 = element("th");
      th3.textContent = "Max pages";
      t13 = space();
      td3 = element("td");
      t14 = text(t14_value);
      t15 = space();
      if (if_block)
        if_block.c();
      t16 = space();
      tr4 = element("tr");
      th4 = element("th");
      div1 = element("div");
      button = element("button");
      button.textContent = "Edit Crawler";
      t18 = space();
      td4 = element("td");
      set_style(th0, "width", "25%");
      toggle_class(div0, "error", ctx[5].state !== C$2.STATE_READY);
      set_style(th1, "width", "25%");
      attr(a, "href", a_href_value = ctx[5].url);
      attr(a, "target", "_blank");
      set_style(th2, "width", "25%");
      set_style(th3, "width", "25%");
      attr(button, "class", "btn btn-default");
      attr(table, "class", "table");
      set_style(div2, "width", "50%");
      attr(div3, "class", "d-flex");
      attr(div4, "class", "tab-pane bg-white bb bl br border-bootstrap-border");
      attr(div4, "id", "options_tab");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div2);
      append(div2, table);
      append(table, tbody);
      append(tbody, tr0);
      append(tr0, th0);
      append(tr0, t1);
      append(tr0, td0);
      append(td0, div0);
      append(div0, t2);
      append(tbody, t3);
      append(tbody, tr1);
      append(tr1, th1);
      append(tr1, t5);
      append(tr1, td1);
      append(td1, a);
      append(a, t6);
      append(tbody, t7);
      append(tbody, tr2);
      append(tr2, th2);
      append(tr2, t9);
      append(tr2, td2);
      append(td2, t10);
      append(tbody, t11);
      append(tbody, tr3);
      append(tr3, th3);
      append(tr3, t13);
      append(tr3, td3);
      append(td3, t14);
      append(tbody, t15);
      if (if_block)
        if_block.m(tbody, null);
      append(tbody, t16);
      append(tbody, tr4);
      append(tr4, th4);
      append(th4, div1);
      append(div1, button);
      append(tr4, t18);
      append(tr4, td4);
      if (!mounted) {
        dispose = listen(button, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32 && t2_value !== (t2_value = ctx2[5].state === C$2.STATE_READY ? "Active" : "Inactive"))
        set_data(t2, t2_value);
      if (dirty[0] & 32) {
        toggle_class(div0, "error", ctx2[5].state !== C$2.STATE_READY);
      }
      if (dirty[0] & 32 && t6_value !== (t6_value = ctx2[5].url + ""))
        set_data(t6, t6_value);
      if (dirty[0] & 32 && a_href_value !== (a_href_value = ctx2[5].url)) {
        attr(a, "href", a_href_value);
      }
      if (dirty[0] & 32 && t10_value !== (t10_value = getShortDisplayText(ctx2[5].schedule) + ""))
        set_data(t10, t10_value);
      if (dirty[0] & 32 && t14_value !== (t14_value = ctx2[5].config.maxPages + ""))
        set_data(t14, t14_value);
      if (ctx2[5].config.excludes.length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$3(ctx2);
          if_block.c();
          if_block.m(tbody, t16);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$3(ctx) {
  let tr;
  let td;
  let a;
  let t0_value = ctx[29].toJSON().name + "";
  let t0;
  let a_href_value;
  let t1;
  return {
    c() {
      tr = element("tr");
      td = element("td");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "href", a_href_value = "#/w/" + ctx[9] + "/list/all/" + ctx[29].toJSON().id + ".id");
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(td, a);
      append(a, t0);
      append(tr, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t0_value !== (t0_value = ctx2[29].toJSON().name + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 16 && a_href_value !== (a_href_value = "#/w/" + ctx2[9] + "/list/all/" + ctx2[29].toJSON().id + ".id")) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block_1$1(ctx) {
  let show_if = ctx[29].toJSON().state === 40 || ctx[29].toJSON().state === 45;
  let if_block_anchor;
  let if_block = show_if && create_if_block_3$3(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16)
        show_if = ctx2[29].toJSON().state === 40 || ctx2[29].toJSON().state === 45;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_2$3(ctx) {
  let tr;
  let th;
  let t1;
  let td;
  let each_value = ctx[5].config.excludes;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$4(get_each_context$4(ctx, each_value, i2));
  }
  return {
    c() {
      tr = element("tr");
      th = element("th");
      th.textContent = "Excludes";
      t1 = space();
      td = element("td");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      set_style(th, "width", "25%");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, th);
      append(tr, t1);
      append(tr, td);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(td, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32) {
        each_value = ctx2[5].config.excludes;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(td, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$4(ctx) {
  let div;
  let code0;
  let t0_value = ctx[26].expr + "";
  let t0;
  let t1;
  let code1;
  let t2_value = ctx[26].flags + "";
  let t2;
  let t3;
  return {
    c() {
      div = element("div");
      code0 = element("code");
      t0 = text(t0_value);
      t1 = text("\xA0\xA0");
      code1 = element("code");
      t2 = text(t2_value);
      t3 = space();
      attr(code0, "class", "bg-gray-200 px-2 rounded-md");
      attr(code1, "class", "bg-gray-200 px-2 rounded-md");
      attr(div, "class", "flex my-2 items-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, code0);
      append(code0, t0);
      append(div, t1);
      append(div, code1);
      append(code1, t2);
      append(div, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32 && t0_value !== (t0_value = ctx2[26].expr + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 32 && t2_value !== (t2_value = ctx2[26].flags + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_pending_block$2(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block$5(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: false,
      onSave: ctx[13],
      disableSave: ctx[6],
      $$slots: {
        header: [create_header_slot_1],
        default: [create_default_slot_1]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[18]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty[0] & 64)
        savemodal_changes.disableSave = ctx2[6];
      if (dirty[0] & 524292) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let div;
  let crawleditor;
  let current;
  crawleditor = new CrawlEditor({
    props: { crawler: ctx[2] }
  });
  return {
    c() {
      div = element("div");
      create_component(crawleditor.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(crawleditor, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const crawleditor_changes = {};
      if (dirty[0] & 4)
        crawleditor_changes.crawler = ctx2[2];
      crawleditor.$set(crawleditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crawleditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crawleditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(crawleditor);
    }
  };
}
function fallback_block(ctx) {
  let t;
  return {
    c() {
      t = text("Configure Crawler");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot_1(ctx) {
  let current;
  const header_slot_template = ctx[15].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[19], get_header_slot_context);
  const header_slot_or_fallback = header_slot || fallback_block();
  return {
    c() {
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty[0] & 524288)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(header_slot_template, ctx2[19], dirty, get_header_slot_changes),
            get_header_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
    }
  };
}
function create_default_slot$3(ctx) {
  let div2;
  let div1;
  let div0;
  let t;
  let if_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2,
    value: 25,
    blocks: [, , ,]
  };
  handle_promise(ctx[11], info);
  let if_block = ctx[0] && create_if_block$5(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      info.block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "col-sm-12");
      attr(div1, "class", "row");
      attr(div2, "class", "container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      info.block.m(div0, info.anchor = null);
      info.mount = () => div0;
      info.anchor = null;
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (ctx[0]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      info.block.d();
      info.token = null;
      info = null;
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_header_slot$2(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Crawlers</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot$2(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty[0] & 524288) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$d(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      renderDefaultToolbar: true,
      $$slots: {
        topbar: [create_topbar_slot$2],
        default: [create_default_slot$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const layout_changes = {};
      if (dirty[0] & 524407) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let $crawler;
  let $error, $$unsubscribe_error = noop, $$subscribe_error = () => ($$unsubscribe_error(), $$unsubscribe_error = subscribe(error, ($$value) => $$invalidate(6, $error = $$value)), error);
  $$self.$$.on_destroy.push(() => $$unsubscribe_error());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { params: params2 } = $$props;
  let showEditorModal = false;
  ({
    [C$2.STATE_DONE]: "Done",
    [C$2.STATE_READY]: "Running",
    [C$2.STATE_PAUSED]: "Paused",
    [C$2.STATE_DEFAULT]: "New"
  });
  const TABS = { OPTIONS: "options", MONITORS: "monitors" };
  let currentTab = TABS.OPTIONS;
  let id2 = params2 == null ? void 0 : params2.id;
  let team = params2.team;
  let jobsStore = new CrawlerJobs(null, { crawler_id: id2 });
  let crawler = new Crawler$2({ id: id2 });
  component_subscribe($$self, crawler, (value) => $$invalidate(5, $crawler = value));
  let crawlerForm;
  let error;
  let sieveStore = new Model$2.Sieves();
  let sieves = [];
  let fetchComplete;
  let pagePromise = new Promise((resolve, reject) => {
    fetchComplete = resolve;
  });
  setContext("job:store", jobsStore);
  onMount(async () => {
    await Promise.all([jobsStore.fetch(), crawler.fetch(), sieveStore.fetch()]);
    $$invalidate(4, sieves = sieveStore.where({ crawler_id: id2 }));
    fetchComplete(true);
  });
  function onEdit() {
    $$invalidate(2, crawlerForm = new Crawler$1(crawler));
    $$subscribe_error($$invalidate(3, error = crawlerForm.error));
    $$invalidate(0, showEditorModal = true);
  }
  async function saveCrawler() {
    try {
      await crawlerForm.save();
      crawler.set(crawlerForm.toJSON());
      $$invalidate(0, showEditorModal = false);
    } catch (err) {
      console.error("Error saving", err);
      err.message;
    }
  }
  const click_handler = (e) => $$invalidate(1, currentTab = TABS.OPTIONS);
  const click_handler_1 = (e) => $$invalidate(1, currentTab = TABS.MONITORS);
  const close_handler = () => {
    $$invalidate(0, showEditorModal = false);
  };
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(14, params2 = $$props2.params);
    if ("$$scope" in $$props2)
      $$invalidate(19, $$scope = $$props2.$$scope);
  };
  return [
    showEditorModal,
    currentTab,
    crawlerForm,
    error,
    sieves,
    $crawler,
    $error,
    TABS,
    id2,
    team,
    crawler,
    pagePromise,
    onEdit,
    saveCrawler,
    params2,
    slots,
    click_handler,
    click_handler_1,
    close_handler,
    $$scope
  ];
}
class Crawler_detail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$d, safe_not_equal, { params: 14 }, null, [-1, -1]);
  }
}
class Url extends base.Model {
}
class Urls extends base.PagedCollection {
  constructor(attrs, options) {
    super(attrs, options);
    __publicField(this, "model", Url);
    __publicField(this, "limit", 20);
    this.crawler_id = options.crawler_id;
    this.jobId = options.id;
    this.url = `/crawlers/data/${options.crawler_id}/jobs/${options.id}`;
  }
}
class FieldFilter extends base.Model {
  constructor(attrs, options) {
    super(attrs, options);
    this.fields = lib.stringify(options.fields);
    this.url = `/crawlers/data/${options.crawler_id}/jobs/${options.jobId}/filter?${this.fields}`;
  }
}
function get_each_context$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_if_block_4(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[0].code + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Status Code:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].code + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$2(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[0].body + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Body:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].body + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$4(ctx) {
  let div;
  let t1;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (typeof ctx2[0].cause === "string")
      return create_if_block_1$4;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      div.textContent = "Cause";
      t1 = space();
      if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "gray f5 lh-copy");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$4(ctx) {
  let each_1_anchor;
  let each_value = Object.keys(ctx[0].cause);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$3(get_each_context$3(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = Object.keys(ctx2[0].cause);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$4(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[0].cause + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Message:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].cause + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$2(ctx) {
  let div;
  let label;
  let t0_value = ctx[3] + "";
  let t0;
  let t1;
  let t2;
  let span;
  let t3_value = (typeof ctx[0].cause[ctx[3]] === "string" ? ctx[0].cause[ctx[3]] : JSON.stringify(ctx[0].cause[ctx[3]])) + "";
  let t3;
  let t4;
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = text(":");
      t2 = space();
      span = element("span");
      t3 = text(t3_value);
      t4 = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      append(div, span);
      append(span, t3);
      append(div, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[3] + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t3_value !== (t3_value = (typeof ctx2[0].cause[ctx2[3]] === "string" ? ctx2[0].cause[ctx2[3]] : JSON.stringify(ctx2[0].cause[ctx2[3]])) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$3(ctx) {
  let if_block_anchor;
  let if_block = ctx[3] !== "stack" && create_if_block_2$2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[3] !== "stack") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$c(ctx) {
  let div4;
  let a;
  let div0;
  let t0;
  let t1;
  let t2_value = ctx[0].message + "";
  let t2;
  let t3;
  let span0;
  let t4;
  let div3;
  let div1;
  let t6;
  let div2;
  let label;
  let t8;
  let span1;
  let t9_value = (ctx[0].message || "NA") + "";
  let t9;
  let t10;
  let t11;
  let t12;
  let show_if = !_.isEmpty(ctx[0].cause);
  let if_block0 = ctx[0].code && create_if_block_4(ctx);
  let if_block1 = ctx[0].body && create_if_block_3$2(ctx);
  let if_block2 = show_if && create_if_block$4(ctx);
  return {
    c() {
      div4 = element("div");
      a = element("a");
      div0 = element("div");
      t0 = text(ctx[1]);
      t1 = text(": ");
      t2 = text(t2_value);
      t3 = space();
      span0 = element("span");
      t4 = space();
      div3 = element("div");
      div1 = element("div");
      div1.textContent = "Details";
      t6 = space();
      div2 = element("div");
      label = element("label");
      label.textContent = "Message:";
      t8 = space();
      span1 = element("span");
      t9 = text(t9_value);
      t10 = space();
      if (if_block0)
        if_block0.c();
      t11 = space();
      if (if_block1)
        if_block1.c();
      t12 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "text-truncate");
      set_style(div0, "max-width", "300px");
      attr(span0, "class", "ml-1 dropdown-toggle");
      attr(a, "href", "asd");
      attr(a, "title", "Click to view details");
      attr(a, "class", "d-flex align-items-center pointer");
      attr(a, "data-bs-toggle", "dropdown");
      attr(a, "aria-haspopup", "true");
      attr(a, "aria-expanded", "false");
      toggle_class(a, "red", ctx[2]);
      attr(div1, "class", "gray f5 lh-copy");
      attr(div3, "class", "dropdown-menu pa2");
      attr(div4, "class", "dropdown clearfix mr-2");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, a);
      append(a, div0);
      append(div0, t0);
      append(div0, t1);
      append(div0, t2);
      append(a, t3);
      append(a, span0);
      append(div4, t4);
      append(div4, div3);
      append(div3, div1);
      append(div3, t6);
      append(div3, div2);
      append(div2, label);
      append(div2, t8);
      append(div2, span1);
      append(span1, t9);
      append(div3, t10);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t11);
      if (if_block1)
        if_block1.m(div3, null);
      append(div3, t12);
      if (if_block2)
        if_block2.m(div3, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].message + ""))
        set_data(t2, t2_value);
      if (dirty & 4) {
        toggle_class(a, "red", ctx2[2]);
      }
      if (dirty & 1 && t9_value !== (t9_value = (ctx2[0].message || "NA") + ""))
        set_data(t9, t9_value);
      if (ctx2[0].code) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          if_block0.m(div3, t11);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0].body) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3$2(ctx2);
          if_block1.c();
          if_block1.m(div3, t12);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 1)
        show_if = !_.isEmpty(ctx2[0].cause);
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$4(ctx2);
          if_block2.c();
          if_block2.m(div3, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let { errorObj } = $$props;
  let { message } = $$props;
  let { isError: isError2 = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("errorObj" in $$props2)
      $$invalidate(0, errorObj = $$props2.errorObj);
    if ("message" in $$props2)
      $$invalidate(1, message = $$props2.message);
    if ("isError" in $$props2)
      $$invalidate(2, isError2 = $$props2.isError);
  };
  return [errorObj, message, isError2];
}
class Log extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$c, safe_not_equal, { errorObj: 0, message: 1, isError: 2 });
  }
}
function create_else_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("Not Crawled");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$1(ctx) {
  let log;
  let current;
  log = new Log({
    props: {
      message: ctx[3](ctx[2].state),
      errorObj: ctx[2].error,
      isError: ctx[2].state === C$2.STATE_ERROR
    }
  });
  return {
    c() {
      create_component(log.$$.fragment);
    },
    m(target, anchor) {
      mount_component(log, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const log_changes = {};
      if (dirty & 4)
        log_changes.message = ctx2[3](ctx2[2].state);
      if (dirty & 4)
        log_changes.errorObj = ctx2[2].error;
      if (dirty & 4)
        log_changes.isError = ctx2[2].state === C$2.STATE_ERROR;
      log.$set(log_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(log.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(log.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(log, detaching);
    }
  };
}
function create_if_block_1$3(ctx) {
  let show_if;
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    var _a;
    if (dirty & 4)
      show_if = null;
    if (show_if == null)
      show_if = !!((_a = ctx2[2].status_code) == null ? void 0 : _a.toString().startsWith("3"));
    if (show_if)
      return create_if_block_2$1;
    return create_else_block$3;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_1(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$3(ctx) {
  let log;
  let current;
  log = new Log({
    props: {
      message: ctx[3](ctx[2].state),
      errorObj: { message: "Reached URL Limit" }
    }
  });
  return {
    c() {
      create_component(log.$$.fragment);
    },
    m(target, anchor) {
      mount_component(log, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const log_changes = {};
      if (dirty & 4)
        log_changes.message = ctx2[3](ctx2[2].state);
      log.$set(log_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(log.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(log.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(log, detaching);
    }
  };
}
function create_else_block$3(ctx) {
  let t;
  return {
    c() {
      t = text("Success");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$1(ctx) {
  let t;
  return {
    c() {
      t = text("Redirected");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$b(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[2].url + "";
  let t0;
  let td0_title_value;
  let t1;
  let td1;
  let t2_value = (ctx[2].content_type || "NA") + "";
  let t2;
  let t3;
  let td2;
  let t4_value = (ctx[2].status_code || "NA") + "";
  let t4;
  let t5;
  let td3;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$3, create_if_block_1$3, create_if_block_3$1, create_else_block_1$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === C$2.STATE_DONE && ctx2[2].state === C$2.STATE_DEFAULT)
      return 0;
    if (ctx2[2].state === C$2.STATE_DONE)
      return 1;
    if (ctx2[2].error)
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = space();
      td3 = element("td");
      if_block.c();
      attr(td0, "title", td0_title_value = ctx[2].url);
      attr(td0, "class", "truncate mw6");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(tr, t5);
      append(tr, td3);
      if_blocks[current_block_type_index].m(td3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 4) && t0_value !== (t0_value = ctx2[2].url + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 4 && td0_title_value !== (td0_title_value = ctx2[2].url)) {
        attr(td0, "title", td0_title_value);
      }
      if ((!current || dirty & 4) && t2_value !== (t2_value = (ctx2[2].content_type || "NA") + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 4) && t4_value !== (t4_value = (ctx2[2].status_code || "NA") + ""))
        set_data(t4, t4_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(td3, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let $url, $$unsubscribe_url = noop, $$subscribe_url = () => ($$unsubscribe_url(), $$unsubscribe_url = subscribe(url, ($$value) => $$invalidate(2, $url = $$value)), url);
  $$self.$$.on_destroy.push(() => $$unsubscribe_url());
  let { jobState } = $$props;
  const getStateText = (state) => {
    switch (state) {
      case C$2.STATE_ERROR:
        return "Error";
      case C$2.STATE_DEFAULT:
      case C$2.STATE_PAUSED:
        return "Not Crawled";
      default:
        return "";
    }
  };
  let { url } = $$props;
  $$subscribe_url();
  $$self.$$set = ($$props2) => {
    if ("jobState" in $$props2)
      $$invalidate(0, jobState = $$props2.jobState);
    if ("url" in $$props2)
      $$subscribe_url($$invalidate(1, url = $$props2.url));
  };
  return [jobState, url, $url, getStateText];
}
class UrlRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$b, safe_not_equal, { jobState: 0, url: 1 });
  }
}
function get_each_context$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  child_ctx[5] = list;
  child_ctx[6] = i2;
  return child_ctx;
}
function create_each_block$2(ctx) {
  let div;
  let label;
  let t0_value = ctx[4].label + "";
  let t0;
  let label_for_value;
  let t1;
  let input;
  let input_id_value;
  let input_value_value;
  let t2;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[2].call(input, ctx[5], ctx[6]);
  }
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      input = element("input");
      t2 = space();
      attr(label, "class", "col-form-label");
      attr(label, "for", label_for_value = "filter-" + ctx[4].value);
      attr(input, "type", "checkbox");
      set_style(input, "vertical-align", "top");
      set_style(input, "margin", "0 4px");
      attr(input, "id", input_id_value = "filter-" + ctx[4].value);
      input.__value = input_value_value = ctx[4].value;
      input.value = input.__value;
      attr(div, "class", "flex items-center mr-6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(div, t1);
      append(div, input);
      input.checked = ctx[4].checked;
      append(div, t2);
      if (!mounted) {
        dispose = [
          listen(input, "change", input_change_handler),
          listen(input, "change", ctx[1])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[4].label + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && label_for_value !== (label_for_value = "filter-" + ctx[4].value)) {
        attr(label, "for", label_for_value);
      }
      if (dirty & 1 && input_id_value !== (input_id_value = "filter-" + ctx[4].value)) {
        attr(input, "id", input_id_value);
      }
      if (dirty & 1 && input_value_value !== (input_value_value = ctx[4].value)) {
        input.__value = input_value_value;
        input.value = input.__value;
      }
      if (dirty & 1) {
        input.checked = ctx[4].checked;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$a(ctx) {
  let each_1_anchor;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$2(get_each_context$2(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { items } = $$props;
  function onSelect(e) {
    dispatch("select", items);
  }
  function input_change_handler(each_value, item_index) {
    each_value[item_index].checked = this.checked;
    $$invalidate(0, items);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
  };
  return [items, onSelect, input_change_handler];
}
class FilterMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$a, safe_not_equal, { items: 0 });
  }
}
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  child_ctx[24] = list;
  child_ctx[25] = i2;
  return child_ctx;
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function create_catch_block$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$1(ctx) {
  let each_1_anchor;
  let each_value_1 = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  let each_1_else = null;
  if (!each_value_1.length) {
    each_1_else = create_else_block_1();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4134) {
        each_value_1 = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
        if (!each_value_1.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value_1.length) {
          each_1_else = create_else_block_1();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_else_block_1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block_2(ctx) {
  let option;
  let t_value = (ctx[26] || "Other") + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[26];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = (ctx2[26] || "Other") + ""))
        set_data(t, t_value);
      if (dirty & 4 && option_value_value !== (option_value_value = ctx2[26])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block_1(ctx) {
  let div;
  let select;
  let option;
  let t0;
  let t1_value = ctx[5][ctx[23].field] + "";
  let t1;
  let select_title_value;
  let t2;
  let mounted;
  let dispose;
  let each_value_2 = ctx[23].values;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  function select_change_handler() {
    ctx[14].call(select, ctx[23]);
  }
  function change_handler(...args) {
    return ctx[15](ctx[23], ...args);
  }
  return {
    c() {
      div = element("div");
      select = element("select");
      option = element("option");
      t0 = text("All ");
      t1 = text(t1_value);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      option.__value = "all";
      option.value = option.__value;
      attr(select, "id", "job-type-selection");
      attr(select, "class", "pa1 btn-sm");
      attr(select, "title", select_title_value = "Select " + ctx[5][ctx[23].field]);
      if (ctx[1][ctx[23].field] === void 0)
        add_render_callback(select_change_handler);
      attr(div, "class", "mx-2 pa1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, select);
      append(select, option);
      append(option, t0);
      append(option, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(select, ctx[1][ctx[23].field], true);
      append(div, t2);
      if (!mounted) {
        dispose = [
          listen(select, "change", select_change_handler),
          listen(select, "change", change_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t1_value !== (t1_value = ctx[5][ctx[23].field] + ""))
        set_data(t1, t1_value);
      if (dirty & 4) {
        each_value_2 = ctx[23].values;
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty & 4 && select_title_value !== (select_title_value = "Select " + ctx[5][ctx[23].field])) {
        attr(select, "title", select_title_value);
      }
      if (dirty & 6) {
        select_option(select, ctx[1][ctx[23].field]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_pending_block$1(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_else_block$2(ctx) {
  let t;
  return {
    c() {
      t = text("No urls were crawled");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$1(ctx) {
  let urlrow;
  let current;
  const urlrow_spread_levels = [{ url: ctx[19] }, ctx[13]];
  let urlrow_props = {};
  for (let i2 = 0; i2 < urlrow_spread_levels.length; i2 += 1) {
    urlrow_props = assign$1(urlrow_props, urlrow_spread_levels[i2]);
  }
  urlrow = new UrlRow({ props: urlrow_props });
  return {
    c() {
      create_component(urlrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urlrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const urlrow_changes = dirty & 8208 ? get_spread_update(urlrow_spread_levels, [
        dirty & 16 && { url: ctx2[19] },
        dirty & 8192 && get_spread_object(ctx2[13])
      ]) : {};
      urlrow.$set(urlrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(urlrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urlrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urlrow, detaching);
    }
  };
}
function create_fragment$9(ctx) {
  let div3;
  let div2;
  let div0;
  let t3;
  let div1;
  let t4;
  let promise;
  let t5;
  let filtermenu;
  let t6;
  let searchbar;
  let t7;
  let listpager;
  let t8;
  let sortby;
  let t9;
  let table;
  let thead;
  let t17;
  let tbody;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    value: 22,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[3].fetchPromise, info);
  filtermenu = new FilterMenu({ props: { items: ctx[7] } });
  filtermenu.$on("select", ctx[10]);
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[11]);
  listpager = new ListPager({ props: { store: ctx[0] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[9],
      sortingFields: ctx[6],
      currentFieldName: ctx[4].orderBy
    }
  });
  let each_value = ctx[4].models;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1(get_each_context$1(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let each_1_else_1 = null;
  if (!each_value.length) {
    each_1_else_1 = create_else_block$2();
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>URLs</h3> 
    <small>List of urls obtained by crawler in this run</small>`;
      t3 = space();
      div1 = element("div");
      t4 = space();
      info.block.c();
      t5 = space();
      create_component(filtermenu.$$.fragment);
      t6 = space();
      create_component(searchbar.$$.fragment);
      t7 = space();
      create_component(listpager.$$.fragment);
      t8 = space();
      create_component(sortby.$$.fragment);
      t9 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th class="w-75">URL</th> 
        <th>Content Type</th> 
        <th>Status Code</th> 
        <th>Status</th></tr>`;
      t17 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else_1) {
        each_1_else_1.c();
      }
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      set_style(div1, "max-width", "50px");
      attr(div2, "class", "card-header flex items-center");
      attr(thead, "class", "table-light");
      attr(table, "class", "table");
      attr(div3, "class", "card panel-default mt-5");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t3);
      append(div2, div1);
      append(div2, t4);
      info.block.m(div2, info.anchor = null);
      info.mount = () => div2;
      info.anchor = t5;
      append(div2, t5);
      mount_component(filtermenu, div2, null);
      append(div2, t6);
      mount_component(searchbar, div2, null);
      append(div2, t7);
      mount_component(listpager, div2, null);
      append(div2, t8);
      mount_component(sortby, div2, null);
      append(div3, t9);
      append(div3, table);
      append(table, thead);
      append(table, t17);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else_1) {
        each_1_else_1.m(tbody, null);
      }
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 8 && promise !== (promise = ctx[3].fetchPromise) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      const listpager_changes = {};
      if (dirty & 1)
        listpager_changes.store = ctx[0];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 16)
        sortby_changes.currentFieldName = ctx[4].orderBy;
      sortby.$set(sortby_changes);
      if (dirty & 8208) {
        each_value = ctx[4].models;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1(ctx, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(tbody, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
        if (each_value.length) {
          if (each_1_else_1) {
            each_1_else_1.d(1);
            each_1_else_1 = null;
          }
        } else if (!each_1_else_1) {
          each_1_else_1 = create_else_block$2();
          each_1_else_1.c();
          each_1_else_1.m(tbody, null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      transition_in(filtermenu.$$.fragment, local);
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      transition_out(filtermenu.$$.fragment, local);
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      info.block.d();
      info.token = null;
      info = null;
      destroy_component(filtermenu);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      destroy_each(each_blocks, detaching);
      if (each_1_else_1)
        each_1_else_1.d();
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contentTypeStore;
  let $store;
  let store2 = getContext("url:store");
  component_subscribe($$self, store2, (value) => $$invalidate(4, $store = value));
  let selectedJobTypes = {};
  let filterLabels = {
    content_type: "Content Types",
    domain: "Domains"
  };
  const sortingFields = [
    { value: "url", label: "Url" },
    { value: "-url", label: "Url - Descending" },
    {
      value: "content_type",
      label: "Content Type"
    },
    {
      value: "-content_type",
      label: "Content Type - Descending"
    }
  ];
  const items = [
    {
      field: "state",
      value: C$2.STATE_ERROR,
      checked: false,
      label: "Errorred"
    }
  ];
  let { crawler_id, jobId } = $store;
  let contentTypeStore = new FieldFilter(
    {},
    {
      crawler_id,
      jobId,
      fields: ["content_type", "domain"]
    }
  );
  component_subscribe($$self, contentTypeStore, (value) => $$invalidate(3, $contentTypeStore = value));
  let fields = [];
  let searchQuery = "";
  onMount(async () => {
    await contentTypeStore.fetch();
    $$invalidate(2, fields = $contentTypeStore.result);
    for (let field of fields) {
      $$invalidate(1, selectedJobTypes[field.field] = "all", selectedJobTypes);
    }
  });
  async function onSort(by) {
    $$invalidate(0, store2.orderBy = by, store2);
    await store2.fetch();
  }
  async function onFilter(e) {
    let filters = e.detail;
    let query = store2.getQuery();
    filters.forEach((filter) => {
      if (!filter.checked) {
        query[filter.field] && delete query[filter.field];
      } else {
        query[filter.field] = filter.value;
      }
    });
    store2.setQuery(query);
    return await store2.goto(0, { reset: true });
  }
  async function onSearch2(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      let query = store2.getQuery();
      delete query.$or["url.ilike"];
      store2.setQuery(query);
      return await store2.goto(0, { reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({
      ...store2.getQuery(),
      $or: { "url.ilike": searchQuery }
    });
    return await store2.goto(0, { reset: true });
  }
  async function onJobTypeChange(e, field) {
    let query = store2.getQuery();
    if (selectedJobTypes[field] === null) {
      query[field] = "$null";
    } else if (selectedJobTypes[field] !== "all") {
      query[field] = selectedJobTypes[field];
    } else {
      delete query[field];
    }
    store2.setQuery(query);
    return await store2.goto(0, { reset: true });
  }
  function select_change_handler(field) {
    selectedJobTypes[field.field] = select_value(this);
    $$invalidate(1, selectedJobTypes);
    $$invalidate(2, fields);
  }
  const change_handler = (field, e) => onJobTypeChange(e, field.field);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [
    store2,
    selectedJobTypes,
    fields,
    $contentTypeStore,
    $store,
    filterLabels,
    sortingFields,
    items,
    contentTypeStore,
    onSort,
    onFilter,
    onSearch2,
    onJobTypeChange,
    $$restProps,
    select_change_handler,
    change_handler
  ];
}
class List extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$9, safe_not_equal, {});
  }
}
function create_fragment$8(ctx) {
  let svg;
  let g0;
  let g1;
  let g3;
  let g2;
  let path;
  let svg_levels = [
    { viewBox: "0 0 24 24" },
    { fill: "none" },
    { xmlns: "http://www.w3.org/2000/svg" },
    { stroke: "currentColor" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g3 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      attr(g0, "stroke-width", "0");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path, "d", "M4 12L8.94975 16.9497L19.5572 6.34326");
      attr(path, "stroke-width", "3");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(g2, "id", "Interface / Check_Big");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g0);
      append(svg, g1);
      append(svg, g3);
      append(g3, g2);
      append(g2, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { viewBox: "0 0 24 24" },
        { fill: "none" },
        { xmlns: "http://www.w3.org/2000/svg" },
        { stroke: "currentColor" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Check extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$8, safe_not_equal, {});
  }
}
function create_fragment$7(ctx) {
  let svg;
  let g0;
  let g1;
  let g3;
  let g2;
  let path;
  let svg_levels = [
    { viewBox: "0 0 24 24" },
    { fill: "none" },
    { xmlns: "http://www.w3.org/2000/svg" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g3 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      attr(g0, "stroke-width", "0");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path, "d", "M10 8H5V3M5.29102 16.3569C6.22284 17.7918 7.59014 18.8902 9.19218 19.4907C10.7942 20.0913 12.547 20.1624 14.1925 19.6937C15.8379 19.225 17.2893 18.2413 18.3344 16.8867C19.3795 15.5321 19.963 13.878 19.9989 12.1675C20.0347 10.4569 19.5211 8.78001 18.5337 7.38281C17.5462 5.98561 16.1366 4.942 14.5122 4.40479C12.8878 3.86757 11.1341 3.86499 9.5083 4.39795C7.88252 4.93091 6.47059 5.97095 5.47949 7.36556");
      attr(path, "stroke", "#000000");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g0);
      append(svg, g1);
      append(svg, g3);
      append(g3, g2);
      append(g2, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { viewBox: "0 0 24 24" },
        { fill: "none" },
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class ReloadCircle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$7, safe_not_equal, {});
  }
}
function create_fragment$6(ctx) {
  let svg;
  let path;
  let animateTransform;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      animateTransform = svg_element("animateTransform");
      attr(animateTransform, "attributeName", "transform");
      attr(animateTransform, "attributeType", "XML");
      attr(animateTransform, "type", "rotate");
      attr(animateTransform, "dur", "1s");
      attr(animateTransform, "from", "0 50 50");
      attr(animateTransform, "to", "360 50 50");
      attr(animateTransform, "repeatCount", "indefinite");
      attr(path, "d", "M31.6,3.5C5.9,13.6-6.6,42.7,3.5,68.4c10.1,25.7,39.2,38.3,64.9,28.1l-3.1-7.9c-21.3,8.4-45.4-2-53.8-23.3\n  c-8.4-21.3,2-45.4,23.3-53.8L31.6,3.5z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "x", "0px");
      attr(svg, "y", "0px");
      attr(svg, "viewBox", "0 0 100 100");
      attr(svg, "xml:space", "preserve");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(path, animateTransform);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class Loading extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$6, safe_not_equal, {});
  }
}
function create_fragment$5(ctx) {
  let svg;
  let g0;
  let g1;
  let g3;
  let g2;
  let path;
  let svg_levels = [
    { viewBox: "0 0 24 24" },
    { fill: "currentColor" },
    { xmlns: "http://www.w3.org/2000/svg" },
    { stroke: "currentColor" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g3 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      attr(g0, "stroke-width", "0");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path, "d", "M5 17.3336V6.66698C5 5.78742 5 5.34715 5.18509 5.08691C5.34664 4.85977 5.59564 4.71064 5.87207 4.67499C6.18868 4.63415 6.57701 4.84126 7.35254 5.25487L17.3525 10.5882L17.3562 10.5898C18.2132 11.0469 18.642 11.2756 18.7826 11.5803C18.9053 11.8462 18.9053 12.1531 18.7826 12.4189C18.6418 12.7241 18.212 12.9537 17.3525 13.4121L7.35254 18.7454C6.57645 19.1593 6.1888 19.3657 5.87207 19.3248C5.59564 19.2891 5.34664 19.1401 5.18509 18.9129C5 18.6527 5 18.2132 5 17.3336Z");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g0);
      append(svg, g1);
      append(svg, g3);
      append(g3, g2);
      append(g2, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { viewBox: "0 0 24 24" },
        { fill: "currentColor" },
        { xmlns: "http://www.w3.org/2000/svg" },
        { stroke: "currentColor" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Start extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
  }
}
function create_fragment$4(ctx) {
  let div3;
  let div2;
  let div0;
  let switch_instance;
  let t0;
  let div1;
  let strong;
  let t1_value = ctx[1][ctx[0].state] + "";
  let t1;
  let t2;
  let t3;
  let t4_value = new Date(ctx[0].ts).toLocaleString() + "";
  let t4;
  let current;
  var switch_value = ctx[2][ctx[0].state].component;
  function switch_props(ctx2) {
    return {
      props: {
        class: ctx2[2][ctx2[0].state].class
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t0 = space();
      div1 = element("div");
      strong = element("strong");
      t1 = text(t1_value);
      t2 = text(":");
      t3 = text("\n      \xA0");
      t4 = text(t4_value);
      attr(div0, "class", "d-flex");
      set_style(div0, "width", "20px");
      attr(div1, "class", "d-flex px-2 align-items-center");
      attr(div2, "class", "d-flex align-items-center");
      attr(div3, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      append(div2, t0);
      append(div2, div1);
      append(div1, strong);
      append(strong, t1);
      append(strong, t2);
      append(div1, t3);
      append(div1, t4);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & 1)
        switch_instance_changes.class = ctx2[2][ctx2[0].state].class;
      if (dirty & 1 && switch_value !== (switch_value = ctx2[2][ctx2[0].state].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[1][ctx2[0].state] + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 1) && t4_value !== (t4_value = new Date(ctx2[0].ts).toLocaleString() + ""))
        set_data(t4, t4_value);
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let { jobState } = $$props;
  const jobStateLabels = {
    [C$2.STATE_ERROR]: "Errored",
    [C$2.STATE_DISCARD]: "Cancelled",
    [C$2.STATE_DONE]: "Done",
    [C$2.STATE_READY]: "Running",
    [C$2.STATE_DEFAULT]: "Started",
    [C$2.STATE_TERMINATED]: "Terminated",
    [C$2.STATE_RETRYING]: "Started Retry"
  };
  const JOB_STOPPED_ICON = { component: Cross$1, class: "center-block" };
  const JOB_RUNNING_ICON = {
    component: Loading,
    class: "center-block"
  };
  let jobStateIcon = {
    [C$2.STATE_ERROR]: JOB_STOPPED_ICON,
    [C$2.STATE_TERMINATED]: JOB_STOPPED_ICON,
    [C$2.STATE_DONE]: { component: Check, class: "center-block" },
    [C$2.STATE_DEFAULT]: { component: Start, class: "center-block" },
    [C$2.STATE_READY]: JOB_RUNNING_ICON,
    [C$2.STATE_RETRYING]: {
      component: ReloadCircle,
      class: "center-block"
    }
  };
  $$self.$$set = ($$props2) => {
    if ("jobState" in $$props2)
      $$invalidate(0, jobState = $$props2.jobState);
  };
  return [jobState, jobStateLabels, jobStateIcon];
}
class RunDetail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, { jobState: 0 });
  }
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  child_ctx[18] = i2;
  return child_ctx;
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let div5;
  let div4;
  let div3;
  let h3;
  let t0_value = ctx[3].name + "";
  let t0;
  let t1;
  let t2_value = new Date(ctx[4].ts).toLocaleString() + "";
  let t2;
  let t3;
  let div2;
  let div1;
  let t4;
  let div0;
  let t5;
  let list;
  let current;
  let if_block = ctx[2].length > MAX_LENGTH && !ctx[0] && create_if_block_1$2(ctx);
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  list = new List({
    props: { jobState: ctx[4].state }
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div3 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(": Details for job run on ");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      if (if_block)
        if_block.c();
      t4 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t5 = space();
      create_component(list.$$.fragment);
      attr(div0, "class", "ms-4");
      attr(div1, "class", "ms-4");
      attr(div2, "class", "mt-5 w-50");
      attr(div3, "class", "col-sm-12");
      attr(div4, "class", "row");
      attr(div5, "class", "container");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div3);
      append(div3, h3);
      append(h3, t0);
      append(h3, t1);
      append(h3, t2);
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t4);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div3, t5);
      mount_component(list, div3, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 8) && t0_value !== (t0_value = ctx2[3].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 16) && t2_value !== (t2_value = new Date(ctx2[4].ts).toLocaleString() + ""))
        set_data(t2, t2_value);
      if (ctx2[2].length > MAX_LENGTH && !ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$2(ctx2);
          if_block.c();
          if_block.m(div1, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 2) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const list_changes = {};
      if (dirty & 16)
        list_changes.jobState = ctx2[4].state;
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      destroy_component(list);
    }
  };
}
function create_if_block_1$2(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${"Show more"}`;
      attr(button, "class", "btn btn-block btn-outline-secondary my-2 ms-4");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(ctx[9]));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "d-flex border-start h-8 my-1");
      set_style(div, "width", "20px");
      set_style(div, "margin-left", "10px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block(ctx) {
  let rundetail;
  let t;
  let if_block_anchor;
  let current;
  rundetail = new RunDetail({
    props: { jobState: ctx[16] }
  });
  let if_block = ctx[18] !== ctx[1].length - 1 && create_if_block$2();
  return {
    c() {
      create_component(rundetail.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(rundetail, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rundetail_changes = {};
      if (dirty & 2)
        rundetail_changes.jobState = ctx2[16];
      rundetail.$set(rundetail_changes);
      if (ctx2[18] !== ctx2[1].length - 1) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$2();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rundetail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rundetail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rundetail, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 15,
    blocks: [, , ,]
  };
  handle_promise(ctx[8], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_header_slot$1(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Crawlers</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot$1(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 524288) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      renderDefaultToolbar: true,
      $$slots: {
        topbar: [create_topbar_slot$1],
        default: [create_default_slot$2]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 524319) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
const MAX_LENGTH = 4;
function instance$3($$self, $$props, $$invalidate) {
  let $jobStates;
  let $crawler;
  let $job;
  let { params: params2 } = $$props;
  let expanded = false;
  let states = [];
  let crawler_id = params2 == null ? void 0 : params2.id;
  let id2 = params2 == null ? void 0 : params2.jobId;
  let crawler = new Crawler$2({ id: crawler_id });
  component_subscribe($$self, crawler, (value) => $$invalidate(3, $crawler = value));
  let job = new CrawlerJob({ id: id2 }, { crawler_id });
  component_subscribe($$self, job, (value) => $$invalidate(4, $job = value));
  let urlStore = new Urls({}, { crawler_id, id: id2 });
  let jobStates = new JobStates({}, { crawler_id, id: id2 });
  component_subscribe($$self, jobStates, (value) => $$invalidate(2, $jobStates = value));
  let fetchComplete;
  let pagePromise = new Promise((resolve, reject) => {
    fetchComplete = resolve;
  });
  setContext("url:store", urlStore);
  onMount(async () => {
    await Promise.all([urlStore.fetch(), crawler.fetch(), job.fetch(), jobStates.fetch()]);
    $$invalidate(1, states = $jobStates.length > MAX_LENGTH ? jobStates.toJSON().slice(-MAX_LENGTH) : jobStates.toJSON());
    fetchComplete(true);
  });
  function expand() {
    $$invalidate(0, expanded = !expanded);
    if (expanded) {
      $$invalidate(1, states = jobStates.toJSON());
    } else {
      $$invalidate(1, states = jobStates.toJSON().slice(-MAX_LENGTH));
    }
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(10, params2 = $$props2.params);
  };
  return [
    expanded,
    states,
    $jobStates,
    $crawler,
    $job,
    crawler,
    job,
    jobStates,
    pagePromise,
    expand,
    params2
  ];
}
class Job_detail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { params: 10 });
  }
}
function create_else_block$1(ctx) {
  let div1;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="alert alert-success">Thank you! Your response has been saved.</div>`;
      attr(div1, "class", "flex align-item justify-center");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block$1(ctx) {
  var _a;
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ((_a = ctx[2]) == null ? void 0 : _a.formName) && create_if_block_3(ctx);
  let if_block1 = ctx[0].formId && create_if_block_2(ctx);
  let if_block2 = ctx[2] && create_if_block_1$1(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if ((_a2 = ctx2[2]) == null ? void 0 : _a2.formName) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0].formId) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$1(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let h4;
  let t_value = ctx[2].formName + "";
  let t;
  return {
    c() {
      h4 = element("h4");
      t = text(t_value);
      attr(h4, "class", "pl3 font-bold");
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      append(h4, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[2].formName + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(h4);
    }
  };
}
function create_if_block_2(ctx) {
  let formgroup;
  let updating_model;
  let current;
  function formgroup_model_binding(value) {
    ctx[4](value);
  }
  let formgroup_props = { id: ctx[0].formId };
  if (ctx[2] !== void 0) {
    formgroup_props.model = ctx[2];
  }
  formgroup = new FormGroup({ props: formgroup_props });
  binding_callbacks.push(() => bind$2(formgroup, "model", formgroup_model_binding));
  return {
    c() {
      create_component(formgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formgroup_changes = {};
      if (dirty & 1)
        formgroup_changes.id = ctx2[0].formId;
      if (!updating_model && dirty & 4) {
        updating_model = true;
        formgroup_changes.model = ctx2[2];
        add_flush_callback(() => updating_model = false);
      }
      formgroup.$set(formgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formgroup, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = `${T("a_submit")}`;
      attr(button, "class", "btn btn-primary xbtn-default mt-1 mb-4");
      attr(div, "class", "pl3 xbg-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[3]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$1(ctx) {
  let div4;
  let div3;
  let div0;
  let t;
  let div2;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$1, create_else_block$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      t = space();
      div2 = element("div");
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "col-sm-4");
      attr(div1, "class", "row mb2");
      attr(div2, "class", "col-sm-4");
      attr(div3, "class", "row");
      attr(div4, "class", "container");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div3, t);
      append(div3, div2);
      append(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_header_slot(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Feedback</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 64) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let t;
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot],
        default: [create_default_slot$1]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
      document.title = "Feedback | Distill.io";
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 71) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $querystring;
  component_subscribe($$self, querystring, ($$value) => $$invalidate(5, $querystring = $$value));
  let { params: params2 } = $$props;
  let submitted = false;
  let model;
  async function submit() {
    try {
      const parsedQs = lib.parse($querystring);
      await (model == null ? void 0 : model.submit(parsedQs));
    } catch (e) {
      return;
    }
    $$invalidate(1, submitted = true);
  }
  function formgroup_model_binding(value) {
    model = value;
    $$invalidate(2, model);
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, submitted, model, submit, formgroup_model_binding];
}
class Forms extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, { params: 0 });
  }
}
function prepareRoutes(overrides) {
  return {
    "/admin/:module/": Admin,
    "/teams/": Teams,
    "/teams/:id": Team,
    "/u/:team/usage/:module/": Usage_1,
    "/u/:team/sieve/:sieveId/data/:dataId/diff": Explore_diff,
    "/u/:team/crawlers/": Crawlers_1,
    "/u/:team/crawlers/:id": Crawler_detail,
    "/u/:team/crawlers/:id/:jobId": Job_detail,
    "/u/:team/sieve/:id/detail": SieveDetail,
    "/checks/:team/:sieveID": Works$1,
    "/w/:team/:module/": Watchlist,
    "/w/:team/:module/:prefix/*": Watchlist,
    "/u/:team/form/:formId": Forms,
    ...overrides,
    "*": Error404
  };
}
function prepareRedirects(overrides = {}) {
  const redirects = {
    "": () => {
      return `#/w/0/list/all/`;
    },
    "inbox": () => {
      return `#/w/0/list/all/`;
    },
    "/w/:team/sieve/detail/:sieveId.id": ({ team, sieveId }) => {
      return `#/u/${team}/sieve/${sieveId}/detail`;
    },
    ...overrides
  };
  const handlers = {};
  const rp = Object.keys(redirects).map((u) => {
    const rp2 = parse$3(u);
    handlers[rp2.pattern.source] = redirects[u];
    return rp2;
  });
  return ({ location: location2 }) => {
    let hash = (location2.hash || "").replace("#", "");
    if (!hash.startsWith("/")) {
      hash = "/" + hash;
    }
    for (let i2 = 0; i2 < rp.length; i2++) {
      if (rp[i2].pattern.test(hash)) {
        const paramsKV = exec(hash, rp[i2]);
        return handlers[rp[i2].pattern.source](paramsKV);
      }
    }
    return null;
  };
}
function exec(path, result) {
  let i2 = 0, out = {};
  let matches = result.pattern.exec(path);
  while (i2 < result.keys.length) {
    out[result.keys[i2]] = matches[++i2] || null;
  }
  return out;
}
function navBack() {
  if (history.length > 1) {
    history.back();
  } else {
    replace$1("/w/0/list/all/");
  }
}
function appCommon({
  setContext: setContext2,
  clientId
}) {
  let labels = new ModelLabel.Labels();
  let user = new Self();
  let redirectedRoutes = prepareRedirects();
  window.redirectedRoutes = redirectedRoutes;
  setContext2("api", Api.api);
  setContext2("user", user);
  setContext2("labels", labels);
  setContext2("clientId", clientId);
  const newURL = redirectedRoutes({ location });
  if (newURL) {
    replace$1(newURL);
  }
  const Root = View.RoutedRoot.extend({
    actions: {
      "go_back": { fn: "action_go_back" },
      "go_up": { fn: "action_go_up" }
    },
    action_go_back: function() {
      navBack();
    },
    action_go_up: function() {
      let path = location.hash.slice(1);
      if (path.endsWith("/")) {
        let parts = path.split("/");
        let newParts = parts.slice(0, parts.length - 2);
        let newPath = newParts.join("/") + "/";
        push$1(newPath);
      } else {
        push$1(path.slice(0, path.lastIndexOf("/") + 1));
      }
    },
    route: function(path) {
      push$1(`/${path}`);
    }
  });
  let root = new Root();
  setContext2("view:root", root);
  Core$1.Acts.setView(root);
  Api.on("error:403", (err) => {
    Msg.error("You do not have enough permissions. Please contact your account administrator.");
    setTimeout(() => {
      Msg.reset();
    }, 8 * 1e3);
  });
  return {
    labels,
    user,
    root,
    navBack
  };
}
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1(ctx) {
  let router;
  let current;
  router = new Router({ props: { routes: ctx[1] } });
  router.$on("routeLoaded", ctx[5]);
  return {
    c() {
      create_component(router.$$.fragment);
    },
    m(target, anchor) {
      mount_component(router, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const router_changes = {};
      if (dirty & 2)
        router_changes.routes = ctx2[1];
      router.$set(router_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(router.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(router.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(router, detaching);
    }
  };
}
function create_if_block(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: T("l_feedback_form"),
      onSave: ctx[7],
      saveLabel: "Submit",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[8]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 28)
        savemodal_changes.onSave = ctx2[7];
      if (dirty & 1032) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let formgroup;
  let updating_model;
  let current;
  function formgroup_model_binding(value) {
    ctx[6](value);
  }
  let formgroup_props = { id: C$2.FORM_APP_FEEDBACK };
  if (ctx[3] !== void 0) {
    formgroup_props.model = ctx[3];
  }
  formgroup = new FormGroup({ props: formgroup_props });
  binding_callbacks.push(() => bind$2(formgroup, "model", formgroup_model_binding));
  return {
    c() {
      create_component(formgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formgroup_changes = {};
      if (!updating_model && dirty & 8) {
        updating_model = true;
        formgroup_changes.model = ctx2[3];
        add_flush_callback(() => updating_model = false);
      }
      formgroup.$set(formgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formgroup, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let button;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[2] && create_if_block(ctx);
  return {
    c() {
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      button = element("button");
      button.textContent = "Give Feedback";
      attr(button, "class", "btn btn-default xbtn-feedback xbtn-default");
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, button, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t0.parentNode, t0);
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function preventDefault(e) {
  if (e.target.tagName == "A" && e.target.getAttribute("href") == "#") {
    let url = new URL(e.target.href);
    if (url.hash === "") {
      e.preventDefault();
    }
  }
}
function instance$1($$self, $$props, $$invalidate) {
  let $location;
  component_subscribe($$self, location$1, ($$value) => $$invalidate(4, $location = $$value));
  let { loaded } = $$props;
  let { routes } = $$props;
  let showFeedbackModal = false;
  let feedbackModel;
  function routeLoaded(event) {
    var _a, _b, _c, _d;
    const team = (_c = (_b = (_a = event.detail) == null ? void 0 : _a.params) == null ? void 0 : _b.team) != null ? _c : "0";
    const routeName = (_d = event.detail) == null ? void 0 : _d.route;
    updateTeam(team);
    updateRoute(routeName);
    Msg.reset();
  }
  document.addEventListener("click", preventDefault);
  function formgroup_model_binding(value) {
    feedbackModel = value;
    $$invalidate(3, feedbackModel);
  }
  const func2 = () => {
    let doc = { location: $location };
    feedbackModel.submit(doc);
    $$invalidate(2, showFeedbackModal = false);
  };
  const close_handler = () => {
    $$invalidate(2, showFeedbackModal = false);
  };
  const click_handler = () => {
    $$invalidate(2, showFeedbackModal = true);
  };
  $$self.$$set = ($$props2) => {
    if ("loaded" in $$props2)
      $$invalidate(0, loaded = $$props2.loaded);
    if ("routes" in $$props2)
      $$invalidate(1, routes = $$props2.routes);
  };
  return [
    loaded,
    routes,
    showFeedbackModal,
    feedbackModel,
    $location,
    routeLoaded,
    formgroup_model_binding,
    func2,
    close_handler,
    click_handler
  ];
}
class AppCommon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { loaded: 0, routes: 1 });
  }
}
var AppLocal_svelte_svelte_type_style_lang = "";
function create_fragment(ctx) {
  let div2;
  let t1;
  let appcommon;
  let current;
  appcommon = new AppCommon({
    props: {
      loaded: ctx[1],
      routes: ctx[3]
    }
  });
  return {
    c() {
      div2 = element("div");
      div2.innerHTML = `<div class="xmsg" style="display:inline-block;"></div> 
  <div class="xerror" style="display:inline-block;"></div>`;
      t1 = space();
      create_component(appcommon.$$.fragment);
      attr(div2, "id", "msg");
      attr(div2, "class", "container-fluid xmsgbox");
      set_style(div2, "width", "100%");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      ctx[6](div2);
      insert(target, t1, anchor);
      mount_component(appcommon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const appcommon_changes = {};
      if (dirty & 2)
        appcommon_changes.loaded = ctx2[1];
      appcommon.$set(appcommon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(appcommon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(appcommon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      ctx[6](null);
      if (detaching)
        detach(t1);
      destroy_component(appcommon, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $user, $$unsubscribe_user = noop, $$subscribe_user = () => ($$unsubscribe_user(), $$unsubscribe_user = subscribe(user, ($$value) => $$invalidate(7, $user = $$value)), user);
  $$self.$$.on_destroy.push(() => $$unsubscribe_user());
  let { labels: labels_1, user: user_1, root: root_1 } = appCommon({ setContext, clientId: serviceProxy.clientId });
  let { labels = labels_1, user = user_1, root = root_1 } = $$props;
  $$subscribe_user();
  let loaded = false;
  let elMsg;
  const routes = prepareRoutes({ "/settings/:module/": Index_ext });
  instance$4s.on("users", syncUser);
  onMount(async () => {
    Msg.bind(elMsg);
    window.USER = $user;
    await isReady();
    await Promise.all([syncUser()]);
    $$invalidate(1, loaded = true);
  });
  onDestroy(() => {
    instance$4s.off("users", syncUser);
  });
  async function isReady() {
    return new Promise(async (resolve) => {
      if (await serviceProxy.service.isReady()) {
        if (await serviceProxy.auth.isReady()) {
          resolve();
        } else {
          location.href = serviceProxy.CFG.URL.LOGIN;
        }
      } else {
        serviceProxy.serviceEvents.on("init", resolve);
      }
    });
  }
  async function syncUser() {
    if (await serviceProxy.auth.isLoggedIn()) {
      await user.fetch().catch(async (e) => {
        let tUser = await serviceProxy.store.UserStore.findOne({ id: await serviceProxy.auth.getId() });
        tUser && user.set(tUser);
      });
    }
    let locale = $user.locale || await serviceProxy.store.Prefs.get("locale");
    await loadLang(locale || "en-US");
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elMsg = $$value;
      $$invalidate(2, elMsg);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("labels" in $$props2)
      $$invalidate(4, labels = $$props2.labels);
    if ("user" in $$props2)
      $$subscribe_user($$invalidate(0, user = $$props2.user));
    if ("root" in $$props2)
      $$invalidate(5, root = $$props2.root);
  };
  return [user, loaded, elMsg, routes, labels, root, div2_binding];
}
class AppLocal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { labels: 4, user: 0, root: 5 });
  }
  get labels() {
    return this.$$.ctx[4];
  }
  set labels(labels) {
    this.$$set({ labels });
    flush();
  }
  get user() {
    return this.$$.ctx[0];
  }
  set user(user) {
    this.$$set({ user });
    flush();
  }
  get root() {
    return this.$$.ctx[5];
  }
  set root(root) {
    this.$$set({ root });
    flush();
  }
  get navBack() {
    return navBack;
  }
}
export { AppLocal as default };
