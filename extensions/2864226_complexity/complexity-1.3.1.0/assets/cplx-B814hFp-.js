import{g as j}from"./cplx-BbAh7E-i.js";var I={exports:{}};const k=e=>typeof crypto<"u"&&typeof crypto.getRandomValues=="function"?()=>{const n=crypto.getRandomValues(new Uint8Array(1))[0];return(n>=e?n%e:n).toString(e)}:()=>Math.floor(Math.random()*e).toString(e),v=(e=7,n=!1)=>Array.from({length:e},k(n?16:36)).join("");I.exports=v;I.exports.default=v;var N=I.exports;const w=j(N);var $=/^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/,x=e=>{const[,n,s,i]=e.match($)||[];return{context:n,tabId:+s,frameId:i?+i:void 0}},B=({context:e,tabId:n,frameId:s})=>["background","popup","options"].includes(e)?e:`${e}@${n}${s?`.${s}`:""}`;const O=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0}],_=Symbol(".toJSON was called"),D=e=>{e[_]=!0;const n=e.toJSON();return delete e[_],n},C=({from:e,seen:n,to_:s,forceEnumerable:i,maxDepth:c,depth:f})=>{const r=s||(Array.isArray(e)?[]:{});if(n.push(e),f>=c)return r;if(typeof e.toJSON=="function"&&e[_]!==!0)return D(e);for(const[t,o]of Object.entries(e)){if(typeof Buffer=="function"&&Buffer.isBuffer(o)){r[t]="[object Buffer]";continue}if(o!==null&&typeof o=="object"&&typeof o.pipe=="function"){r[t]="[object Stream]";continue}if(typeof o!="function"){if(!o||typeof o!="object"){r[t]=o;continue}if(!n.includes(e[t])){f++,r[t]=C({from:e[t],seen:[...n],forceEnumerable:i,maxDepth:c,depth:f});continue}r[t]="[Circular]"}}for(const{property:t,enumerable:o}of O)typeof e[t]=="string"&&Object.defineProperty(r,t,{value:e[t],enumerable:i?!0:o,configurable:!0,writable:!0});return r};function P(e,n={}){const{maxDepth:s=Number.POSITIVE_INFINITY}=n;return typeof e=="object"&&e!==null?C({from:e,seen:[],forceEnumerable:!0,maxDepth:s,depth:0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}let T=()=>({events:{},emit(e,...n){(this.events[e]||[]).forEach(s=>s(...n))},on(e,n){return(this.events[e]=this.events[e]||[]).push(n),()=>this.events[e]=(this.events[e]||[]).filter(s=>s!==n)}});var F=(e,n,s)=>{const i=w(),c=new Map,f=new Map,r=t=>{if(t.destination.context===e&&!t.destination.frameId&&!t.destination.tabId){s==null||s(t);const{transactionId:o,messageID:d,messageType:u}=t,m=()=>{const l=c.get(o);if(l){const{err:a,data:y}=t;if(a){const p=a,S=self[p.name],E=new(typeof S=="function"?S:Error)(p.message);for(const M in p)E[M]=p[M];l.reject(E)}else l.resolve(y);c.delete(o)}},h=async()=>{let l,a,y=!1;try{const p=f.get(d);if(typeof p=="function")l=await p({sender:t.origin,id:d,data:t.data,timestamp:t.timestamp});else throw y=!0,new Error(`[webext-bridge] No handler registered in '${e}' to accept messages with id '${d}'`)}catch(p){a=p}finally{if(a&&(t.err=P(a)),r({...t,messageType:"reply",data:l,origin:{context:e,tabId:null},destination:t.origin,hops:[]}),a&&!y)throw l}};switch(u){case"reply":return m();case"message":return h()}}return t.hops.push(`${e}::${i}`),n(t)};return{handleMessage:r,endTransaction:t=>{const o=c.get(t);o==null||o.reject("Transaction was ended before it could complete"),c.delete(t)},sendMessage:(t,o,d="background")=>{const u=typeof d=="string"?x(d):d,m="Bridge#sendMessage ->";if(!u.context)throw new TypeError(`${m} Destination must be any one of known destinations`);return new Promise((h,l)=>{const a={messageID:t,data:o,destination:u,messageType:"message",transactionId:w(),origin:{context:e,tabId:null},hops:[],timestamp:Date.now()};c.set(a.transactionId,{resolve:h,reject:l});try{r(a)}catch(y){c.delete(a.transactionId),l(y)}})},onMessage:(t,o)=>(f.set(t,o),()=>f.delete(t))}},g=class{constructor(e,n){this.endpointRuntime=e,this.streamInfo=n,this.emitter=T(),this.isClosed=!1,this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},g.initDone||(e.onMessage("__crx_bridge_stream_transfer__",s=>{const{streamId:i,streamTransfer:c,action:f}=s.data,r=g.openStreams.get(i);r&&!r.isClosed&&(f==="transfer"&&r.emitter.emit("message",c),f==="close"&&(g.openStreams.delete(i),r.handleStreamClose()))}),g.initDone=!0),g.openStreams.set(this.streamInfo.streamId,this)}get info(){return this.streamInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:e,action:"transfer"},this.streamInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:null,action:"close"},this.streamInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,n){const s=this.emitter.on(e,n);return Object.assign(s,{dispose:s,close:s})}},b=g;b.initDone=!1;b.openStreams=new Map;var J=e=>{const n=new Map,s=new Map,i=T();e.onMessage("__crx_bridge_stream_open__",r=>new Promise(t=>{const{sender:o,data:d}=r,{channel:u}=d;let m=!1,h=()=>{};const l=()=>{const a=s.get(u);typeof a=="function"?(a(new b(e,{...d,endpoint:o})),m&&h(),t(!0)):m||(m=!0,h=i.on("did-change-stream-callbacks",l))};l()}));async function c(r,t){if(n.has(r))throw new Error("webext-bridge: A Stream is already open at this channel");const o=typeof t=="string"?x(t):t,d={streamId:w(),channel:r,endpoint:o},u=new b(e,d);return u.onClose(()=>n.delete(r)),await e.sendMessage("__crx_bridge_stream_open__",d,o),n.set(r,u),u}function f(r,t){if(s.has(r))throw new Error("webext-bridge: This channel has already been claimed. Stream allows only one-on-one communication");s.set(r,t),i.emit("did-change-stream-callbacks")}return{openStream:c,onOpenStreamChannel:f}};export{J as a,F as c,B as f,x as p,w as u};
