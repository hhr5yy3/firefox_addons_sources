{"version":3,"file":"useUnlock-23c9a9eb.js","sources":["../../../../client-core/lib/src/util/loginFilter.js","../../../node_modules/throttle-debounce/index.esm.js","../../../src/util/addAchievement.ts","../../../src/util/dom/copyToClipboard.ts","../../../src/util/getUnprotectedValueForContentLogin.ts","../../../src/util/react/useCopyToClipboard.ts","../../../src/connections/index.ts","../../../src/util/react/useUnlock.tsx"],"sourcesContent":["import getRelatedDomains from '../relatedDomains/getRelatedDomains';\nexport function searchPredicate(login, searchString) {\n    return getSearchTerms(searchString).every((part) => searchWordPredicate(login, part));\n}\n// NOTE: Keep consistent with getSearchableTermList below!\nfunction searchWordPredicate(login, searchTerm) {\n    var _a, _b, _c, _d, _e, _f;\n    return (login.title.toLowerCase().includes(searchTerm) ||\n        login.username.toLowerCase().includes(searchTerm) ||\n        login.note.toLowerCase().includes(searchTerm) ||\n        ((_a = login.creditCard) === null || _a === void 0 ? void 0 : _a.cardHolder.toLowerCase().includes(searchTerm)) ||\n        ((_b = login.creditCard) === null || _b === void 0 ? void 0 : _b.displayType.toLowerCase().includes(searchTerm)) ||\n        (\n        // Number is stored normalized with spaces for grouping. Remove to allow searching without. Note;\n        // that searchTerm never contains spaces, so no need to also include number with spaces.\n        (_c = login.creditCard) === null || _c === void 0 ? void 0 : _c.number.replace(/ /g, '').toLowerCase().includes(searchTerm)) ||\n        ((_d = login.wifiSsid) === null || _d === void 0 ? void 0 : _d.toLowerCase().includes(searchTerm)) ||\n        login.customFields\n            .filter((cf) => !cf.protected)\n            .some((cf) => cf.value.toLowerCase().includes(searchTerm)) ||\n        searchWordPredicateWebsite(login, searchTerm) ||\n        ((_e = login.androidApps) === null || _e === void 0 ? void 0 : _e.some((a) => a.displayName.toLowerCase().includes(searchTerm))) ||\n        ((_f = login.tags) === null || _f === void 0 ? void 0 : _f.some((t) => t.toLowerCase().includes(searchTerm))));\n}\nfunction searchWordPredicateWebsite({ websites }, searchTerm) {\n    const match = /^www\\.(.+)$/.exec(searchTerm);\n    const strippedSearchTerm = match ? match[1] : searchTerm;\n    if (websites.some((w) => w.toLowerCase().includes(strippedSearchTerm))) {\n        return true;\n    }\n    return getRelatedDomainsForWebsites(websites).some((w) => w.includes(strippedSearchTerm));\n}\nexport function getSearchTerms(searchString) {\n    return searchString\n        .toLowerCase()\n        .trim()\n        .split(/\\s+/)\n        .map((part) => {\n        if (part.startsWith('#')) {\n            // We used prefix tags with the # symbol for display, and allowed search with that symbol\n            // accordingly. For now we strip leading \"#\" so searching for \"#tag\" continues to\n            // work for finding logins tagged with \"tag\"\n            return part.replace(/^#+/, '');\n        }\n        else {\n            return part;\n        }\n    });\n}\nexport function compareLoginsByChangeTime(l, r) {\n    var _a, _b;\n    const lTime = (_a = l.changeTime) !== null && _a !== void 0 ? _a : l.editTime;\n    const rTime = (_b = r.changeTime) !== null && _b !== void 0 ? _b : r.editTime;\n    return rTime.localeCompare(lTime);\n}\nexport function filterLogins(logins, searchString) {\n    const filtered = !searchString\n        ? [...logins]\n        : logins.filter((l) => searchPredicate(l, searchString));\n    filtered.sort(compareLoginsByChangeTime);\n    return filtered;\n}\n// Returns a list of searchable terms for a login. client-node-bridge provides this list to the\n// mobile apps to facilitate filtering of logins.\n// NOTE: Keep consistent with searchWordPredicate above!\nexport function getSearchableTermList(login) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    return [\n        login.username,\n        login.title,\n        login.note,\n        (_a = login.creditCard) === null || _a === void 0 ? void 0 : _a.cardHolder,\n        (_b = login.creditCard) === null || _b === void 0 ? void 0 : _b.displayType,\n        (_c = login.creditCard) === null || _c === void 0 ? void 0 : _c.number.replace(/ /g, ''),\n        login.wifiSsid,\n        ...login.websites,\n        ...login.customFields.flatMap((cf) => (!cf.protected ? cf.value : [])),\n        ...((_d = login.tags) !== null && _d !== void 0 ? _d : []),\n        // We used prefix tags with the # symbol for display, and allowed search with that symbol\n        // accordingly. For now we keep these in searchable terms so searching for \"#tag\" continues to\n        // work for finding logins tagged with \"tag\"\n        ...((_f = (_e = login.tags) === null || _e === void 0 ? void 0 : _e.map((t) => `#${t}`)) !== null && _f !== void 0 ? _f : []),\n        ...((_h = (_g = login.androidApps) === null || _g === void 0 ? void 0 : _g.map((a) => a.displayName)) !== null && _h !== void 0 ? _h : []),\n        ...getRelatedDomainsForWebsites(login.websites),\n    ].flatMap((t) => {\n        const normalized = t === null || t === void 0 ? void 0 : t.trim().toLowerCase();\n        return normalized ? normalized : [];\n    });\n}\nexport function getRelatedDomainsForWebsites(websites) {\n    const domains = websites.flatMap((website) => {\n        try {\n            return new URL(`https://${website}`).hostname;\n        }\n        catch (e) {\n            return [];\n        }\n    });\n    // We don't have access to the psl here, so we approximate by simply splitting the domains and\n    // including all parent domains. We can afford to be less exact than in getLoginsForUrl, the worst\n    // thing that's going to happen is showing more logins than expected in search.\n    const domainsWithPslApproximation = domains.flatMap((hostname) => {\n        const splitHostname = hostname.split('.').reverse();\n        const result = [];\n        // eslint-disable-next-line prefer-const\n        let [current, ...rest] = splitHostname;\n        for (const part of rest) {\n            current = `${part}.${current}`;\n            result.push(current);\n        }\n        return result;\n    });\n    // Note that this may return duplicates if some of the domains have overlapping related domains.\n    // It's not worth it filtering them out, since we will only proceed to the first match anyways.\n    return domainsWithPslApproximation.flatMap((domain) => { var _a; return (_a = getRelatedDomains(domain)) !== null && _a !== void 0 ? _a : []; });\n}\n//# sourceMappingURL=loginFilter.js.map","/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset).\n * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function}  A new, throttled, function.\n */\nfunction throttle (delay, noTrailing, callback, debounceMode) {\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel() {\n    clearExistingTimeout();\n    cancelled = true;\n  } // `noTrailing` defaults to falsy.\n\n\n  if (typeof noTrailing !== 'boolean') {\n    debounceMode = callback;\n    callback = noTrailing;\n    noTrailing = undefined;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */\n      exec();\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, atBegin, callback) {\n  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\n}\n\nexport { debounce, throttle };\n//# sourceMappingURL=index.esm.js.map\n","import { Achievement, trackError } from 'backend-client-web';\n\nimport { sendMessage } from 'src/message';\n\nexport default function addAchievement(...achievements: Achievement[]) {\n  sendMessage({\n    type: 'AddAchievements',\n    achievements,\n  }).catch(trackError);\n}\n","import { trackError } from 'backend-client-web';\n\nimport { sendMessage } from 'src/message';\n\n/**\n * Copies a value to clipboard.\n *\n * Writing to the clipboard is complicated by the fact that different browsers support different\n * sets of APIs and have differing requirements with regard to user gesture.\n *\n * In most browsers we have the `clipboardWrite` permission, which allows us to write to the\n * clipboard in the background without further restrictions.\n *\n * However this permission does not exist in Safari, so there we're only allowed to write to the\n * clipboard when calling the APi synchronously from a user gesture (e.g. a click or keyboard\n * handler). This is meant to protect the user from websites unexpectedly overwriting their\n * clipboard.\n *\n * To be able to write a value to the clipboard that we procure asynchronously and still fulfill the\n * user gesture requirement we accept a promise of the value to copy, which we can then warp in a\n * `ClipboardItem`. See https://wolfgangrittner.dev/how-to-use-clipboard-api-in-firefox/ for more\n * details.\n *\n * We need to be able to get the value asynchronously for ProtectedValues. For these extension pages\n * message the background script to perform the unprotect. Note that for the async we need to also\n * deal with the fact the we might get `undefined` when unprotect fails. As a fallback we copy empty\n * string in that case.\n */\nexport default async function copyToClipboard(value: string | Promise<string | undefined>) {\n  try {\n    // Try the modern approach with ClipboardItem and an async value. This is used in Chrome and\n    // Safari.\n    if (window.ClipboardItem && navigator.clipboard.write) {\n      const filteredValue = typeof value === 'string' ? value : value.then((v) => v ?? '');\n      const text = new ClipboardItem({\n        'text/plain': filteredValue,\n      });\n      await navigator.clipboard.write([text]);\n      return await filteredValue;\n    } else {\n      // If ClipboardItem is not supported fall back to navigator.clipboard.writeText. This is for\n      // older versions of Firefox (< 127, released 2024-06-11)\n      const text = await value;\n      if (text !== undefined) {\n        await navigator.clipboard.writeText(text);\n      }\n      return text;\n    }\n  } catch (e) {\n    // Chrome doesn't allow access to navigator.clipboard in iframes, so we need to fall back to\n    // the old-style document.execCommand api.\n    // See https://github.com/HearthSim/twitch-hdt-frontend/issues/50#issuecomment-824773810\n    const text = await value;\n    if (text !== undefined) {\n      fallbackCopyTextToClipboard(text);\n    }\n    return text;\n  }\n}\n\nfunction fallbackCopyTextToClipboard(text: string) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    const successful = document.execCommand('copy');\n    if (!successful) {\n      throw new Error('unable to copy!');\n    }\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n\nexport async function copyToClipboardWithClear(\n  value: string | Promise<string | undefined>,\n  clearAfterTimeout?: boolean,\n): Promise<string | undefined> {\n  // Be very careful with adding await calls here! We need to preserve a user gesture when\n  // trying to write to the clipboard in Safari, so we can't have any awaits before the\n  // navigator.clipboard.write call.\n  const copiedText = await copyToClipboard(value);\n  if (copiedText === undefined) {\n    return;\n  }\n  sendMessage({\n    type: 'SetClearValueFromClipboardAfterTimeout',\n    clearAfterTimeout: !!clearAfterTimeout,\n    value: copiedText,\n  }).catch(trackError);\n  return copiedText;\n}\n","import { VaultId } from 'backend-client-web';\nimport { ProtectedValue, UnprotectedValue } from 'persistable-types';\n\nimport { messageError, sendMessage } from 'src/message';\nimport { ContentLogin } from 'src/types';\n\nexport default async function getUnprotectedValueForContentLogin(\n  l: ContentLogin,\n  value: ProtectedValue | UnprotectedValue,\n): Promise<string | undefined> {\n  return (await getUnprotectedValueForContentLoginWithContentId(l, value))?.unencrypted;\n}\n\nexport async function getUnprotectedValueForContentLoginWithContentId(\n  l: ContentLogin,\n  value: ProtectedValue | UnprotectedValue,\n): Promise<UnprotectedValue | undefined> {\n  if (!l.vaultMetadata) {\n    return undefined;\n  }\n  return getUnprotectedValueForVaultWithContentId(l.vaultMetadata.id, value);\n}\n\nexport async function getUnprotectedValueForVault(\n  vaultId: VaultId,\n  value: ProtectedValue | UnprotectedValue,\n) {\n  return (await getUnprotectedValueForVaultWithContentId(vaultId, value))?.unencrypted;\n}\n\nexport async function getUnprotectedValueForVaultWithContentId(\n  vaultId: VaultId,\n  value: ProtectedValue | UnprotectedValue,\n): Promise<UnprotectedValue | undefined> {\n  if ('unencrypted' in value) {\n    return value;\n  }\n  const response = await sendMessage({\n    type: 'GetUnprotectedValue',\n    vaultId: vaultId,\n    value: value,\n  });\n  if (response === messageError) {\n    return undefined;\n  }\n  return response;\n}\n","import { useCallback, useRef, useState } from 'react';\n\nimport { trackError } from 'backend-client-web';\n\nexport default function useCopyToClipboard(\n  copyToClipboardWithClear: (\n    value: string | Promise<string | undefined>,\n    clearAfterTimeout?: boolean,\n  ) => Promise<string | undefined>,\n) {\n  const [copied, setCopied] = useState(false);\n  const resetCopiedTimerRef = useRef<number>();\n\n  const copy = useCallback(\n    (value: string | Promise<string | undefined>, clearAfterTimeout?: boolean) => {\n      (async () => {\n        // Be very careful with adding await calls here! We need to preserve a user gesture when\n        // trying to write to the clipboard in Safari, so we can't have any awaits before the\n        // navigator.clipboard.write call.\n        const copiedText = await copyToClipboardWithClear(value, clearAfterTimeout);\n        if (!copiedText) {\n          return;\n        }\n\n        setCopied(true);\n        window.clearTimeout(resetCopiedTimerRef.current);\n        resetCopiedTimerRef.current = window.setTimeout(() => {\n          setCopied(false);\n        }, 1000);\n      })().catch(trackError);\n    },\n    [copyToClipboardWithClear],\n  );\n\n  return [copied, copy] as const;\n}\n","import browser from 'webextension-polyfill';\n\nimport { isWebExtError } from 'src/webExtErrors';\n\nimport { ClientPort, BackgroundPort } from './base';\nimport { ForwardContentConnectionDescriptor } from './forwardContentConnection';\nimport { ForwardIframeConnectionDescriptor } from './forwardIframeConnection';\nimport { UnlockConnectionDescriptor } from './unlockConnection';\nimport { WebauthnUnlockConnectionDescriptor } from './webauthnUnlockConnection';\n\nexport * from './base';\nexport * from './unlockConnection';\nexport * from './contentIframeMessages';\nexport * from './forwardContentConnection';\nexport * from './forwardIframeConnection';\n\nexport type ConnectionDescriptor =\n  | UnlockConnectionDescriptor\n  | ForwardIframeConnectionDescriptor\n  | ForwardContentConnectionDescriptor\n  | WebauthnUnlockConnectionDescriptor;\n\ntype ConnectionName = ConnectionDescriptor['name'];\ntype ConnectionDescriptorByName<N extends ConnectionName> = Extract<\n  ConnectionDescriptor,\n  { name: N }\n>;\n\nexport function openConnection<P extends ConnectionDescriptor & { useConnectionId: true }>(\n  name: P['name'],\n  connectionId: string,\n): ClientPort<P>;\n\nexport function openConnection<P extends ConnectionDescriptor & { useConnectionId: false }>(\n  name: P['name'],\n): ClientPort<P>;\n\nexport function openConnection<P extends ConnectionDescriptor>(\n  name: P['name'],\n  connectionId?: string,\n): ClientPort<P> {\n  const portName = makePortName(name, connectionId);\n\n  let port: ClientPort<P> | undefined;\n\n  // browser.runtime.connect can intermittently fail in Firefox according to error reporting. It\n  // isn't really clear when that happens or what we can do to prevent it. As an experimental fix we\n  // retry for a few times and report if that still does not result in a connection.\n  // See https://sentry.heylogin.dev/organizations/heylogin/issues/18\n  let retries = 0;\n  while (!port && retries < 3) {\n    try {\n      port = browser.runtime.connect(undefined, {\n        name: portName,\n      }) as ClientPort<P>;\n    } catch (e) {\n      if (!isWebExtError(e, 'UNEXPECTED_ERROR')) {\n        throw e;\n      }\n    }\n    retries++;\n  }\n\n  if (!port) {\n    throw new Error('Failed to open connection after retries');\n  }\n\n  return port;\n}\n\ntype ConnectionHandler<N extends ConnectionName> = (\n  port: BackgroundPort<ConnectionDescriptorByName<N>>,\n  connectionId?: string,\n) => void;\n\nexport function makeConnectionListener(\n  handlers: {\n    [N in ConnectionName]?: ConnectionHandler<N>;\n  },\n) {\n  return (port: browser.Runtime.Port) => {\n    const { name, connectionId } = parsePortName(port.name);\n    if (!isKey(name, handlers)) {\n      return;\n    }\n    const handler = handlers[name];\n    if (handler) {\n      handler(port as any, connectionId);\n    }\n  };\n}\n\nfunction makePortName(name: string, connectionId: string | undefined) {\n  if (!connectionId) {\n    return name;\n  }\n  return `${name},${connectionId}`;\n}\n\nfunction parsePortName(portName: string) {\n  const [name, ...rest] = portName.split(',');\n  if (rest.length) {\n    return { name, connectionId: rest.join(',') };\n  }\n  return { name, connectionId: undefined };\n}\n\nfunction isKey<T extends object>(k: string | number | symbol, obj: T): k is keyof T {\n  return k in obj;\n}\n","import { useState, useRef, useCallback, useEffect } from 'react';\nimport browser from 'webextension-polyfill';\n\nimport {\n  Achievement,\n  LoginId,\n  VaultId,\n  assertExhaustive,\n  debugConsole,\n  trackError,\n} from 'backend-client-web';\nimport { newUuid, TotpParameters } from 'client-core';\nimport { PushStateType, UnlockDeviceType } from 'client-web-sdk';\n\nimport {\n  openConnection,\n  UnlockConnectionDescriptor,\n  UnlockBackgroundMessage,\n  UnlockClientMessage,\n} from 'src/connections';\nimport { makeMessageListener, messageError, sendMessage } from 'src/message';\nimport { getFrontendServerUrl } from 'src/serverUrl';\nimport { UnlockState } from 'src/types';\nimport addAchievement from 'src/util/addAchievement';\n\nexport default function useUnlock({\n  unlockOnInitialRender,\n  achievement,\n  skipWebauthnUnlock,\n}: {\n  unlockOnInitialRender?: boolean;\n  achievement: Achievement;\n  skipWebauthnUnlock?: boolean;\n}) {\n  const [isUnlocked, setIsUnlocked] = useState<boolean>();\n  const [unlockState, setUnlockState] = useState<UnlockState | undefined>(\n    unlockOnInitialRender && !skipWebauthnUnlock ? 'unlocking' : undefined,\n  );\n  const [webauthnOnlyUnlockSkipped, setWebauthnOnlyUnlockSkipped] = useState(false);\n  const [unlockDeviceType, setUnlockDeviceType] = useState<UnlockDeviceType>();\n\n  const disconnectPortRef = useRef<() => void>();\n  const cancelWebauthnRef = useRef<() => void>();\n\n  const triggerUnlock = useCallback(\n    (initialMessage: UnlockClientMessage, onStateChange?: (state: UnlockState) => void) => {\n      const unlockPort = openConnection<UnlockConnectionDescriptor>('Unlock');\n\n      disconnectPortRef.current = () => {\n        unlockPort.disconnect();\n      };\n\n      function onDisconnect() {\n        unlockPort.onMessage.removeListener(onMessage);\n        unlockPort.onDisconnect.removeListener(onDisconnect);\n      }\n\n      function onMessage(message: UnlockBackgroundMessage) {\n        if (message.type === 'StateUpdate') {\n          debugConsole.log(message);\n          const { state } = message;\n          setUnlockState(state);\n          if (state === 'unlocking') {\n            addAchievement(achievement);\n          }\n          if (state === 'unlocked') {\n            setIsUnlocked(true);\n            unlockPort.disconnect();\n            cancelWebauthnRef.current?.();\n          } else {\n            setIsUnlocked(false);\n          }\n          if (state === 'error') {\n            cancelWebauthnRef.current?.();\n          }\n          onStateChange?.(state);\n        } else if (message.type === 'TriggerWebauthnUnlock') {\n          cancelWebauthnRef.current?.();\n          const webauthnIframe = document.createElement('iframe');\n          Object.assign(webauthnIframe.style, {\n            position: 'absolute',\n            top: '-99px',\n            left: '-999px',\n            width: 0,\n            height: 0,\n            border: 'none',\n          });\n          const webauthnUnlockId = newUuid();\n          webauthnIframe.allow = 'publickey-credentials-get *';\n          // This opens a blank page, which we use to perform webauthn, see WebauthnUnlockConnector\n          webauthnIframe.src = `${getFrontendServerUrl()}/blank.html?webauthnUnlockId=${webauthnUnlockId}`;\n          webauthnIframe.addEventListener('load', () => {\n            unlockPort.postMessage({ type: 'WebauthnUnlockIframeSetUp', webauthnUnlockId });\n          });\n          document.documentElement.appendChild(webauthnIframe);\n          cancelWebauthnRef.current = () => webauthnIframe?.remove();\n        } else if (message.type === 'WebauthnOnlyUnlockSkipped') {\n          setIsUnlocked(false);\n          setUnlockState(undefined);\n          setWebauthnOnlyUnlockSkipped(true);\n        } else {\n          assertExhaustive(message);\n        }\n      }\n\n      unlockPort.onMessage.addListener(onMessage);\n      unlockPort.onDisconnect.addListener(onDisconnect);\n\n      // Delay the initial message. Without this delay, it is never received in safari, probably\n      // because the port has not yet been set up on the receiver's side.\n      window.setTimeout(() => {\n        unlockPort.postMessage(initialMessage);\n      }, 100);\n    },\n    [achievement],\n  );\n\n  const performLogin = useCallback(\n    (loginId: LoginId, options?: { confirmLogin?: boolean }) => {\n      triggerUnlock({\n        type: 'RequestFormFill',\n        loginId,\n        confirmLogin: options?.confirmLogin,\n        skipWebauthnUnlock,\n      });\n    },\n    [skipWebauthnUnlock, triggerUnlock],\n  );\n\n  const requestUnlock = useCallback(() => {\n    triggerUnlock({ type: 'RequestUnlock', skipWebauthnUnlock }, (state) => {\n      if (state === 'unlocked') {\n        setUnlockState(undefined);\n      }\n    });\n  }, [skipWebauthnUnlock, triggerUnlock]);\n\n  const addTotpParametersToLogin = useCallback(\n    (loginId: LoginId, vaultId: VaultId, totpParameters: TotpParameters) => {\n      triggerUnlock({\n        type: 'AddTotpParametersToLogin',\n        loginId,\n        vaultId,\n        totpParameters,\n        skipWebauthnUnlock,\n      });\n    },\n    [skipWebauthnUnlock, triggerUnlock],\n  );\n\n  const cancelLogin = useCallback(() => {\n    setUnlockState(undefined);\n    disconnectPortRef.current?.();\n  }, [setUnlockState]);\n\n  // listen for unlock state changes\n  useEffect(() => {\n    const messageListener = makeMessageListener({\n      UnlockStateUpdate: (msg) => setIsUnlocked(msg.isUnlocked),\n    });\n\n    browser.runtime.onMessage.addListener(messageListener);\n    return () => browser.runtime.onMessage.removeListener(messageListener);\n  }, []);\n\n  // unlock on initial render\n  const initialRenderRef = useRef(true);\n  useEffect(() => {\n    if (unlockOnInitialRender && initialRenderRef.current) {\n      requestUnlock();\n    }\n    initialRenderRef.current = false;\n  }, [requestUnlock, unlockOnInitialRender]);\n\n  // get unlock device type\n  useEffect(() => {\n    if (unlockDeviceType) {\n      return;\n    }\n    (async () => {\n      const result = await sendMessage({ type: 'GetUnlockDeviceType' });\n      if (result !== messageError) {\n        setUnlockDeviceType((udt) => udt ?? result);\n      }\n    })().catch(trackError);\n  }, [unlockDeviceType]);\n\n  return {\n    unlockState,\n    isUnlocked,\n    pushState: unlockState ? unlockStateToPushState(unlockState) : null,\n    // populate a reasonable default here in case the unlock happens before the request can go\n    // through\n    unlockDeviceType: unlockDeviceType ?? 'phone',\n    performLogin,\n    cancelLogin,\n    requestUnlock,\n    addTotpParametersToLogin,\n    webauthnOnlyUnlockSkipped,\n  };\n}\n\nfunction unlockStateToPushState(state: UnlockState): PushStateType {\n  if (state === 'unlocking') {\n    return 'connecting';\n  }\n  if (state === 'unlocked') {\n    return 'confirmed';\n  }\n  if (state === 'warning') {\n    return 'warning';\n  }\n  return 'error';\n}\n"],"names":["addAchievement","achievements","type","catch","trackError","copyToClipboard","value","window","ClipboardItem","navigator","clipboard","write","filteredValue","then","v","text","undefined","writeText","e","fallbackCopyTextToClipboard","textArea","document","createElement","style","top","left","position","body","appendChild","focus","select","successful","execCommand","Error","removeChild","copyToClipboardWithClear","clearAfterTimeout","copiedText","getUnprotectedValueForContentLogin","l","getUnprotectedValueForContentLoginWithContentId","unencrypted","vaultMetadata","getUnprotectedValueForVaultWithContentId","id","vaultId","response","sendMessage","messageError","useCopyToClipboard","copied","setCopied","useState","resetCopiedTimerRef","useRef","copy","useCallback","clearTimeout","current","setTimeout","openConnection","name","connectionId","portName","makePortName","port","retries","browser","runtime","connect","isWebExtError","useUnlock","unlockOnInitialRender","achievement","skipWebauthnUnlock","isUnlocked","setIsUnlocked","unlockState","setUnlockState","webauthnOnlyUnlockSkipped","setWebauthnOnlyUnlockSkipped","unlockDeviceType","setUnlockDeviceType","disconnectPortRef","cancelWebauthnRef","triggerUnlock","initialMessage","onStateChange","unlockPort","disconnect","onDisconnect","onMessage","removeListener","message","debugConsole","log","state","webauthnIframe","assign","width","height","border","webauthnUnlockId","newUuid","allow","src","getFrontendServerUrl","addEventListener","postMessage","documentElement","remove","assertExhaustive","addListener","performLogin","loginId","options","confirmLogin","requestUnlock","addTotpParametersToLogin","totpParameters","cancelLogin","useEffect","messageListener","makeMessageListener","UnlockStateUpdate","msg","initialRenderRef","result","udt","pushState","unlockStateToPushState"],"mappings":";;AACO,SAAS,gBAAgB,OAAO,cAAc;AACjD,SAAO,eAAe,YAAY,EAAE,MAAM,CAAC,SAAS,oBAAoB,OAAO,IAAI,CAAC;AACxF;AAEA,SAAS,oBAAoB,OAAO,YAAY;AAC5C,MAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AACxB,SAAQ,MAAM,MAAM,YAAW,EAAG,SAAS,UAAU,KACjD,MAAM,SAAS,cAAc,SAAS,UAAU,KAChD,MAAM,KAAK,cAAc,SAAS,UAAU,OAC1C,KAAK,MAAM,gBAAgB,QAAQ,OAAO,SAAS,SAAS,GAAG,WAAW,YAAa,EAAC,SAAS,UAAU,QAC3G,KAAK,MAAM,gBAAgB,QAAQ,OAAO,SAAS,SAAS,GAAG,YAAY,YAAa,EAAC,SAAS,UAAU;AAAA;AAAA,IAI7G,KAAK,MAAM,gBAAgB,QAAQ,OAAO,SAAS,SAAS,GAAG,OAAO,QAAQ,MAAM,EAAE,EAAE,cAAc,SAAS,UAAU,QACxH,KAAK,MAAM,cAAc,QAAQ,OAAO,SAAS,SAAS,GAAG,YAAa,EAAC,SAAS,UAAU,MAChG,MAAM,aACD,OAAO,CAAC,OAAO,CAAC,GAAG,SAAS,EAC5B,KAAK,CAAC,OAAO,GAAG,MAAM,cAAc,SAAS,UAAU,CAAC,KAC7D,2BAA2B,OAAO,UAAU,OAC1C,KAAK,MAAM,iBAAiB,QAAQ,OAAO,SAAS,SAAS,GAAG,KAAK,CAAC,MAAM,EAAE,YAAY,YAAW,EAAG,SAAS,UAAU,CAAC,QAC5H,KAAK,MAAM,UAAU,QAAQ,OAAO,SAAS,SAAS,GAAG,KAAK,CAAC,MAAM,EAAE,YAAa,EAAC,SAAS,UAAU,CAAC;AACnH;AACA,SAAS,2BAA2B,EAAE,SAAU,GAAE,YAAY;AAC1D,QAAM,QAAQ,cAAc,KAAK,UAAU;AAC3C,QAAM,qBAAqB,QAAQ,MAAM,CAAC,IAAI;AAC9C,MAAI,SAAS,KAAK,CAAC,MAAM,EAAE,cAAc,SAAS,kBAAkB,CAAC,GAAG;AACpE,WAAO;AAAA,EACV;AACD,SAAO,6BAA6B,QAAQ,EAAE,KAAK,CAAC,MAAM,EAAE,SAAS,kBAAkB,CAAC;AAC5F;AACO,SAAS,eAAe,cAAc;AACzC,SAAO,aACF,YAAa,EACb,KAAM,EACN,MAAM,KAAK,EACX,IAAI,CAAC,SAAS;AACf,QAAI,KAAK,WAAW,GAAG,GAAG;AAItB,aAAO,KAAK,QAAQ,OAAO,EAAE;AAAA,IAChC,OACI;AACD,aAAO;AAAA,IACV;AAAA,EACT,CAAK;AACL;AACO,SAAS,0BAA0B,GAAG,GAAG;AAC5C,MAAI,IAAI;AACR,QAAM,SAAS,KAAK,EAAE,gBAAgB,QAAQ,OAAO,SAAS,KAAK,EAAE;AACrE,QAAM,SAAS,KAAK,EAAE,gBAAgB,QAAQ,OAAO,SAAS,KAAK,EAAE;AACrE,SAAO,MAAM,cAAc,KAAK;AACpC;AACO,SAAS,aAAa,QAAQ,cAAc;AAC/C,QAAM,WAAW,CAAC,eACZ,CAAC,GAAG,MAAM,IACV,OAAO,OAAO,CAAC,MAAM,gBAAgB,GAAG,YAAY,CAAC;AAC3D,WAAS,KAAK,yBAAyB;AACvC,SAAO;AACX;AA4BO,SAAS,6BAA6B,UAAU;AACnD,QAAM,UAAU,SAAS,QAAQ,CAAC,YAAY;AAC1C,QAAI;AACA,aAAO,IAAI,IAAI,WAAW,OAAO,EAAE,EAAE;AAAA,IACxC,SACM,GAAG;AACN,aAAO;IACV;AAAA,EACT,CAAK;AAID,QAAM,8BAA8B,QAAQ,QAAQ,CAAC,aAAa;AAC9D,UAAM,gBAAgB,SAAS,MAAM,GAAG,EAAE,QAAO;AACjD,UAAM,SAAS,CAAA;AAEf,QAAI,CAAC,SAAS,GAAG,IAAI,IAAI;AACzB,eAAW,QAAQ,MAAM;AACrB,gBAAU,GAAG,IAAI,IAAI,OAAO;AAC5B,aAAO,KAAK,OAAO;AAAA,IACtB;AACD,WAAO;AAAA,EACf,CAAK;AAGD,SAAO,4BAA4B,QAAQ,CAAC,WAAW;AAAE,QAAI;AAAI,YAAQ,KAAK,kBAAkB,MAAM,OAAO,QAAQ,OAAO,SAAS,KAAK,CAAA;AAAA,EAAG,CAAE;AACnJ;ACjGA,SAAS,SAAU,OAAO,YAAY,UAAU,cAAc;AAM5D,MAAI;AACJ,MAAI,YAAY;AAEhB,MAAI,WAAW;AAEf,WAAS,uBAAuB;AAC9B,QAAI,WAAW;AACb,mBAAa,SAAS;AAAA,IACvB;AAAA,EACF;AAGD,WAAS,SAAS;AAChB;AACA,gBAAY;AAAA,EACb;AAGD,MAAI,OAAO,eAAe,WAAW;AACnC,mBAAe;AACf,eAAW;AACX,iBAAa;AAAA,EACd;AAQD,WAAS,UAAU;AACjB,aAAS,OAAO,UAAU,QAAQ,aAAa,IAAI,MAAM,IAAI,GAAG,OAAO,GAAG,OAAO,MAAM,QAAQ;AAC7F,iBAAW,IAAI,IAAI,UAAU,IAAI;AAAA,IAClC;AAED,QAAI,OAAO;AACX,QAAI,UAAU,KAAK,IAAG,IAAK;AAE3B,QAAI,WAAW;AACb;AAAA,IACD;AAGD,aAAS,OAAO;AACd,iBAAW,KAAK;AAChB,eAAS,MAAM,MAAM,UAAU;AAAA,IAChC;AAOD,aAAS,QAAQ;AACf,kBAAY;AAAA,IACb;AAED,QAAI,gBAAgB,CAAC,WAAW;AAK9B;IACD;AAED;AAEA,QAAI,iBAAiB,UAAa,UAAU,OAAO;AAKjD;IACN,WAAe,eAAe,MAAM;AAY9B,kBAAY,WAAW,eAAe,QAAQ,MAAM,iBAAiB,SAAY,QAAQ,UAAU,KAAK;AAAA,IACzG;AAAA,EACF;AAED,UAAQ,SAAS;AAEjB,SAAO;AACT;AAkBA,SAAS,SAAU,OAAO,SAAS,UAAU;AAC3C,SAAO,aAAa,SAAY,SAAS,OAAO,SAAS,KAAK,IAAI,SAAS,OAAO,UAAU,YAAY,KAAK;AAC/G;ACpIA,SAAwBA,kBAAkBC,cAA6B;AACzD,cAAA;AAAA,IACVC,MAAM;AAAA,IACND;AAAAA,EAAAA,CACD,EAAEE,MAAMC,UAAU;AACrB;ACmBA,eAA8BC,gBAAgBC,OAA6C;AACrF,MAAA;AAGF,QAAIC,OAAOC,iBAAiBC,UAAUC,UAAUC,OAAO;AAC/CC,YAAAA,gBAAgB,OAAON,UAAU,WAAWA,QAAQA,MAAMO,KAAMC,CAAMA,MAAAA,KAAK,EAAE;AAC7EC,YAAAA,OAAO,IAAIP,cAAc;AAAA,QAC7B,cAAcI;AAAAA,MAAAA,CACf;AACD,YAAMH,UAAUC,UAAUC,MAAM,CAACI,IAAI,CAAC;AACtC,aAAO,MAAMH;AAAAA,IAAAA,OACR;AAGL,YAAMG,OAAO,MAAMT;AACnB,UAAIS,SAASC,QAAW;AAChBP,cAAAA,UAAUC,UAAUO,UAAUF,IAAI;AAAA,MAC1C;AACOA,aAAAA;AAAAA,IACT;AAAA,WACOG,GAAG;AAIV,UAAMH,OAAO,MAAMT;AACnB,QAAIS,SAASC,QAAW;AACtBG,kCAA4BJ,IAAI;AAAA,IAClC;AACOA,WAAAA;AAAAA,EACT;AACF;AAEA,SAASI,4BAA4BJ,MAAc;AAC3CK,QAAAA,WAAWC,SAASC,cAAc,UAAU;AAClDF,WAASd,QAAQS;AAGjBK,WAASG,MAAMC,MAAM;AACrBJ,WAASG,MAAME,OAAO;AACtBL,WAASG,MAAMG,WAAW;AAEjBC,WAAAA,KAAKC,YAAYR,QAAQ;AAClCA,WAASS,MAAM;AACfT,WAASU,OAAO;AAEZ,MAAA;AACIC,UAAAA,aAAaV,SAASW,YAAY,MAAM;AAC9C,QAAI,CAACD,YAAY;AACT,YAAA,IAAIE,MAAM,iBAAiB;AAAA,IACnC;AAAA,EAAA,UACQ;AACCN,aAAAA,KAAKO,YAAYd,QAAQ;AAAA,EACpC;AACF;AAEsBe,eAAAA,yBACpB7B,OACA8B,mBAC6B;AAIvBC,QAAAA,aAAa,MAAMhC,gBAAgBC,KAAK;AAC9C,MAAI+B,eAAerB,QAAW;AAC5B;AAAA,EACF;AACY,cAAA;AAAA,IACVd,MAAM;AAAA,IACNkC,mBAAmB,CAAC,CAACA;AAAAA,IACrB9B,OAAO+B;AAAAA,EAAAA,CACR,EAAElC,MAAMC,UAAU;AACZiC,SAAAA;AACT;AC9F8BC,eAAAA,mCAC5BC,GACAjC,OAC6B;;AAC7B,UAAQ,WAAMkC,gDAAgDD,GAAGjC,KAAK,MAA9D,mBAAkEmC;AAC5E;AAEsBD,eAAAA,gDACpBD,GACAjC,OACuC;AACnC,MAAA,CAACiC,EAAEG,eAAe;AACb1B,WAAAA;AAAAA,EACT;AACA,SAAO2B,yCAAyCJ,EAAEG,cAAcE,IAAItC,KAAK;AAC3E;AASsBqC,eAAAA,yCACpBE,SACAvC,OACuC;AACvC,MAAI,iBAAiBA,OAAO;AACnBA,WAAAA;AAAAA,EACT;AACMwC,QAAAA,WAAW,MAAMC,YAAY;AAAA,IACjC7C,MAAM;AAAA,IACN2C;AAAAA,IACAvC;AAAAA,EAAAA,CACD;AACD,MAAIwC,aAAaE,cAAc;AACtBhC,WAAAA;AAAAA,EACT;AACO8B,SAAAA;AACT;AC1CA,SAAwBG,mBACtBd,2BAIA;AACA,QAAM,CAACe,QAAQC,SAAS,IAAIC,sBAAS,KAAK;AAC1C,QAAMC,sBAAsBC,aAAAA;AAE5B,QAAMC,OAAOC,aAAAA,YACX,CAAClD,OAA6C8B,sBAAgC;AAC5E,KAAC,YAAY;AAIX,YAAMC,aAAa,MAAMF,0BAAyB7B,OAAO8B,iBAAiB;AAC1E,UAAI,CAACC,YAAY;AACf;AAAA,MACF;AAEAc,gBAAU,IAAI;AACPM,aAAAA,aAAaJ,oBAAoBK,OAAO;AAC3BA,0BAAAA,UAAUnD,OAAOoD,WAAW,MAAM;AACpDR,kBAAU,KAAK;AAAA,SACd,GAAI;AAAA,IAAA,KACJhD,MAAMC,UAAU;AAAA,EAAA,GAEvB,CAAC+B,yBAAwB,CAC3B;AAEO,SAAA,CAACe,QAAQK,IAAI;AACtB;ACEgBK,SAAAA,eACdC,MACAC,cACe;AACTC,QAAAA,WAAWC,aAAaH,MAAMC,YAAY;AAE5CG,MAAAA;AAMJ,MAAIC,UAAU;AACP,SAAA,CAACD,QAAQC,UAAU,GAAG;AACvB,QAAA;AACKC,aAAAA,QAAQC,QAAQC,QAAQrD,QAAW;AAAA,QACxC6C,MAAME;AAAAA,MAAAA,CACP;AAAA,aACM7C,GAAG;AACV,UAAI,CAACoD,cAAcpD,GAAG,kBAAkB,GAAG;AACnCA,cAAAA;AAAAA,MACR;AAAA,IACF;AACAgD;AAAAA,EACF;AAEA,MAAI,CAACD,MAAM;AACH,UAAA,IAAIhC,MAAM,yCAAyC;AAAA,EAC3D;AAEOgC,SAAAA;AACT;AAwBA,SAASD,aAAaH,MAAcC,cAAkC;AACpE,MAAI,CAACA,cAAc;AACVD,WAAAA;AAAAA,EACT;AACQ,SAAA,GAAEA,IAAK,IAAGC,YAAa;AACjC;ACxEA,SAAwBS,UAAU;AAAA,EAChCC;AAAAA,EACAC;AAAAA,EACAC;AAKF,GAAG;AACD,QAAM,CAACC,YAAYC,aAAa,IAAIxB,aAAkB,SAAA;AAChD,QAAA,CAACyB,aAAaC,cAAc,IAAI1B,sBACpCoB,yBAAyB,CAACE,qBAAqB,cAAc1D,MAC/D;AACA,QAAM,CAAC+D,2BAA2BC,4BAA4B,IAAI5B,sBAAS,KAAK;AAChF,QAAM,CAAC6B,kBAAkBC,mBAAmB,IAAI9B,aAA2B,SAAA;AAE3E,QAAM+B,oBAAoB7B,aAAAA;AAC1B,QAAM8B,oBAAoB9B,aAAAA;AAE1B,QAAM+B,gBAAgB7B,aAAAA,YACpB,CAAC8B,gBAAqCC,kBAAiD;AAC/EC,UAAAA,aAAa5B,eAA2C,QAAQ;AAEtEuB,sBAAkBzB,UAAU,MAAM;AAChC8B,iBAAWC,WAAW;AAAA,IAAA;AAGxB,aAASC,eAAe;AACXC,iBAAAA,UAAUC,eAAeD,SAAS;AAClCD,iBAAAA,aAAaE,eAAeF,YAAY;AAAA,IACrD;AAEA,aAASC,UAAUE,SAAkC;;AAC/CA,UAAAA,QAAQ3F,SAAS,eAAe;AAClC4F,qBAAaC,IAAIF,OAAO;AAClB,cAAA;AAAA,UAAEG;AAAAA,QAAUH,IAAAA;AAClBf,uBAAekB,KAAK;AACpB,YAAIA,UAAU,aAAa;AACzBhG,yBAAeyE,WAAW;AAAA,QAC5B;AACA,YAAIuB,UAAU,YAAY;AACxBpB,wBAAc,IAAI;AAClBY,qBAAWC,WAAW;AACtBL,kCAAkB1B,YAAlB0B;AAAAA,QAA4B,OACvB;AACLR,wBAAc,KAAK;AAAA,QACrB;AACA,YAAIoB,UAAU,SAAS;AACrBZ,kCAAkB1B,YAAlB0B;AAAAA,QACF;AACAG,uDAAgBS;AAAAA,MAAK,WACZH,QAAQ3F,SAAS,yBAAyB;AACnDkF,gCAAkB1B,YAAlB0B;AACMa,cAAAA,iBAAiB5E,SAASC,cAAc,QAAQ;AAC/C4E,eAAAA,OAAOD,eAAe1E,OAAO;AAAA,UAClCG,UAAU;AAAA,UACVF,KAAK;AAAA,UACLC,MAAM;AAAA,UACN0E,OAAO;AAAA,UACPC,QAAQ;AAAA,UACRC,QAAQ;AAAA,QAAA,CACT;AACD,cAAMC,mBAAmBC;AACzBN,uBAAeO,QAAQ;AAEvBP,uBAAeQ,MAAO,GAAEC,qBAAuB,CAAA,gCAA+BJ,gBAAiB;AAChFK,uBAAAA,iBAAiB,QAAQ,MAAM;AAC5CnB,qBAAWoB,YAAY;AAAA,YAAE1G,MAAM;AAAA,YAA6BoG;AAAAA,UAAAA,CAAkB;AAAA,QAAA,CAC/E;AACQO,iBAAAA,gBAAgBjF,YAAYqE,cAAc;AACjCvC,0BAAAA,UAAU,MAAMuC,iDAAgBa;AAAAA,MAAO,WAChDjB,QAAQ3F,SAAS,6BAA6B;AACvD0E,sBAAc,KAAK;AACnBE,uBAAe9D,MAAS;AACxBgE,qCAA6B,IAAI;AAAA,MAAA,OAC5B;AACL+B,yBAAwB;AAAA,MAC1B;AAAA,IACF;AAEWpB,eAAAA,UAAUqB,YAAYrB,SAAS;AAC/BD,eAAAA,aAAasB,YAAYtB,YAAY;AAIhDnF,WAAOoD,WAAW,MAAM;AACtB6B,iBAAWoB,YAAYtB,cAAc;AAAA,OACpC,GAAG;AAAA,EAAA,GAER,CAACb,WAAW,CACd;AAEA,QAAMwC,eAAezD,aAAAA,YACnB,CAAC0D,SAAkBC,YAAyC;AAC5C,kBAAA;AAAA,MACZjH,MAAM;AAAA,MACNgH;AAAAA,MACAE,cAAcD,mCAASC;AAAAA,MACvB1C;AAAAA,IAAAA,CACD;AAAA,EAAA,GAEH,CAACA,oBAAoBW,aAAa,CACpC;AAEMgC,QAAAA,gBAAgB7D,aAAAA,YAAY,MAAM;AACxB,kBAAA;AAAA,MAAEtD,MAAM;AAAA,MAAiBwE;AAAAA,OAAuBsB,CAAU,UAAA;AACtE,UAAIA,UAAU,YAAY;AACxBlB,uBAAe9D,MAAS;AAAA,MAC1B;AAAA,IAAA,CACD;AAAA,EAAA,GACA,CAAC0D,oBAAoBW,aAAa,CAAC;AAEtC,QAAMiC,2BAA2B9D,aAAAA,YAC/B,CAAC0D,SAAkBrE,SAAkB0E,mBAAmC;AACxD,kBAAA;AAAA,MACZrH,MAAM;AAAA,MACNgH;AAAAA,MACArE;AAAAA,MACA0E;AAAAA,MACA7C;AAAAA,IAAAA,CACD;AAAA,EAAA,GAEH,CAACA,oBAAoBW,aAAa,CACpC;AAEMmC,QAAAA,cAAchE,aAAAA,YAAY,MAAM;;AACpCsB,mBAAe9D,MAAS;AACxBmE,4BAAkBzB,YAAlByB;AAAAA,EAA4B,GAC3B,CAACL,cAAc,CAAC;AAGnB2C,eAAAA,UAAU,MAAM;AACd,UAAMC,kBAAkBC,oBAAoB;AAAA,MAC1CC,mBAAoBC,CAAAA,QAAQjD,cAAciD,IAAIlD,UAAU;AAAA,IAAA,CACzD;AAEOP,YAAAA,QAAQuB,UAAUqB,YAAYU,eAAe;AACrD,WAAO,MAAMvD,QAAQC,QAAQuB,UAAUC,eAAe8B,eAAe;AAAA,EACvE,GAAG,CAAE,CAAA;AAGCI,QAAAA,mBAAmBxE,oBAAO,IAAI;AACpCmE,eAAAA,UAAU,MAAM;AACVjD,QAAAA,yBAAyBsD,iBAAiBpE,SAAS;AACvC;IAChB;AACAoE,qBAAiBpE,UAAU;AAAA,EAAA,GAC1B,CAAC2D,eAAe7C,qBAAqB,CAAC;AAGzCiD,eAAAA,UAAU,MAAM;AACd,QAAIxC,kBAAkB;AACpB;AAAA,IACF;AACA,KAAC,YAAY;AACL8C,YAAAA,SAAS,MAAMhF,YAAY;AAAA,QAAE7C,MAAM;AAAA,MAAA,CAAuB;AAChE,UAAI6H,WAAW/E,cAAc;AACNgF,4BAAAA,CAAAA,QAAQA,OAAOD,MAAM;AAAA,MAC5C;AAAA,IAAA,KACG5H,MAAMC,UAAU;AAAA,EAAA,GACpB,CAAC6E,gBAAgB,CAAC;AAEd,SAAA;AAAA,IACLJ;AAAAA,IACAF;AAAAA,IACAsD,WAAWpD,cAAcqD,uBAAuBrD,WAAW,IAAI;AAAA;AAAA;AAAA,IAG/DI,kBAAkBA,oBAAoB;AAAA,IACtCgC;AAAAA,IACAO;AAAAA,IACAH;AAAAA,IACAC;AAAAA,IACAvC;AAAAA,EAAAA;AAEJ;AAEA,SAASmD,uBAAuBlC,OAAmC;AACjE,MAAIA,UAAU,aAAa;AAClB,WAAA;AAAA,EACT;AACA,MAAIA,UAAU,YAAY;AACjB,WAAA;AAAA,EACT;AACA,MAAIA,UAAU,WAAW;AAChB,WAAA;AAAA,EACT;AACO,SAAA;AACT;","x_google_ignoreList":[1]}