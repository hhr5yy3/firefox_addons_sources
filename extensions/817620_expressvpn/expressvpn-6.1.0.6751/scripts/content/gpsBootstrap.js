const eventName=Math.random().toString(36).substring(2)+crypto.getRandomValues(new Uint32Array(3)).join("");let shadowRoot,currentInfo,isLocationSpoofEnabled=!0,isScriptInjected=!1;function shouldInject(){return document instanceof HTMLDocument||document instanceof XMLDocument}function sendFirefoxEvent(){if("undefined"==typeof browser)return;const detail={coords:currentInfo.selectedLocation?.coords,fakeIt:["connected","connecting","disconnecting","reconnecting","connection_error"].includes(currentInfo.state)&&isLocationSpoofEnabled},event=new CustomEvent(eventName,{bubbles:!0,composed:!0,detail:JSON.stringify(detail)});shadowRoot?.dispatchEvent(event)}function inject_chrome(){let script=document.createElementNS("http://www.w3.org/1999/xhtml","script");script.src=chrome.runtime.getURL("/scripts/content/gps.js");let parent=document.head||document.body||document.documentElement,firstChild=parent.childNodes&&parent.childNodes.length>0?parent.childNodes[0]:null;firstChild?parent.insertBefore(script,firstChild):parent.appendChild(script),isScriptInjected=!0}function inject(){let shadowHost=document.createElement("div");shadowHost.style.display="none";let parent=document.head||document.body||document.documentElement,firstChild=parent.childNodes&&parent.childNodes.length>0?parent.childNodes[0]:null;firstChild?parent.insertBefore(shadowHost,firstChild):parent.appendChild(shadowHost),shadowRoot=shadowHost.attachShadow({mode:"closed"});let script=document.createElementNS("http://www.w3.org/1999/xhtml","script");script.appendChild(document.createTextNode("/* eslint-disable camelcase */\n/*\nExpressVPN Browser Extension:\nCopyright 2017-2023 Express VPN International Ltd\nLicensed GPL v2\n*/\n\n//<![CDATA[\nfunction hookGeo(eventName) {\n\t//<![CDATA[\n\tconst WAIT_TIME = 100;\n\tconst originalGetCurrentPosition = navigator.geolocation.getCurrentPosition.bind(navigator.geolocation);\n\tconst originalWatchPosition = navigator.geolocation.watchPosition.bind(navigator.geolocation);\n  const originalPermissionsQuery = navigator.permissions.query.bind(navigator.permissions);\n  const reloadHostnames = ['tv.youtube.com']; // Whitelist the hostnames that we should reload the page after granting geolocation permission\n\n  let fakeGeo = true;\n\tlet genLat = 38.883333;\n\tlet genLon = -77.000;\n  let geolocationPermissionPrompted = false;\n\n  function createFakePosition() {\n    return {\n      coords: {\n        latitude: genLat,\n        longitude: genLon,\n        accuracy: 10,\n        altitude: null,\n        altitudeAccuracy: null,\n        heading: null,\n        speed: null,\n      },\n      timestamp: new Date().getTime(),\n    };\n  }\n\n  /**\n   * If `geolocationPermissionPrompted` is true, we will invoke `originalGetCurrentPosition` to trigger the permission prompt.\n   * After which, we will invoke the spoofed `getCurrentPosition` to return the spoofed coordinates.\n   * Then, for certain host names, we will perform a reload to ensure the page is not in an erroneous state.\n   */\n  function getCurrentPosition() {\n    if (geolocationPermissionPrompted) {\n      originalGetCurrentPosition(() => {\n          geolocationPermissionPrompted = false;\n          geolocationProxy.tmp_successCallback(createFakePosition());\n          const shouldReload = reloadHostnames.includes(window.location.hostname);\n          if (shouldReload) {\n            window.location.reload();\n          }\n        },\n        geolocationProxy.tmp_errorCallback,\n        geolocationProxy.tmp_options\n      );\n    } else {\n      geolocationProxy.tmp_successCallback(createFakePosition());\n    }\n  }\n  \n  function waitGetCurrentPosition() {\n    if (typeof fakeGeo !== 'undefined') {\n      if (fakeGeo === true) {\n        getCurrentPosition();\n      } else {\n        originalGetCurrentPosition(\n          geolocationProxy.tmp_successCallback,\n          geolocationProxy.tmp_errorCallback,\n          geolocationProxy.tmp_options\n        );\n      }\n    } else {\n      setTimeout(waitGetCurrentPosition, WAIT_TIME);\n    }\n  }\n\n  function waitWatchPosition() {\n    if (typeof fakeGeo !== 'undefined') {\n      if (fakeGeo === true) {\n        geolocationProxy.tmp2_successCallback(createFakePosition());\n        return Math.floor(Math.random() * 10000); // random id\n      } else {\n        return originalWatchPosition(\n          geolocationProxy.tmp2_successCallback,\n          geolocationProxy.tmp2_errorCallback,\n          geolocationProxy.tmp2_options\n        );\n      }\n    } else {\n      setTimeout(waitWatchPosition, WAIT_TIME);\n    }\n  }\n\n  /**\n   * Executes a geolocation callback function in a sandboxed environment.\n   * This function is designed to prevent the callback from accessing or modifying\n   * the surrounding scope.\n   * \n   * The callback is converted to a string and then recreated as a new function.\n   * This process strips the original function of its closure and context,\n   * preventing it from accessing variables in the outer scope.\n   *\n   * @param {function(GeolocationPosition): void} callback - The original success callback\n   *  function. It should accept a GeolocationPosition object\n   *  as defined by the W3C Geolocation API specification.\n   * @param {GeolocationPosition} position - The position data (either fake or real) \n   *  to be passed to the callback. This object conforms to the GeolocationPosition\n   *  interface as defined in the W3C Geolocation API specification.\n   * \n   * @throws {Error} May throw an error if the callback execution fails.\n   * \n   * @see {@link https://www.w3.org/TR/geolocation-API/#position_interface|W3C Geolocation API}\n   */\n  function executeCallback(callback, position) {\n    const isolatedCallback = callback.toString();\n    try {\n      const safeCallback = new Function('position', `return (${isolatedCallback})(position);`);\n      safeCallback(position);\n    } catch (e) {\n      console.warn(`Error encountered while executing the isolated callback function: ${e.message}. Falling back to the original callback.`);\n      callback(position);\n    }\n  }\n\n  /**\n   * Override `navigator.permissions.query` to check if 'geolocation' is in 'prompt' state. \n   * If yes, we need to call the original `getCurrentPosition` to trigger the permission prompt.\n   */\n  navigator.permissions.query = async function (descriptor) {\n    const permission = await originalPermissionsQuery(descriptor);\n    geolocationPermissionPrompted = fakeGeo && descriptor.name === 'geolocation' && permission.state === 'prompt';\n    return permission;\n  };\n\n  const geolocationProxy = {\n    tmp_successCallback: null,\n    tmp_errorCallback: null,\n    tmp_options: null,\n    tmp2_successCallback: null,\n    tmp2_errorCallback: null,\n    tmp2_options: null,\n\n    getCurrentPosition(successCallback, errorCallback, options) {\n      this.tmp_successCallback = (position) => executeCallback(successCallback, position);\n      this.tmp_errorCallback = errorCallback;\n      this.tmp_options = options;\n      waitGetCurrentPosition();\n    },\n\n    watchPosition(successCallback, errorCallback, options) {\n      this.tmp2_successCallback = (position) => executeCallback(successCallback, position);\n      this.tmp2_errorCallback = errorCallback;\n      this.tmp2_options = options;\n      return waitWatchPosition();\n    }\n  };\n\n  /**\n   * Replaces the native geolocation object with a proxy to enable location spoofing.\n   * This method redefines the 'geolocation' property on the navigator object,\n   * replacing it with our custom proxy object that intercepts geolocation requests.\n   */\n  Object.defineProperty(navigator, 'geolocation', {\n    value: geolocationProxy,\n    configurable: false,\n    writable: false,\n  });\n\n\tconst instantiate = (constructor, args) => {\n\t\tconst bind = Function.bind;\n\t\tconst unbind = bind.bind(bind);\n\t\treturn new (unbind(constructor, null).apply(null, args));\n\t}\n\n\tBlob = function (_Blob) {\n\t\tfunction secureBlob(...args) {\n\t\t\tconst injectableMimeTypes = [\n\t\t\t\t{ mime: 'text/html', useXMLparser: false },\n\t\t\t\t{ mime: 'application/xhtml+xml', useXMLparser: true },\n\t\t\t\t{ mime: 'text/xml', useXMLparser: true },\n\t\t\t\t{ mime: 'application/xml', useXMLparser: true },\n\t\t\t\t{ mime: 'image/svg+xml', useXMLparser: true },\n\t\t\t];\n\t\t\tlet typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));\n\n\t\t\tif (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {\n\t\t\t\tconst mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());\n\t\t\t\tif (mimeTypeIndex >= 0) {\n\t\t\t\t\tlet mimeType = injectableMimeTypes[mimeTypeIndex];\n\t\t\n\t\t\n\t\t\t\t\tlet parser = new DOMParser();\n\t\t\t\t\tlet xmlDoc;\n\t\t\t\t\tif (mimeType.useXMLparser === true) {\n\t\t\t\t\t\txmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); // For XML documents we need to merge all items in order to not break the header when injecting\n\t\t\t\t\t} else {\n\t\t\t\t\t\txmlDoc = parser.parseFromString(args[0][0], mimeType.mime);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (xmlDoc.getElementsByTagName('parsererror').length === 0) { // if no errors were found while parsing...\n\t\t\t\t\t\tif (typeEl.type === 'image/svg+xml') {\n\t\t\t\t\t\t  const scriptElem = xmlDoc.createElementNS('http://www.w3.org/2000/svg', 'script');\n\t\t\t\t\t\t  scriptElem.setAttributeNS(null, 'type', 'application/ecmascript');\n\t\t\t\t\t\t  scriptElem.innerHTML = `(${hookGeo})();`;\n\t\t\t\t\t\t  xmlDoc.documentElement.insertBefore(scriptElem, xmlDoc.documentElement.firstChild);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t  const injectedCode = `\n\t\t\t\t\t\t\t\t<script>(\n\t\t\t\t\t\t\t\t\t${hookGeo}\n\t\t\t\t\t\t\t\t)();\n\t\t\t\t\t\t\t\t<\\/script>\n\t\t\t\t\t\t\t`;\n\t\t\t\t\t\t  xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\tif (mimeType.useXMLparser === true) {\n\t\t\t\t\t\t\targs[0] = [new XMLSerializer().serializeToString(xmlDoc)];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs[0][0] = xmlDoc.documentElement.outerHTML;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn instantiate(_Blob, args); // arguments?\n\t\t}\n\n\t\t// Copy props and methods\n\t\tlet propNames = Object.getOwnPropertyNames(_Blob);\n\t\tfor (let i = 0; i < propNames.length; i++) {\n\t\t\tlet propName = propNames[i];\n\t\t\tif (propName in secureBlob) {\n\t\t\t\tcontinue; // Skip already existing props\n\t\t\t}\n\t\t\tlet desc = Object.getOwnPropertyDescriptor(_Blob, propName);\n\t\t\tObject.defineProperty(secureBlob, propName, desc);\n\t\t}\n\n\t\tsecureBlob.prototype = _Blob.prototype;\n\t\treturn secureBlob;\n\t}(Blob);\n\n\tfunction updateHookedObj(response) {\n\t\tif ((typeof response === 'object') && (typeof response.coords === 'object')) {\n\t\t\tgenLat = response.coords.lat;\n\t\t\tgenLon = response.coords.lon;\n\t\t\tfakeGeo = response.fakeIt;\n\t\t}\n\t}\n\n\tif (typeof chrome !== 'undefined') {\n\t\t// https://developer.chrome.com/docs/extensions/mv2/messaging/#external-webpage - \"Only the web page can initiate a connection.\", as such we need to query the background at a frequent interval\n\t\t// No hit in performance or memory usage according to our tests\n\t\tsetInterval(() => {\n\t\t\tchrome.runtime.sendMessage(__EXTENSION_ID__, { GET_LOCATION_SPOOFING_SETTINGS: true }, (response) => {\n\t\t\t\tupdateHookedObj(response);\n\t\t\t});\n\t\t}, 500);\n\t} else if (typeof eventName !== 'undefined') {\n\t\tdocument.addEventListener(eventName, function(event) {\n\t\t\ttry {\n\t\t\t\tconst response = JSON.parse(event.detail);\n\t\t\t\tupdateHookedObj(response);\n\t\t\t} catch (ex) {\n\t\t\t\t// noop\n\t\t\t}\t\t\t\n\t\t});\n\t}\n\t//]]>\n}\n\nhookGeo();\n".replace("hookGeo();",`hookGeo('${eventName}');`))),shadowRoot.appendChild(script),sendFirefoxEvent(),isScriptInjected=!0}chrome.storage.local.get(["currentInfo","prefs"],(function(storage){isLocationSpoofEnabled=storage.prefs.hideLocation,currentInfo=storage.currentInfo,shouldInject()&&!0===isLocationSpoofEnabled&&inject()})),chrome.storage.onChanged.addListener((changes=>{changes?.prefs?.newValue&&(isLocationSpoofEnabled=changes?.prefs?.newValue?.hideLocation),changes?.currentInfo?.newValue&&(currentInfo=changes?.currentInfo?.newValue),!0!==changes?.prefs?.newValue?.hideLocation||isScriptInjected||inject(),isScriptInjected&&sendFirefoxEvent()}));