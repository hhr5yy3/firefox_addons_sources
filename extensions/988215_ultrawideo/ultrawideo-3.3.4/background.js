var background=function(){"use strict";var ee,te,ae,re;function oe(r){return r==null||typeof r=="function"?{main:r}:r}const g=((te=(ee=globalThis.browser)==null?void 0:ee.runtime)==null?void 0:te.id)==null?globalThis.chrome:globalThis.browser;var J=Object.prototype.hasOwnProperty;function D(r,e){var t,s;if(r===e)return!0;if(r&&e&&(t=r.constructor)===e.constructor){if(t===Date)return r.getTime()===e.getTime();if(t===RegExp)return r.toString()===e.toString();if(t===Array){if((s=r.length)===e.length)for(;s--&&D(r[s],e[s]););return s===-1}if(!t||typeof r=="object"){s=0;for(t in r)if(J.call(r,t)&&++s&&!J.call(e,t)||!(t in e)||!D(r[t],e[t]))return!1;return Object.keys(e).length===s}}return r!==r&&e!==e}const ce=new Error("request for lock canceled");var le=function(r,e,t,s){function d(u){return u instanceof t?u:new t(function(h){h(u)})}return new(t||(t=Promise))(function(u,h){function v(y){try{V(s.next(y))}catch(k){h(k)}}function $(y){try{V(s.throw(y))}catch(k){h(k)}}function V(y){y.done?u(y.value):d(y.value).then(v,$)}V((s=s.apply(r,e||[])).next())})};class ue{constructor(e,t=ce){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((s,d)=>{const u={resolve:s,reject:d,weight:e,priority:t},h=H(this._queue,v=>t<=v.priority);h===-1&&e<=this._value?this._dispatchItem(u):this._queue.splice(h+1,0,u)})}runExclusive(e){return le(this,arguments,void 0,function*(t,s=1,d=0){const[u,h]=yield this.acquire(s,d);try{return yield t(u)}finally{h()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(s=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),de(this._weightedWaiters[e-1],{resolve:s,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(s=>s.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const s=this._weightedWaiters[t-1];if(!s)continue;const d=s.findIndex(u=>u.priority<=e);(d===-1?s:s.splice(0,d)).forEach(u=>u.resolve())}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function de(r,e){const t=H(r,s=>e.priority<=s.priority);r.splice(t+1,0,e)}function H(r,e){for(let t=r.length-1;t>=0;t--)if(e(r[t]))return t;return-1}var he=function(r,e,t,s){function d(u){return u instanceof t?u:new t(function(h){h(u)})}return new(t||(t=Promise))(function(u,h){function v(y){try{V(s.next(y))}catch(k){h(k)}}function $(y){try{V(s.throw(y))}catch(k){h(k)}}function V(y){y.done?u(y.value):d(y.value).then(v,$)}V((s=s.apply(r,e||[])).next())})};class me{constructor(e){this._semaphore=new ue(1,e)}acquire(){return he(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const L=((re=(ae=globalThis.browser)==null?void 0:ae.runtime)==null?void 0:re.id)==null?globalThis.chrome:globalThis.browser,b=fe();function fe(){const r={local:j("local"),session:j("session"),sync:j("sync"),managed:j("managed")},e=o=>{const n=r[o];if(n==null){const a=Object.keys(r).join(", ");throw Error(`Invalid area "${o}". Options: ${a}`)}return n},t=o=>{const n=o.indexOf(":"),a=o.substring(0,n),i=o.substring(n+1);if(i==null)throw Error(`Storage key should be in the form of "area:key", but received "${o}"`);return{driverArea:a,driverKey:i,driver:e(a)}},s=o=>o+"$",d=(o,n)=>{const a={...o};return Object.entries(n).forEach(([i,c])=>{c==null?delete a[i]:a[i]=c}),a},u=(o,n)=>o??n??null,h=o=>typeof o=="object"&&!Array.isArray(o)?o:{},v=async(o,n,a)=>{const i=await o.getItem(n);return u(i,(a==null?void 0:a.fallback)??(a==null?void 0:a.defaultValue))},$=async(o,n)=>{const a=s(n),i=await o.getItem(a);return h(i)},V=async(o,n,a)=>{await o.setItem(n,a??null)},y=async(o,n,a)=>{const i=s(n),c=h(await o.getItem(i));await o.setItem(i,d(c,a))},k=async(o,n,a)=>{if(await o.removeItem(n),a!=null&&a.removeMeta){const i=s(n);await o.removeItem(i)}},ne=async(o,n,a)=>{const i=s(n);if(a==null)await o.removeItem(i);else{const c=h(await o.getItem(i));[a].flat().forEach(l=>delete c[l]),await o.setItem(i,c)}},se=(o,n,a)=>o.watch(n,a);return{getItem:async(o,n)=>{const{driver:a,driverKey:i}=t(o);return await v(a,i,n)},getItems:async o=>{const n=new Map,a=new Map,i=[];o.forEach(l=>{let m,f;typeof l=="string"?m=l:"getValue"in l?(m=l.key,f={fallback:l.fallback}):(m=l.key,f=l.options),i.push(m);const{driverArea:x,driverKey:_}=t(m),p=n.get(x)??[];n.set(x,p.concat(_)),a.set(m,f)});const c=new Map;return await Promise.all(Array.from(n.entries()).map(async([l,m])=>{(await r[l].getItems(m)).forEach(x=>{const _=`${l}:${x.key}`,p=a.get(_),w=u(x.value,(p==null?void 0:p.fallback)??(p==null?void 0:p.defaultValue));c.set(_,w)})})),i.map(l=>({key:l,value:c.get(l)}))},getMeta:async o=>{const{driver:n,driverKey:a}=t(o);return await $(n,a)},getMetas:async o=>{const n=o.map(c=>{const l=typeof c=="string"?c:c.key,{driverArea:m,driverKey:f}=t(l);return{key:l,driverArea:m,driverKey:f,driverMetaKey:s(f)}}),a=n.reduce((c,l)=>{var m;return c[m=l.driverArea]??(c[m]=[]),c[l.driverArea].push(l),c},{}),i={};return await Promise.all(Object.entries(a).map(async([c,l])=>{const m=await L.storage[c].get(l.map(f=>f.driverMetaKey));l.forEach(f=>{i[f.key]=m[f.driverMetaKey]??{}})})),n.map(c=>({key:c.key,meta:i[c.key]}))},setItem:async(o,n)=>{const{driver:a,driverKey:i}=t(o);await V(a,i,n)},setItems:async o=>{const n={};o.forEach(a=>{const{driverArea:i,driverKey:c}=t("key"in a?a.key:a.item.key);n[i]??(n[i]=[]),n[i].push({key:c,value:a.value})}),await Promise.all(Object.entries(n).map(async([a,i])=>{await e(a).setItems(i)}))},setMeta:async(o,n)=>{const{driver:a,driverKey:i}=t(o);await y(a,i,n)},setMetas:async o=>{const n={};o.forEach(a=>{const{driverArea:i,driverKey:c}=t("key"in a?a.key:a.item.key);n[i]??(n[i]=[]),n[i].push({key:c,properties:a.meta})}),await Promise.all(Object.entries(n).map(async([a,i])=>{const c=e(a),l=i.map(({key:_})=>s(_));console.log(a,l);const m=await c.getItems(l),f=Object.fromEntries(m.map(({key:_,value:p})=>[_,h(p)])),x=i.map(({key:_,properties:p})=>{const w=s(_);return{key:w,value:d(f[w]??{},p)}});await c.setItems(x)}))},removeItem:async(o,n)=>{const{driver:a,driverKey:i}=t(o);await k(a,i,n)},removeItems:async o=>{const n={};o.forEach(a=>{let i,c;typeof a=="string"?i=a:"getValue"in a?i=a.key:"item"in a?(i=a.item.key,c=a.options):(i=a.key,c=a.options);const{driverArea:l,driverKey:m}=t(i);n[l]??(n[l]=[]),n[l].push(m),c!=null&&c.removeMeta&&n[l].push(s(m))}),await Promise.all(Object.entries(n).map(async([a,i])=>{await e(a).removeItems(i)}))},removeMeta:async(o,n)=>{const{driver:a,driverKey:i}=t(o);await ne(a,i,n)},snapshot:async(o,n)=>{var c;const i=await e(o).snapshot();return(c=n==null?void 0:n.excludeKeys)==null||c.forEach(l=>{delete i[l],delete i[s(l)]}),i},restoreSnapshot:async(o,n)=>{await e(o).restoreSnapshot(n)},watch:(o,n)=>{const{driver:a,driverKey:i}=t(o);return se(a,i,n)},unwatch(){Object.values(r).forEach(o=>{o.unwatch()})},defineItem:(o,n)=>{const{driver:a,driverKey:i}=t(o),{version:c=1,migrations:l={}}=n??{};if(c<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const m=async()=>{var ie;const w=s(i),[{value:K},{value:S}]=await a.getItems([i,w]);if(K==null)return;const T=(S==null?void 0:S.v)??1;if(T>c)throw Error(`Version downgrade detected (v${T} -> v${c}) for "${o}"`);console.debug(`[@wxt-dev/storage] Running storage migration for ${o}: v${T} -> v${c}`);const Ie=Array.from({length:c-T},(B,Q)=>T+Q+1);let q=K;for(const B of Ie)try{q=await((ie=l==null?void 0:l[B])==null?void 0:ie.call(l,q))??q}catch(Q){throw Error(`v${B} migration failed for "${o}"`,{cause:Q})}await a.setItems([{key:i,value:q},{key:w,value:{...S,v:c}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${o} v${c}`,{migratedValue:q})},f=(n==null?void 0:n.migrations)==null?Promise.resolve():m().catch(w=>{console.error(`[@wxt-dev/storage] Migration failed for ${o}`,w)}),x=new me,_=()=>(n==null?void 0:n.fallback)??(n==null?void 0:n.defaultValue)??null,p=()=>x.runExclusive(async()=>{const w=await a.getItem(i);if(w!=null||(n==null?void 0:n.init)==null)return w;const K=await n.init();return await a.setItem(i,K),K});return f.then(p),{key:o,get defaultValue(){return _()},get fallback(){return _()},getValue:async()=>(await f,n!=null&&n.init?await p():await v(a,i,n)),getMeta:async()=>(await f,await $(a,i)),setValue:async w=>(await f,await V(a,i,w)),setMeta:async w=>(await f,await y(a,i,w)),removeValue:async w=>(await f,await k(a,i,w)),removeMeta:async w=>(await f,await ne(a,i,w)),watch:w=>se(a,i,(K,S)=>w(K??_(),S??_())),migrate:m}}}}function j(r){const e=()=>{if(L.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(L.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const s=L.storage[r];if(s==null)throw Error(`"browser.storage.${r}" is undefined`);return s},t=new Set;return{getItem:async s=>(await e().get(s))[s],getItems:async s=>{const d=await e().get(s);return s.map(u=>({key:u,value:d[u]??null}))},setItem:async(s,d)=>{d==null?await e().remove(s):await e().set({[s]:d})},setItems:async s=>{const d=s.reduce((u,{key:h,value:v})=>(u[h]=v,u),{});await e().set(d)},removeItem:async s=>{await e().remove(s)},removeItems:async s=>{await e().remove(s)},snapshot:async()=>await e().get(),restoreSnapshot:async s=>{await e().set(s)},watch(s,d){const u=h=>{const v=h[s];v!=null&&(D(v.newValue,v.oldValue)||d(v.newValue??null,v.oldValue??null))};return e().onChanged.addListener(u),t.add(u),()=>{e().onChanged.removeListener(u),t.delete(u)}},unwatch(){t.forEach(s=>{e().onChanged.removeListener(s)}),t.clear()}}}function I(r,e="local"){return`${e}:${r}`}const U="https://uw.wtf",N="license-check",M=["normal","upscale","stretch"];M.map(r=>({value:r,label:g.i18n.getMessage(`mode_${r}`),disabled:!1}));const E={activity:!0,mode:M[1],scaleX:1,scaleY:1,helpers:[],booster:!1},O=b.defineItem(I("activity"),{fallback:E.activity}),A=b.defineItem(I("mode"),{fallback:E.mode}),W=b.defineItem(I("scaleX"),{fallback:E.scaleX}),P=b.defineItem(I("scaleY"),{fallback:E.scaleY}),C=b.defineItem(I("license")),F=b.defineItem(I("helpers"),{fallback:E.helpers}),we=b.defineItem(I("tabsInFullscreen"),{fallback:[]}),z=b.defineItem(I("booster"),{fallback:E.booster}),ge=oe(()=>{_e(),g.runtime.onInstalled.addListener(async({reason:r})=>{switch(r){case"install":return ye();case"update":return ve()}}),"commands"in g&&g.commands.onCommand.addListener(async r=>{const e=await C.getValue();switch(r){case"toggle_activity":O.setValue(!await O.getValue());break;case"toggle_mode":A.setValue(M[(M.indexOf(await A.getValue())+1)%M.length]);break;case"increment_x":W.setValue(await W.getValue()+.1);break;case"decrement_x":W.setValue(await W.getValue()-.1);break;case"increment_y":P.setValue(await P.getValue()+.1);break;case"decrement_y":P.setValue(await P.getValue()-.1);break;case"toggle_helper":if(!e)return;const t=await we.getValue(),[s]=await g.tabs.query({active:!0,currentWindow:!0});if(!(s.url&&new URL(s.url).protocol.startsWith("http"))||!s.id||t!=null&&t.includes(s.id))return;const u=await F.getValue();F.setValue(u.includes(s.id)?u.filter(h=>h!==s.id):[...u,s.id]);break;case"toggle_booster":if(!e)return;z.setValue(!await z.getValue());break}}),g.runtime.onMessage.addListener(r=>{(async()=>"toggle_mode"in r&&await A.setValue(M[(M.indexOf(await A.getValue())+(r.toggle_mode==="prev"?-1:1)+M.length)%M.length]))()}),O.watch(r=>{r!==null&&Y(r)}),g.tabs.onUpdated.addListener(async(r,e)=>{const[t]=await g.tabs.query({active:!0,currentWindow:!0});if((t==null?void 0:t.id)===r)try{await g.tabs.get(r);const s=(t==null?void 0:t.url)&&new URL(t.url).protocol.startsWith("http");if((g.action??g.browserAction)[s?"enable":"disable"](r),!s||e.status!=="complete")return;await F.setValue((await F.getValue()).filter(d=>d!==r)),await g.tabs.sendMessage(r,{currentTab:r,version:g.runtime.getManifest().version})}catch{}}),g.alarms.onAlarm.addListener(async r=>{r.name===N&&pe()})});async function ye(){g.tabs.create({url:`${U}/installed`}),Y(await O.getValue()),await G(),Z()}async function ve(){Y(await O.getValue()),await G(),Z()}async function _e(){g.runtime.setUninstallURL(`${U}/uninstalled`)}function Y(r){(g.action??g.browserAction).setBadgeText({text:r?"":"off"})}async function G(){const r=(await b.getItems(Object.keys(E).map(t=>I(t)))).map(({key:t,value:s})=>({key:t.replace("local:",""),value:s}));for(let{key:t,value:s}of r)s===null&&await b.setItem(I(t),E[t]);await b.getItem(I("uuid","sync"))===null&&await b.setItem(I("uuid","sync"),self.crypto.randomUUID())}async function pe(){const r=await C.getValue();if(!r)return;const e=await fetch(`${U}/api/license/validate`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({licenseKey:r.key,instanceId:r.instance})}).then(t=>t.json());e.data.valid||e.data.license_key.expires_at&&new Date(e.data.license_key.expires_at).getTime()-36e5>Date.now()?C.setValue({...r,expires_at:e.data.license_key.expires_at}):(await fetch(`${U}/api/license/deactivate`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({instanceId:r.instance,licenseKey:r.key})}).then(s=>s.json())).data.deactivated&&await C.setValue(null)}function Z(){g.alarms.get(N,r=>{r||g.alarms.create(N,{periodInMinutes:1440})})}function Ve(){}function R(r,...e){}const be={debug:(...r)=>R(console.debug,...r),log:(...r)=>R(console.log,...r),warn:(...r)=>R(console.warn,...r),error:(...r)=>R(console.error,...r)};let X;try{X=ge.main(),X instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(r){throw be.error("The background crashed on startup!"),r}return X}();
background;
