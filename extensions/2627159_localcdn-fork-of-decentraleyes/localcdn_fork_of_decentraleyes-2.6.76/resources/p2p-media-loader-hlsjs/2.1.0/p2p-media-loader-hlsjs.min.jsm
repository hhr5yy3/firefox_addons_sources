var j = Object.defineProperty;
var R = (n) => {
  throw TypeError(n);
};
var q = (n, t, e) => t in n ? j(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var r = (n, t, e) => q(n, typeof t != "symbol" ? t + "" : t, e), D = (n, t, e) => t.has(n) || R("Cannot " + e);
var i = (n, t, e) => (D(n, t, "read from private field"), e ? e.call(n) : t.get(n)), l = (n, t, e) => t.has(n) ? R("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), u = (n, t, e, s) => (D(n, t, "write to private field"), s ? s.call(n, e) : t.set(n, e), e), x = (n, t, e) => (D(n, t, "access private method"), e);
import { CoreRequestError as T, debug as N, Core as z } from "p2p-media-loader-core";
function F(n, t) {
  return t ? `${n}|${t.start}-${t.end}` : n;
}
function J(n, t) {
  if (n !== void 0 && t !== void 0 && n <= t) return { start: n, end: t };
}
var H, M, g, y, p, m, b, G, A;
class B {
  constructor(t, e) {
    l(this, b);
    r(this, "context");
    r(this, "config");
    r(this, "stats");
    l(this, H);
    l(this, M);
    l(this, g);
    l(this, y);
    l(this, p);
    l(this, m);
    u(this, y, e), u(this, M, () => new t.loader(t)), this.stats = { aborted: !1, chunkCount: 0, loading: { start: 0, first: 0, end: 0 }, buffering: { start: 0, first: 0, end: 0 }, parsing: { start: 0, end: 0 }, total: 1, loaded: 1, bwEstimate: 0, retry: 0 };
  }
  load(t, e, s) {
    this.context = t, this.config = e, u(this, H, s);
    const { stats: o } = this, { rangeStart: d, rangeEnd: a } = t, E = J(d, a !== void 0 ? a - 1 : void 0);
    u(this, m, F(t.url, E));
    const h = i(this, y).isSegmentLoadable(i(this, m));
    if (!i(this, y).hasSegment(i(this, m)) || !h) return u(this, g, i(this, M).call(this)), i(this, g).stats = this.stats, void i(this, g).load(t, e, s);
    i(this, y).loadSegment(i(this, m), { onSuccess: (f) => {
      u(this, p, f);
      const c = i(this, p).data.byteLength;
      o.loading = function(L, C, I) {
        const w = 8e3 * C / L, S = I - w;
        return { start: S - 10, first: S, end: I };
      }(i(this, p).bandwidth, c, performance.now()), o.total = c, o.loaded = c, s.onProgress && s.onProgress(this.stats, t, i(this, p).data, void 0), s.onSuccess({ data: i(this, p).data, url: t.url }, this.stats, t, void 0);
    }, onError: (f) => {
      f instanceof T && f.type === "aborted" && this.stats.aborted || x(this, b, G).call(this, f);
    } });
  }
  abort() {
    var t, e;
    i(this, g) ? i(this, g).abort() : (x(this, b, A).call(this), (e = (t = i(this, H)) == null ? void 0 : t.onAbort) == null || e.call(t, this.stats, this.context, {}));
  }
  destroy() {
    i(this, g) ? i(this, g).destroy() : (this.stats.aborted || x(this, b, A).call(this), u(this, H, null), this.config = null);
  }
}
H = new WeakMap(), M = new WeakMap(), g = new WeakMap(), y = new WeakMap(), p = new WeakMap(), m = new WeakMap(), b = new WeakSet(), G = function(t) {
  var s;
  const e = { code: 0, text: "" };
  (t instanceof T && t.type === "failed" || t instanceof Error) && (e.text = t.message), (s = i(this, H)) == null || s.onError(e, this.context, null, this.stats);
}, A = function() {
  !i(this, p) && i(this, m) && (this.stats.aborted = !0, i(this, y).abortSegmentLoading(i(this, m)));
};
var v;
class X {
  constructor(t) {
    l(this, v);
    r(this, "context");
    r(this, "stats");
    u(this, v, new t.loader(t)), this.stats = i(this, v).stats, this.context = i(this, v).context;
  }
  load(t, e, s) {
    i(this, v).load(t, e, s);
  }
  abort() {
    i(this, v).abort();
  }
  destroy() {
    i(this, v).destroy();
  }
}
v = new WeakMap();
class K {
  constructor(t) {
    r(this, "core");
    this.core = t;
  }
  processMainManifest(t) {
    const { levels: e, audioTracks: s } = t;
    for (const [o, d] of e.entries()) {
      const { url: a } = d;
      this.core.addStreamIfNoneExists({ runtimeId: Array.isArray(a) ? a[0] : a, type: "main", index: o });
    }
    for (const [o, d] of s.entries()) {
      const { url: a } = d;
      this.core.addStreamIfNoneExists({ runtimeId: Array.isArray(a) ? a[0] : a, type: "secondary", index: o });
    }
  }
  updatePlaylist(t) {
    const { details: { url: e, fragments: s, live: o } } = t, d = this.core.getStream(e);
    if (!d) return;
    const a = new Set(d.segments.keys()), E = [];
    s.forEach((h, f) => {
      const { url: c, byteRange: L, sn: C, start: I, end: w } = h;
      if (C === "initSegment") return;
      const [S, P] = L, U = J(S, P !== void 0 ? P - 1 : void 0), k = F(c, U);
      a.delete(k), d.segments.has(k) || E.push({ runtimeId: k, url: c, externalId: o ? C : f, byteRange: U, startTime: I, endTime: w });
    }), (E.length || a.size) && this.core.updateStream(e, E, a.values());
  }
}
class $ {
  constructor(t) {
    r(this, "core");
    r(this, "segmentManager");
    r(this, "hlsInstanceGetter");
    r(this, "currentHlsInstance");
    r(this, "debug", N("p2pml-hlsjs:engine"));
    r(this, "updateMediaElementEventHandlers", (t) => {
      var o;
      const e = (o = this.currentHlsInstance) == null ? void 0 : o.media;
      if (!e) return;
      const s = t === "register" ? "addEventListener" : "removeEventListener";
      e[s]("timeupdate", this.handlePlaybackUpdate), e[s]("seeking", this.handlePlaybackUpdate), e[s]("ratechange", this.handlePlaybackUpdate);
    });
    r(this, "handleManifestLoaded", (t, e) => {
      const s = e.networkDetails;
      s instanceof XMLHttpRequest ? this.core.setManifestResponseUrl(s.responseURL) : s instanceof Response && this.core.setManifestResponseUrl(s.url), this.segmentManager.processMainManifest(e);
    });
    r(this, "handleLevelSwitching", (t, e) => {
      e.bitrate && this.core.setActiveLevelBitrate(e.bitrate);
    });
    r(this, "handleLevelUpdated", (t, e) => {
      this.currentHlsInstance && this.currentHlsInstance.config.liveSyncDurationCount !== e.details.fragments.length - 1 && e.details.live && e.details.fragments[0].type === "main" && !this.currentHlsInstance.userConfig.liveSyncDuration && !this.currentHlsInstance.userConfig.liveSyncDurationCount && e.details.fragments.length > 4 && (this.debug("set liveSyncDurationCount " + (e.details.fragments.length - 1)), this.currentHlsInstance.config.liveSyncDurationCount = e.details.fragments.length - 1), this.core.setIsLive(e.details.live), this.segmentManager.updatePlaylist(e);
    });
    r(this, "handleMediaAttached", () => {
      this.updateMediaElementEventHandlers("register");
    });
    r(this, "handleMediaDetached", () => {
      this.updateMediaElementEventHandlers("unregister");
    });
    r(this, "handlePlaybackUpdate", (t) => {
      const e = t.target;
      this.core.updatePlayback(e.currentTime, e.playbackRate);
    });
    r(this, "destroyCore", () => this.core.destroy());
    r(this, "destroy", () => {
      this.destroyCore(), this.updateHlsEventsHandlers("unregister"), this.updateMediaElementEventHandlers("unregister"), this.currentHlsInstance = void 0;
    });
    this.core = new z(t == null ? void 0 : t.core), this.segmentManager = new K(this.core);
  }
  static injectMixin(t) {
    var s, o;
    return e = t, o = class extends e {
      constructor(...a) {
        var L;
        const E = a[0], { p2p: h, ...f } = E ?? {}, c = new $(h);
        super({ ...f, ...c.getConfigForHlsJs() });
        l(this, s);
        c.bindHls(this), u(this, s, c), (L = h == null ? void 0 : h.onHlsJsCreated) == null || L.call(h, this);
      }
      get p2pEngine() {
        return i(this, s);
      }
    }, s = new WeakMap(), o;
    var e;
  }
  addEventListener(t, e) {
    this.core.addEventListener(t, e);
  }
  removeEventListener(t, e) {
    this.core.removeEventListener(t, e);
  }
  getConfigForHlsJs() {
    return { fLoader: this.createFragmentLoaderClass(), pLoader: this.createPlaylistLoaderClass() };
  }
  getConfig() {
    return { core: this.core.getConfig() };
  }
  applyDynamicConfig(t) {
    t.core && this.core.applyDynamicConfig(t.core);
  }
  bindHls(t) {
    this.hlsInstanceGetter = typeof t == "function" ? t : () => t;
  }
  initHlsEvents() {
    var e;
    const t = (e = this.hlsInstanceGetter) == null ? void 0 : e.call(this);
    this.currentHlsInstance !== t && (this.currentHlsInstance && this.destroy(), this.currentHlsInstance = t, this.updateHlsEventsHandlers("register"), this.updateMediaElementEventHandlers("register"));
  }
  updateHlsEventsHandlers(t) {
    const e = this.currentHlsInstance;
    if (!e) return;
    const s = t === "register" ? "on" : "off";
    e[s]("hlsManifestLoaded", this.handleManifestLoaded), e[s]("hlsLevelSwitching", this.handleLevelSwitching), e[s]("hlsLevelUpdated", this.handleLevelUpdated), e[s]("hlsAudioTrackLoaded", this.handleLevelUpdated), e[s]("hlsDestroying", this.destroy), e[s]("hlsMediaAttaching", this.destroyCore), e[s]("hlsManifestLoading", this.destroyCore), e[s]("hlsMediaDetached", this.handleMediaDetached), e[s]("hlsMediaAttached", this.handleMediaAttached);
  }
  createFragmentLoaderClass() {
    const { core: t } = this, e = this;
    return class extends B {
      constructor(s) {
        super(s, t);
      }
      static getEngine() {
        return e;
      }
    };
  }
  createPlaylistLoaderClass() {
    const t = this;
    return class extends X {
      constructor(e) {
        super(e), t.initHlsEvents();
      }
    };
  }
}
export {
  $ as HlsJsP2PEngine
};
//# sourceMappingURL=p2p-media-loader-hlsjs.es.min.js.map
