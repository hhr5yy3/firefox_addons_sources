import{a as f,l as c,E as x,M as v,L as E,c as I,d as j}from"./chunk-70aa1672.js";import{c as p,Q as B}from"./chunk-4da8f9f7.js";const q=407520;let m,k=!1;const N="legacy-verified-users",b="verified_users",A=1;async function L(){const r=await f.storage.sync.get({skipVerified:!0});if(!r.skipVerified){console.log(c,"skip verified false, not populating legacyDb",r);return}const t=indexedDB.open(N,A);t.onerror=t.onblocked=()=>{console.error(c,"failed to open legacy verified user database:",t)},t.onupgradeneeded=o=>{console.debug(c,"legacy db onupgradeneeded:",o),m=t.result,!m.objectStoreNames.contains(b)&&(m.createObjectStore(b,{keyPath:"user_id"}),console.log(c,"created legacy database."))},t.onsuccess=async()=>{if(console.debug(c,"successfully connected to legacy db"),m=t.result,k){f.storage.sync.set({skipVerified:!0});return}console.debug(c,"checking verified user database.");try{await new Promise((o,e)=>{const s=m.transaction([b],"readwrite").objectStore(b).count();s.onerror=e,s.onsuccess=()=>{const u=s.result;u!==q?e(`legacy verified users database (${p(u)}) did not contain the expected number of users (${p(q)})`):(console.log(c,"loaded",u,"legacy verified users"),o())}})}catch{await new Promise((l,y)=>{const _=m.transaction([b],"readwrite").objectStore(b).clear();_.onerror=y,_.onsuccess=()=>{console.debug(c,"cleared existing legacyDb store."),l()}}),(()=>{const l="downloading legacy verified users database, this may take a few minutes.";f.storage.local.set({[x]:{type:v,message:l}}),console.log(c,l)})();let e=0;const n=await fetch(E).then(l=>l.text());let a=!1;const s=m.transaction([b],"readwrite"),u=s.objectStore(b);for(const l of n.split(`
`)){if(l==="Twitter ID, Screen name, Followers"){console.debug(c,"response csv good!"),a=!0;continue}else if(!a){const y="legacy verified users database was mangled or otherwise unable to be parsed";throw console.error(c,y),f.storage.local.set({[x]:{type:I,message:y}}),new Error(y)}await new Promise((y,S)=>{const[D,_,O]=l.split(","),V={user_id:D,handle:_},P=u.add(V);P.onerror=S,P.onsuccess=()=>{e++,e%1e3===0&&console.debug(c,"stored 1,000 legacy verified users"),y()}})}s.commit(),console.debug(c,"committed",e,"users to legacy verified legacyDb:",s);const i=`loaded ${p(e)} legacy verified users!`;if(console.log(c,i),f.storage.local.set({[x]:{type:v,message:i}}),e!==q)throw new Error(`legacy verified users database (${p(e)}) did not contain the expected number of users (${p(q)})`)}f.storage.sync.set({skipVerified:!0}),k=!0},console.debug(c,"opening legacy verified user database:",t)}function $(r,t){return new Promise((o,e)=>{const n=m.transaction([b],"readonly");n.onabort=n.onerror=e;const s=n.objectStore(b).get(r);s.onerror=e,s.onsuccess=()=>{const u=s.result;o(r===(u==null?void 0:u.user_id)&&t===(u==null?void 0:u.handle))}}).catch(o=>{if(k)return L().finally(()=>{throw o});throw o})}let d;const U="blue-blocker-db",w="blocked_users",g="block_queue",M=2;let Q=!1;function h(){return new Promise((r,t)=>{const o=indexedDB.open(U,M);o.onerror=o.onblocked=()=>(console.error(c,"failed to connect database:",o),t()),o.onupgradeneeded=e=>{if(console.debug(c,"upgrading db:",e),d=o.result,!d.objectStoreNames.contains(w)){const n=d.createObjectStore(w,{keyPath:"user_id"});n.createIndex("user.name","user.name",{unique:!1}),n.createIndex("user.screen_name","user.screen_name",{unique:!1}),n.createIndex("time","time",{unique:!1}),console.log(c,"created history database.")}if(!d.objectStoreNames.contains(g)){const n=d.createObjectStore(g,{keyPath:"user_id"});n.createIndex("user_id","user_id",{unique:!0}),n.createIndex("queue","queue",{unique:!1}),console.log(c,"created queue database.")}},o.onsuccess=async()=>{var n,a;if(d=o.result,Q)return r(d);Q=!0;const e=await f.storage.local.get({BlockQueue:[]});if(((n=e==null?void 0:e.BlockQueue)==null?void 0:n.length)!==void 0&&((a=e==null?void 0:e.BlockQueue)==null?void 0:a.length)>0){const s=d.transaction([g],"readwrite");s.onabort=s.onerror=t;const u=s.objectStore(g);e.BlockQueue.forEach(i=>{i.user.hasOwnProperty("legacy")&&(i.user.name=i.user.legacy.name,i.user.screen_name=i.user.legacy.screen_name,delete i.user.legacy);const l={user_id:i.user_id,user:{name:i.user.name,screen_name:i.user.screen_name},reason:i.reason,queue:B()};u.add(l)}),f.storage.local.set({BlockQueue:null}),s.commit(),console.debug(c,"imported",e.BlockQueue.length,"users from local storage queue")}return console.log(c,"successfully connected to db"),r(d)}})}function F(r){return new Promise((t,o)=>{const e=d.transaction([w],"readwrite");e.onabort=e.onerror=o,e.oncomplete=()=>t(),e.objectStore(w).add(r),e.commit()}).catch(t=>h().finally(()=>{throw t}))}function H(r){return new Promise(async(t,o)=>{try{const e=d.transaction([w],"readwrite");e.onabort=e.onerror=o,e.oncomplete=()=>t();const n=e.objectStore(w),a=await new Promise((s,u)=>{const i=n.get(r);i.onerror=u,i.onsuccess=()=>{const l=i.result;s(l)}}).catch(s=>{throw s});a.state=j,a.time=new Date,n.put(a),e.commit()}catch(e){o(e)}}).catch(t=>h().finally(()=>{throw t}))}function K(r){const t={user_id:r.user_id,user:{name:r.user.name,screen_name:r.user.screen_name},reason:r.reason,queue:B()};return r.external_reason&&(t.external_reason=r.external_reason),new Promise((o,e)=>{const n=d.transaction([g],"readwrite");n.onabort=n.onerror=e,n.objectStore(g).add(t),n.oncomplete=()=>o(),n.commit()}).catch(o=>{var e,n;if(((n=(e=o==null?void 0:o.target)==null?void 0:e.error)==null?void 0:n.name)!=="ConstraintError")return h().finally(()=>{throw o})})}function T(){return new Promise(async(r,t)=>{const o=d.transaction([g],"readwrite");o.onabort=o.onerror=t;const e=o.objectStore(g),n=e.index("queue"),a=await new Promise((u,i)=>{const l=n.get(IDBKeyRange.bound(Number.MIN_VALUE,Number.MAX_VALUE));l.onerror=i,l.onsuccess=()=>{u(l.result)}});if(a===void 0)return r(null);const s={user_id:a.user_id,user:{name:a.user.name,screen_name:a.user.screen_name},reason:a.reason};a.external_reason&&(s.external_reason=a.external_reason),e.delete(s.user_id),o.commit(),o.oncomplete=()=>r(s)}).catch(r=>h().finally(()=>{throw r}))}function W(){return h().then(r=>new Promise((t,o)=>{const e=r.transaction([g],"readonly");e.onabort=e.onerror=o;const s=e.objectStore(g).index("queue").getAll(IDBKeyRange.bound(Number.MIN_VALUE,Number.MAX_VALUE),1e4);s.onerror=o,s.onsuccess=()=>{const u=s.result;t(u)}})).catch(()=>f.storage.local.get({BlockQueue:[]}).then(r=>r==null?void 0:r.BlockQueue))}function X(){return h().then(r=>new Promise((t,o)=>{const e=r.transaction([g],"readonly");e.onabort=e.onerror=o;const a=e.objectStore(g).count();a.onerror=o,a.onsuccess=()=>{const s=a.result;t(s)}})).catch(()=>f.storage.local.get({BlockQueue:[]}).then(r=>{var t;return(t=r==null?void 0:r.BlockQueue)==null?void 0:t.length}))}export{K as A,h as C,L as P,X as Q,H as R,W,T as a,F as b,$ as c,w as h,g as q};
