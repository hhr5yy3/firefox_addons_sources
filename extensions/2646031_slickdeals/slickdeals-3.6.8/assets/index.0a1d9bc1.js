var de=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Te(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}let ne=()=>({events:{},emit(e,...r){(this.events[e]||[]).forEach(s=>s(...r))},on(e,r){return(this.events[e]=this.events[e]||[]).push(r),()=>this.events[e]=(this.events[e]||[]).filter(s=>s!==r)}});var te={exports:{}};(function(e,r){(function(s,o){o(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:de,function(s){if(typeof globalThis!="object"||typeof chrome!="object"||!chrome||!chrome.runtime||!chrome.runtime.id)throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const o="The message port closed before a response was received.",d="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)",c=i=>{const a={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(a).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class u extends WeakMap{constructor(t,l=void 0){super(l),this.createItem=t}get(t){return this.has(t)||this.set(t,this.createItem(t)),super.get(t)}}const y=n=>n&&typeof n=="object"&&typeof n.then=="function",M=(n,t)=>(...l)=>{i.runtime.lastError?n.reject(new Error(i.runtime.lastError.message)):t.singleCallbackArg||l.length<=1&&t.singleCallbackArg!==!1?n.resolve(l[0]):n.resolve(l)},C=n=>n==1?"argument":"arguments",R=(n,t)=>function(m,...p){if(p.length<t.minArgs)throw new Error(`Expected at least ${t.minArgs} ${C(t.minArgs)} for ${n}(), got ${p.length}`);if(p.length>t.maxArgs)throw new Error(`Expected at most ${t.maxArgs} ${C(t.maxArgs)} for ${n}(), got ${p.length}`);return new Promise((b,h)=>{if(t.fallbackToNoCallback)try{m[n](...p,M({resolve:b,reject:h},t))}catch(g){console.warn(`${n} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,g),m[n](...p),t.fallbackToNoCallback=!1,t.noCallback=!0,b()}else t.noCallback?(m[n](...p),b()):m[n](...p,M({resolve:b,reject:h},t))})},Y=(n,t,l)=>new Proxy(t,{apply(m,p,b){return l.call(p,n,...b)}});let $=Function.call.bind(Object.prototype.hasOwnProperty);const j=(n,t={},l={})=>{let m=Object.create(null),p={has(h,g){return g in n||g in m},get(h,g,w){if(g in m)return m[g];if(!(g in n))return;let f=n[g];if(typeof f=="function")if(typeof t[g]=="function")f=Y(n,n[g],t[g]);else if($(l,g)){let I=R(g,l[g]);f=Y(n,n[g],I)}else f=f.bind(n);else if(typeof f=="object"&&f!==null&&($(t,g)||$(l,g)))f=j(f,t[g],l[g]);else if($(l,"*"))f=j(f,t[g],l["*"]);else return Object.defineProperty(m,g,{configurable:!0,enumerable:!0,get(){return n[g]},set(I){n[g]=I}}),f;return m[g]=f,f},set(h,g,w,f){return g in m?m[g]=w:n[g]=w,!0},defineProperty(h,g,w){return Reflect.defineProperty(m,g,w)},deleteProperty(h,g){return Reflect.deleteProperty(m,g)}},b=Object.create(n);return new Proxy(b,p)},F=n=>({addListener(t,l,...m){t.addListener(n.get(l),...m)},hasListener(t,l){return t.hasListener(n.get(l))},removeListener(t,l){t.removeListener(n.get(l))}}),le=new u(n=>typeof n!="function"?n:function(l){const m=j(l,{},{getContent:{minArgs:0,maxArgs:0}});n(m)});let X=!1;const ee=new u(n=>typeof n!="function"?n:function(l,m,p){let b=!1,h,g=new Promise(S=>{h=function(v){X||(console.warn(d,new Error().stack),X=!0),b=!0,S(v)}}),w;try{w=n(l,m,h)}catch(S){w=Promise.reject(S)}const f=w!==!0&&y(w);if(w!==!0&&!f&&!b)return!1;const I=S=>{S.then(v=>{p(v)},v=>{let W;v&&(v instanceof Error||typeof v.message=="string")?W=v.message:W="An unexpected error occurred",p({__mozWebExtensionPolyfillReject__:!0,message:W})}).catch(v=>{console.error("Failed to send onMessage rejected reply",v)})};return I(f?w:g),!0}),me=({reject:n,resolve:t},l)=>{i.runtime.lastError?i.runtime.lastError.message===o?t():n(new Error(i.runtime.lastError.message)):l&&l.__mozWebExtensionPolyfillReject__?n(new Error(l.message)):t(l)},re=(n,t,l,...m)=>{if(m.length<t.minArgs)throw new Error(`Expected at least ${t.minArgs} ${C(t.minArgs)} for ${n}(), got ${m.length}`);if(m.length>t.maxArgs)throw new Error(`Expected at most ${t.maxArgs} ${C(t.maxArgs)} for ${n}(), got ${m.length}`);return new Promise((p,b)=>{const h=me.bind(null,{resolve:p,reject:b});m.push(h),l.sendMessage(...m)})},ce={devtools:{network:{onRequestFinished:F(le)}},runtime:{onMessage:F(ee),onMessageExternal:F(ee),sendMessage:re.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:re.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},B={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return a.privacy={network:{"*":B},services:{"*":B},websites:{"*":B}},j(i,ce,a)};s.exports=c(chrome)}else s.exports=globalThis.browser})})(te);const _=te.exports,Ae=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0}],z=Symbol(".toJSON was called"),ue=e=>{e[z]=!0;const r=e.toJSON();return delete e[z],r},oe=({from:e,seen:r,to_:s,forceEnumerable:o,maxDepth:d,depth:c})=>{const i=s||(Array.isArray(e)?[]:{});if(r.push(e),c>=d)return i;if(typeof e.toJSON=="function"&&e[z]!==!0)return ue(e);for(const[a,u]of Object.entries(e)){if(typeof Buffer=="function"&&Buffer.isBuffer(u)){i[a]="[object Buffer]";continue}if(u!==null&&typeof u=="object"&&typeof u.pipe=="function"){i[a]="[object Stream]";continue}if(typeof u!="function"){if(!u||typeof u!="object"){i[a]=u;continue}if(!r.includes(e[a])){c++,i[a]=oe({from:e[a],seen:[...r],forceEnumerable:o,maxDepth:d,depth:c});continue}i[a]="[Circular]"}}for(const{property:a,enumerable:u}of Ae)typeof e[a]=="string"&&Object.defineProperty(i,a,{value:e[a],enumerable:o?!0:u,configurable:!0,writable:!0});return i};function fe(e,r={}){const{maxDepth:s=Number.POSITIVE_INFINITY}=r;return typeof e=="object"&&e!==null?oe({from:e,seen:[],forceEnumerable:!0,maxDepth:s,depth:0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}var N={exports:{}};const pe=e=>typeof crypto<"u"&&typeof crypto.getRandomValues=="function"?()=>{const r=crypto.getRandomValues(new Uint8Array(1))[0];return(r>=e?r%e:r).toString(e)}:()=>Math.floor(Math.random()*e).toString(e),ie=(e=7,r=!1)=>Array.from({length:e},pe(r?16:36)).join("");N.exports=ie;N.exports.default=ie;var xe=/^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/,D=e=>{const[,r,s,o]=e.match(xe)||[];return{context:r,tabId:+s,frameId:o?+o:void 0}},be=({context:e})=>["content-script","background","devtools"].includes(e),U=e=>_[e],he=()=>{var e,r,s;const o=_.runtime.getManifest();if(typeof window>"u")return"background";const d=((e=o.browser_action)==null?void 0:e.default_popup)||((r=o.action)==null?void 0:r.default_popup);return d&&new URL(_.runtime.getURL(d)).pathname===window.location.pathname?"popup":(s=o.options_ui)!=null&&s.page&&new URL(_.runtime.getURL(o.options_ui.page)).pathname===window.location.pathname?"options":"background"},A=U("devtools")?"devtools":U("tabs")?he():U("extension")?"content-script":typeof document<"u"?"window":null,se=N.exports(),J=new Map,ae=new Map,V=new Set,G=new Map,x=null,E,K;P();function we(e){E=e}function ye(e){K=!0,E=e}function P(){if(A===null)throw new Error("Unable to detect runtime context i.e webext-bridge can't figure out what to do");if((A==="window"||A==="content-script")&&window.addEventListener("message",_e),A==="content-script"&&top===window&&(x=_.runtime.connect(),x.onMessage.addListener(e=>{k(e)}),x.onDisconnect.addListener(()=>{x=null,P()})),A==="content-script"&&top!==window&&(x=_.runtime.connect(),x.onMessage.addListener(e=>{k(e)}),x.onDisconnect.addListener(()=>{x=null,P()})),A==="devtools"){const{tabId:e}=_.devtools.inspectedWindow,r=`devtools@${e}`;x=_.runtime.connect(void 0,{name:r}),x.onMessage.addListener(s=>{k(s)}),x.onDisconnect.addListener(()=>{x=null,P()})}if(A==="popup"||A==="options"){const e=`${A}`;x=_.runtime.connect(void 0,{name:e}),x.onMessage.addListener(r=>{k(r)}),x.onDisconnect.addListener(()=>{x=null,P()})}A==="background"&&_.runtime.onConnect.addListener(e=>{let r=e.name||`content-script@${e.sender.tab.id}`;const s=e.sender.frameId;s&&(r=`${r}.${s}`);const{context:o,tabId:d,frameId:c}=D(r);!d&&o!=="popup"&&o!=="options"||(G.set(r,e),V.forEach(i=>{i.resolvedDestination===r&&(e.postMessage(i.message),V.delete(i))}),e.onDisconnect.addListener(()=>{G.delete(r)}),e.onMessage.addListener(i=>{var a;(a=i==null?void 0:i.origin)!=null&&a.context&&(i.origin.tabId=d,i.origin.frameId=c,k(i))}))})}function k(e){const{origin:r,destination:s}=e;if(!e.hops.includes(se)&&(e.hops.push(se),!(A==="content-script"&&[s,r].some(o=>(o==null?void 0:o.context)==="window")&&!K))){if(!s)return ve(e);if(s.context){if(A==="window")return Z(window,e);if(A==="content-script"&&s.context==="window")return e.destination=null,Z(window,e);if(["devtools","content-script","popup","options"].includes(A))return s.context==="background"&&(e.destination=null),x.postMessage(e);if(A==="background"){const{context:o,tabId:d,frameId:c}=s,{tabId:i}=r;o!=="window"?e.destination=null:e.destination.tabId=null;let a=["popup","options"].includes(o)?o:`${o==="window"?"content-script":o}@${d||i}`;c&&(a=`${a}.${c}`);const u=G.get(a);u?u.postMessage(e):V.add({resolvedDestination:a,message:e})}}}}async function ve(e){const{transactionId:r,messageID:s,messageType:o}=e,d=()=>{const i=J.get(r);if(i){const{err:a,data:u}=e;if(a){const y=a,M=self[y.name],C=new(typeof M=="function"?M:Error)(y.message);for(const R in y)C[R]=y[R];i.reject(C)}else i.resolve(u);J.delete(r)}},c=async()=>{let i,a,u=!1;try{const y=ae.get(s);if(typeof y=="function")i=await y({sender:e.origin,id:s,data:e.data,timestamp:e.timestamp});else throw u=!0,new Error(`[webext-bridge] No handler registered in '${A}' to accept messages with id '${s}'`)}catch(y){a=y}finally{if(a&&(e.err=fe(a)),k({...e,messageType:"reply",data:i,origin:{context:A,tabId:null},destination:e.origin,hops:[]}),a&&!u)throw i}};switch(o){case"reply":return d();case"message":return c()}}async function _e({data:e,ports:r}){if(!(A==="content-script"&&!K)){if(e.cmd==="__crx_bridge_verify_listening"&&e.scope===E&&e.context!==A)r[0].postMessage(!0);else if(e.cmd==="__crx_bridge_route_message"&&e.scope===E&&e.context!==A){const{payload:s}=e;A==="content-script"&&(s.origin={context:"window",tabId:null}),k(s)}}}function Z(e,r){ke();const s=new MessageChannel,o=setTimeout(()=>{s.port1.onmessage=null,Z(e,r)},300);s.port1.onmessage=()=>{clearTimeout(o),e.postMessage({cmd:"__crx_bridge_route_message",scope:E,context:A,payload:r},"*")},e.postMessage({cmd:"__crx_bridge_verify_listening",scope:E,context:A},"*",[s.port2])}function ke(){if(typeof E!="string"||E.length===0)throw new Error(`webext-bridge uses window.postMessage to talk with other "window"(s), for message routing and stuff,which is global/conflicting operation in case there are other scripts using webext-bridge. Call Bridge#setNamespace(nsps) to isolate your app. Example: setNamespace('com.facebook.react-devtools'). Make sure to use same namespace across all your scripts whereever window.postMessage is likely to be used\``)}function Ee(){return A}function Q(e,r){ae.set(e,r)}async function L(e,r,s="background"){const o=typeof s=="string"?D(s):s,d="Bridge#sendMessage ->";if(!o.context)throw new TypeError(`${d} Destination must be any one of known destinations`);if(A==="background"){const{context:c,tabId:i}=o;if(c!=="background"&&!i)throw new TypeError(`${d} When sending messages from background page, use @tabId syntax to target specific tab`)}return new Promise((c,i)=>{const a={messageID:e,data:r,destination:o,messageType:"message",transactionId:N.exports(),origin:{context:A,tabId:null},hops:[],timestamp:Date.now()};J.set(a.transactionId,{resolve:c,reject:i}),k(a)})}var T=class{constructor(e){this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},this.internalInfo=e,this.emitter=ne(),this.isClosed=!1,T.initDone||(Q("__crx_bridge_stream_transfer__",r=>{const{streamId:s,streamTransfer:o,action:d}=r.data,c=T.openStreams.get(s);c&&!c.isClosed&&(d==="transfer"&&c.emitter.emit("message",o),d==="close"&&(T.openStreams.delete(s),c.handleStreamClose()))}),T.initDone=!0),T.openStreams.set(e.streamId,this)}get info(){return this.internalInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");L("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:e,action:"transfer"},this.internalInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),L("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:null,action:"close"},this.internalInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,r){const s=this.emitter.on(e,r);return Object.assign(s,{dispose:s,close:s})}},O=T;O.initDone=!1;O.openStreams=new Map;var q=new Map,H=new Map,ge=ne();Q("__crx_bridge_stream_open__",e=>new Promise(r=>{const{sender:s,data:o}=e,{channel:d}=o;let c=!1,i=()=>{};const a=()=>{const u=H.get(d);typeof u=="function"?(u(new O({...o,endpoint:s})),c&&i(),r(!0)):c||(c=!0,i=ge.on("did-change-stream-callbacks",a))};a()}));async function Ce(e,r){if(q.has(e))throw new Error("webext-bridge: A Stream is already open at this channel");const s=typeof r=="string"?D(r):r,o={streamId:N.exports(),channel:e,endpoint:s},d=new O(o);return d.onClose(()=>q.delete(e)),await L("__crx_bridge_stream_open__",o,s),q.set(e,d),d}function Ie(e,r){if(H.has(e))throw new Error("webext-bridge: This channel has already been claimed. Stream allows only one-on-one communication");H.set(e,r),ge.emit("did-change-stream-callbacks")}const Me=Object.freeze(Object.defineProperty({__proto__:null,Stream:O,allowWindowMessaging:ye,getCurrentContext:Ee,isInternalEndpoint:be,onMessage:Q,onOpenStreamChannel:Ie,openStream:Ce,parseEndpoint:D,sendMessage:L,setNamespace:we},Symbol.toStringTag,{value:"Module"}));export{de as c,Te as g,Me as i,Q as o,L as s};
