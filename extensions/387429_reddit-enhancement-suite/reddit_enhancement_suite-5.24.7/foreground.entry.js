(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all2) => {
    for (var name2 in all2)
      __defProp(target, name2, { get: all2[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/fastest-levenshtein/mod.js
  var require_mod = __commonJS({
    "node_modules/fastest-levenshtein/mod.js"(exports2) {
      "use strict";
      exports2.__esModule = true;
      exports2.distance = exports2.closest = void 0;
      var peq = new Uint32Array(65536);
      var myers_32 = function(a2, b2) {
        var n = a2.length;
        var m = b2.length;
        var lst = 1 << n - 1;
        var pv = -1;
        var mv = 0;
        var sc = n;
        var i2 = n;
        while (i2--) {
          peq[a2.charCodeAt(i2)] |= 1 << i2;
        }
        for (i2 = 0; i2 < m; i2++) {
          var eq2 = peq[b2.charCodeAt(i2)];
          var xv = eq2 | mv;
          eq2 |= (eq2 & pv) + pv ^ pv;
          mv |= ~(eq2 | pv);
          pv &= eq2;
          if (mv & lst) {
            sc++;
          }
          if (pv & lst) {
            sc--;
          }
          mv = mv << 1 | 1;
          pv = pv << 1 | ~(xv | mv);
          mv &= xv;
        }
        i2 = n;
        while (i2--) {
          peq[a2.charCodeAt(i2)] = 0;
        }
        return sc;
      };
      var myers_x = function(b2, a2) {
        var n = a2.length;
        var m = b2.length;
        var mhc = [];
        var phc = [];
        var hsize = Math.ceil(n / 32);
        var vsize = Math.ceil(m / 32);
        for (var i2 = 0; i2 < hsize; i2++) {
          phc[i2] = -1;
          mhc[i2] = 0;
        }
        var j = 0;
        for (; j < vsize - 1; j++) {
          var mv_1 = 0;
          var pv_1 = -1;
          var start_1 = j * 32;
          var vlen_1 = Math.min(32, m) + start_1;
          for (var k2 = start_1; k2 < vlen_1; k2++) {
            peq[b2.charCodeAt(k2)] |= 1 << k2;
          }
          for (var i2 = 0; i2 < n; i2++) {
            var eq2 = peq[a2.charCodeAt(i2)];
            var pb = phc[i2 / 32 | 0] >>> i2 & 1;
            var mb = mhc[i2 / 32 | 0] >>> i2 & 1;
            var xv = eq2 | mv_1;
            var xh = ((eq2 | mb) & pv_1) + pv_1 ^ pv_1 | eq2 | mb;
            var ph = mv_1 | ~(xh | pv_1);
            var mh = pv_1 & xh;
            if (ph >>> 31 ^ pb) {
              phc[i2 / 32 | 0] ^= 1 << i2;
            }
            if (mh >>> 31 ^ mb) {
              mhc[i2 / 32 | 0] ^= 1 << i2;
            }
            ph = ph << 1 | pb;
            mh = mh << 1 | mb;
            pv_1 = mh | ~(xv | ph);
            mv_1 = ph & xv;
          }
          for (var k2 = start_1; k2 < vlen_1; k2++) {
            peq[b2.charCodeAt(k2)] = 0;
          }
        }
        var mv = 0;
        var pv = -1;
        var start2 = j * 32;
        var vlen = Math.min(32, m - start2) + start2;
        for (var k2 = start2; k2 < vlen; k2++) {
          peq[b2.charCodeAt(k2)] |= 1 << k2;
        }
        var score = m;
        for (var i2 = 0; i2 < n; i2++) {
          var eq2 = peq[a2.charCodeAt(i2)];
          var pb = phc[i2 / 32 | 0] >>> i2 & 1;
          var mb = mhc[i2 / 32 | 0] >>> i2 & 1;
          var xv = eq2 | mv;
          var xh = ((eq2 | mb) & pv) + pv ^ pv | eq2 | mb;
          var ph = mv | ~(xh | pv);
          var mh = pv & xh;
          score += ph >>> m - 1 & 1;
          score -= mh >>> m - 1 & 1;
          if (ph >>> 31 ^ pb) {
            phc[i2 / 32 | 0] ^= 1 << i2;
          }
          if (mh >>> 31 ^ mb) {
            mhc[i2 / 32 | 0] ^= 1 << i2;
          }
          ph = ph << 1 | pb;
          mh = mh << 1 | mb;
          pv = mh | ~(xv | ph);
          mv = ph & xv;
        }
        for (var k2 = start2; k2 < vlen; k2++) {
          peq[b2.charCodeAt(k2)] = 0;
        }
        return score;
      };
      var distance = function(a2, b2) {
        if (a2.length < b2.length) {
          var tmp = b2;
          b2 = a2;
          a2 = tmp;
        }
        if (b2.length === 0) {
          return a2.length;
        }
        if (a2.length <= 32) {
          return myers_32(a2, b2);
        }
        return myers_x(a2, b2);
      };
      exports2.distance = distance;
      var closest2 = function(str, arr) {
        var min_distance = Infinity;
        var min_index = 0;
        for (var i2 = 0; i2 < arr.length; i2++) {
          var dist = distance(str, arr[i2]);
          if (dist < min_distance) {
            min_distance = dist;
            min_index = i2;
          }
        }
        return arr[min_index];
      };
      exports2.closest = closest2;
    }
  });

  // node_modules/fast-levenshtein/levenshtein.js
  var require_levenshtein = __commonJS({
    "node_modules/fast-levenshtein/levenshtein.js"(exports2, module84) {
      (function() {
        "use strict";
        var collator;
        try {
          collator = typeof Intl !== "undefined" && typeof Intl.Collator !== "undefined" ? Intl.Collator("generic", { sensitivity: "base" }) : null;
        } catch (err) {
          console.log("Collator could not be initialized and wouldn't be used");
        }
        var levenshtein2 = require_mod();
        var prevRow = [], str2Char = [];
        var Levenshtein = {
          /**
           * Calculate levenshtein distance of the two strings.
           *
           * @param str1 String the first string.
           * @param str2 String the second string.
           * @param [options] Additional options.
           * @param [options.useCollator] Use `Intl.Collator` for locale-sensitive string comparison.
           * @return Integer the levenshtein distance (0 and above).
           */
          get: function(str1, str2, options6) {
            var useCollator = options6 && collator && options6.useCollator;
            if (useCollator) {
              var str1Len = str1.length, str2Len = str2.length;
              if (str1Len === 0) return str2Len;
              if (str2Len === 0) return str1Len;
              var curCol, nextCol, i2, j, tmp;
              for (i2 = 0; i2 < str2Len; ++i2) {
                prevRow[i2] = i2;
                str2Char[i2] = str2.charCodeAt(i2);
              }
              prevRow[str2Len] = str2Len;
              var strCmp;
              for (i2 = 0; i2 < str1Len; ++i2) {
                nextCol = i2 + 1;
                for (j = 0; j < str2Len; ++j) {
                  curCol = nextCol;
                  strCmp = 0 === collator.compare(str1.charAt(i2), String.fromCharCode(str2Char[j]));
                  nextCol = prevRow[j] + (strCmp ? 0 : 1);
                  tmp = curCol + 1;
                  if (nextCol > tmp) {
                    nextCol = tmp;
                  }
                  tmp = prevRow[j + 1] + 1;
                  if (nextCol > tmp) {
                    nextCol = tmp;
                  }
                  prevRow[j] = curCol;
                }
                prevRow[j] = nextCol;
              }
              return nextCol;
            }
            return levenshtein2.distance(str1, str2);
          }
        };
        if (typeof define !== "undefined" && define !== null && define.amd) {
          define(function() {
            return Levenshtein;
          });
        } else if (typeof module84 !== "undefined" && module84 !== null && typeof exports2 !== "undefined" && module84.exports === exports2) {
          module84.exports = Levenshtein;
        } else if (typeof self !== "undefined" && typeof self.postMessage === "function" && typeof self.importScripts === "function") {
          self.Levenshtein = Levenshtein;
        } else if (typeof window !== "undefined" && window !== null) {
          window.Levenshtein = Levenshtein;
        }
      })();
    }
  });

  // node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "node_modules/dayjs/dayjs.min.js"(exports2, module84) {
      !function(t2, e2) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = e2() : "function" == typeof define && define.amd ? define(e2) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs = e2();
      }(exports2, function() {
        "use strict";
        var t2 = 1e3, e2 = 6e4, n = 36e5, r = "millisecond", i2 = "second", s = "minute", u = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h = "year", d = "date", l = "Invalid Date", $51 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e3 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
          return "[" + t3 + (e3[(n2 - 20) % 10] || e3[n2] || e3[0]) + "]";
        } }, m = function(t3, e3, n2) {
          var r2 = String(t3);
          return !r2 || r2.length >= e3 ? t3 : "" + Array(e3 + 1 - r2.length).join(n2) + t3;
        }, v = { s: m, z: function(t3) {
          var e3 = -t3.utcOffset(), n2 = Math.abs(e3), r2 = Math.floor(n2 / 60), i3 = n2 % 60;
          return (e3 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i3, 2, "0");
        }, m: function t3(e3, n2) {
          if (e3.date() < n2.date()) return -t3(n2, e3);
          var r2 = 12 * (n2.year() - e3.year()) + (n2.month() - e3.month()), i3 = e3.clone().add(r2, c2), s2 = n2 - i3 < 0, u2 = e3.clone().add(r2 + (s2 ? -1 : 1), c2);
          return +(-(r2 + (n2 - i3) / (s2 ? i3 - u2 : u2 - i3)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: c2, y: h, w: o2, d: a2, D: d, h: u, m: s, s: i2, ms: r, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g = "en", D = {};
        D[g] = M;
        var p = "$isDayjsObject", S = function(t3) {
          return t3 instanceof _ || !(!t3 || !t3[p]);
        }, w = function t3(e3, n2, r2) {
          var i3;
          if (!e3) return g;
          if ("string" == typeof e3) {
            var s2 = e3.toLowerCase();
            D[s2] && (i3 = s2), n2 && (D[s2] = n2, i3 = s2);
            var u2 = e3.split("-");
            if (!i3 && u2.length > 1) return t3(u2[0]);
          } else {
            var a3 = e3.name;
            D[a3] = e3, i3 = a3;
          }
          return !r2 && i3 && (g = i3), i3 || !r2 && g;
        }, O = function(t3, e3) {
          if (S(t3)) return t3.clone();
          var n2 = "object" == typeof e3 ? e3 : {};
          return n2.date = t3, n2.args = arguments, new _(n2);
        }, b2 = v;
        b2.l = w, b2.i = S, b2.w = function(t3, e3) {
          return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _ = function() {
          function M2(t3) {
            this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
          }
          var m2 = M2.prototype;
          return m2.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n2 = t4.utc;
              if (null === e3) return /* @__PURE__ */ new Date(NaN);
              if (b2.u(e3)) return /* @__PURE__ */ new Date();
              if (e3 instanceof Date) return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r2 = e3.match($51);
                if (r2) {
                  var i3 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                  return n2 ? new Date(Date.UTC(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
                }
              }
              return new Date(e3);
            }(t3), this.init();
          }, m2.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m2.$utils = function() {
            return b2;
          }, m2.isValid = function() {
            return !(this.$d.toString() === l);
          }, m2.isSame = function(t3, e3) {
            var n2 = O(t3);
            return this.startOf(e3) <= n2 && n2 <= this.endOf(e3);
          }, m2.isAfter = function(t3, e3) {
            return O(t3) < this.startOf(e3);
          }, m2.isBefore = function(t3, e3) {
            return this.endOf(e3) < O(t3);
          }, m2.$g = function(t3, e3, n2) {
            return b2.u(t3) ? this[e3] : this.set(n2, t3);
          }, m2.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m2.valueOf = function() {
            return this.$d.getTime();
          }, m2.startOf = function(t3, e3) {
            var n2 = this, r2 = !!b2.u(e3) || e3, f3 = b2.p(t3), l2 = function(t4, e4) {
              var i3 = b2.w(n2.$u ? Date.UTC(n2.$y, e4, t4) : new Date(n2.$y, e4, t4), n2);
              return r2 ? i3 : i3.endOf(a2);
            }, $52 = function(t4, e4) {
              return b2.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n2);
            }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
            switch (f3) {
              case h:
                return r2 ? l2(1, 0) : l2(31, 11);
              case c2:
                return r2 ? l2(1, M3) : l2(0, M3 + 1);
              case o2:
                var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
              case a2:
              case d:
                return $52(v2 + "Hours", 0);
              case u:
                return $52(v2 + "Minutes", 1);
              case s:
                return $52(v2 + "Seconds", 2);
              case i2:
                return $52(v2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m2.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m2.$set = function(t3, e3) {
            var n2, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a2] = f3 + "Date", n2[d] = f3 + "Date", n2[c2] = f3 + "Month", n2[h] = f3 + "FullYear", n2[u] = f3 + "Hours", n2[s] = f3 + "Minutes", n2[i2] = f3 + "Seconds", n2[r] = f3 + "Milliseconds", n2)[o3], $52 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
            if (o3 === c2 || o3 === h) {
              var y2 = this.clone().set(d, 1);
              y2.$d[l2]($52), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
            } else l2 && this.$d[l2]($52);
            return this.init(), this;
          }, m2.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m2.get = function(t3) {
            return this[b2.p(t3)]();
          }, m2.add = function(r2, f3) {
            var d2, l2 = this;
            r2 = Number(r2);
            var $52 = b2.p(f3), y2 = function(t3) {
              var e3 = O(l2);
              return b2.w(e3.date(e3.date() + Math.round(t3 * r2)), l2);
            };
            if ($52 === c2) return this.set(c2, this.$M + r2);
            if ($52 === h) return this.set(h, this.$y + r2);
            if ($52 === a2) return y2(1);
            if ($52 === o2) return y2(7);
            var M3 = (d2 = {}, d2[s] = e2, d2[u] = n, d2[i2] = t2, d2)[$52] || 1, m3 = this.$d.getTime() + r2 * M3;
            return b2.w(m3, this);
          }, m2.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m2.format = function(t3) {
            var e3 = this, n2 = this.$locale();
            if (!this.isValid()) return n2.invalidDate || l;
            var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s2 = this.$H, u2 = this.$m, a3 = this.$M, o3 = n2.weekdays, c3 = n2.months, f3 = n2.meridiem, h2 = function(t4, n3, i4, s3) {
              return t4 && (t4[n3] || t4(e3, r2)) || i4[n3].slice(0, s3);
            }, d2 = function(t4) {
              return b2.s(s2 % 12 || 12, t4, "0");
            }, $52 = f3 || function(t4, e4, n3) {
              var r3 = t4 < 12 ? "AM" : "PM";
              return n3 ? r3.toLowerCase() : r3;
            };
            return r2.replace(y, function(t4, r3) {
              return r3 || function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return b2.s(e3.$y, 4, "0");
                  case "M":
                    return a3 + 1;
                  case "MM":
                    return b2.s(a3 + 1, 2, "0");
                  case "MMM":
                    return h2(n2.monthsShort, a3, c3, 3);
                  case "MMMM":
                    return h2(c3, a3);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return b2.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h2(n2.weekdaysMin, e3.$W, o3, 2);
                  case "ddd":
                    return h2(n2.weekdaysShort, e3.$W, o3, 3);
                  case "dddd":
                    return o3[e3.$W];
                  case "H":
                    return String(s2);
                  case "HH":
                    return b2.s(s2, 2, "0");
                  case "h":
                    return d2(1);
                  case "hh":
                    return d2(2);
                  case "a":
                    return $52(s2, u2, true);
                  case "A":
                    return $52(s2, u2, false);
                  case "m":
                    return String(u2);
                  case "mm":
                    return b2.s(u2, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return b2.s(e3.$s, 2, "0");
                  case "SSS":
                    return b2.s(e3.$ms, 3, "0");
                  case "Z":
                    return i3;
                }
                return null;
              }(t4) || i3.replace(":", "");
            });
          }, m2.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m2.diff = function(r2, d2, l2) {
            var $52, y2 = this, M3 = b2.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e2, g2 = this - m3, D2 = function() {
              return b2.m(y2, m3);
            };
            switch (M3) {
              case h:
                $52 = D2() / 12;
                break;
              case c2:
                $52 = D2();
                break;
              case f2:
                $52 = D2() / 3;
                break;
              case o2:
                $52 = (g2 - v2) / 6048e5;
                break;
              case a2:
                $52 = (g2 - v2) / 864e5;
                break;
              case u:
                $52 = g2 / n;
                break;
              case s:
                $52 = g2 / e2;
                break;
              case i2:
                $52 = g2 / t2;
                break;
              default:
                $52 = g2;
            }
            return l2 ? $52 : b2.a($52);
          }, m2.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m2.$locale = function() {
            return D[this.$L];
          }, m2.locale = function(t3, e3) {
            if (!t3) return this.$L;
            var n2 = this.clone(), r2 = w(t3, e3, true);
            return r2 && (n2.$L = r2), n2;
          }, m2.clone = function() {
            return b2.w(this.$d, this);
          }, m2.toDate = function() {
            return new Date(this.valueOf());
          }, m2.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m2.toISOString = function() {
            return this.$d.toISOString();
          }, m2.toString = function() {
            return this.$d.toUTCString();
          }, M2;
        }(), k2 = _.prototype;
        return O.prototype = k2, [["$ms", r], ["$s", i2], ["$m", s], ["$H", u], ["$W", a2], ["$M", c2], ["$y", h], ["$D", d]].forEach(function(t3) {
          k2[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), O.extend = function(t3, e3) {
          return t3.$i || (t3(e3, _, O), t3.$i = true), O;
        }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
          return O(1e3 * t3);
        }, O.en = D[g], O.Ls = D, O.p = {}, O;
      });
    }
  });

  // node_modules/dayjs/locale/de.js
  var require_de = __commonJS({
    "node_modules/dayjs/locale/de.js"(exports2, module84) {
      !function(e2, n) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = n(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], n) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_locale_de = n(e2.dayjs);
      }(exports2, function(e2) {
        "use strict";
        function n(e3) {
          return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
        }
        var t2 = n(e2), a2 = { s: "ein paar Sekunden", m: ["eine Minute", "einer Minute"], mm: "%d Minuten", h: ["eine Stunde", "einer Stunde"], hh: "%d Stunden", d: ["ein Tag", "einem Tag"], dd: ["%d Tage", "%d Tagen"], M: ["ein Monat", "einem Monat"], MM: ["%d Monate", "%d Monaten"], y: ["ein Jahr", "einem Jahr"], yy: ["%d Jahre", "%d Jahren"] };
        function i2(e3, n2, t3) {
          var i3 = a2[t3];
          return Array.isArray(i3) && (i3 = i3[n2 ? 0 : 1]), i3.replace("%d", e3);
        }
        var r = { name: "de", weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), months: "Januar_Februar_M\xE4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Feb._M\xE4rz_Apr._Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.".split("_"), ordinal: function(e3) {
          return e3 + ".";
        }, weekStart: 1, yearStart: 4, formats: { LTS: "HH:mm:ss", LT: "HH:mm", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, relativeTime: { future: "in %s", past: "vor %s", s: i2, m: i2, mm: i2, h: i2, hh: i2, d: i2, dd: i2, M: i2, MM: i2, y: i2, yy: i2 } };
        return t2.default.locale(r, null, true), r;
      });
    }
  });

  // node_modules/dayjs/locale/el.js
  var require_el = __commonJS({
    "node_modules/dayjs/locale/el.js"(exports2, module84) {
      !function(e2, _) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = _(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], _) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_locale_el = _(e2.dayjs);
      }(exports2, function(e2) {
        "use strict";
        function _(e3) {
          return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
        }
        var t2 = _(e2), d = { name: "el", weekdays: "\u039A\u03C5\u03C1\u03B9\u03B1\u03BA\u03AE_\u0394\u03B5\u03C5\u03C4\u03AD\u03C1\u03B1_\u03A4\u03C1\u03AF\u03C4\u03B7_\u03A4\u03B5\u03C4\u03AC\u03C1\u03C4\u03B7_\u03A0\u03AD\u03BC\u03C0\u03C4\u03B7_\u03A0\u03B1\u03C1\u03B1\u03C3\u03BA\u03B5\u03C5\u03AE_\u03A3\u03AC\u03B2\u03B2\u03B1\u03C4\u03BF".split("_"), weekdaysShort: "\u039A\u03C5\u03C1_\u0394\u03B5\u03C5_\u03A4\u03C1\u03B9_\u03A4\u03B5\u03C4_\u03A0\u03B5\u03BC_\u03A0\u03B1\u03C1_\u03A3\u03B1\u03B2".split("_"), weekdaysMin: "\u039A\u03C5_\u0394\u03B5_\u03A4\u03C1_\u03A4\u03B5_\u03A0\u03B5_\u03A0\u03B1_\u03A3\u03B1".split("_"), months: "\u0399\u03B1\u03BD\u03BF\u03C5\u03AC\u03C1\u03B9\u03BF\u03C2_\u03A6\u03B5\u03B2\u03C1\u03BF\u03C5\u03AC\u03C1\u03B9\u03BF\u03C2_\u039C\u03AC\u03C1\u03C4\u03B9\u03BF\u03C2_\u0391\u03C0\u03C1\u03AF\u03BB\u03B9\u03BF\u03C2_\u039C\u03AC\u03B9\u03BF\u03C2_\u0399\u03BF\u03CD\u03BD\u03B9\u03BF\u03C2_\u0399\u03BF\u03CD\u03BB\u03B9\u03BF\u03C2_\u0391\u03CD\u03B3\u03BF\u03C5\u03C3\u03C4\u03BF\u03C2_\u03A3\u03B5\u03C0\u03C4\u03AD\u03BC\u03B2\u03C1\u03B9\u03BF\u03C2_\u039F\u03BA\u03C4\u03CE\u03B2\u03C1\u03B9\u03BF\u03C2_\u039D\u03BF\u03AD\u03BC\u03B2\u03C1\u03B9\u03BF\u03C2_\u0394\u03B5\u03BA\u03AD\u03BC\u03B2\u03C1\u03B9\u03BF\u03C2".split("_"), monthsShort: "\u0399\u03B1\u03BD_\u03A6\u03B5\u03B2_\u039C\u03B1\u03C1_\u0391\u03C0\u03C1_\u039C\u03B1\u03B9_\u0399\u03BF\u03C5\u03BD_\u0399\u03BF\u03C5\u03BB_\u0391\u03C5\u03B3_\u03A3\u03B5\u03C0\u03C4_\u039F\u03BA\u03C4_\u039D\u03BF\u03B5_\u0394\u03B5\u03BA".split("_"), ordinal: function(e3) {
          return e3;
        }, weekStart: 1, relativeTime: { future: "\u03C3\u03B5 %s", past: "\u03C0\u03C1\u03B9\u03BD %s", s: "\u03BC\u03B5\u03C1\u03B9\u03BA\u03AC \u03B4\u03B5\u03C5\u03C4\u03B5\u03C1\u03CC\u03BB\u03B5\u03C0\u03C4\u03B1", m: "\u03AD\u03BD\u03B1 \u03BB\u03B5\u03C0\u03C4\u03CC", mm: "%d \u03BB\u03B5\u03C0\u03C4\u03AC", h: "\u03BC\u03AF\u03B1 \u03CE\u03C1\u03B1", hh: "%d \u03CE\u03C1\u03B5\u03C2", d: "\u03BC\u03AF\u03B1 \u03BC\u03AD\u03C1\u03B1", dd: "%d \u03BC\u03AD\u03C1\u03B5\u03C2", M: "\u03AD\u03BD\u03B1 \u03BC\u03AE\u03BD\u03B1", MM: "%d \u03BC\u03AE\u03BD\u03B5\u03C2", y: "\u03AD\u03BD\u03B1 \u03C7\u03C1\u03CC\u03BD\u03BF", yy: "%d \u03C7\u03C1\u03CC\u03BD\u03B9\u03B1" }, formats: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" } };
        return t2.default.locale(d, null, true), d;
      });
    }
  });

  // node_modules/dayjs/locale/es.js
  var require_es = __commonJS({
    "node_modules/dayjs/locale/es.js"(exports2, module84) {
      !function(e2, o2) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = o2(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], o2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_locale_es = o2(e2.dayjs);
      }(exports2, function(e2) {
        "use strict";
        function o2(e3) {
          return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
        }
        var s = o2(e2), d = { name: "es", monthsShort: "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), weekdays: "domingo_lunes_martes_mi\xE9rcoles_jueves_viernes_s\xE1bado".split("_"), weekdaysShort: "dom._lun._mar._mi\xE9._jue._vie._s\xE1b.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_s\xE1".split("_"), months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), weekStart: 1, formats: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un d\xEDa", dd: "%d d\xEDas", M: "un mes", MM: "%d meses", y: "un a\xF1o", yy: "%d a\xF1os" }, ordinal: function(e3) {
          return e3 + "\xBA";
        } };
        return s.default.locale(d, null, true), d;
      });
    }
  });

  // node_modules/dayjs/locale/he.js
  var require_he = __commonJS({
    "node_modules/dayjs/locale/he.js"(exports2, module84) {
      !function(Y, M) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = M(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], M) : (Y = "undefined" != typeof globalThis ? globalThis : Y || self).dayjs_locale_he = M(Y.dayjs);
      }(exports2, function(Y) {
        "use strict";
        function M(Y2) {
          return Y2 && "object" == typeof Y2 && "default" in Y2 ? Y2 : { default: Y2 };
        }
        var d = M(Y), e2 = { s: "\u05DE\u05E1\u05E4\u05E8 \u05E9\u05E0\u05D9\u05D5\u05EA", ss: "%d \u05E9\u05E0\u05D9\u05D5\u05EA", m: "\u05D3\u05E7\u05D4", mm: "%d \u05D3\u05E7\u05D5\u05EA", h: "\u05E9\u05E2\u05D4", hh: "%d \u05E9\u05E2\u05D5\u05EA", hh2: "\u05E9\u05E2\u05EA\u05D9\u05D9\u05DD", d: "\u05D9\u05D5\u05DD", dd: "%d \u05D9\u05DE\u05D9\u05DD", dd2: "\u05D9\u05D5\u05DE\u05D9\u05D9\u05DD", M: "\u05D7\u05D5\u05D3\u05E9", MM: "%d \u05D7\u05D5\u05D3\u05E9\u05D9\u05DD", MM2: "\u05D7\u05D5\u05D3\u05E9\u05D9\u05D9\u05DD", y: "\u05E9\u05E0\u05D4", yy: "%d \u05E9\u05E0\u05D9\u05DD", yy2: "\u05E9\u05E0\u05EA\u05D9\u05D9\u05DD" };
        function _(Y2, M2, d2) {
          return (e2[d2 + (2 === Y2 ? "2" : "")] || e2[d2]).replace("%d", Y2);
        }
        var l = { name: "he", weekdays: "\u05E8\u05D0\u05E9\u05D5\u05DF_\u05E9\u05E0\u05D9_\u05E9\u05DC\u05D9\u05E9\u05D9_\u05E8\u05D1\u05D9\u05E2\u05D9_\u05D7\u05DE\u05D9\u05E9\u05D9_\u05E9\u05D9\u05E9\u05D9_\u05E9\u05D1\u05EA".split("_"), weekdaysShort: "\u05D0\u05F3_\u05D1\u05F3_\u05D2\u05F3_\u05D3\u05F3_\u05D4\u05F3_\u05D5\u05F3_\u05E9\u05F3".split("_"), weekdaysMin: "\u05D0\u05F3_\u05D1\u05F3_\u05D2\u05F3_\u05D3\u05F3_\u05D4\u05F3_\u05D5_\u05E9\u05F3".split("_"), months: "\u05D9\u05E0\u05D5\u05D0\u05E8_\u05E4\u05D1\u05E8\u05D5\u05D0\u05E8_\u05DE\u05E8\u05E5_\u05D0\u05E4\u05E8\u05D9\u05DC_\u05DE\u05D0\u05D9_\u05D9\u05D5\u05E0\u05D9_\u05D9\u05D5\u05DC\u05D9_\u05D0\u05D5\u05D2\u05D5\u05E1\u05D8_\u05E1\u05E4\u05D8\u05DE\u05D1\u05E8_\u05D0\u05D5\u05E7\u05D8\u05D5\u05D1\u05E8_\u05E0\u05D5\u05D1\u05DE\u05D1\u05E8_\u05D3\u05E6\u05DE\u05D1\u05E8".split("_"), monthsShort: "\u05D9\u05E0\u05D5_\u05E4\u05D1\u05E8_\u05DE\u05E8\u05E5_\u05D0\u05E4\u05E8_\u05DE\u05D0\u05D9_\u05D9\u05D5\u05E0_\u05D9\u05D5\u05DC_\u05D0\u05D5\u05D2_\u05E1\u05E4\u05D8_\u05D0\u05D5\u05E7_\u05E0\u05D5\u05D1_\u05D3\u05E6\u05DE".split("_"), relativeTime: { future: "\u05D1\u05E2\u05D5\u05D3 %s", past: "\u05DC\u05E4\u05E0\u05D9 %s", s: _, m: _, mm: _, h: _, hh: _, d: _, dd: _, M: _, MM: _, y: _, yy: _ }, ordinal: function(Y2) {
          return Y2;
        }, format: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [\u05D1]MMMM YYYY", LLL: "D [\u05D1]MMMM YYYY HH:mm", LLLL: "dddd, D [\u05D1]MMMM YYYY HH:mm", l: "D/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [\u05D1]MMMM YYYY", LLL: "D [\u05D1]MMMM YYYY HH:mm", LLLL: "dddd, D [\u05D1]MMMM YYYY HH:mm", l: "D/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" } };
        return d.default.locale(l, null, true), l;
      });
    }
  });

  // node_modules/dayjs/locale/it.js
  var require_it = __commonJS({
    "node_modules/dayjs/locale/it.js"(exports2, module84) {
      !function(e2, o2) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = o2(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], o2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_locale_it = o2(e2.dayjs);
      }(exports2, function(e2) {
        "use strict";
        function o2(e3) {
          return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
        }
        var t2 = o2(e2), n = { name: "it", weekdays: "domenica_luned\xEC_marted\xEC_mercoled\xEC_gioved\xEC_venerd\xEC_sabato".split("_"), weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"), weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"), months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"), weekStart: 1, monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"), formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, relativeTime: { future: "tra %s", past: "%s fa", s: "qualche secondo", m: "un minuto", mm: "%d minuti", h: "un' ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, ordinal: function(e3) {
          return e3 + "\xBA";
        } };
        return t2.default.locale(n, null, true), n;
      });
    }
  });

  // node_modules/dayjs/locale/nl.js
  var require_nl = __commonJS({
    "node_modules/dayjs/locale/nl.js"(exports2, module84) {
      !function(e2, a2) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = a2(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], a2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_locale_nl = a2(e2.dayjs);
      }(exports2, function(e2) {
        "use strict";
        function a2(e3) {
          return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
        }
        var d = a2(e2), n = { name: "nl", weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"), months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), ordinal: function(e3) {
          return "[" + e3 + (1 === e3 || 8 === e3 || e3 >= 20 ? "ste" : "de") + "]";
        }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", m: "een minuut", mm: "%d minuten", h: "een uur", hh: "%d uur", d: "een dag", dd: "%d dagen", M: "een maand", MM: "%d maanden", y: "een jaar", yy: "%d jaar" } };
        return d.default.locale(n, null, true), n;
      });
    }
  });

  // node_modules/dayjs/locale/pl.js
  var require_pl = __commonJS({
    "node_modules/dayjs/locale/pl.js"(exports2, module84) {
      !function(e2, t2) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = t2(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], t2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_locale_pl = t2(e2.dayjs);
      }(exports2, function(e2) {
        "use strict";
        function t2(e3) {
          return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
        }
        var i2 = t2(e2);
        function a2(e3) {
          return e3 % 10 < 5 && e3 % 10 > 1 && ~~(e3 / 10) % 10 != 1;
        }
        function n(e3, t3, i3) {
          var n2 = e3 + " ";
          switch (i3) {
            case "m":
              return t3 ? "minuta" : "minut\u0119";
            case "mm":
              return n2 + (a2(e3) ? "minuty" : "minut");
            case "h":
              return t3 ? "godzina" : "godzin\u0119";
            case "hh":
              return n2 + (a2(e3) ? "godziny" : "godzin");
            case "MM":
              return n2 + (a2(e3) ? "miesi\u0105ce" : "miesi\u0119cy");
            case "yy":
              return n2 + (a2(e3) ? "lata" : "lat");
          }
        }
        var r = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrze\u015Bnia_pa\u017Adziernika_listopada_grudnia".split("_"), _ = "stycze\u0144_luty_marzec_kwiecie\u0144_maj_czerwiec_lipiec_sierpie\u0144_wrzesie\u0144_pa\u017Adziernik_listopad_grudzie\u0144".split("_"), s = /D MMMM/, d = function(e3, t3) {
          return s.test(t3) ? r[e3.month()] : _[e3.month()];
        };
        d.s = _, d.f = r;
        var o2 = { name: "pl", weekdays: "niedziela_poniedzia\u0142ek_wtorek_\u015Broda_czwartek_pi\u0105tek_sobota".split("_"), weekdaysShort: "ndz_pon_wt_\u015Br_czw_pt_sob".split("_"), weekdaysMin: "Nd_Pn_Wt_\u015Ar_Cz_Pt_So".split("_"), months: d, monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa\u017A_lis_gru".split("_"), ordinal: function(e3) {
          return e3 + ".";
        }, weekStart: 1, yearStart: 4, relativeTime: { future: "za %s", past: "%s temu", s: "kilka sekund", m: n, mm: n, h: n, hh: n, d: "1 dzie\u0144", dd: "%d dni", M: "miesi\u0105c", MM: n, y: "rok", yy: n }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" } };
        return i2.default.locale(o2, null, true), o2;
      });
    }
  });

  // node_modules/dayjs/locale/pt-br.js
  var require_pt_br = __commonJS({
    "node_modules/dayjs/locale/pt-br.js"(exports2, module84) {
      !function(e2, o2) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = o2(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], o2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_locale_pt_br = o2(e2.dayjs);
      }(exports2, function(e2) {
        "use strict";
        function o2(e3) {
          return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
        }
        var a2 = o2(e2), s = { name: "pt-br", weekdays: "domingo_segunda-feira_ter\xE7a-feira_quarta-feira_quinta-feira_sexta-feira_s\xE1bado".split("_"), weekdaysShort: "dom_seg_ter_qua_qui_sex_s\xE1b".split("_"), weekdaysMin: "Do_2\xAA_3\xAA_4\xAA_5\xAA_6\xAA_S\xE1".split("_"), months: "janeiro_fevereiro_mar\xE7o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), ordinal: function(e3) {
          return e3 + "\xBA";
        }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [\xE0s] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [\xE0s] HH:mm" }, relativeTime: { future: "em %s", past: "h\xE1 %s", s: "poucos segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um m\xEAs", MM: "%d meses", y: "um ano", yy: "%d anos" } };
        return a2.default.locale(s, null, true), s;
      });
    }
  });

  // node_modules/dayjs/locale/pt.js
  var require_pt = __commonJS({
    "node_modules/dayjs/locale/pt.js"(exports2, module84) {
      !function(e2, a2) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = a2(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], a2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_locale_pt = a2(e2.dayjs);
      }(exports2, function(e2) {
        "use strict";
        function a2(e3) {
          return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
        }
        var o2 = a2(e2), t2 = { name: "pt", weekdays: "domingo_segunda-feira_ter\xE7a-feira_quarta-feira_quinta-feira_sexta-feira_s\xE1bado".split("_"), weekdaysShort: "dom_seg_ter_qua_qui_sex_sab".split("_"), weekdaysMin: "Do_2\xAA_3\xAA_4\xAA_5\xAA_6\xAA_Sa".split("_"), months: "janeiro_fevereiro_mar\xE7o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), ordinal: function(e3) {
          return e3 + "\xBA";
        }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [\xE0s] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [\xE0s] HH:mm" }, relativeTime: { future: "em %s", past: "h\xE1 %s", s: "alguns segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um m\xEAs", MM: "%d meses", y: "um ano", yy: "%d anos" } };
        return o2.default.locale(t2, null, true), t2;
      });
    }
  });

  // node_modules/dayjs/plugin/relativeTime.js
  var require_relativeTime = __commonJS({
    "node_modules/dayjs/plugin/relativeTime.js"(exports2, module84) {
      !function(r, e2) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = e2() : "function" == typeof define && define.amd ? define(e2) : (r = "undefined" != typeof globalThis ? globalThis : r || self).dayjs_plugin_relativeTime = e2();
      }(exports2, function() {
        "use strict";
        return function(r, e2, t2) {
          r = r || {};
          var n = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
          function i2(r2, e3, t3, o3) {
            return n.fromToBase(r2, e3, t3, o3);
          }
          t2.en.relativeTime = o2, n.fromToBase = function(e3, n2, i3, d2, u) {
            for (var f2, a2, s, l = i3.$locale().relativeTime || o2, h = r.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m = h.length, c2 = 0; c2 < m; c2 += 1) {
              var y = h[c2];
              y.d && (f2 = d2 ? t2(e3).diff(i3, y.d, true) : i3.diff(e3, y.d, true));
              var p = (r.rounding || Math.round)(Math.abs(f2));
              if (s = f2 > 0, p <= y.r || !y.r) {
                p <= 1 && c2 > 0 && (y = h[c2 - 1]);
                var v = l[y.l];
                u && (p = u("" + p)), a2 = "string" == typeof v ? v.replace("%d", p) : v(p, n2, y.l, s);
                break;
              }
            }
            if (n2) return a2;
            var M = s ? l.future : l.past;
            return "function" == typeof M ? M(a2) : M.replace("%s", a2);
          }, n.to = function(r2, e3) {
            return i2(r2, e3, this, true);
          }, n.from = function(r2, e3) {
            return i2(r2, e3, this);
          };
          var d = function(r2) {
            return r2.$u ? t2.utc() : t2();
          };
          n.toNow = function(r2) {
            return this.to(d(this), r2);
          }, n.fromNow = function(r2) {
            return this.from(d(this), r2);
          };
        };
      });
    }
  });

  // node_modules/dayjs/plugin/localizedFormat.js
  var require_localizedFormat = __commonJS({
    "node_modules/dayjs/plugin/localizedFormat.js"(exports2, module84) {
      !function(e2, t2) {
        "object" == typeof exports2 && "undefined" != typeof module84 ? module84.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_plugin_localizedFormat = t2();
      }(exports2, function() {
        "use strict";
        var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
        return function(t2, o2, n) {
          var r = o2.prototype, i2 = r.format;
          n.en.formats = e2, r.format = function(t3) {
            void 0 === t3 && (t3 = "YYYY-MM-DDTHH:mm:ssZ");
            var o3 = this.$locale().formats, n2 = function(t4, o4) {
              return t4.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t5, n3, r2) {
                var i3 = r2 && r2.toUpperCase();
                return n3 || o4[r2] || e2[r2] || o4[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t6, o5) {
                  return t6 || o5.slice(1);
                });
              });
            }(t3, void 0 === o3 ? {} : o3);
            return i2.call(this, n2);
          };
        };
      });
    }
  });

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports2, module84) {
      (function(global2, factory) {
        "use strict";
        if (typeof module84 === "object" && typeof module84.exports === "object") {
          module84.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports2, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf = arr.indexOf;
        var class2type = {};
        var toString3 = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction2 = function isFunction3(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc) {
          doc = doc || document2;
          var i2, val, script = doc.createElement("script");
          script.text = code;
          if (node) {
            for (i2 in preservedScriptAttributes) {
              val = node[i2] || node.getAttribute && node.getAttribute(i2);
              if (val) {
                script.setAttribute(i2, val);
              }
            }
          }
          doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString3.call(obj)] || "object" : typeof obj;
        }
        var version4 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery = function(selector, context) {
          return new jQuery.fn.init(selector, context);
        };
        jQuery.fn = jQuery.prototype = {
          // The current version of jQuery being used
          jquery: version4,
          constructor: jQuery,
          // The default length of a jQuery object is 0
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          // Get the Nth element in the matched element set OR
          // Get the whole matched element set as a clean array
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          // Take an array of elements and push it onto the stack
          // (returning the new matched element set)
          pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          // Execute a callback for every element in the matched set.
          each: function(callback) {
            return jQuery.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i2) {
              return callback.call(elem, i2, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i2) {
              return (i2 + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i2) {
              return i2 % 2;
            }));
          },
          eq: function(i2) {
            var len = this.length, j = +i2 + (i2 < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          // For internal use only.
          // Behaves like an Array's method, not like a jQuery method.
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery.extend = jQuery.fn.extend = function() {
          var options6, name2, src, copy, copyIsArray, clone3, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i2] || {};
            i2++;
          }
          if (typeof target !== "object" && !isFunction2(target)) {
            target = {};
          }
          if (i2 === length) {
            target = this;
            i2--;
          }
          for (; i2 < length; i2++) {
            if ((options6 = arguments[i2]) != null) {
              for (name2 in options6) {
                copy = options6[name2];
                if (name2 === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name2];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone3 = [];
                  } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                    clone3 = {};
                  } else {
                    clone3 = src;
                  }
                  copyIsArray = false;
                  target[name2] = jQuery.extend(deep, clone3, copy);
                } else if (copy !== void 0) {
                  target[name2] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery.extend({
          // Unique for each copy of jQuery on the page
          expando: "jQuery" + (version4 + Math.random()).replace(/\D/g, ""),
          // Assume jQuery is ready without the ready module
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString3.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name2;
            for (name2 in obj) {
              return false;
            }
            return true;
          },
          // Evaluates a script in a provided context; falls back to the global one
          // if not specified.
          globalEval: function(code, options6, doc) {
            DOMEval(code, { nonce: options6 && options6.nonce }, doc);
          },
          each: function(obj, callback) {
            var length, i2 = 0;
            if (isArrayLike2(obj)) {
              length = obj.length;
              for (; i2 < length; i2++) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            } else {
              for (i2 in obj) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          // Retrieve the text value of an array of DOM nodes
          text: function(elem) {
            var node, ret = "", i2 = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i2++]) {
                ret += jQuery.text(node);
              }
            }
            if (nodeType === 1 || nodeType === 11) {
              return elem.textContent;
            }
            if (nodeType === 9) {
              return elem.documentElement.textContent;
            }
            if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          },
          // results is for internal usage only
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike2(Object(arr2))) {
                jQuery.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i2) {
            return arr2 == null ? -1 : indexOf.call(arr2, elem, i2);
          },
          isXMLDoc: function(elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
          },
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          merge: function(first, second) {
            var len = +second.length, j = 0, i2 = first.length;
            for (; j < len; j++) {
              first[i2++] = second[j];
            }
            first.length = i2;
            return first;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches2 = [], i2 = 0, length = elems.length, callbackExpect = !invert;
            for (; i2 < length; i2++) {
              callbackInverse = !callback(elems[i2], i2);
              if (callbackInverse !== callbackExpect) {
                matches2.push(elems[i2]);
              }
            }
            return matches2;
          },
          // arg is for internal usage only
          map: function(elems, callback, arg) {
            var length, value, i2 = 0, ret = [];
            if (isArrayLike2(elems)) {
              length = elems.length;
              for (; i2 < length; i2++) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i2 in elems) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          // A global GUID counter for objects
          guid: 1,
          // jQuery.support is not used in Core but other projects attach their
          // properties to it so it needs to exist.
          support
        });
        if (typeof Symbol === "function") {
          jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i, name2) {
            class2type["[object " + name2 + "]"] = name2.toLowerCase();
          }
        );
        function isArrayLike2(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType(obj);
          if (isFunction2(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        function nodeName(elem, name2) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name2.toLowerCase();
        }
        var pop = arr.pop;
        var sort2 = arr.sort;
        var splice4 = arr.splice;
        var whitespace = "[\\x20\\t\\r\\n\\f]";
        var rtrimCSS = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        );
        jQuery.contains = function(a2, b2) {
          var bup = b2 && b2.parentNode;
          return a2 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
          // IE doesn't have `contains` on SVG.
          (a2.contains ? a2.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
        };
        var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
        function fcssescape(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }
        jQuery.escapeSelector = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        var preferredDoc = document2, pushNative = push;
        (function() {
          var i2, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches2, expando2 = jQuery.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a2, b2) {
            if (a2 === b2) {
              hasDuplicate = true;
            }
            return 0;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
          "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp(
              "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
              "i"
            ),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
            var high = "0x" + escape2.slice(1) - 65536;
            if (nonHex) {
              return nonHex;
            }
            return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, unloadHandler = function() {
            setDocument();
          }, inDisabledFieldset = addCombinator(
            function(elem) {
              return elem.disabled === true && nodeName(elem, "fieldset");
            },
            { dir: "parentNode", next: "legend" }
          );
          function safeActiveElement() {
            try {
              return document3.activeElement;
            } catch (err) {
            }
          }
          try {
            push2.apply(
              arr = slice.call(preferredDoc.childNodes),
              preferredDoc.childNodes
            );
            arr[preferredDoc.childNodes.length].nodeType;
          } catch (e2) {
            push2 = {
              apply: function(target, els) {
                pushNative.apply(target, slice.call(els));
              },
              call: function(target) {
                pushNative.apply(target, slice.call(arguments, 1));
              }
            };
          }
          function find2(selector, context, results, seed) {
            var m, i3, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed) {
              setDocument(context);
              context = context || document3;
              if (documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                  if (m = match[1]) {
                    if (nodeType === 9) {
                      if (elem = context.getElementById(m)) {
                        if (elem.id === m) {
                          push2.call(results, elem);
                          return results;
                        }
                      } else {
                        return results;
                      }
                    } else {
                      if (newContext && (elem = newContext.getElementById(m)) && find2.contains(context, elem) && elem.id === m) {
                        push2.call(results, elem);
                        return results;
                      }
                    }
                  } else if (match[2]) {
                    push2.apply(results, context.getElementsByTagName(selector));
                    return results;
                  } else if ((m = match[3]) && context.getElementsByClassName) {
                    push2.apply(results, context.getElementsByClassName(m));
                    return results;
                  }
                }
                if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                  newSelector = selector;
                  newContext = context;
                  if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    if (newContext != context || !support.scope) {
                      if (nid = context.getAttribute("id")) {
                        nid = jQuery.escapeSelector(nid);
                      } else {
                        context.setAttribute("id", nid = expando2);
                      }
                    }
                    groups = tokenize(selector);
                    i3 = groups.length;
                    while (i3--) {
                      groups[i3] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i3]);
                    }
                    newSelector = groups.join(",");
                  }
                  try {
                    push2.apply(
                      results,
                      newContext.querySelectorAll(newSelector)
                    );
                    return results;
                  } catch (qsaError) {
                    nonnativeSelectorCache(selector, true);
                  } finally {
                    if (nid === expando2) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
          }
          function createCache() {
            var keys3 = [];
            function cache(key, value) {
              if (keys3.push(key + " ") > Expr.cacheLength) {
                delete cache[keys3.shift()];
              }
              return cache[key + " "] = value;
            }
            return cache;
          }
          function markFunction(fn) {
            fn[expando2] = true;
            return fn;
          }
          function assert(fn) {
            var el = document3.createElement("fieldset");
            try {
              return !!fn(el);
            } catch (e2) {
              return false;
            } finally {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
              el = null;
            }
          }
          function createInputPseudo(type) {
            return function(elem) {
              return nodeName(elem, "input") && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
            };
          }
          function createDisabledPseudo(disabled) {
            return function(elem) {
              if ("form" in elem) {
                if (elem.parentNode && elem.disabled === false) {
                  if ("label" in elem) {
                    if ("label" in elem.parentNode) {
                      return elem.parentNode.disabled === disabled;
                    } else {
                      return elem.disabled === disabled;
                    }
                  }
                  return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                  elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
              } else if ("label" in elem) {
                return elem.disabled === disabled;
              }
              return false;
            };
          }
          function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches3) {
                var j, matchIndexes = fn([], seed.length, argument), i3 = matchIndexes.length;
                while (i3--) {
                  if (seed[j = matchIndexes[i3]]) {
                    seed[j] = !(matches3[j] = seed[j]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          function setDocument(node) {
            var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
              return document3;
            }
            document3 = doc;
            documentElement2 = document3.documentElement;
            documentIsHTML = !jQuery.isXMLDoc(document3);
            matches2 = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
            if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
              subWindow.addEventListener("unload", unloadHandler);
            }
            support.getById = assert(function(el) {
              documentElement2.appendChild(el).id = jQuery.expando;
              return !document3.getElementsByName || !document3.getElementsByName(jQuery.expando).length;
            });
            support.disconnectedMatch = assert(function(el) {
              return matches2.call(el, "*");
            });
            support.scope = assert(function() {
              return document3.querySelectorAll(":scope");
            });
            support.cssHas = assert(function() {
              try {
                document3.querySelector(":has(*,:jqfake)");
                return false;
              } catch (e2) {
                return true;
              }
            });
            if (support.getById) {
              Expr.filter.ID = function(id2) {
                var attrId = id2.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
              Expr.find.ID = function(id2, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var elem = context.getElementById(id2);
                  return elem ? [elem] : [];
                }
              };
            } else {
              Expr.filter.ID = function(id2) {
                var attrId = id2.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
              Expr.find.ID = function(id2, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var node2, i3, elems, elem = context.getElementById(id2);
                  if (elem) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id2) {
                      return [elem];
                    }
                    elems = context.getElementsByName(id2);
                    i3 = 0;
                    while (elem = elems[i3++]) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id2) {
                        return [elem];
                      }
                    }
                  }
                  return [];
                }
              };
            }
            Expr.find.TAG = function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else {
                return context.querySelectorAll(tag);
              }
            };
            Expr.find.CLASS = function(className2, context) {
              if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                return context.getElementsByClassName(className2);
              }
            };
            rbuggyQSA = [];
            assert(function(el) {
              var input2;
              documentElement2.appendChild(el).innerHTML = "<a id='" + expando2 + "' href='' disabled='disabled'></a><select id='" + expando2 + "-\r\\' disabled='disabled'><option selected=''></option></select>";
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando2 + "-]").length) {
                rbuggyQSA.push("~=");
              }
              if (!el.querySelectorAll("a#" + expando2 + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              input2 = document3.createElement("input");
              input2.setAttribute("type", "hidden");
              el.appendChild(input2).setAttribute("name", "D");
              documentElement2.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              input2 = document3.createElement("input");
              input2.setAttribute("name", "");
              el.appendChild(input2);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
              }
            });
            if (!support.cssHas) {
              rbuggyQSA.push(":has");
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            sortOrder = function(a2, b2) {
              if (a2 === b2) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a2.ownerDocument || a2) == (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : (
                // Otherwise we know they are disconnected
                1
              );
              if (compare & 1 || !support.sortDetached && b2.compareDocumentPosition(a2) === compare) {
                if (a2 === document3 || a2.ownerDocument == preferredDoc && find2.contains(preferredDoc, a2)) {
                  return -1;
                }
                if (b2 === document3 || b2.ownerDocument == preferredDoc && find2.contains(preferredDoc, b2)) {
                  return 1;
                }
                return sortInput ? indexOf.call(sortInput, a2) - indexOf.call(sortInput, b2) : 0;
              }
              return compare & 4 ? -1 : 1;
            };
            return document3;
          }
          find2.matches = function(expr, elements) {
            return find2(expr, null, null, elements);
          };
          find2.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches2.call(elem, expr);
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e2) {
                nonnativeSelectorCache(expr, true);
              }
            }
            return find2(expr, document3, null, [elem]).length > 0;
          };
          find2.contains = function(context, elem) {
            if ((context.ownerDocument || context) != document3) {
              setDocument(context);
            }
            return jQuery.contains(context, elem);
          };
          find2.attr = function(elem, name2) {
            if ((elem.ownerDocument || elem) != document3) {
              setDocument(elem);
            }
            var fn = Expr.attrHandle[name2.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name2.toLowerCase()) ? fn(elem, name2, !documentIsHTML) : void 0;
            if (val !== void 0) {
              return val;
            }
            return elem.getAttribute(name2);
          };
          find2.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          jQuery.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i3 = 0;
            hasDuplicate = !support.sortStable;
            sortInput = !support.sortStable && slice.call(results, 0);
            sort2.call(results, sortOrder);
            if (hasDuplicate) {
              while (elem = results[i3++]) {
                if (elem === results[i3]) {
                  j = duplicates.push(i3);
                }
              }
              while (j--) {
                splice4.call(results, duplicates[j], 1);
              }
            }
            sortInput = null;
            return results;
          };
          jQuery.fn.uniqueSort = function() {
            return this.pushStack(jQuery.uniqueSort(slice.apply(this)));
          };
          Expr = jQuery.expr = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              ATTR: function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                  match[3] = " " + match[3] + " ";
                }
                return match.slice(0, 4);
              },
              CHILD: function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                  if (!match[3]) {
                    find2.error(match[0]);
                  }
                  match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                  match[5] = +(match[7] + match[8] || match[3] === "odd");
                } else if (match[3]) {
                  find2.error(match[0]);
                }
                return match;
              },
              PSEUDO: function(match) {
                var excess, unquoted = !match[6] && match[2];
                if (matchExpr.CHILD.test(match[0])) {
                  return null;
                }
                if (match[3]) {
                  match[2] = match[4] || match[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
                (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match[0] = match[0].slice(0, excess);
                  match[2] = unquoted.slice(0, excess);
                }
                return match.slice(0, 3);
              }
            },
            filter: {
              TAG: function(nodeNameSelector) {
                var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return nodeName(elem, expectedNodeName);
                };
              },
              CLASS: function(className2) {
                var pattern = classCache[className2 + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className2 + "(" + whitespace + "|$)")) && classCache(className2, function(elem) {
                  return pattern.test(
                    typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                  );
                });
              },
              ATTR: function(name2, operator, check2) {
                return function(elem) {
                  var result = find2.attr(elem, name2);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  if (operator === "=") {
                    return result === check2;
                  }
                  if (operator === "!=") {
                    return result !== check2;
                  }
                  if (operator === "^=") {
                    return check2 && result.indexOf(check2) === 0;
                  }
                  if (operator === "*=") {
                    return check2 && result.indexOf(check2) > -1;
                  }
                  if (operator === "$=") {
                    return check2 && result.slice(-check2.length) === check2;
                  }
                  if (operator === "~=") {
                    return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check2) > -1;
                  }
                  if (operator === "|=") {
                    return result === check2 || result.slice(0, check2.length + 1) === check2 + "-";
                  }
                  return false;
                };
              },
              CHILD: function(type, what, _argument, first, last2) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last2 === 0 ? (
                  // Shortcut for :nth-*(n)
                  function(elem) {
                    return !!elem.parentNode;
                  }
                ) : function(elem, _context, xml) {
                  var cache, outerCache, node, nodeIndex, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent2 = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                  if (parent2) {
                    if (simple) {
                      while (dir2) {
                        node = elem;
                        while (node = node[dir2]) {
                          if (ofType ? nodeName(node, name2) : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start2 = dir2 = type === "only" && !start2 && "nextSibling";
                      }
                      return true;
                    }
                    start2 = [forward ? parent2.firstChild : parent2.lastChild];
                    if (forward && useCache) {
                      outerCache = parent2[expando2] || (parent2[expando2] = {});
                      cache = outerCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex && cache[2];
                      node = nodeIndex && parent2.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                      (diff = nodeIndex = 0) || start2.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          outerCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      if (useCache) {
                        outerCache = elem[expando2] || (elem[expando2] = {});
                        cache = outerCache[type] || [];
                        nodeIndex = cache[0] === dirruns && cache[1];
                        diff = nodeIndex;
                      }
                      if (diff === false) {
                        while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start2.pop()) {
                          if ((ofType ? nodeName(node, name2) : node.nodeType === 1) && ++diff) {
                            if (useCache) {
                              outerCache = node[expando2] || (node[expando2] = {});
                              outerCache[type] = [dirruns, diff];
                            }
                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }
                    diff -= last2;
                    return diff === first || diff % first === 0 && diff / first >= 0;
                  }
                };
              },
              PSEUDO: function(pseudo, argument) {
                var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find2.error("unsupported pseudo: " + pseudo);
                if (fn[expando2]) {
                  return fn(argument);
                }
                if (fn.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches3) {
                    var idx, matched = fn(seed, argument), i3 = matched.length;
                    while (i3--) {
                      idx = indexOf.call(seed, matched[i3]);
                      seed[idx] = !(matches3[idx] = matched[i3]);
                    }
                  }) : function(elem) {
                    return fn(elem, 0, args);
                  };
                }
                return fn;
              }
            },
            pseudos: {
              // Potentially complex pseudos
              not: markFunction(function(selector) {
                var input2 = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
                return matcher[expando2] ? markFunction(function(seed, matches3, _context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
                  while (i3--) {
                    if (elem = unmatched[i3]) {
                      seed[i3] = !(matches3[i3] = elem);
                    }
                  }
                }) : function(elem, _context, xml) {
                  input2[0] = elem;
                  matcher(input2, null, xml, results);
                  input2[0] = null;
                  return !results.pop();
                };
              }),
              has: markFunction(function(selector) {
                return function(elem) {
                  return find2(selector, elem).length > 0;
                };
              }),
              contains: markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
                };
              }),
              // "Whether an element is represented by a :lang() selector
              // is based solely on the element's language value
              // being equal to the identifier C,
              // or beginning with the identifier C immediately followed by "-".
              // The matching of C against the element's language value is performed case-insensitively.
              // The identifier C does not have to be a valid language name."
              // https://www.w3.org/TR/selectors/#lang-pseudo
              lang: markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  find2.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              // Miscellaneous
              target: function(elem) {
                var hash = window2.location && window2.location.hash;
                return hash && hash.slice(1) === elem.id;
              },
              root: function(elem) {
                return elem === documentElement2;
              },
              focus: function(elem) {
                return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              // Boolean properties
              enabled: createDisabledPseudo(false),
              disabled: createDisabledPseudo(true),
              checked: function(elem) {
                return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
              },
              selected: function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              // Contents
              empty: function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              parent: function(elem) {
                return !Expr.pseudos.empty(elem);
              },
              // Element/input types
              header: function(elem) {
                return rheader.test(elem.nodeName);
              },
              input: function(elem) {
                return rinputs.test(elem.nodeName);
              },
              button: function(elem) {
                return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
              },
              text: function(elem) {
                var attr;
                return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
                // New HTML5 attribute values (e.g., "search") appear
                // with elem.type === "text"
                ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              // Position-in-collection
              first: createPositionalPseudo(function() {
                return [0];
              }),
              last: createPositionalPseudo(function(_matchIndexes, length) {
                return [length - 1];
              }),
              eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              even: createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 0;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              odd: createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 1;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3;
                if (argument < 0) {
                  i3 = argument + length;
                } else if (argument > length) {
                  i3 = length;
                } else {
                  i3 = argument;
                }
                for (; --i3 >= 0; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3 = argument < 0 ? argument + length : argument;
                for (; ++i3 < length; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos.nth = Expr.pseudos.eq;
          for (i2 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i2] = createInputPseudo(i2);
          }
          for (i2 in { submit: true, reset: true }) {
            Expr.pseudos[i2] = createButtonPseudo(i2);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          function tokenize(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                  soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match = rleadingCombinator.exec(soFar)) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  // Cast descendant combinators to space
                  type: match[0].replace(rtrimCSS, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            if (parseOnly) {
              return soFar.length;
            }
            return soFar ? find2.error(selector) : (
              // Cache the tokens
              tokenCache(selector, groups).slice(0)
            );
          }
          function toSelector(tokens) {
            var i3 = 0, len = tokens.length, selector = "";
            for (; i3 < len; i3++) {
              selector += tokens[i3].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? (
              // Check against closest ancestor/preceding element
              function(elem, context, xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    return matcher(elem, context, xml);
                  }
                }
                return false;
              }
            ) : (
              // Check against all ancestor/preceding elements
              function(elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                if (xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      if (matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                } else {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      outerCache = elem[expando2] || (elem[expando2] = {});
                      if (skip && nodeName(elem, skip)) {
                        elem = elem[dir2] || elem;
                      } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                        return newCache[2] = oldCache[2];
                      } else {
                        outerCache[key] = newCache;
                        if (newCache[2] = matcher(elem, context, xml)) {
                          return true;
                        }
                      }
                    }
                  }
                }
                return false;
              }
            );
          }
          function elementMatcher(matchers2) {
            return matchers2.length > 1 ? function(elem, context, xml) {
              var i3 = matchers2.length;
              while (i3--) {
                if (!matchers2[i3](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers2[0];
          }
          function multipleContexts(selector, contexts, results) {
            var i3 = 0, len = contexts.length;
            for (; i3 < len; i3++) {
              find2(selector, contexts[i3], results);
            }
            return results;
          }
          function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map != null;
            for (; i3 < len; i3++) {
              if (elem = unmatched[i3]) {
                if (!filter || filter(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map.push(i3);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando2]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando2]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i3, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
              if (matcher) {
                matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                  // ...intermediate processing is necessary
                  []
                ) : (
                  // ...otherwise use results directly
                  results
                );
                matcher(matcherIn, matcherOut, context, xml);
              } else {
                matcherOut = matcherIn;
              }
              if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i3 = temp.length;
                while (i3--) {
                  if (elem = temp[i3]) {
                    matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i3 = matcherOut.length;
                    while (i3--) {
                      if (elem = matcherOut[i3]) {
                        temp.push(matcherIn[i3] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i3 = matcherOut.length;
                  while (i3--) {
                    if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i3]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense(
                  matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                );
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf.call(checkContext, elem) > -1;
            }, implicitRelative, true), matchers2 = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i3 < len; i3++) {
              if (matcher = Expr.relative[tokens[i3].type]) {
                matchers2 = [addCombinator(elementMatcher(matchers2), matcher)];
              } else {
                matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
                if (matcher[expando2]) {
                  j = ++i3;
                  for (; j < len; j++) {
                    if (Expr.relative[tokens[j].type]) {
                      break;
                    }
                  }
                  return setMatcher(
                    i3 > 1 && elementMatcher(matchers2),
                    i3 > 1 && toSelector(
                      // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                      tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })
                    ).replace(rtrimCSS, "$1"),
                    matcher,
                    i3 < j && matcherFromTokens(tokens.slice(i3, j)),
                    j < len && matcherFromTokens(tokens = tokens.slice(j)),
                    j < len && toSelector(tokens)
                  );
                }
                matchers2.push(matcher);
              }
            }
            return elementMatcher(matchers2);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context == document3 || context || outermost;
              }
              for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
                if (byElement && elem) {
                  j = 0;
                  if (!context && elem.ownerDocument != document3) {
                    setDocument(elem);
                    xml = !documentIsHTML;
                  }
                  while (matcher = elementMatchers[j++]) {
                    if (matcher(elem, context || document3, xml)) {
                      push2.call(results, elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i3;
              if (bySet && i3 !== matchedCount) {
                j = 0;
                while (matcher = setMatchers[j++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i3--) {
                      if (!(unmatched[i3] || setMatched[i3])) {
                        setMatched[i3] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  jQuery.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          function compile(selector, match) {
            var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match) {
                match = tokenize(selector);
              }
              i3 = match.length;
              while (i3--) {
                cached = matcherFromTokens(match[i3]);
                if (cached[expando2]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(
                selector,
                matcherFromGroupMatchers(elementMatchers, setMatchers)
              );
              cached.selector = selector;
            }
            return cached;
          }
          function select(selector, context, results, seed) {
            var i3, tokens, token, type, find3, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
              tokens = match[0] = match[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find.ID(
                  token.matches[0].replace(runescape, funescape),
                  context
                ) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i3 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
              while (i3--) {
                token = tokens[i3];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find3 = Expr.find[type]) {
                  if (seed = find3(
                    token.matches[0].replace(runescape, funescape),
                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                  )) {
                    tokens.splice(i3, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile(selector, match))(
              seed,
              context,
              !documentIsHTML,
              results,
              !context || rsibling.test(selector) && testContext(context.parentNode) || context
            );
            return results;
          }
          support.sortStable = expando2.split("").sort(sortOrder).join("") === expando2;
          setDocument();
          support.sortDetached = assert(function(el) {
            return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
          });
          jQuery.find = find2;
          jQuery.expr[":"] = jQuery.expr.pseudos;
          jQuery.unique = jQuery.uniqueSort;
          find2.compile = compile;
          find2.select = select;
          find2.setDocument = setDocument;
          find2.tokenize = tokenize;
          find2.escape = jQuery.escapeSelector;
          find2.getText = jQuery.text;
          find2.isXML = jQuery.isXMLDoc;
          find2.selectors = jQuery.expr;
          find2.support = jQuery.support;
          find2.uniqueSort = jQuery.uniqueSort;
        })();
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n, elem) {
          var matched = [];
          for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
              matched.push(n);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery.expr.match.needsContext;
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction2(qualifier)) {
            return jQuery.grep(elements, function(elem, i2) {
              return !!qualifier.call(elem, i2, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery.grep(elements, function(elem) {
              return indexOf.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery.filter(qualifier, elements, not);
        }
        jQuery.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery.fn.extend({
          find: function(selector) {
            var i2, ret, len = this.length, self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery(selector).filter(function() {
                for (i2 = 0; i2 < len; i2++) {
                  if (jQuery.contains(self2[i2], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i2 = 0; i2 < len; i2++) {
              jQuery.find(selector, self2[i2], ret);
            }
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              // If this is a positional/relative selector, check membership in the returned set
              // so $("p:first").is("p:last") won't return true for a doc with two "p".
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init2 = jQuery.fn.init = function(selector, context, root2) {
          var match, elem;
          if (!selector) {
            return this;
          }
          root2 = root2 || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
              if (match[1]) {
                context = context instanceof jQuery ? context[0] : context;
                jQuery.merge(this, jQuery.parseHTML(
                  match[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                  for (match in context) {
                    if (isFunction2(this[match])) {
                      this[match](context[match]);
                    } else {
                      this.attr(match, context[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root2).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction2(selector)) {
            return root2.ready !== void 0 ? root2.ready(selector) : (
              // Execute immediately if ready is not present
              selector(jQuery)
            );
          }
          return jQuery.makeArray(selector, this);
        };
        init2.prototype = jQuery.fn;
        rootjQuery = jQuery(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery.fn.extend({
          has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
              var i2 = 0;
              for (; i2 < l; i2++) {
                if (jQuery.contains(this, targets[i2])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i2 = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i2 < l; i2++) {
                for (cur = this[i2]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                    // Don't pass non-elements to jQuery#find
                    cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
                  ))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
          },
          // Determine the position of an element within the set
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(
              this,
              // If it receives a jQuery object, the first element is used
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery.uniqueSort(
                jQuery.merge(this.get(), jQuery(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery.each({
          parent: function(elem) {
            var parent2 = elem.parentNode;
            return parent2 && parent2.nodeType !== 11 ? parent2 : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery.merge([], elem.childNodes);
          }
        }, function(name2, fn) {
          jQuery.fn[name2] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name2.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name2]) {
                jQuery.uniqueSort(matched);
              }
              if (rparentsprev.test(name2)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options6) {
          var object = {};
          jQuery.each(options6.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery.Callbacks = function(options6) {
          options6 = typeof options6 === "string" ? createOptions(options6) : jQuery.extend({}, options6);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options6.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options6.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options6.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self2 = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add4(args) {
                  jQuery.each(args, function(_, arg) {
                    if (isFunction2(arg)) {
                      if (!options6.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType(arg) !== "string") {
                      add4(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            // Remove a callback from the list
            remove: function() {
              jQuery.each(arguments, function(_, arg) {
                var index2;
                while ((index2 = jQuery.inArray(arg, list, index2)) > -1) {
                  list.splice(index2, 1);
                  if (index2 <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
              return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        function Identity(v) {
          return v;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve, reject, noValue) {
          var method;
          try {
            if (value && isFunction2(method = value.promise)) {
              method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction2(method = value.then)) {
              method.call(value, resolve, reject);
            } else {
              resolve.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery.extend({
          Deferred: function(func) {
            var tuples = [
              // action, add listener, callbacks,
              // ... .then handlers, argument index, [final state]
              [
                "notify",
                "progress",
                jQuery.Callbacks("memory"),
                jQuery.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery.Callbacks("once memory"),
                jQuery.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery.Callbacks("once memory"),
                jQuery.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn) {
                return promise.then(null, fn);
              },
              // Keep pipe for back-compat
              pipe: function() {
                var fns = arguments;
                return jQuery.Deferred(function(newDefer) {
                  jQuery.each(tuples, function(_i, tuple) {
                    var fn = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn && fn.apply(this, arguments);
                      if (returned && isFunction2(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction2(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special),
                            resolve(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process2 = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e2) {
                        if (jQuery.Deferred.exceptionHook) {
                          jQuery.Deferred.exceptionHook(
                            e2,
                            process2.error
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e2];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process2();
                    } else {
                      if (jQuery.Deferred.getErrorHook) {
                        process2.error = jQuery.Deferred.getErrorHook();
                      } else if (jQuery.Deferred.getStackHook) {
                        process2.error = jQuery.Deferred.getStackHook();
                      }
                      window2.setTimeout(process2);
                    }
                  };
                }
                return jQuery.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction2(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction2(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction2(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              // Get a promise for this deferred
              // If obj is provided, the promise aspect is added to the object
              promise: function(obj) {
                return obj != null ? jQuery.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery.each(tuples, function(i2, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  // rejected_callbacks.disable
                  // fulfilled_callbacks.disable
                  tuples[3 - i2][2].disable,
                  // rejected_handlers.disable
                  // fulfilled_handlers.disable
                  tuples[3 - i2][3].disable,
                  // progress_callbacks.lock
                  tuples[0][2].lock,
                  // progress_handlers.lock
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          // Deferred helper
          when: function(singleValue) {
            var remaining = arguments.length, i2 = remaining, resolveContexts = Array(i2), resolveValues = slice.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i3) {
              return function(value) {
                resolveContexts[i3] = this;
                resolveValues[i3] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  primary.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                primary.done(updateFunc(i2)).resolve,
                primary.reject,
                !remaining
              );
              if (primary.state() === "pending" || isFunction2(resolveValues[i2] && resolveValues[i2].then)) {
                return primary.then();
              }
            }
            while (i2--) {
              adoptValue(resolveValues[i2], updateFunc(i2), primary.reject);
            }
            return primary.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery.Deferred.exceptionHook = function(error, asyncError) {
          if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
            window2.console.warn(
              "jQuery.Deferred exception: " + error.message,
              error.stack,
              asyncError
            );
          }
        };
        jQuery.readyException = function(error) {
          window2.setTimeout(function() {
            throw error;
          });
        };
        var readyList = jQuery.Deferred();
        jQuery.fn.ready = function(fn) {
          readyList.then(fn).catch(function(error) {
            jQuery.readyException(error);
          });
          return this;
        };
        jQuery.extend({
          // Is the DOM ready to be used? Set to true once it occurs.
          isReady: false,
          // A counter to track how many items to wait for before
          // the ready event fires. See trac-6781
          readyWait: 1,
          // Handle when the DOM is ready
          ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
              return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery]);
          }
        });
        jQuery.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
          var i2 = 0, len = elems.length, bulk = key == null;
          if (toType(key) === "object") {
            chainable = true;
            for (i2 in key) {
              access(elems, fn, i2, key[i2], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction2(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn.call(elems, value);
                fn = null;
              } else {
                bulk = fn;
                fn = function(elem, _key, value2) {
                  return bulk.call(jQuery(elem), value2);
                };
              }
            }
            if (fn) {
              for (; i2 < len; i2++) {
                fn(
                  elems[i2],
                  key,
                  raw ? value : value.call(elems[i2], i2, fn(elems[i2], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn.call(elems);
          }
          return len ? fn(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          this.expando = jQuery.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data2, value) {
            var prop, cache = this.cache(owner);
            if (typeof data2 === "string") {
              cache[camelCase(data2)] = value;
            } else {
              for (prop in data2) {
                cache[camelCase(prop)] = data2[prop];
              }
            }
            return cache;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : (
              // Always use camelCase key (gh-2257)
              owner[this.expando] && owner[this.expando][camelCase(key)]
            );
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i2, cache = owner[this.expando];
            if (cache === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
              }
              i2 = key.length;
              while (i2--) {
                delete cache[key[i2]];
              }
            }
            if (key === void 0 || jQuery.isEmptyObject(cache)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== void 0 && !jQuery.isEmptyObject(cache);
          }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData2(data2) {
          if (data2 === "true") {
            return true;
          }
          if (data2 === "false") {
            return false;
          }
          if (data2 === "null") {
            return null;
          }
          if (data2 === +data2 + "") {
            return +data2;
          }
          if (rbrace.test(data2)) {
            return JSON.parse(data2);
          }
          return data2;
        }
        function dataAttr(elem, key, data2) {
          var name2;
          if (data2 === void 0 && elem.nodeType === 1) {
            name2 = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data2 = elem.getAttribute(name2);
            if (typeof data2 === "string") {
              try {
                data2 = getData2(data2);
              } catch (e2) {
              }
              dataUser.set(elem, key, data2);
            } else {
              data2 = void 0;
            }
          }
          return data2;
        }
        jQuery.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name2, data2) {
            return dataUser.access(elem, name2, data2);
          },
          removeData: function(elem, name2) {
            dataUser.remove(elem, name2);
          },
          // TODO: Now that all calls to _data and _removeData have been replaced
          // with direct calls to dataPriv methods, these can be deprecated.
          _data: function(elem, name2, data2) {
            return dataPriv.access(elem, name2, data2);
          },
          _removeData: function(elem, name2) {
            dataPriv.remove(elem, name2);
          }
        });
        jQuery.fn.extend({
          data: function(key, value) {
            var i2, name2, data2, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data2 = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i2 = attrs.length;
                  while (i2--) {
                    if (attrs[i2]) {
                      name2 = attrs[i2].name;
                      if (name2.indexOf("data-") === 0) {
                        name2 = camelCase(name2.slice(5));
                        dataAttr(elem, name2, data2[name2]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data2;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data3;
              if (elem && value2 === void 0) {
                data3 = dataUser.get(elem, key);
                if (data3 !== void 0) {
                  return data3;
                }
                data3 = dataAttr(elem, key);
                if (data3 !== void 0) {
                  return data3;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery.extend({
          queue: function(elem, type, data2) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data2) {
                if (!queue || Array.isArray(data2)) {
                  queue = dataPriv.access(elem, type, jQuery.makeArray(data2));
                } else {
                  queue.push(data2);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
              jQuery.dequeue(elem, type);
            };
            if (fn === "inprogress") {
              fn = queue.shift();
              startLength--;
            }
            if (fn) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          // Not public - generate a queueHooks object, or return the current one
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery.fn.extend({
          queue: function(type, data2) {
            var setter = 2;
            if (typeof type !== "string") {
              data2 = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery.queue(this[0], type);
            }
            return data2 === void 0 ? this : this.each(function() {
              var queue = jQuery.queue(this, type, data2);
              jQuery._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          // Get a promise resolved when queues of a certain type
          // are emptied (fx is the type by default)
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i2 = this.length, resolve = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i2--) {
              tmp = dataPriv.get(elements[i2], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve);
              }
            }
            resolve();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
          // Support: Firefox <=43 - 45
          // Disconnected elements can have computed display: none, so first confirm that elem is
          // in the document.
          isAttached(elem) && jQuery.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery.css(elem, prop, "");
          }, initial3 = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial3) && rcssNum.exec(jQuery.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial3 = initial3 / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial3 || 1;
            while (maxIterations--) {
              jQuery.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial3 || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial3 || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc.body.appendChild(doc.createElement(nodeName2));
          display = jQuery.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show2) {
          var display, elem, values = [], index2 = 0, length = elements.length;
          for (; index2 < length; index2++) {
            elem = elements[index2];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show2) {
              if (display === "none") {
                values[index2] = dataPriv.get(elem, "display") || null;
                if (!values[index2]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index2] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index2] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index2 = 0; index2 < length; index2++) {
            if (values[index2] != null) {
              elements[index2].style.display = values[index2];
            }
          }
          return elements;
        }
        jQuery.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery(this).show();
              } else {
                jQuery(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input2 = document2.createElement("input");
          input2.setAttribute("type", "radio");
          input2.setAttribute("checked", "checked");
          input2.setAttribute("name", "t");
          div.appendChild(input2);
          support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
          div.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
          div.innerHTML = "<option></option>";
          support.option = !!div.lastChild;
        })();
        var wrapMap = {
          // XHTML parsers do not magically insert elements in the
          // same way that tag soup parsers do. So we cannot shorten
          // this by omitting <tbody> or other required elements.
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll2(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i2 = 0, l = elems.length;
          for (; i2 < l; i2++) {
            dataPriv.set(
              elems[i2],
              "globalEval",
              !refElements || dataPriv.get(refElements[i2], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap2, attached, j, fragment = context.createDocumentFragment(), nodes = [], i2 = 0, l = elems.length;
          for (; i2 < l; i2++) {
            elem = elems[i2];
            if (elem || elem === 0) {
              if (toType(elem) === "object") {
                jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap2 = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap2[1] + jQuery.htmlPrefilter(elem) + wrap2[2];
                j = wrap2[0];
                while (j--) {
                  tmp = tmp.lastChild;
                }
                jQuery.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i2 = 0;
          while (elem = nodes[i2++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll2(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j = 0;
              while (elem = tmp[j++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function on2(elem, types2, selector, data2, fn, one) {
          var origFn, type;
          if (typeof types2 === "object") {
            if (typeof selector !== "string") {
              data2 = data2 || selector;
              selector = void 0;
            }
            for (type in types2) {
              on2(elem, type, selector, data2, types2[type], one);
            }
            return elem;
          }
          if (data2 == null && fn == null) {
            fn = selector;
            data2 = selector = void 0;
          } else if (fn == null) {
            if (typeof selector === "string") {
              fn = data2;
              data2 = void 0;
            } else {
              fn = data2;
              data2 = selector;
              selector = void 0;
            }
          }
          if (fn === false) {
            fn = returnFalse;
          } else if (!fn) {
            return elem;
          }
          if (one === 1) {
            origFn = fn;
            fn = function(event) {
              jQuery().off(event);
              return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
          }
          return elem.each(function() {
            jQuery.event.add(this, types2, fn, data2, selector);
          });
        }
        jQuery.event = {
          global: {},
          add: function(elem, types2, handler, data2, selector) {
            var handleObjIn, eventHandle, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e2) {
                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e2.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types2 = (types2 || "").match(rnothtmlwhite) || [""];
            t2 = types2.length;
            while (t2--) {
              tmp = rtypenamespace.exec(types2[t2]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery.event.special[type] || {};
              handleObj = jQuery.extend({
                type,
                origType,
                data: data2,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data2, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery.event.global[type] = true;
            }
          },
          // Detach an event or set of events from an element
          remove: function(elem, types2, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types2 = (types2 || "").match(rnothtmlwhite) || [""];
            t2 = types2.length;
            while (t2--) {
              tmp = rtypenamespace.exec(types2[t2]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery.event.remove(elem, type + types2[t2], handler, selector, true);
                }
                continue;
              }
              special = jQuery.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j = handlers.length;
              while (j--) {
                handleObj = handlers[j];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i2, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            for (i2 = 1; i2 < arguments.length; i2++) {
              args[i2] = arguments[i2];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i2 = 0;
            while ((matched = handlerQueue[i2++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j = 0;
              while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i2, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i2 = 0; i2 < delegateCount; i2++) {
                    handleObj = handlers[i2];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name2, hook) {
            Object.defineProperty(jQuery.Event.prototype, name2, {
              enumerable: true,
              configurable: true,
              get: isFunction2(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name2];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name2, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
          },
          special: {
            load: {
              // Prevent triggered image.load events from bubbling to window.load
              noBubble: true
            },
            click: {
              // Utilize native event to ensure correct state for checkable inputs
              setup: function(data2) {
                var el = this || data2;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", true);
                }
                return false;
              },
              trigger: function(data2) {
                var el = this || data2;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              // For cross-browser consistency, suppress native .click() on links
              // Also prevent it if we're currently inside a leveraged native-event stack
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, isSetup) {
          if (!isSetup) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  this[type]();
                  result = dataPriv.get(this, type);
                  dataPriv.set(this, type, false);
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result;
                  }
                } else if ((jQuery.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved) {
                dataPriv.set(this, type, jQuery.event.trigger(
                  saved[0],
                  saved.slice(1),
                  this
                ));
                event.stopPropagation();
                event.isImmediatePropagationStopped = returnTrue;
              }
            }
          });
        }
        jQuery.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery.Event = function(src, props) {
          if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery.expando] = true;
        };
        jQuery.Event.prototype = {
          constructor: jQuery.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e2 = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.preventDefault();
            }
          },
          stopPropagation: function() {
            var e2 = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e2 = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, jQuery.event.addProp);
        jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          function focusMappedHandler(nativeEvent) {
            if (document2.documentMode) {
              var handle = dataPriv.get(this, "handle"), event = jQuery.event.fix(nativeEvent);
              event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
              event.isSimulated = true;
              handle(nativeEvent);
              if (event.target === event.currentTarget) {
                handle(event);
              }
            } else {
              jQuery.event.simulate(
                delegateType,
                nativeEvent.target,
                jQuery.event.fix(nativeEvent)
              );
            }
          }
          jQuery.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
              var attaches;
              leverageNative(this, type, true);
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType);
                if (!attaches) {
                  this.addEventListener(delegateType, focusMappedHandler);
                }
                dataPriv.set(this, delegateType, (attaches || 0) + 1);
              } else {
                return false;
              }
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            teardown: function() {
              var attaches;
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType) - 1;
                if (!attaches) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                  dataPriv.remove(this, delegateType);
                } else {
                  dataPriv.set(this, delegateType, attaches);
                }
              } else {
                return false;
              }
            },
            // Suppress native focus or blur if we're currently inside
            // a leveraged native-event stack
            _default: function(event) {
              return dataPriv.get(event.target, type);
            },
            delegateType
          };
          jQuery.event.special[delegateType] = {
            setup: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
              if (!attaches) {
                if (document2.documentMode) {
                  this.addEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.addEventListener(type, focusMappedHandler, true);
                }
              }
              dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
            },
            teardown: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
              if (!attaches) {
                if (document2.documentMode) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.removeEventListener(type, focusMappedHandler, true);
                }
                dataPriv.remove(dataHolder, delegateType);
              } else {
                dataPriv.set(dataHolder, delegateType, attaches);
              }
            }
          };
        });
        jQuery.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery.fn.extend({
          on: function(types2, selector, data2, fn) {
            return on2(this, types2, selector, data2, fn);
          },
          one: function(types2, selector, data2, fn) {
            return on2(this, types2, selector, data2, fn, 1);
          },
          off: function(types2, selector, fn) {
            var handleObj, type;
            if (types2 && types2.preventDefault && types2.handleObj) {
              handleObj = types2.handleObj;
              jQuery(types2.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types2 === "object") {
              for (type in types2) {
                this.off(type, selector, types2[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn = selector;
              selector = void 0;
            }
            if (fn === false) {
              fn = returnFalse;
            }
            return this.each(function() {
              jQuery.event.remove(this, types2, fn, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i2, l, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i2 = 0, l = events[type].length; i2 < l; i2++) {
                  jQuery.event.add(dest, type, events[type][i2]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first, scripts, hasScripts, node, doc, i2 = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction2(value);
          if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index2) {
              var self2 = collection.eq(index2);
              if (valueIsFunction) {
                args[0] = value.call(this, index2, self2.html());
              }
              domManip(self2, args, callback, ignored);
            });
          }
          if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts = jQuery.map(getAll2(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i2 < l; i2++) {
                node = fragment;
                if (i2 !== iNoClone) {
                  node = jQuery.clone(node, true, true);
                  if (hasScripts) {
                    jQuery.merge(scripts, getAll2(node, "script"));
                  }
                }
                callback.call(collection[i2], node, i2);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery.map(scripts, restoreScript);
                for (i2 = 0; i2 < hasScripts; i2++) {
                  node = scripts[i2];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery._evalUrl && !node.noModule) {
                        jQuery._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove3(elem, selector, keepData) {
          var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i2 = 0;
          for (; (node = nodes[i2]) != null; i2++) {
            if (!keepData && node.nodeType === 1) {
              jQuery.cleanData(getAll2(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll2(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery.extend({
          htmlPrefilter: function(html2) {
            return html2;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i2, l, srcElements, destElements, clone3 = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
              destElements = getAll2(clone3);
              srcElements = getAll2(elem);
              for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
                fixInput(srcElements[i2], destElements[i2]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll2(elem);
                destElements = destElements || getAll2(clone3);
                for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
                  cloneCopyEvent(srcElements[i2], destElements[i2]);
                }
              } else {
                cloneCopyEvent(elem, clone3);
              }
            }
            destElements = getAll2(clone3, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll2(elem, "script"));
            }
            return clone3;
          },
          cleanData: function(elems) {
            var data2, elem, type, special = jQuery.event.special, i2 = 0;
            for (; (elem = elems[i2]) !== void 0; i2++) {
              if (acceptData(elem)) {
                if (data2 = elem[dataPriv.expando]) {
                  if (data2.events) {
                    for (type in data2.events) {
                      if (special[type]) {
                        jQuery.event.remove(elem, type);
                      } else {
                        jQuery.removeEvent(elem, type, data2.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery.fn.extend({
          detach: function(selector) {
            return remove3(this, selector, true);
          },
          remove: function(selector) {
            return remove3(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i2 = 0;
            for (; (elem = this[i2]) != null; i2++) {
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll2(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i2 = 0, l = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery.htmlPrefilter(value2);
                try {
                  for (; i2 < l; i2++) {
                    elem = this[i2] || {};
                    if (elem.nodeType === 1) {
                      jQuery.cleanData(getAll2(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e2) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent2 = this.parentNode;
              if (jQuery.inArray(this, ignored) < 0) {
                jQuery.cleanData(getAll2(this));
                if (parent2) {
                  parent2.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name2, original) {
          jQuery.fn[name2] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last2 = insert.length - 1, i2 = 0;
            for (; i2 <= last2; i2++) {
              elems = i2 === last2 ? this : this.clone(true);
              jQuery(insert[i2])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var rcustomProp = /^--/;
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options6, callback) {
          var ret, name2, old = {};
          for (name2 in options6) {
            old[name2] = elem.style[name2];
            elem.style[name2] = options6[name2];
          }
          ret = callback.call(elem);
          for (name2 in options6) {
            elem.style[name2] = old[name2];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
          function computeStyleTests() {
            if (!div) {
              return;
            }
            container2.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container2).appendChild(div);
            var divStyle = window2.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container2);
            div = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container2 = document2.createElement("div"), div = document2.createElement("div");
          if (!div.style) {
            return;
          }
          div.style.backgroundClip = "content-box";
          div.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div.style.backgroundClip === "content-box";
          jQuery.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
              var table2, tr, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table2 = document2.createElement("table");
                tr = document2.createElement("tr");
                trChild = document2.createElement("div");
                table2.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                tr.style.cssText = "box-sizing:content-box;border:1px solid";
                tr.style.height = "1px";
                trChild.style.height = "9px";
                trChild.style.display = "block";
                documentElement.appendChild(table2).appendChild(tr).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr);
                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                documentElement.removeChild(table2);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name2, computed) {
          var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name2), style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name2) || computed[name2];
            if (isCustomProp && ret) {
              ret = ret.replace(rtrimCSS, "$1") || void 0;
            }
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery.style(elem, name2);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name2)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? (
            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + ""
          ) : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name2) {
          var capName = name2[0].toUpperCase() + name2.slice(1), i2 = cssPrefixes.length;
          while (i2--) {
            name2 = cssPrefixes[i2] + capName;
            if (name2 in emptyStyle) {
              return name2;
            }
          }
        }
        function finalPropName(name2) {
          var final = jQuery.cssProps[name2] || vendorProps[name2];
          if (final) {
            return final;
          }
          if (name2 in emptyStyle) {
            return name2;
          }
          return vendorProps[name2] = vendorPropName(name2) || name2;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches2 = rcssNum.exec(value);
          return matches2 ? (
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches2[2] - (subtract || 0)) + (matches2[3] || "px")
          ) : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i2 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i2 < 4; i2 += 2) {
            if (box === "margin") {
              marginDelta += jQuery.css(elem, box + cssExpand[i2], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery.css(elem, "padding" + cssExpand[i2], true, styles);
              if (box !== "padding") {
                delta += jQuery.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              } else {
                extra += jQuery.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery.css(elem, "padding" + cssExpand[i2], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
              // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
              // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
          }
          return delta + marginDelta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Interestingly, in some cases IE 9 doesn't suffer from this issue.
          !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
          // This happens for inline elements with no explicit setting (gh-3571)
          val === "auto" || // Support: Android <=4.1 - 4.3 only
          // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
          !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
          elem.getClientRects().length) {
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            // Provide the current computed size to request scroll gutter calculation (gh-3589)
            val
          ) + "px";
        }
        jQuery.extend({
          // Add in style property hooks for overriding the default
          // behavior of getting and setting a style property
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          // Don't automatically add "px" to these possibly-unitless properties
          cssNumber: {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageSlice: true,
            columnCount: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            gridArea: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnStart: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowStart: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            scale: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeMiterlimit: true,
            strokeOpacity: true
          },
          // Add in properties whose names you wish to fix before
          // setting or getting the value
          cssProps: {},
          // Get and set the style property on a DOM Node
          style: function(elem, name2, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2), style = elem.style;
            if (!isCustomProp) {
              name2 = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name2, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name2.indexOf("background") === 0) {
                style[name2] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name2, value);
                } else {
                  style[name2] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name2];
            }
          },
          css: function(elem, name2, extra, styles) {
            var val, num, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2);
            if (!isCustomProp) {
              name2 = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name2, styles);
            }
            if (val === "normal" && name2 in cssNormalTransform) {
              val = cssNormalTransform[name2];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery.each(["height", "width"], function(_i, dimension) {
          jQuery.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches2, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches2 = rcssNum.exec(value)) && (matches2[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed) {
            if (computed) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i2 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i2 < 4; i2++) {
                expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery.fn.extend({
          css: function(name2, value) {
            return access(this, function(elem, name3, value2) {
              var styles, len, map = {}, i2 = 0;
              if (Array.isArray(name3)) {
                styles = getStyles(elem);
                len = name3.length;
                for (; i2 < len; i2++) {
                  map[name3[i2]] = jQuery.css(elem, name3[i2], false, styles);
                }
                return map;
              }
              return value2 !== void 0 ? jQuery.style(elem, name3, value2) : jQuery.css(elem, name3);
            }, name2, value, arguments.length > 1);
          }
        });
        function Tween(elem, options6, prop, end, easing) {
          return new Tween.prototype.init(elem, options6, prop, end, easing);
        }
        jQuery.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options6, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options6;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery.fx.step[tween.prop]) {
                jQuery.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery.easing = {
          linear: function(p) {
            return p;
          },
          swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery.fx = Tween.prototype.init;
        jQuery.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery.fx.interval);
            }
            jQuery.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i2 = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i2 < 4; i2 += 2 - includeWidth) {
            which = cssExpand[i2];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index2 = 0, length = collection.length;
          for (; index2 < length; index2++) {
            if (tween = collection[index2].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle7, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle7 = toggle7 || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
          }
          propTween = !jQuery.isEmptyObject(props);
          if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle7) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index2, name2, easing, value, hooks;
          for (index2 in props) {
            name2 = camelCase(index2);
            easing = specialEasing[name2];
            value = props[index2];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index2] = value[0];
            }
            if (index2 !== name2) {
              props[name2] = value;
              delete props[index2];
            }
            hooks = jQuery.cssHooks[name2];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name2];
              for (index2 in value) {
                if (!(index2 in props)) {
                  props[index2] = value[index2];
                  specialEasing[index2] = easing;
                }
              }
            } else {
              specialEasing[name2] = easing;
            }
          }
        }
        function Animation(elem, properties, options6) {
          var result, stopped, index2 = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index3 = 0, length2 = animation.tweens.length;
            for (; index3 < length2; index3++) {
              animation.tweens[index3].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
              specialEasing: {},
              easing: jQuery.easing._default
            }, options6),
            originalProperties: properties,
            originalOptions: options6,
            startTime: fxNow || createFxNow(),
            duration: options6.duration,
            tweens: [],
            createTween: function(prop, end) {
              var tween = jQuery.Tween(
                elem,
                animation.opts,
                prop,
                end,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index3 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index3 < length2; index3++) {
                animation.tweens[index3].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index2 < length; index2++) {
            result = Animation.prefilters[index2].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction2(result.stop)) {
                jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery.map(props, createTween, animation);
          if (isFunction2(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery.fx.timer(
            jQuery.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery.Animation = jQuery.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction2(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index2 = 0, length = props.length;
            for (; index2 < length; index2++) {
              prop = props[index2];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery.speed = function(speed, easing, fn) {
          var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction2(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction2(easing) && easing
          };
          if (jQuery.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery.fx.speeds) {
                opt.duration = jQuery.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction2(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery.fn.extend({
          fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty2 = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery.extend({}, prop), optall);
              if (empty2 || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty2 || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index2 = type != null && type + "queueHooks", timers = jQuery.timers, data2 = dataPriv.get(this);
              if (index2) {
                if (data2[index2] && data2[index2].stop) {
                  stopQueue(data2[index2]);
                }
              } else {
                for (index2 in data2) {
                  if (data2[index2] && data2[index2].stop && rrun.test(index2)) {
                    stopQueue(data2[index2]);
                  }
                }
              }
              for (index2 = timers.length; index2--; ) {
                if (timers[index2].elem === this && (type == null || timers[index2].queue === type)) {
                  timers[index2].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index2, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index2, data2 = dataPriv.get(this), queue = data2[type + "queue"], hooks = data2[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
              data2.finish = true;
              jQuery.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index2 = timers.length; index2--; ) {
                if (timers[index2].elem === this && timers[index2].queue === type) {
                  timers[index2].anim.stop(true);
                  timers.splice(index2, 1);
                }
              }
              for (index2 = 0; index2 < length; index2++) {
                if (queue[index2] && queue[index2].finish) {
                  queue[index2].finish.call(this);
                }
              }
              delete data2.finish;
            });
          }
        });
        jQuery.each(["toggle", "show", "hide"], function(_i, name2) {
          var cssFn = jQuery.fn[name2];
          jQuery.fn[name2] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name2, true), speed, easing, callback);
          };
        });
        jQuery.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name2, props) {
          jQuery.fn[name2] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery.timers = [];
        jQuery.fx.tick = function() {
          var timer, i2 = 0, timers = jQuery.timers;
          fxNow = Date.now();
          for (; i2 < timers.length; i2++) {
            timer = timers[i2];
            if (!timer() && timers[i2] === timer) {
              timers.splice(i2--, 1);
            }
          }
          if (!timers.length) {
            jQuery.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery.fx.timer = function(timer) {
          jQuery.timers.push(timer);
          jQuery.fx.start();
        };
        jQuery.fx.interval = 13;
        jQuery.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery.fx.stop = function() {
          inProgress = null;
        };
        jQuery.fx.speeds = {
          slow: 600,
          fast: 200,
          // Default speed
          _default: 400
        };
        jQuery.fn.delay = function(time, type) {
          time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input2 = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input2.type = "checkbox";
          support.checkOn = input2.value !== "";
          support.optSelected = opt.selected;
          input2 = document2.createElement("input");
          input2.value = "t";
          input2.type = "radio";
          support.radioValue = input2.value === "t";
        })();
        var boolHook, attrHandle = jQuery.expr.attrHandle;
        jQuery.fn.extend({
          attr: function(name2, value) {
            return access(this, jQuery.attr, name2, value, arguments.length > 1);
          },
          removeAttr: function(name2) {
            return this.each(function() {
              jQuery.removeAttr(this, name2);
            });
          }
        });
        jQuery.extend({
          attr: function(elem, name2, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery.prop(elem, name2, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
              hooks = jQuery.attrHooks[name2.toLowerCase()] || (jQuery.expr.match.bool.test(name2) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery.removeAttr(elem, name2);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name2, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
              return ret;
            }
            ret = jQuery.find.attr(elem, name2);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name2, i2 = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name2 = attrNames[i2++]) {
                elem.removeAttribute(name2);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name2) {
            if (value === false) {
              jQuery.removeAttr(elem, name2);
            } else {
              elem.setAttribute(name2, name2);
            }
            return name2;
          }
        };
        jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name2) {
          var getter = attrHandle[name2] || jQuery.find.attr;
          attrHandle[name2] = function(elem, name3, isXML) {
            var ret, handle, lowercaseName = name3.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name3, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery.fn.extend({
          prop: function(name2, value) {
            return access(this, jQuery.prop, name2, value, arguments.length > 1);
          },
          removeProp: function(name2) {
            return this.each(function() {
              delete this[jQuery.propFix[name2] || name2];
            });
          }
        });
        jQuery.extend({
          prop: function(elem, name2, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
              name2 = jQuery.propFix[name2] || name2;
              hooks = jQuery.propHooks[name2];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
                return ret;
              }
              return elem[name2] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
              return ret;
            }
            return elem[name2];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery.propHooks.selected = {
            get: function(elem) {
              var parent2 = elem.parentNode;
              if (parent2 && parent2.parentNode) {
                parent2.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent2 = elem.parentNode;
              if (parent2) {
                parent2.selectedIndex;
                if (parent2.parentNode) {
                  parent2.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery.fn.extend({
          addClass: function(value) {
            var classNames, cur, curValue, className2, i2, finalValue;
            if (isFunction2(value)) {
              return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, getClass(this)));
              });
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i2 = 0; i2 < classNames.length; i2++) {
                    className2 = classNames[i2];
                    if (cur.indexOf(" " + className2 + " ") < 0) {
                      cur += className2 + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          removeClass: function(value) {
            var classNames, cur, curValue, className2, i2, finalValue;
            if (isFunction2(value)) {
              return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i2 = 0; i2 < classNames.length; i2++) {
                    className2 = classNames[i2];
                    while (cur.indexOf(" " + className2 + " ") > -1) {
                      cur = cur.replace(" " + className2 + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var classNames, className2, i2, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (isFunction2(value)) {
              return this.each(function(i3) {
                jQuery(this).toggleClass(
                  value.call(this, i3, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            classNames = classesToArray(value);
            return this.each(function() {
              if (isValidValue) {
                self2 = jQuery(this);
                for (i2 = 0; i2 < classNames.length; i2++) {
                  className2 = classNames[i2];
                  if (self2.hasClass(className2)) {
                    self2.removeClass(className2);
                  } else {
                    self2.addClass(className2);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className2 = getClass(this);
                if (className2) {
                  dataPriv.set(this, "__className__", className2);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className2 || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className2, elem, i2 = 0;
            className2 = " " + selector + " ";
            while (elem = this[i2++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className2) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction2(value);
            return this.each(function(i2) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i2, jQuery(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery.find.attr(elem, "value");
                return val != null ? val : (
                  // Support: IE <=10 - 11 only
                  // option.text throws exceptions (trac-14686, trac-14858)
                  // Strip and collapse whitespace
                  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                  stripAndCollapse(jQuery.text(elem))
                );
              }
            },
            select: {
              get: function(elem) {
                var value, option2, i2, options6 = elem.options, index2 = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index2 + 1 : options6.length;
                if (index2 < 0) {
                  i2 = max;
                } else {
                  i2 = one ? index2 : 0;
                }
                for (; i2 < max; i2++) {
                  option2 = options6[i2];
                  if ((option2.selected || i2 === index2) && // Don't return options that are disabled or in a disabled optgroup
                  !option2.disabled && (!option2.parentNode.disabled || !nodeName(option2.parentNode, "optgroup"))) {
                    value = jQuery(option2).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option2, options6 = elem.options, values = jQuery.makeArray(value), i2 = options6.length;
                while (i2--) {
                  option2 = options6[i2];
                  if (option2.selected = jQuery.inArray(jQuery.valHooks.option.get(option2), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery.each(["radio", "checkbox"], function() {
          jQuery.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery.parseXML = function(data2) {
          var xml, parserErrorElem;
          if (!data2 || typeof data2 !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data2, "text/xml");
          } catch (e2) {
          }
          parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
          if (!xml || parserErrorElem) {
            jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data2));
          }
          return xml;
        };
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e2) {
          e2.stopPropagation();
        };
        jQuery.extend(jQuery.event, {
          trigger: function(event, data2, elem, onlyHandlers) {
            var i2, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data2 = data2 == null ? [event] : jQuery.makeArray(data2, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data2) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i2 = 0;
            while ((cur = eventPath[i2++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i2 > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data2);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data2);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data2) === false) && acceptData(elem)) {
                if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          // Piggyback on a donor event to simulate a different one
          // Used only for `focus(in | out)` events
          simulate: function(type, elem, event) {
            var e2 = jQuery.extend(
              new jQuery.Event(),
              event,
              {
                type,
                isSimulated: true
              }
            );
            jQuery.event.trigger(e2, null, elem);
          }
        });
        jQuery.fn.extend({
          trigger: function(type, data2) {
            return this.each(function() {
              jQuery.event.trigger(type, data2, this);
            });
          },
          triggerHandler: function(type, data2) {
            var elem = this[0];
            if (elem) {
              return jQuery.event.trigger(type, data2, elem, true);
            }
          }
        });
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add4) {
          var name2;
          if (Array.isArray(obj)) {
            jQuery.each(obj, function(i2, v) {
              if (traditional || rbracket.test(prefix)) {
                add4(prefix, v);
              } else {
                buildParams(
                  prefix + "[" + (typeof v === "object" && v != null ? i2 : "") + "]",
                  v,
                  traditional,
                  add4
                );
              }
            });
          } else if (!traditional && toType(obj) === "object") {
            for (name2 in obj) {
              buildParams(prefix + "[" + name2 + "]", obj[name2], traditional, add4);
            }
          } else {
            add4(prefix, obj);
          }
        }
        jQuery.param = function(a2, traditional) {
          var prefix, s = [], add4 = function(key, valueOrFunction) {
            var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a2 == null) {
            return "";
          }
          if (Array.isArray(a2) || a2.jquery && !jQuery.isPlainObject(a2)) {
            jQuery.each(a2, function() {
              add4(this.name, this.value);
            });
          } else {
            for (prefix in a2) {
              buildParams(prefix, a2[prefix], traditional, add4);
            }
          }
          return s.join("&");
        };
        jQuery.fn.extend({
          serialize: function() {
            return jQuery.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery.prop(this, "elements");
              return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
              var val = jQuery(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction2(func)) {
              while (dataType = dataTypes[i2++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options6, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options6, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options6.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options6.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s, jqXHR, responses) {
          var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === void 0) {
              ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
          var conv2, current2, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s.converters) {
              converters[conv.toLowerCase()] = s.converters[conv];
            }
          }
          current2 = dataTypes.shift();
          while (current2) {
            if (s.responseFields[current2]) {
              jqXHR[s.responseFields[current2]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
              response = s.dataFilter(response, s.dataType);
            }
            prev = current2;
            current2 = dataTypes.shift();
            if (current2) {
              if (current2 === "*") {
                current2 = prev;
              } else if (prev !== "*" && prev !== current2) {
                conv = converters[prev + " " + current2] || converters["* " + current2];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current2) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current2 = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e2) {
                      return {
                        state: "parsererror",
                        error: conv ? e2 : "No conversion from " + prev + " to " + current2
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery.extend({
          // Counter for holding the number of active queries
          active: 0,
          // Last-Modified header cache for next request
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
              // Convert anything to text
              "* text": String,
              // Text to html (true = no transformation)
              "text html": true,
              // Evaluate text as a json expression
              "text json": JSON.parse,
              // Parse text as xml
              "text xml": jQuery.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
              url: true,
              context: true
            }
          },
          // Creates a full fledged settings object into target
          // with both ajaxSettings and settings fields.
          // If target is omitted, writes into ajaxSettings.
          ajaxSetup: function(target, settings) {
            return settings ? (
              // Building a settings object
              ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
            ) : (
              // Extending ajaxSettings
              ajaxExtend(jQuery.ajaxSettings, target)
            );
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          // Main method
          ajax: function(url, options6) {
            if (typeof url === "object") {
              options6 = url;
              url = void 0;
            }
            options6 = options6 || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i2, uncached, s = jQuery.ajaxSetup({}, options6), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              // Builds headers hashtable if needed
              getResponseHeader: function(key) {
                var match;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                    }
                  }
                  match = responseHeaders[key.toLowerCase() + " "];
                }
                return match == null ? null : match.join(", ");
              },
              // Raw string
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              // Caches the header
              setRequestHeader: function(name2, value) {
                if (completed2 == null) {
                  name2 = requestHeadersNames[name2.toLowerCase()] = requestHeadersNames[name2.toLowerCase()] || name2;
                  requestHeaders[name2] = value;
                }
                return this;
              },
              // Overrides response content-type header
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s.mimeType = type;
                }
                return this;
              },
              // Status-dependent callbacks
              statusCode: function(map) {
                var code;
                if (map) {
                  if (completed2) {
                    jqXHR.always(map[jqXHR.status]);
                  } else {
                    for (code in map) {
                      statusCode[code] = [statusCode[code], map[code]];
                    }
                  }
                }
                return this;
              },
              // Cancel the request
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s.type = options6.method || options6.type || s.method || s.type;
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s.url;
                urlAnchor.href = urlAnchor.href;
                s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e2) {
                s.crossDomain = true;
              }
            }
            if (s.data && s.processData && typeof s.data !== "string") {
              s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options6, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
              jQuery.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, "");
            if (!s.hasContent) {
              uncached = s.url.slice(cacheURL.length);
              if (s.data && (s.processData || typeof s.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                delete s.data;
              }
              if (s.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s.data = s.data.replace(r20, "+");
            }
            if (s.ifModified) {
              if (jQuery.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
              }
              if (jQuery.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
              }
            }
            if (s.data && s.hasContent && s.contentType !== false || options6.contentType) {
              jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
            );
            for (i2 in s.headers) {
              jqXHR.setRequestHeader(i2, s.headers[i2]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options6, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s.async && s.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e2) {
                if (completed2) {
                  throw e2;
                }
                done(-1, e2);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s, jqXHR, responses);
              }
              if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
                s.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error = response.error;
                  isSuccess = !error;
                }
              } else {
                error = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s, isSuccess ? success : error]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                if (!--jQuery.active) {
                  jQuery.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data2, callback) {
            return jQuery.get(url, data2, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery.get(url, void 0, callback, "script");
          }
        });
        jQuery.each(["get", "post"], function(_i, method) {
          jQuery[method] = function(url, data2, callback, type) {
            if (isFunction2(data2)) {
              type = type || callback;
              callback = data2;
              data2 = void 0;
            }
            return jQuery.ajax(jQuery.extend({
              url,
              type: method,
              dataType: type,
              data: data2,
              success: callback
            }, jQuery.isPlainObject(url) && url));
          };
        });
        jQuery.ajaxPrefilter(function(s) {
          var i2;
          for (i2 in s.headers) {
            if (i2.toLowerCase() === "content-type") {
              s.contentType = s.headers[i2] || "";
            }
          }
        });
        jQuery._evalUrl = function(url, options6, doc) {
          return jQuery.ajax({
            url,
            // Make this explicit, since user can override this through ajaxSetup (trac-11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery.globalEval(response, options6, doc);
            }
          });
        };
        jQuery.fn.extend({
          wrapAll: function(html2) {
            var wrap2;
            if (this[0]) {
              if (isFunction2(html2)) {
                html2 = html2.call(this[0]);
              }
              wrap2 = jQuery(html2, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap2.insertBefore(this[0]);
              }
              wrap2.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html2) {
            if (isFunction2(html2)) {
              return this.each(function(i2) {
                jQuery(this).wrapInner(html2.call(this, i2));
              });
            }
            return this.each(function() {
              var self2 = jQuery(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html2);
              } else {
                self2.append(html2);
              }
            });
          },
          wrap: function(html2) {
            var htmlIsFunction = isFunction2(html2);
            return this.each(function(i2) {
              jQuery(this).wrapAll(htmlIsFunction ? html2.call(this, i2) : html2);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery.expr.pseudos.hidden = function(elem) {
          return !jQuery.expr.pseudos.visible(elem);
        };
        jQuery.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e2) {
          }
        };
        var xhrSuccessStatus = {
          // File protocol always yields status code 0, assume 200
          0: 200,
          // Support: IE <=9 only
          // trac-1450: sometimes IE returns 1223 when it should be 204
          1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery.ajaxTransport(function(options6) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options6.crossDomain) {
            return {
              send: function(headers, complete) {
                var i2, xhr = options6.xhr();
                xhr.open(
                  options6.type,
                  options6.url,
                  options6.async,
                  options6.username,
                  options6.password
                );
                if (options6.xhrFields) {
                  for (i2 in options6.xhrFields) {
                    xhr[i2] = options6.xhrFields[i2];
                  }
                }
                if (options6.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options6.mimeType);
                }
                if (!options6.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i2 in headers) {
                  xhr.setRequestHeader(i2, headers[i2]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            // File: protocol always yields status 0; see trac-8605, trac-14207
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          // Support: IE <=9 only
                          // IE9 has no XHR2 but throws on binary (trac-11426)
                          // For XHR2 non-text, let the caller handle it (gh-2498)
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options6.hasContent && options6.data || null);
                } catch (e2) {
                  if (callback) {
                    throw e2;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery.ajaxPrefilter(function(s) {
          if (s.crossDomain) {
            s.contents.script = false;
          }
        });
        jQuery.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery.globalEval(text);
              return text;
            }
          }
        });
        jQuery.ajaxPrefilter("script", function(s) {
          if (s.cache === void 0) {
            s.cache = false;
          }
          if (s.crossDomain) {
            s.type = "GET";
          }
        });
        jQuery.ajaxTransport("script", function(s) {
          if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
              send: function(_, complete) {
                script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
          if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = isFunction2(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
              s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
              s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s[callbackName]) {
                s.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction2(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery.parseHTML = function(data2, context, keepScripts) {
          if (typeof data2 !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base = context.createElement("base");
              base.href = document2.location.href;
              context.head.appendChild(base);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data2);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data2], context, scripts);
          if (scripts && scripts.length) {
            jQuery(scripts).remove();
          }
          return jQuery.merge([], parsed.childNodes);
        };
        jQuery.fn.load = function(url, params, callback) {
          var selector, type, response, self2 = this, off2 = url.indexOf(" ");
          if (off2 > -1) {
            selector = stripAndCollapse(url.slice(off2));
            url = url.slice(0, off2);
          }
          if (isFunction2(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery.ajax({
              url,
              // If "type" variable is undefined, then "GET" method will be used.
              // Make value of this field explicit since
              // user can override it through ajaxSetup method
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self2.html(selector ? (
                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
              ) : (
                // Otherwise use the full result
                responseText
              ));
            }).always(callback && function(jqXHR, status) {
              self2.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery.expr.pseudos.animated = function(elem) {
          return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
          }).length;
        };
        jQuery.offset = {
          setOffset: function(elem, options6, i2) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction2(options6)) {
              options6 = options6.call(elem, i2, jQuery.extend({}, curOffset));
            }
            if (options6.top != null) {
              props.top = options6.top - curOffset.top + curTop;
            }
            if (options6.left != null) {
              props.left = options6.left - curOffset.left + curLeft;
            }
            if ("using" in options6) {
              options6.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery.fn.extend({
          // offset() relates an element's border box to the document origin
          offset: function(options6) {
            if (arguments.length) {
              return options6 === void 0 ? this : this.each(function(i2) {
                jQuery.offset.setOffset(this, options6, i2);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          // position() relates an element's margin box to its offset parent's padding box
          // This corresponds to the behavior of CSS absolute positioning
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery.css(elem, "position") === "fixed") {
              offset = elem.getBoundingClientRect();
            } else {
              offset = this.offset();
              doc = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc.documentElement;
              while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery(offsetParent).offset();
                parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
              left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
          },
          // This method will return documentElement in the following cases:
          // 1) For the element inside the iframe without offsetParent, this method will return
          //    documentElement of the parent window
          // 2) For the hidden or detached element
          // 3) For body or html element, i.e. in case of the html node - it will return itself
          //
          // but those exceptions were never presented as a real life use-cases
          // and might be considered as more preferable results.
          //
          // This logic, however, is not guaranteed and can change at any point in the future
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top = "pageYOffset" === prop;
          jQuery.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top ? val2 : win.pageXOffset,
                  top ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery.each(["top", "left"], function(_i, prop) {
          jQuery.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery.each({ Height: "height", Width: "width" }, function(name2, type) {
          jQuery.each({
            padding: "inner" + name2,
            content: type,
            "": "outer" + name2
          }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name2] : elem.document.documentElement["client" + name2];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name2],
                    doc["scroll" + name2],
                    elem.body["offset" + name2],
                    doc["offset" + name2],
                    doc["client" + name2]
                  );
                }
                return value2 === void 0 ? (
                  // Get width or height on the element, requesting but not forcing parseFloat
                  jQuery.css(elem, type2, extra)
                ) : (
                  // Set width or height on the element
                  jQuery.style(elem, type2, value2, extra)
                );
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i, type) {
          jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
          };
        });
        jQuery.fn.extend({
          bind: function(types2, data2, fn) {
            return this.on(types2, null, data2, fn);
          },
          unbind: function(types2, fn) {
            return this.off(types2, null, fn);
          },
          delegate: function(selector, types2, data2, fn) {
            return this.on(types2, selector, data2, fn);
          },
          undelegate: function(selector, types2, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types2, selector || "**", fn);
          },
          hover: function(fnOver, fnOut) {
            return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
          }
        });
        jQuery.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i, name2) {
            jQuery.fn[name2] = function(data2, fn) {
              return arguments.length > 0 ? this.on(name2, null, data2, fn) : this.trigger(name2);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        jQuery.proxy = function(fn, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
          }
          if (!isFunction2(fn)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn.guid = fn.guid || jQuery.guid++;
          return proxy;
        };
        jQuery.holdReady = function(hold) {
          if (hold) {
            jQuery.readyWait++;
          } else {
            jQuery.ready(true);
          }
        };
        jQuery.isArray = Array.isArray;
        jQuery.parseJSON = JSON.parse;
        jQuery.nodeName = nodeName;
        jQuery.isFunction = isFunction2;
        jQuery.isWindow = isWindow;
        jQuery.camelCase = camelCase;
        jQuery.type = toType;
        jQuery.now = Date.now;
        jQuery.isNumeric = function(obj) {
          var type = jQuery.type(obj);
          return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          !isNaN(obj - parseFloat(obj));
        };
        jQuery.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "$1");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery.noConflict = function(deep) {
          if (window2.$ === jQuery) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery) {
            window2.jQuery = _jQuery;
          }
          return jQuery;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery;
        }
        return jQuery;
      });
    }
  });

  // node_modules/dompurify/dist/purify.js
  var require_purify = __commonJS({
    "node_modules/dompurify/dist/purify.js"(exports2, module84) {
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module84 !== "undefined" ? module84.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.DOMPurify = factory());
      })(exports2, function() {
        "use strict";
        const {
          entries,
          setPrototypeOf,
          isFrozen,
          getPrototypeOf,
          getOwnPropertyDescriptor
        } = Object;
        let {
          freeze,
          seal,
          create
        } = Object;
        let {
          apply: apply2,
          construct
        } = typeof Reflect !== "undefined" && Reflect;
        if (!freeze) {
          freeze = function freeze2(x) {
            return x;
          };
        }
        if (!seal) {
          seal = function seal2(x) {
            return x;
          };
        }
        if (!apply2) {
          apply2 = function apply3(fun, thisValue, args) {
            return fun.apply(thisValue, args);
          };
        }
        if (!construct) {
          construct = function construct2(Func, args) {
            return new Func(...args);
          };
        }
        const arrayForEach = unapply(Array.prototype.forEach);
        const arrayPop = unapply(Array.prototype.pop);
        const arrayPush2 = unapply(Array.prototype.push);
        const stringToLowerCase = unapply(String.prototype.toLowerCase);
        const stringToString = unapply(String.prototype.toString);
        const stringMatch = unapply(String.prototype.match);
        const stringReplace = unapply(String.prototype.replace);
        const stringIndexOf = unapply(String.prototype.indexOf);
        const stringTrim = unapply(String.prototype.trim);
        const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
        const regExpTest = unapply(RegExp.prototype.test);
        const typeErrorCreate = unconstruct(TypeError);
        function unapply(func) {
          return function(thisArg) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return apply2(func, thisArg, args);
          };
        }
        function unconstruct(func) {
          return function() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return construct(func, args);
          };
        }
        function addToSet(set6, array) {
          let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
          if (setPrototypeOf) {
            setPrototypeOf(set6, null);
          }
          let l = array.length;
          while (l--) {
            let element = array[l];
            if (typeof element === "string") {
              const lcElement = transformCaseFunc(element);
              if (lcElement !== element) {
                if (!isFrozen(array)) {
                  array[l] = lcElement;
                }
                element = lcElement;
              }
            }
            set6[element] = true;
          }
          return set6;
        }
        function cleanArray(array) {
          for (let index2 = 0; index2 < array.length; index2++) {
            const isPropertyExist = objectHasOwnProperty(array, index2);
            if (!isPropertyExist) {
              array[index2] = null;
            }
          }
          return array;
        }
        function clone3(object) {
          const newObject = create(null);
          for (const [property2, value] of entries(object)) {
            const isPropertyExist = objectHasOwnProperty(object, property2);
            if (isPropertyExist) {
              if (Array.isArray(value)) {
                newObject[property2] = cleanArray(value);
              } else if (value && typeof value === "object" && value.constructor === Object) {
                newObject[property2] = clone3(value);
              } else {
                newObject[property2] = value;
              }
            }
          }
          return newObject;
        }
        function lookupGetter(object, prop) {
          while (object !== null) {
            const desc = getOwnPropertyDescriptor(object, prop);
            if (desc) {
              if (desc.get) {
                return unapply(desc.get);
              }
              if (typeof desc.value === "function") {
                return unapply(desc.value);
              }
            }
            object = getPrototypeOf(object);
          }
          function fallbackValue() {
            return null;
          }
          return fallbackValue;
        }
        const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
        const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
        const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
        const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
        const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
        const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
        const text = freeze(["#text"]);
        const html2 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
        const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
        const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
        const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
        const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
        const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
        const TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
        const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
        const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
        const IS_ALLOWED_URI = seal(
          /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
          // eslint-disable-line no-useless-escape
        );
        const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
        const ATTR_WHITESPACE = seal(
          /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
          // eslint-disable-line no-control-regex
        );
        const DOCTYPE_NAME = seal(/^html$/i);
        const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
        var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          MUSTACHE_EXPR,
          ERB_EXPR,
          TMPLIT_EXPR,
          DATA_ATTR,
          ARIA_ATTR,
          IS_ALLOWED_URI,
          IS_SCRIPT_OR_DATA,
          ATTR_WHITESPACE,
          DOCTYPE_NAME,
          CUSTOM_ELEMENT
        });
        const NODE_TYPE = {
          element: 1,
          attribute: 2,
          text: 3,
          cdataSection: 4,
          entityReference: 5,
          // Deprecated
          entityNode: 6,
          // Deprecated
          progressingInstruction: 7,
          comment: 8,
          document: 9,
          documentType: 10,
          documentFragment: 11,
          notation: 12
          // Deprecated
        };
        const getGlobal = function getGlobal2() {
          return typeof window === "undefined" ? null : window;
        };
        const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
          if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
            return null;
          }
          let suffix = null;
          const ATTR_NAME = "data-tt-policy-suffix";
          if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
            suffix = purifyHostElement.getAttribute(ATTR_NAME);
          }
          const policyName = "dompurify" + (suffix ? "#" + suffix : "");
          try {
            return trustedTypes.createPolicy(policyName, {
              createHTML(html3) {
                return html3;
              },
              createScriptURL(scriptUrl) {
                return scriptUrl;
              }
            });
          } catch (_) {
            console.warn("TrustedTypes policy " + policyName + " could not be created.");
            return null;
          }
        };
        function createDOMPurify() {
          let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
          const DOMPurify3 = (root2) => createDOMPurify(root2);
          DOMPurify3.version = "3.1.6";
          DOMPurify3.removed = [];
          if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document) {
            DOMPurify3.isSupported = false;
            return DOMPurify3;
          }
          let {
            document: document2
          } = window2;
          const originalDocument = document2;
          const currentScript = originalDocument.currentScript;
          const {
            DocumentFragment,
            HTMLTemplateElement,
            Node: Node2,
            Element: Element2,
            NodeFilter,
            NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
            HTMLFormElement,
            DOMParser: DOMParser2,
            trustedTypes
          } = window2;
          const ElementPrototype = Element2.prototype;
          const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
          const remove3 = lookupGetter(ElementPrototype, "remove");
          const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
          const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
          const getParentNode = lookupGetter(ElementPrototype, "parentNode");
          if (typeof HTMLTemplateElement === "function") {
            const template = document2.createElement("template");
            if (template.content && template.content.ownerDocument) {
              document2 = template.content.ownerDocument;
            }
          }
          let trustedTypesPolicy;
          let emptyHTML = "";
          const {
            implementation,
            createNodeIterator,
            createDocumentFragment,
            getElementsByTagName
          } = document2;
          const {
            importNode
          } = originalDocument;
          let hooks = {};
          DOMPurify3.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
          const {
            MUSTACHE_EXPR: MUSTACHE_EXPR2,
            ERB_EXPR: ERB_EXPR2,
            TMPLIT_EXPR: TMPLIT_EXPR2,
            DATA_ATTR: DATA_ATTR2,
            ARIA_ATTR: ARIA_ATTR2,
            IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
            ATTR_WHITESPACE: ATTR_WHITESPACE2,
            CUSTOM_ELEMENT: CUSTOM_ELEMENT2
          } = EXPRESSIONS;
          let {
            IS_ALLOWED_URI: IS_ALLOWED_URI$1
          } = EXPRESSIONS;
          let ALLOWED_TAGS = null;
          const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
          let ALLOWED_ATTR = null;
          const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html2, ...svg, ...mathMl, ...xml]);
          let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
            tagNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            attributeNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            allowCustomizedBuiltInElements: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: false
            }
          }));
          let FORBID_TAGS = null;
          let FORBID_ATTR = null;
          let ALLOW_ARIA_ATTR = true;
          let ALLOW_DATA_ATTR = true;
          let ALLOW_UNKNOWN_PROTOCOLS = false;
          let ALLOW_SELF_CLOSE_IN_ATTR = true;
          let SAFE_FOR_TEMPLATES = false;
          let SAFE_FOR_XML = true;
          let WHOLE_DOCUMENT = false;
          let SET_CONFIG = false;
          let FORCE_BODY = false;
          let RETURN_DOM = false;
          let RETURN_DOM_FRAGMENT = false;
          let RETURN_TRUSTED_TYPE = false;
          let SANITIZE_DOM = true;
          let SANITIZE_NAMED_PROPS = false;
          const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
          let KEEP_CONTENT = true;
          let IN_PLACE = false;
          let USE_PROFILES = {};
          let FORBID_CONTENTS = null;
          const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
          let DATA_URI_TAGS = null;
          const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
          let URI_SAFE_ATTRIBUTES = null;
          const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
          const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          let NAMESPACE = HTML_NAMESPACE;
          let IS_EMPTY_INPUT = false;
          let ALLOWED_NAMESPACES = null;
          const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
          let PARSER_MEDIA_TYPE = null;
          const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
          const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
          let transformCaseFunc = null;
          let CONFIG = null;
          const formElement = document2.createElement("form");
          const isRegexOrFunction = function isRegexOrFunction2(testValue) {
            return testValue instanceof RegExp || testValue instanceof Function;
          };
          const _parseConfig = function _parseConfig2() {
            let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (CONFIG && CONFIG === cfg) {
              return;
            }
            if (!cfg || typeof cfg !== "object") {
              cfg = {};
            }
            cfg = clone3(cfg);
            PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
            SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
            transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
            ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
            ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
            ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
            URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(
              clone3(DEFAULT_URI_SAFE_ATTRIBUTES),
              // eslint-disable-line indent
              cfg.ADD_URI_SAFE_ATTR,
              // eslint-disable-line indent
              transformCaseFunc
              // eslint-disable-line indent
            ) : DEFAULT_URI_SAFE_ATTRIBUTES;
            DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(
              clone3(DEFAULT_DATA_URI_TAGS),
              // eslint-disable-line indent
              cfg.ADD_DATA_URI_TAGS,
              // eslint-disable-line indent
              transformCaseFunc
              // eslint-disable-line indent
            ) : DEFAULT_DATA_URI_TAGS;
            FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
            FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
            FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
            USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
            ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
            ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
            ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
            ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
            SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
            SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
            WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
            RETURN_DOM = cfg.RETURN_DOM || false;
            RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
            RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
            FORCE_BODY = cfg.FORCE_BODY || false;
            SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
            SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
            KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
            IN_PLACE = cfg.IN_PLACE || false;
            IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
            NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
            CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
              CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
            }
            if (SAFE_FOR_TEMPLATES) {
              ALLOW_DATA_ATTR = false;
            }
            if (RETURN_DOM_FRAGMENT) {
              RETURN_DOM = true;
            }
            if (USE_PROFILES) {
              ALLOWED_TAGS = addToSet({}, text);
              ALLOWED_ATTR = [];
              if (USE_PROFILES.html === true) {
                addToSet(ALLOWED_TAGS, html$1);
                addToSet(ALLOWED_ATTR, html2);
              }
              if (USE_PROFILES.svg === true) {
                addToSet(ALLOWED_TAGS, svg$1);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.svgFilters === true) {
                addToSet(ALLOWED_TAGS, svgFilters);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.mathMl === true) {
                addToSet(ALLOWED_TAGS, mathMl$1);
                addToSet(ALLOWED_ATTR, mathMl);
                addToSet(ALLOWED_ATTR, xml);
              }
            }
            if (cfg.ADD_TAGS) {
              if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = clone3(ALLOWED_TAGS);
              }
              addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
            }
            if (cfg.ADD_ATTR) {
              if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = clone3(ALLOWED_ATTR);
              }
              addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
            }
            if (cfg.ADD_URI_SAFE_ATTR) {
              addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
            }
            if (cfg.FORBID_CONTENTS) {
              if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
                FORBID_CONTENTS = clone3(FORBID_CONTENTS);
              }
              addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
            }
            if (KEEP_CONTENT) {
              ALLOWED_TAGS["#text"] = true;
            }
            if (WHOLE_DOCUMENT) {
              addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
            }
            if (ALLOWED_TAGS.table) {
              addToSet(ALLOWED_TAGS, ["tbody"]);
              delete FORBID_TAGS.tbody;
            }
            if (cfg.TRUSTED_TYPES_POLICY) {
              if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
              }
              if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
              }
              trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
              emptyHTML = trustedTypesPolicy.createHTML("");
            } else {
              if (trustedTypesPolicy === void 0) {
                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
              }
              if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
                emptyHTML = trustedTypesPolicy.createHTML("");
              }
            }
            if (freeze) {
              freeze(cfg);
            }
            CONFIG = cfg;
          };
          const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
          const HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "annotation-xml"]);
          const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
          const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
          const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
          const _checkValidNamespace = function _checkValidNamespace2(element) {
            let parent2 = getParentNode(element);
            if (!parent2 || !parent2.tagName) {
              parent2 = {
                namespaceURI: NAMESPACE,
                tagName: "template"
              };
            }
            const tagName = stringToLowerCase(element.tagName);
            const parentTagName = stringToLowerCase(parent2.tagName);
            if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
              return false;
            }
            if (element.namespaceURI === SVG_NAMESPACE) {
              if (parent2.namespaceURI === HTML_NAMESPACE) {
                return tagName === "svg";
              }
              if (parent2.namespaceURI === MATHML_NAMESPACE) {
                return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
              }
              return Boolean(ALL_SVG_TAGS[tagName]);
            }
            if (element.namespaceURI === MATHML_NAMESPACE) {
              if (parent2.namespaceURI === HTML_NAMESPACE) {
                return tagName === "math";
              }
              if (parent2.namespaceURI === SVG_NAMESPACE) {
                return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
              }
              return Boolean(ALL_MATHML_TAGS[tagName]);
            }
            if (element.namespaceURI === HTML_NAMESPACE) {
              if (parent2.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              if (parent2.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
            }
            if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
              return true;
            }
            return false;
          };
          const _forceRemove = function _forceRemove2(node) {
            arrayPush2(DOMPurify3.removed, {
              element: node
            });
            try {
              getParentNode(node).removeChild(node);
            } catch (_) {
              remove3(node);
            }
          };
          const _removeAttribute = function _removeAttribute2(name2, node) {
            try {
              arrayPush2(DOMPurify3.removed, {
                attribute: node.getAttributeNode(name2),
                from: node
              });
            } catch (_) {
              arrayPush2(DOMPurify3.removed, {
                attribute: null,
                from: node
              });
            }
            node.removeAttribute(name2);
            if (name2 === "is" && !ALLOWED_ATTR[name2]) {
              if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
                try {
                  _forceRemove(node);
                } catch (_) {
                }
              } else {
                try {
                  node.setAttribute(name2, "");
                } catch (_) {
                }
              }
            }
          };
          const _initDocument = function _initDocument2(dirty) {
            let doc = null;
            let leadingWhitespace = null;
            if (FORCE_BODY) {
              dirty = "<remove></remove>" + dirty;
            } else {
              const matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
              leadingWhitespace = matches2 && matches2[0];
            }
            if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
              dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
            }
            const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
            if (NAMESPACE === HTML_NAMESPACE) {
              try {
                doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
              } catch (_) {
              }
            }
            if (!doc || !doc.documentElement) {
              doc = implementation.createDocument(NAMESPACE, "template", null);
              try {
                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
              } catch (_) {
              }
            }
            const body = doc.body || doc.documentElement;
            if (dirty && leadingWhitespace) {
              body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
            }
            if (NAMESPACE === HTML_NAMESPACE) {
              return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
            }
            return WHOLE_DOCUMENT ? doc.documentElement : body;
          };
          const _createNodeIterator = function _createNodeIterator2(root2) {
            return createNodeIterator.call(
              root2.ownerDocument || root2,
              root2,
              // eslint-disable-next-line no-bitwise
              NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
              null
            );
          };
          const _isClobbered = function _isClobbered2(elm) {
            return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
          };
          const _isNode = function _isNode2(object) {
            return typeof Node2 === "function" && object instanceof Node2;
          };
          const _executeHook = function _executeHook2(entryPoint, currentNode, data2) {
            if (!hooks[entryPoint]) {
              return;
            }
            arrayForEach(hooks[entryPoint], (hook) => {
              hook.call(DOMPurify3, currentNode, data2, CONFIG);
            });
          };
          const _sanitizeElements = function _sanitizeElements2(currentNode) {
            let content = null;
            _executeHook("beforeSanitizeElements", currentNode, null);
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            const tagName = transformCaseFunc(currentNode.nodeName);
            _executeHook("uponSanitizeElement", currentNode, {
              tagName,
              allowedTags: ALLOWED_TAGS
            });
            if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
              _forceRemove(currentNode);
              return true;
            }
            if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
              _forceRemove(currentNode);
              return true;
            }
            if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
              _forceRemove(currentNode);
              return true;
            }
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
                  return false;
                }
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
                  return false;
                }
              }
              if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
                const parentNode = getParentNode(currentNode) || currentNode.parentNode;
                const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
                if (childNodes && parentNode) {
                  const childCount = childNodes.length;
                  for (let i2 = childCount - 1; i2 >= 0; --i2) {
                    const childClone = cloneNode(childNodes[i2], true);
                    childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                    parentNode.insertBefore(childClone, getNextSibling(currentNode));
                  }
                }
              }
              _forceRemove(currentNode);
              return true;
            }
            if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
              content = currentNode.textContent;
              arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
                content = stringReplace(content, expr, " ");
              });
              if (currentNode.textContent !== content) {
                arrayPush2(DOMPurify3.removed, {
                  element: currentNode.cloneNode()
                });
                currentNode.textContent = content;
              }
            }
            _executeHook("afterSanitizeElements", currentNode, null);
            return false;
          };
          const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
            if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
              return false;
            }
            if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
            else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
              if (
                // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
              ) ;
              else {
                return false;
              }
            } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
            else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
            else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
            else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
            else if (value) {
              return false;
            } else ;
            return true;
          };
          const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
            return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
          };
          const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
            _executeHook("beforeSanitizeAttributes", currentNode, null);
            const {
              attributes
            } = currentNode;
            if (!attributes) {
              return;
            }
            const hookEvent = {
              attrName: "",
              attrValue: "",
              keepAttr: true,
              allowedAttributes: ALLOWED_ATTR
            };
            let l = attributes.length;
            while (l--) {
              const attr = attributes[l];
              const {
                name: name2,
                namespaceURI,
                value: attrValue
              } = attr;
              const lcName = transformCaseFunc(name2);
              let value = name2 === "value" ? attrValue : stringTrim(attrValue);
              hookEvent.attrName = lcName;
              hookEvent.attrValue = value;
              hookEvent.keepAttr = true;
              hookEvent.forceKeepAttr = void 0;
              _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
              value = hookEvent.attrValue;
              if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
                _removeAttribute(name2, currentNode);
                continue;
              }
              if (hookEvent.forceKeepAttr) {
                continue;
              }
              _removeAttribute(name2, currentNode);
              if (!hookEvent.keepAttr) {
                continue;
              }
              if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
                _removeAttribute(name2, currentNode);
                continue;
              }
              if (SAFE_FOR_TEMPLATES) {
                arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
                  value = stringReplace(value, expr, " ");
                });
              }
              const lcTag = transformCaseFunc(currentNode.nodeName);
              if (!_isValidAttribute(lcTag, lcName, value)) {
                continue;
              }
              if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
                _removeAttribute(name2, currentNode);
                value = SANITIZE_NAMED_PROPS_PREFIX + value;
              }
              if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
                if (namespaceURI) ;
                else {
                  switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                    case "TrustedHTML": {
                      value = trustedTypesPolicy.createHTML(value);
                      break;
                    }
                    case "TrustedScriptURL": {
                      value = trustedTypesPolicy.createScriptURL(value);
                      break;
                    }
                  }
                }
              }
              try {
                if (namespaceURI) {
                  currentNode.setAttributeNS(namespaceURI, name2, value);
                } else {
                  currentNode.setAttribute(name2, value);
                }
                if (_isClobbered(currentNode)) {
                  _forceRemove(currentNode);
                } else {
                  arrayPop(DOMPurify3.removed);
                }
              } catch (_) {
              }
            }
            _executeHook("afterSanitizeAttributes", currentNode, null);
          };
          const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
            let shadowNode = null;
            const shadowIterator = _createNodeIterator(fragment);
            _executeHook("beforeSanitizeShadowDOM", fragment, null);
            while (shadowNode = shadowIterator.nextNode()) {
              _executeHook("uponSanitizeShadowNode", shadowNode, null);
              if (_sanitizeElements(shadowNode)) {
                continue;
              }
              if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM2(shadowNode.content);
              }
              _sanitizeAttributes(shadowNode);
            }
            _executeHook("afterSanitizeShadowDOM", fragment, null);
          };
          DOMPurify3.sanitize = function(dirty) {
            let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            let body = null;
            let importedNode = null;
            let currentNode = null;
            let returnNode = null;
            IS_EMPTY_INPUT = !dirty;
            if (IS_EMPTY_INPUT) {
              dirty = "<!-->";
            }
            if (typeof dirty !== "string" && !_isNode(dirty)) {
              if (typeof dirty.toString === "function") {
                dirty = dirty.toString();
                if (typeof dirty !== "string") {
                  throw typeErrorCreate("dirty is not a string, aborting");
                }
              } else {
                throw typeErrorCreate("toString is not a function");
              }
            }
            if (!DOMPurify3.isSupported) {
              return dirty;
            }
            if (!SET_CONFIG) {
              _parseConfig(cfg);
            }
            DOMPurify3.removed = [];
            if (typeof dirty === "string") {
              IN_PLACE = false;
            }
            if (IN_PLACE) {
              if (dirty.nodeName) {
                const tagName = transformCaseFunc(dirty.nodeName);
                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                  throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
                }
              }
            } else if (dirty instanceof Node2) {
              body = _initDocument("<!---->");
              importedNode = body.ownerDocument.importNode(dirty, true);
              if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
                body = importedNode;
              } else if (importedNode.nodeName === "HTML") {
                body = importedNode;
              } else {
                body.appendChild(importedNode);
              }
            } else {
              if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
              dirty.indexOf("<") === -1) {
                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
              }
              body = _initDocument(dirty);
              if (!body) {
                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
              }
            }
            if (body && FORCE_BODY) {
              _forceRemove(body.firstChild);
            }
            const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
            while (currentNode = nodeIterator.nextNode()) {
              if (_sanitizeElements(currentNode)) {
                continue;
              }
              if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
              }
              _sanitizeAttributes(currentNode);
            }
            if (IN_PLACE) {
              return dirty;
            }
            if (RETURN_DOM) {
              if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);
                while (body.firstChild) {
                  returnNode.appendChild(body.firstChild);
                }
              } else {
                returnNode = body;
              }
              if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
                returnNode = importNode.call(originalDocument, returnNode, true);
              }
              return returnNode;
            }
            let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
            if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
              serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
            }
            if (SAFE_FOR_TEMPLATES) {
              arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
                serializedHTML = stringReplace(serializedHTML, expr, " ");
              });
            }
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
          };
          DOMPurify3.setConfig = function() {
            let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            _parseConfig(cfg);
            SET_CONFIG = true;
          };
          DOMPurify3.clearConfig = function() {
            CONFIG = null;
            SET_CONFIG = false;
          };
          DOMPurify3.isValidAttribute = function(tag, attr, value) {
            if (!CONFIG) {
              _parseConfig({});
            }
            const lcTag = transformCaseFunc(tag);
            const lcName = transformCaseFunc(attr);
            return _isValidAttribute(lcTag, lcName, value);
          };
          DOMPurify3.addHook = function(entryPoint, hookFunction) {
            if (typeof hookFunction !== "function") {
              return;
            }
            hooks[entryPoint] = hooks[entryPoint] || [];
            arrayPush2(hooks[entryPoint], hookFunction);
          };
          DOMPurify3.removeHook = function(entryPoint) {
            if (hooks[entryPoint]) {
              return arrayPop(hooks[entryPoint]);
            }
          };
          DOMPurify3.removeHooks = function(entryPoint) {
            if (hooks[entryPoint]) {
              hooks[entryPoint] = [];
            }
          };
          DOMPurify3.removeAllHooks = function() {
            hooks = {};
          };
          return DOMPurify3;
        }
        var purify = createDOMPurify();
        return purify;
      });
    }
  });

  // node_modules/suncalc/suncalc.js
  var require_suncalc = __commonJS({
    "node_modules/suncalc/suncalc.js"(exports2, module84) {
      (function() {
        "use strict";
        var PI = Math.PI, sin = Math.sin, cos = Math.cos, tan = Math.tan, asin = Math.asin, atan = Math.atan2, acos = Math.acos, rad = PI / 180;
        var dayMs = 1e3 * 60 * 60 * 24, J1970 = 2440588, J2000 = 2451545;
        function toJulian(date) {
          return date.valueOf() / dayMs - 0.5 + J1970;
        }
        function fromJulian(j) {
          return new Date((j + 0.5 - J1970) * dayMs);
        }
        function toDays(date) {
          return toJulian(date) - J2000;
        }
        var e2 = rad * 23.4397;
        function rightAscension(l, b2) {
          return atan(sin(l) * cos(e2) - tan(b2) * sin(e2), cos(l));
        }
        function declination(l, b2) {
          return asin(sin(b2) * cos(e2) + cos(b2) * sin(e2) * sin(l));
        }
        function azimuth(H, phi, dec) {
          return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
        }
        function altitude(H, phi, dec) {
          return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
        }
        function siderealTime(d, lw) {
          return rad * (280.16 + 360.9856235 * d) - lw;
        }
        function astroRefraction(h) {
          if (h < 0)
            h = 0;
          return 2967e-7 / Math.tan(h + 312536e-8 / (h + 0.08901179));
        }
        function solarMeanAnomaly(d) {
          return rad * (357.5291 + 0.98560028 * d);
        }
        function eclipticLongitude(M) {
          var C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 3e-4 * sin(3 * M)), P = rad * 102.9372;
          return M + C + P + PI;
        }
        function sunCoords(d) {
          var M = solarMeanAnomaly(d), L = eclipticLongitude(M);
          return {
            dec: declination(L, 0),
            ra: rightAscension(L, 0)
          };
        }
        var SunCalc = {};
        SunCalc.getPosition = function(date, lat, lng) {
          var lw = rad * -lng, phi = rad * lat, d = toDays(date), c2 = sunCoords(d), H = siderealTime(d, lw) - c2.ra;
          return {
            azimuth: azimuth(H, phi, c2.dec),
            altitude: altitude(H, phi, c2.dec)
          };
        };
        var times = SunCalc.times = [
          [-0.833, "sunrise", "sunset"],
          [-0.3, "sunriseEnd", "sunsetStart"],
          [-6, "dawn", "dusk"],
          [-12, "nauticalDawn", "nauticalDusk"],
          [-18, "nightEnd", "night"],
          [6, "goldenHourEnd", "goldenHour"]
        ];
        SunCalc.addTime = function(angle, riseName, setName) {
          times.push([angle, riseName, setName]);
        };
        var J0 = 9e-4;
        function julianCycle(d, lw) {
          return Math.round(d - J0 - lw / (2 * PI));
        }
        function approxTransit(Ht, lw, n) {
          return J0 + (Ht + lw) / (2 * PI) + n;
        }
        function solarTransitJ(ds, M, L) {
          return J2000 + ds + 53e-4 * sin(M) - 69e-4 * sin(2 * L);
        }
        function hourAngle(h, phi, d) {
          return acos((sin(h) - sin(phi) * sin(d)) / (cos(phi) * cos(d)));
        }
        function observerAngle(height) {
          return -2.076 * Math.sqrt(height) / 60;
        }
        function getSetJ(h, lw, phi, dec, n, M, L) {
          var w = hourAngle(h, phi, dec), a2 = approxTransit(w, lw, n);
          return solarTransitJ(a2, M, L);
        }
        SunCalc.getTimes = function(date, lat, lng, height) {
          height = height || 0;
          var lw = rad * -lng, phi = rad * lat, dh = observerAngle(height), d = toDays(date), n = julianCycle(d, lw), ds = approxTransit(0, lw, n), M = solarMeanAnomaly(ds), L = eclipticLongitude(M), dec = declination(L, 0), Jnoon = solarTransitJ(ds, M, L), i2, len, time, h0, Jset, Jrise;
          var result = {
            solarNoon: fromJulian(Jnoon),
            nadir: fromJulian(Jnoon - 0.5)
          };
          for (i2 = 0, len = times.length; i2 < len; i2 += 1) {
            time = times[i2];
            h0 = (time[0] + dh) * rad;
            Jset = getSetJ(h0, lw, phi, dec, n, M, L);
            Jrise = Jnoon - (Jset - Jnoon);
            result[time[1]] = fromJulian(Jrise);
            result[time[2]] = fromJulian(Jset);
          }
          return result;
        };
        function moonCoords(d) {
          var L = rad * (218.316 + 13.176396 * d), M = rad * (134.963 + 13.064993 * d), F = rad * (93.272 + 13.22935 * d), l = L + rad * 6.289 * sin(M), b2 = rad * 5.128 * sin(F), dt = 385001 - 20905 * cos(M);
          return {
            ra: rightAscension(l, b2),
            dec: declination(l, b2),
            dist: dt
          };
        }
        SunCalc.getMoonPosition = function(date, lat, lng) {
          var lw = rad * -lng, phi = rad * lat, d = toDays(date), c2 = moonCoords(d), H = siderealTime(d, lw) - c2.ra, h = altitude(H, phi, c2.dec), pa = atan(sin(H), tan(phi) * cos(c2.dec) - sin(c2.dec) * cos(H));
          h = h + astroRefraction(h);
          return {
            azimuth: azimuth(H, phi, c2.dec),
            altitude: h,
            distance: c2.dist,
            parallacticAngle: pa
          };
        };
        SunCalc.getMoonIllumination = function(date) {
          var d = toDays(date || /* @__PURE__ */ new Date()), s = sunCoords(d), m = moonCoords(d), sdist = 149598e3, phi = acos(sin(s.dec) * sin(m.dec) + cos(s.dec) * cos(m.dec) * cos(s.ra - m.ra)), inc = atan(sdist * sin(phi), m.dist - sdist * cos(phi)), angle = atan(cos(s.dec) * sin(s.ra - m.ra), sin(s.dec) * cos(m.dec) - cos(s.dec) * sin(m.dec) * cos(s.ra - m.ra));
          return {
            fraction: (1 + cos(inc)) / 2,
            phase: 0.5 + 0.5 * inc * (angle < 0 ? -1 : 1) / Math.PI,
            angle
          };
        };
        function hoursLater(date, h) {
          return new Date(date.valueOf() + h * dayMs / 24);
        }
        SunCalc.getMoonTimes = function(date, lat, lng, inUTC) {
          var t2 = new Date(date);
          if (inUTC) t2.setUTCHours(0, 0, 0, 0);
          else t2.setHours(0, 0, 0, 0);
          var hc = 0.133 * rad, h0 = SunCalc.getMoonPosition(t2, lat, lng).altitude - hc, h1, h2, rise, set6, a2, b2, xe, ye, d, roots, x1, x2, dx;
          for (var i2 = 1; i2 <= 24; i2 += 2) {
            h1 = SunCalc.getMoonPosition(hoursLater(t2, i2), lat, lng).altitude - hc;
            h2 = SunCalc.getMoonPosition(hoursLater(t2, i2 + 1), lat, lng).altitude - hc;
            a2 = (h0 + h2) / 2 - h1;
            b2 = (h2 - h0) / 2;
            xe = -b2 / (2 * a2);
            ye = (a2 * xe + b2) * xe + h1;
            d = b2 * b2 - 4 * a2 * h1;
            roots = 0;
            if (d >= 0) {
              dx = Math.sqrt(d) / (Math.abs(a2) * 2);
              x1 = xe - dx;
              x2 = xe + dx;
              if (Math.abs(x1) <= 1) roots++;
              if (Math.abs(x2) <= 1) roots++;
              if (x1 < -1) x1 = x2;
            }
            if (roots === 1) {
              if (h0 < 0) rise = i2 + x1;
              else set6 = i2 + x1;
            } else if (roots === 2) {
              rise = i2 + (ye < 0 ? x2 : x1);
              set6 = i2 + (ye < 0 ? x1 : x2);
            }
            if (rise && set6) break;
            h0 = h2;
          }
          var result = {};
          if (rise) result.rise = hoursLater(t2, rise);
          if (set6) result.set = hoursLater(t2, set6);
          if (!rise && !set6) result[ye > 0 ? "alwaysUp" : "alwaysDown"] = true;
          return result;
        };
        if (typeof exports2 === "object" && typeof module84 !== "undefined") module84.exports = SunCalc;
        else if (typeof define === "function" && define.amd) define(SunCalc);
        else window.SunCalc = SunCalc;
      })();
    }
  });

  // lib/vendor/guiders.js
  var guiders_exports = {};
  __export(guiders_exports, {
    guiders: () => guiders
  });
  var import_jquery13, guiders;
  var init_guiders = __esm({
    "lib/vendor/guiders.js"() {
      import_jquery13 = __toESM(require_jquery(), 1);
      guiders = {};
      (() => {
        guiders.version = "2.0.0";
        guiders._defaultSettings = {
          attachTo: null,
          // Selector of the element to attach to.
          autoFocus: false,
          // Determines whether or not the browser scrolls to the element.
          buttons: [{ name: "Close" }],
          buttonCustomHTML: "",
          classString: null,
          closeOnEscape: false,
          description: "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
          highlight: null,
          isHashable: true,
          maxWidth: null,
          offset: {
            top: null,
            left: null
          },
          onClose: null,
          onHide: null,
          onShow: null,
          overlay: false,
          position: 0,
          // 1-12 follows an analog clock, 0 means centered.
          shouldSkip: function() {
          },
          // Optional handler allows you to skip a guider if returns true.
          title: "Sample title goes here",
          width: 400,
          xButton: false
          // This places a closer "x" button in the top right of the guider.
        };
        guiders._htmlSkeleton = [
          "<div class='guider'>",
          "  <div class='guiders_content'>",
          "    <h1 class='guiders_title'></h1>",
          "    <div class='guiders_close'></div>",
          "    <p class='guiders_description'></p>",
          "    <div class='guiders_buttons_container'>",
          "    </div>",
          "  </div>",
          "  <div class='guiders_arrow'>",
          "  </div>",
          "</div>"
        ].join("");
        guiders._arrowSize = 42;
        guiders._backButtonTitle = "Back";
        guiders._buttonAttributes = { "href": "javascript:void(0);" };
        guiders._buttonClassName = "guiders_button";
        guiders._buttonClickEvent = "click touch";
        guiders._buttonElement = "<a></a>";
        guiders._closeButtonTitle = "Close";
        guiders._currentGuiderID = null;
        guiders._fixedOrAbsolute = "fixed";
        guiders._guiders = {};
        guiders._lastCreatedGuiderID = null;
        guiders._nextButtonTitle = "Next";
        guiders._offsetNameMapping = {
          "topLeft": 11,
          "top": 12,
          "topRight": 1,
          "rightTop": 2,
          "right": 3,
          "rightBottom": 4,
          "bottomRight": 5,
          "bottom": 6,
          "bottomLeft": 7,
          "leftBottom": 8,
          "left": 9,
          "leftTop": 10
        };
        guiders._windowHeight = 0;
        var ieBrowserMatch = navigator.userAgent.match(/MSIE\s([\d.]+)/);
        guiders._isIE = ieBrowserMatch && ieBrowserMatch.length > 1;
        guiders._ieVersion = ieBrowserMatch && ieBrowserMatch.length > 1 ? Number(ieBrowserMatch[1]) : -1;
        guiders._addButtons = function(myGuider) {
          var guiderButtonsContainer = myGuider.elem.find(".guiders_buttons_container");
          if (myGuider.buttons === null || myGuider.buttons.length === 0) {
            guiderButtonsContainer.remove();
            return;
          }
          for (var i2 = myGuider.buttons.length - 1; i2 >= 0; i2--) {
            var thisButton = myGuider.buttons[i2];
            var thisButtonElem = (0, import_jquery13.default)(
              guiders._buttonElement,
              import_jquery13.default.extend({ "class": guiders._buttonClassName, "html": thisButton.name }, guiders._buttonAttributes, thisButton.html || {})
            );
            if (typeof thisButton.classString !== "undefined" && thisButton.classString !== null) {
              thisButtonElem.addClass(thisButton.classString);
            }
            guiderButtonsContainer.append(thisButtonElem);
            var thisButtonName = thisButton.name.toLowerCase();
            if (thisButton.onclick) {
              thisButtonElem.bind(guiders._buttonClickEvent, thisButton.onclick);
            } else {
              switch (thisButtonName) {
                case guiders._closeButtonTitle.toLowerCase():
                  thisButtonElem.bind(guiders._buttonClickEvent, function() {
                    guiders.hideAll();
                    if (myGuider.onClose) {
                      myGuider.onClose(
                        myGuider,
                        false
                        /* close by button */
                      );
                    }
                    (0, import_jquery13.default)("body").trigger("guidersClose");
                  });
                  break;
                case guiders._nextButtonTitle.toLowerCase():
                  thisButtonElem.bind(guiders._buttonClickEvent, function() {
                    !myGuider.elem.data("locked") && guiders.next();
                  });
                  break;
                case guiders._backButtonTitle.toLowerCase():
                  thisButtonElem.bind(guiders._buttonClickEvent, function() {
                    !myGuider.elem.data("locked") && guiders.prev();
                  });
                  break;
              }
            }
          }
          if (myGuider.buttonCustomHTML !== "") {
            var myCustomHTML = (0, import_jquery13.default)(myGuider.buttonCustomHTML);
            myGuider.elem.find(".guiders_buttons_container").append(myCustomHTML);
          }
          if (myGuider.buttons.length === 0) {
            guiderButtonsContainer.remove();
          }
        };
        guiders._addXButton = function(myGuider) {
          var xButtonContainer = myGuider.elem.find(".guiders_close");
          var xButton = (0, import_jquery13.default)("<div></div>", {
            "class": "guiders_x_button",
            "role": "button"
          });
          xButtonContainer.append(xButton);
          xButton.click(function() {
            guiders.hideAll();
            if (myGuider.onClose) {
              myGuider.onClose(myGuider, true);
            }
            (0, import_jquery13.default)("body").trigger("guidersClose");
          });
        };
        guiders._attach = function(myGuider) {
          if (typeof myGuider !== "object") {
            return;
          }
          var attachTo = (0, import_jquery13.default)(myGuider.attachTo);
          var myHeight = myGuider.elem.innerHeight();
          var myWidth = myGuider.elem.innerWidth();
          if (myGuider.position === 0 || attachTo.length === 0) {
            var fixedOrAbsolute = "fixed";
            if (guiders._isIE && guiders._ieVersion < 9) {
              fixedOrAbsolute = "absolute";
            }
            myGuider.elem.css("position", fixedOrAbsolute);
            myGuider.elem.css("top", ((0, import_jquery13.default)(window).height() - myHeight) / 3 + "px");
            myGuider.elem.css("left", ((0, import_jquery13.default)(window).width() - myWidth) / 2 + "px");
            return;
          }
          var base = attachTo.offset();
          var top = base.top;
          var left = base.left;
          var topMarginOfBody = (0, import_jquery13.default)("body").outerHeight(true) - (0, import_jquery13.default)("body").outerHeight(false);
          top -= topMarginOfBody;
          if (guiders._offsetNameMapping[myGuider.position]) {
            myGuider.position = guiders._offsetNameMapping[myGuider.position];
          }
          var attachToHeight = attachTo.innerHeight();
          var attachToWidth = attachTo.innerWidth();
          var bufferOffset = 0.9 * guiders._arrowSize;
          var offsetMap = {
            1: [-bufferOffset - myHeight, attachToWidth - myWidth],
            2: [0, bufferOffset + attachToWidth],
            3: [attachToHeight / 2 - myHeight / 2, bufferOffset + attachToWidth],
            4: [attachToHeight - myHeight, bufferOffset + attachToWidth],
            5: [bufferOffset + attachToHeight, attachToWidth - myWidth],
            6: [bufferOffset + attachToHeight, attachToWidth / 2 - myWidth / 2],
            7: [bufferOffset + attachToHeight, 0],
            8: [attachToHeight - myHeight, -myWidth - bufferOffset],
            9: [attachToHeight / 2 - myHeight / 2, -myWidth - bufferOffset],
            10: [0, -myWidth - bufferOffset],
            11: [-bufferOffset - myHeight, 0],
            12: [-bufferOffset - myHeight, attachToWidth / 2 - myWidth / 2]
          };
          var offset = offsetMap[myGuider.position];
          top += offset[0];
          left += offset[1];
          var positionType = "absolute";
          if (attachTo.css("position") === "fixed" && guiders._fixedOrAbsolute === "fixed") {
            positionType = "fixed";
            top -= (0, import_jquery13.default)(window).scrollTop();
            left -= (0, import_jquery13.default)(window).scrollLeft();
          }
          if (myGuider.offset.top !== null) {
            top += myGuider.offset.top;
          }
          if (myGuider.offset.left !== null) {
            left += myGuider.offset.left;
          }
          guiders._styleArrow(myGuider);
          myGuider.elem.css({
            "position": positionType,
            "top": top,
            "left": left
          });
          return myGuider;
        };
        guiders._dehighlightElement = function(selector) {
          (0, import_jquery13.default)(selector).removeClass("guiders_highlight");
        };
        guiders._hideOverlay = function() {
          (0, import_jquery13.default)("#guiders_overlay").fadeOut("fast");
        };
        guiders._highlightElement = function(selector) {
          (0, import_jquery13.default)(selector).addClass("guiders_highlight");
        };
        guiders._initializeOverlay = function() {
          if ((0, import_jquery13.default)("#guiders_overlay").length === 0) {
            (0, import_jquery13.default)("<div id='guiders_overlay'></div>").hide().appendTo("body");
          }
        };
        guiders._showOverlay = function(myGuider) {
          (0, import_jquery13.default)("#guiders_overlay").fadeIn("fast", function() {
            if (this.style.removeAttribute) {
              this.style.removeAttribute("filter");
            }
          });
          if (guiders._isIE) {
            (0, import_jquery13.default)("#guiders_overlay").css("position", "absolute");
          }
        };
        guiders._styleArrow = function(myGuider) {
          var position = myGuider.position || 0;
          if (!position) {
            return;
          }
          var myGuiderArrow = (0, import_jquery13.default)(myGuider.elem.find(".guiders_arrow"));
          var newClass = {
            1: "guiders_arrow_down",
            2: "guiders_arrow_left",
            3: "guiders_arrow_left",
            4: "guiders_arrow_left",
            5: "guiders_arrow_up",
            6: "guiders_arrow_up",
            7: "guiders_arrow_up",
            8: "guiders_arrow_right",
            9: "guiders_arrow_right",
            10: "guiders_arrow_right",
            11: "guiders_arrow_down",
            12: "guiders_arrow_down"
          };
          myGuiderArrow.addClass(newClass[position]);
          var myHeight = myGuider.elem.innerHeight();
          var myWidth = myGuider.elem.innerWidth();
          var arrowOffset = guiders._arrowSize / 2;
          var positionMap = {
            1: ["right", arrowOffset],
            2: ["top", arrowOffset],
            3: ["top", myHeight / 2 - arrowOffset],
            4: ["bottom", arrowOffset],
            5: ["right", arrowOffset],
            6: ["left", myWidth / 2 - arrowOffset],
            7: ["left", arrowOffset],
            8: ["bottom", arrowOffset],
            9: ["top", myHeight / 2 - arrowOffset],
            10: ["top", arrowOffset],
            11: ["left", arrowOffset],
            12: ["left", myWidth / 2 - arrowOffset]
          };
          var position = positionMap[myGuider.position];
          myGuiderArrow.css(position[0], position[1] + "px");
        };
        guiders._showIfHashed = function(myGuider) {
          var GUIDER_HASH_TAG = "guider=";
          var hashIndex = window.location.hash.indexOf(GUIDER_HASH_TAG);
          if (hashIndex !== -1) {
            var hashGuiderId = window.location.hash.substr(hashIndex + GUIDER_HASH_TAG.length);
            if (myGuider.id.toLowerCase() === hashGuiderId.toLowerCase()) {
              guiders.show(myGuider.id);
            }
          }
        };
        guiders._updatePositionOnResize = function() {
          var _resizing = void 0;
          (0, import_jquery13.default)(window).resize(function() {
            if (typeof _resizing !== "undefined") {
              clearTimeout(_resizing);
            }
            _resizing = setTimeout(function() {
              _resizing = void 0;
              if (typeof guiders !== "undefined") {
                guiders.reposition();
              }
            }, 20);
          });
        };
        guiders._updatePositionOnResize();
        guiders._unwireEscape = function(myGuider) {
          (0, import_jquery13.default)(document).unbind("keydown");
        };
        guiders._wireEscape = function(myGuider) {
          (0, import_jquery13.default)(document).keydown(function(event) {
            if (event.keyCode == 27 || event.which == 27) {
              guiders.hideAll();
              if (myGuider.onClose) {
                myGuider.onClose(
                  myGuider,
                  true
                  /*close by X/Escape*/
                );
              }
              (0, import_jquery13.default)("body").trigger("guidersClose");
              return false;
            }
          });
        };
        guiders.createGuider = function(passedSettings) {
          if (passedSettings === null || passedSettings === void 0) {
            passedSettings = {};
          }
          var myGuider = import_jquery13.default.extend({}, guiders._defaultSettings, passedSettings);
          myGuider.id = myGuider.id || "guider_random_" + String(Math.floor(Math.random() * 1e3));
          var guiderElement = (0, import_jquery13.default)("#" + myGuider.id);
          if (!guiderElement.length) {
            guiderElement = (0, import_jquery13.default)(guiders._htmlSkeleton);
          }
          myGuider.elem = guiderElement;
          if (typeof myGuider.classString !== "undefined" && myGuider.classString !== null) {
            myGuider.elem.addClass(myGuider.classString);
          }
          if (Number(myGuider.width) === myGuider.width) {
            myGuider.width = String(myGuider.width) + "px";
          }
          if (Number(myGuider.maxWidth) === myGuider.maxWidth) {
            myGuider.maxWidth = String(myGuider.maxWidth) + "px";
          }
          myGuider.elem.css("width", myGuider.width);
          myGuider.elem.css("maxWidth", myGuider.maxWidth);
          var guiderTitleContainer = guiderElement.find(".guiders_title");
          guiderTitleContainer.html(myGuider.title);
          guiderElement.find(".guiders_description").html(myGuider.description);
          guiders._addButtons(myGuider);
          if (myGuider.xButton) {
            guiders._addXButton(myGuider);
          }
          guiderElement.hide();
          guiderElement.appendTo("body");
          guiderElement.attr("id", myGuider.id);
          if (typeof myGuider.attachTo !== "undefined" && myGuider !== null) {
            guiders._attach(myGuider);
          }
          guiders._initializeOverlay();
          guiders._guiders[myGuider.id] = myGuider;
          if (guiders._lastCreatedGuiderID != null) {
            myGuider.prev = guiders._lastCreatedGuiderID;
          }
          guiders._lastCreatedGuiderID = myGuider.id;
          if (myGuider.isHashable) {
            guiders._showIfHashed(myGuider);
          }
          return guiders;
        };
        guiders.get = function(id2) {
          if (typeof guiders._guiders[id2] === "undefined") {
            return null;
          }
          return guiders._guiders[id2] || null;
        };
        guiders.getCurrentGuider = function() {
          return guiders._guiders[guiders._currentGuiderID] || null;
        };
        guiders.hideAll = function(omitHidingOverlay, next) {
          next = next || false;
          (0, import_jquery13.default)(".guider:visible").each(function(index2, elem) {
            var myGuider = guiders.get((0, import_jquery13.default)(elem).attr("id"));
            if (myGuider.onHide) {
              myGuider.onHide(myGuider, next);
            }
          });
          (0, import_jquery13.default)(".guider").fadeOut("fast");
          var currentGuider = guiders._guiders[guiders._currentGuiderID];
          if (currentGuider && currentGuider.highlight) {
            guiders._dehighlightElement(currentGuider.highlight);
          }
          if (typeof omitHidingOverlay !== "undefined" && omitHidingOverlay === true) {
          } else {
            guiders._hideOverlay();
          }
          return guiders;
        };
        guiders.next = function() {
          var currentGuider = guiders._guiders[guiders._currentGuiderID];
          if (typeof currentGuider === "undefined") {
            return null;
          }
          currentGuider.elem.data("locked", true);
          var nextGuiderId = currentGuider.next || null;
          if (nextGuiderId !== null && nextGuiderId !== "") {
            var nextGuider = guiders.get(nextGuiderId);
            var omitHidingOverlay = nextGuider.overlay ? true : false;
            guiders.hideAll(omitHidingOverlay, true);
            if (currentGuider && currentGuider.highlight) {
              guiders._dehighlightElement(currentGuider.highlight);
            }
            if (nextGuider.shouldSkip && nextGuider.shouldSkip()) {
              guiders._currentGuiderID = nextGuider.id;
              guiders.next();
              return guiders.getCurrentGuider();
            } else {
              guiders.show(nextGuiderId);
              return guiders.getCurrentGuider();
            }
          }
        };
        guiders.prev = function() {
          var currentGuider = guiders._guiders[guiders._currentGuiderID];
          if (typeof currentGuider === "undefined") {
            return null;
          }
          if (currentGuider.prev === null) {
            return null;
          }
          var prevGuider = guiders._guiders[currentGuider.prev];
          prevGuider.elem.data("locked", true);
          var prevGuiderId = prevGuider.id || null;
          if (prevGuiderId !== null && prevGuiderId !== "") {
            var myGuider = guiders.get(prevGuiderId);
            var omitHidingOverlay = myGuider.overlay ? true : false;
            guiders.hideAll(omitHidingOverlay, true);
            if (prevGuider && prevGuider.highlight) {
              guiders._dehighlightElement(prevGuider.highlight);
            }
            guiders.show(prevGuiderId);
            return myGuider;
          }
        };
        guiders.reposition = function() {
          var currentGuider = guiders._guiders[guiders._currentGuiderID];
          guiders._attach(currentGuider);
        };
        guiders.scrollToCurrent = function() {
          var currentGuider = guiders._guiders[guiders._currentGuiderID];
          if (typeof currentGuider === "undefined") {
            return;
          }
          var windowHeight = guiders._windowHeight;
          var scrollHeight = (0, import_jquery13.default)(window).scrollTop();
          var guiderOffset = currentGuider.elem.offset();
          var guiderElemHeight = currentGuider.elem.height();
          var scrollToHeight = Math.round(Math.max(guiderOffset.top + guiderElemHeight / 2 - windowHeight / 2, 0));
          window.scrollTo(0, scrollToHeight);
        };
        guiders.show = function(id2) {
          if (!id2 && guiders._lastCreatedGuiderID) {
            id2 = guiders._lastCreatedGuiderID;
          }
          var myGuider = guiders.get(id2);
          if (myGuider.overlay) {
            guiders._showOverlay(myGuider);
            if (myGuider.highlight && myGuider.attachTo) {
              guiders._highlightElement(myGuider.attachTo);
            }
          }
          if (myGuider.closeOnEscape) {
            guiders._wireEscape(myGuider);
          } else {
            guiders._unwireEscape(myGuider);
          }
          if (myGuider.onShow) {
            myGuider.onShow(myGuider);
          }
          guiders._attach(myGuider);
          myGuider.elem.fadeIn("fast").data("locked", false);
          guiders._currentGuiderID = id2;
          var windowHeight = guiders._windowHeight = (0, import_jquery13.default)(window).height();
          var scrollHeight = (0, import_jquery13.default)(window).scrollTop();
          var guiderOffset = myGuider.elem.offset();
          var guiderElemHeight = myGuider.elem.height();
          var isGuiderBelow = scrollHeight + windowHeight < guiderOffset.top + guiderElemHeight;
          var isGuiderAbove = guiderOffset.top < scrollHeight;
          if (myGuider.autoFocus && (isGuiderBelow || isGuiderAbove)) {
            setTimeout(guiders.scrollToCurrent, 10);
          }
          (0, import_jquery13.default)(myGuider.elem).trigger("guiders.show");
          return guiders;
        };
      })();
    }
  });

  // node_modules/semver/internal/debug.js
  var require_debug = __commonJS({
    "node_modules/semver/internal/debug.js"(exports2, module84) {
      var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
      module84.exports = debug;
    }
  });

  // node_modules/semver/internal/constants.js
  var require_constants = __commonJS({
    "node_modules/semver/internal/constants.js"(exports2, module84) {
      var SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER3 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
      9007199254740991;
      var MAX_SAFE_COMPONENT_LENGTH = 16;
      var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
      var RELEASE_TYPES = [
        "major",
        "premajor",
        "minor",
        "preminor",
        "patch",
        "prepatch",
        "prerelease"
      ];
      module84.exports = {
        MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER: MAX_SAFE_INTEGER3,
        RELEASE_TYPES,
        SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
      };
    }
  });

  // node_modules/semver/internal/re.js
  var require_re = __commonJS({
    "node_modules/semver/internal/re.js"(exports2, module84) {
      var {
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_LENGTH
      } = require_constants();
      var debug = require_debug();
      exports2 = module84.exports = {};
      var re = exports2.re = [];
      var safeRe = exports2.safeRe = [];
      var src = exports2.src = [];
      var t2 = exports2.t = {};
      var R = 0;
      var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
      var safeRegexReplacements = [
        ["\\s", 1],
        ["\\d", MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
      ];
      var makeSafeRegex = (value) => {
        for (const [token, max] of safeRegexReplacements) {
          value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
        }
        return value;
      };
      var createToken = (name2, value, isGlobal) => {
        const safe2 = makeSafeRegex(value);
        const index2 = R++;
        debug(name2, index2, value);
        t2[name2] = index2;
        src[index2] = value;
        re[index2] = new RegExp(value, isGlobal ? "g" : void 0);
        safeRe[index2] = new RegExp(safe2, isGlobal ? "g" : void 0);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
      createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
      createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
      createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
      createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
      createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
      createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
      createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
      createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
      createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
      createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
      createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
      createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
      createToken("COERCERTL", src[t2.COERCE], true);
      createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
      exports2.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
      createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
      exports2.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
      createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
      createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
      createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
      createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
      exports2.comparatorTrimReplace = "$1$2$3";
      createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    }
  });

  // node_modules/semver/internal/parse-options.js
  var require_parse_options = __commonJS({
    "node_modules/semver/internal/parse-options.js"(exports2, module84) {
      var looseOption = Object.freeze({ loose: true });
      var emptyOpts = Object.freeze({});
      var parseOptions = (options6) => {
        if (!options6) {
          return emptyOpts;
        }
        if (typeof options6 !== "object") {
          return looseOption;
        }
        return options6;
      };
      module84.exports = parseOptions;
    }
  });

  // node_modules/semver/internal/identifiers.js
  var require_identifiers = __commonJS({
    "node_modules/semver/internal/identifiers.js"(exports2, module84) {
      var numeric = /^[0-9]+$/;
      var compareIdentifiers = (a2, b2) => {
        const anum = numeric.test(a2);
        const bnum = numeric.test(b2);
        if (anum && bnum) {
          a2 = +a2;
          b2 = +b2;
        }
        return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
      };
      var rcompareIdentifiers = (a2, b2) => compareIdentifiers(b2, a2);
      module84.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    }
  });

  // node_modules/semver/classes/semver.js
  var require_semver = __commonJS({
    "node_modules/semver/classes/semver.js"(exports2, module84) {
      var debug = require_debug();
      var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER3 } = require_constants();
      var { safeRe: re, t: t2 } = require_re();
      var parseOptions = require_parse_options();
      var { compareIdentifiers } = require_identifiers();
      var SemVer = class _SemVer {
        constructor(version4, options6) {
          options6 = parseOptions(options6);
          if (version4 instanceof _SemVer) {
            if (version4.loose === !!options6.loose && version4.includePrerelease === !!options6.includePrerelease) {
              return version4;
            } else {
              version4 = version4.version;
            }
          } else if (typeof version4 !== "string") {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version4}".`);
          }
          if (version4.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`
            );
          }
          debug("SemVer", version4, options6);
          this.options = options6;
          this.loose = !!options6.loose;
          this.includePrerelease = !!options6.includePrerelease;
          const m = version4.trim().match(options6.loose ? re[t2.LOOSE] : re[t2.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version4}`);
          }
          this.raw = version4;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER3 || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER3 || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER3 || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map((id2) => {
              if (/^[0-9]+$/.test(id2)) {
                const num = +id2;
                if (num >= 0 && num < MAX_SAFE_INTEGER3) {
                  return num;
                }
              }
              return id2;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof _SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new _SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof _SemVer)) {
            other = new _SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof _SemVer)) {
            other = new _SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i2 = 0;
          do {
            const a2 = this.prerelease[i2];
            const b2 = other.prerelease[i2];
            debug("prerelease compare", i2, a2, b2);
            if (a2 === void 0 && b2 === void 0) {
              return 0;
            } else if (b2 === void 0) {
              return 1;
            } else if (a2 === void 0) {
              return -1;
            } else if (a2 === b2) {
              continue;
            } else {
              return compareIdentifiers(a2, b2);
            }
          } while (++i2);
        }
        compareBuild(other) {
          if (!(other instanceof _SemVer)) {
            other = new _SemVer(other, this.options);
          }
          let i2 = 0;
          do {
            const a2 = this.build[i2];
            const b2 = other.build[i2];
            debug("build compare", i2, a2, b2);
            if (a2 === void 0 && b2 === void 0) {
              return 0;
            } else if (b2 === void 0) {
              return 1;
            } else if (a2 === void 0) {
              return -1;
            } else if (a2 === b2) {
              continue;
            } else {
              return compareIdentifiers(a2, b2);
            }
          } while (++i2);
        }
        // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.
        inc(release, identifier, identifierBase) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier, identifierBase);
              this.inc("pre", identifier, identifierBase);
              break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier, identifierBase);
              }
              this.inc("pre", identifier, identifierBase);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case "pre": {
              const base = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === false) {
                throw new Error("invalid increment argument: identifier is empty");
              }
              if (this.prerelease.length === 0) {
                this.prerelease = [base];
              } else {
                let i2 = this.prerelease.length;
                while (--i2 >= 0) {
                  if (typeof this.prerelease[i2] === "number") {
                    this.prerelease[i2]++;
                    i2 = -2;
                  }
                }
                if (i2 === -1) {
                  if (identifier === this.prerelease.join(".") && identifierBase === false) {
                    throw new Error("invalid increment argument: identifier already exists");
                  }
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                let prerelease = [identifier, base];
                if (identifierBase === false) {
                  prerelease = [identifier];
                }
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = prerelease;
                  }
                } else {
                  this.prerelease = prerelease;
                }
              }
              break;
            }
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.raw = this.format();
          if (this.build.length) {
            this.raw += `+${this.build.join(".")}`;
          }
          return this;
        }
      };
      module84.exports = SemVer;
    }
  });

  // node_modules/semver/functions/compare.js
  var require_compare = __commonJS({
    "node_modules/semver/functions/compare.js"(exports2, module84) {
      var SemVer = require_semver();
      var compare = (a2, b2, loose) => new SemVer(a2, loose).compare(new SemVer(b2, loose));
      module84.exports = compare;
    }
  });

  // node_modules/semver/functions/gt.js
  var require_gt = __commonJS({
    "node_modules/semver/functions/gt.js"(exports2, module84) {
      var compare = require_compare();
      var gt = (a2, b2, loose) => compare(a2, b2, loose) > 0;
      module84.exports = gt;
    }
  });

  // node_modules/semver/functions/parse.js
  var require_parse = __commonJS({
    "node_modules/semver/functions/parse.js"(exports2, module84) {
      var SemVer = require_semver();
      var parse2 = (version4, options6, throwErrors = false) => {
        if (version4 instanceof SemVer) {
          return version4;
        }
        try {
          return new SemVer(version4, options6);
        } catch (er) {
          if (!throwErrors) {
            return null;
          }
          throw er;
        }
      };
      module84.exports = parse2;
    }
  });

  // node_modules/semver/functions/diff.js
  var require_diff = __commonJS({
    "node_modules/semver/functions/diff.js"(exports2, module84) {
      var parse2 = require_parse();
      var diff = (version1, version22) => {
        const v1 = parse2(version1, null, true);
        const v2 = parse2(version22, null, true);
        const comparison = v1.compare(v2);
        if (comparison === 0) {
          return null;
        }
        const v1Higher = comparison > 0;
        const highVersion = v1Higher ? v1 : v2;
        const lowVersion = v1Higher ? v2 : v1;
        const highHasPre = !!highVersion.prerelease.length;
        const lowHasPre = !!lowVersion.prerelease.length;
        if (lowHasPre && !highHasPre) {
          if (!lowVersion.patch && !lowVersion.minor) {
            return "major";
          }
          if (highVersion.patch) {
            return "patch";
          }
          if (highVersion.minor) {
            return "minor";
          }
          return "major";
        }
        const prefix = highHasPre ? "pre" : "";
        if (v1.major !== v2.major) {
          return prefix + "major";
        }
        if (v1.minor !== v2.minor) {
          return prefix + "minor";
        }
        if (v1.patch !== v2.patch) {
          return prefix + "patch";
        }
        return "prerelease";
      };
      module84.exports = diff;
    }
  });

  // node_modules/favico.js/favico.js
  var require_favico = __commonJS({
    "node_modules/favico.js/favico.js"(exports2, module84) {
      (function() {
        var Favico2 = function(opt) {
          "use strict";
          opt = opt ? opt : {};
          var _def = {
            bgColor: "#d00",
            textColor: "#fff",
            fontFamily: "sans-serif",
            //Arial,Verdana,Times New Roman,serif,sans-serif,...
            fontStyle: "bold",
            //normal,italic,oblique,bold,bolder,lighter,100,200,300,400,500,600,700,800,900
            type: "circle",
            position: "down",
            // down, up, left, leftup (upleft)
            animation: "slide",
            elementId: false,
            dataUrl: false,
            win: window
          };
          var _opt, _orig, _h, _w, _canvas, _context, _img, _ready, _lastBadge, _running, _readyCb, _stop, _browser, _animTimeout, _drawTimeout, _doc;
          _browser = {};
          _browser.ff = typeof InstallTrigger != "undefined";
          _browser.chrome = !!window.chrome;
          _browser.opera = !!window.opera || navigator.userAgent.indexOf("Opera") >= 0;
          _browser.ie = /*@cc_on!@*/
          false;
          _browser.safari = Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0;
          _browser.supported = _browser.chrome || _browser.ff || _browser.opera;
          var _queue = [];
          _readyCb = function() {
          };
          _ready = _stop = false;
          var init2 = function() {
            _opt = merge(_def, opt);
            _opt.bgColor = hexToRgb(_opt.bgColor);
            _opt.textColor = hexToRgb(_opt.textColor);
            _opt.position = _opt.position.toLowerCase();
            _opt.animation = animation.types["" + _opt.animation] ? _opt.animation : _def.animation;
            _doc = _opt.win.document;
            var isUp = _opt.position.indexOf("up") > -1;
            var isLeft = _opt.position.indexOf("left") > -1;
            if (isUp || isLeft) {
              for (var i2 = 0; i2 < animation.types["" + _opt.animation].length; i2++) {
                var step = animation.types["" + _opt.animation][i2];
                if (isUp) {
                  if (step.y < 0.6) {
                    step.y = step.y - 0.4;
                  } else {
                    step.y = step.y - 2 * step.y + (1 - step.w);
                  }
                }
                if (isLeft) {
                  if (step.x < 0.6) {
                    step.x = step.x - 0.4;
                  } else {
                    step.x = step.x - 2 * step.x + (1 - step.h);
                  }
                }
                animation.types["" + _opt.animation][i2] = step;
              }
            }
            _opt.type = type["" + _opt.type] ? _opt.type : _def.type;
            _orig = link.getIcon();
            _canvas = document.createElement("canvas");
            _img = document.createElement("img");
            if (_orig.hasAttribute("href")) {
              _img.setAttribute("crossOrigin", "anonymous");
              _img.onload = function() {
                _h = _img.height > 0 ? _img.height : 32;
                _w = _img.width > 0 ? _img.width : 32;
                _canvas.height = _h;
                _canvas.width = _w;
                _context = _canvas.getContext("2d");
                icon2.ready();
              };
              _img.setAttribute("src", _orig.getAttribute("href"));
            } else {
              _img.onload = function() {
                _h = 32;
                _w = 32;
                _img.height = _h;
                _img.width = _w;
                _canvas.height = _h;
                _canvas.width = _w;
                _context = _canvas.getContext("2d");
                icon2.ready();
              };
              _img.setAttribute("src", "");
            }
          };
          var icon2 = {};
          icon2.ready = function() {
            _ready = true;
            icon2.reset();
            _readyCb();
          };
          icon2.reset = function() {
            if (!_ready) {
              return;
            }
            _queue = [];
            _lastBadge = false;
            _running = false;
            _context.clearRect(0, 0, _w, _h);
            _context.drawImage(_img, 0, 0, _w, _h);
            link.setIcon(_canvas);
            window.clearTimeout(_animTimeout);
            window.clearTimeout(_drawTimeout);
          };
          icon2.start = function() {
            if (!_ready || _running) {
              return;
            }
            var finished = function() {
              _lastBadge = _queue[0];
              _running = false;
              if (_queue.length > 0) {
                _queue.shift();
                icon2.start();
              } else {
              }
            };
            if (_queue.length > 0) {
              _running = true;
              var run = function() {
                ["type", "animation", "bgColor", "textColor", "fontFamily", "fontStyle"].forEach(function(a2) {
                  if (a2 in _queue[0].options) {
                    _opt[a2] = _queue[0].options[a2];
                  }
                });
                animation.run(_queue[0].options, function() {
                  finished();
                }, false);
              };
              if (_lastBadge) {
                animation.run(_lastBadge.options, function() {
                  run();
                }, true);
              } else {
                run();
              }
            }
          };
          var type = {};
          var options6 = function(opt2) {
            opt2.n = typeof opt2.n === "number" ? Math.abs(opt2.n | 0) : opt2.n;
            opt2.x = _w * opt2.x;
            opt2.y = _h * opt2.y;
            opt2.w = _w * opt2.w;
            opt2.h = _h * opt2.h;
            opt2.len = ("" + opt2.n).length;
            return opt2;
          };
          type.circle = function(opt2) {
            opt2 = options6(opt2);
            var more = false;
            if (opt2.len === 2) {
              opt2.x = opt2.x - opt2.w * 0.4;
              opt2.w = opt2.w * 1.4;
              more = true;
            } else if (opt2.len >= 3) {
              opt2.x = opt2.x - opt2.w * 0.65;
              opt2.w = opt2.w * 1.65;
              more = true;
            }
            _context.clearRect(0, 0, _w, _h);
            _context.drawImage(_img, 0, 0, _w, _h);
            _context.beginPath();
            _context.font = _opt.fontStyle + " " + Math.floor(opt2.h * (opt2.n > 99 ? 0.85 : 1)) + "px " + _opt.fontFamily;
            _context.textAlign = "center";
            if (more) {
              _context.moveTo(opt2.x + opt2.w / 2, opt2.y);
              _context.lineTo(opt2.x + opt2.w - opt2.h / 2, opt2.y);
              _context.quadraticCurveTo(opt2.x + opt2.w, opt2.y, opt2.x + opt2.w, opt2.y + opt2.h / 2);
              _context.lineTo(opt2.x + opt2.w, opt2.y + opt2.h - opt2.h / 2);
              _context.quadraticCurveTo(opt2.x + opt2.w, opt2.y + opt2.h, opt2.x + opt2.w - opt2.h / 2, opt2.y + opt2.h);
              _context.lineTo(opt2.x + opt2.h / 2, opt2.y + opt2.h);
              _context.quadraticCurveTo(opt2.x, opt2.y + opt2.h, opt2.x, opt2.y + opt2.h - opt2.h / 2);
              _context.lineTo(opt2.x, opt2.y + opt2.h / 2);
              _context.quadraticCurveTo(opt2.x, opt2.y, opt2.x + opt2.h / 2, opt2.y);
            } else {
              _context.arc(opt2.x + opt2.w / 2, opt2.y + opt2.h / 2, opt2.h / 2, 0, 2 * Math.PI);
            }
            _context.fillStyle = "rgba(" + _opt.bgColor.r + "," + _opt.bgColor.g + "," + _opt.bgColor.b + "," + opt2.o + ")";
            _context.fill();
            _context.closePath();
            _context.beginPath();
            _context.stroke();
            _context.fillStyle = "rgba(" + _opt.textColor.r + "," + _opt.textColor.g + "," + _opt.textColor.b + "," + opt2.o + ")";
            if (typeof opt2.n === "number" && opt2.n > 999) {
              _context.fillText((opt2.n > 9999 ? 9 : Math.floor(opt2.n / 1e3)) + "k+", Math.floor(opt2.x + opt2.w / 2), Math.floor(opt2.y + opt2.h - opt2.h * 0.2));
            } else {
              _context.fillText(opt2.n, Math.floor(opt2.x + opt2.w / 2), Math.floor(opt2.y + opt2.h - opt2.h * 0.15));
            }
            _context.closePath();
          };
          type.rectangle = function(opt2) {
            opt2 = options6(opt2);
            var more = false;
            if (opt2.len === 2) {
              opt2.x = opt2.x - opt2.w * 0.4;
              opt2.w = opt2.w * 1.4;
              more = true;
            } else if (opt2.len >= 3) {
              opt2.x = opt2.x - opt2.w * 0.65;
              opt2.w = opt2.w * 1.65;
              more = true;
            }
            _context.clearRect(0, 0, _w, _h);
            _context.drawImage(_img, 0, 0, _w, _h);
            _context.beginPath();
            _context.font = _opt.fontStyle + " " + Math.floor(opt2.h * (opt2.n > 99 ? 0.9 : 1)) + "px " + _opt.fontFamily;
            _context.textAlign = "center";
            _context.fillStyle = "rgba(" + _opt.bgColor.r + "," + _opt.bgColor.g + "," + _opt.bgColor.b + "," + opt2.o + ")";
            _context.fillRect(opt2.x, opt2.y, opt2.w, opt2.h);
            _context.fillStyle = "rgba(" + _opt.textColor.r + "," + _opt.textColor.g + "," + _opt.textColor.b + "," + opt2.o + ")";
            if (typeof opt2.n === "number" && opt2.n > 999) {
              _context.fillText((opt2.n > 9999 ? 9 : Math.floor(opt2.n / 1e3)) + "k+", Math.floor(opt2.x + opt2.w / 2), Math.floor(opt2.y + opt2.h - opt2.h * 0.2));
            } else {
              _context.fillText(opt2.n, Math.floor(opt2.x + opt2.w / 2), Math.floor(opt2.y + opt2.h - opt2.h * 0.15));
            }
            _context.closePath();
          };
          var badge = function(number, opts) {
            opts = (typeof opts === "string" ? {
              animation: opts
            } : opts) || {};
            _readyCb = function() {
              try {
                if (typeof number === "number" ? number > 0 : number !== "") {
                  var q = {
                    type: "badge",
                    options: {
                      n: number
                    }
                  };
                  if ("animation" in opts && animation.types["" + opts.animation]) {
                    q.options.animation = "" + opts.animation;
                  }
                  if ("type" in opts && type["" + opts.type]) {
                    q.options.type = "" + opts.type;
                  }
                  ["bgColor", "textColor"].forEach(function(o2) {
                    if (o2 in opts) {
                      q.options[o2] = hexToRgb(opts[o2]);
                    }
                  });
                  ["fontStyle", "fontFamily"].forEach(function(o2) {
                    if (o2 in opts) {
                      q.options[o2] = opts[o2];
                    }
                  });
                  _queue.push(q);
                  if (_queue.length > 100) {
                    throw new Error("Too many badges requests in queue.");
                  }
                  icon2.start();
                } else {
                  icon2.reset();
                }
              } catch (e2) {
                throw new Error("Error setting badge. Message: " + e2.message);
              }
            };
            if (_ready) {
              _readyCb();
            }
          };
          var image = function(imageElement) {
            _readyCb = function() {
              try {
                var w = imageElement.width;
                var h = imageElement.height;
                var newImg = document.createElement("img");
                var ratio = w / _w < h / _h ? w / _w : h / _h;
                newImg.setAttribute("crossOrigin", "anonymous");
                newImg.onload = function() {
                  _context.clearRect(0, 0, _w, _h);
                  _context.drawImage(newImg, 0, 0, _w, _h);
                  link.setIcon(_canvas);
                };
                newImg.setAttribute("src", imageElement.getAttribute("src"));
                newImg.height = h / ratio;
                newImg.width = w / ratio;
              } catch (e2) {
                throw new Error("Error setting image. Message: " + e2.message);
              }
            };
            if (_ready) {
              _readyCb();
            }
          };
          var video = function(videoElement) {
            _readyCb = function() {
              try {
                if (videoElement === "stop") {
                  _stop = true;
                  icon2.reset();
                  _stop = false;
                  return;
                }
                videoElement.addEventListener("play", function() {
                  drawVideo(this);
                }, false);
              } catch (e2) {
                throw new Error("Error setting video. Message: " + e2.message);
              }
            };
            if (_ready) {
              _readyCb();
            }
          };
          var webcam = function(action) {
            if (!window.URL || !window.URL.createObjectURL) {
              window.URL = window.URL || {};
              window.URL.createObjectURL = function(obj) {
                return obj;
              };
            }
            if (_browser.supported) {
              var newVideo = false;
              navigator.getUserMedia = navigator.getUserMedia || navigator.oGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia || navigator.webkitGetUserMedia;
              _readyCb = function() {
                try {
                  if (action === "stop") {
                    _stop = true;
                    icon2.reset();
                    _stop = false;
                    return;
                  }
                  newVideo = document.createElement("video");
                  newVideo.width = _w;
                  newVideo.height = _h;
                  navigator.getUserMedia({
                    video: true,
                    audio: false
                  }, function(stream) {
                    newVideo.src = URL.createObjectURL(stream);
                    newVideo.play();
                    drawVideo(newVideo);
                  }, function() {
                  });
                } catch (e2) {
                  throw new Error("Error setting webcam. Message: " + e2.message);
                }
              };
              if (_ready) {
                _readyCb();
              }
            }
          };
          function drawVideo(video2) {
            if (video2.paused || video2.ended || _stop) {
              return false;
            }
            try {
              _context.clearRect(0, 0, _w, _h);
              _context.drawImage(video2, 0, 0, _w, _h);
            } catch (e2) {
            }
            _drawTimeout = setTimeout(function() {
              drawVideo(video2);
            }, animation.duration);
            link.setIcon(_canvas);
          }
          var link = {};
          link.getIcon = function() {
            var elm = false;
            var getLink = function() {
              var link2 = _doc.getElementsByTagName("head")[0].getElementsByTagName("link");
              for (var l = link2.length, i2 = l - 1; i2 >= 0; i2--) {
                if (/(^|\s)icon(\s|$)/i.test(link2[i2].getAttribute("rel"))) {
                  return link2[i2];
                }
              }
              return false;
            };
            if (_opt.element) {
              elm = _opt.element;
            } else if (_opt.elementId) {
              elm = _doc.getElementById(_opt.elementId);
              elm.setAttribute("href", elm.getAttribute("src"));
            } else {
              elm = getLink();
              if (elm === false) {
                elm = _doc.createElement("link");
                elm.setAttribute("rel", "icon");
                _doc.getElementsByTagName("head")[0].appendChild(elm);
              }
            }
            elm.setAttribute("type", "image/png");
            return elm;
          };
          link.setIcon = function(canvas) {
            var url = canvas.toDataURL("image/png");
            if (_opt.dataUrl) {
              _opt.dataUrl(url);
            }
            if (_opt.element) {
              _opt.element.setAttribute("href", url);
              _opt.element.setAttribute("src", url);
            } else if (_opt.elementId) {
              var elm = _doc.getElementById(_opt.elementId);
              elm.setAttribute("href", url);
              elm.setAttribute("src", url);
            } else {
              if (_browser.ff || _browser.opera) {
                var old = _orig;
                _orig = _doc.createElement("link");
                if (_browser.opera) {
                  _orig.setAttribute("rel", "icon");
                }
                _orig.setAttribute("rel", "icon");
                _orig.setAttribute("type", "image/png");
                _doc.getElementsByTagName("head")[0].appendChild(_orig);
                _orig.setAttribute("href", url);
                if (old.parentNode) {
                  old.parentNode.removeChild(old);
                }
              } else {
                _orig.setAttribute("href", url);
              }
            }
          };
          function hexToRgb(hex) {
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function(m, r, g, b2) {
              return r + r + g + g + b2 + b2;
            });
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
              r: parseInt(result[1], 16),
              g: parseInt(result[2], 16),
              b: parseInt(result[3], 16)
            } : false;
          }
          function merge(def, opt2) {
            var mergedOpt = {};
            var attrname;
            for (attrname in def) {
              mergedOpt[attrname] = def[attrname];
            }
            for (attrname in opt2) {
              mergedOpt[attrname] = opt2[attrname];
            }
            return mergedOpt;
          }
          function isPageHidden() {
            return _doc.hidden || _doc.msHidden || _doc.webkitHidden || _doc.mozHidden;
          }
          var animation = {};
          animation.duration = 40;
          animation.types = {};
          animation.types.fade = [{
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0.1
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0.2
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0.3
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0.4
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0.5
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0.6
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0.7
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0.8
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 0.9
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 1
          }];
          animation.types.none = [{
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 1
          }];
          animation.types.pop = [{
            x: 1,
            y: 1,
            w: 0,
            h: 0,
            o: 1
          }, {
            x: 0.9,
            y: 0.9,
            w: 0.1,
            h: 0.1,
            o: 1
          }, {
            x: 0.8,
            y: 0.8,
            w: 0.2,
            h: 0.2,
            o: 1
          }, {
            x: 0.7,
            y: 0.7,
            w: 0.3,
            h: 0.3,
            o: 1
          }, {
            x: 0.6,
            y: 0.6,
            w: 0.4,
            h: 0.4,
            o: 1
          }, {
            x: 0.5,
            y: 0.5,
            w: 0.5,
            h: 0.5,
            o: 1
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 1
          }];
          animation.types.popFade = [{
            x: 0.75,
            y: 0.75,
            w: 0,
            h: 0,
            o: 0
          }, {
            x: 0.65,
            y: 0.65,
            w: 0.1,
            h: 0.1,
            o: 0.2
          }, {
            x: 0.6,
            y: 0.6,
            w: 0.2,
            h: 0.2,
            o: 0.4
          }, {
            x: 0.55,
            y: 0.55,
            w: 0.3,
            h: 0.3,
            o: 0.6
          }, {
            x: 0.5,
            y: 0.5,
            w: 0.4,
            h: 0.4,
            o: 0.8
          }, {
            x: 0.45,
            y: 0.45,
            w: 0.5,
            h: 0.5,
            o: 0.9
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 1
          }];
          animation.types.slide = [{
            x: 0.4,
            y: 1,
            w: 0.6,
            h: 0.6,
            o: 1
          }, {
            x: 0.4,
            y: 0.9,
            w: 0.6,
            h: 0.6,
            o: 1
          }, {
            x: 0.4,
            y: 0.9,
            w: 0.6,
            h: 0.6,
            o: 1
          }, {
            x: 0.4,
            y: 0.8,
            w: 0.6,
            h: 0.6,
            o: 1
          }, {
            x: 0.4,
            y: 0.7,
            w: 0.6,
            h: 0.6,
            o: 1
          }, {
            x: 0.4,
            y: 0.6,
            w: 0.6,
            h: 0.6,
            o: 1
          }, {
            x: 0.4,
            y: 0.5,
            w: 0.6,
            h: 0.6,
            o: 1
          }, {
            x: 0.4,
            y: 0.4,
            w: 0.6,
            h: 0.6,
            o: 1
          }];
          animation.run = function(opt2, cb, revert, step) {
            var animationType = animation.types[isPageHidden() ? "none" : _opt.animation];
            if (revert === true) {
              step = typeof step !== "undefined" ? step : animationType.length - 1;
            } else {
              step = typeof step !== "undefined" ? step : 0;
            }
            cb = cb ? cb : function() {
            };
            if (step < animationType.length && step >= 0) {
              type[_opt.type](merge(opt2, animationType[step]));
              _animTimeout = setTimeout(function() {
                if (revert) {
                  step = step - 1;
                } else {
                  step = step + 1;
                }
                animation.run(opt2, cb, revert, step);
              }, animation.duration);
              link.setIcon(_canvas);
            } else {
              cb();
              return;
            }
          };
          init2();
          return {
            badge,
            video,
            image,
            webcam,
            reset: icon2.reset,
            browser: {
              supported: _browser.supported
            }
          };
        };
        if (typeof define !== "undefined" && define.amd) {
          define([], function() {
            return Favico2;
          });
        } else if (typeof module84 !== "undefined" && module84.exports) {
          module84.exports = Favico2;
        } else {
          this.Favico = Favico2;
        }
      })();
    }
  });

  // lib/constants/urlHashes.js
  var RES_DISABLED_HASH = "#res:disabled";
  var RES_SETTINGS_HASH = "#res:settings";
  var RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH = "#res:settings-redirect-standalone-options-page";
  var RES_NER_PAGE_HASH = "#res:ner-page";

  // node_modules/lodash-es/_freeGlobal.js
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeGlobal_default = freeGlobal;

  // node_modules/lodash-es/_root.js
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal_default || freeSelf || Function("return this")();
  var root_default = root;

  // node_modules/lodash-es/_Symbol.js
  var Symbol2 = root_default.Symbol;
  var Symbol_default = Symbol2;

  // node_modules/lodash-es/_getRawTag.js
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getRawTag_default = getRawTag;

  // node_modules/lodash-es/_objectToString.js
  var objectProto2 = Object.prototype;
  var nativeObjectToString2 = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString2.call(value);
  }
  var objectToString_default = objectToString;

  // node_modules/lodash-es/_baseGetTag.js
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
  }
  var baseGetTag_default = baseGetTag;

  // node_modules/lodash-es/isObjectLike.js
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var isObjectLike_default = isObjectLike;

  // node_modules/lodash-es/isSymbol.js
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
  }
  var isSymbol_default = isSymbol;

  // node_modules/lodash-es/_arrayMap.js
  function arrayMap(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index2 < length) {
      result[index2] = iteratee(array[index2], index2, array);
    }
    return result;
  }
  var arrayMap_default = arrayMap;

  // node_modules/lodash-es/isArray.js
  var isArray = Array.isArray;
  var isArray_default = isArray;

  // node_modules/lodash-es/_baseToString.js
  var INFINITY = 1 / 0;
  var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray_default(value)) {
      return arrayMap_default(value, baseToString) + "";
    }
    if (isSymbol_default(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  var baseToString_default = baseToString;

  // node_modules/lodash-es/_trimmedEndIndex.js
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index2 = string.length;
    while (index2-- && reWhitespace.test(string.charAt(index2))) {
    }
    return index2;
  }
  var trimmedEndIndex_default = trimmedEndIndex;

  // node_modules/lodash-es/_baseTrim.js
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
  }
  var baseTrim_default = baseTrim;

  // node_modules/lodash-es/isObject.js
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var isObject_default = isObject;

  // node_modules/lodash-es/toNumber.js
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol_default(value)) {
      return NAN;
    }
    if (isObject_default(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject_default(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim_default(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var toNumber_default = toNumber;

  // node_modules/lodash-es/toFinite.js
  var INFINITY2 = 1 / 0;
  var MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber_default(value);
    if (value === INFINITY2 || value === -INFINITY2) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  var toFinite_default = toFinite;

  // node_modules/lodash-es/toInteger.js
  function toInteger(value) {
    var result = toFinite_default(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  var toInteger_default = toInteger;

  // node_modules/lodash-es/identity.js
  function identity(value) {
    return value;
  }
  var identity_default = identity;

  // node_modules/lodash-es/isFunction.js
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject_default(value)) {
      return false;
    }
    var tag = baseGetTag_default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var isFunction_default = isFunction;

  // node_modules/lodash-es/_coreJsData.js
  var coreJsData = root_default["__core-js_shared__"];
  var coreJsData_default = coreJsData;

  // node_modules/lodash-es/_isMasked.js
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var isMasked_default = isMasked;

  // node_modules/lodash-es/_toSource.js
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  var toSource_default = toSource;

  // node_modules/lodash-es/_baseIsNative.js
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto2 = Function.prototype;
  var objectProto3 = Object.prototype;
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto3.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject_default(value) || isMasked_default(value)) {
      return false;
    }
    var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource_default(value));
  }
  var baseIsNative_default = baseIsNative;

  // node_modules/lodash-es/_getValue.js
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  var getValue_default = getValue;

  // node_modules/lodash-es/_getNative.js
  function getNative(object, key) {
    var value = getValue_default(object, key);
    return baseIsNative_default(value) ? value : void 0;
  }
  var getNative_default = getNative;

  // node_modules/lodash-es/_WeakMap.js
  var WeakMap2 = getNative_default(root_default, "WeakMap");
  var WeakMap_default = WeakMap2;

  // node_modules/lodash-es/_metaMap.js
  var metaMap = WeakMap_default && new WeakMap_default();
  var metaMap_default = metaMap;

  // node_modules/lodash-es/_baseSetData.js
  var baseSetData = !metaMap_default ? identity_default : function(func, data2) {
    metaMap_default.set(func, data2);
    return func;
  };
  var baseSetData_default = baseSetData;

  // node_modules/lodash-es/_baseCreate.js
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    return function(proto) {
      if (!isObject_default(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  var baseCreate_default = baseCreate;

  // node_modules/lodash-es/_createCtor.js
  function createCtor(Ctor) {
    return function() {
      var args = arguments;
      switch (args.length) {
        case 0:
          return new Ctor();
        case 1:
          return new Ctor(args[0]);
        case 2:
          return new Ctor(args[0], args[1]);
        case 3:
          return new Ctor(args[0], args[1], args[2]);
        case 4:
          return new Ctor(args[0], args[1], args[2], args[3]);
        case 5:
          return new Ctor(args[0], args[1], args[2], args[3], args[4]);
        case 6:
          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7:
          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
      }
      var thisBinding = baseCreate_default(Ctor.prototype), result = Ctor.apply(thisBinding, args);
      return isObject_default(result) ? result : thisBinding;
    };
  }
  var createCtor_default = createCtor;

  // node_modules/lodash-es/_createBind.js
  var WRAP_BIND_FLAG = 1;
  function createBind(func, bitmask, thisArg) {
    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
    function wrapper() {
      var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
      return fn.apply(isBind ? thisArg : this, arguments);
    }
    return wrapper;
  }
  var createBind_default = createBind;

  // node_modules/lodash-es/_apply.js
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  var apply_default = apply;

  // node_modules/lodash-es/_composeArgs.js
  var nativeMax = Math.max;
  function composeArgs(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
    while (++leftIndex < leftLength) {
      result[leftIndex] = partials[leftIndex];
    }
    while (++argsIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
    }
    while (rangeLength--) {
      result[leftIndex++] = args[argsIndex++];
    }
    return result;
  }
  var composeArgs_default = composeArgs;

  // node_modules/lodash-es/_composeArgsRight.js
  var nativeMax2 = Math.max;
  function composeArgsRight(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
    while (++argsIndex < rangeLength) {
      result[argsIndex] = args[argsIndex];
    }
    var offset = argsIndex;
    while (++rightIndex < rightLength) {
      result[offset + rightIndex] = partials[rightIndex];
    }
    while (++holdersIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
    }
    return result;
  }
  var composeArgsRight_default = composeArgsRight;

  // node_modules/lodash-es/_countHolders.js
  function countHolders(array, placeholder) {
    var length = array.length, result = 0;
    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }
  var countHolders_default = countHolders;

  // node_modules/lodash-es/_baseLodash.js
  function baseLodash() {
  }
  var baseLodash_default = baseLodash;

  // node_modules/lodash-es/_LazyWrapper.js
  var MAX_ARRAY_LENGTH = 4294967295;
  function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__dir__ = 1;
    this.__filtered__ = false;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH;
    this.__views__ = [];
  }
  LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
  LazyWrapper.prototype.constructor = LazyWrapper;
  var LazyWrapper_default = LazyWrapper;

  // node_modules/lodash-es/noop.js
  function noop() {
  }
  var noop_default = noop;

  // node_modules/lodash-es/_getData.js
  var getData = !metaMap_default ? noop_default : function(func) {
    return metaMap_default.get(func);
  };
  var getData_default = getData;

  // node_modules/lodash-es/_realNames.js
  var realNames = {};
  var realNames_default = realNames;

  // node_modules/lodash-es/_getFuncName.js
  var objectProto4 = Object.prototype;
  var hasOwnProperty3 = objectProto4.hasOwnProperty;
  function getFuncName(func) {
    var result = func.name + "", array = realNames_default[result], length = hasOwnProperty3.call(realNames_default, result) ? array.length : 0;
    while (length--) {
      var data2 = array[length], otherFunc = data2.func;
      if (otherFunc == null || otherFunc == func) {
        return data2.name;
      }
    }
    return result;
  }
  var getFuncName_default = getFuncName;

  // node_modules/lodash-es/_LodashWrapper.js
  function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
    this.__index__ = 0;
    this.__values__ = void 0;
  }
  LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
  LodashWrapper.prototype.constructor = LodashWrapper;
  var LodashWrapper_default = LodashWrapper;

  // node_modules/lodash-es/_copyArray.js
  function copyArray(source, array) {
    var index2 = -1, length = source.length;
    array || (array = Array(length));
    while (++index2 < length) {
      array[index2] = source[index2];
    }
    return array;
  }
  var copyArray_default = copyArray;

  // node_modules/lodash-es/_wrapperClone.js
  function wrapperClone(wrapper) {
    if (wrapper instanceof LazyWrapper_default) {
      return wrapper.clone();
    }
    var result = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
    result.__actions__ = copyArray_default(wrapper.__actions__);
    result.__index__ = wrapper.__index__;
    result.__values__ = wrapper.__values__;
    return result;
  }
  var wrapperClone_default = wrapperClone;

  // node_modules/lodash-es/wrapperLodash.js
  var objectProto5 = Object.prototype;
  var hasOwnProperty4 = objectProto5.hasOwnProperty;
  function lodash(value) {
    if (isObjectLike_default(value) && !isArray_default(value) && !(value instanceof LazyWrapper_default)) {
      if (value instanceof LodashWrapper_default) {
        return value;
      }
      if (hasOwnProperty4.call(value, "__wrapped__")) {
        return wrapperClone_default(value);
      }
    }
    return new LodashWrapper_default(value);
  }
  lodash.prototype = baseLodash_default.prototype;
  lodash.prototype.constructor = lodash;
  var wrapperLodash_default = lodash;

  // node_modules/lodash-es/_isLaziable.js
  function isLaziable(func) {
    var funcName = getFuncName_default(func), other = wrapperLodash_default[funcName];
    if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
      return false;
    }
    if (func === other) {
      return true;
    }
    var data2 = getData_default(other);
    return !!data2 && func === data2[0];
  }
  var isLaziable_default = isLaziable;

  // node_modules/lodash-es/_shortOut.js
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  var shortOut_default = shortOut;

  // node_modules/lodash-es/_setData.js
  var setData = shortOut_default(baseSetData_default);
  var setData_default = setData;

  // node_modules/lodash-es/_getWrapDetails.js
  var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
  var reSplitDetails = /,? & /;
  function getWrapDetails(source) {
    var match = source.match(reWrapDetails);
    return match ? match[1].split(reSplitDetails) : [];
  }
  var getWrapDetails_default = getWrapDetails;

  // node_modules/lodash-es/_insertWrapDetails.js
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
  function insertWrapDetails(source, details) {
    var length = details.length;
    if (!length) {
      return source;
    }
    var lastIndex = length - 1;
    details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
    details = details.join(length > 2 ? ", " : " ");
    return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
  }
  var insertWrapDetails_default = insertWrapDetails;

  // node_modules/lodash-es/constant.js
  function constant(value) {
    return function() {
      return value;
    };
  }
  var constant_default = constant;

  // node_modules/lodash-es/_defineProperty.js
  var defineProperty = function() {
    try {
      var func = getNative_default(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e2) {
    }
  }();
  var defineProperty_default = defineProperty;

  // node_modules/lodash-es/_baseSetToString.js
  var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
    return defineProperty_default(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant_default(string),
      "writable": true
    });
  };
  var baseSetToString_default = baseSetToString;

  // node_modules/lodash-es/_setToString.js
  var setToString = shortOut_default(baseSetToString_default);
  var setToString_default = setToString;

  // node_modules/lodash-es/_arrayEach.js
  function arrayEach(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  var arrayEach_default = arrayEach;

  // node_modules/lodash-es/_baseFindIndex.js
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return index2;
      }
    }
    return -1;
  }
  var baseFindIndex_default = baseFindIndex;

  // node_modules/lodash-es/_baseIsNaN.js
  function baseIsNaN(value) {
    return value !== value;
  }
  var baseIsNaN_default = baseIsNaN;

  // node_modules/lodash-es/_strictIndexOf.js
  function strictIndexOf(array, value, fromIndex) {
    var index2 = fromIndex - 1, length = array.length;
    while (++index2 < length) {
      if (array[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  var strictIndexOf_default = strictIndexOf;

  // node_modules/lodash-es/_baseIndexOf.js
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
  }
  var baseIndexOf_default = baseIndexOf;

  // node_modules/lodash-es/_arrayIncludes.js
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf_default(array, value, 0) > -1;
  }
  var arrayIncludes_default = arrayIncludes;

  // node_modules/lodash-es/_updateWrapDetails.js
  var WRAP_BIND_FLAG2 = 1;
  var WRAP_BIND_KEY_FLAG = 2;
  var WRAP_CURRY_FLAG = 8;
  var WRAP_CURRY_RIGHT_FLAG = 16;
  var WRAP_PARTIAL_FLAG = 32;
  var WRAP_PARTIAL_RIGHT_FLAG = 64;
  var WRAP_ARY_FLAG = 128;
  var WRAP_REARG_FLAG = 256;
  var WRAP_FLIP_FLAG = 512;
  var wrapFlags = [
    ["ary", WRAP_ARY_FLAG],
    ["bind", WRAP_BIND_FLAG2],
    ["bindKey", WRAP_BIND_KEY_FLAG],
    ["curry", WRAP_CURRY_FLAG],
    ["curryRight", WRAP_CURRY_RIGHT_FLAG],
    ["flip", WRAP_FLIP_FLAG],
    ["partial", WRAP_PARTIAL_FLAG],
    ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
    ["rearg", WRAP_REARG_FLAG]
  ];
  function updateWrapDetails(details, bitmask) {
    arrayEach_default(wrapFlags, function(pair) {
      var value = "_." + pair[0];
      if (bitmask & pair[1] && !arrayIncludes_default(details, value)) {
        details.push(value);
      }
    });
    return details.sort();
  }
  var updateWrapDetails_default = updateWrapDetails;

  // node_modules/lodash-es/_setWrapToString.js
  function setWrapToString(wrapper, reference, bitmask) {
    var source = reference + "";
    return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
  }
  var setWrapToString_default = setWrapToString;

  // node_modules/lodash-es/_createRecurry.js
  var WRAP_BIND_FLAG3 = 1;
  var WRAP_BIND_KEY_FLAG2 = 2;
  var WRAP_CURRY_BOUND_FLAG = 4;
  var WRAP_CURRY_FLAG2 = 8;
  var WRAP_PARTIAL_FLAG2 = 32;
  var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
  function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
    var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
    bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
    if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
      bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
    }
    var newData = [
      func,
      bitmask,
      thisArg,
      newPartials,
      newHolders,
      newPartialsRight,
      newHoldersRight,
      argPos,
      ary,
      arity
    ];
    var result = wrapFunc.apply(void 0, newData);
    if (isLaziable_default(func)) {
      setData_default(result, newData);
    }
    result.placeholder = placeholder;
    return setWrapToString_default(result, func, bitmask);
  }
  var createRecurry_default = createRecurry;

  // node_modules/lodash-es/_getHolder.js
  function getHolder(func) {
    var object = func;
    return object.placeholder;
  }
  var getHolder_default = getHolder;

  // node_modules/lodash-es/_isIndex.js
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  var isIndex_default = isIndex;

  // node_modules/lodash-es/_reorder.js
  var nativeMin = Math.min;
  function reorder(array, indexes) {
    var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray_default(array);
    while (length--) {
      var index2 = indexes[length];
      array[length] = isIndex_default(index2, arrLength) ? oldArray[index2] : void 0;
    }
    return array;
  }
  var reorder_default = reorder;

  // node_modules/lodash-es/_replaceHolders.js
  var PLACEHOLDER = "__lodash_placeholder__";
  function replaceHolders(array, placeholder) {
    var index2 = -1, length = array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index2] = PLACEHOLDER;
        result[resIndex++] = index2;
      }
    }
    return result;
  }
  var replaceHolders_default = replaceHolders;

  // node_modules/lodash-es/_createHybrid.js
  var WRAP_BIND_FLAG4 = 1;
  var WRAP_BIND_KEY_FLAG3 = 2;
  var WRAP_CURRY_FLAG3 = 8;
  var WRAP_CURRY_RIGHT_FLAG2 = 16;
  var WRAP_ARY_FLAG2 = 128;
  var WRAP_FLIP_FLAG2 = 512;
  function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
    function wrapper() {
      var length = arguments.length, args = Array(length), index2 = length;
      while (index2--) {
        args[index2] = arguments[index2];
      }
      if (isCurried) {
        var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
      }
      if (partials) {
        args = composeArgs_default(args, partials, holders, isCurried);
      }
      if (partialsRight) {
        args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
      }
      length -= holdersCount;
      if (isCurried && length < arity) {
        var newHolders = replaceHolders_default(args, placeholder);
        return createRecurry_default(
          func,
          bitmask,
          createHybrid,
          wrapper.placeholder,
          thisArg,
          args,
          newHolders,
          argPos,
          ary,
          arity - length
        );
      }
      var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
      length = args.length;
      if (argPos) {
        args = reorder_default(args, argPos);
      } else if (isFlip && length > 1) {
        args.reverse();
      }
      if (isAry && ary < length) {
        args.length = ary;
      }
      if (this && this !== root_default && this instanceof wrapper) {
        fn = Ctor || createCtor_default(fn);
      }
      return fn.apply(thisBinding, args);
    }
    return wrapper;
  }
  var createHybrid_default = createHybrid;

  // node_modules/lodash-es/_createCurry.js
  function createCurry(func, bitmask, arity) {
    var Ctor = createCtor_default(func);
    function wrapper() {
      var length = arguments.length, args = Array(length), index2 = length, placeholder = getHolder_default(wrapper);
      while (index2--) {
        args[index2] = arguments[index2];
      }
      var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
      length -= holders.length;
      if (length < arity) {
        return createRecurry_default(
          func,
          bitmask,
          createHybrid_default,
          wrapper.placeholder,
          void 0,
          args,
          holders,
          void 0,
          void 0,
          arity - length
        );
      }
      var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
      return apply_default(fn, this, args);
    }
    return wrapper;
  }
  var createCurry_default = createCurry;

  // node_modules/lodash-es/_createPartial.js
  var WRAP_BIND_FLAG5 = 1;
  function createPartial(func, bitmask, thisArg, partials) {
    var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
    function wrapper() {
      var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
      while (++leftIndex < leftLength) {
        args[leftIndex] = partials[leftIndex];
      }
      while (argsLength--) {
        args[leftIndex++] = arguments[++argsIndex];
      }
      return apply_default(fn, isBind ? thisArg : this, args);
    }
    return wrapper;
  }
  var createPartial_default = createPartial;

  // node_modules/lodash-es/_mergeData.js
  var PLACEHOLDER2 = "__lodash_placeholder__";
  var WRAP_BIND_FLAG6 = 1;
  var WRAP_BIND_KEY_FLAG4 = 2;
  var WRAP_CURRY_BOUND_FLAG2 = 4;
  var WRAP_CURRY_FLAG4 = 8;
  var WRAP_ARY_FLAG3 = 128;
  var WRAP_REARG_FLAG2 = 256;
  var nativeMin2 = Math.min;
  function mergeData(data2, source) {
    var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
    var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
    if (!(isCommon || isCombo)) {
      return data2;
    }
    if (srcBitmask & WRAP_BIND_FLAG6) {
      data2[2] = source[2];
      newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
    }
    var value = source[3];
    if (value) {
      var partials = data2[3];
      data2[3] = partials ? composeArgs_default(partials, value, source[4]) : value;
      data2[4] = partials ? replaceHolders_default(data2[3], PLACEHOLDER2) : source[4];
    }
    value = source[5];
    if (value) {
      partials = data2[5];
      data2[5] = partials ? composeArgsRight_default(partials, value, source[6]) : value;
      data2[6] = partials ? replaceHolders_default(data2[5], PLACEHOLDER2) : source[6];
    }
    value = source[7];
    if (value) {
      data2[7] = value;
    }
    if (srcBitmask & WRAP_ARY_FLAG3) {
      data2[8] = data2[8] == null ? source[8] : nativeMin2(data2[8], source[8]);
    }
    if (data2[9] == null) {
      data2[9] = source[9];
    }
    data2[0] = source[0];
    data2[1] = newBitmask;
    return data2;
  }
  var mergeData_default = mergeData;

  // node_modules/lodash-es/_createWrap.js
  var FUNC_ERROR_TEXT = "Expected a function";
  var WRAP_BIND_FLAG7 = 1;
  var WRAP_BIND_KEY_FLAG5 = 2;
  var WRAP_CURRY_FLAG5 = 8;
  var WRAP_CURRY_RIGHT_FLAG3 = 16;
  var WRAP_PARTIAL_FLAG3 = 32;
  var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
  var nativeMax3 = Math.max;
  function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
    if (!isBindKey && typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var length = partials ? partials.length : 0;
    if (!length) {
      bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
      partials = holders = void 0;
    }
    ary = ary === void 0 ? ary : nativeMax3(toInteger_default(ary), 0);
    arity = arity === void 0 ? arity : toInteger_default(arity);
    length -= holders ? holders.length : 0;
    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
      var partialsRight = partials, holdersRight = holders;
      partials = holders = void 0;
    }
    var data2 = isBindKey ? void 0 : getData_default(func);
    var newData = [
      func,
      bitmask,
      thisArg,
      partials,
      holders,
      partialsRight,
      holdersRight,
      argPos,
      ary,
      arity
    ];
    if (data2) {
      mergeData_default(newData, data2);
    }
    func = newData[0];
    bitmask = newData[1];
    thisArg = newData[2];
    partials = newData[3];
    holders = newData[4];
    arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length, 0);
    if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
      bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
    }
    if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
      var result = createBind_default(func, bitmask, thisArg);
    } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
      result = createCurry_default(func, bitmask, arity);
    } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
      result = createPartial_default(func, bitmask, thisArg, partials);
    } else {
      result = createHybrid_default.apply(void 0, newData);
    }
    var setter = data2 ? baseSetData_default : setData_default;
    return setWrapToString_default(setter(result, newData), func, bitmask);
  }
  var createWrap_default = createWrap;

  // node_modules/lodash-es/_baseAssignValue.js
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty_default) {
      defineProperty_default(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  var baseAssignValue_default = baseAssignValue;

  // node_modules/lodash-es/eq.js
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var eq_default = eq;

  // node_modules/lodash-es/_assignValue.js
  var objectProto6 = Object.prototype;
  var hasOwnProperty5 = objectProto6.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty5.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue_default(object, key, value);
    }
  }
  var assignValue_default = assignValue;

  // node_modules/lodash-es/_copyObject.js
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue_default(object, key, newValue);
      } else {
        assignValue_default(object, key, newValue);
      }
    }
    return object;
  }
  var copyObject_default = copyObject;

  // node_modules/lodash-es/_overRest.js
  var nativeMax4 = Math.max;
  function overRest(func, start2, transform2) {
    start2 = nativeMax4(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax4(args.length - start2, 0), array = Array(length);
      while (++index2 < length) {
        array[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array);
      return apply_default(func, this, otherArgs);
    };
  }
  var overRest_default = overRest;

  // node_modules/lodash-es/_baseRest.js
  function baseRest(func, start2) {
    return setToString_default(overRest_default(func, start2, identity_default), func + "");
  }
  var baseRest_default = baseRest;

  // node_modules/lodash-es/isLength.js
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  var isLength_default = isLength;

  // node_modules/lodash-es/isArrayLike.js
  function isArrayLike(value) {
    return value != null && isLength_default(value.length) && !isFunction_default(value);
  }
  var isArrayLike_default = isArrayLike;

  // node_modules/lodash-es/_isIterateeCall.js
  function isIterateeCall(value, index2, object) {
    if (!isObject_default(object)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike_default(object) && isIndex_default(index2, object.length) : type == "string" && index2 in object) {
      return eq_default(object[index2], value);
    }
    return false;
  }
  var isIterateeCall_default = isIterateeCall;

  // node_modules/lodash-es/_createAssigner.js
  function createAssigner(assigner) {
    return baseRest_default(function(object, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  var createAssigner_default = createAssigner;

  // node_modules/lodash-es/_isPrototype.js
  var objectProto7 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto7;
    return value === proto;
  }
  var isPrototype_default = isPrototype;

  // node_modules/lodash-es/_baseTimes.js
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  var baseTimes_default = baseTimes;

  // node_modules/lodash-es/_baseIsArguments.js
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
  }
  var baseIsArguments_default = baseIsArguments;

  // node_modules/lodash-es/isArguments.js
  var objectProto8 = Object.prototype;
  var hasOwnProperty6 = objectProto8.hasOwnProperty;
  var propertyIsEnumerable = objectProto8.propertyIsEnumerable;
  var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments_default : function(value) {
    return isObjectLike_default(value) && hasOwnProperty6.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArguments_default = isArguments;

  // node_modules/lodash-es/stubFalse.js
  function stubFalse() {
    return false;
  }
  var stubFalse_default = stubFalse;

  // node_modules/lodash-es/isBuffer.js
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root_default.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse_default;
  var isBuffer_default = isBuffer;

  // node_modules/lodash-es/_baseIsTypedArray.js
  var argsTag2 = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag2 = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
  }
  var baseIsTypedArray_default = baseIsTypedArray;

  // node_modules/lodash-es/_baseUnary.js
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var baseUnary_default = baseUnary;

  // node_modules/lodash-es/_nodeUtil.js
  var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess = moduleExports2 && freeGlobal_default.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  var nodeUtil_default = nodeUtil;

  // node_modules/lodash-es/isTypedArray.js
  var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
  var isTypedArray_default = isTypedArray;

  // node_modules/lodash-es/_arrayLikeKeys.js
  var objectProto9 = Object.prototype;
  var hasOwnProperty7 = objectProto9.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex_default(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  var arrayLikeKeys_default = arrayLikeKeys;

  // node_modules/lodash-es/_overArg.js
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var overArg_default = overArg;

  // node_modules/lodash-es/_nativeKeys.js
  var nativeKeys = overArg_default(Object.keys, Object);
  var nativeKeys_default = nativeKeys;

  // node_modules/lodash-es/_baseKeys.js
  var objectProto10 = Object.prototype;
  var hasOwnProperty8 = objectProto10.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype_default(object)) {
      return nativeKeys_default(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty8.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  var baseKeys_default = baseKeys;

  // node_modules/lodash-es/keys.js
  function keys(object) {
    return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
  }
  var keys_default = keys;

  // node_modules/lodash-es/_nativeKeysIn.js
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  var nativeKeysIn_default = nativeKeysIn;

  // node_modules/lodash-es/_baseKeysIn.js
  var objectProto11 = Object.prototype;
  var hasOwnProperty9 = objectProto11.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject_default(object)) {
      return nativeKeysIn_default(object);
    }
    var isProto = isPrototype_default(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty9.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  var baseKeysIn_default = baseKeysIn;

  // node_modules/lodash-es/keysIn.js
  function keysIn(object) {
    return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
  }
  var keysIn_default = keysIn;

  // node_modules/lodash-es/assignIn.js
  var assignIn = createAssigner_default(function(object, source) {
    copyObject_default(source, keysIn_default(source), object);
  });
  var assignIn_default = assignIn;

  // node_modules/lodash-es/_isKey.js
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray_default(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var isKey_default = isKey;

  // node_modules/lodash-es/_nativeCreate.js
  var nativeCreate = getNative_default(Object, "create");
  var nativeCreate_default = nativeCreate;

  // node_modules/lodash-es/_hashClear.js
  function hashClear() {
    this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
    this.size = 0;
  }
  var hashClear_default = hashClear;

  // node_modules/lodash-es/_hashDelete.js
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var hashDelete_default = hashDelete;

  // node_modules/lodash-es/_hashGet.js
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto12 = Object.prototype;
  var hasOwnProperty10 = objectProto12.hasOwnProperty;
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate_default) {
      var result = data2[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty10.call(data2, key) ? data2[key] : void 0;
  }
  var hashGet_default = hashGet;

  // node_modules/lodash-es/_hashHas.js
  var objectProto13 = Object.prototype;
  var hasOwnProperty11 = objectProto13.hasOwnProperty;
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate_default ? data2[key] !== void 0 : hasOwnProperty11.call(data2, key);
  }
  var hashHas_default = hashHas;

  // node_modules/lodash-es/_hashSet.js
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data2 = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data2[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  var hashSet_default = hashSet;

  // node_modules/lodash-es/_Hash.js
  function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear_default;
  Hash.prototype["delete"] = hashDelete_default;
  Hash.prototype.get = hashGet_default;
  Hash.prototype.has = hashHas_default;
  Hash.prototype.set = hashSet_default;
  var Hash_default = Hash;

  // node_modules/lodash-es/_listCacheClear.js
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  var listCacheClear_default = listCacheClear;

  // node_modules/lodash-es/_assocIndexOf.js
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_default(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var assocIndexOf_default = assocIndexOf;

  // node_modules/lodash-es/_listCacheDelete.js
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data2 = this.__data__, index2 = assocIndexOf_default(data2, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index2, 1);
    }
    --this.size;
    return true;
  }
  var listCacheDelete_default = listCacheDelete;

  // node_modules/lodash-es/_listCacheGet.js
  function listCacheGet(key) {
    var data2 = this.__data__, index2 = assocIndexOf_default(data2, key);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  var listCacheGet_default = listCacheGet;

  // node_modules/lodash-es/_listCacheHas.js
  function listCacheHas(key) {
    return assocIndexOf_default(this.__data__, key) > -1;
  }
  var listCacheHas_default = listCacheHas;

  // node_modules/lodash-es/_listCacheSet.js
  function listCacheSet(key, value) {
    var data2 = this.__data__, index2 = assocIndexOf_default(data2, key);
    if (index2 < 0) {
      ++this.size;
      data2.push([key, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  var listCacheSet_default = listCacheSet;

  // node_modules/lodash-es/_ListCache.js
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear_default;
  ListCache.prototype["delete"] = listCacheDelete_default;
  ListCache.prototype.get = listCacheGet_default;
  ListCache.prototype.has = listCacheHas_default;
  ListCache.prototype.set = listCacheSet_default;
  var ListCache_default = ListCache;

  // node_modules/lodash-es/_Map.js
  var Map2 = getNative_default(root_default, "Map");
  var Map_default = Map2;

  // node_modules/lodash-es/_mapCacheClear.js
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash_default(),
      "map": new (Map_default || ListCache_default)(),
      "string": new Hash_default()
    };
  }
  var mapCacheClear_default = mapCacheClear;

  // node_modules/lodash-es/_isKeyable.js
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  var isKeyable_default = isKeyable;

  // node_modules/lodash-es/_getMapData.js
  function getMapData(map, key) {
    var data2 = map.__data__;
    return isKeyable_default(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  var getMapData_default = getMapData;

  // node_modules/lodash-es/_mapCacheDelete.js
  function mapCacheDelete(key) {
    var result = getMapData_default(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var mapCacheDelete_default = mapCacheDelete;

  // node_modules/lodash-es/_mapCacheGet.js
  function mapCacheGet(key) {
    return getMapData_default(this, key).get(key);
  }
  var mapCacheGet_default = mapCacheGet;

  // node_modules/lodash-es/_mapCacheHas.js
  function mapCacheHas(key) {
    return getMapData_default(this, key).has(key);
  }
  var mapCacheHas_default = mapCacheHas;

  // node_modules/lodash-es/_mapCacheSet.js
  function mapCacheSet(key, value) {
    var data2 = getMapData_default(this, key), size = data2.size;
    data2.set(key, value);
    this.size += data2.size == size ? 0 : 1;
    return this;
  }
  var mapCacheSet_default = mapCacheSet;

  // node_modules/lodash-es/_MapCache.js
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear_default;
  MapCache.prototype["delete"] = mapCacheDelete_default;
  MapCache.prototype.get = mapCacheGet_default;
  MapCache.prototype.has = mapCacheHas_default;
  MapCache.prototype.set = mapCacheSet_default;
  var MapCache_default = MapCache;

  // node_modules/lodash-es/memoize.js
  var FUNC_ERROR_TEXT2 = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT2);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache_default)();
    return memoized;
  }
  memoize.Cache = MapCache_default;
  var memoize_default = memoize;

  // node_modules/lodash-es/_memoizeCapped.js
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize_default(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  var memoizeCapped_default = memoizeCapped;

  // node_modules/lodash-es/_stringToPath.js
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped_default(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  var stringToPath_default = stringToPath;

  // node_modules/lodash-es/toString.js
  function toString(value) {
    return value == null ? "" : baseToString_default(value);
  }
  var toString_default = toString;

  // node_modules/lodash-es/_castPath.js
  function castPath(value, object) {
    if (isArray_default(value)) {
      return value;
    }
    return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
  }
  var castPath_default = castPath;

  // node_modules/lodash-es/_toKey.js
  var INFINITY3 = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol_default(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
  }
  var toKey_default = toKey;

  // node_modules/lodash-es/_baseGet.js
  function baseGet(object, path) {
    path = castPath_default(path, object);
    var index2 = 0, length = path.length;
    while (object != null && index2 < length) {
      object = object[toKey_default(path[index2++])];
    }
    return index2 && index2 == length ? object : void 0;
  }
  var baseGet_default = baseGet;

  // node_modules/lodash-es/get.js
  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet_default(object, path);
    return result === void 0 ? defaultValue : result;
  }
  var get_default = get;

  // node_modules/lodash-es/_arrayPush.js
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  var arrayPush_default = arrayPush;

  // node_modules/lodash-es/_isFlattenable.js
  var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  var isFlattenable_default = isFlattenable;

  // node_modules/lodash-es/_baseFlatten.js
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index2 = -1, length = array.length;
    predicate || (predicate = isFlattenable_default);
    result || (result = []);
    while (++index2 < length) {
      var value = array[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush_default(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  var baseFlatten_default = baseFlatten;

  // node_modules/lodash-es/flatten.js
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten_default(array, 1) : [];
  }
  var flatten_default = flatten;

  // node_modules/lodash-es/_flatRest.js
  function flatRest(func) {
    return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
  }
  var flatRest_default = flatRest;

  // node_modules/lodash-es/_getPrototype.js
  var getPrototype = overArg_default(Object.getPrototypeOf, Object);
  var getPrototype_default = getPrototype;

  // node_modules/lodash-es/before.js
  var FUNC_ERROR_TEXT3 = "Expected a function";
  function before(n, func) {
    var result;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT3);
    }
    n = toInteger_default(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = void 0;
      }
      return result;
    };
  }
  var before_default = before;

  // node_modules/lodash-es/_baseSlice.js
  function baseSlice(array, start2, end) {
    var index2 = -1, length = array.length;
    if (start2 < 0) {
      start2 = -start2 > length ? 0 : length + start2;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start2 > end ? 0 : end - start2 >>> 0;
    start2 >>>= 0;
    var result = Array(length);
    while (++index2 < length) {
      result[index2] = array[index2 + start2];
    }
    return result;
  }
  var baseSlice_default = baseSlice;

  // node_modules/lodash-es/_baseClamp.js
  function baseClamp(number, lower, upper) {
    if (number === number) {
      if (upper !== void 0) {
        number = number <= upper ? number : upper;
      }
      if (lower !== void 0) {
        number = number >= lower ? number : lower;
      }
    }
    return number;
  }
  var baseClamp_default = baseClamp;

  // node_modules/lodash-es/clamp.js
  function clamp(number, lower, upper) {
    if (upper === void 0) {
      upper = lower;
      lower = void 0;
    }
    if (upper !== void 0) {
      upper = toNumber_default(upper);
      upper = upper === upper ? upper : 0;
    }
    if (lower !== void 0) {
      lower = toNumber_default(lower);
      lower = lower === lower ? lower : 0;
    }
    return baseClamp_default(toNumber_default(number), lower, upper);
  }
  var clamp_default = clamp;

  // node_modules/lodash-es/_stackClear.js
  function stackClear() {
    this.__data__ = new ListCache_default();
    this.size = 0;
  }
  var stackClear_default = stackClear;

  // node_modules/lodash-es/_stackDelete.js
  function stackDelete(key) {
    var data2 = this.__data__, result = data2["delete"](key);
    this.size = data2.size;
    return result;
  }
  var stackDelete_default = stackDelete;

  // node_modules/lodash-es/_stackGet.js
  function stackGet(key) {
    return this.__data__.get(key);
  }
  var stackGet_default = stackGet;

  // node_modules/lodash-es/_stackHas.js
  function stackHas(key) {
    return this.__data__.has(key);
  }
  var stackHas_default = stackHas;

  // node_modules/lodash-es/_stackSet.js
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache_default) {
      var pairs = data2.__data__;
      if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache_default(pairs);
    }
    data2.set(key, value);
    this.size = data2.size;
    return this;
  }
  var stackSet_default = stackSet;

  // node_modules/lodash-es/_Stack.js
  function Stack(entries) {
    var data2 = this.__data__ = new ListCache_default(entries);
    this.size = data2.size;
  }
  Stack.prototype.clear = stackClear_default;
  Stack.prototype["delete"] = stackDelete_default;
  Stack.prototype.get = stackGet_default;
  Stack.prototype.has = stackHas_default;
  Stack.prototype.set = stackSet_default;
  var Stack_default = Stack;

  // node_modules/lodash-es/_arrayFilter.js
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  var arrayFilter_default = arrayFilter;

  // node_modules/lodash-es/stubArray.js
  function stubArray() {
    return [];
  }
  var stubArray_default = stubArray;

  // node_modules/lodash-es/_getSymbols.js
  var objectProto14 = Object.prototype;
  var propertyIsEnumerable2 = objectProto14.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable2.call(object, symbol);
    });
  };
  var getSymbols_default = getSymbols;

  // node_modules/lodash-es/_getSymbolsIn.js
  var nativeGetSymbols2 = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
    var result = [];
    while (object) {
      arrayPush_default(result, getSymbols_default(object));
      object = getPrototype_default(object);
    }
    return result;
  };
  var getSymbolsIn_default = getSymbolsIn;

  // node_modules/lodash-es/_baseGetAllKeys.js
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
  }
  var baseGetAllKeys_default = baseGetAllKeys;

  // node_modules/lodash-es/_getAllKeys.js
  function getAllKeys(object) {
    return baseGetAllKeys_default(object, keys_default, getSymbols_default);
  }
  var getAllKeys_default = getAllKeys;

  // node_modules/lodash-es/_getAllKeysIn.js
  function getAllKeysIn(object) {
    return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
  }
  var getAllKeysIn_default = getAllKeysIn;

  // node_modules/lodash-es/_DataView.js
  var DataView = getNative_default(root_default, "DataView");
  var DataView_default = DataView;

  // node_modules/lodash-es/_Promise.js
  var Promise2 = getNative_default(root_default, "Promise");
  var Promise_default = Promise2;

  // node_modules/lodash-es/_Set.js
  var Set2 = getNative_default(root_default, "Set");
  var Set_default = Set2;

  // node_modules/lodash-es/_getTag.js
  var mapTag2 = "[object Map]";
  var objectTag2 = "[object Object]";
  var promiseTag = "[object Promise]";
  var setTag2 = "[object Set]";
  var weakMapTag2 = "[object WeakMap]";
  var dataViewTag2 = "[object DataView]";
  var dataViewCtorString = toSource_default(DataView_default);
  var mapCtorString = toSource_default(Map_default);
  var promiseCtorString = toSource_default(Promise_default);
  var setCtorString = toSource_default(Set_default);
  var weakMapCtorString = toSource_default(WeakMap_default);
  var getTag = baseGetTag_default;
  if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
    getTag = function(value) {
      var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag2;
          case mapCtorString:
            return mapTag2;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag2;
          case weakMapCtorString:
            return weakMapTag2;
        }
      }
      return result;
    };
  }
  var getTag_default = getTag;

  // node_modules/lodash-es/_Uint8Array.js
  var Uint8Array2 = root_default.Uint8Array;
  var Uint8Array_default = Uint8Array2;

  // node_modules/lodash-es/compact.js
  function compact(array) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (value) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  var compact_default = compact;

  // node_modules/lodash-es/_setCacheAdd.js
  var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED3);
    return this;
  }
  var setCacheAdd_default = setCacheAdd;

  // node_modules/lodash-es/_setCacheHas.js
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  var setCacheHas_default = setCacheHas;

  // node_modules/lodash-es/_SetCache.js
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache_default();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
  SetCache.prototype.has = setCacheHas_default;
  var SetCache_default = SetCache;

  // node_modules/lodash-es/_arraySome.js
  function arraySome(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  var arraySome_default = arraySome;

  // node_modules/lodash-es/_cacheHas.js
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  var cacheHas_default = cacheHas;

  // node_modules/lodash-es/_equalArrays.js
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome_default(other, function(othValue2, othIndex) {
          if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  var equalArrays_default = equalArrays;

  // node_modules/lodash-es/_mapToArray.js
  function mapToArray(map) {
    var index2 = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  var mapToArray_default = mapToArray;

  // node_modules/lodash-es/_setToArray.js
  function setToArray(set6) {
    var index2 = -1, result = Array(set6.size);
    set6.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var setToArray_default = setToArray;

  // node_modules/lodash-es/_equalByTag.js
  var COMPARE_PARTIAL_FLAG2 = 1;
  var COMPARE_UNORDERED_FLAG2 = 2;
  var boolTag2 = "[object Boolean]";
  var dateTag2 = "[object Date]";
  var errorTag2 = "[object Error]";
  var mapTag3 = "[object Map]";
  var numberTag2 = "[object Number]";
  var regexpTag2 = "[object RegExp]";
  var setTag3 = "[object Set]";
  var stringTag2 = "[object String]";
  var symbolTag2 = "[object Symbol]";
  var arrayBufferTag2 = "[object ArrayBuffer]";
  var dataViewTag3 = "[object DataView]";
  var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag3:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag2:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
          return false;
        }
        return true;
      case boolTag2:
      case dateTag2:
      case numberTag2:
        return eq_default(+object, +other);
      case errorTag2:
        return object.name == other.name && object.message == other.message;
      case regexpTag2:
      case stringTag2:
        return object == other + "";
      case mapTag3:
        var convert = mapToArray_default;
      case setTag3:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
        convert || (convert = setToArray_default);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG2;
        stack.set(object, other);
        var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var equalByTag_default = equalByTag;

  // node_modules/lodash-es/_equalObjects.js
  var COMPARE_PARTIAL_FLAG3 = 1;
  var objectProto15 = Object.prototype;
  var hasOwnProperty12 = objectProto15.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  var equalObjects_default = equalObjects;

  // node_modules/lodash-es/_baseIsEqualDeep.js
  var COMPARE_PARTIAL_FLAG4 = 1;
  var argsTag3 = "[object Arguments]";
  var arrayTag2 = "[object Array]";
  var objectTag3 = "[object Object]";
  var objectProto16 = Object.prototype;
  var hasOwnProperty13 = objectProto16.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
    objTag = objTag == argsTag3 ? objectTag3 : objTag;
    othTag = othTag == argsTag3 ? objectTag3 : othTag;
    var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer_default(object)) {
      if (!isBuffer_default(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack_default());
      return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
      var objIsWrapped = objIsObj && hasOwnProperty13.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack_default());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack_default());
    return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
  }
  var baseIsEqualDeep_default = baseIsEqualDeep;

  // node_modules/lodash-es/_baseIsEqual.js
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  var baseIsEqual_default = baseIsEqual;

  // node_modules/lodash-es/_baseIsMatch.js
  var COMPARE_PARTIAL_FLAG5 = 1;
  var COMPARE_UNORDERED_FLAG3 = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index2 = matchData.length, length = index2, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index2--) {
      var data2 = matchData[index2];
      if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
        return false;
      }
    }
    while (++index2 < length) {
      data2 = matchData[index2];
      var key = data2[0], objValue = object[key], srcValue = data2[1];
      if (noCustomizer && data2[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack_default();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  var baseIsMatch_default = baseIsMatch;

  // node_modules/lodash-es/_isStrictComparable.js
  function isStrictComparable(value) {
    return value === value && !isObject_default(value);
  }
  var isStrictComparable_default = isStrictComparable;

  // node_modules/lodash-es/_getMatchData.js
  function getMatchData(object) {
    var result = keys_default(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable_default(value)];
    }
    return result;
  }
  var getMatchData_default = getMatchData;

  // node_modules/lodash-es/_matchesStrictComparable.js
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }
  var matchesStrictComparable_default = matchesStrictComparable;

  // node_modules/lodash-es/_baseMatches.js
  function baseMatches(source) {
    var matchData = getMatchData_default(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch_default(object, source, matchData);
    };
  }
  var baseMatches_default = baseMatches;

  // node_modules/lodash-es/_baseHasIn.js
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  var baseHasIn_default = baseHasIn;

  // node_modules/lodash-es/_hasPath.js
  function hasPath(object, path, hasFunc) {
    path = castPath_default(path, object);
    var index2 = -1, length = path.length, result = false;
    while (++index2 < length) {
      var key = toKey_default(path[index2]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index2 != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
  }
  var hasPath_default = hasPath;

  // node_modules/lodash-es/hasIn.js
  function hasIn(object, path) {
    return object != null && hasPath_default(object, path, baseHasIn_default);
  }
  var hasIn_default = hasIn;

  // node_modules/lodash-es/_baseMatchesProperty.js
  var COMPARE_PARTIAL_FLAG6 = 1;
  var COMPARE_UNORDERED_FLAG4 = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey_default(path) && isStrictComparable_default(srcValue)) {
      return matchesStrictComparable_default(toKey_default(path), srcValue);
    }
    return function(object) {
      var objValue = get_default(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
    };
  }
  var baseMatchesProperty_default = baseMatchesProperty;

  // node_modules/lodash-es/_baseProperty.js
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  var baseProperty_default = baseProperty;

  // node_modules/lodash-es/_basePropertyDeep.js
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet_default(object, path);
    };
  }
  var basePropertyDeep_default = basePropertyDeep;

  // node_modules/lodash-es/property.js
  function property(path) {
    return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
  }
  var property_default = property;

  // node_modules/lodash-es/_baseIteratee.js
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity_default;
    }
    if (typeof value == "object") {
      return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
    }
    return property_default(value);
  }
  var baseIteratee_default = baseIteratee;

  // node_modules/lodash-es/_arrayAggregator.js
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      var value = array[index2];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }
  var arrayAggregator_default = arrayAggregator;

  // node_modules/lodash-es/_createBaseFor.js
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  var createBaseFor_default = createBaseFor;

  // node_modules/lodash-es/_baseFor.js
  var baseFor = createBaseFor_default();
  var baseFor_default = baseFor;

  // node_modules/lodash-es/_baseForOwn.js
  function baseForOwn(object, iteratee) {
    return object && baseFor_default(object, iteratee, keys_default);
  }
  var baseForOwn_default = baseForOwn;

  // node_modules/lodash-es/_createBaseEach.js
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike_default(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  var createBaseEach_default = createBaseEach;

  // node_modules/lodash-es/_baseEach.js
  var baseEach = createBaseEach_default(baseForOwn_default);
  var baseEach_default = baseEach;

  // node_modules/lodash-es/_baseAggregator.js
  function baseAggregator(collection, setter, iteratee, accumulator) {
    baseEach_default(collection, function(value, key, collection2) {
      setter(accumulator, value, iteratee(value), collection2);
    });
    return accumulator;
  }
  var baseAggregator_default = baseAggregator;

  // node_modules/lodash-es/_createAggregator.js
  function createAggregator(setter, initializer) {
    return function(collection, iteratee) {
      var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
      return func(collection, setter, baseIteratee_default(iteratee, 2), accumulator);
    };
  }
  var createAggregator_default = createAggregator;

  // node_modules/lodash-es/curryRight.js
  var WRAP_CURRY_RIGHT_FLAG4 = 16;
  function curryRight(func, arity, guard) {
    arity = guard ? void 0 : arity;
    var result = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
    result.placeholder = curryRight.placeholder;
    return result;
  }
  curryRight.placeholder = {};
  var curryRight_default = curryRight;

  // node_modules/lodash-es/now.js
  var now = function() {
    return root_default.Date.now();
  };
  var now_default = now;

  // node_modules/lodash-es/debounce.js
  var FUNC_ERROR_TEXT4 = "Expected a function";
  var nativeMax5 = Math.max;
  var nativeMin3 = Math.min;
  function debounce(func, wait, options6) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT4);
    }
    wait = toNumber_default(wait) || 0;
    if (isObject_default(options6)) {
      leading = !!options6.leading;
      maxing = "maxWait" in options6;
      maxWait = maxing ? nativeMax5(toNumber_default(options6.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options6 ? !!options6.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin3(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now_default();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now_default());
    }
    function debounced() {
      var time = now_default(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  var debounce_default = debounce;

  // node_modules/lodash-es/isArrayLikeObject.js
  function isArrayLikeObject(value) {
    return isObjectLike_default(value) && isArrayLike_default(value);
  }
  var isArrayLikeObject_default = isArrayLikeObject;

  // node_modules/lodash-es/_arrayIncludesWith.js
  function arrayIncludesWith(array, value, comparator) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (comparator(value, array[index2])) {
        return true;
      }
    }
    return false;
  }
  var arrayIncludesWith_default = arrayIncludesWith;

  // node_modules/lodash-es/_baseDifference.js
  var LARGE_ARRAY_SIZE2 = 200;
  function baseDifference(array, values, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes_default, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap_default(values, baseUnary_default(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith_default;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE2) {
      includes = cacheHas_default;
      isCommon = false;
      values = new SetCache_default(values);
    }
    outer:
      while (++index2 < length) {
        var value = array[index2], computed = iteratee == null ? value : iteratee(value);
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  var baseDifference_default = baseDifference;

  // node_modules/lodash-es/difference.js
  var difference = baseRest_default(function(array, values) {
    return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values, 1, isArrayLikeObject_default, true)) : [];
  });
  var difference_default = difference;

  // node_modules/lodash-es/last.js
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : void 0;
  }
  var last_default = last;

  // node_modules/lodash-es/_baseWhile.js
  function baseWhile(array, predicate, isDrop, fromRight) {
    var length = array.length, index2 = fromRight ? length : -1;
    while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
    }
    return isDrop ? baseSlice_default(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice_default(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
  }
  var baseWhile_default = baseWhile;

  // node_modules/lodash-es/dropWhile.js
  function dropWhile(array, predicate) {
    return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true) : [];
  }
  var dropWhile_default = dropWhile;

  // node_modules/lodash-es/escapeRegExp.js
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reHasRegExpChar = RegExp(reRegExpChar2.source);
  function escapeRegExp(string) {
    string = toString_default(string);
    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
  }
  var escapeRegExp_default = escapeRegExp;

  // node_modules/lodash-es/_baseMap.js
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
    baseEach_default(collection, function(value, key, collection2) {
      result[++index2] = iteratee(value, key, collection2);
    });
    return result;
  }
  var baseMap_default = baseMap;

  // node_modules/lodash-es/fromPairs.js
  function fromPairs(pairs) {
    var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
    while (++index2 < length) {
      var pair = pairs[index2];
      result[pair[0]] = pair[1];
    }
    return result;
  }
  var fromPairs_default = fromPairs;

  // node_modules/lodash-es/groupBy.js
  var objectProto17 = Object.prototype;
  var hasOwnProperty14 = objectProto17.hasOwnProperty;
  var groupBy = createAggregator_default(function(result, value, key) {
    if (hasOwnProperty14.call(result, key)) {
      result[key].push(value);
    } else {
      baseAssignValue_default(result, key, [value]);
    }
  });
  var groupBy_default = groupBy;

  // node_modules/lodash-es/_baseGt.js
  function baseGt(value, other) {
    return value > other;
  }
  var baseGt_default = baseGt;

  // node_modules/lodash-es/_baseIntersection.js
  var nativeMin4 = Math.min;
  function baseIntersection(arrays, iteratee, comparator) {
    var includes = comparator ? arrayIncludesWith_default : arrayIncludes_default, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
    while (othIndex--) {
      var array = arrays[othIndex];
      if (othIndex && iteratee) {
        array = arrayMap_default(array, baseUnary_default(iteratee));
      }
      maxLength = nativeMin4(array.length, maxLength);
      caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache_default(othIndex && array) : void 0;
    }
    array = arrays[0];
    var index2 = -1, seen = caches[0];
    outer:
      while (++index2 < length && result.length < maxLength) {
        var value = array[index2], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (!(seen ? cacheHas_default(seen, computed) : includes(result, computed, comparator))) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache ? cacheHas_default(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var baseIntersection_default = baseIntersection;

  // node_modules/lodash-es/_castArrayLikeObject.js
  function castArrayLikeObject(value) {
    return isArrayLikeObject_default(value) ? value : [];
  }
  var castArrayLikeObject_default = castArrayLikeObject;

  // node_modules/lodash-es/intersection.js
  var intersection = baseRest_default(function(arrays) {
    var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
    return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
  });
  var intersection_default = intersection;

  // node_modules/lodash-es/_parent.js
  function parent(object, path) {
    return path.length < 2 ? object : baseGet_default(object, baseSlice_default(path, 0, -1));
  }
  var parent_default = parent;

  // node_modules/lodash-es/isEmpty.js
  var mapTag4 = "[object Map]";
  var setTag4 = "[object Set]";
  var objectProto18 = Object.prototype;
  var hasOwnProperty15 = objectProto18.hasOwnProperty;
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
      return !value.length;
    }
    var tag = getTag_default(value);
    if (tag == mapTag4 || tag == setTag4) {
      return !value.size;
    }
    if (isPrototype_default(value)) {
      return !baseKeys_default(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty15.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  var isEmpty_default = isEmpty;

  // node_modules/lodash-es/isEqual.js
  function isEqual(value, other) {
    return baseIsEqual_default(value, other);
  }
  var isEqual_default = isEqual;

  // node_modules/lodash-es/keyBy.js
  var keyBy = createAggregator_default(function(result, value, key) {
    baseAssignValue_default(result, key, value);
  });
  var keyBy_default = keyBy;

  // node_modules/lodash-es/mapValues.js
  function mapValues(object, iteratee) {
    var result = {};
    iteratee = baseIteratee_default(iteratee, 3);
    baseForOwn_default(object, function(value, key, object2) {
      baseAssignValue_default(result, key, iteratee(value, key, object2));
    });
    return result;
  }
  var mapValues_default = mapValues;

  // node_modules/lodash-es/_baseExtremum.js
  function baseExtremum(array, iteratee, comparator) {
    var index2 = -1, length = array.length;
    while (++index2 < length) {
      var value = array[index2], current2 = iteratee(value);
      if (current2 != null && (computed === void 0 ? current2 === current2 && !isSymbol_default(current2) : comparator(current2, computed))) {
        var computed = current2, result = value;
      }
    }
    return result;
  }
  var baseExtremum_default = baseExtremum;

  // node_modules/lodash-es/maxBy.js
  function maxBy(array, iteratee) {
    return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee, 2), baseGt_default) : void 0;
  }
  var maxBy_default = maxBy;

  // node_modules/lodash-es/negate.js
  var FUNC_ERROR_TEXT5 = "Expected a function";
  function negate(predicate) {
    if (typeof predicate != "function") {
      throw new TypeError(FUNC_ERROR_TEXT5);
    }
    return function() {
      var args = arguments;
      switch (args.length) {
        case 0:
          return !predicate.call(this);
        case 1:
          return !predicate.call(this, args[0]);
        case 2:
          return !predicate.call(this, args[0], args[1]);
        case 3:
          return !predicate.call(this, args[0], args[1], args[2]);
      }
      return !predicate.apply(this, args);
    };
  }
  var negate_default = negate;

  // node_modules/lodash-es/_baseUnset.js
  function baseUnset(object, path) {
    path = castPath_default(path, object);
    object = parent_default(object, path);
    return object == null || delete object[toKey_default(last_default(path))];
  }
  var baseUnset_default = baseUnset;

  // node_modules/lodash-es/_baseSet.js
  function baseSet(object, path, value, customizer) {
    if (!isObject_default(object)) {
      return object;
    }
    path = castPath_default(path, object);
    var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
    while (nested != null && ++index2 < length) {
      var key = toKey_default(path[index2]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object;
      }
      if (index2 != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index2 + 1]) ? [] : {};
        }
      }
      assignValue_default(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }
  var baseSet_default = baseSet;

  // node_modules/lodash-es/_basePickBy.js
  function basePickBy(object, paths, predicate) {
    var index2 = -1, length = paths.length, result = {};
    while (++index2 < length) {
      var path = paths[index2], value = baseGet_default(object, path);
      if (predicate(value, path)) {
        baseSet_default(result, castPath_default(path, object), value);
      }
    }
    return result;
  }
  var basePickBy_default = basePickBy;

  // node_modules/lodash-es/pickBy.js
  function pickBy(object, predicate) {
    if (object == null) {
      return {};
    }
    var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
      return [prop];
    });
    predicate = baseIteratee_default(predicate);
    return basePickBy_default(object, props, function(value, path) {
      return predicate(value, path[0]);
    });
  }
  var pickBy_default = pickBy;

  // node_modules/lodash-es/omitBy.js
  function omitBy(object, predicate) {
    return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
  }
  var omitBy_default = omitBy;

  // node_modules/lodash-es/once.js
  function once(func) {
    return before_default(2, func);
  }
  var once_default = once;

  // node_modules/lodash-es/_baseSortBy.js
  function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }
  var baseSortBy_default = baseSortBy;

  // node_modules/lodash-es/_compareAscending.js
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  var compareAscending_default = compareAscending;

  // node_modules/lodash-es/_compareMultiple.js
  function compareMultiple(object, other, orders) {
    var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
    while (++index2 < length) {
      var result = compareAscending_default(objCriteria[index2], othCriteria[index2]);
      if (result) {
        if (index2 >= ordersLength) {
          return result;
        }
        var order = orders[index2];
        return result * (order == "desc" ? -1 : 1);
      }
    }
    return object.index - other.index;
  }
  var compareMultiple_default = compareMultiple;

  // node_modules/lodash-es/_baseOrderBy.js
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap_default(iteratees, function(iteratee) {
        if (isArray_default(iteratee)) {
          return function(value) {
            return baseGet_default(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity_default];
    }
    var index2 = -1;
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    var result = baseMap_default(collection, function(value, key, collection2) {
      var criteria = arrayMap_default(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index2, "value": value };
    });
    return baseSortBy_default(result, function(object, other) {
      return compareMultiple_default(object, other, orders);
    });
  }
  var baseOrderBy_default = baseOrderBy;

  // node_modules/lodash-es/partition.js
  var partition = createAggregator_default(function(result, value, key) {
    result[key ? 0 : 1].push(value);
  }, function() {
    return [[], []];
  });
  var partition_default = partition;

  // node_modules/lodash-es/_basePick.js
  function basePick(object, paths) {
    return basePickBy_default(object, paths, function(value, path) {
      return hasIn_default(object, path);
    });
  }
  var basePick_default = basePick;

  // node_modules/lodash-es/pick.js
  var pick = flatRest_default(function(object, paths) {
    return object == null ? {} : basePick_default(object, paths);
  });
  var pick_default = pick;

  // node_modules/lodash-es/_baseIndexOfWith.js
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index2 = fromIndex - 1, length = array.length;
    while (++index2 < length) {
      if (comparator(array[index2], value)) {
        return index2;
      }
    }
    return -1;
  }
  var baseIndexOfWith_default = baseIndexOfWith;

  // node_modules/lodash-es/_basePullAll.js
  var arrayProto2 = Array.prototype;
  var splice2 = arrayProto2.splice;
  function basePullAll(array, values, iteratee, comparator) {
    var indexOf = comparator ? baseIndexOfWith_default : baseIndexOf_default, index2 = -1, length = values.length, seen = array;
    if (array === values) {
      values = copyArray_default(values);
    }
    if (iteratee) {
      seen = arrayMap_default(array, baseUnary_default(iteratee));
    }
    while (++index2 < length) {
      var fromIndex = 0, value = values[index2], computed = iteratee ? iteratee(value) : value;
      while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
        if (seen !== array) {
          splice2.call(seen, fromIndex, 1);
        }
        splice2.call(array, fromIndex, 1);
      }
    }
    return array;
  }
  var basePullAll_default = basePullAll;

  // node_modules/lodash-es/pullAll.js
  function pullAll(array, values) {
    return array && array.length && values && values.length ? basePullAll_default(array, values) : array;
  }
  var pullAll_default = pullAll;

  // node_modules/lodash-es/pull.js
  var pull = baseRest_default(pullAll_default);
  var pull_default = pull;

  // node_modules/lodash-es/_basePullAt.js
  var arrayProto3 = Array.prototype;
  var splice3 = arrayProto3.splice;
  function basePullAt(array, indexes) {
    var length = array ? indexes.length : 0, lastIndex = length - 1;
    while (length--) {
      var index2 = indexes[length];
      if (length == lastIndex || index2 !== previous2) {
        var previous2 = index2;
        if (isIndex_default(index2)) {
          splice3.call(array, index2, 1);
        } else {
          baseUnset_default(array, index2);
        }
      }
    }
    return array;
  }
  var basePullAt_default = basePullAt;

  // node_modules/lodash-es/_baseRandom.js
  var nativeFloor = Math.floor;
  var nativeRandom = Math.random;
  function baseRandom(lower, upper) {
    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
  }
  var baseRandom_default = baseRandom;

  // node_modules/lodash-es/random.js
  var freeParseFloat = parseFloat;
  var nativeMin5 = Math.min;
  var nativeRandom2 = Math.random;
  function random(lower, upper, floating) {
    if (floating && typeof floating != "boolean" && isIterateeCall_default(lower, upper, floating)) {
      upper = floating = void 0;
    }
    if (floating === void 0) {
      if (typeof upper == "boolean") {
        floating = upper;
        upper = void 0;
      } else if (typeof lower == "boolean") {
        floating = lower;
        lower = void 0;
      }
    }
    if (lower === void 0 && upper === void 0) {
      lower = 0;
      upper = 1;
    } else {
      lower = toFinite_default(lower);
      if (upper === void 0) {
        upper = lower;
        lower = 0;
      } else {
        upper = toFinite_default(upper);
      }
    }
    if (lower > upper) {
      var temp = lower;
      lower = upper;
      upper = temp;
    }
    if (floating || lower % 1 || upper % 1) {
      var rand = nativeRandom2();
      return nativeMin5(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
    }
    return baseRandom_default(lower, upper);
  }
  var random_default = random;

  // node_modules/lodash-es/remove.js
  function remove(array, predicate) {
    var result = [];
    if (!(array && array.length)) {
      return result;
    }
    var index2 = -1, indexes = [], length = array.length;
    predicate = baseIteratee_default(predicate, 3);
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result.push(value);
        indexes.push(index2);
      }
    }
    basePullAt_default(array, indexes);
    return result;
  }
  var remove_default = remove;

  // node_modules/lodash-es/sortBy.js
  var sortBy = baseRest_default(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length = iteratees.length;
    if (length > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
  });
  var sortBy_default = sortBy;

  // node_modules/lodash-es/throttle.js
  var FUNC_ERROR_TEXT6 = "Expected a function";
  function throttle(func, wait, options6) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT6);
    }
    if (isObject_default(options6)) {
      leading = "leading" in options6 ? !!options6.leading : leading;
      trailing = "trailing" in options6 ? !!options6.trailing : trailing;
    }
    return debounce_default(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  var throttle_default = throttle;

  // node_modules/lodash-es/transform.js
  function transform(object, iteratee, accumulator) {
    var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
    iteratee = baseIteratee_default(iteratee, 4);
    if (accumulator == null) {
      var Ctor = object && object.constructor;
      if (isArrLike) {
        accumulator = isArr ? new Ctor() : [];
      } else if (isObject_default(object)) {
        accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
      } else {
        accumulator = {};
      }
    }
    (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value, index2, object2) {
      return iteratee(accumulator, value, index2, object2);
    });
    return accumulator;
  }
  var transform_default = transform;

  // node_modules/lodash-es/_createSet.js
  var INFINITY4 = 1 / 0;
  var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values) {
    return new Set_default(values);
  };
  var createSet_default = createSet;

  // node_modules/lodash-es/_baseUniq.js
  var LARGE_ARRAY_SIZE3 = 200;
  function baseUniq(array, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes_default, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith_default;
    } else if (length >= LARGE_ARRAY_SIZE3) {
      var set6 = iteratee ? null : createSet_default(array);
      if (set6) {
        return setToArray_default(set6);
      }
      isCommon = false;
      includes = cacheHas_default;
      seen = new SetCache_default();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index2 < length) {
        var value = array[index2], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var baseUniq_default = baseUniq;

  // node_modules/lodash-es/uniqBy.js
  function uniqBy(array, iteratee) {
    return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee, 2)) : [];
  }
  var uniqBy_default = uniqBy;

  // node_modules/lodash-es/unzip.js
  var nativeMax6 = Math.max;
  function unzip(array) {
    if (!(array && array.length)) {
      return [];
    }
    var length = 0;
    array = arrayFilter_default(array, function(group) {
      if (isArrayLikeObject_default(group)) {
        length = nativeMax6(group.length, length);
        return true;
      }
    });
    return baseTimes_default(length, function(index2) {
      return arrayMap_default(array, baseProperty_default(index2));
    });
  }
  var unzip_default = unzip;

  // node_modules/lodash-es/unzipWith.js
  function unzipWith(array, iteratee) {
    if (!(array && array.length)) {
      return [];
    }
    var result = unzip_default(array);
    if (iteratee == null) {
      return result;
    }
    return arrayMap_default(result, function(group) {
      return apply_default(iteratee, void 0, group);
    });
  }
  var unzipWith_default = unzipWith;

  // node_modules/lodash-es/without.js
  var without = baseRest_default(function(array, values) {
    return isArrayLikeObject_default(array) ? baseDifference_default(array, values) : [];
  });
  var without_default = without;

  // node_modules/lodash-es/zip.js
  var zip = baseRest_default(unzip_default);
  var zip_default = zip;

  // node_modules/lodash-es/zipWith.js
  var zipWith = baseRest_default(function(arrays) {
    var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : void 0;
    iteratee = typeof iteratee == "function" ? (arrays.pop(), iteratee) : void 0;
    return unzipWith_default(arrays, iteratee);
  });
  var zipWith_default = zipWith;

  // lib/utils/time.js
  var MINUTE = 1e3 * 60;
  var HOUR = 60 * MINUTE;
  var DAY = 24 * HOUR;
  var WEEK = 7 * DAY;
  function fromSecondsToTime(timeInSeconds) {
    const seconds = timeInSeconds % 60;
    const minutes = Math.floor(timeInSeconds / 60) % 60;
    const hours = Math.floor(timeInSeconds / 3600);
    const time = [minutes, seconds];
    if (hours > 0) {
      time.unshift(hours);
    }
    return time.map((part) => String(part).padStart(2, "0")).join(":");
  }

  // lib/utils/location.js
  var regexes = {
    frontpage: /^\/(?:hot|new|rising|controversial|top)?(?:\/|$)/i,
    comments: /^\/(?:r\/([\w\.]+)\/|(u(?:ser)?\/[\w-]+)\/)?comments\/([a-z0-9]+)(?:\/|$)/i,
    commentsLinklist: /^\/(r\/[\w\.\+]+\/|u(?:ser)?\/[\w-]+\/)?comments\/?$/i,
    inbox: /^\/(?:r\/([\w\.]+)\/)?message(?:\/|$)/i,
    profile: /^\/user\/([\w\-]+)(?:\/(?:(?!m\/)(\w+)))?\/?$/i,
    profile2x: /^\/user\/([\w\-]+)(?:\/(?:(?!m\/)(\w+)))?\/?$/i,
    profileCommentsPage: /^\/user\/([\w\-]+)\/comments\/([a-z0-9]+)(?:\/|$)/i,
    submit: /^\/(?:r\/([\w\.\+]+)\/)?submit(?:\/|$)/i,
    prefs: /^\/prefs(?:\/|$)/i,
    account: /^\/account-activity(?:\/|$)/i,
    wiki: /^\/(?:r\/([\w\.]+)\/)?wiki(?:\/|$)/i,
    stylesheet: /^\/(?:r\/([\w\.]+)\/)about\/stylesheet(?:\/|$)/i,
    search: /^\/(?:r\/[\w\.\+]+\/|(?:me|user\/[\w\-]+)\/[mf]\/[\w\.\+]+\/|domain\/[^\/]+\/)?search(?:\/|$)/i,
    commentPermalink: /^\/(?:r\/([\w\.]+)\/)?comments\/([a-z0-9]+)\/[^\/]*\/([a-z0-9]+)(?:\/|$)/i,
    duplicates: /^\/r\/[\w\.\+]+\/duplicates\/([a-z0-9]+)/i,
    subreddit: /^\/r\/([\w\.\+]+)(?:\/|$)/i,
    subredditAbout: /^\/r\/([\w\.]+)\/about(?:\/(?!modqueue|reports|spam|unmoderated|edited)|$)/i,
    modqueue: /^\/(?:r|me\/f)\/([\w\.\+]+)\/about\/(?:modqueue|reports|spam|unmoderated|edited)(?:\/|$)/i,
    multireddit: /^\/((?:me|user\/[\w\-]+)\/[mf]\/[\w\.\+]+)(?:\/|$)/i,
    domain: /^\/domain\/([\w\.]+)(?:\/|$)/i,
    composeMessage: /^\/(?:r\/([\w\.\+]+)\/)?message\/compose(?:\/|$)/i,
    liveThread: /^\/live\/(?!create(?:\/|$))([a-z0-9]+)(?:\/|$)/i
  };
  var execRegexes = {
    comments: (path) => {
      const match = regexes.comments.exec(path);
      if (!match) return match;
      match.splice(1, 2, match[1] || match[2] && match[2].replace(/^u.*\//, "u_"));
      return match;
    }
  };
  var appPageTypes = {
    r2: {
      default: "linklist",
      pageTypes: ["wiki", "search", "stylesheet", "modqueue", "subredditAbout", "comments", "commentsLinklist", "profile", "liveThread", "inbox", "submit", "account", "prefs"]
    },
    d2x: {
      pageTypes: ["profile2x", "profileCommentsPage", "submit"]
    },
    options: {
      pageTypes: []
    }
  };
  var fullLocation = (pathname = location.pathname) => {
    const regex = Object.keys(regexes).find((key) => pathname.match(regexes[key]));
    if (!regex) return pathname.toLowerCase();
    return [
      regex,
      ...(pathname.match(regexes[regex]) || []).slice(1)
      // ignore matched string
    ].filter((v) => v).join("-").toLowerCase();
  };
  var COMMENT_CODE_REGEX = /^[\/#].+$/;
  function isCommentCode(link) {
    const href = link.getAttribute("href");
    const emptyText = link.textContent.length === 0;
    const isCommentCode2 = COMMENT_CODE_REGEX.test(href);
    return emptyText && isCommentCode2;
  }
  function isEmptyLink(link) {
    const href = link.getAttribute("href");
    return typeof href !== "string" || href.startsWith("javascript:") || href === "#";
  }

  // lib/utils/flow.js
  function downcast(val, ty) {
    if (
      // only perform the check in dev mode, but hide this from Flow
      /*:: ` */
      true
    ) {
      return val;
    }
    throw new TypeError(`Expected ${val} to be instance of ${ty}.`);
  }

  // lib/utils/generator.js
  function* range(start2, end) {
    for (let i2 = start2; i2 < end; ++i2) {
      yield i2;
    }
  }
  function* zip2(...iterables) {
    const generators = iterables.map((it) => it[Symbol.iterator]());
    let results;
    while ((results = generators.map((gen) => gen.next())).some((r) => !r.done)) {
      yield results.map((r) => r.value);
    }
  }

  // lib/utils/async.js
  function waitFor(callback, interval = 1) {
    return new Promise((resolve) => {
      (function repeat() {
        let val;
        try {
          val = callback();
        } catch (e2) {
          console.warn(val);
        }
        if (!val) {
          setTimeout(repeat, interval);
          return;
        }
        resolve(val);
      })();
    });
  }
  var forEachChunked = (() => {
    const framerate = 30;
    const frameTime = 1e3 / framerate;
    const queues = [];
    const run = frameThrottle(() => {
      const start2 = performance.now();
      do {
        remove_default(queues, ({ generator, callback, resolve, reject }) => {
          const { value, done } = generator.next();
          if (done) {
            resolve();
            return true;
          }
          try {
            callback(value);
          } catch (e2) {
            if (generator.return) generator.return();
            reject(e2);
            return true;
          }
        });
        if (!queues.length) {
          return;
        }
      } while (performance.now() - start2 < frameTime);
      run();
    });
    return curryRight_default(
      (collection, callback) => new Promise((resolve, reject) => {
        const iterable = Symbol.iterator in collection ? collection : Array.from(collection);
        queues.push({ generator: iterable[Symbol.iterator](), callback, resolve, reject });
        run();
      })
    );
  })();
  function batch(callback, { size = 100, delay = 50, flushBeforeUnload = false } = {}) {
    let invoke;
    function* batchAccumulator() {
      const entries = [];
      const promises = [];
      function addPromise() {
        if (entries.length) {
          return new Promise((resolve, reject) => {
            promises.push({ resolve, reject });
          });
        } else {
          return void 0;
        }
      }
      invoke = once_default(async () => {
        startNewBatch();
        if (!entries.length) return;
        try {
          const results = await callback(entries) || [];
          for (const [{ resolve, reject }, result] of zip2(promises, results)) {
            if (result instanceof Error) reject(result);
            else resolve(result);
          }
        } catch (e2) {
          for (const { reject } of promises) {
            reject(e2);
          }
        }
      });
      const timeout = delay ? debounce_default(invoke, delay) : throttle2(invoke);
      while (entries.length < size) {
        const entry = yield addPromise();
        if (entry === void 0) throw new Error("undefined passed into batch generator");
        entries.push(entry);
        timeout();
      }
      const lastPromise = addPromise();
      invoke();
      yield lastPromise;
    }
    let currentBatch;
    function startNewBatch() {
      currentBatch = batchAccumulator();
      currentBatch.next();
    }
    startNewBatch();
    if (flushBeforeUnload) window.addEventListener("beforeunload", () => {
      invoke();
    }, true);
    return (entry) => {
      const { value } = currentBatch.next(entry);
      if (value === void 0) throw new Error("Batch generator was not replaced after completion");
      return value;
    };
  }
  function always(promise, callback) {
    return promise.then(callback, callback);
  }
  function fastAsync(callback) {
    return function(...args) {
      return function next(generator, arg, throwing) {
        const { value, done } = !throwing ? generator.next(arg) : generator.throw(arg);
        if (done) {
          return value;
        } else if (!(value instanceof Promise)) {
          return next(generator, value, false);
        } else {
          return value.then(
            (val) => next(generator, val, false),
            (err) => next(generator, err, true)
          );
        }
      }(Reflect.apply(callback, this, args), void 0, false);
    };
  }
  function keyedMutex(callback, keyResolver = (x) => x) {
    const queues = /* @__PURE__ */ new Map();
    return function(...args) {
      const key = keyResolver(...args);
      const tail = queues.has(key) ? always(queues.get(key), () => Reflect.apply(callback, this, args)) : Reflect.apply(callback, this, args);
      if (tail instanceof Promise) {
        queues.set(key, tail);
        always(tail, () => {
          if (queues.get(key) === tail) queues.delete(key);
        });
      }
      return tail;
    };
  }
  function mutex(callback) {
    let queue;
    return function(...args) {
      const tail = queue ? always(queue, () => Reflect.apply(callback, this, args)) : Reflect.apply(callback, this, args);
      if (tail instanceof Promise) {
        queue = tail;
        always(tail, () => {
          if (queue === tail) queue = void 0;
        });
      }
      return tail;
    };
  }
  function throttle2(callback) {
    let promise;
    return () => {
      promise = promise || Promise.resolve().then(() => {
        promise = null;
        callback();
      });
      return promise;
    };
  }
  function frameDebounce(callback, debounce2 = 1) {
    let remaining;
    const update3 = frameThrottle(() => {
      if (remaining) requestAnimationFrame(() => {
        update3();
      });
      else callback();
      remaining -= 1;
    });
    return () => {
      remaining = debounce2;
      requestAnimationFrame(() => {
        update3();
      });
    };
  }
  function frameThrottle(callback) {
    let args = [];
    let promise;
    return (...a2) => {
      args = a2;
      promise = promise || new Promise((res, rej) => {
        requestAnimationFrame(() => {
          promise = null;
          try {
            res(callback(...args));
          } catch (e2) {
            rej(e2);
          }
        });
      });
      return promise;
    };
  }
  var throttleQueuePositionReset = (() => {
    let queues = [];
    const run = throttle2(() => {
      for (const fn of queues) {
        try {
          fn();
        } catch (e2) {
        }
      }
      queues = [];
    });
    return function(callback) {
      let args = [];
      let queued = false;
      function runCallback2() {
        queued = false;
        callback();
      }
      return (...a2) => {
        args = a2;
        if (queued) {
          pull_default(queues, callback);
        } else {
          queued = true;
        }
        queues.push(callback);
        run();
      };
    };
  })();
  function idleThrottle(callback) {
    let args = [];
    let promise;
    return (...a2) => {
      args = a2;
      promise = promise || new Promise((res, rej) => {
        requestIdleCallback(() => {
          promise = null;
          try {
            res(callback(...args));
          } catch (e2) {
            rej(e2);
          }
        });
      });
      return promise;
    };
  }

  // lib/utils/array.js
  async function forEachSeq(iterable, callback) {
    for (const val of iterable) {
      await callback(val);
    }
  }
  async function asyncFilter(array, predicate) {
    const shouldKeep = await Promise.all(array.map(predicate));
    return array.filter((e2, i2) => shouldKeep[i2]);
  }
  var asyncFind = fastAsync(function* asyncFind2(iterable, predicate) {
    for (const val of iterable) {
      if (yield predicate(val)) return val;
    }
  });
  function concurrentFold(array, reduce, initialValue, baseCase) {
    if (!array.length) return Promise.resolve(initialValue);
    return new Promise((resolve, reject) => {
      let remaining = array.length;
      let accum = initialValue;
      function onResolve(x) {
        if (remaining === 0) return;
        accum = reduce(accum, x);
        if (accum === baseCase || --remaining === 0) {
          remaining = 0;
          resolve(accum);
        }
      }
      function onReject(err) {
        if (remaining === 0) return;
        remaining = 0;
        reject(err);
      }
      array.forEach((promise) => promise.then(onResolve, onReject));
    });
  }
  function asyncSome(array, predicate) {
    return concurrentFold(array.map(predicate), (a2, b2) => a2 || !!b2, false, true);
  }
  var filterMap = curryRight_default((iterable, callback) => {
    const mapped = [];
    for (const x of iterable) {
      const result = callback(x);
      if (result) mapped.push(result[0]);
    }
    return mapped;
  });

  // lib/utils/Thing.js
  var elementMap = /* @__PURE__ */ new WeakMap();
  var things = /* @__PURE__ */ new Set();
  var SECRET_TOKEN = new class {
  }();
  var Thing = class _Thing {
    static thingSelector = ".thing, .search-result-link";
    static entrySelector = ".entry";
    // This query may be expensive and performed fairly often
    static thingElements = memoize_default((doc = document.body.querySelector('.content[role="main"]')) => Array.from(doc.querySelectorAll(_Thing.thingSelector)));
    static things(doc) {
      return _Thing.thingElements(doc).map((e2) => _Thing.checkedFrom(e2));
    }
    static visibleThingElements(doc) {
      return _Thing.thingElements(doc).filter((v) => v.offsetParent);
    }
    static visibleThings(doc) {
      return filterMap(_Thing.visibleThingElements(doc), (ele) => {
        const thing = _Thing.from(ele);
        if (thing) return [thing];
      });
    }
    element;
    entry;
    parent;
    children = /* @__PURE__ */ new Set();
    // Tasks are added and generally executed by watchers
    tasks = { completed: false, visible: [], immediate: [], byId: /* @__PURE__ */ new Map() };
    static checkedFrom(element) {
      const thing = _Thing.from(element);
      if (!thing) {
        throw new Error(`Could not construct Thing from ${String(element)}`);
      }
      return thing;
    }
    static from(element) {
      if (!element) return null;
      if (element instanceof _Thing) return element;
      const thingElement = element.closest(_Thing.thingSelector);
      if (!thingElement) return null;
      if (elementMap.has(thingElement)) return elementMap.get(thingElement);
      const entry = thingElement.querySelector(_Thing.entrySelector) || thingElement;
      const thing = new _Thing(SECRET_TOKEN, downcast(thingElement, HTMLElement), entry);
      _Thing.thingElements.cache.clear();
      elementMap.set(thingElement, thing);
      things.add(thing);
      return thing;
    }
    constructor(token, thing, entry) {
      if (token !== SECRET_TOKEN) {
        throw new Error("Use Thing.from() or Thing.checkedFrom() instead of new Thing()");
      }
      this.element = thing;
      this.entry = entry;
      const _p = this.element.parentElement;
      this.parent = _p && _Thing.from(_p.closest(".thing"));
      if (this.parent) this.parent.children.add(this);
    }
    runTasks() {
      if (this.tasks.completed) return;
      this.tasks.completed = true;
      this.tasks.immediate.map((fn) => fn());
      this.tasks.visible.map((fn) => fn());
    }
    runSurroundingTasks(margin = 10) {
      const thingElements = _Thing.thingElements();
      const idx = thingElements.indexOf(this.element);
      const min = Math.max(idx - margin, 0);
      const max = Math.min(idx + margin, thingElements.length - 1);
      for (let i2 = min; i2 <= max; i2++) {
        const thing = _Thing.checkedFrom(thingElements[i2]);
        if (!thing.tasks.completed && thing.isVisible()) thing.runTasks();
      }
    }
    anchor() {
      const anchor2 = getPercentageVisibleYAxis(this.entry) && { to: this.entry.getBoundingClientRect().top };
      if (!anchor2) return;
      requestAnimationFrame(() => {
        if (!this.entry.offsetParent) return;
        scrollToElement(this.entry, void 0, { scrollStyle: "none", anchor: anchor2 });
      });
    }
    setHideFilter(match) {
      this.element.classList.toggle("res-thing-filter-hide", !!match);
      if (this.isComment()) {
        this.refreshPartialVisibility();
        for (const p of this.getParents()) p.refreshPartialVisibility();
      }
    }
    setFilterReasons(elements) {
      for (const old of this.element.querySelectorAll(".res-thing-filter-remove-matching-entry")) old.remove();
      this.element.prepend(...elements);
    }
    // `throttleQueuePositionReset` ensures that children will be evaluated first
    // Class is applied when a thing is hidden by a filter, but may have descendants that are not
    refreshPartialVisibility = throttleQueuePositionReset(() => {
      this.element.classList.toggle("res-thing-partial", this.isHiddenByFilter(true) && // Comment has unloaded comments whose state is still not known
      // TODO If clicking this causes the comment to disappear, notify!
      (this.element.matches(".morerecursion, .morechildren") || // Comment has unfilter children
      Array.from(this.children).some((v) => !v.isHiddenByFilter())));
    });
    getDirectionOf(other) {
      if (!this.isVisible() || !other.isVisible()) return;
      return other.entry.compareDocumentPosition(this.entry) & Node.DOCUMENT_POSITION_FOLLOWING ? "up" : "down";
    }
    getThreadTop() {
      let thing = this;
      let current2 = this.element;
      while (current2 = current2.parentElement) {
        if (current2.matches(_Thing.thingSelector)) thing = downcast(current2, HTMLElement);
      }
      return _Thing.checkedFrom(thing);
    }
    getParents() {
      const parents = [];
      let level = this;
      while (level = level.parent) parents.push(level);
      return parents;
    }
    getNext({ direction = "down", excludeMoreChildren = false } = {}, things2 = _Thing.thingElements()) {
      let index2 = things2.indexOf(this.element);
      let target;
      do {
        index2 += direction === "down" ? 1 : -1;
        const _target = things2[index2];
        target = _target;
        if (!target) return null;
        if (excludeMoreChildren && target.matches(".morechildren")) continue;
      } while (!target.offsetParent);
      return _Thing.from(target);
    }
    getNextSibling(options6) {
      if (!this.element.parentElement) return null;
      const things2 = Array.from(this.element.parentElement.children).filter((e2) => e2.matches(_Thing.thingSelector));
      return this.getNext(options6, things2);
    }
    getClosest(func, ...args) {
      const target = Reflect.apply(func, this, args);
      if (target) {
        return target;
      } else {
        if (this.parent) return this.parent.getClosest(func, ...args);
      }
    }
    getClosestVisible(options6 = { excludeMoreChildren: true }) {
      if (this.element.offsetParent) return this;
      return this.getNext({ direction: "down", ...options6 }) || this.getNext({ direction: "up", ...options6 });
    }
    isMessage() {
      return this.element.classList.contains("message");
    }
    isSubreddit() {
      return this.element.classList.contains("subreddit");
    }
    isPost() {
      return this.element.classList.contains("link") || this.element.classList.contains("search-result-link");
    }
    isLinkPost() {
      if (!this.isPost()) {
        return false;
      }
      if (this.element.classList.contains("search-result-link")) {
        return !this.element.querySelector("a").classList.contains("self");
      } else {
        return !this.element.classList.contains("self");
      }
    }
    isSelfPost() {
      if (!this.isPost()) {
        return false;
      }
      if (this.element.classList.contains("search-result-link")) {
        return this.element.querySelector("a").classList.contains("self");
      } else {
        return this.element.classList.contains("self");
      }
    }
    isComment() {
      return this.element.classList.contains("comment") || this.element.classList.contains("was-comment");
    }
    isTopLevelComment() {
      return this.isComment() && !!this.element.parentElement && this.element.parentElement.classList.contains("nestedlisting");
    }
    getTitle() {
      const element = this.getTitleElement();
      return element && element.textContent || "";
    }
    getTitleElement() {
      return this.entry.querySelector("a.title, a.search-title") || this.entry.querySelector(".title");
    }
    getTitleUrl() {
      const element = this.getTitleElement();
      if (element) {
        return element.href;
      }
      return "";
    }
    getPostLink() {
      return downcast(this.entry.querySelector("a.title, a.search-link"), HTMLAnchorElement);
    }
    getPostUrl() {
      return this.element.dataset.url || this.getPostLink().href;
    }
    getTextBody() {
      return this.entry.querySelector(".md");
    }
    getCommentsLink() {
      const a2 = this.entry.querySelector("a.comments, a.search-comments");
      return a2 instanceof HTMLAnchorElement ? a2 : void 0;
    }
    getCommentPermalink() {
      return this.entry.querySelector("a.bylink");
    }
    getHideElement() {
      return this.entry.querySelector(".hide-button a, .unhide-button a");
    }
    getButtons() {
      return this.entry.querySelector(".flat-list.buttons");
    }
    getNumberOfChildren() {
      const numChildrenElem = this.entry.querySelector(".numchildren");
      const match = numChildrenElem && /(\d+)/.exec(numChildrenElem.textContent);
      return match && parseInt(match[1], 10) || 0;
    }
    static _parseScore(scoreEle) {
      return parseInt(scoreEle.title || scoreEle.textContent, 10) || 0;
    }
    getScore() {
      if (!isNaN(this.element.dataset.score)) {
        return parseInt(this.element.dataset.score, 10);
      }
      const element = this._getActiveScoreElement();
      return element && _Thing._parseScore(element);
    }
    _getActiveScoreElement() {
      if (this.isPost()) {
        return this.element.querySelector([
          ".midcol.unvoted > .score.unvoted",
          ".midcol.likes > .score.likes",
          ".midcol.dislikes > .score.dislikes",
          ".search-score"
        ].join(", "));
      } else {
        return this.entry.querySelector(".tagline > .score");
      }
    }
    getAllScoreElements() {
      const toScoreTuple = (ele) => [ele, _Thing._parseScore(ele)];
      if (this.isPost()) {
        return Array.from(this.element.querySelectorAll(".midcol > .score, .search-score")).map(toScoreTuple);
      } else {
        return Array.from(this.entry.querySelectorAll(".tagline > .score")).map(toScoreTuple);
      }
    }
    getAuthor() {
      const data2 = this.element.getAttribute("data-author");
      if (data2) {
        return data2;
      }
      const element = this.getAuthorElement();
      if (element) {
        const match = regexes.profile.exec(element.pathname);
        if (match) {
          return match[1];
        }
      }
    }
    getAuthorUrl() {
      const author = this.getAuthor();
      if (author) {
        return `/user/${author}/`;
      }
      return "";
    }
    getAuthorElement() {
      return this.entry.querySelector(".tagline a.author, .search-author .author");
    }
    getSubreddit() {
      const data2 = this.element.getAttribute("data-subreddit");
      if (data2) {
        return data2;
      }
      const element = this.getSubredditLink();
      if (element) {
        const match = regexes.subreddit.exec(element.pathname);
        if (match) {
          return match[1];
        }
      } else {
        return currentSubreddit();
      }
    }
    getSubredditLink() {
      if (this.isPost()) {
        return this.entry.querySelector(".tagline a.subreddit, a.search-subreddit-link");
      } else if (this.isComment()) {
        return this.entry.querySelector(".parent a.subreddit, .tagline .subreddit a");
      }
    }
    getPostDomain() {
      const data2 = this.element.getAttribute("data-domain");
      if (data2) {
        return data2;
      }
      const element = this.getPostDomainLink();
      if (element) {
        return element.textContent;
      }
      const text = this.getPostDomainText();
      if (text) {
        return text;
      }
      const subreddit2 = this.getSubreddit();
      if (subreddit2) {
        return `self.${subreddit2}`;
      }
      return "reddit.com";
    }
    getPostDomainUrl() {
      const link = this.getPostDomainLink();
      if (link) {
        return link.href;
      }
      return `/domain/${this.getPostDomain()}/`;
    }
    getPostDomainLink() {
      return this.entry.querySelector(".domain a");
    }
    getPostDomainText() {
      const data2 = this.element.getAttribute("data-domain");
      if (data2) {
        return data2;
      }
      const element = this.element.querySelector(".domain");
      if (!element) return "";
      const text = element.textContent || "";
      return text.replace(/[\(\)\s]/g, "");
    }
    getCommentCount() {
      const element = this.getCommentCountElement();
      if (!element) return;
      return parseInt(/\d+/.exec(
        element.getAttribute("data-text") || // In case noCtrlF is applied
        element.textContent
      ), 10) || 0;
    }
    getCommentCountElement() {
      if (this.isPost()) {
        return this.entry.querySelector(".buttons .comments");
      } else if (this.isComment()) {
        return this.entry.querySelector(".buttons a.full-comments");
      }
    }
    getPostThumbnailUrl() {
      const thumbnail = this.getPostThumbnailElement();
      if (!thumbnail) return "";
      return thumbnail.src || "";
    }
    getPostThumbnailElement() {
      return this.element.querySelector(".thumbnail img");
    }
    getPostFlairText() {
      const element = this.getPostFlairElement();
      return element && element.textContent || "";
    }
    getPostFlairElement() {
      return this.entry.querySelector(".title > .linkflairlabel");
    }
    getUserFlairText() {
      const element = this.getUserFlairElement();
      return element && element.textContent || "";
    }
    getUserFlairElement() {
      return this.entry.querySelector(".tagline > .flair");
    }
    getCrosspostBadgeElement() {
      return this.entry.querySelector(".crosspost-badge");
    }
    getUpvoteButton() {
      return this._getVoteButton("div.up, div.upmod");
    }
    getDownvoteButton() {
      return this._getVoteButton("div.down, div.downmod");
    }
    _getVoteButton(selector) {
      const previousSibling = this.entry.previousSibling;
      if (previousSibling.tagName === "A") {
        return previousSibling.previousSibling.querySelector(selector);
      } else {
        return previousSibling.querySelector(selector);
      }
    }
    getTimestamp() {
      const element = this.getTimestampElement();
      return element && new Date(element.getAttribute("datetime"));
    }
    getTimestampElement() {
      return this.entry.querySelector("time");
    }
    getPostEditTimestamp() {
      const element = this.getPostEditTimestampElement();
      return element && Date.parse(element.getAttribute("datetime")) / 1e3 || 0;
    }
    getPostEditTimestampElement() {
      return this.entry.querySelector("time.edited-timestamp");
    }
    getFullname() {
      return this.element.getAttribute("data-fullname") || "";
    }
    getUserattrsElement() {
      return this.entry.querySelector(".userattrs");
    }
    getRank() {
      const rank = parseInt(this.element.getAttribute("data-rank"), 10);
      if (!isNaN(rank)) return rank;
    }
    getRankElement() {
      if (!this.isPost()) return;
      return this.element.querySelector(".rank");
    }
    getTaglineElement() {
      return this.entry.querySelector(".tagline");
    }
    getCommentCollapseToggleElement() {
      return this.entry.querySelector(".expand");
    }
    setCommentCollapse(state, reason, openOnlyWhenSameReason = false) {
      const toggle7 = this.getCommentCollapseToggleElement();
      if (!toggle7) return;
      if (state) toggle7.setAttribute("collapse-reason", reason);
      if (this.isCollapsed() === state) return;
      if (!state && openOnlyWhenSameReason && toggle7.getAttribute("collapse-reason") !== reason) return;
      if (!state) toggle7.removeAttribute("collapse-reason");
      click(toggle7);
    }
    getPostTime() {
      const element = this.getPostTimeElement();
      if (element) {
        return element.textContent;
      }
      return "";
    }
    getPostTimeElement() {
      return this.entry.querySelector(".tagline time");
    }
    isNSFW() {
      return this.element.classList.contains("over18") || !!this.entry.querySelector(".nsfw-stamp");
    }
    isSpoiler() {
      if (this.element.classList.contains("search-result")) {
        return !!this.entry.querySelector(".spoiler-stamp");
      }
      return this.element.classList.contains("spoiler");
    }
    isCrosspost() {
      return !!this.getCrosspostBadgeElement();
    }
    isLocked() {
      if (this.element.classList.contains("search-result")) {
        return this.element.classList.contains("linkflair-locked");
      }
      return this.element.classList.contains("locked");
    }
    isDeleted() {
      return this.element.classList.contains("deleted");
    }
    isHiddenByFilter(partialAsFiltered = false) {
      if (this.element.matches("body.hideOver18 .over18:not(.allowOver18)")) return true;
      if (!this.element.classList.contains("res-thing-filter-hide")) return false;
      if (this.element.classList.contains("res-filterline-highlight-match")) return false;
      if (partialAsFiltered) {
        if (this.element.classList.contains("res-thing-partial") && this.element.classList.contains("res-selected")) return false;
        return true;
      } else {
        if (this.element.classList.contains("res-thing-hide-children")) return true;
        return !this.element.classList.contains("res-thing-partial");
      }
    }
    isCollapsed() {
      return this.element.classList.contains("collapsed");
    }
    // Should be equivalent to `this.element.offsetParent !== null`
    isVisible() {
      if (this.element.classList.contains("promoted")) return false;
      if (!document.body.classList.contains("res-filters-disabled") && this.isHiddenByFilter()) return false;
      const { parent: parent2 } = this;
      if (parent2) {
        if (parent2.isCollapsed()) return false;
        if (parent2.element.classList.contains("res-children-hidden")) return false;
        if (!parent2.isVisible()) return false;
      }
      return true;
    }
    isContentVisible() {
      return !(this.element.classList.contains("res-thing-has-placeholder") || !document.body.classList.contains("res-filters-disabled") && this.isHiddenByFilter(true) || this.isCollapsed() || !this.isVisible());
    }
    isSelected() {
      return this.element.classList.contains("res-selected");
    }
    isUpvoted() {
      return this.entry.classList.contains("likes");
    }
    isDownvoted() {
      return this.entry.classList.contains("dislikes");
    }
    isUnvoted() {
      return this.entry.classList.contains("unvoted");
    }
  };
  if (false) {
    window.getThingIsVisibleInconsistencies = () => Array.from(things).filter((v) => v.isVisible() === !v.element.offsetParent);
  }

  // lib/utils/pagePhases.js
  var pagePhases_exports = {};
  __export(pagePhases_exports, {
    bodyStart: () => bodyStart,
    contentLoaded: () => contentLoaded,
    contentStart: () => contentStart,
    loadComplete: () => loadComplete
  });
  var bodyStart = waitForChild(document.documentElement, "body").then(() => waitFor(() => document.body, 10));
  var contentStart = bodyStart.then(() => Promise.race([
    bodyStart.then(() => waitForDescendant(document.body, "#siteTable")),
    contentLoaded
  ]));
  var contentLoaded = bodyStart.then(() => Promise.race([
    waitForEvent(window, "DOMContentLoaded", "load"),
    waitFor(() => document.readyState === "interactive" || document.readyState === "complete", 500)
  ]));
  var loadComplete = bodyStart.then(() => Promise.race([
    waitForEvent(window, "load"),
    waitFor(() => document.readyState === "complete", 500)
  ]));

  // lib/utils/watchers.js
  var elementWatchers = {
    page: [],
    selfText: []
  };
  var thingWatchers = {
    comment: [],
    message: [],
    post: [],
    subreddit: []
  };
  var runCallback = (fn) => {
    try {
      return fn();
    } catch (e2) {
      console.error(e2);
    }
  };
  var addCallback = (callback, actingOnElement, { immediate, id: id2 } = {}) => {
    const thing = Thing.from(actingOnElement);
    if (thing) {
      const task = once_default(() => runCallback(callback));
      if (id2) thing.tasks.byId.set(id2, task);
      (immediate ? thing.tasks.immediate : thing.tasks.visible).push(task);
      if (immediate || thing.tasks.completed) task();
    } else {
      runCallback(callback);
    }
  };
  function registerElement(type, element) {
    for (const { selector, callback, options: options6, registered } of elementWatchers[type]) {
      const elements = selector && !element.matches(selector) ? Array.from(element.querySelectorAll(selector)) : [element];
      for (const e2 of elements) {
        if (registered.has(e2)) continue;
        registered.add(e2);
        addCallback(() => callback(e2), e2, options6);
      }
    }
  }
  var dupeSet = /* @__PURE__ */ new Map();
  function registerThing(element) {
    const thing = Thing.checkedFrom(element);
    const id2 = thing.getFullname();
    if (id2.length === 9) {
      const existing = dupeSet.get(id2);
      if (existing === element) return;
      if (existing && document.contains(existing)) {
        element.remove();
        return;
      }
      dupeSet.set(id2, element);
    }
    const thingWatcherCallbacks = thing.isPost() && thingWatchers.post || thing.isComment() && thingWatchers.comment || thing.isMessage() && thingWatchers.message || thing.isSubreddit() && thingWatchers.subreddit || [];
    for (const { callback, options: options6, registered } of thingWatcherCallbacks) {
      if (registered.has(thing)) continue;
      registered.add(thing);
      addCallback(() => callback(thing), thing.element, options6);
    }
  }
  function watchForThings(types2, callback, options6) {
    if (!types2) types2 = Object.keys(thingWatchers);
    const entry = { callback, options: options6, registered: /* @__PURE__ */ new WeakSet() };
    for (const type of types2) thingWatchers[type].push(entry);
  }
  function watchForElements(types2, selector, callback, options6) {
    const entry = { selector, callback, options: options6, registered: /* @__PURE__ */ new WeakSet() };
    for (const type of types2) elementWatchers[type].push(entry);
  }
  function registerPage(page) {
    if (page.matches(Thing.thingSelector)) registerThing(page);
    for (const ele of page.querySelectorAll(Thing.thingSelector)) registerThing(ele);
    registerElement("page", page);
  }
  var HIDE_FOLLOWING_CLASS = "res-hide-following";
  var cleanHideClasses = () => {
    for (const ele of [...document.getElementsByClassName(HIDE_FOLLOWING_CLASS)]) ele.classList.remove(HIDE_FOLLOWING_CLASS);
  };
  async function r2WatcherContentStart() {
    const initialProcessSize = Math.ceil(
      screen.availHeight / window.devicePixelRatio / 55
      /* approx min height of a thing */
    );
    const container2 = document.body.querySelector('.content[role="main"]');
    watchForThings(["post"], async (thing) => {
      const container3 = thing.entry.querySelector("div.expando");
      if (!container3) return;
      let body = thing.getTextBody();
      if (!body || container3.matches(".thing.spoiler .expando")) {
        await waitForSelectorMatch(container3, ":not(.expando--with-interstitial, .expando-uninitialized)");
      }
      watchForChildren(container3, "form", () => {
        body = thing.getTextBody();
        if (body) registerElement("selfText", body);
      });
    }, { immediate: true });
    watchForThings(null, (() => {
      let max = initialProcessSize;
      const queue = [];
      let i2 = 0;
      contentLoaded.then(() => {
        setInterval(() => {
          queue.length = 0;
          i2 = 0;
        }, 0.5 * MINUTE);
      });
      return (thing) => {
        const n = i2++;
        const check2 = queue[n] = async () => {
          delete queue[n];
          const filterTask = thing.tasks.byId.get("filter");
          if (filterTask instanceof Promise) await filterTask();
          if (thing.tasks.completed || thing.isVisible()) {
            thing.runTasks();
          } else if (n < max) {
            max++;
            const nextCheck = queue.find(Boolean);
            if (nextCheck) nextCheck();
          }
        };
        if (n < max) check2();
      };
    })(), { immediate: true });
    const io = new IntersectionObserver((entries) => {
      for (const { target, isIntersecting } of entries) {
        if (isIntersecting) {
          io.unobserve(target);
          Thing.checkedFrom(target).runTasks();
        }
      }
    }, { rootMargin: "100%", delay: 200 });
    watchForThings(null, async (thing) => {
      if (thing.tasks.completed) return;
      if (!container2.contains(thing.element)) await waitForAttach(container2, thing.element);
      io.observe(thing.entry);
    }, { immediate: true });
    const getReadyThingElements = () => {
      Thing.thingElements.cache.clear();
      const thingElements = Thing.thingElements(container2);
      let _last = thingElements.slice(-1)[0];
      if (_last) {
        if (isLastNodeInDOM(_last)) {
          thingElements.pop();
          if (thingElements.length) {
            _last = thingElements.slice(-1)[0];
          } else {
            while (!_last.previousElementSibling) {
              _last = _last.parentElement;
            }
            _last = _last.previousElementSibling;
          }
        }
        cleanHideClasses();
        do {
          _last.classList.add(HIDE_FOLLOWING_CLASS);
        } while ((_last = _last.parentElement) && _last !== container2);
      }
      return thingElements;
    };
    while (true) {
      const thingElements = getReadyThingElements();
      for (const e2 of thingElements) registerThing(e2);
      if (thingElements.length >= initialProcessSize) return;
      try {
        await Promise.race([
          // eslint-disable-line no-await-in-loop
          contentLoaded.then(() => Promise.reject()),
          // eslint-disable-line prefer-promise-reject-errors
          Promise.all([
            // Give the browser some time to load additional posts into the DOM before continuing if we've already processed some
            thingElements.length ? new Promise((res) => {
              setTimeout(res, 100);
            }) : Promise.resolve(),
            waitForDescendantChange(container2, Thing.thingSelector)
          ])
        ]);
      } catch (e2) {
        break;
      }
    }
  }
  function r2WatcherContentLoaded() {
    cleanHideClasses();
    if (isPageType("comments")) {
      const commentarea = document.body.querySelector(".commentarea");
      if (commentarea) watchForFutureDescendants(commentarea, ".thing", registerPage, true);
    } else {
      const watchList = memoize_default((ele) => {
        if (ele) watchForFutureChildren(ele, ".thing", registerPage);
      });
      watchForThings(null, (thing) => {
        watchList(thing.element.parentElement);
      });
    }
    registerPage(document.body);
  }

  // lib/utils/dom.js
  function waitForEvent(ele, ...events) {
    return Promise.race(events.map(
      (event) => new Promise((resolve) => {
        ele.addEventListener(event, function fire(e2) {
          ele.removeEventListener(event, fire);
          resolve(e2);
        });
      })
    ));
  }
  function waitForChild(ele, selector) {
    return new Promise((resolve) => {
      const child = Array.from(ele.children).find((child2) => child2.matches(selector));
      if (child) {
        resolve(child);
        return;
      }
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          for (const node of mutation.addedNodes) {
            if (node.nodeType === Node.ELEMENT_NODE && node.matches(selector)) {
              observer.disconnect();
              resolve(downcast(node, HTMLElement));
              return;
            }
          }
        }
      });
      observer.observe(ele, { childList: true });
    });
  }
  function watchForChildren(ele, selector, callback) {
    for (const child of Array.from(ele.children).filter((child2) => child2.matches(selector))) {
      callback(child);
    }
    watchForFutureChildren(ele, selector, callback);
  }
  function watchForFutureChildren(ele, selector, callback) {
    new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE && node.matches(selector)) {
            callback(downcast(node, HTMLElement));
          }
        }
      }
    }).observe(ele, { childList: true });
  }
  function waitForDescendant(ele, selector) {
    return new Promise((resolve) => {
      const child = ele.querySelector(selector);
      if (child) {
        resolve(child);
        return;
      }
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          for (const node of mutation.addedNodes) {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const child2 = ele.querySelector(selector);
              if (child2) {
                observer.disconnect();
                resolve(child2);
              }
              return;
            }
          }
        }
      });
      observer.observe(ele, { childList: true, subtree: true });
    });
  }
  function waitForDescendantChange(ele, selector) {
    return new Promise((resolve) => {
      const found = () => {
        observer.disconnect();
        resolve();
      };
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.target.matches(selector)) return found();
          for (const node of mutation.addedNodes) {
            if (node.nodeType === Node.ELEMENT_NODE && node.querySelector(selector)) return found();
          }
          for (const node of mutation.removedNodes) {
            if (node.nodeType === Node.ELEMENT_NODE && node.querySelector(selector)) return found();
          }
        }
      });
      observer.observe(ele, { childList: true, subtree: true });
    });
  }
  function waitForAttach(parent2, el, cancel) {
    if (parent2.contains(el)) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const observer = new MutationObserver(() => {
        if (parent2.contains(el)) {
          resolve();
          observer.disconnect();
        }
      });
      observer.observe(parent2, { subtree: true, childList: true });
      if (cancel) cancel.then(() => {
        observer.disconnect();
        reject(new Error("Canceled"));
      });
    });
  }
  function waitForDetach(el, cancel) {
    const parent2 = document.documentElement;
    if (!parent2.contains(el)) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const observer = new MutationObserver(() => {
        if (!parent2.contains(el)) {
          resolve();
          observer.disconnect();
        }
      });
      observer.observe(parent2, { subtree: true, childList: true });
      if (cancel) cancel.then(() => {
        observer.disconnect();
        reject(new Error("Canceled"));
      });
    });
  }
  function watchForDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches = false) {
    for (const child of ele.querySelectorAll(selector)) {
      callback(child);
    }
    watchForFutureDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches);
  }
  function watchForFutureDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches = false) {
    new MutationObserver((mutations) => {
      const children = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.matches(selector)) {
              children.add(node);
              if (ignoreChildrenIfAddedNodeMatches) continue;
            }
            for (const child of node.querySelectorAll(selector)) {
              children.add(child);
            }
          }
        }
      }
      for (const child of children) {
        callback(downcast(child, HTMLElement));
      }
    }).observe(ele, { childList: true, subtree: true });
  }
  function waitForSelectorMatch(ele, selector) {
    if (ele.matches(selector)) return Promise.resolve();
    return new Promise((resolve) => {
      const observer = new MutationObserver(() => {
        if (ele.matches(selector)) {
          resolve();
          observer.disconnect();
        }
      });
      observer.observe(ele, { attributes: true });
    });
  }
  function empty(parent2) {
    while (parent2.lastChild) parent2.removeChild(parent2.lastChild);
    return parent2;
  }
  function click(obj, button = 0) {
    obj.dispatchEvent(new MouseEvent("click", {
      bubbles: true,
      cancelable: true,
      detail: 0,
      screenX: 1,
      screenY: 1,
      clientX: 1,
      clientY: 1,
      button
    }));
  }
  click.isProgrammaticEvent = (e2) => e2.clientX === 1 && e2.clientY === 1;
  var getViewportSize = memoize_default(() => {
    waitForEvent(window, "resize").then(() => {
      getViewportSize.cache.clear();
    });
    let visualViewport;
    if (window.visualViewport) {
      visualViewport = window.visualViewport;
    } else {
      const viewportSizedElement = document.createElement("div");
      viewportSizedElement.style.width = viewportSizedElement.style.height = "100%";
      viewportSizedElement.style.position = "fixed";
      document.body.appendChild(viewportSizedElement);
      visualViewport = viewportSizedElement.getBoundingClientRect();
      if (!visualViewport.height || !visualViewport.width) {
        visualViewport = document.documentElement.getBoundingClientRect();
      }
      viewportSizedElement.remove();
    }
    return pick_default(visualViewport, ["height", "width"]);
  });
  function elementInViewport(ele) {
    if (!ele || !ele.offsetParent) return false;
    const { top, left, bottom, right } = ele.getBoundingClientRect();
    return top >= 0 && left >= 0 && bottom <= getViewportSize().height && right <= getViewportSize().width;
  }
  function getViewportDimensions() {
    const headerOffset = getHeaderOffset();
    const left = window.pageXOffset;
    const top = window.pageYOffset + headerOffset;
    const width = getViewportSize().width;
    const height = getViewportSize().height - headerOffset;
    return {
      yOffset: headerOffset,
      left,
      top,
      bottom: top + height,
      right: left + width,
      width,
      height
    };
  }
  function getPercentageVisibleYAxis(obj) {
    const rect = obj.getBoundingClientRect();
    const top = Math.max(0, rect.bottom - rect.height);
    const bottom = Math.min(getViewportSize().height, rect.bottom);
    if (rect.height === 0) {
      return 0;
    }
    return Math.max(0, (bottom - top) / rect.height);
  }
  var padBottom = once_default(() => {
    const element = document.createElement("div");
    element.style.clear = "both";
    const extraPadding = 50;
    return (scrollTop, viewportHeight) => {
      const currentPadding = element.clientHeight;
      const paddingRequired = extraPadding + -(document.documentElement.scrollHeight - scrollTop - viewportHeight - currentPadding);
      if (paddingRequired > 0) document.body.append(element);
      else element.remove();
      element.style.height = `${paddingRequired}px`;
    };
  });
  var recentScroll = false;
  var scrollInvokationToken;
  function scrollToElement(to, from, {
    scrollStyle,
    restrictDirectionTo,
    direction: selectedDirection,
    anchor: anchor2,
    waitTillVisible
  }) {
    const _scrollInvokationToken = scrollInvokationToken = {};
    if (scrollStyle === "none" && !anchor2) {
      return;
    }
    if (waitTillVisible && !to.offsetParent) {
      requestAnimationFrame(() => {
        if (scrollInvokationToken === _scrollInvokationToken) scrollToElement(...arguments);
      });
      return;
    }
    if (!to.offsetParent) {
      console.error("Element is not visible.");
      return;
    }
    if (scrollStyle === "none" && anchor2) {
      const diff = to.getBoundingClientRect().top - anchor2.to;
      if (diff) window.scrollBy(0, diff);
    }
    const viewport = getViewportDimensions();
    const target = assignIn_default({}, to.getBoundingClientRect());
    target.top -= viewport.yOffset;
    target.bottom -= viewport.yOffset;
    const top = viewport.top + target.top - 5;
    if (scrollStyle === "middle" && target.height >= viewport.height) {
      scrollStyle = "top";
    }
    let compensateHeader = true;
    let scrollY;
    if (scrollStyle === "top") {
      padBottom()(top, viewport.height);
      scrollY = top;
    } else if (from && scrollStyle === "adopt") {
      const fromTop = anchor2 && typeof anchor2.from === "number" ? anchor2.from : from.getBoundingClientRect().top;
      let diff = to.getBoundingClientRect().top - fromTop;
      if (fromTop < 0) {
        diff += fromTop;
      } else if (fromTop > viewport.height - 60) {
        diff += fromTop - viewport.height + 60;
      }
      scrollY = window.scrollY + diff;
      compensateHeader = false;
    } else if (scrollStyle === "middle") {
      const buffer = (viewport.height - target.height) / 2;
      const newScrollY = top - buffer;
      if (elementInViewport(to)) {
        const viewportDirection = newScrollY >= window.scrollY ? "down" : "up";
        if (viewportDirection !== selectedDirection) return;
      }
      scrollY = newScrollY;
    } else if (target.top >= 0 && target.bottom <= viewport.height) {
    } else if (scrollStyle === "legacy") {
      scrollY = top;
    } else if (target.top < viewport.yOffset) {
      scrollY = top;
    } else if (viewport.height < target.bottom && target.height < viewport.height) {
      if (scrollStyle === "page") {
        scrollY = top;
      } else {
        scrollY = viewport.top + target.bottom - viewport.height;
      }
    } else {
      scrollY = top;
    }
    if (scrollY !== void 0) {
      if (compensateHeader) scrollY -= getHeaderOffset();
      const scollDirection = scrollY > viewport.top ? "down" : "up";
      if (viewport.top === scrollY || restrictDirectionTo && restrictDirectionTo !== scollDirection) return;
      window.scrollTo(0, scrollY);
      recentScroll = true;
      waitForEvent(window, "scroll").then(() => {
        recentScroll = false;
      });
    }
  }
  scrollToElement.isProgrammaticEvent = () => recentScroll;
  var headerIds = { fullWidth: [], partialWidth: [] };
  function _addHeaderId(elementId, partialWidth = false) {
    headerIds[partialWidth ? "partialWidth" : "fullWidth"].push(elementId);
  }
  var getHeaderOffset = memoize_default((includePartialWidthHeaders = false) => {
    const headers = [
      ...headerIds.fullWidth,
      ...includePartialWidthHeaders ? headerIds.partialWidth : []
    ];
    return headers.map((id2) => document.getElementById(id2)).reduce((a2, b2) => a2 + b2.getBoundingClientRect().height, 0);
  });
  var getD2xBodyOffset = memoize_default(() => {
    try {
      return document.getElementById("2x-container").offsetTop;
    } catch (e2) {
      return 65;
    }
  });
  function addCSS(css3) {
    let style = addStyle(css3);
    return {
      remove() {
        if (!style) return;
        style.remove();
        style.textContent = "";
        style = void 0;
      }
    };
  }
  function addStyle(css3) {
    const style = document.createElement("style");
    style.textContent = css3;
    (document.head || document.documentElement).appendChild(style);
    return style;
  }
  var isLastNodeInDOM = (node) => {
    let _last = node;
    do {
      if (_last.nextSibling) break;
    } while (_last = _last.parentNode);
    return !_last;
  };
  var preventCloning = (() => {
    if (typeof window === "undefined") return (e2) => e2;
    const attribute = `res-prevent-cloning-${Date.now()}`;
    const elements = /* @__PURE__ */ new WeakSet();
    waitForEvent(window, "DOMContentLoaded", "load").then(() => {
      watchForThings(null, (thing) => {
        for (const ele of [...thing.entry.querySelectorAll(`[${attribute}]`)]) {
          if (!elements.has(ele)) ele.remove();
        }
      }, { immediate: true });
    });
    return (element) => {
      element.setAttribute(attribute, "");
      elements.add(element);
      return element;
    };
  })();

  // lib/utils/currentLocation.js
  function matchesPageLocation(includes, excludes = []) {
    const [includeStrings, includeRegExps] = partition_default(includes, (x) => typeof x === "string");
    const [excludeStrings, excludeRegExps] = partition_default(excludes, (x) => typeof x === "string");
    return (!excludes.length || !(isPageType(...excludeStrings) || isAppType(...excludeStrings) || matchesPageRegex(...excludeRegExps))) && (!includes.length || (isPageType(...includeStrings) || isAppType(...includeStrings) || matchesPageRegex(...includeRegExps)));
  }
  var appType = once_default(() => {
    if (document.documentElement.hasAttribute("res-options")) {
      return "options";
    }
    if (document.documentElement.getAttribute("xmlns")) {
      return "r2";
    }
    return "d2x";
  });
  function isAppType(...types2) {
    const thisApp = appType();
    return types2.some((type) => type === thisApp);
  }
  var pageType = memoize_default(() => {
    waitForEvent(document, "reddit.urlChanged").then(() => {
      pageType.cache.clear();
    });
    const spec = appPageTypes[appType()];
    return spec.pageTypes.find((pageType2) => regexes[pageType2].test(location.pathname)) || spec.default;
  });
  function matchesPageRegex(...regexps) {
    return regexps.some((regex) => regex.test(location.pathname));
  }
  var currentSubreddit = once_default(() => {
    const match = location.pathname.match(regexes.subreddit);
    if (match) return match[1];
  });
  function isCurrentSubreddit(...subreddits2) {
    const sub = (currentSubreddit() || "").toLowerCase();
    if (!sub) return false;
    return subreddits2.some((v) => v.toLowerCase() === sub);
  }
  var currentMultireddit = once_default(() => {
    const match = location.pathname.match(regexes.multireddit);
    if (match) return match[1];
  });
  function isCurrentMultireddit(...multireddits) {
    const multi = (currentMultireddit() || "").toLowerCase();
    if (!multi) return false;
    return multireddits.some((v) => v.toLowerCase() === multi);
  }
  var currentDomain = once_default(() => {
    const match = location.pathname.match(regexes.domain);
    if (match) return match[1];
  });
  var currentUserProfile = once_default(() => {
    const match = location.pathname.match(regexes.profile);
    if (match) return match[1];
  });
  function isPageType(...types2) {
    const thisPage = pageType();
    return types2.some((type) => type === thisPage);
  }
  var inQuarantinedSubreddit = once_default(() => document.body.classList.contains("quarantine"));

  // lib/utils/string.js
  var string_exports = {};
  __export(string_exports, {
    _html: () => _html,
    areSimilar: () => areSimilar,
    encode: () => encode,
    escape: () => escape,
    html: () => html,
    regexRegex: () => regexRegex,
    safe: () => safe
  });
  var import_fast_levenshtein = __toESM(require_levenshtein(), 1);

  // lib/utils/html.js
  var escapeLookups = {
    "&": "&amp;",
    '"': "&quot;",
    "'": "&apos;",
    // eslint-disable-line quotes
    "<": "&lt;",
    ">": "&gt;",
    "/": "&#47;"
  };
  function escapeHTML(str) {
    return str ? str.toString().replace(/[&"'<>\/]/g, (m) => escapeLookups[m]) : "";
  }

  // lib/utils/string.js
  function stringTagFunction(valueTransform) {
    return (strings, ...values) => zipWith_default(
      strings,
      values.map(valueTransform),
      (s, v) => `${s}${v === void 0 ? "" : v}`
    ).join("");
  }
  var encode = stringTagFunction(encodeURIComponent);
  var escape = stringTagFunction(escapeHTML);
  function safe(str) {
    return { __safe__: str };
  }
  var MAX_DISTANCE_RATIO = 0.05;
  function areSimilar(a2, b2) {
    return import_fast_levenshtein.default.get(a2, b2) <= MAX_DISTANCE_RATIO * Math.max(a2.length, b2.length);
  }
  var regexRegex = /^\/(.*)\/([sgimu]+)?$/;
  var htmlTagFunction = stringTagFunction((x) => {
    if (typeof x === "number") return String(x);
    if (!x) return "";
    if (typeof x === "string") return escapeHTML(x);
    if (Array.isArray(x)) return x.filter((s) => s && typeof s.__safe__ === "string").map((s) => s.__safe__).join("");
    if (x.hasOwnProperty("__safe__")) return x.__safe__;
    throw new TypeError(`Invalid html template interpolation: ${String(x)}`);
  });
  var html = (s, ...values) => {
    const markup = htmlTagFunction(s, ...values);
    const template = document.createElement("div");
    template.innerHTML = markup;
    if (template.childElementCount !== 1) {
      throw new Error(`Html template should have exactly one root node, but had ${template.childElementCount}`);
    }
    const child = downcast(template.firstElementChild, HTMLElement);
    child.remove();
    return child;
  };
  var _html = (s, ...values) => safe(htmlTagFunction(s, ...values));

  // lib/utils/user.js
  var isLoggedIn = once_default(() => {
    if (loggedInUser()) {
      return true;
    } else if (document.querySelector('header a[href^="/message/inbox"]')) {
      return true;
    }
  });
  var loggedInUser = once_default(() => documentLoggedInUser(document));
  var documentLoggedInUser = (document2) => {
    if (isAppType("d2x")) {
      const findFirstTextNode = (e2) => [...e2.childNodes].filter((v) => v.nodeType === 3).concat(...[...e2.children].map(findFirstTextNode));
      const button = document2.querySelector("#USER_DROPDOWN_ID > *");
      const username = button && findFirstTextNode(button)[0];
      return username && username.textContent;
    }
    const link = document2.querySelector("#header-bottom-right > span.user > a");
    if (!link || link.classList.contains("login-required")) return;
    const profile = regexes.profile.exec(link.pathname);
    if (profile) {
      return profile[1];
    }
  };
  var isModeratorAnywhere = once_default(() => !!(document.getElementById("modmail") || document.querySelector('[href="/r/mod/"]')));
  var loggedInUserHash = once_default(async () => {
    const hashEle = document.querySelector("[name=uh]");
    if (hashEle instanceof HTMLInputElement) {
      return hashEle.value;
    }
    const userInfo = await loggedInUserInfo();
    return userInfo && userInfo.data && userInfo.data.modhash;
  });
  var loggedInUserInfo = once_default(() => !isLoggedIn() ? Promise.resolve() : ajax({ url: "/api/me.json", type: "json" }).then((data2) => data2.data && data2.data.modhash ? data2 : void 0));
  var usernameRE = /(?:u|user)\/([\w\-]{3,20}(?![\w\-]))/;
  var usernameSelector = [
    ".contents .author",
    "p.tagline a.author",
    "#friend-table span.user a",
    ".sidecontentbox .author",
    'div.md a[href^="/u/"]:not([href*="/m/"])',
    'div.md a[href*="reddit.com/u/"]:not([href*="/m/"])',
    ".usertable a.author",
    ".parent > a.author",
    ".usertable span.user a",
    "div.wiki-page-content .author",
    ".Post__authorLink"
    // Newish profile page
  ].join(", ");
  function getUsernameFromLink(element) {
    if (!(element instanceof HTMLAnchorElement)) return;
    const { href, origin } = element;
    if (!location.origin.endsWith(origin.split(".").slice(-2).join("."))) return;
    const [, username] = href.match(usernameRE) || [];
    if (username) return username;
  }
  function getUserInfo(username = loggedInUser()) {
    if (!username) {
      return Promise.reject(new Error("getUserInfo: null/undefined username"));
    }
    return ajax({
      url: encode`/user/${username}/about.json`,
      type: "json",
      cacheFor: 10 * MINUTE
    });
  }

  // lib/environment/foreground/context.js
  var data = {
    userHash: null,
    username: null,
    origin: "https://www.reddit.com",
    pathname: location.pathname
  };
  if (location.protocol.startsWith("http")) {
    data.origin = location.origin;
    contentStart.then(() => {
      data.username = loggedInUser();
      loggedInUserHash().then((hash) => {
        data.userHash = hash;
      });
    });
  }

  // lib/environment/utils/messaging.js
  var MessageHandlerError = class extends Error {
    constructor(message, stack) {
      super();
      this.message = message;
      this.stack = stack;
    }
  };
  function createMessageHandler(_sendMessage2, errorOnUnrecognizedTypes = false) {
    const listeners2 = /* @__PURE__ */ new Map();
    function addListener3(type, callback) {
      if (listeners2.has(type)) {
        throw new Error(`Listener for "${type}" already exists.`);
      }
      listeners2.set(type, callback);
    }
    async function sendMessage3(type, data2, context) {
      const { data: newData, error } = await _sendMessage2({ type, data: data2 }, context);
      if (error) {
        throw new MessageHandlerError(error.message, `${error.stack}
    at target's "${type}" handler`);
      } else {
        return newData;
      }
    }
    function _handleMessage2({ type, data: data2 }, sendResponse, context) {
      const listener2 = listeners2.get(type);
      if (!listener2) {
        if (errorOnUnrecognizedTypes) {
          sendResponse({ error: { message: `Unrecognised message type: ${type}`, stack: "" } });
        }
        return false;
      }
      let response;
      try {
        response = listener2(data2, context);
      } catch (e2) {
        console.error(e2);
        sendResponse({ error: { message: e2.message, stack: e2.stack } });
        return false;
      }
      if (response instanceof Promise) {
        response.then(
          (data3) => sendResponse({ data: data3 }),
          (e2) => {
            console.error(e2);
            sendResponse({ error: { message: e2.message, stack: e2.stack } });
          }
        );
        return true;
      } else {
        sendResponse({ data: response });
        return false;
      }
    }
    return {
      _handleMessage: _handleMessage2,
      sendMessage: sendMessage3,
      addListener: addListener3
    };
  }

  // lib/environment/utils/api.js
  function apiToPromise(func) {
    return (...args) => new Promise((resolve, reject) => {
      func(...args, (...results) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(results.length > 1 ? results : results[0]);
        }
      });
    });
  }

  // lib/environment/foreground/messaging.js
  var _sendMessage = apiToPromise(chrome.runtime.sendMessage);
  var {
    _handleMessage,
    sendMessage,
    addListener
  } = createMessageHandler((obj) => _sendMessage(obj));
  chrome.runtime.onMessage.addListener((obj, sender, sendResponse) => _handleMessage(obj, sendResponse));

  // lib/environment/foreground/privateBrowsing.js
  function isPrivateBrowsing() {
    return chrome.extension.inIncognitoContext;
  }

  // lib/environment/foreground/history.js
  async function addURLToHistory(url) {
    if (isPrivateBrowsing()) return;
    await sendMessage("addURLToHistory", url);
  }
  function isURLVisited(url) {
    return sendMessage("isURLVisited", url);
  }

  // lib/environment/foreground/xhrCache.js
  var xhrCache_exports = {};
  __export(xhrCache_exports, {
    check: () => check,
    clear: () => clear,
    delete: () => delete_,
    set: () => set
  });
  function set(key, value) {
    return sendMessage("XHRCache", ["set", key, value]);
  }
  function check(key, maxAge) {
    return sendMessage("XHRCache", ["check", key, maxAge]);
  }
  function delete_(key) {
    return sendMessage("XHRCache", ["delete", key]);
  }
  function clear() {
    return sendMessage("XHRCache", ["clear"]);
  }

  // lib/environment/foreground/ajax.js
  var FetchError = class extends Error {
    status;
    constructor(url, status) {
      super(`${url} failed with status ${status}`);
      this.status = status;
    }
  };
  async function ajax(options6) {
    const { method, url, headers, data: data2, type, cacheFor, sameOrigin, credentials } = buildRequestParams(options6);
    if (cacheFor) {
      const cached = await check(url, cacheFor);
      if (cached) {
        return processResponse(cached, type);
      }
    }
    const response = await (sameOrigin ? fetch(url, {
      method,
      headers,
      credentials,
      body: data2
    }).then(async (r) => ({
      ok: r.ok,
      status: r.status,
      headers: fromPairs_default(Array.from(r.headers.entries())),
      text: await r.text()
    })) : sendMessage("ajax", { method, url, headers, data: data2, credentials }));
    if (!response.ok) {
      throw new FetchError(url, response.status);
    }
    if (cacheFor) {
      set(url, response);
    }
    return processResponse(response, type);
  }
  ajax.invalidate = (options6) => delete_(buildRequestParams(options6).url);
  function buildRequestParams({ method = "GET", url, query = {}, headers = {}, data: data2, type = "text", credentials, cacheFor = 0 }) {
    const siteOrigin = new URL(data.origin);
    const requestURL = new URL(url, siteOrigin);
    for (const [key, val] of Object.entries(query)) {
      requestURL.searchParams.set(key, String(val));
    }
    const sameSite = requestURL.hostname.split(".").slice(-2).join(".") === siteOrigin.hostname.split(".").slice(-2).join(".");
    if (sameSite) {
      requestURL.searchParams.set("app", "res");
      if (!credentials) credentials = "include";
      if (method !== "GET" && method !== "HEAD") {
        if (data.userHash) headers["X-Modhash"] = data.userHash;
      }
      requestURL.hostname = requestURL.hostname.replace(/new\./, "www.");
    }
    const sameOrigin = siteOrigin.origin === requestURL.origin;
    if (typeof data2 === "object") {
      headers["Content-Type"] = "application/x-www-form-urlencoded";
      data2 = new URLSearchParams(data2).toString();
    }
    return {
      method,
      url: requestURL.href,
      headers,
      data: data2,
      type,
      cacheFor,
      credentials: credentials || "omit",
      sameOrigin
    };
  }
  function processResponse(response, type) {
    switch (type) {
      case "text":
        return response.text;
      case "json":
        return JSON.parse(response.text);
      case "raw":
        return response;
      default:
        throw new Error(`Invalid type: ${type}`);
    }
  }

  // lib/environment/foreground/download.js
  function download(url, filename) {
    sendMessage("download", {
      // resolve relative URLs
      url: new URL(url, location.href).href,
      filename
    });
  }

  // lib/environment/foreground/id.js
  function getExtensionId() {
    return chrome.runtime.id;
  }
  var getURL = chrome.runtime.getURL;
  var getOptionsURL = (hash = "") => new URL(hash, getURL("options.html"));
  var isOptionsPage = () => location.origin === getOptionsURL().origin;

  // lib/constants/localStorage.js
  var CACHED_LANG_KEY = "RES.i18nCachedLang";
  var CACHED_MESSAGES_KEY = "RES.i18nCachedMessages";
  var CACHED_MESSAGES_TOKEN_KEY = "RES.i18nCachedMessagesToken";

  // lib/environment/foreground/i18n.js
  var buildToken = downcast("5.24.7", "string");
  var REDDIT_LANGUAGES = /* @__PURE__ */ new Set(["en", "af", "ar", "be", "bg", "bn-IN", "bn-bd", "bs", "ca", "cs", "cy", "da", "de", "el", "en-au", "en-ca", "en-gb", "en-us", "eo", "es", "es-ar", "es-mx", "et", "eu", "fa", "fi", "fil", "fr", "fr-ca", "fy-NL", "ga-ie", "gd", "gl", "he", "hi", "hr", "hu", "hy", "id", "is", "it", "ja", "kn_IN", "ko", "la", "leet", "lol", "lt", "lv", "ms", "mt-MT", "nl", "nn", "no", "pir", "pl", "pt", "pt-pt", "pt_BR", "ro", "ru", "sk", "sl", "sr", "sr-la", "sv", "ta", "th", "tr", "uk", "vi", "zh", "zh-cn"]);
  var SPECIAL_LANGUAGES = /* @__PURE__ */ new Set(["leet", "lol", "pir"]);
  var locale = navigator.language || "en";
  function isValidLocale(localeString) {
    try {
      return typeof 0 .toLocaleString(localeString) === "string";
    } catch (e2) {
      return false;
    }
  }
  function getRedditLocale() {
    const redditLocale = typeof document !== "undefined" && document.documentElement.getAttribute("lang");
    if (redditLocale && REDDIT_LANGUAGES.has(redditLocale)) {
      const locale2 = redditLocale.toLowerCase().replace("_", "-");
      if (isValidLocale(locale2)) {
        requestIdleCallback(() => {
          sendMessage("setLastRedditLocale", locale2);
        });
        return locale2;
      }
    }
    return sendMessage("getLastRedditLocale");
  }
  var messages;
  async function _loadI18n() {
    const redditLocale = await getRedditLocale();
    if (redditLocale && !SPECIAL_LANGUAGES.has(redditLocale)) locale = redditLocale;
    if (localStorage.getItem(CACHED_LANG_KEY) === redditLocale && localStorage.getItem(CACHED_MESSAGES_TOKEN_KEY) === buildToken) {
      try {
        messages = JSON.parse(localStorage.getItem(CACHED_MESSAGES_KEY) || "");
        return;
      } catch (e2) {
        console.error("Failed to parse cached i18n", e2);
      }
    }
    messages = await sendMessage("i18n", redditLocale);
    try {
      localStorage.setItem(CACHED_MESSAGES_KEY, JSON.stringify(messages));
      localStorage.setItem(CACHED_LANG_KEY, redditLocale);
      localStorage.setItem(CACHED_MESSAGES_TOKEN_KEY, buildToken);
    } catch (e2) {
      console.error("Could not cache i18n - RES will load VERY slowly", e2);
      localStorage.removeItem("ads.adserverDownvotePixel");
      localStorage.removeItem("ads.adserverUpvotePixel");
    }
  }
  function i18n(messageName, ...substitutions) {
    if (!messageName) return "";
    if (!messages) {
      if (false) {
        throw new Error(`i18n called too early! key: ${messageName}`);
      } else {
        console.error("i18n called too early! key:", messageName);
        return messageName;
      }
    }
    const message = messages[messageName];
    if (!message) return messageName;
    if (substitutions.length === 0) return message;
    return message.replace(/\$(\d)\b(?!\$)/g, (match, number) => substitutions[number - 1]);
  }

  // lib/environment/foreground/loadScript.js
  var loadScript = memoize_default((url) => sendMessage("loadScript", { url }));

  // lib/environment/foreground/permissions.js
  var permissions_exports = {};
  __export(permissions_exports, {
    has: () => has,
    request: () => request
  });
  function filterPerms(perms) {
    const permissions = perms.filter((p) => !p.includes("://") && p !== "<all_urls>");
    const origins = perms.filter((p) => p.includes("://") || p === "<all_urls>");
    return { permissions, origins };
  }
  var has = memoize_default(
    (perms) => sendMessage("permissions", { operation: "contains", ...filterPerms(perms) }),
    (perms) => perms.join(",")
  );
  var request = mutex(async (perms) => {
    if (await has(perms)) return;
    const { permissions, origins } = filterPerms(perms);
    const granted = await sendMessage("permissions", { operation: "request", permissions, origins });
    if (granted) {
      has.cache.set(perms.join(","), true);
    } else {
      throw new Error(`Permission not granted for: ${perms.join(", ")}`);
    }
  });

  // lib/environment/foreground/auth.js
  async function launchAuthFlow({
    domain,
    clientId,
    scope = "",
    permissions
  }, warnUserInteraction) {
    if (permissions.length && !await has(permissions)) {
      const resAuth = "https://redditenhancementsuite.com/oauth";
      if (false) {
        permissions.push(resAuth);
      }
      await warnUserInteraction(permissions.includes(resAuth) ? "You may be redirected to redditenhancementsuite.com to complete the login process." : "");
      await request(permissions);
    }
    let responseUrl;
    try {
      responseUrl = await sendMessage("authFlow", { domain, clientId, scope, interactive: false });
    } catch (e2) {
      console.error("Noninteractive auth failed:", e2);
      responseUrl = await sendMessage("authFlow", { domain, clientId, scope, interactive: true });
    }
    const hash = new URL(responseUrl).hash.slice(1);
    const token = new URLSearchParams(hash).get("access_token");
    if (!token) throw new Error("No token found in response.");
    return token;
  }

  // lib/environment/foreground/multicast.js
  var callbacks = /* @__PURE__ */ new Map();
  addListener("multicast", ({ name: name2, args }) => {
    const callback = callbacks.get(name2);
    if (callback) return callback(...args);
  });
  function multicast(callback, { name: name2, local = true, crossContext = true }) {
    if (callbacks.has(name2)) {
      throw new Error(`Multicast handler with name "${name2}" exists.`);
    }
    callbacks.set(name2, callback);
    function localOnly(...args) {
      callback(...args);
    }
    const invoke = (...args) => {
      sendMessage("multicast", { name: name2, args, crossContext });
      if (local) {
        localOnly(...args);
      }
    };
    invoke.local = localOnly;
    return invoke;
  }

  // lib/environment/foreground/tabs.js
  function openNewTab(url, focus = true) {
    return openNewTabs(focus, url);
  }
  function openNewTabs(focus, ...urls2) {
    let focusIndex;
    if (typeof focus !== "string") focus = !!focus;
    switch (focus) {
      case "first":
        focusIndex = 0;
        break;
      case true:
      case "last":
        focusIndex = urls2.length - 1;
        break;
      case false:
      case "none":
        focusIndex = -1;
        break;
      default:
        throw new Error(`Invalid focus specified: ${focus}`);
    }
    urls2 = urls2.map((url) => new URL(url, location.href).href);
    return sendMessage("openNewTabs", { urls: urls2, focusIndex });
  }

  // lib/environment/foreground/pageAction.js
  var pageAction_exports = {};
  __export(pageAction_exports, {
    hide: () => hide,
    onClick: () => onClick,
    show: () => show
  });
  var clickListeners = [];
  function onClick(callback) {
    clickListeners.push(callback);
  }
  addListener("pageActionClick", () => {
    for (const fn of clickListeners) fn();
  });
  var update = frameThrottle((value) => sendMessage("pageAction", value));
  function show(state = false) {
    return update({ operation: "show", state });
  }
  function hide() {
    return update({ operation: "hide" });
  }

  // lib/environment/foreground/session.js
  var session_exports = {};
  __export(session_exports, {
    clear: () => clear2,
    delete: () => delete_2,
    delete_: () => delete_2,
    get: () => get2,
    has: () => has2,
    set: () => set2
  });
  function get2(key) {
    return sendMessage("session", ["get", key]);
  }
  function set2(key, value) {
    return sendMessage("session", ["set", key, value]);
  }
  function delete_2(key) {
    return sendMessage("session", ["delete", key]);
  }
  function has2(key) {
    return sendMessage("session", ["has", key]);
  }
  function clear2() {
    return sendMessage("session", ["clear"]);
  }

  // lib/environment/foreground/storage.js
  var storage_exports = {};
  __export(storage_exports, {
    clear: () => clear3,
    delete: () => delete_3,
    deleteMultiple: () => deleteMultiple,
    get: () => get3,
    getAll: () => getAll,
    getMultiple: () => getMultiple,
    has: () => has3,
    keys: () => keys2,
    set: () => set3,
    setMultiple: () => setMultiple,
    wrap: () => wrap,
    wrapBlob: () => wrapBlob,
    wrapPrefix: () => wrapPrefix,
    wrapPrefix2: () => wrapPrefix2
  });

  // lib/utils/object.js
  function extendDeep(target, source) {
    for (const key of Object.keys(source)) {
      if (target[key] && source[key] && typeof target[key] === "object" && typeof source[key] === "object" && !Array.isArray(source[key]) && !Array.isArray(target[key])) {
        extendDeep(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
    return target;
  }

  // lib/environment/foreground/storage.js
  var __set = apiToPromise((items2, callback) => chrome.storage.local.set(items2, callback));
  var _set = (key, value) => __set({ [key]: value });
  var __get = apiToPromise((keys3, callback) => chrome.storage.local.get(keys3, callback));
  var _get = async (key, defaultValue = null) => (await __get({ [key]: defaultValue }))[key];
  var _delete = apiToPromise((keys3, callback) => chrome.storage.local.remove(keys3, callback));
  var _clear = apiToPromise((callback) => chrome.storage.local.clear(callback));
  var withLockOn = keyedMutex((key, fn) => fn());
  function get3(key) {
    return withLockOn(key, () => _get(key, null));
  }
  function getAll() {
    return __get(null);
  }
  function getMultiple(keys3) {
    const defaults2 = {};
    for (const k2 of keys3) {
      defaults2[k2] = null;
    }
    return __get(defaults2);
  }
  function set3(key, value) {
    return withLockOn(key, () => _set(key, value));
  }
  function setMultiple(valueMap) {
    return __set(valueMap);
  }
  function compareAndSet(key, defaultValue, oldValue, newValue) {
    return sendMessage("storage-cas", [key, defaultValue, oldValue, newValue]);
  }
  function patch(key, value) {
    return withLockOn(key, async () => {
      const extended = extendDeep(await _get(key) || {}, value);
      return _set(key, extended);
    });
  }
  function patchShallow(key, value) {
    return withLockOn(key, async () => {
      const extended = Object.assign(await _get(key) || {}, value);
      return _set(key, extended);
    });
  }
  function deletePaths(key, paths) {
    return withLockOn(key, async () => {
      const stored = await _get(key);
      if (!stored) return;
      for (const path of paths) {
        path.reduce((obj, key2, i2, { length }) => {
          if (!obj) return;
          if (i2 < length - 1) return obj[key2];
          delete obj[key2];
        }, stored);
      }
      return _set(key, stored);
    });
  }
  function delete_3(key) {
    return withLockOn(key, () => _delete(key));
  }
  function deleteMultiple(keys3) {
    return _delete(keys3);
  }
  function has3(key) {
    return withLockOn(key, async () => {
      const sentinel = Math.random();
      return await _get(key, sentinel) !== sentinel;
    });
  }
  async function keys2() {
    return Object.keys(await __get(null));
  }
  function clear3() {
    return _clear();
  }
  var Wrapper = class {
    _key;
    _default;
    constructor(key, def) {
      this._key = key;
      this._default = def;
    }
    get() {
      return get3(this._key()).then((val) => val === null ? this._default : val);
    }
    set(value) {
      return set3(this._key(), value);
    }
    patch(value) {
      return patch(this._key(), value);
    }
    compareAndSet(oldValue, newValue) {
      return compareAndSet(this._key(), this._default, oldValue, newValue);
    }
    deletePath(...path) {
      return deletePaths(this._key(), [path]);
    }
    delete() {
      return delete_3(this._key());
    }
    has() {
      return has3(this._key());
    }
  };
  function wrap(key, defaultValue) {
    const keyGenerator = typeof key === "string" ? () => key : once_default(key);
    return new Wrapper(keyGenerator, defaultValue);
  }
  var PrefixWrapper = class {
    _prefix;
    _keyMapper;
    _default;
    _get;
    constructor(prefix, def, keyMapper, batching) {
      this._prefix = prefix;
      this._default = def;
      this._keyMapper = keyMapper;
      if (batching) {
        this._get = batch(async (keys3) => {
          const v = await this.getMultipleNullable(keys3);
          return keys3.map((key) => v[this._keyMapper(key)]);
        }, { size: Infinity, delay: 0 });
      } else {
        this._get = (key) => get3(this._keyGen(key));
      }
    }
    _keyGen(key) {
      return this._prefix + this._keyMapper(key);
    }
    get(key) {
      return this._get(key).then((val) => val === null ? this._default() : val);
    }
    getNullable(key) {
      return this._get(key);
    }
    async getAll() {
      const everything = await getAll();
      return transform_default(everything, (acc, v, k2) => {
        if (k2.startsWith(this._prefix)) {
          acc[k2.slice(this._prefix.length)] = v;
        }
      }, {});
    }
    async getMultiple(keys3) {
      const rawValues = await getMultiple(keys3.map((k2) => this._keyGen(k2)));
      return transform_default(rawValues, (acc, v, k2) => {
        acc[k2.slice(this._prefix.length)] = v === null ? this._default() : v;
      }, {});
    }
    async getMultipleNullable(keys3) {
      const rawValues = await getMultiple(keys3.map((k2) => this._keyGen(k2)));
      return transform_default(rawValues, (acc, v, k2) => {
        acc[k2.slice(this._prefix.length)] = v;
      }, {});
    }
    set(key, value) {
      return set3(this._keyGen(key), value);
    }
    patch(key, value) {
      return patch(this._keyGen(key), value);
    }
    deletePath(key, ...path) {
      return deletePaths(this._keyGen(key), [path]);
    }
    delete(key) {
      return delete_3(this._keyGen(key));
    }
    deleteMultiple(keys3) {
      return deleteMultiple(keys3.map((k2) => this._keyGen(k2)));
    }
    has(key) {
      return has3(this._keyGen(key));
    }
  };
  function wrapPrefix(prefix, defaultValue, destructiveKeyMapper = (x) => x, batching = false) {
    return new PrefixWrapper(prefix, defaultValue, destructiveKeyMapper, batching);
  }
  function wrapPrefix2(prefix, defaultValue, destructiveKeyMapper = (x) => x, batching = false) {
    return new PrefixWrapper(prefix, defaultValue, destructiveKeyMapper, batching);
  }
  var BlobWrapper = class {
    _rootKey;
    _default;
    constructor(rootKey, def) {
      this._rootKey = rootKey;
      this._default = def;
    }
    get(key) {
      return get3(this._rootKey).then((val) => val === null || val[key] === void 0 ? this._default() : val[key]);
    }
    getNullable(key) {
      return get3(this._rootKey).then((val) => val === null || val[key] === void 0 ? null : val[key]);
    }
    getAll() {
      return get3(this._rootKey).then((val) => val === null ? {} : val);
    }
    async getMultiple(keys3) {
      const rawValues = await get3(this._rootKey) || {};
      return transform_default(keys3, (acc, key) => {
        acc[key] = rawValues[key] === void 0 ? this._default() : rawValues[key];
      }, {});
    }
    async getMultipleNullable(keys3) {
      const rawValues = await get3(this._rootKey) || {};
      return transform_default(keys3, (acc, key) => {
        acc[key] = rawValues[key] === void 0 ? null : rawValues[key];
      }, {});
    }
    set(key, value) {
      return patchShallow(this._rootKey, { [key]: value });
    }
    patch(key, value) {
      return patch(this._rootKey, { [key]: value });
    }
    deletePath(key, ...path) {
      return deletePaths(this._rootKey, [[key, ...path]]);
    }
    delete(key) {
      return deletePaths(this._rootKey, [[key]]);
    }
    deleteMultiple(keys3) {
      return deletePaths(this._rootKey, keys3.map((k2) => [k2]));
    }
    has(key) {
      return get3(this._rootKey).then((val) => val !== null && val[key] !== void 0);
    }
    clear() {
      return delete_3(this._rootKey);
    }
  };
  function wrapBlob(rootKey, defaultValue) {
    return new BlobWrapper(rootKey, defaultValue);
  }

  // lib/utils/thingMetadata.js
  var getPostMetadata = batch(async (requests) => {
    const byId = requests.map((r) => r.id).map((id2) => `t3_${id2}`).join(",");
    const { data: { children } } = await ajax({
      url: `/by_id/${byId}.json`,
      query: { limit: 100, raw_json: 1 },
      type: "json"
    });
    return children.map((c2) => c2.data);
  }, { size: 100 });

  // node_modules/tinycolor2/esm/tinycolor.js
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  var trimLeft = /^\s+/;
  var trimRight = /\s+$/;
  function tinycolor(color, opts) {
    color = color ? color : "";
    opts = opts || {};
    if (color instanceof tinycolor) {
      return color;
    }
    if (!(this instanceof tinycolor)) {
      return new tinycolor(color, opts);
    }
    var rgb = inputToRGB(color);
    this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;
    if (this._r < 1) this._r = Math.round(this._r);
    if (this._g < 1) this._g = Math.round(this._g);
    if (this._b < 1) this._b = Math.round(this._b);
    this._ok = rgb.ok;
  }
  tinycolor.prototype = {
    isDark: function isDark() {
      return this.getBrightness() < 128;
    },
    isLight: function isLight() {
      return !this.isDark();
    },
    isValid: function isValid() {
      return this._ok;
    },
    getOriginalInput: function getOriginalInput() {
      return this._originalInput;
    },
    getFormat: function getFormat() {
      return this._format;
    },
    getAlpha: function getAlpha() {
      return this._a;
    },
    getBrightness: function getBrightness() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    },
    getLuminance: function getLuminance() {
      var rgb = this.toRgb();
      var RsRGB, GsRGB, BsRGB, R, G, B;
      RsRGB = rgb.r / 255;
      GsRGB = rgb.g / 255;
      BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) R = RsRGB / 12.92;
      else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      if (GsRGB <= 0.03928) G = GsRGB / 12.92;
      else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      if (BsRGB <= 0.03928) B = BsRGB / 12.92;
      else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    },
    setAlpha: function setAlpha(value) {
      this._a = boundAlpha(value);
      this._roundA = Math.round(100 * this._a) / 100;
      return this;
    },
    toHsv: function toHsv() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v,
        a: this._a
      };
    },
    toHsvString: function toHsvString() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      var h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
      return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
    },
    toHsl: function toHsl() {
      var hsl = rgbToHsl(this._r, this._g, this._b);
      return {
        h: hsl.h * 360,
        s: hsl.s,
        l: hsl.l,
        a: this._a
      };
    },
    toHslString: function toHslString() {
      var hsl = rgbToHsl(this._r, this._g, this._b);
      var h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
      return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
    },
    toHex: function toHex(allow3Char) {
      return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function toHexString(allow3Char) {
      return "#" + this.toHex(allow3Char);
    },
    toHex8: function toHex8(allow4Char) {
      return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function toHex8String(allow4Char) {
      return "#" + this.toHex8(allow4Char);
    },
    toRgb: function toRgb() {
      return {
        r: Math.round(this._r),
        g: Math.round(this._g),
        b: Math.round(this._b),
        a: this._a
      };
    },
    toRgbString: function toRgbString() {
      return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function toPercentageRgb() {
      return {
        r: Math.round(bound01(this._r, 255) * 100) + "%",
        g: Math.round(bound01(this._g, 255) * 100) + "%",
        b: Math.round(bound01(this._b, 255) * 100) + "%",
        a: this._a
      };
    },
    toPercentageRgbString: function toPercentageRgbString() {
      return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function toName() {
      if (this._a === 0) {
        return "transparent";
      }
      if (this._a < 1) {
        return false;
      }
      return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function toFilter(secondColor) {
      var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
      var secondHex8String = hex8String;
      var gradientType = this._gradientType ? "GradientType = 1, " : "";
      if (secondColor) {
        var s = tinycolor(secondColor);
        secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
      }
      return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
    },
    toString: function toString2(format) {
      var formatSet = !!format;
      format = format || this._format;
      var formattedString = false;
      var hasAlpha = this._a < 1 && this._a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
      if (needsAlphaFormat) {
        if (format === "name" && this._a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }
      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format === "name") {
        formattedString = this.toName();
      }
      if (format === "hsl") {
        formattedString = this.toHslString();
      }
      if (format === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    },
    clone: function clone() {
      return tinycolor(this.toString());
    },
    _applyModification: function _applyModification(fn, args) {
      var color = fn.apply(null, [this].concat([].slice.call(args)));
      this._r = color._r;
      this._g = color._g;
      this._b = color._b;
      this.setAlpha(color._a);
      return this;
    },
    lighten: function lighten() {
      return this._applyModification(_lighten, arguments);
    },
    brighten: function brighten() {
      return this._applyModification(_brighten, arguments);
    },
    darken: function darken() {
      return this._applyModification(_darken, arguments);
    },
    desaturate: function desaturate() {
      return this._applyModification(_desaturate, arguments);
    },
    saturate: function saturate() {
      return this._applyModification(_saturate, arguments);
    },
    greyscale: function greyscale() {
      return this._applyModification(_greyscale, arguments);
    },
    spin: function spin() {
      return this._applyModification(_spin, arguments);
    },
    _applyCombination: function _applyCombination(fn, args) {
      return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function analogous() {
      return this._applyCombination(_analogous, arguments);
    },
    complement: function complement() {
      return this._applyCombination(_complement, arguments);
    },
    monochromatic: function monochromatic() {
      return this._applyCombination(_monochromatic, arguments);
    },
    splitcomplement: function splitcomplement() {
      return this._applyCombination(_splitcomplement, arguments);
    },
    // Disabled until https://github.com/bgrins/TinyColor/issues/254
    // polyad: function (number) {
    //   return this._applyCombination(polyad, [number]);
    // },
    triad: function triad() {
      return this._applyCombination(polyad, [3]);
    },
    tetrad: function tetrad() {
      return this._applyCombination(polyad, [4]);
    }
  };
  tinycolor.fromRatio = function(color, opts) {
    if (_typeof(color) == "object") {
      var newColor = {};
      for (var i2 in color) {
        if (color.hasOwnProperty(i2)) {
          if (i2 === "a") {
            newColor[i2] = color[i2];
          } else {
            newColor[i2] = convertToPercentage(color[i2]);
          }
        }
      }
      color = newColor;
    }
    return tinycolor(color, opts);
  };
  function inputToRGB(color) {
    var rgb = {
      r: 0,
      g: 0,
      b: 0
    };
    var a2 = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;
    if (typeof color == "string") {
      color = stringInputToObject(color);
    }
    if (_typeof(color) == "object") {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s = convertToPercentage(color.s);
        v = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s, v);
        ok = true;
        format = "hsv";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s = convertToPercentage(color.s);
        l = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s, l);
        ok = true;
        format = "hsl";
      }
      if (color.hasOwnProperty("a")) {
        a2 = color.a;
      }
    }
    a2 = boundAlpha(a2);
    return {
      ok,
      format: color.format || format,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a: a2
    };
  }
  function rgbToRgb(r, g, b2) {
    return {
      r: bound01(r, 255) * 255,
      g: bound01(g, 255) * 255,
      b: bound01(b2, 255) * 255
    };
  }
  function rgbToHsl(r, g, b2) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b2 = bound01(b2, 255);
    var max = Math.max(r, g, b2), min = Math.min(r, g, b2);
    var h, s, l = (max + min) / 2;
    if (max == min) {
      h = s = 0;
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b2) / d + (g < b2 ? 6 : 0);
          break;
        case g:
          h = (b2 - r) / d + 2;
          break;
        case b2:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return {
      h,
      s,
      l
    };
  }
  function hslToRgb(h, s, l) {
    var r, g, b2;
    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);
    function hue2rgb(p2, q2, t2) {
      if (t2 < 0) t2 += 1;
      if (t2 > 1) t2 -= 1;
      if (t2 < 1 / 6) return p2 + (q2 - p2) * 6 * t2;
      if (t2 < 1 / 2) return q2;
      if (t2 < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      return p2;
    }
    if (s === 0) {
      r = g = b2 = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b2 = hue2rgb(p, q, h - 1 / 3);
    }
    return {
      r: r * 255,
      g: g * 255,
      b: b2 * 255
    };
  }
  function rgbToHsv(r, g, b2) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b2 = bound01(b2, 255);
    var max = Math.max(r, g, b2), min = Math.min(r, g, b2);
    var h, s, v = max;
    var d = max - min;
    s = max === 0 ? 0 : d / max;
    if (max == min) {
      h = 0;
    } else {
      switch (max) {
        case r:
          h = (g - b2) / d + (g < b2 ? 6 : 0);
          break;
        case g:
          h = (b2 - r) / d + 2;
          break;
        case b2:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return {
      h,
      s,
      v
    };
  }
  function hsvToRgb(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i2 = Math.floor(h), f2 = h - i2, p = v * (1 - s), q = v * (1 - f2 * s), t2 = v * (1 - (1 - f2) * s), mod = i2 % 6, r = [v, q, p, p, t2, v][mod], g = [t2, v, v, q, p, p][mod], b2 = [p, p, t2, v, v, q][mod];
    return {
      r: r * 255,
      g: g * 255,
      b: b2 * 255
    };
  }
  function rgbToHex(r, g, b2, allow3Char) {
    var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b2).toString(16))];
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }
    return hex.join("");
  }
  function rgbaToHex(r, g, b2, a2, allow4Char) {
    var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b2).toString(16)), pad2(convertDecimalToHex(a2))];
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }
    return hex.join("");
  }
  function rgbaToArgbHex(r, g, b2, a2) {
    var hex = [pad2(convertDecimalToHex(a2)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b2).toString(16))];
    return hex.join("");
  }
  tinycolor.equals = function(color1, color2) {
    if (!color1 || !color2) return false;
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
  };
  tinycolor.random = function() {
    return tinycolor.fromRatio({
      r: Math.random(),
      g: Math.random(),
      b: Math.random()
    });
  };
  function _desaturate(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
  }
  function _saturate(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
  }
  function _greyscale(color) {
    return tinycolor(color).desaturate(100);
  }
  function _lighten(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
  }
  function _brighten(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var rgb = tinycolor(color).toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return tinycolor(rgb);
  }
  function _darken(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
  }
  function _spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
  }
  function _complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
  }
  function polyad(color, number) {
    if (isNaN(number) || number <= 0) {
      throw new Error("Argument to polyad must be a positive number");
    }
    var hsl = tinycolor(color).toHsl();
    var result = [tinycolor(color)];
    var step = 360 / number;
    for (var i2 = 1; i2 < number; i2++) {
      result.push(tinycolor({
        h: (hsl.h + i2 * step) % 360,
        s: hsl.s,
        l: hsl.l
      }));
    }
    return result;
  }
  function _splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [tinycolor(color), tinycolor({
      h: (h + 72) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h + 216) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  }
  function _analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;
    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(tinycolor(hsl));
    }
    return ret;
  }
  function _monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;
    while (results--) {
      ret.push(tinycolor({
        h,
        s,
        v
      }));
      v = (v + modification) % 1;
    }
    return ret;
  }
  tinycolor.mix = function(color1, color2, amount) {
    amount = amount === 0 ? 0 : amount || 50;
    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();
    var p = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p + rgb1.r,
      g: (rgb2.g - rgb1.g) * p + rgb1.g,
      b: (rgb2.b - rgb1.b) * p + rgb1.b,
      a: (rgb2.a - rgb1.a) * p + rgb1.a
    };
    return tinycolor(rgba);
  };
  tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
  };
  tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;
    out = false;
    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
      case "AAsmall":
      case "AAAlarge":
        out = readability >= 4.5;
        break;
      case "AAlarge":
        out = readability >= 3;
        break;
      case "AAAsmall":
        out = readability >= 7;
        break;
    }
    return out;
  };
  tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors;
    level = args.level;
    size = args.size;
    for (var i2 = 0; i2 < colorList.length; i2++) {
      readability = tinycolor.readability(baseColor, colorList[i2]);
      if (readability > bestScore) {
        bestScore = readability;
        bestColor = tinycolor(colorList[i2]);
      }
    }
    if (tinycolor.isReadable(baseColor, bestColor, {
      level,
      size
    }) || !includeFallbackColors) {
      return bestColor;
    } else {
      args.includeFallbackColors = false;
      return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
    }
  };
  var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
  };
  var hexNames = tinycolor.hexNames = flip(names);
  function flip(o2) {
    var flipped = {};
    for (var i2 in o2) {
      if (o2.hasOwnProperty(i2)) {
        flipped[o2[i2]] = i2;
      }
    }
    return flipped;
  }
  function boundAlpha(a2) {
    a2 = parseFloat(a2);
    if (isNaN(a2) || a2 < 0 || a2 > 1) {
      a2 = 1;
    }
    return a2;
  }
  function bound01(n, max) {
    if (isOnePointZero(n)) n = "100%";
    var processPercent = isPercentage(n);
    n = Math.min(max, Math.max(0, parseFloat(n)));
    if (processPercent) {
      n = parseInt(n * max, 10) / 100;
    }
    if (Math.abs(n - max) < 1e-6) {
      return 1;
    }
    return n % max / parseFloat(max);
  }
  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
  }
  function isPercentage(n) {
    return typeof n === "string" && n.indexOf("%") != -1;
  }
  function pad2(c2) {
    return c2.length == 1 ? "0" + c2 : "" + c2;
  }
  function convertToPercentage(n) {
    if (n <= 1) {
      n = n * 100 + "%";
    }
    return n;
  }
  function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
  }
  function convertHexToDecimal(h) {
    return parseIntFromHex(h) / 255;
  }
  var matchers = function() {
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    return {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
  }();
  function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
  }
  function stringInputToObject(color) {
    color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
    var named = false;
    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color == "transparent") {
      return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
      };
    }
    var match;
    if (match = matchers.rgb.exec(color)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3]
      };
    }
    if (match = matchers.rgba.exec(color)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3],
        a: match[4]
      };
    }
    if (match = matchers.hsl.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3]
      };
    }
    if (match = matchers.hsla.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3],
        a: match[4]
      };
    }
    if (match = matchers.hsv.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3]
      };
    }
    if (match = matchers.hsva.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3],
        a: match[4]
      };
    }
    if (match = matchers.hex8.exec(color)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        a: convertHexToDecimal(match[4]),
        format: named ? "name" : "hex8"
      };
    }
    if (match = matchers.hex6.exec(color)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        format: named ? "name" : "hex"
      };
    }
    if (match = matchers.hex4.exec(color)) {
      return {
        r: parseIntFromHex(match[1] + "" + match[1]),
        g: parseIntFromHex(match[2] + "" + match[2]),
        b: parseIntFromHex(match[3] + "" + match[3]),
        a: convertHexToDecimal(match[4] + "" + match[4]),
        format: named ? "name" : "hex8"
      };
    }
    if (match = matchers.hex3.exec(color)) {
      return {
        r: parseIntFromHex(match[1] + "" + match[1]),
        g: parseIntFromHex(match[2] + "" + match[2]),
        b: parseIntFromHex(match[3] + "" + match[3]),
        format: named ? "name" : "hex"
      };
    }
    return false;
  }
  function validateWCAG2Parms(parms) {
    var level, size;
    parms = parms || {
      level: "AA",
      size: "small"
    };
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
      level = "AA";
    }
    if (size !== "small" && size !== "large") {
      size = "small";
    }
    return {
      level,
      size
    };
  }

  // lib/utils/color.js
  function colorToArray(colorString) {
    const { r, g, b: b2 } = tinycolor(colorString).toRgb();
    return [r, g, b2];
  }
  function colorFromArray([r, g, b2]) {
    return tinycolor({ r, g, b: b2 }).toHexString();
  }

  // lib/utils/dashboard.js
  var initialTabID = location.hash.replace("#", "") || "dashboardContents";
  var selectedTabMenuItem;
  function addDashboardTab(tabID, tabName, moduleId, callback) {
    if (!isCurrentSubreddit("dashboard")) return;
    bodyClasses_exports.add("res-dashboard");
    let tabPage;
    const tabMenuItem2 = createElement_exports.tabMenuItem({
      text: tabName,
      className: "res-dashboard-tab",
      order: -1,
      onChange: (active) => {
        const container2 = document.querySelector("#siteTable.linklisting");
        if (!container2) return;
        if (active) {
          if (selectedTabMenuItem) selectedTabMenuItem.click();
          selectedTabMenuItem = tabMenuItem2;
          tabPage = string_exports.html`<div class="dashboardPane"></div>`;
          container2.append(tabPage);
          callback(tabPage);
          location.hash = tabID;
        } else {
          tabPage.remove();
        }
      }
    });
    if (moduleId) {
      tabMenuItem2.after(string_exports.html`<a class="gearIcon" href="#res:settings/${moduleId}"></a>`);
    }
    if (tabID === initialTabID) tabMenuItem2.click();
  }

  // lib/utils/floater.js
  var Container = class {
    static isAvailable() {
      return true;
    }
    static fallback;
    static phase = loadComplete;
    static useList = true;
    element = document.createElement("div");
    list = html`<ul class="res-floater-list"></ul>`;
    constructor() {
      if (this.constructor.useList) this.element.append(this.list);
      this.constructor.phase.then(() => this.go());
    }
    go() {
    }
    add(element, { separate, order }) {
      if (separate || !this.constructor.useList) {
        element.style.order = String(order);
        this.element.append(element);
      } else {
        if (element instanceof HTMLLIElement) {
          this.list.append(element);
        } else {
          const li = html`<li style="order: ${order}"></li>`;
          li.append(element);
          this.list.append(li);
        }
      }
    }
  };
  var containers = {
    inNavbar: class extends Container {
      static isAvailable() {
        return isAppType("d2x") && !!document.querySelector(".header-user-dropdown");
      }
      static fallback = "userMenu";
      static phase = contentStart;
      go() {
        this.element.classList.add("res-floater-inNavbar");
        document.body.append(this.element);
        this.updateHeaderWidth();
      }
      add(element, opts) {
        super.add(element, opts);
        this.updateHeaderWidth();
      }
      updateHeaderWidth = frameThrottle(() => {
        const { width } = this.element.getBoundingClientRect();
        const headerButton = document.querySelector(".header-user-dropdown");
        headerButton.style.marginRight = `${width}px`;
      });
    },
    userMenu: class extends Container {
      static isAvailable() {
        return isAppType("r2");
      }
      static phase = contentStart;
      static useList = false;
      go() {
        const element = document.body.querySelector("#header-bottom-right ul");
        element.append(...this.element.children);
        this.element = element;
      }
      add(element) {
        this.element.append(html`<span class="separator">|</span>`, element);
      }
    },
    belowFixedNavbar: class extends Container {
      static isAvailable() {
        return isAppType("d2x");
      }
      go() {
        this.element.classList.add("res-floater-belowNavbar");
        this.element.style.top = `${5 + getD2xBodyOffset()}px`;
        document.body.append(this.element);
      }
    },
    visibleAfterScroll: class extends Container {
      static isAvailable() {
        return !isAppType("d2x");
      }
      static fallback = "belowFixedNavbar";
      go() {
        this.element.classList.add("res-floater-visibleAfterScroll");
        document.body.append(this.element);
        this.element.style.top = `${8 + getHeaderOffset(true)}px`;
        if (!document.querySelector("#RESPinnedHeaderSpacer")) {
          this.element.hidden = true;
          new IntersectionObserver((entries) => {
            this.element.hidden = entries[0].isIntersecting;
          }).observe(document.querySelector("#header"));
        }
      }
    },
    tabMenu: class extends Container {
      static isAvailable() {
        return isAppType("r2");
      }
      static fallback = "belowFixedNavbar";
      static phase = contentStart;
      static useList = false;
      go() {
        let menu = document.querySelector("#header-bottom-left ul.tabmenu");
        if (menu) {
        } else if (document.querySelector("#header-bottom-left")) {
          menu = html`<ul class="tabmenu" />`;
          document.querySelector("#header-bottom-left").append(menu);
        } else {
          if (false) {
            console.warn("Could not find tab menu");
          }
          return;
        }
        menu.append(...this.element.children);
        this.element = menu;
      }
    },
    inert: Container
  };
  var getContainer = memoize_default((name2) => {
    let container2;
    if (containers[name2].isAvailable()) {
      container2 = new containers[name2]();
    } else if (containers[name2].fallback) {
      container2 = getContainer(containers[name2].fallback);
    }
    if (container2) {
      return container2;
    } else {
      const InertContainer = containers.inert;
      return new InertContainer();
    }
  });
  function addFloater(element, {
    container: containerName = ["inNavbar", "belowFixedNavbar", "visibleAfterScroll"].find((name2) => containers[name2].isAvailable()) || "inert",
    separate = false,
    order = 0
  } = {}) {
    getContainer(containerName).add(element, { separate, order });
  }

  // lib/utils/hash.js
  var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomHash(len = 5) {
    const arr = new Array(len);
    for (const i2 of range(0, len)) {
      arr[i2] = chars.charAt(Math.random() * chars.length | 0);
    }
    return arr.join("");
  }
  function hashCode(str) {
    let hash = 0;
    for (const char of str) {
      hash = (hash << 5) - hash + char.charCodeAt(0) | 0;
    }
    return hash;
  }

  // lib/utils/thingHide.js
  var hideEndpoint = "/api/hide";
  var unhideEndpoint = "/api/unhide";
  var [HIDE, UNHIDE] = ["hide", "unhide"];
  var send = async (state, things2) => {
    if (!isLoggedIn()) throw new Error("Not logged in");
    const values = filterMap(things2, (thing) => {
      const id2 = thing.getFullname();
      const element = thing.getHideElement();
      return id2 && element && element.dataset.eventAction === state ? [{ id: id2, element }] : void 0;
    });
    if (!values.length) return;
    const updateElements = (action, text) => {
      for (const { element } of values) {
        if (action) element.dataset.eventAction = action;
        if (element.classList.contains("noCtrlF")) element.dataset.text = text;
        else element.textContent = text;
      }
    };
    updateElements(state === HIDE ? UNHIDE : HIDE, state === HIDE ? "hiding..." : "unhiding...");
    try {
      await ajax({
        method: "POST",
        url: state === HIDE ? hideEndpoint : unhideEndpoint,
        data: { id: values.map(({ id: id2 }) => id2).join(",") },
        type: "json"
      });
      updateElements(void 0, state === HIDE ? UNHIDE : HIDE);
    } catch (e2) {
      updateElements(state, state);
      throw e2;
    }
  };
  var hide2 = batch((things2) => send(HIDE, things2), { size: 50 });
  var unhide = batch((things2) => send(UNHIDE, things2), { size: 50 });

  // lib/utils/keycode.js
  var NAMED_KEYS = {
    Backspace: "Backspace",
    Tab: "Tab",
    Enter: "Enter",
    Escape: "Escape",
    Space: " ",
    PageUp: "PageUp",
    PageDown: "PageDown",
    End: "End",
    Home: "Home",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Shift: "Shift",
    Control: "Control",
    Alt: "Alt"
  };
  var keyCodes = {
    "-1": "none",
    "8": "backspace",
    "9": "tab",
    "13": "enter",
    "16": "shift",
    "17": "ctrl",
    "18": "alt",
    "19": "pause/break",
    "20": "caps lock",
    "27": "escape",
    "33": "page up",
    "34": "page down",
    "35": "end",
    "36": "home",
    "37": "left arrow",
    "38": "up arrow",
    "39": "right arrow",
    "40": "down arrow",
    "45": "insert",
    "46": "delete",
    "91": "left window",
    "92": "right window",
    "93": "select key",
    "96": "numpad 0",
    "97": "numpad 1",
    "98": "numpad 2",
    "99": "numpad 3",
    "100": "numpad 4",
    "101": "numpad 5",
    "102": "numpad 6",
    "103": "numpad 7",
    "104": "numpad 8",
    "105": "numpad 9",
    "106": "multiply",
    "107": "add",
    "109": "subtract",
    "110": "decimal point",
    "111": "divide",
    "112": "F1",
    "113": "F2",
    "114": "F3",
    "115": "F4",
    "116": "F5",
    "117": "F6",
    "118": "F7",
    "119": "F8",
    "120": "F9",
    "121": "F10",
    "122": "F11",
    "123": "F12",
    "144": "num lock",
    "145": "scroll lock",
    "186": ";",
    "187": "=",
    "188": ",",
    "189": "-",
    "190": ".",
    "191": "/",
    "192": "`",
    "219": "[",
    "220": "\\",
    "221": "]",
    "222": "'"
  };
  function niceKeyCode(keyArray) {
    if (!keyArray && isNaN(keyArray)) {
      return "";
    }
    if (typeof keyArray === "number") {
      keyArray = [keyArray, false, false, false, false];
    } else if (typeof keyArray === "string") {
      const split = keyArray.split(",");
      const code = parseInt(split[0], 10);
      const modifiers2 = [...split.slice(1).map((s) => s === "true"), false, false, false, false];
      const [alt, ctrl, shift, meta] = modifiers2;
      keyArray = [code, alt, ctrl, shift, meta];
    }
    const [keyCode, ...modifiers] = keyArray;
    const keyCombo = zipWith_default(modifiers, ["alt-", "ctrl-", "shift-", "command-"], (predicate, name2) => predicate && name2).filter((x) => x).join("");
    const keyName = keyCodes[keyCode] || String.fromCharCode(keyCode);
    return `${keyCombo}${keyName}`;
  }
  function checkKeysForEvent(event, keyArray) {
    if (typeof keyArray === "number") {
      keyArray = [keyArray, false, false, false, false];
    } else if (keyArray.length === 4) {
      keyArray.push(false);
    }
    const eventHash = hashKeyEvent(event);
    const arrayHash = hashKeyArray(keyArray);
    return eventHash === arrayHash;
  }
  function hashKeyEvent(event) {
    const keyArray = [event.keyCode, event.altKey, event.ctrlKey, event.shiftKey, event.metaKey];
    if (true) {
      if (keyArray[0] === 173) {
        keyArray[0] = 189;
      }
      if (keyArray[0] === 61) {
        keyArray[0] = 187;
      }
    }
    return hashKeyArray(keyArray);
  }
  function hashKeyArray(keyArray) {
    const length = 5;
    let hash = keyArray[0] * 2 ** length;
    for (const i2 of range(1, length)) {
      if (keyArray[i2]) {
        hash += 2 ** i2;
      }
    }
    return hash;
  }

  // lib/utils/localization.js
  var Dayjs = once_default(() => {
    const dayjs2 = require_dayjs_min();
    const localeCode = locale.toLowerCase();
    if (localeCode.startsWith("de")) dayjs2.locale(require_de());
    if (localeCode.startsWith("el")) dayjs2.locale(require_el());
    if (localeCode.startsWith("es")) dayjs2.locale(require_es());
    if (localeCode.startsWith("he")) dayjs2.locale(require_he());
    if (localeCode.startsWith("it")) dayjs2.locale(require_it());
    if (localeCode.startsWith("nl")) dayjs2.locale(require_nl());
    if (localeCode.startsWith("pl")) dayjs2.locale(require_pl());
    if (localeCode.startsWith("pt-br")) dayjs2.locale(require_pt_br());
    if (localeCode.startsWith("pt")) dayjs2.locale(require_pt());
    dayjs2.extend(require_relativeTime());
    dayjs2.extend(require_localizedFormat());
    return dayjs2;
  });
  var dayjs = (...args) => new Dayjs()(...args);
  function formatNumber(number) {
    return number.toLocaleString(locale);
  }
  function formatDate(date) {
    return dayjs(date).format("L");
  }
  function formatDateTime(date) {
    return dayjs(date).format("L LTS");
  }
  function formatDateDiff(from, to) {
    return dayjs(to).from(from, true);
  }
  function formatRelativeTime(from) {
    return dayjs(from).fromNow();
  }

  // lib/utils/math.js
  function numericalCompare(op, a2, b2) {
    switch (op) {
      case "==":
        return a2 == b2;
      // eslint-disable-line eqeqeq
      case "!=":
        return a2 != b2;
      // eslint-disable-line eqeqeq
      case ">":
        return a2 > b2;
      case "<":
        return a2 < b2;
      case ">=":
        return a2 >= b2;
      case "<=":
        return a2 <= b2;
      default:
        throw new Error(`Unhandled operator ${op}`);
    }
  }
  function inverseOperator(op) {
    switch (op) {
      case "==":
        return "!=";
      case "!=":
        return "==";
      case ">":
        return "<=";
      case "<":
        return ">=";
      case ">=":
        return "<";
      case "<=":
        return ">";
      default:
        throw new Error(`Unhandled operator ${op}`);
    }
  }
  function prettyOperator(op) {
    switch (op) {
      case "==":
        return "=";
      case "!=":
        return "\u2260";
      case ">":
        return ">";
      case "<":
        return "<";
      case ">=":
        return "\u2265";
      case "<=":
        return "\u2264";
      default:
        throw new Error(`Unhandled operator ${op}`);
    }
  }
  function interpolate(low, high, frac) {
    return (1 - frac) * low + frac * high;
  }
  function deinterpolate(low, high, value) {
    if (low === -Infinity && high === Infinity) {
      return 0.5;
    } else if (low === -Infinity) {
      return 1;
    } else if (high === Infinity) {
      return 0;
    }
    return (value - low) / (high - low);
  }
  function projectInto(fromLow, fromHigh, toLow, toHigh, value) {
    return interpolate(toLow, toHigh, deinterpolate(fromLow, fromHigh, value));
  }
  function positiveModulo(a2, n) {
    return (a2 % n + n) % n;
  }

  // lib/utils/options.js
  function indexOptionTable(option2, keyIndex, keyTransformer = (v) => v) {
    const source = option2.fields[keyIndex].type === "list" ? Array.from(expandKeys(option2.value)) : option2.value;
    return groupBy_default(source, (arr) => keyTransformer(arr[keyIndex]));
    function* expandKeys(nestedArray) {
      for (const arr of nestedArray) {
        for (const subKey of arr[keyIndex].split(",")) {
          yield [...arr.slice(0, keyIndex), subKey, ...arr.slice(keyIndex + 1)];
        }
      }
    }
  }

  // lib/utils/pageContextScript.js
  function stopPageContextScript(test, _parent, onlyChildrenOfParent) {
    const undo2 = [];
    let stopped = false;
    (async () => {
      if (_parent instanceof Promise) {
        _parent = await _parent;
      }
      const parent2 = _parent instanceof HTMLElement ? _parent : document.documentElement.querySelector(_parent) || await waitForDescendant(document.documentElement, _parent);
      if (stopped) return;
      (onlyChildrenOfParent ? watchForChildren : watchForDescendants)(parent2, "script", (ele) => {
        if (stopped) return;
        const script = downcast(ele, HTMLScriptElement);
        if (test(script)) {
          if (true) {
            script.addEventListener("beforescriptexecute", (e2) => {
              e2.preventDefault();
            });
          }
          const origType = script.type;
          script.type = "javascript/blocked";
          const origSrc = script.src;
          if (origSrc) script.src = "";
          const origContent = script.innerHTML;
          if (origContent) script.innerHTML = "";
          undo2.push(() => {
            const ele2 = document.createElement("script");
            ele2.type = origType;
            if (origSrc) ele2.src = origSrc;
            if (origContent) ele2.innerHTML = origContent;
            script.after(ele2);
            return waitForEvent(ele2, "load");
          });
        }
      });
    })();
    return {
      undo: () => {
        stopped = true;
        return Promise.allSettled(undo2.map((fn) => fn()));
      }
    };
  }

  // lib/utils/profiling.js
  var counter = 0;
  function markStart() {
    const tag = (++counter).toString();
    performance.mark(tag);
    return tag;
  }
  function markEnd(tag, name2) {
    performance.measure(name2, tag);
  }

  // lib/utils/storage.js
  async function maybePruneOldEntries(id2, entryStorage4, keepTrackDays = 30) {
    if (!await shouldPrune(id2)) return;
    const keepTrackPeriod = DAY * keepTrackDays;
    const now4 = Date.now();
    for (const [id3, data2] of Object.entries(await entryStorage4.getAll())) {
      const { updateTime } = data2 || {};
      if (!updateTime || now4 - updateTime > keepTrackPeriod) {
        entryStorage4.delete(id3);
      }
    }
  }
  async function shouldPrune(id2, interval = WEEK) {
    await new Promise((res) => {
      setTimeout(() => requestIdleCallback(res), 1e4);
    });
    const lastStorage = storage_exports.wrap(`last_prune.${id2}`, 0);
    const now4 = Date.now();
    if (now4 - await lastStorage.get() < interval) return false;
    lastStorage.set(now4);
    return true;
  }

  // lib/utils/subreddits.js
  var fakeSubreddits = [
    "mod",
    "friends",
    "random",
    "myrandom",
    "all",
    "contrib",
    "popular"
  ];
  function isFakeSubreddit(subreddit2) {
    return fakeSubreddits.some((fakeSubreddit) => fakeSubreddit === subreddit2.toLowerCase());
  }

  // lib/utils/value.js
  function firstValid(...vals) {
    return vals.find(
      (val) => val !== void 0 && val !== null && (typeof val !== "number" || !isNaN(val))
    );
  }

  // lib/constants/jsapi.js
  var JSAPI_CONSUMER_NAME = "reddit-enhancement-suite";

  // lib/utils/watchers_d2x.js
  var callbacks2 = {
    subreddit: [],
    postAuthor: [],
    post: []
  };
  function watchForRedditEvents(type, callback) {
    if (!callbacks2[type]) {
      callbacks2[type] = [];
    }
    callbacks2[type].push(callback);
  }
  function handleRedditEvent(event) {
    const { target, detail: { type, data: data2 } } = event;
    const fns = callbacks2[type];
    if (!fns) {
      if (false) {
        console.warn("Unhandled reddit event type:", type);
      }
      return;
    }
    let expandoId = `${type}|`;
    switch (type) {
      case "postAuthor":
        expandoId += data2.post.id;
        break;
      case "commentAuthor":
        expandoId += data2.comment.id;
        break;
      case "userHovercard":
        expandoId += `${data2.contextId}|${data2.user.id}`;
        break;
      case "subreddit":
      case "post":
      case "postModTools":
      default:
        expandoId += data2.id;
        break;
    }
    const update3 = target.expando && target.expando._.id === expandoId ? (target.expando._.update || 0) + 1 : 0;
    const expando2 = {
      ...data2,
      _: {
        id: expandoId,
        type,
        update: update3
      }
    };
    target.expando = expando2;
    const ownedTarget = target.querySelector(`[data-name="${JSAPI_CONSUMER_NAME}"]`);
    for (const fn of fns) {
      try {
        fn(ownedTarget, expando2);
      } catch (e2) {
        console.log(e2);
      }
    }
  }
  function initD2xWatcher() {
    document.addEventListener("reddit", handleRedditEvent, true);
    const meta = document.createElement("meta");
    meta.name = "jsapi.consumer";
    meta.content = JSAPI_CONSUMER_NAME;
    document.head.appendChild(meta);
    meta.dispatchEvent(new CustomEvent("reddit.ready"));
  }

  // lib/utils/bodyClasses.js
  var bodyClasses_exports = {};
  __export(bodyClasses_exports, {
    add: () => add,
    addMissing: () => addMissing,
    remove: () => remove2,
    toggle: () => toggle
  });
  var classes = /* @__PURE__ */ new Set();
  var addMissing = () => {
    document.body.classList.add(...difference_default(Array.from(classes), Array.from(document.body.classList)));
  };
  function add(...change) {
    for (const cls of change) classes.add(cls);
    if (document.documentElement) document.documentElement.classList.add(...change);
    if (document.body) document.body.classList.add(...change);
  }
  function remove2(...change) {
    for (const cls of change) classes.delete(cls);
    if (document.documentElement) document.documentElement.classList.remove(...change);
    if (document.body) document.body.classList.remove(...change);
  }
  function toggle(state, ...change) {
    if (state) add(...change);
    else remove2(...change);
  }

  // lib/utils/browserDetect.js
  var browserDetect_exports = {};
  __export(browserDetect_exports, {
    OS: () => OS,
    browser: () => browser,
    version: () => version
  });
  var versionSearchString;
  var searchString = (datas) => {
    const data2 = datas.find((data3) => {
      versionSearchString = data3.versionSearch || data3.identity;
      return data3.string ? data3.string.includes(data3.subString) : data3.prop;
    });
    return data2 ? data2.identity : void 0;
  };
  var searchVersion = (dataString) => {
    const index2 = dataString.indexOf(versionSearchString);
    if (index2 === -1) {
      return;
    }
    return parseFloat(dataString.substring(index2 + versionSearchString.length + 1));
  };
  var hasNavigator = typeof navigator !== "undefined";
  var browser = hasNavigator ? searchString(dataBrowser()) || "An unknown browser" : "An unknown browser without `navigator`";
  var version = hasNavigator ? searchVersion(navigator.userAgent) || searchVersion(navigator.appVersion) || "an unknown version" : "an unknown version without `navigator`";
  var OS = hasNavigator ? searchString(dataOS()) || "an unknown OS" : "an unknown OS without `navigator`";
  function dataBrowser() {
    return [
      {
        string: navigator.userAgent,
        subString: "OPR/",
        identity: "Opera"
      },
      {
        string: navigator.userAgent,
        subString: "Edge",
        identity: "Edge Spartan"
      },
      {
        string: navigator.userAgent,
        subString: "Edg",
        versionSearch: "Edg",
        identity: "Edge"
      },
      {
        string: navigator.userAgent,
        subString: "Chrome",
        identity: "Chrome"
      },
      {
        string: navigator.userAgent,
        subString: "OmniWeb",
        versionSearch: "OmniWeb/",
        identity: "OmniWeb"
      },
      {
        string: navigator.vendor,
        subString: "Apple",
        identity: "Safari",
        versionSearch: "Version"
      },
      {
        prop: window.opera,
        identity: "Opera",
        versionSearch: "Version"
      },
      {
        string: navigator.vendor,
        subString: "iCab",
        identity: "iCab"
      },
      {
        string: navigator.vendor,
        subString: "KDE",
        identity: "Konqueror"
      },
      {
        string: navigator.userAgent,
        subString: "Firefox",
        identity: "Firefox"
      },
      {
        string: navigator.vendor,
        subString: "Camino",
        identity: "Camino"
      },
      {
        // for newer Netscapes (6+)
        string: navigator.userAgent,
        subString: "Netscape",
        identity: "Netscape"
      },
      {
        string: navigator.userAgent,
        subString: "MSIE",
        identity: "Explorer",
        versionSearch: "MSIE"
      },
      {
        string: navigator.userAgent,
        subString: "Gecko",
        identity: "Mozilla",
        versionSearch: "rv"
      },
      {
        // for older Netscapes (4-)
        string: navigator.userAgent,
        subString: "Mozilla",
        identity: "Netscape",
        versionSearch: "Mozilla"
      }
    ];
  }
  function dataOS() {
    return [
      {
        string: navigator.platform,
        subString: "Win",
        identity: "Windows"
      },
      {
        string: navigator.platform,
        subString: "Mac",
        identity: "Mac"
      },
      {
        string: navigator.userAgent,
        subString: "iPhone",
        identity: "iPhone/iPod"
      },
      {
        string: navigator.platform,
        subString: "Linux",
        identity: "Linux"
      }
    ];
  }

  // lib/utils/createElement.js
  var createElement_exports = {};
  __export(createElement_exports, {
    fancyToggleButton: () => fancyToggleButton,
    icon: () => icon,
    sidebarSubscribeButtonWrappers: () => sidebarSubscribeButtonWrappers,
    tabMenuItem: () => tabMenuItem,
    table: () => table,
    toggleButton: () => toggleButton,
    undo: () => undo
  });
  function toggleButton(onClick2 = () => {
  }, fieldID, enabled2 = false, onText = i18n("toggleOn"), offText = i18n("toggleOff"), isTable = false, usesBatch = false) {
    const toggle7 = html`
		<div ${fieldID && _html`id="${fieldID}Container"`} class="toggleButton ${enabled2 && "enabled"}">
			<span class="toggleThumb"></span>
			<div class="toggleLabel ${usesBatch && "res-icon"}"
				${onText && _html`data-enabled-text="${onText}"`}
				${offText && _html`data-disabled-text="${offText}"`}
			></div>
			<input id="${fieldID}" name="${fieldID}" type="checkbox" ${enabled2 && "checked"}
				${isTable && _html`tableOption="true"`}
			/>
		</div>
	`;
    toggle7.addEventListener("click", () => {
      const checkbox = downcast(toggle7.querySelector("input[type=checkbox]"), HTMLInputElement);
      const enabling = !checkbox.checked;
      checkbox.checked = enabling;
      toggle7.classList.toggle("enabled", enabling);
      onClick2(enabling);
    });
    return toggle7;
  }
  function icon(charCode, tagName = "span", className2 = "", title = "") {
    const icon2 = document.createElement(tagName);
    icon2.className = className2;
    icon2.classList.add("res-icon");
    icon2.textContent = String.fromCharCode(charCode);
    icon2.setAttribute("title", title);
    return icon2;
  }
  function table(items2, callback) {
    items2 = [].concat(items2);
    const description = [];
    description.push("<table>");
    for (const item of items2.map(callback)) {
      if (typeof item === "string") {
        description.push(item);
      } else if (item) {
        description.push(...item);
      }
    }
    description.push("</table>");
    return description.join("\n");
  }
  function tabMenuItem({ text, aftercontent, className: className2, title, checked, onChange, order }) {
    const element = html`
		<li class="res-tabmenu-button ${checked && "selected"} ${className2}">
			<a
				${title && _html`title="${title}"`}
				${aftercontent && _html`aftercontent="${aftercontent}"`}
			>${text}</a>
		</li>
	`;
    addFloater(element, { container: "tabMenu", order });
    const a2 = element.querySelector("a");
    a2.addEventListener("click", () => {
      checked = !checked;
      element.classList.toggle("selected", checked);
      onChange(checked);
    });
    return a2;
  }
  function undo(buttonText, timeout = 5e3) {
    const restoreButton = html`<button class="res-button-undo">${buttonText}</button>`;
    let hideTimer2, fadeTimer;
    const scheduleFade = () => {
      hideTimer2 = setTimeout(() => {
        restoreButton.classList.add("transitionToTransparent");
        restoreButton.style.transitionDuration = "2s";
        fadeTimer = setTimeout(() => {
          restoreButton.remove();
        }, 2e3);
      }, timeout);
    };
    restoreButton.addEventListener("mouseenter", () => {
      clearTimeout(hideTimer2);
      clearTimeout(fadeTimer);
      restoreButton.classList.remove("transitionToTransparent");
    });
    restoreButton.addEventListener("mouseleave", scheduleFade);
    scheduleFade();
    document.body.append(restoreButton);
    return waitForEvent(restoreButton, "click").then(() => {
      restoreButton.remove();
    });
  }
  function fancyToggleButton(text, title, getState, callback) {
    const element = document.createElement("span");
    element.className = "res-fancy-toggle-button";
    element.title = title;
    let state;
    const refresh3 = (_state) => {
      if (state === _state) return;
      state = _state;
      if (state) {
        element.textContent = `-${text}`;
        element.classList.add("remove");
      } else {
        element.textContent = `+${text}`;
        element.classList.remove("remove");
      }
    };
    element.addEventListener("click", () => {
      callback(!state);
      refresh3(!state);
    });
    element.addEventListener("refresh", () => {
      refresh3(getState());
    });
    refresh3(getState());
    return element;
  }
  var sidebarSubscribeButtonWrappers = once_default(() => {
    const subreddit2 = currentSubreddit() || "";
    return [...document.querySelectorAll(".side .subscribe-button.fancy-toggle-button")].map((subButton) => {
      const thisSubredditFragment = subButton.getAttribute("data-sr_name") || subreddit2;
      const isMulti = subreddit2.includes("+") || isCurrentSubreddit("mod");
      const wrapper = html`<div subreddit="${thisSubredditFragment}" class="subButtons" style="margin: 0 !important;"></div>`;
      subButton.replaceWith(wrapper);
      wrapper.append(subButton);
      if (isMulti) wrapper.parentElement.append(wrapper);
      return wrapper;
    });
  });

  // lib/utils/alert.js
  var alert_exports = {};
  __export(alert_exports, {
    makeButton: () => makeButton,
    open: () => open
  });
  var open = mutex((content, { cancelable = false } = {}) => new Promise((resolve, reject) => {
    const overlay = html`<div id="alert_message_background"></div>`;
    const container2 = html`<div id="alert_message"></div>`;
    const buttons = document.createElement("div");
    container2.append(content instanceof HTMLElement ? content : html`<div>${safe(content)}</div>`, buttons);
    document.body.append(overlay, container2);
    function confirm2() {
      resolve();
      close3();
    }
    function cancel() {
      reject(new Error("User cancelled alert."));
      close3();
    }
    function close3() {
      document.body.removeEventListener("keyup", listenForEscape);
      container2.remove();
      overlay.remove();
    }
    function listenForEscape(e2) {
      if (e2.key === NAMED_KEYS.Escape) {
        if (cancelable) cancel();
        else confirm2();
      }
    }
    document.body.addEventListener("keyup", listenForEscape);
    if (cancelable) {
      buttons.style.float = "right";
      buttons.append(
        makeButton("cancel", "button-right", cancel),
        makeButton("confirm", "button-right", confirm2, true)
      );
    } else {
      buttons.append(makeButton("ok", void 0, confirm2, true));
    }
  }));
  function makeButton(text, cls, onClick2, focus) {
    const btn = document.createElement("input");
    btn.setAttribute("type", "button");
    btn.setAttribute("value", text);
    if (onClick2) btn.addEventListener("click", onClick2);
    if (cls) btn.classList.add(cls);
    if (focus) requestAnimationFrame(() => {
      btn.focus();
    });
    return btn;
  }

  // lib/utils/selectedThing.js
  var selectedThing_exports = {};
  __export(selectedThing_exports, {
    addListener: () => addListener2,
    current: () => current,
    move: () => move,
    refresh: () => refresh,
    selectClosestInView: () => selectClosestInView,
    set: () => set4,
    setScrollToSelectedThingOnLoad: () => setScrollToSelectedThingOnLoad
  });

  // lib/constants/sessionStorage.js
  var LAST_SELECTED_ENTRY_KEY = "RES.lastSelectedEntry";

  // lib/utils/selectedThing.js
  var current;
  var currentContainer;
  var previous;
  var listeners = { instantly: [], beforePaint: [], idle: [] };
  function addListener2(callback, when = "idle", priority = 0) {
    callback.priority = priority;
    listeners[when].push(callback);
    listeners[when].sort((a2, b2) => a2.priority - b2.priority);
  }
  var runCallbacks = (() => {
    function runListeners(listeners2, new_, old, opt) {
      for (const listener2 of listeners2) try {
        listener2(new_, old, opt);
      } catch (e2) {
        console.error(e2);
      }
    }
    function throttle4(throttler, listeners2) {
      let oldest;
      const throttled2 = throttler((new_, old, opt) => {
        runListeners(listeners2, new_, oldest, opt);
        oldest = null;
      });
      return (new_, old, opt) => {
        if (!oldest) oldest = old;
        throttled2(new_, old, opt);
      };
    }
    const runBeforePaint = throttle4(frameThrottle, listeners.beforePaint);
    const runIdle = throttle4(idleThrottle, listeners.idle);
    return (new_, old, opt) => {
      if (listeners.instantly.length) runListeners(listeners.instantly, new_, old, opt);
      if (listeners.beforePaint.length) runBeforePaint(new_, old, opt);
      if (listeners.idle.length) runIdle(new_, old, opt);
    };
  })();
  function set4(_new, options6 = { scrollStyle: "none" }, force = false) {
    if (!force && _new === current) return;
    previous = current;
    current = _new;
    currentContainer = current.element.closest(".sitetable");
    const direction = previous && previous.getDirectionOf(current);
    runCallbacks(current, previous, { ...options6, ...direction ? { direction } : void 0 });
  }
  var selectClosestInView = frameDebounce(() => {
    if (current && getPercentageVisibleYAxis(current.entry)) return;
    const closestToCurrent = current && current.getClosestVisible();
    if (closestToCurrent && getPercentageVisibleYAxis(closestToCurrent.entry)) {
      set4(closestToCurrent);
      return;
    }
    const things2 = Thing.visibleThings();
    const currentIndex = things2.indexOf(current);
    const closestThings = sortBy_default(things2.filter((thing) => thing.isVisible()), (thing) => Math.abs(things2.indexOf(thing) - currentIndex));
    const closestVisible = maxBy_default(closestThings, ({ entry }) => getPercentageVisibleYAxis(entry));
    if (closestVisible) set4(closestVisible);
  });
  function refresh() {
    if (!current || current.isVisible()) return;
    selectClosestInView();
  }
  var movers = {
    closestVisible: (thing) => thing.getClosestVisible(),
    up: (thing) => thing.getNext({ direction: "up" }),
    down: (thing) => thing.getNext({ direction: "down" }),
    top: () => Thing.visibleThings()[0],
    bottom: () => Thing.visibleThings().slice(-1)[0],
    upSibling: (thing) => thing.getNextSibling({ direction: "up" }) || thing.parent,
    downSibling: (thing) => thing.getClosest(thing.getNextSibling, { direction: "down" }),
    downParentSibling: (thing) => (thing.parent || thing).getClosest(thing.getNextSibling, { direction: "down" }),
    upThread: (thing) => thing.getThreadTop().getNextSibling({ direction: "up" }) || thing.getThreadTop(),
    downThread: (thing) => thing.getThreadTop().getNextSibling({ direction: "down" }),
    toTopComment: (thing) => thing.getThreadTop(),
    toParent: (thing) => thing.parent,
    previous: () => previous
  };
  function move(direction, options6, fallback) {
    if (!current || !current.element.offsetParent) {
      selectClosestInView();
      return;
    }
    const targetFn = movers[direction];
    if (!current && targetFn.length) {
      if (!fallback || !fallback()) throw new Error("Function only works when an entry is current");
    }
    const target = targetFn(current);
    if (!target) {
      if (fallback && fallback()) return;
      if (current) return set4(current, { scrollStyle: "middle" });
      throw new Error("Could not find a target");
    } else if (current === target) {
      if (current) return set4(current, { scrollStyle: "middle" });
      throw new Error("Target already current");
    }
    set4(target, options6);
  }
  var anchor;
  addListener2((current2, previous2, { scrollStyle }) => {
    if (previous2 && current2 !== previous2 && ["none", "adopt"].includes(scrollStyle) && (current2.element.classList.contains("res-thing-partial") || previous2.element.classList.contains("res-thing-partial"))) {
      anchor = {
        to: current2.entry.getBoundingClientRect().top,
        from: previous2.entry.getBoundingClientRect().top
      };
    } else {
      anchor = void 0;
    }
  }, "instantly", -Infinity);
  addListener2((current2, previous2, { direction, scrollStyle }) => {
    scrollToElement(current2.entry, previous2 && previous2.entry, { scrollStyle, direction, anchor, waitTillVisible: true });
  }, "beforePaint", 9);
  addListener2((current2) => {
    current2.runSurroundingTasks();
  }, "instantly");
  watchForThings(["comment"], throttle_default((thing) => {
    if (!current) return;
    if (current && document.contains(current.element)) return;
    if (currentContainer && currentContainer !== thing.element.closest(".sitetable")) return;
    set4(thing);
  }, 100, { leading: true, trailing: false }), { immediate: true });
  var lastSelectedKey = `${LAST_SELECTED_ENTRY_KEY}-${location.pathname}`;
  var getLastSelectedId = () => sessionStorage[lastSelectedKey];
  var scrollToSelectedThingOnLoad = false;
  var setScrollToSelectedThingOnLoad = (v) => {
    scrollToSelectedThingOnLoad = v;
  };
  var lastSelectedId = getLastSelectedId();
  watchForThings(null, (thing) => {
    if (current) return;
    if (!lastSelectedId) return set4(thing);
    if (thing.getFullname() !== lastSelectedId) return;
    if (scrollToSelectedThingOnLoad) history.scrollRestoration = "manual";
    set4(thing, { scrollStyle: history.scrollRestoration === "manual" ? "legacy" : "none" });
  }, { immediate: true });
  addListener2((current2) => {
    const id2 = current2.getFullname();
    if (!id2) return;
    sessionStorage[lastSelectedKey] = id2;
  }, "beforePaint");
  addListener2((current2, previous2) => {
    if (previous2) {
      previous2.entry.classList.remove("res-selected");
      previous2.element.classList.remove("res-selected");
    }
    if (current2) {
      current2.entry.classList.add("res-selected");
      current2.element.classList.add("res-selected");
    }
  }, "instantly");

  // lib/utils/table.js
  var table_exports = {};
  __export(table_exports, {
    RESTable: () => RESTable,
    sortByColumn: () => sortByColumn
  });
  var RESTables = /* @__PURE__ */ new Map();
  var RESTable = class {
    _data;
    getRow;
    page = 0;
    pageSize = 100;
    tbody;
    element;
    columns = [];
    // columns in shown order
    filters = [];
    onRowsChanges = [];
    sortBy;
    sortDirection = "asc";
    data = memoize_default(() => {
      const data2 = this._data.filter((v) => this.filters.every((filter) => filter(v)));
      if (this.sortBy) {
        const getValue3 = memoize_default((r) => {
          const v = this.getRow(r)[this.sortBy];
          return v instanceof HTMLElement ? v.hasAttribute("sort-value") ? v.getAttribute("sort-value") : v.textContent : String(v);
        });
        data2.sort((a2, b2) => getValue3(a2).localeCompare(getValue3(b2), void 0, { numeric: true }));
      }
      if (this.sortDirection === "desc") {
        data2.reverse();
      }
      return data2;
    });
    constructor(headers, data2, getRow, opts) {
      this._data = data2;
      this.getRow = getRow;
      Object.assign(this, opts);
      const table2 = this.element = document.createElement("table");
      table2.style.width = "100%";
      const thead = document.createElement("thead");
      const tbody = this.tbody = downcast(document.createElement("tbody"), HTMLTableSectionElement);
      table2.append(thead, tbody);
      const tr = document.createElement("tr");
      thead.append(tr);
      for (const [id2, label] of Object.entries(headers)) {
        const th = document.createElement("th");
        th.addEventListener("click", sortByColumn);
        th.style.cursor = "pointer";
        th.textContent = label;
        this.columns.push(id2);
        tr.append(th);
        if (this.sortBy === id2) th.classList.add(`sort-${this.sortDirection}`);
      }
      RESTables.set(table2, this);
      this.refresh();
    }
    refresh() {
      this.data.cache.clear();
      this.updatePage();
    }
    start() {
      this.page = 0;
      this.refresh();
    }
    updatePage = frameThrottle(() => {
      this.page = positiveModulo(this.page, Math.ceil(this.data().length / this.pageSize)) || 0;
      const start2 = this.page * this.pageSize || 0;
      empty(this.tbody);
      for (const rawRow of this.data().slice(start2, start2 + this.pageSize)) {
        const tr = document.createElement("tr");
        this.tbody.append(tr);
        const row = this.getRow(rawRow);
        for (const id2 of this.columns) {
          const td = document.createElement("td");
          const content = row[id2];
          if (content instanceof HTMLElement) td.append(content);
          else td.textContent = content;
          tr.append(td);
        }
      }
      for (const observer of this.onRowsChanges) observer();
    });
    createSearchElement(valueGetter, placeholder, focus = false) {
      const search = document.createElement("input");
      search.setAttribute("placeholder", placeholder);
      if (focus) requestAnimationFrame(() => {
        search.focus();
      });
      let lastFilter;
      search.addEventListener("input", () => {
        let regex;
        if (string_exports.regexRegex.test(search.value)) {
          const [, str, flags = ""] = string_exports.regexRegex.exec(search.value);
          regex = new RegExp(str, flags);
        } else {
          regex = new RegExp(escapeRegExp_default(search.value), "i");
        }
        if (lastFilter) pull_default(this.filters, lastFilter);
        if (search.value) this.filters.push(lastFilter = (data2) => regex.test(valueGetter(data2)));
        this.start();
      });
      return search;
    }
    createSelectFilterElement(filters) {
      const ele = string_exports.html`<div>
			Show only:
			<select>${filters.map(({ name: name2, initialSelected }) => string_exports._html`<option ${initialSelected ? "selected" : ""}>${name2}</option>`)}</select>
		</div>`;
      const filterSelect = downcast(ele.querySelector("select"), HTMLSelectElement);
      let lastFilter;
      this.filters.push(lastFilter = filters[filterSelect.selectedIndex].filter);
      filterSelect.addEventListener("change", () => {
        pull_default(this.filters, lastFilter);
        const filter = filters[filterSelect.selectedIndex].filter;
        this.filters.push(lastFilter = filter);
        this.start();
      });
      return ele;
    }
    createPaginationElement() {
      const ele = string_exports.html`<div class="res-step-container">
			<div class="res-step res-step-previous" role="button"></div>
			<div class="res-step-progress">
				<span class="res-step-position"></span> of <span class="res-step-total"></span>
			</div>
			<div class="res-step res-step-next" role="button"></div>
		</div>`;
      ele.querySelector(".res-step-previous").addEventListener("click", () => {
        this.page--;
        this.updatePage();
      });
      ele.querySelector(".res-step-next").addEventListener("click", () => {
        this.page++;
        this.updatePage();
      });
      const position = ele.querySelector(".res-step-position");
      const total = ele.querySelector(".res-step-total");
      const refresh3 = () => {
        const pages2 = Math.ceil(this.data().length / this.pageSize);
        ele.setAttribute("first-piece", String(this.page === 0));
        ele.setAttribute("last-piece", String(this.page === pages2 - 1));
        position.textContent = String(this.page + 1);
        total.textContent = String(pages2 || 1);
      };
      this.onRowsChanges.push(refresh3);
      return ele;
    }
    sort(by, reverseCurrent) {
      this.sortBy = typeof by === "number" ? this.columns[by] : by;
      this.sortDirection = reverseCurrent ? this.sortDirection === "asc" ? "desc" : "asc" : "asc";
      this.start();
    }
  };
  function sortByColumn({ target: sortColumn }) {
    const table2 = downcast(sortColumn.closest("table"), HTMLTableElement);
    const reverseCurrent = sortColumn.classList.contains("sort-asc") || sortColumn.classList.contains("sort-asc");
    const tableRES = RESTables.get(table2);
    if (tableRES) {
      const index2 = [...downcast(sortColumn.parentElement, HTMLElement).children].indexOf(sortColumn);
      tableRES.sort(index2, reverseCurrent);
    } else {
      const tbody = table2.querySelector("tbody");
      const columns = Array.from(table2.querySelectorAll("thead th"));
      const rows = Array.from(tbody.querySelectorAll("tr"));
      if (reverseCurrent) {
        rows.reverse();
      } else {
        const index2 = columns.indexOf(sortColumn);
        const getCellValue = memoize_default((row) => {
          const cell = row.querySelectorAll("td")[index2];
          return cell.textContent;
        });
        rows.sort((rowA, rowB) => getCellValue(rowA).localeCompare(getCellValue(rowB), void 0, { numeric: true }));
      }
      tbody.append(...rows);
    }
    if (reverseCurrent) {
      sortColumn.classList.toggle("sort-asc");
      sortColumn.classList.toggle("sort-desc");
    } else {
      const previous2 = table2.querySelector(".sort-asc, .sort-desc");
      if (previous2) previous2.classList.remove("sort-asc");
      if (previous2) previous2.classList.remove("sort-desc");
      sortColumn.classList.add("sort-asc");
    }
  }

  // lib/utils/caseBuilder.js
  var caseBuilder_exports = {};
  __export(caseBuilder_exports, {
    drawBuilderBlock: () => drawBuilderBlock,
    drawOptionBuilder: () => drawOptionBuilder,
    readBuilderBlock: () => readBuilderBlock,
    readBuilderItem: () => readBuilderItem
  });
  var import_jquery = __toESM(require_jquery(), 1);

  // node_modules/sortablejs/modular/sortable.core.esm.js
  function ownKeys(object, enumerableOnly) {
    var keys3 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  var version2 = "1.15.3";
  function userAgent(pattern) {
    if (typeof window !== "undefined" && window.navigator) {
      return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
    }
  }
  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
  var captureMode = {
    capture: false,
    passive: false
  };
  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function matches(el, selector) {
    if (!selector) return;
    selector[0] === ">" && (selector = selector.substring(1));
    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }
    return false;
  }
  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }
  function closest(el, selector, ctx, includeCTX) {
    if (el) {
      ctx = ctx || document;
      do {
        if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
          return el;
        }
        if (el === ctx) break;
      } while (el = getParentOrHost(el));
    }
    return null;
  }
  var R_SPACE = /\s+/g;
  function toggleClass(el, name2, state) {
    if (el && name2) {
      if (el.classList) {
        el.classList[state ? "add" : "remove"](name2);
      } else {
        var className2 = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
        el.className = (className2 + (state ? " " + name2 : "")).replace(R_SPACE, " ");
      }
    }
  }
  function css(el, prop, val) {
    var style = el && el.style;
    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, "");
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf("webkit") === -1) {
          prop = "-webkit-" + prop;
        }
        style[prop] = val + (typeof val === "string" ? "" : "px");
      }
    }
  }
  function matrix(el, selfOnly) {
    var appliedTransforms = "";
    if (typeof el === "string") {
      appliedTransforms = el;
    } else {
      do {
        var transform2 = css(el, "transform");
        if (transform2 && transform2 !== "none") {
          appliedTransforms = transform2 + " " + appliedTransforms;
        }
      } while (!selfOnly && (el = el.parentNode));
    }
    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    return matrixFn && new matrixFn(appliedTransforms);
  }
  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName), i2 = 0, n = list.length;
      if (iterator) {
        for (; i2 < n; i2++) {
          iterator(list[i2], i2);
        }
      }
      return list;
    }
    return [];
  }
  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container2) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left, bottom, right, height, width;
    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left = elRect.left;
      bottom = elRect.bottom;
      right = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }
    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      container2 = container2 || el.parentNode;
      if (!IE11OrLess) {
        do {
          if (container2 && container2.getBoundingClientRect && (css(container2, "transform") !== "none" || relativeToNonStaticParent && css(container2, "position") !== "static")) {
            var containerRect = container2.getBoundingClientRect();
            top -= containerRect.top + parseInt(css(container2, "border-top-width"));
            left -= containerRect.left + parseInt(css(container2, "border-left-width"));
            bottom = top + elRect.height;
            right = left + elRect.width;
            break;
          }
        } while (container2 = container2.parentNode);
      }
    }
    if (undoScale && el !== window) {
      var elMatrix = matrix(container2 || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
      if (elMatrix) {
        top /= scaleY;
        left /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top + height;
        right = left + width;
      }
    }
    return {
      top,
      left,
      bottom,
      right,
      width,
      height
    };
  }
  function isScrolledPast(el, elSide, parentSide) {
    var parent2 = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
    while (parent2) {
      var parentSideVal = getRect(parent2)[parentSide], visible2 = void 0;
      if (parentSide === "top" || parentSide === "left") {
        visible2 = elSideVal >= parentSideVal;
      } else {
        visible2 = elSideVal <= parentSideVal;
      }
      if (!visible2) return parent2;
      if (parent2 === getWindowScrollingElement()) break;
      parent2 = getParentAutoScrollElement(parent2, false);
    }
    return false;
  }
  function getChild(el, childNum, options6, includeDragEl) {
    var currentChild = 0, i2 = 0, children = el.children;
    while (i2 < children.length) {
      if (children[i2].style.display !== "none" && children[i2] !== Sortable.ghost && (includeDragEl || children[i2] !== Sortable.dragged) && closest(children[i2], options6.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i2];
        }
        currentChild++;
      }
      i2++;
    }
    return null;
  }
  function lastChild(el, selector) {
    var last2 = el.lastElementChild;
    while (last2 && (last2 === Sortable.ghost || css(last2, "display") === "none" || selector && !matches(last2, selector))) {
      last2 = last2.previousElementSibling;
    }
    return last2 || null;
  }
  function index(el, selector) {
    var index2 = 0;
    if (!el || !el.parentNode) {
      return -1;
    }
    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
        index2++;
      }
    }
    return index2;
  }
  function getRelativeScrollOffset(el) {
    var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
    if (el) {
      do {
        var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }
    return [offsetLeft, offsetTop];
  }
  function indexOfObject(arr, obj) {
    for (var i2 in arr) {
      if (!arr.hasOwnProperty(i2)) continue;
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key]) return Number(i2);
      }
    }
    return -1;
  }
  function getParentAutoScrollElement(el, includeSelf) {
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;
    do {
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);
        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
          if (gotSelf || includeSelf) return elem;
          gotSelf = true;
        }
      }
    } while (elem = elem.parentNode);
    return getWindowScrollingElement();
  }
  function extend(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }
  var _throttleTimeout;
  function throttle3(callback, ms) {
    return function() {
      if (!_throttleTimeout) {
        var args = arguments, _this = this;
        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }
        _throttleTimeout = setTimeout(function() {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }
  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }
  function scrollBy(el, x, y) {
    el.scrollLeft += x;
    el.scrollTop += y;
  }
  function clone2(el) {
    var Polymer = window.Polymer;
    var $51 = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($51) {
      return $51(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }
  function getChildContainingRectFromElement(container2, options6, ghostEl2) {
    var rect = {};
    Array.from(container2.children).forEach(function(child) {
      var _rect$left, _rect$top, _rect$right, _rect$bottom;
      if (!closest(child, options6.draggable, container2, false) || child.animated || child === ghostEl2) return;
      var childRect = getRect(child);
      rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
      rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
      rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
      rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
    });
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
  function AnimationStateManager() {
    var animationStates = [], animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation) return;
        var children = [].slice.call(this.el.children);
        children.forEach(function(child) {
          if (css(child, "display") === "none" || child === Sortable.ghost) return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });
          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);
            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }
          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target
        }), 1);
      },
      animateAll: function animateAll(callback) {
        var _this = this;
        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === "function") callback();
          return;
        }
        var animating = false, animationTime = 0;
        animationStates.forEach(function(state) {
          var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
          if (targetMatrix) {
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }
          target.toRect = toRect;
          if (target.thisAnimationDuration) {
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          }
          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;
            if (!time) {
              time = _this.options.animation;
            }
            _this.animate(target, animatingRect, toRect, time);
          }
          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function() {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);
        if (!animating) {
          if (typeof callback === "function") callback();
        } else {
          animationCallbackId = setTimeout(function() {
            if (typeof callback === "function") callback();
          }, animationTime);
        }
        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, "transition", "");
          css(target, "transform", "");
          var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
          this.forRepaintDummy = repaint(target);
          css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
          css(target, "transform", "translate3d(0,0,0)");
          typeof target.animated === "number" && clearTimeout(target.animated);
          target.animated = setTimeout(function() {
            css(target, "transition", "");
            css(target, "transform", "");
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }
  function repaint(target) {
    return target.offsetWidth;
  }
  function calculateRealTime(animatingRect, fromRect, toRect, options6) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options6.animation;
  }
  var plugins = [];
  var defaults = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      for (var option2 in defaults) {
        if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
          plugin[option2] = defaults[option2];
        }
      }
      plugins.forEach(function(p) {
        if (p.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;
      this.eventCanceled = false;
      evt.cancel = function() {
        _this.eventCanceled = true;
      };
      var eventNameGlobal = eventName + "Global";
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName]) return;
        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable
          }, evt));
        }
        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults2, options6) {
      plugins.forEach(function(plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized;
        _extends(defaults2, initialized.defaults);
      });
      for (var option2 in sortable.options) {
        if (!sortable.options.hasOwnProperty(option2)) continue;
        var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
        if (typeof modified !== "undefined") {
          sortable.options[option2] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name2, sortable) {
      var eventProperties = {};
      plugins.forEach(function(plugin) {
        if (typeof plugin.eventProperties !== "function") return;
        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name2));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name2, value) {
      var modifiedValue;
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName]) return;
        if (plugin.optionListeners && typeof plugin.optionListeners[name2] === "function") {
          modifiedValue = plugin.optionListeners[name2].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }
  };
  function dispatchEvent(_ref) {
    var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl2 && rootEl2[expando];
    if (!sortable) return;
    var evt, options6 = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name2, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent(name2, true, true);
    }
    evt.to = toEl || rootEl2;
    evt.from = fromEl || rootEl2;
    evt.item = targetEl || rootEl2;
    evt.clone = cloneEl2;
    evt.oldIndex = oldIndex2;
    evt.newIndex = newIndex2;
    evt.oldDraggableIndex = oldDraggableIndex2;
    evt.newDraggableIndex = newDraggableIndex2;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
    for (var option2 in allEventProperties) {
      evt[option2] = allEventProperties[option2];
    }
    if (rootEl2) {
      rootEl2.dispatchEvent(evt);
    }
    if (options6[onName]) {
      options6[onName].call(sortable, evt);
    }
  }
  var _excluded = ["evt"];
  var pluginEvent2 = function pluginEvent3(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data2 = _objectWithoutProperties(_ref, _excluded);
    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      dragStarted: moved,
      putSortable,
      activeSortable: Sortable.active,
      originalEvent,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name2) {
        _dispatchEvent({
          sortable,
          name: name2,
          originalEvent
        });
      }
    }, data2));
  };
  function _dispatchEvent(info) {
    dispatchEvent(_objectSpread2({
      putSortable,
      cloneEl,
      targetEl: dragEl,
      rootEl,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex
    }, info));
  }
  var dragEl;
  var parentEl;
  var ghostEl;
  var rootEl;
  var nextEl;
  var lastDownEl;
  var cloneEl;
  var cloneHidden;
  var oldIndex;
  var newIndex;
  var oldDraggableIndex;
  var newDraggableIndex;
  var activeGroup;
  var putSortable;
  var awaitingDragStarted = false;
  var ignoreNextClick = false;
  var sortables = [];
  var tapEvt;
  var touchEvt;
  var lastDx;
  var lastDy;
  var tapDistanceLeft;
  var tapDistanceTop;
  var moved;
  var lastTarget;
  var lastDirection;
  var pastFirstInvertThresh = false;
  var isCircumstantialInvert = false;
  var targetMoveDistance;
  var ghostRelativeParent;
  var ghostRelativeParentInitialScroll = [];
  var _silent = false;
  var savedInputChecked = [];
  var documentExists = typeof document !== "undefined";
  var PositionGhostAbsolutely = IOS;
  var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
  var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
  var supportCssPointerEvents = function() {
    if (!documentExists) return;
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement("x");
    el.style.cssText = "pointer-events:auto";
    return el.style.pointerEvents === "auto";
  }();
  var _detectDirection = function _detectDirection2(el, options6) {
    var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options6), child2 = getChild(el, 1, options6), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === "flex") {
      return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
    }
    if (elCSS.display === "grid") {
      return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
      var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
      return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
    }
    return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
  };
  var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  };
  var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
    var ret;
    sortables.some(function(sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  };
  var _prepareGroup = function _prepareGroup2(options6) {
    function toFn(value, pull2) {
      return function(to, from, dragEl2, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull2 || sameGroup)) {
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull2 && value === "clone") {
          return value;
        } else if (typeof value === "function") {
          return toFn(value(to, from, dragEl2, evt), pull2)(to, from, dragEl2, evt);
        } else {
          var otherGroup = (pull2 ? to : from).options.group.name;
          return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options6.group;
    if (!originalGroup || _typeof2(originalGroup) != "object") {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options6.group = group;
  };
  var _hideGhostForTarget = function _hideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "none");
    }
  };
  var _unhideGhostForTarget = function _unhideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "");
    }
  };
  if (documentExists && !ChromeForAndroid) {
    document.addEventListener("click", function(evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }
  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;
      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
      if (nearest) {
        var event = {};
        for (var i2 in evt) {
          if (evt.hasOwnProperty(i2)) {
            event[i2] = evt[i2];
          }
        }
        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;
        nearest[expando]._onDragOver(event);
      }
    }
  };
  var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  function Sortable(el, options6) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
    }
    this.el = el;
    this.options = options6 = _extends({}, options6);
    el[expando] = this;
    var defaults2 = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el, this.options);
      },
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      ignore: "a, img",
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData2(dataTransfer, dragEl2) {
        dataTransfer.setData("Text", dragEl2.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: "data-id",
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults2);
    for (var name2 in defaults2) {
      !(name2 in options6) && (options6[name2] = defaults2[name2]);
    }
    _prepareGroup(options6);
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
    this.nativeDraggable = options6.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) {
      this.options.touchStartThreshold = 1;
    }
    if (options6.supportPointer) {
      on(el, "pointerdown", this._onTapStart);
    } else {
      on(el, "mousedown", this._onTapStart);
      on(el, "touchstart", this._onTapStart);
    }
    if (this.nativeDraggable) {
      on(el, "dragover", this);
      on(el, "dragenter", this);
    }
    sortables.push(this.el);
    options6.store && options6.store.get && this.sort(options6.store.get(this) || []);
    _extends(this, AnimationStateManager());
  }
  Sortable.prototype = /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(evt) {
      if (!evt.cancelable) return;
      var _this = this, el = this.el, options6 = this.options, preventOnFilter = options6.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options6.filter;
      _saveInputCheckedState(el);
      if (dragEl) {
        return;
      }
      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options6.disabled) {
        return;
      }
      if (originalTarget.isContentEditable) {
        return;
      }
      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
        return;
      }
      target = closest(target, options6.draggable, el, false);
      if (target && target.animated) {
        return;
      }
      if (lastDownEl === target) {
        return;
      }
      oldIndex = index(target);
      oldDraggableIndex = index(target, options6.draggable);
      if (typeof filter === "function") {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: "filter",
            targetEl: target,
            toEl: el,
            fromEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return;
        }
      } else if (filter) {
        filter = filter.split(",").some(function(criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);
          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: "filter",
              targetEl: target,
              fromEl: el,
              toEl: el
            });
            pluginEvent2("filter", _this, {
              evt
            });
            return true;
          }
        });
        if (filter) {
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return;
        }
      }
      if (options6.handle && !closest(originalTarget, options6.handle, el, false)) {
        return;
      }
      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(evt, touch, target) {
      var _this = this, el = _this.el, options6 = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options6.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style["will-change"] = "all";
        dragStartFn = function dragStartFn2() {
          pluginEvent2("delayEnded", _this, {
            evt
          });
          if (Sortable.eventCanceled) {
            _this._onDrop();
            return;
          }
          _this._disableDelayedDragEvents();
          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          }
          _this._triggerDragStart(evt, touch);
          _dispatchEvent({
            sortable: _this,
            name: "choose",
            originalEvent: evt
          });
          toggleClass(dragEl, options6.chosenClass, true);
        };
        options6.ignore.split(",").forEach(function(criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mouseup", _this._onDrop);
        on(ownerDocument, "touchend", _this._onDrop);
        on(ownerDocument, "touchcancel", _this._onDrop);
        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }
        pluginEvent2("delayStart", this, {
          evt
        });
        if (options6.delay && (!options6.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          }
          on(ownerDocument, "mouseup", _this._disableDelayedDrag);
          on(ownerDocument, "touchend", _this._disableDelayedDrag);
          on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
          on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
          on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
          options6.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options6.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e2) {
      var touch = e2.touches ? e2.touches[0] : e2;
      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);
      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._disableDelayedDrag);
      off(ownerDocument, "touchend", this._disableDelayedDrag);
      off(ownerDocument, "touchcancel", this._disableDelayedDrag);
      off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(evt, touch) {
      touch = touch || evt.pointerType == "touch" && evt;
      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._onTouchMove);
        } else if (touch) {
          on(document, "touchmove", this._onTouchMove);
        } else {
          on(document, "mousemove", this._onTouchMove);
        }
      } else {
        on(dragEl, "dragend", this);
        on(rootEl, "dragstart", this._onDragStart);
      }
      try {
        if (document.selection) {
          _nextTick(function() {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {
      }
    },
    _dragStarted: function _dragStarted(fallback, evt) {
      awaitingDragStarted = false;
      if (rootEl && dragEl) {
        pluginEvent2("dragStarted", this, {
          evt
        });
        if (this.nativeDraggable) {
          on(document, "dragover", _checkOutsideTargetEl);
        }
        var options6 = this.options;
        !fallback && toggleClass(dragEl, options6.dragClass, false);
        toggleClass(dragEl, options6.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost();
        _dispatchEvent({
          sortable: this,
          name: "start",
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        _hideGhostForTarget();
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent2 = target;
        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent2) break;
          parent2 = target;
        }
        dragEl.parentNode[expando]._isOutsideThisEl(target);
        if (parent2) {
          do {
            if (parent2[expando]) {
              var inserted = void 0;
              inserted = parent2[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target,
                rootEl: parent2
              });
              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }
            target = parent2;
          } while (parent2 = getParentOrHost(parent2));
        }
        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(evt) {
      if (tapEvt) {
        var options6 = this.options, fallbackTolerance = options6.fallbackTolerance, fallbackOffset = options6.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }
          this._onDragStart(evt, true);
        }
        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }
          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, "webkitTransform", cssMatrix);
          css(ghostEl, "mozTransform", cssMatrix);
          css(ghostEl, "msTransform", cssMatrix);
          css(ghostEl, "transform", cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }
        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      if (!ghostEl) {
        var container2 = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container2), options6 = this.options;
        if (PositionGhostAbsolutely) {
          ghostRelativeParent = container2;
          while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }
          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }
          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }
        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options6.ghostClass, false);
        toggleClass(ghostEl, options6.fallbackClass, true);
        toggleClass(ghostEl, options6.dragClass, true);
        css(ghostEl, "transition", "");
        css(ghostEl, "transform", "");
        css(ghostEl, "box-sizing", "border-box");
        css(ghostEl, "margin", 0);
        css(ghostEl, "top", rect.top);
        css(ghostEl, "left", rect.left);
        css(ghostEl, "width", rect.width);
        css(ghostEl, "height", rect.height);
        css(ghostEl, "opacity", "0.8");
        css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
        css(ghostEl, "zIndex", "100000");
        css(ghostEl, "pointerEvents", "none");
        Sortable.ghost = ghostEl;
        container2.appendChild(ghostEl);
        css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
      }
    },
    _onDragStart: function _onDragStart(evt, fallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options6 = _this.options;
      pluginEvent2("dragStart", this, {
        evt
      });
      if (Sortable.eventCanceled) {
        this._onDrop();
        return;
      }
      pluginEvent2("setupClone", this);
      if (!Sortable.eventCanceled) {
        cloneEl = clone2(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style["will-change"] = "";
        this._hideClone();
        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      }
      _this.cloneId = _nextTick(function() {
        pluginEvent2("clone", _this);
        if (Sortable.eventCanceled) return;
        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }
        _this._hideClone();
        _dispatchEvent({
          sortable: _this,
          name: "clone"
        });
      });
      !fallback && toggleClass(dragEl, options6.dragClass, true);
      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        off(document, "mouseup", _this._onDrop);
        off(document, "touchend", _this._onDrop);
        off(document, "touchcancel", _this._onDrop);
        if (dataTransfer) {
          dataTransfer.effectAllowed = "move";
          options6.setData && options6.setData.call(_this, dataTransfer, dragEl);
        }
        on(document, "drop", _this);
        css(dragEl, "transform", "translateZ(0)");
      }
      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, "selectstart", _this);
      moved = true;
      if (Safari) {
        css(document.body, "user-select", "none");
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(evt) {
      var el = this.el, target = evt.target, dragRect, targetRect, revert, options6 = this.options, group = options6.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options6.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
      if (_silent) return;
      function dragOverEvent(name2, extra) {
        pluginEvent2(name2, _this, _objectSpread2({
          evt,
          isOwner,
          axis: vertical ? "vertical" : "horizontal",
          revert,
          dragRect,
          targetRect,
          canSort,
          fromSortable,
          target,
          completed,
          onMove: function onMove(target2, after2) {
            return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
          },
          changed
        }, extra));
      }
      function capture() {
        dragOverEvent("dragOverAnimationCapture");
        _this.captureAnimationState();
        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      }
      function completed(insertion) {
        dragOverEvent("dragOverCompleted", {
          insertion
        });
        if (insertion) {
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }
          if (_this !== fromSortable) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options6.ghostClass, true);
          }
          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          }
          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }
          _this.animateAll(function() {
            dragOverEvent("dragOverAnimationComplete");
            _this._ignoreWhileAnimating = null;
          });
          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        }
        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        }
        if (!options6.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
          !insertion && nearestEmptyInsertDetectEvent(evt);
        }
        !options6.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      }
      function changed() {
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options6.draggable);
        _dispatchEvent({
          sortable: _this,
          name: "change",
          toEl: el,
          newIndex,
          newDraggableIndex,
          originalEvent: evt
        });
      }
      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }
      target = closest(target, options6.draggable, el, true);
      dragOverEvent("dragOver");
      if (Sortable.eventCanceled) return completedFired;
      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }
      ignoreNextClick = false;
      if (activeSortable && !options6.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === "vertical";
        dragRect = getRect(dragEl);
        dragOverEvent("dragOverValid");
        if (Sortable.eventCanceled) return completedFired;
        if (revert) {
          parentEl = rootEl;
          capture();
          this._hideClone();
          dragOverEvent("revert");
          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }
          return completed(true);
        }
        var elLastChild = lastChild(el, options6.draggable);
        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          if (elLastChild === dragEl) {
            return completed(false);
          }
          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }
          if (target) {
            targetRect = getRect(target);
          }
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            if (elLastChild && elLastChild.nextSibling) {
              el.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el.appendChild(dragEl);
            }
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
          var firstChild = getChild(el, 0, options6, true);
          if (firstChild === dragEl) {
            return completed(false);
          }
          target = firstChild;
          targetRect = getRect(target);
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el.insertBefore(dragEl, firstChild);
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options6.invertSwap || differentLevel;
          }
          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options6.swapThreshold, options6.invertedSwapThreshold == null ? options6.swapThreshold : options6.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;
          if (direction !== 0) {
            var dragIndex = index(dragEl);
            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
          }
          if (direction === 0 || sibling === target) {
            return completed(false);
          }
          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling, after = false;
          after = direction === 1;
          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }
            _silent = true;
            setTimeout(_unsilent, 30);
            capture();
            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            }
            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }
            parentEl = dragEl.parentNode;
            if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }
            changed();
            return completed(true);
          }
        }
        if (el.contains(dragEl)) {
          return completed(false);
        }
      }
      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, "mousemove", this._onTouchMove);
      off(document, "touchmove", this._onTouchMove);
      off(document, "pointermove", this._onTouchMove);
      off(document, "dragover", nearestEmptyInsertDetectEvent);
      off(document, "mousemove", nearestEmptyInsertDetectEvent);
      off(document, "touchmove", nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._onDrop);
      off(ownerDocument, "touchend", this._onDrop);
      off(ownerDocument, "pointerup", this._onDrop);
      off(ownerDocument, "touchcancel", this._onDrop);
      off(document, "selectstart", this);
    },
    _onDrop: function _onDrop(evt) {
      var el = this.el, options6 = this.options;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options6.draggable);
      pluginEvent2("drop", this, {
        evt
      });
      parentEl = dragEl && dragEl.parentNode;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options6.draggable);
      if (Sortable.eventCanceled) {
        this._nulling();
        return;
      }
      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);
      _cancelNextTick(this.cloneId);
      _cancelNextTick(this._dragStartId);
      if (this.nativeDraggable) {
        off(document, "drop", this);
        off(el, "dragstart", this._onDragStart);
      }
      this._offMoveEvents();
      this._offUpEvents();
      if (Safari) {
        css(document.body, "user-select", "");
      }
      css(dragEl, "transform", "");
      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options6.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, "dragend", this);
          }
          _disableDraggable(dragEl);
          dragEl.style["will-change"] = "";
          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }
          toggleClass(dragEl, this.options.chosenClass, false);
          _dispatchEvent({
            sortable: this,
            name: "unchoose",
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });
          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              _dispatchEvent({
                rootEl: parentEl,
                name: "add",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "remove",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                rootEl: parentEl,
                name: "sort",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  sortable: this,
                  name: "update",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }
          if (Sortable.active) {
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }
            _dispatchEvent({
              sortable: this,
              name: "end",
              toEl: parentEl,
              originalEvent: evt
            });
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent2("nulling", this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function(el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(evt) {
      switch (evt.type) {
        case "drop":
        case "dragend":
          this._onDrop(evt);
          break;
        case "dragenter":
        case "dragover":
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case "selectstart":
          evt.preventDefault();
          break;
      }
    },
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order = [], el, children = this.el.children, i2 = 0, n = children.length, options6 = this.options;
      for (; i2 < n; i2++) {
        el = children[i2];
        if (closest(el, options6.draggable, this.el, false)) {
          order.push(el.getAttribute(options6.dataIdAttr) || _generateId(el));
        }
      }
      return order;
    },
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order, useAnimation) {
      var items2 = {}, rootEl2 = this.el;
      this.toArray().forEach(function(id2, i2) {
        var el = rootEl2.children[i2];
        if (closest(el, this.options.draggable, rootEl2, false)) {
          items2[id2] = el;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order.forEach(function(id2) {
        if (items2[id2]) {
          rootEl2.removeChild(items2[id2]);
          rootEl2.appendChild(items2[id2]);
        }
      });
      useAnimation && this.animateAll();
    },
    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name2, value) {
      var options6 = this.options;
      if (value === void 0) {
        return options6[name2];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name2, value);
        if (typeof modifiedValue !== "undefined") {
          options6[name2] = modifiedValue;
        } else {
          options6[name2] = value;
        }
        if (name2 === "group") {
          _prepareGroup(options6);
        }
      }
    },
    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent2("destroy", this);
      var el = this.el;
      el[expando] = null;
      off(el, "mousedown", this._onTapStart);
      off(el, "touchstart", this._onTapStart);
      off(el, "pointerdown", this._onTapStart);
      if (this.nativeDraggable) {
        off(el, "dragover", this);
        off(el, "dragenter", this);
      }
      Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
        el2.removeAttribute("draggable");
      });
      this._onDrop();
      this._disableDelayedDragEvents();
      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent2("hideClone", this);
        if (Sortable.eventCanceled) return;
        css(cloneEl, "display", "none");
        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }
        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable2) {
      if (putSortable2.lastPutMode !== "clone") {
        this._hideClone();
        return;
      }
      if (cloneHidden) {
        pluginEvent2("showClone", this);
        if (Sortable.eventCanceled) return;
        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }
        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }
        css(cloneEl, "display", "");
        cloneHidden = false;
      }
    }
  };
  function _globalDragOver(evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = "move";
    }
    evt.cancelable && evt.preventDefault();
  }
  function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent("move", {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent("move", true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl2;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }
    return retVal;
  }
  function _disableDraggable(el) {
    el.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }
  function _ghostIsFirst(evt, vertical, sortable) {
    var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
  }
  function _ghostIsLast(evt, vertical, sortable) {
    var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
  }
  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
    if (!invertSwap) {
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          pastFirstInvertThresh = true;
        }
        if (!pastFirstInvertThresh) {
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }
    invert = invert || invertSwap;
    if (invert) {
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }
    return 0;
  }
  function _getInsertDirection(target) {
    if (index(dragEl) < index(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
    while (i2--) {
      sum += str.charCodeAt(i2);
    }
    return sum.toString(36);
  }
  function _saveInputCheckedState(root2) {
    savedInputChecked.length = 0;
    var inputs = root2.getElementsByTagName("input");
    var idx = inputs.length;
    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }
  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }
  function _cancelNextTick(id2) {
    return clearTimeout(id2);
  }
  if (documentExists) {
    on(document, "touchmove", function(evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  }
  Sortable.utils = {
    on,
    off,
    css,
    find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend,
    throttle: throttle3,
    closest,
    toggleClass,
    clone: clone2,
    index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild,
    expando
  };
  Sortable.get = function(element) {
    return element[expando];
  };
  Sortable.mount = function() {
    for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins2[_key] = arguments[_key];
    }
    if (plugins2[0].constructor === Array) plugins2 = plugins2[0];
    plugins2.forEach(function(plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }
      if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  Sortable.create = function(el, options6) {
    return new Sortable(el, options6);
  };
  Sortable.version = version2;
  var autoScrolls = [];
  var scrollEl;
  var scrollRootEl;
  var scrolling = false;
  var lastAutoScrollX;
  var lastAutoScrollY;
  var touchEvt$1;
  var pointerElemChangedInterval;
  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      };
      for (var fn in this) {
        if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
          this[fn] = this[fn].bind(this);
        }
      }
    }
    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;
        if (this.sortable.nativeDraggable) {
          on(document, "dragover", this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, "pointermove", this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, "touchmove", this._handleFallbackAutoScroll);
          } else {
            on(document, "mousemove", this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop3() {
        if (this.sortable.nativeDraggable) {
          off(document, "dragover", this._handleAutoScroll);
        } else {
          off(document, "pointermove", this._handleFallbackAutoScroll);
          off(document, "touchmove", this._handleFallbackAutoScroll);
          off(document, "mousemove", this._handleFallbackAutoScroll);
        }
        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;
        var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
        touchEvt$1 = evt;
        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback);
          var ogElemScroller = getParentAutoScrollElement(elem, true);
          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval();
            pointerElemChangedInterval = setInterval(function() {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }
              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y;
          }
        } else {
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }
          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: "scroll",
      initializeByDefault: true
    });
  }
  function clearAutoScrolls() {
    autoScrolls.forEach(function(autoScroll2) {
      clearInterval(autoScroll2.pid);
    });
    autoScrolls = [];
  }
  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }
  var autoScroll = throttle3(function(evt, options6, rootEl2, isFallback) {
    if (!options6.scroll) return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options6.scrollSensitivity, speed = options6.scrollSpeed, winScroller = getWindowScrollingElement();
    var scrollThisInstance = false, scrollCustomFn;
    if (scrollRootEl !== rootEl2) {
      scrollRootEl = rootEl2;
      clearAutoScrolls();
      scrollEl = options6.scroll;
      scrollCustomFn = options6.scrollFn;
      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl2, true);
      }
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
      var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
      }
      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
      if (!autoScrolls[layersOut]) {
        for (var i2 = 0; i2 <= layersOut; i2++) {
          if (!autoScrolls[i2]) {
            autoScrolls[i2] = {};
          }
        }
      }
      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);
        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          autoScrolls[layersOut].pid = setInterval(function() {
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1);
            }
            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
            if (typeof scrollCustomFn === "function") {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                return;
              }
            }
            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }
      layersOut++;
    } while (options6.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance;
  }, 30);
  var drop = function drop2(_ref) {
    var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable2 || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent("spill");
      this.onSpill({
        dragEl: dragEl2,
        putSortable: putSortable2
      });
    }
  };
  function Revert() {
  }
  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex2 = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex2;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
      this.sortable.captureAnimationState();
      if (putSortable2) {
        putSortable2.captureAnimationState();
      }
      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl2, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl2);
      }
      this.sortable.animateAll();
      if (putSortable2) {
        putSortable2.animateAll();
      }
    },
    drop
  };
  _extends(Revert, {
    pluginName: "revertOnSpill"
  });
  function Remove() {
  }
  Remove.prototype = {
    onSpill: function onSpill2(_ref4) {
      var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
      var parentSortable = putSortable2 || this.sortable;
      parentSortable.captureAnimationState();
      dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
      parentSortable.animateAll();
    },
    drop
  };
  _extends(Remove, {
    pluginName: "removeOnSpill"
  });
  var sortable_core_esm_default = Sortable;

  // lib/vendor/index.js
  sortable_core_esm_default.mount(new AutoScrollPlugin());

  // lib/utils/caseBuilder.js
  function drawOptionBuilder(options6, mod, optionName) {
    const option2 = options6[optionName];
    const $addRowButton = (0, import_jquery.default)('<button class="addRowButton">');
    const $itemContainer = (0, import_jquery.default)('<div class="optionBuilder">');
    $itemContainer.attr({
      "data-module-id": mod.moduleID,
      "data-option-name": optionName
    });
    $addRowButton.text(i18n(option2.addItemText) || "+add item").on("click", function() {
      const $newBody = drawBuilderItem(option2.defaultTemplate(), option2.customOptionsFields, option2.cases);
      (0, import_jquery.default)(this).siblings(".optionBuilder:first").trigger("change").append($newBody);
      const firstText = $newBody.find("input[type=text], textarea")[0];
      if (firstText) {
        setTimeout(() => firstText.focus(), 200);
      }
    });
    option2.value.forEach((item) => drawBuilderItem(item, option2.customOptionsFields, option2.cases).appendTo($itemContainer));
    sortable_core_esm_default.create($itemContainer.get(0), { handle: ".handle" });
    return (0, import_jquery.default)("<div>").append($itemContainer, $addRowButton)[0];
  }
  function drawBuilderItem(data2, customOptionsFields = [], cases) {
    const $item = (0, import_jquery.default)('<div class="builderItem">');
    const $editButton = (0, import_jquery.default)("<div>").addClass("res-icon-button res-icon builderControls builderTrailingControls").html("&#xF061;").attr("title", "copy and share, or update your settings with a new version").on("click", async () => {
      const data3 = readBuilderItem($item, customOptionsFields, cases);
      const element = string_exports.html`<div>Copy this and share it, or update your settings with a new version: <br><br><textarea rows="5" cols="50"></textarea></div>`;
      const textarea = downcast(element.querySelector("textarea"), HTMLTextAreaElement);
      textarea.value = JSON.stringify(data3);
      const newData = await alert_exports.open(element, { cancelable: true }).then(() => JSON.parse(textarea.value));
      $item.replaceWith(drawBuilderItem(newData, customOptionsFields, cases)).trigger("change");
    });
    const $deleteButton = drawDeleteButton().addClass("builderTrailingControls").on("click", () => {
      const parent2 = $item.parent();
      $item.trigger("change").detach();
      undo("Restore deleted item").then(() => {
        parent2.append($item).trigger("change");
      });
    });
    const customOptions = string_exports.html`<ul class="builderCustomOptions"></ul>`;
    for (const fields of customOptionsFields) {
      const li = document.createElement("li");
      (0, import_jquery.default)(li).append(drawFields(fields, data2.opts || {}));
      customOptions.append(li);
    }
    const $header = (0, import_jquery.default)('<div class="builderItemControls">').append(
      drawHandle(),
      (0, import_jquery.default)('<input type="hidden" name="version">').val(data2.ver),
      (0, import_jquery.default)('<input type="hidden" name="id">').val(data2.id),
      customOptions,
      (0, import_jquery.default)('<textarea name="builderNote" rows="1" cols="40" placeholder="Write a description/note for this">').val(data2.note),
      (0, import_jquery.default)('<div class="pushRight">').append($editButton, $deleteButton)
    );
    const $body = drawBuilderBlock(data2.body, cases, false);
    return $item.append($header, $body);
  }
  function drawHandle() {
    return (0, import_jquery.default)("<div>").addClass("res-icon-button res-icon handle builderControls").html("&#xF0AA;").attr("title", "drag and drop to move this condition");
  }
  function drawDeleteButton() {
    return (0, import_jquery.default)("<div>").addClass("res-icon-button res-icon builderControls").html("&#xF056;").attr("title", "remove this condition");
  }
  function drawBuilderBlock(data2, cases, addBaseControls = true) {
    if (!cases.hasOwnProperty(data2.type)) {
      console.error(`Case type ${data2.type} is not available. Ignoring block.`, data2);
      return (0, import_jquery.default)();
    }
    const $block = (0, import_jquery.default)('<div class="builderBlock">').attr("data-type", data2.type).append(drawFields(cases[data2.type].fields, data2, cases));
    if (!addBaseControls) return $block;
    const $wrap = (0, import_jquery.default)('<div class="builderWrap">');
    const $deleteButton = drawDeleteButton().addClass("builderTrailingControls").on("click", () => {
      const parent2 = $wrap.parent();
      $wrap.trigger("change").detach();
      undo("Restore deleted block").then(() => {
        parent2.append($wrap).trigger("change");
      });
    });
    return $wrap.append(
      drawHandle(),
      $block,
      $deleteButton
    );
  }
  function readBuilderItem(item, customOptionsFields = [], cases) {
    const $firstBlock = (0, import_jquery.default)(item).find("> .builderBlock");
    const $header = (0, import_jquery.default)(item).find(".builderItemControls");
    return {
      note: $header.find("textarea[name=builderNote]").val(),
      ver: parseInt($header.find("input[name=version]").val(), 10),
      id: $header.find("input[name=id]").val(),
      body: readBuilderBlock($firstBlock, cases),
      // $FlowIssue Array#flat
      opts: readFields($header.find(".builderCustomOptions li"), customOptionsFields.flat(Infinity), cases)
    };
  }
  function readBuilderBlock($element, cases) {
    const type = $element.attr("data-type");
    const BlockClass = cases[type];
    const data2 = { type, ...readFields($element, BlockClass.fields, cases) };
    const multiType = BlockClass.fields.find(({ type: type2 }) => type2 === "multi");
    if (!multiType) {
      try {
        BlockClass.validate(data2);
        $element.removeClass("builderBlock-error");
      } catch (e2) {
        $element.attr("error", e2.message).addClass("builderBlock-error");
        throw e2;
      }
    }
    return data2;
  }
  function readFields($element, fields, cases) {
    return fields.reduce((acc, field) => {
      if (typeof field === "string") return acc;
      const $fieldElem = $element.find(`> [name=${field.id}]`);
      const fieldModule = builderFields[field.type];
      if (fieldModule && typeof fieldModule.read === "function") {
        acc[field.id] = fieldModule.read($fieldElem, field, cases);
      } else {
        acc[field.id] = $fieldElem.val();
      }
      return acc;
    }, {});
  }
  function drawFields(fields, data2, cases) {
    return fields.map((field) => {
      if (typeof field === "string") return field;
      const fieldModule = builderFields[field.type];
      if (fieldModule) {
        return fieldModule.draw(data2, field, cases);
      } else {
        return (0, import_jquery.default)(`<input type="${field.type}">`).attr("name", field.id).val(data2[field.id]);
      }
    });
  }
  var builderFields = {
    multi: {
      draw(data2, field, cases = {}) {
        const $rowWrapper = (0, import_jquery.default)('<ul class="builderMulti">').attr("name", field.id);
        const addItem = (itemData) => drawBuilderBlock(itemData, cases).appendTo($rowWrapper).wrap("<li>");
        const items2 = data2[field.id];
        items2.forEach(addItem);
        const addCaseSelect = downcast(string_exports.html`
				<select class="addBuilderBlock">
					<option>+ add a condition</option>
					${Object.entries(cases).map(([key, { text }]) => string_exports._html`
						<option value="${key}">${text}</option>
					`)}
				</select>
			`, HTMLSelectElement);
        addCaseSelect.addEventListener("change", () => {
          const type = addCaseSelect.value;
          if (type !== "" && cases.hasOwnProperty(type)) {
            addItem({ type, ...cases[type].defaultConditions }).find("input[type=text], input[type=number], textarea").focus();
          }
          addCaseSelect.selectedIndex = 0;
        });
        sortable_core_esm_default.create($rowWrapper.get(0), { group: "block", handle: ".handle" });
        return $rowWrapper.add(addCaseSelect);
      },
      read($elem, fields, cases) {
        return $elem.find("> li > .builderWrap > .builderBlock").map(function() {
          return readBuilderBlock((0, import_jquery.default)(this), cases);
        }).get();
      }
    },
    hidden: {
      draw(data2, field) {
        const id2 = field.id;
        return (0, import_jquery.default)('<input type="hidden">').attr("name", id2).val(data2[id2]);
      }
    },
    number: {
      draw(data2, field) {
        const id2 = field.id;
        return (0, import_jquery.default)('<input type="number">').attr("name", id2).val(data2[id2]);
      },
      read($elem) {
        return parseInt($elem.val(), 10);
      }
    },
    check: {
      draw(data2, field) {
        const id2 = field.id;
        const $input = (0, import_jquery.default)('<input type="checkbox">').prop("checked", data2[id2]);
        return (0, import_jquery.default)("<label>").attr("name", id2).text(field.label).prepend($input);
      },
      read($elem) {
        return $elem.find("input").get(0).checked;
      }
    },
    checkset: {
      uid: 0,
      draw(data2, field) {
        const id2 = field.id;
        const prefixId = this.uid++;
        const $wrap = (0, import_jquery.default)('<span class="checkset">').attr("name", field.id);
        field.items.forEach((e2, idx) => {
          const itemId = `checkset-${prefixId}-${idx}X`;
          const $box = (0, import_jquery.default)('<input type="checkbox" />').attr("id", itemId).attr("name", e2);
          if (data2.hasOwnProperty(id2) && data2[id2].includes(e2)) {
            $box.prop("checked", true);
          }
          const $label = (0, import_jquery.default)("<label>").attr("for", itemId).text(e2);
          $wrap.append($box, $label);
        });
        return $wrap;
      },
      read($elem, fields) {
        return fields.items.filter((e2) => $elem.children(`[name="${e2}"]`).prop("checked"));
      }
    },
    duration: {
      draw(data2, field) {
        let durr = data2[field.id];
        durr /= 60 * 1e3;
        const minutes = durr % 60;
        durr = (durr - minutes) / 60;
        const hours = durr % 24;
        durr = (durr - hours) / 24;
        const days2 = durr;
        return (0, import_jquery.default)('<span class="durationField">').attr("name", field.id).append([
          (0, import_jquery.default)('<input type="number" name="days" />').val(days2),
          " days ",
          (0, import_jquery.default)('<input type="number" name="hours" />').val(hours),
          " hours ",
          (0, import_jquery.default)('<input type="number" name="minutes" />').val(minutes),
          " minutes "
        ]);
      },
      read($elem) {
        const days2 = parseFloat($elem.children("[name=days]").val()) || 0;
        const hours = parseFloat($elem.children("[name=hours]").val()) || 0;
        const minutes = parseFloat($elem.children("[name=minutes]").val()) || 0;
        let duration = 0;
        duration += days2 * 24 * 60 * 60;
        duration += hours * 60 * 60;
        duration += minutes * 60;
        duration *= 1e3;
        return duration;
      }
    },
    select: {
      draw(data2, field) {
        const value = data2[field.id];
        let entries = field.options;
        if (typeof entries === "string") {
          entries = this.getPredefinedChoices(entries);
        }
        const $dropdown = (0, import_jquery.default)("<select>").attr("name", field.id);
        entries.forEach((row) => {
          let label, value2;
          if (typeof row === "string") {
            label = value2 = row;
          } else {
            label = row[0];
            value2 = row[1];
          }
          (0, import_jquery.default)("<option>").text(label).val(value2).appendTo($dropdown);
        });
        $dropdown.val(value);
        return $dropdown;
      },
      getPredefinedChoices(name2) {
        if (name2 === "COMPARISON") {
          return [
            ["exactly", "=="],
            ["not", "!="],
            ["more than", ">"],
            ["less than", "<"],
            ["at least", ">="],
            ["at most", "<="]
          ];
        } else {
          throw new Error(`Option set "${name2}" is not defined`);
        }
      }
    }
  };

  // lib/core/module.js
  var Module = class {
    moduleID;
    moduleName;
    category = "";
    description = "";
    descriptionRaw = false;
    // Whether the message is HTML and should not be run through i18n / markdown
    keywords = [];
    bodyClass = false;
    options = {};
    include = [];
    exclude = [];
    shouldRun = () => true;
    onToggle = () => {
    };
    onSaveSettings = () => {
    };
    hidden = false;
    disabledByDefault = false;
    alwaysEnabled = false;
    sort = 0;
    // no default value for cleaner profiling (modules without a stage defined won't be timed)
    onInit = void 0;
    beforeLoad = void 0;
    contentStart = void 0;
    go = void 0;
    afterLoad = void 0;
    always = void 0;
    permissions = {
      requiredPermissions: []
    };
    constructor(moduleID) {
      this.moduleID = moduleID;
      this.moduleName = moduleID;
    }
  };
  function getModuleId(opaqueId) {
    if (!opaqueId) {
      throw new TypeError(`Expected module, moduleID, or namespace; found: ${opaqueId}`);
    }
    if (typeof opaqueId === "string") {
      return opaqueId;
    } else if (opaqueId.module) {
      return opaqueId.module.moduleID;
    } else {
      return opaqueId.moduleID;
    }
  }

  // lib/modules/index.js
  var modules_exports2 = {};
  __export(modules_exports2, {
    RESTips: () => module32,
    about: () => module33,
    accountSwitcher: () => module15,
    announcements: () => module34,
    autoHide: () => module35,
    backupAndRestore: () => module36,
    betteReddit: () => module38,
    commandLine: () => module3,
    commentDepth: () => module39,
    commentHidePersistor: () => module40,
    commentNavigator: () => module22,
    commentPreview: () => module41,
    commentQuickCollapse: () => module42,
    commentSortBy: () => module43,
    commentStyle: () => module44,
    commentTools: () => module17,
    context: () => module45,
    contribute: () => module46,
    customToggles: () => module10,
    dashboard: () => module47,
    disableChat: () => module48,
    easterEgg: () => module24,
    filteReddit: () => module11,
    hideChildComments: () => module25,
    hover: () => module2,
    keyboardNav: () => module28,
    localDate: () => module49,
    logoLink: () => module50,
    menu: () => module4,
    messageMenu: () => module51,
    modhelper: () => module52,
    multiredditNavbar: () => module53,
    neverEndingComments: () => module54,
    neverEndingReddit: () => module26,
    newCommentCount: () => module8,
    nightMode: () => module12,
    noParticipation: () => module27,
    notifications: () => module6,
    onboarding: () => module55,
    orangered: () => module56,
    pageNavigator: () => module57,
    penaltyBox: () => module7,
    presets: () => module59,
    profileNavigator: () => module60,
    profileRedirect: () => module61,
    quarantineHide: () => module62,
    quickMessage: () => module19,
    readComments: () => module14,
    redditUserInfo: () => module63,
    requestPermissions: () => module64,
    saveComments: () => module29,
    search: () => module65,
    searchHelper: () => module66,
    selectedEntry: () => module67,
    settingsNavigation: () => module5,
    showImages: () => module9,
    showKarma: () => module68,
    showParent: () => module30,
    singleClick: () => module31,
    sourceSnudown: () => module69,
    spamButton: () => module70,
    spoilerTags: () => module71,
    styleTweaks: () => module72,
    stylesheet: () => module73,
    submitHelper: () => module74,
    submitIssue: () => module16,
    subredditInfo: () => module75,
    subredditManager: () => module37,
    subredditStyleToggle: () => module76,
    subredditTagger: () => module77,
    tableTools: () => module78,
    temporaryDropdownLinks: () => module79,
    troubleshooter: () => module58,
    userHighlight: () => module21,
    userInfo: () => module20,
    userTagger: () => module13,
    userbarHider: () => module80,
    usernameHider: () => module18,
    version: () => module81,
    voteEnhancements: () => module82,
    wheelBrowse: () => module23,
    xPostLinks: () => module83
  });

  // lib/modules/RESTips.js
  var import_jquery24 = __toESM(require_jquery(), 1);

  // lib/core/options/storage.js
  var storage = wrapPrefix("RESoptions.", () => ({}), void 0, false);
  function set5(opaqueId, optionKey, value) {
    if (/_[\d]+$/.test(optionKey)) {
      optionKey = optionKey.replace(/_[\d]+$/, "");
    }
    return storage.patch(getModuleId(opaqueId), { [optionKey]: { value } });
  }

  // lib/core/options/modified.js
  function getModified() {
    return filterMap(all(), (module84) => {
      const { moduleID, options: options6 } = module84;
      const enabledByDefault = !module84.disabledByDefault;
      const isEnabled2 = isEnabled(module84);
      const moduleStatusChanged = enabledByDefault !== isEnabled2;
      const modifiedOptions2 = isEnabled2 ? omitBy_default(options6, (v) => isEqual_default(v.value, v.default)) : {};
      if (!isEmpty_default(modifiedOptions2) || moduleStatusChanged) {
        return [{
          moduleID,
          modifiedOptions: modifiedOptions2,
          moduleStatus: moduleStatusChanged ? `${enabledByDefault ? "on" : "off"} \u2192 ${isEnabled2 ? "on" : "off"}` : ""
        }];
      }
    });
  }
  function getModifiedText(censorOptions = ["backupAndRestore/googleAccount"]) {
    const lines = [];
    let optionMaxLength = 0;
    let moduleMaxLength = 0;
    for (const { moduleID, modifiedOptions: modifiedOptions2, moduleStatus } of getModified()) {
      moduleMaxLength = Math.max(moduleMaxLength, moduleID.length);
      optionMaxLength = Math.max(optionMaxLength, ...Object.keys(modifiedOptions2).map((v) => v.length));
      lines.push(
        () => [
          `    ${moduleID.padEnd(moduleMaxLength)} ${moduleStatus}`,
          ...Object.entries(modifiedOptions2).map(([key, { value: _current, default: _default, type }]) => {
            const asText = (v) => ["text", "boolean", "enum", "select", "color"].includes(type) ? JSON.stringify(v) : ["list", "table", "builder"].includes(type) ? v.length : ["keycode"].includes(type) ? niceKeyCode(v) : "***UNKNOWN TYPE***";
            const defaultText = asText(_default);
            const currentText = censorOptions.includes(`${moduleID}/${key}`) ? "***CENSORED***" : asText(_current);
            return `      ${key.padEnd(optionMaxLength)}	${defaultText} \u2192 ${currentText}`;
          })
        ]
      );
    }
    return lines.map((v) => v()).flat(2).join("\n");
  }

  // lib/core/options/stage.js
  var stage_exports = {};
  __export(stage_exports, {
    add: () => stageOption,
    commit: () => commitStagedOptions,
    get: () => getStagedOptions,
    isDirty: () => hasStagedOptions,
    reset: () => clearStagedOptions
  });
  var stagedOptions;
  clearStagedOptions();
  function stageOption(moduleID, optionName, optionValue) {
    const mod = get4(moduleID);
    stagedOptions[moduleID] = stagedOptions[moduleID] || {};
    if (!isEqual_default(mod.options[optionName].value, optionValue)) {
      stagedOptions[moduleID][optionName] = {
        value: optionValue
      };
    } else {
      delete stagedOptions[moduleID][optionName];
    }
    if (isEmpty_default(stagedOptions[moduleID])) {
      delete stagedOptions[moduleID];
    }
  }
  function commitStagedOptions() {
    for (const [modId, options6] of Object.entries(stagedOptions)) {
      const module84 = get4(modId);
      for (const [optionName, option2] of Object.entries(options6)) {
        const _option = module84.options[optionName];
        _option.value = option2.value;
        save2(_option);
      }
      module84.onSaveSettings(options6);
    }
    clearStagedOptions();
  }
  function clearStagedOptions() {
    stagedOptions = {};
  }
  function hasStagedOptions() {
    return !isEmpty_default(stagedOptions);
  }
  function getStagedOptions(moduleID) {
    return stagedOptions[moduleID];
  }

  // lib/core/options/table.js
  var table_exports2 = {};
  __export(table_exports2, {
    getMatchingValueOrAdd: () => getMatchingValueOrAdd
  });
  function getMatchingValueOrAdd(opaqueId, optionKey, valueIdentifier, _default) {
    const module84 = get4(opaqueId);
    const option2 = module84.options[optionKey];
    if (option2.type !== "table") {
      throw new Error(`Tried to save table value to non-table option: modules.${module84.moduleID}.options.${optionKey}`);
    }
    let row = option2.value.find(
      (value) => option2.fields.every((field, i2) => !valueIdentifier.hasOwnProperty(field.key) || value[i2] === valueIdentifier[field.key])
    );
    if (!row) {
      const value = { ...valueIdentifier, ..._default };
      row = option2.fields.map((field) => firstValid(value[field.key], field.value));
      option2.value.push(row);
      set5(module84, optionKey, option2.value);
    }
    return option2.fields.reduce((acc, field, i2) => {
      Object.defineProperty(acc, field.key, {
        enumerable: true,
        get: () => row[i2],
        set: (v) => {
          row[i2] = v;
          set5(module84, optionKey, option2.value);
        }
      });
      return acc;
    }, {});
  }

  // lib/modules/penaltyBox.js
  var import_jquery4 = __toESM(require_jquery(), 1);

  // lib/modules/notifications.js
  var import_jquery3 = __toESM(require_jquery(), 1);

  // lib/modules/hover.js
  var import_jquery2 = __toESM(require_jquery(), 1);
  var module2 = new Module("hover");
  module2.moduleName = "hoverName";
  module2.category = "coreCategory";
  module2.description = "hoverDesc";
  module2.alwaysEnabled = true;
  module2.options = {
    instances: {
      description: "hoverInstancesDesc",
      title: "hoverInstancesTitle",
      type: "table",
      value: [],
      fields: [{
        key: "id",
        name: "hoverInstancesName",
        type: "text"
      }, {
        key: "enabled",
        name: "hoverInstancesEnabled",
        type: "boolean",
        value: true
      }]
    },
    openDelay: {
      type: "text",
      value: "500",
      description: "hoverOpenDelayDesc",
      title: "hoverOpenDelayTitle"
    },
    fadeDelay: {
      type: "text",
      value: "500",
      description: "hoverFadeDelayDesc",
      title: "hoverFadeDelayTitle"
    },
    fadeSpeed: {
      noconfig: true,
      // broken
      type: "text",
      value: "0.7",
      description: "hoverFadeSpeedDesc",
      title: "hoverFadeSpeedTitle"
    },
    width: {
      type: "text",
      value: "512",
      description: "hoverWidthDesc",
      title: "hoverWidthTitle"
    },
    closeOnMouseOut: {
      type: "boolean",
      value: true,
      description: "hoverCloseOnMouseOutDesc",
      title: "hoverCloseOnMouseOutTitle"
    }
  };
  module2.beforeLoad = () => {
    Hover._defaultOptions = {
      openDelay: parseFloat(module2.options.openDelay.value),
      fadeDelay: parseFloat(module2.options.fadeDelay.value),
      fadeSpeed: parseFloat(module2.options.fadeSpeed.value),
      width: parseFloat(module2.options.width.value),
      closeOnMouseOut: module2.options.closeOnMouseOut.value,
      enabled: true
    };
  };
  var instances = {};
  var getInstance = (TypeClass, id2) => instances[id2] || (instances[id2] = new TypeClass(id2));
  var infocard = (name2) => getInstance(HoverInfoCard, name2);
  var dropdownList = (name2) => getInstance(HoverDropdownList, name2);
  function getFixedParent(e2) {
    const p = e2.parentElement;
    return p && (window.getComputedStyle(p).position === "fixed" && e2 || getFixedParent(p));
  }
  var pin = {
    bottom: "bottom",
    right: "right"
  };
  var Hover = class _Hover {
    static _defaultOptions = {};
    template = `
		<div class="RESHover">
			<div data-hover-element="0" />
			<div data-hover-element="1" />
			<div data-hover-element="2" />
			<div data-hover-element="3" />
		</div>
	`;
    _options = _Hover._defaultOptions;
    instanceID;
    visible = false;
    _hideTimer = null;
    _showTimer = null;
    _closeFadeTimer = null;
    _target;
    _callback;
    _container;
    _fixedPosition = false;
    _closePromise;
    _closePromiseResolve;
    constructor(id2) {
      this.instanceID = id2;
    }
    options(options6, persistent = true) {
      const persistentOptions = persistent ? table_exports2.getMatchingValueOrAdd(module2, "instances", { id: this.instanceID }, { enabled: true }) : void 0;
      this._options = {
        ...this._options,
        ...options6,
        ...persistentOptions
      };
      return this;
    }
    target(element) {
      if (this._target && this._target !== element) {
        this.close();
      }
      this._target = element;
      return this;
    }
    getCheckedTarget() {
      if (!this._target || !this._target.offsetParent) {
        this.close();
        throw new Error("Cannot show hover without target; closing hover.");
      }
      return this._target;
    }
    populateWith(callback) {
      this._callback = callback;
      return this;
    }
    getContainer() {
      const container2 = this._container = this._container || this._render();
      if (!document.body.contains(container2)) {
        document.body.append(container2);
      }
      return container2;
    }
    _render() {
      const ele = (0, import_jquery2.default)(this.template).get(0);
      this._addContainerHandlers(ele);
      if (this._options.className) ele.classList.add(this._options.className);
      return ele;
    }
    _checkMouseLeave = frameThrottle(({ target }) => {
      if (this.visible && this._options.closeOnMouseOut && !this.getCheckedTarget().contains(target) && // Also check that the mouse is not in a "child" hover (e.g. by opening the user tagger via userInfo)
      !Object.values(instances).some((instance) => instance._container && instance._container.contains(target))) this._startHideTimer();
    });
    _addContainerHandlers(ele) {
      (0, import_jquery2.default)(ele).on("mouseenter", () => {
        this._cancelHideTimer();
        this._clearCloseFade();
      }).on("mouseleave", this._checkMouseLeave).on("click", ".RESCloseButton", () => this.close()).on("keyup", (e2) => {
        if (e2.key === NAMED_KEYS.Escape) this.close();
        e2.stopImmediatePropagation();
      });
    }
    begin() {
      if (!this._options.enabled) return false;
      if (this._options.openDelay) {
        this._startShowTimer();
      } else {
        this.open();
      }
    }
    watch(selector) {
      (0, import_jquery2.default)(document.body).on("mouseenter", selector, ({ currentTarget }) => {
        this.target(currentTarget).begin();
      });
    }
    open() {
      if (!this._options.enabled) return false;
      this._cancelShowTimer();
      this._cancelHideTimer();
      this._clearCloseFade();
      const callback = this._callback;
      if (!callback) throw new Error();
      if (this._closePromiseResolve) this._closePromiseResolve();
      this._closePromise = new Promise((res) => {
        this._closePromiseResolve = res;
      });
      this._displayLoadIndicator();
      (async () => {
        try {
          this.populate(await callback(this));
        } catch (e2) {
          this.close();
          throw e2;
        }
      })();
      waitForDetach(this.getCheckedTarget(), this._closePromise).then(() => {
        this.close();
      }).catch(() => {
      });
      if (this._options.closeOnMouseOut) {
        document.body.addEventListener("mousemove", this._checkMouseLeave);
        document.body.addEventListener("mouseover", this._checkMouseLeave);
      }
      this.visible = true;
    }
    _displayLoadIndicator() {
    }
    async refresh() {
      const callback = this._callback;
      if (callback) this.populate(await callback(this));
    }
    populate(items2) {
      if (!this._options.enabled) return false;
      const container2 = this.getContainer();
      items2.forEach((item, i2) => {
        if (!item) return;
        const $element = (0, import_jquery2.default)(container2).find(`[data-hover-element="${i2}"]`);
        $element.children().detach();
        $element.empty().append(item);
      });
      const fixedParent = getFixedParent(this.getCheckedTarget());
      if (fixedParent) {
        this._fixedPosition = true;
        const onScroll = () => {
          this.close(false);
          fixedParent.removeEventListener("scroll", onScroll, true);
        };
        fixedParent.addEventListener("scroll", onScroll, true);
      }
      this._updatePosition();
    }
    _positionContainer({ top = "auto", right = "auto", bottom = "auto", left = "auto" }) {
      (0, import_jquery2.default)(this.getContainer()).css({
        position: this._fixedPosition ? "fixed" : "absolute",
        top: top !== "auto" ? top + (this._fixedPosition ? 0 : window.scrollY) : "auto",
        right: right !== "auto" ? right + (this._fixedPosition ? 0 : window.scrollX) : "auto",
        bottom: bottom !== "auto" ? bottom + (this._fixedPosition ? 0 : window.scrollY) : "auto",
        left: left !== "auto" ? left + (this._fixedPosition ? 0 : window.scrollX) : "auto"
      });
    }
    _updatePosition() {
      const target = this.getCheckedTarget();
      const { top, left } = target.getBoundingClientRect();
      this._positionContainer({ top, left });
    }
    // Ensure a stable `this` for timer starters / cancellers, so that they can be referenced when adding / remove event listeners
    _startShowTimer = () => {
      if (this._showTimer) return;
      this._cancelHideTimer();
      waitForEvent(this.getCheckedTarget(), "mouseleave").then(this._cancelShowTimer);
      this._showTimer = setTimeout(() => this.open(), this._options.openDelay);
    };
    _cancelShowTimer = () => {
      if (!this._showTimer) return;
      clearTimeout(this._showTimer);
      this._showTimer = null;
    };
    resetShowTimer() {
      if (this._showTimer) {
        this._cancelShowTimer();
        this._startShowTimer();
      }
    }
    _startHideTimer = () => {
      if (this._hideTimer || this._closeFadeTimer) return;
      this._cancelShowTimer();
      this._hideTimer = setTimeout(() => this.close(true), this._options.fadeDelay);
    };
    _cancelHideTimer = () => {
      if (!this._hideTimer) return;
      clearTimeout(this._hideTimer);
      this._hideTimer = null;
    };
    _startCloseFade() {
      if (this._closeFadeTimer) return;
      this._closeFadeTimer = setTimeout(() => {
        this.remove();
      }, this._options.fadeSpeed * 1e3);
      this.getContainer().style.transitionDuration = `${this._options.fadeSpeed}s`;
      this.getContainer().classList.add("transitionToTransparent");
    }
    _clearCloseFade() {
      if (!this._closeFadeTimer) return;
      clearTimeout(this._closeFadeTimer);
      this.getContainer().style.transitionDuration = "";
      this.getContainer().classList.remove("transitionToTransparent");
      this._closeFadeTimer = null;
    }
    close(fade = false) {
      if (!this._options.enabled) return false;
      this._cancelShowTimer();
      this._cancelHideTimer();
      if (fade) this._startCloseFade();
      else this.remove();
    }
    remove() {
      this._clearCloseFade();
      this.getContainer().remove();
      if (this._closePromiseResolve) this._closePromiseResolve();
      this.visible = false;
      if (this._options.closeOnMouseOut) {
        document.body.removeEventListener("mousemove", this._checkMouseLeave);
        document.body.removeEventListener("mouseover", this._checkMouseLeave);
      }
    }
  };
  var HoverInfoCard = class extends Hover {
    template = `
		<div class="RESHover RESHoverInfoCard RESDialogSmall">
			<h3 class="RESHoverTitle" data-hover-element="0"></h3>
			<div class="RESCloseButton RESCloseButtonTopRight"></div>
			<div class="RESHoverBody RESDialogContents" data-hover-element="1"></div>
		</div>
	`;
    _loadIndicator = '<div class="RESCenteredLoadIndicator"><span class="RESLoadingSpinner"></span></div>';
    _displayLoadIndicator() {
      this.populate(["\u2026", this._loadIndicator]);
    }
    _updatePosition() {
      const target = this.getCheckedTarget();
      const { top, left, bottom, right } = target.getBoundingClientRect();
      const $container = (0, import_jquery2.default)(this.getContainer()).removeClass("right below");
      const tooltipWidth = this._options.width;
      let tooltipLeft, tooltipTop;
      if (!this._options.pin && right + tooltipWidth + 25 < getViewportSize().width) {
        tooltipTop = top - 14;
        tooltipLeft = right + 25;
      } else if (this._options.pin === pin.bottom || left - tooltipWidth - 30 < 0) {
        $container.addClass("below");
        tooltipTop = bottom + 10;
        tooltipLeft = Math.min(Math.max(getViewportSize().width - tooltipWidth, 0), left);
      } else {
        $container.addClass("right");
        tooltipTop = top - 14;
        tooltipLeft = left - tooltipWidth - 30;
      }
      $container.get(0).style.width = `${tooltipWidth}px`;
      this._positionContainer({ left: tooltipLeft, top: tooltipTop });
    }
  };
  var HoverDropdownList = class extends Hover {
    template = `
		<div class="RESHover RESHoverDropdownList RESDropdownList">
			<ul class="RESDropdownOptions" data-hover-element="0"></ul>
		</div>
	`;
    _options = {
      ...Hover._defaultOptions,
      pin: pin.bottom,
      offsetWidth: 0,
      offsetHeight: 2,
      bottomPadding: 10
    };
    _updatePosition() {
      const target = this.getCheckedTarget();
      const { top, left, height, width } = target.getBoundingClientRect();
      const $container = (0, import_jquery2.default)(this.getContainer());
      switch (this._options.pin) {
        case pin.right:
          const bottomAlign = top + $container.height() + this._options.bottomPadding > getViewportSize().height;
          if (bottomAlign) {
            this._positionContainer({ left: left + width, bottom: this._options.bottomPadding });
          } else {
            this._positionContainer({ left: left + width, top: top + this._options.offsetHeight });
          }
          break;
        case pin.bottom:
        // falls through
        default:
          const leftAlign = left + $container.outerWidth() < getViewportSize().width;
          if (leftAlign) {
            this._positionContainer({ left, top: top + height + this._options.offsetHeight });
          } else {
            this._positionContainer({ right: getViewportSize().width - left - width + this._options.offsetWidth, top: top + height + this._options.offsetHeight });
          }
          break;
      }
    }
  };

  // lib/modules/commandLine.js
  var commandLine_exports = {};
  __export(commandLine_exports, {
    module: () => module3,
    open: () => open2,
    registerCommand: () => registerCommand,
    toggle: () => toggle2
  });
  var import_dompurify = __toESM(require_purify(), 1);
  var module3 = new Module("commandLine");
  module3.moduleName = "commandLineName";
  module3.description = "commandLineDesc";
  module3.category = "coreCategory";
  module3.options = {
    launch: {
      title: "commandLineLaunchTitle",
      type: "button",
      text: "Launch",
      description: "commandLineLaunchDesc",
      callback() {
        open2();
      }
    },
    menuItem: {
      title: "commandLineMenuItemTitle",
      type: "boolean",
      description: "commandLineMenuItemDesc",
      value: false
    }
  };
  module3.contentStart = () => {
    if (module3.options.menuItem.value) {
      addMenuItem2();
    }
  };
  function addMenuItem2() {
    addMenuItem(
      () => string_exports.html`<div>command line <span class="RESMenuItemButton res-icon">\uF060</span></div>`,
      () => open2()
    );
  }
  var commandLine = once_default(() => {
    const widget = string_exports.html`
		<div id="keyCommandLineWidget" hidden>
			<div id="keyCommandForm">
				<input id="keyCommandInput" type="text" autocomplete="off">
				type a command, ? for help, esc to close
				<div id="keyCommandInputTip"></div>
				<div id="keyCommandInputError"></div>
			</div>
		</div>
	`;
    document.body.append(widget);
    const input2 = downcast(widget.querySelector("#keyCommandInput"), HTMLInputElement);
    const tip = widget.querySelector("#keyCommandInputTip");
    const error = widget.querySelector("#keyCommandInputError");
    const setTip = (str) => {
      tip.innerHTML = import_dompurify.default.sanitize(str);
    };
    const clearTip = () => empty(tip);
    const setError = (str) => {
      error.innerHTML = import_dompurify.default.sanitize(str);
    };
    const clearError = () => empty(error);
    input2.addEventListener("blur", () => {
      if (!input2.value.length) {
        close();
      } else {
        setError("click into the text input and press escape to close the command line");
      }
    });
    document.addEventListener("keyup", (e2) => {
      if (!widget.hidden && e2.key === NAMED_KEYS.Escape) {
        close();
        e2.stopImmediatePropagation();
      }
    });
    input2.addEventListener("input", async () => {
      clearTip();
      clearError();
      const tip2 = await getTip(parse(input2.value));
      if (tip2) setTip(tip2);
    });
    const commandLineForm = widget.querySelector("#keyCommandForm");
    commandLineForm.addEventListener("keydown", async (e2) => {
      if (e2.key === NAMED_KEYS.Enter) {
        const error2 = await executeCommand(parse(input2.value), e2);
        if (error2) {
          setError(error2);
        } else if (error2 !== false) {
          close();
        }
      }
    });
    return { widget, input: input2 };
  });
  function open2(initialCmd = "") {
    commandLine().widget.hidden = false;
    commandLine().input.focus();
    commandLine().input.value = initialCmd;
    commandLine().input.dispatchEvent(new Event("input"));
  }
  function close() {
    commandLine().input.blur();
    commandLine().widget.hidden = true;
  }
  function toggle2() {
    if (commandLine().widget.hidden) open2();
    else close();
  }
  function navigateTo(url, e2) {
    if (e2.shiftKey) {
      openNewTab(url, !e2.altKey);
    } else {
      location.href = url;
    }
  }
  var commands = [];
  function registerCommand(commandPredicate, description, getTip2, executeCommand2) {
    commands.push({
      commandPredicate,
      description,
      getTip: getTip2,
      executeCommand: executeCommand2
    });
  }
  function getCommandSpec(command, val) {
    let result;
    commands.some((commandSpec) => {
      let predicateResult;
      if (typeof commandSpec.commandPredicate.exec === "function") {
        predicateResult = commandSpec.commandPredicate.exec(command);
      } else if (typeof commandSpec.commandPredicate === "string") {
        predicateResult = commandSpec.commandPredicate === command;
      } else if (typeof commandSpec.commandPredicate === "function") {
        predicateResult = commandSpec.commandPredicate(command, val);
      }
      if (predicateResult) {
        result = {
          ...commandSpec,
          predicateResult
        };
        return true;
      }
    });
    return result;
  }
  function parse(input2) {
    const splitWords = input2.split(" ");
    const command = splitWords[0];
    const value = splitWords.slice(1).join(" ");
    return { command, value };
  }
  function getTip({ command, value }) {
    const matchingCommandSpec = getCommandSpec(command, value);
    if (matchingCommandSpec) {
      return matchingCommandSpec.getTip(command, value, matchingCommandSpec.predicateResult) || matchingCommandSpec.description;
    }
  }
  function executeCommand({ command, value }, event) {
    const matchingCommandSpec = getCommandSpec(command, value);
    if (matchingCommandSpec) {
      return matchingCommandSpec.executeCommand(command, value, matchingCommandSpec.predicateResult, event);
    } else {
      return "unknown command - type ? for help";
    }
  }
  registerCommand(
    /^\/?r\/(.*)/,
    "r/[subreddit] - navigates to subreddit",
    (command, val, match) => `navigate to subreddit: ${match[1]}`,
    (command, val, match, e2) => {
      navigateTo(`/r/${match[1]}`, e2);
    }
  );
  registerCommand(
    /^\/?m\/(.*)/,
    "m/[multi] - view your multi-reddit [multi]",
    (command, val, match) => `navigate to multi-reddit: /me/m/${match[1]}`,
    (command, val, match, e2) => {
      navigateTo(`/me/m/${match[1]}`, e2);
    }
  );
  registerCommand(
    "m",
    "m - go to inbox",
    () => "View messages",
    (command, value, match, e2) => {
      navigateTo("/message/inbox/", e2);
    }
  );
  registerCommand(
    "mm",
    "mm - go to moderator mail",
    () => "View moderator mail",
    (command, value, match, e2) => {
      navigateTo("/message/moderator/", e2);
    }
  );
  registerCommand(
    "front",
    "front - go to frontpage",
    () => "Go to frontpage",
    (command, value, match, e2) => {
      navigateTo("/", e2);
    }
  );
  registerCommand(
    /^XHR/,
    "XHRCache clear - manipulate the XHR cache",
    () => "clear - clear the cache (use if inline images aren't loading properly)",
    (command, value) => {
      if (/^\s*$/.test(value)) {
        return "Operation required [clear]";
      }
      switch (value) {
        case "clear":
          xhrCache_exports.clear();
          break;
        default:
          return "The only accepted operation is <tt>clear</tt>";
      }
    }
  );
  registerCommand(
    /^user$|^u$|^\/?u(?:ser)?\/(\w*((?!\/m\/).)*)$/,
    "user [username] or u/[username] - view profile for [username]",
    (command, val, match) => {
      val = val || match[1];
      if (!val && loggedInUser()) {
        return "go to profile";
      } else if (!val) {
        return false;
      } else {
        return `go to profile for: ${val}`;
      }
    },
    (command, val, match, e2) => {
      val = val || match[1] || loggedInUser();
      if (!val) {
        return "not logged in";
      }
      navigateTo(`/u/${val}`, e2);
    }
  );
  registerCommand(
    /^\/?u(?:ser)?\/(\w+)\/m(?:\/(.+))?/,
    "u/[username]/m/[multi] - view the multireddit [multi] curated by [username]",
    (command, val, match) => `navigate to multi-reddit: /u/${match[1]}/m/${match[2] || ""}`,
    (command, val, match, e2) => {
      if (!match[1]) {
        return "no multi-reddit specified";
      }
      navigateTo(`/u/${match[1]}/m/${match[2]}`, e2);
    }
  );
  registerCommand(
    /^\/?me(?:\/?(.*))$/,
    [
      "me - view profile for current user",
      "me/saved or me/s - view current user's saved links",
      "me/saved#comments or me/sc - view current user's saved comments",
      "me/submitted or me/sub - view current user's submitted content",
      "me/comments or me/c - view current user's comments",
      "me/gilded or me/g - view current user's gilded content",
      "me/liked or me/l - view current user's liked content ",
      "me/disliked or me/d - view current user's disliked content",
      "me/hidden or me/h - view current user's hidden content"
    ],
    (command, val, match) => {
      const loggedIn = loggedInUser();
      if (!loggedIn) {
        return "not logged in";
      }
      let str;
      switch (match[1]) {
        case "":
          str = `navigate to user profile: ${loggedIn}`;
          break;
        case "saved":
        case "s":
          str = "navigate to current user's saved content";
          break;
        case "saved#comments":
        case "sc":
          str = "navigate to current RES's saved comments";
          break;
        case "submitted":
        case "sub":
          str = "navigate to current user's submitted content";
          break;
        case "comments":
        case "c":
          str = "navigate to current user's comments";
          break;
        case "gilded":
        case "g":
          str = "navigate to current user's gilded content";
          break;
        case "liked":
        case "l":
          str = "navigate to current user's liked content";
          break;
        case "disliked":
        case "d":
          str = "navigate to current user's disliked content";
          break;
        case "hidden":
        case "h":
          str = "navigate to current user's hidden content";
          break;
        default:
          str = "navigate to [s]aved, [s]aved[c]omments, [sub]mitted, [c]omments, [g]ilded, [l]iked, [d]isliked, [h]idden";
          break;
      }
      return str;
    },
    (command, val, match, e2) => {
      const currentUser = loggedInUser();
      if (!currentUser) {
        return "not logged in";
      }
      switch (match[1]) {
        case "":
          navigateTo(`/user/${currentUser}`, e2);
          break;
        case "saved":
        case "s":
          navigateTo(`/user/${currentUser}/saved`, e2);
          break;
        case "saved#comments":
        case "sc":
          navigateTo(`/user/${currentUser}/saved#comments`, e2);
          break;
        case "submitted":
        case "sub":
          navigateTo(`/user/${currentUser}/submitted`, e2);
          break;
        case "comments":
        case "c":
          navigateTo(`/user/${currentUser}/comments`, e2);
          break;
        case "gilded":
        case "g":
          navigateTo(`/user/${currentUser}/gilded`, e2);
          break;
        case "liked":
        case "l":
          navigateTo(`/user/${currentUser}/liked`, e2);
          break;
        case "disliked":
        case "d":
          navigateTo(`/user/${currentUser}/disliked`, e2);
          break;
        case "hidden":
        case "h":
          navigateTo(`/user/${currentUser}/hidden`, e2);
          break;
        default:
          return "unknown command - type ? for help";
      }
    }
  );
  registerCommand(
    "userinfo",
    false,
    () => {
    },
    (command, val) => {
      if (val.length <= 1) {
        return "No username specified.";
      } else {
        ajax({ url: string_exports.encode`/user/${val}/about.json` }).then(alert_exports.open);
      }
    }
  );
  registerCommand(
    "userbadge",
    false,
    () => {
    },
    (command, val) => {
      if (val.length <= 1) {
        return "No username specified.";
      } else {
        ajax({
          url: string_exports.encode`/user/${val}/about.json`,
          type: "json"
        }).then(({ data: data2 }) => alert_exports.open(`, .id-t2_${data2.id}::before`));
      }
    }
  );
  {
    let sanitizeStorageKey = function(key) {
      let match;
      if (match = optionsRegex.exec(key)) {
        key = `RESoptions.${match[1]}`;
      } else if (match = moduleDataRegex.exec(key)) {
        key = `RESmodules.${match[1]}`;
      }
      return key;
    }, executeCommand2 = function(command, key, value) {
      if (command === "get") {
        storage_exports.get(key).then(
          (value2) => alert_exports.open(string_exports.escape`Value of RESStorage[${key}]: <br><br><textarea rows="5" cols="50">${JSON.stringify(value2)}</textarea>`)
        );
      } else if (command === "update") {
        storage_exports.get(key).then((value2) => {
          const element = string_exports.html`<div>Value of RESStorage[${key}]: <br><br><textarea rows="5" cols="50">${JSON.stringify(value2)}</textarea></div>`;
          alert_exports.open(element, { cancelable: true }).then(() => storage_exports.set(key, JSON.parse(downcast(element.querySelector("textarea"), HTMLTextAreaElement).value)));
        });
      } else if (command === "remove") {
        storage_exports.delete(key);
        alert_exports.open(string_exports.escape`RESStorage[${key}] deleted`);
      } else if (command === "set") {
        storage_exports.set(key, JSON.parse(value));
        alert_exports.open(string_exports.escape`RESStorage[${key}] set to:<br><br><textarea rows="5" cols="50">${value}</textarea>`);
      } else {
        return 'You must specify either "get [key]" or "set [key] [value]"';
      }
    };
    const optionsRegex = /(?:RES)?opt(?:ion)?s?[\.\s]+(.*)/i;
    const moduleDataRegex = /(?:RES)?mod(?:ule)?s?[\.\s]+(.*)/i;
    registerCommand(
      /(?:RES)?stor(?:e|age)?/i,
      "RESStorage [get|set|update|remove] [key] [value] - For debug use only, you shouldn't mess with this unless you know what you're doing.",
      () => {
      },
      (command, val) => {
        const splitWords = val.split(" ");
        if (splitWords.length < 2) {
          return 'You must specify "get [key]", "update [key]" or "set [key] [value]"';
        } else {
          const key = sanitizeStorageKey(splitWords[1]);
          const value = splitWords.slice(2).join(" ");
          return executeCommand2(splitWords[0], key, value);
        }
      }
    );
  }
  var sortTypes = {
    n: "new",
    t: "top",
    h: "hot",
    r: "rising",
    c: "controversial",
    g: "gilded",
    p: "ads"
  };
  var sortTypeRecognizesPeriod = (sortType) => sortTypes.t === sortType || sortTypes.c === sortType;
  var periods = ["hour", "day", "week", "month", "year", "all"];
  var getPeriod = (val) => val && periods.find((period) => period.startsWith(val));
  registerCommand(
    /^\/([nthrcgp])?/,
    "/n, /t, /h, /r, /c, /g, or /p - goes to new, top, hot, rising, controversial, gilded, or promoted sort of current subreddit, multireddit or user page",
    (command, val, match) => {
      const sortType = sortTypes[match[1]];
      if (sortType) {
        return sortTypeRecognizesPeriod(sortType) ? `sort by ${sortType} [(${periods.map((period) => getPeriod(val) === period ? `<b>${period}</b>` : period).join("|")})]` : `sort by ${sortType}`;
      } else {
        return "sort by ([n]ew, [t]op, [h]ot, [r]ising, [c]ontroversial, [g]ilded, [p]romoted)";
      }
    },
    (command, val, match, e2) => {
      const sortType = sortTypes[match[1]];
      if (!sortType) {
        return "invalid sort command - must be one of [n]ew, [t]op, [h]ot, [r]ising, [c]ontroversial, [g]ilded, [p]romoted";
      }
      function _navigateTo(v) {
        const url = new URL(v, location.href);
        const period = getPeriod(val);
        if (sortTypeRecognizesPeriod(sortType) && period) {
          url.searchParams.append("t", period);
        }
        navigateTo(url.href, e2);
      }
      const currentUser = currentUserProfile();
      if (currentUser) {
        if (sortType === "gilded") {
          _navigateTo(`/user/${currentUser}/${sortType}`);
        } else if (sortType === "ads" || sortType === "rising") {
          return `invalid sort command - "${sortType}" is not supported on profile pages`;
        } else {
          _navigateTo(`/user/${currentUser}?sort=${sortType}`);
        }
        return;
      }
      const subreddit2 = currentSubreddit();
      if (subreddit2) {
        _navigateTo(`/r/${subreddit2}/${sortType}`);
        return;
      }
      const multi = currentMultireddit();
      if (multi) {
        _navigateTo(`/${multi}/${sortType}`);
      } else {
        _navigateTo(`/${sortType}`);
      }
    }
  );
  registerCommand(
    (cmd) => ["s", "search"].includes(cmd),
    "s[earch] [query] - searches the current subreddit (if any) or all of Reddit",
    (command, val) => {
      const subreddit2 = currentSubreddit();
      if (!subreddit2) {
        return `Search all of Reddit: ${val}`;
      }
      return `Search /r/${subreddit2}: ${val}`;
    },
    (command, val, match, e2) => {
      const subreddit2 = currentSubreddit();
      if (!subreddit2) {
        navigateTo(string_exports.encode`/search?q=${val}`, e2);
        return;
      }
      navigateTo(string_exports.encode`/r/${subreddit2}/search?q=${val}&restrict_sr=on`, e2);
    }
  );
  registerCommand(
    "sr",
    "sr [query] - searches all of Reddit",
    (command, val) => `Search all of Reddit: ${val}`,
    (command, val, match, e2) => {
      navigateTo(string_exports.encode`/search?q=${val}`, e2);
    }
  );
  registerCommand(
    "?",
    false,
    () => {
      const descriptions = commands.map((command) => command.description).reduce((a2, b2) => b2 ? a2.concat(b2) : a2, []);
      if (descriptions.length) {
        return `<ul><li>${descriptions.join("</li><li>")}</li></ul>`;
      }
    },
    () => false
  );

  // lib/modules/menu.js
  var module4 = new Module("RESMenu");
  module4.moduleName = "menuName";
  module4.category = "coreCategory";
  module4.description = 'The <span class="gearIcon"></span> dropdown menu to manage RES settings and quick options';
  module4.descriptionRaw = true;
  module4.alwaysEnabled = true;
  module4.options = {
    gearIconClickAction: {
      title: "menuGearIconClickActionTitle",
      type: "enum",
      values: [{
        name: "menuGearIconClickActionOpenSettings",
        value: "openSettings"
      }, {
        name: "menuGearIconClickActionOpenCommandLine",
        value: "openCommandLine"
      }, {
        name: "menuGearIconClickActionToggleMenu",
        value: "toggleMenu"
      }, {
        name: "menuGearIconClickActionToggleMenuNoHover",
        value: "toggleMenuNoHover"
      }],
      value: "toggleMenuNoHover",
      description: "menuGearIconClickActionDesc",
      bodyClass: true,
      advanced: true
    }
  };
  var items = [];
  var gear;
  module4.contentStart = () => {
    gear = string_exports.html`<span id="RESSettingsButton" style="cursor: pointer" title="${i18n("RESSettings")}" class="gearIcon"></span>`;
    if (module4.options.gearIconClickAction.value !== "toggleMenuNoHover") {
      gear.addEventListener("mouseenter", () => {
        showDropdown(200);
      });
    }
    gear.addEventListener("click", () => {
      if (module4.options.gearIconClickAction.value === "openCommandLine" && isRunning(commandLine_exports)) {
        toggle2();
        hideDropdown();
      } else if (module4.options.gearIconClickAction.value === "openSettings") {
        open3();
        hideDropdown();
      } else {
        showDropdown(0);
      }
    });
    addFloater(gear, { order: 5, container: "inNavbar" });
  };
  module4.afterLoad = () => {
    requestAnimationFrame(addLegacyStyling);
  };
  function showDropdown(openDelay) {
    dropdownList(module4.moduleID).options({
      openDelay,
      fadeDelay: 200,
      fadeSpeed: 0.2
    }, false).populateWith(() => {
      const f2 = document.createDocumentFragment();
      f2.append(...items.sort(({ order: a2 }, { order: b2 }) => a2 - b2).map(buildItem));
      return [f2];
    }).target(gear).begin();
  }
  function hideDropdown() {
    dropdownList(module4.moduleID).close(true);
  }
  function addMenuItem(getElement, onClick2 = () => {
  }, order = 0) {
    items.push({ getElement, onClick: onClick2, order });
  }
  function buildItem({ getElement, onClick: onClick2 }) {
    const li = document.createElement("li");
    li.addEventListener("click", onClick2, true);
    li.addEventListener("click", hideDropdown);
    li.append(getElement());
    return li;
  }
  function addLegacyStyling() {
    const { backgroundImage } = window.getComputedStyle(gear);
    if (backgroundImage && backgroundImage !== "none") {
      gear.classList.add("res-gearIcon-legacy");
    }
  }

  // lib/modules/settingsNavigation.js
  var module5 = new Module("settingsNavigation");
  module5.moduleName = "settingsNavName";
  module5.category = "coreCategory";
  module5.description = "settingsNavDesc";
  module5.hidden = true;
  module5.alwaysEnabled = true;
  module5.options = {
    showAllOptions: {
      title: "settingsNavigationShowAllOptionsTitle",
      type: "boolean",
      value: true,
      description: "settingsNavigationShowAllOptionsDesc",
      noconfig: true
    }
  };
  module5.beforeLoad = () => {
    addMenuItem(
      () => string_exports.html`<div id="SettingsConsole">
			${i18n("RESSettingsConsole")}
			<span module="search" class="RESMenuItemButton res-icon" title="search settings">\uF094</span>
		</div>`,
      (e2) => open3(e2.target.getAttribute("module")),
      -10
    );
    registerCommand(
      /^set(?:t?ings?)?$/,
      "settings [words to search for]- search RES settings console",
      (command, val) => `Search RES settings ${val && val.length ? ` for: ${val}` : ""}`,
      (command, val) => open3("search", val)
    );
  };
  module5.contentStart = () => {
    function findModules(val) {
      return all().filter((v) => !v.hidden).map((v) => v.moduleID).filter((id2) => id2.toLowerCase().match(val.toLowerCase())).sort();
    }
    registerCommand(
      /^mod(?:ule?)?$/,
      "module [name of module] - open module settings",
      (command, val) => {
        const matches2 = findModules(val);
        return matches2.length ? `Open module ${matches2[0]}` : "Could not find any matching module.";
      },
      (command, val) => open3(findModules(val)[0])
    );
    window.addEventListener("popstate", () => {
      update2();
    });
    update2();
    document.body.addEventListener("click", (e2) => {
      if (e2.ctrlKey) return;
      const url = e2.target instanceof HTMLAnchorElement && new URL(e2.target.href, location.origin);
      if (url && isSettingsUrl(url.href)) {
        update2(url);
        e2.stopImmediatePropagation();
        e2.preventDefault();
      }
    }, true);
  };
  function makeUrlHashLink(moduleID, optionKey, displayText, cssClass) {
    const mod = getUnchecked(moduleID);
    if (!displayText) {
      if (mod && optionKey) {
        displayText = i18n(mod.options[optionKey].title);
      } else if (mod) {
        displayText = i18n(mod.moduleName);
      } else {
        displayText = "Settings";
      }
    }
    let title = ["RES Settings"];
    if (mod) {
      title.push(i18n(mod.moduleName));
    }
    if (optionKey) {
      title.push(optionKey);
    }
    title = title.join(" &gt; ");
    const hash = makeUrlHash(moduleID, optionKey);
    return `<a class="${cssClass || ""}" href="${hash}" title="${title}">${displayText}</a>`;
  }
  function parseHash(hash) {
    const params = hash.match(/\/(?:\w|\s|%20)+/g);
    return {
      moduleID: params && params[0] && params[0].substring(1).replace("%20", " ") || void 0,
      optionKey: params && params[1] && params[1].substring(1).replace("%20", " ") || void 0
    };
  }
  function makeUrlHash(moduleID, optionKey) {
    const hashComponents = [RES_SETTINGS_HASH];
    if (moduleID) {
      hashComponents.push(moduleID);
    }
    if (moduleID && optionKey) {
      hashComponents.push(optionKey);
    }
    return hashComponents.join("/");
  }
  function isSettingsUrl(href) {
    const { origin, hash } = new URL(href, location.origin);
    const sameSite = origin === getOptionsURL().origin || origin.split(".").slice(-2).join(".") === data.origin.split(".").slice(-2).join(".");
    if (!sameSite) return false;
    return hash.startsWith(RES_SETTINGS_HASH) || hash.startsWith("#!settings");
  }
  function setHash(hash) {
    if (window.top === window) {
      if (parseHash(location.hash).moduleID === parseHash(hash).moduleID) {
        history.replaceState(null, "", hash);
      } else {
        history.pushState(null, "", hash);
      }
    } else {
      window.parent.postMessage({ hash }, "*");
    }
  }
  var iframe;
  function update2(url = location) {
    if (isSettingsUrl(url.href)) {
      const { moduleID, optionKey } = parseHash(url.hash);
      open3(moduleID, optionKey);
    } else if (iframe) {
      iframe.contentWindow.postMessage({ close: true }, "*");
    }
  }
  function listener({ origin, data: data2 }) {
    if (origin !== getOptionsURL().origin) return;
    const { failedToLoad, hash, closing } = data2;
    if (failedToLoad) handleEmbedFailure();
    if (hash) setHash(hash);
    if (closing) close2();
  }
  function handleEmbedFailure() {
    console.warn("Embed failed. Opening RES settings console in new tab");
    if (iframe) openNewTab(iframe.src, true);
    close2();
  }
  function open3(moduleID, optionKey) {
    if (iframe || isOptionsPage()) {
      (iframe && iframe.contentWindow || window).postMessage({ load: { moduleID, optionKey } }, "*");
    } else {
      iframe = document.createElement("iframe");
      iframe.id = "console-container";
      iframe.src = getOptionsURL(makeUrlHash(moduleID, optionKey)).href;
      window.addEventListener("message", listener);
      iframe.addEventListener("load", () => {
        if (iframe) iframe.contentWindow.postMessage({ context: data }, "*");
        let success;
        window.addEventListener("message", ({ origin, data: data2 }) => {
          if (origin === getOptionsURL().origin && data2.loadSuccess) success = true;
        });
        setTimeout(() => {
          if (!success) handleEmbedFailure();
        }, 3e3);
      });
      document.body.append(iframe);
      document.body.classList.add("res-console-open");
    }
  }
  function close2() {
    if (isOptionsPage()) {
      window.parent.postMessage({ closing: true }, "*");
      window.close();
    } else {
      window.removeEventListener("message", listener);
      if (!iframe) return;
      iframe.remove();
      iframe = null;
      document.body.classList.remove("res-console-open");
      if (isSettingsUrl(location.href)) history.pushState(null, "", location.pathname + location.search);
    }
  }

  // lib/modules/notifications.js
  var module6 = new Module("notifications");
  module6.moduleName = "notificationsName";
  module6.category = "coreCategory";
  module6.description = "notificationsDesc";
  module6.options = {
    sticky: {
      description: "notificationStickyDesc",
      title: "notificationStickyTitle",
      type: "enum",
      value: "notificationType",
      values: [{
        name: "notificationsPerNotificationType",
        value: "notificationType"
      }, {
        name: "notificationsAlwaysSticky",
        value: "all"
      }, {
        name: "notificationsNeverSticky",
        value: "none"
      }]
    },
    closeDelay: {
      type: "text",
      value: "3000",
      description: "notificationCloseDelayDesc",
      title: "notificationCloseDelayTitle"
    },
    fadeOutLength: {
      type: "text",
      value: "3000",
      description: "notificationFadeOutLengthDesc",
      title: "notificationFadeOutLengthTitle",
      advanced: true
    },
    notificationTypes: {
      description: "notificationNotificationTypesDesc",
      title: "notificationNotificationTypesTitle",
      type: "table",
      advanced: true,
      addRowText: "notificationsAddNotificationType",
      fields: [{
        key: "id",
        name: "notificationsNotificationID",
        type: "text"
      }, {
        key: "enabled",
        name: "notificationsEnabled",
        type: "boolean",
        value: true
      }, {
        key: "sticky",
        name: "notificationsSticky",
        type: "boolean",
        value: false
      }],
      value: []
    }
  };
  var notificationsContainer = string_exports.html`<div id="RESNotifications"></div>`;
  var lastShownStorage = storage_exports.wrapBlob("notifications.lastShown", () => 0);
  module6.go = () => {
    document.body.append(notificationsContainer);
  };
  var activeNotifications = /* @__PURE__ */ new Set();
  function showNotification(opts, _delay) {
    const data2 = typeof opts === "string" ? { message: opts } : opts;
    const id2 = `${String(firstValid(data2.moduleID, "--"))}-${String(firstValid(data2.notificationID, data2.optionKey, data2.header, hashCode(data2.message instanceof HTMLElement ? data2.message.outerHTML : data2.message)))}`;
    const mod = data2.moduleID && getUnchecked(data2.moduleID);
    const element = string_exports.html`
		<div class="RESNotification" data-id="${id2}">
			<div class="RESNotificationHeader">
				<h3>${data2.header || (mod ? i18n(mod.moduleName) : "") || ""}</h3>
				${mod && !mod.hidden ? string_exports.safe(makeUrlHashLink(mod.moduleID, data2.optionKey, " ", "gearIcon")) : ""}
				<div class="RESCloseButton"></div>
			</div>
			<div class="RESNotificationContent"></div>
			<div class="RESNotificationFooter" ${data2.noDisable ? "hidden" : ""}>
				<label class="RESNotificationToggle" title="Show notifications from ${id2}">
					<input type="checkbox" checked> Always show this type of notification
				</label>
			</div>
		</div>
	`;
    (0, import_jquery3.default)(element.querySelector(".RESNotificationContent")).append(data2.message);
    const inner = element.innerHTML;
    const existing = [...activeNotifications.values()].find(({ element: element2 }) => element2.innerHTML === inner);
    if (existing) {
      existing.element.dispatchEvent(new CustomEvent("notification-reset"));
      return existing;
    }
    const close3 = once_default(() => {
      activeNotifications.delete(notification);
      element.remove();
    });
    const notification = { element, close: close3 };
    activeNotifications.add(notification);
    const storage3 = table_exports2.getMatchingValueOrAdd(module6, "notificationTypes", { id: id2 }, data2);
    element.querySelector(".RESNotificationToggle input").addEventListener("change", (e2) => {
      storage3.enabled = e2.currentTarget.checked;
    });
    element.querySelector(".RESCloseButton").addEventListener("click", () => {
      close3();
    });
    const isSticky = module6.options.sticky.value === "all" || module6.options.sticky.value === "notificationType" && storage3.sticky;
    const delay = +firstValid(_delay, data2.closeDelay, parseInt(module6.options.closeDelay.value, 10), module6.options.closeDelay.default);
    const fadeDuration = +firstValid(parseInt(module6.options.fadeOutLength.value, 10), module6.options.fadeOutLength.default);
    async function resetCloseTimer() {
      await new Promise(requestAnimationFrame);
      if (element.matches(":hover")) await waitForEvent(element, "mouseleave");
      let fadeTimer;
      const hideTimer2 = setTimeout(() => {
        element.classList.add("transitionToTransparent");
        element.style.transitionDuration = `${fadeDuration / 1e3}s`;
        fadeTimer = setTimeout(() => close3(), fadeDuration);
      }, delay);
      await waitForEvent(element, "mouseenter", "notification-reset");
      element.classList.remove("transitionToTransparent");
      if (fadeTimer) clearTimeout(fadeTimer);
      if (hideTimer2) clearTimeout(hideTimer2);
      resetCloseTimer();
    }
    (async () => {
      if (!storage3.enabled || !isRunning(module6)) return;
      if (data2.cooldown) {
        if (data2.cooldown > Date.now() - await lastShownStorage.get(id2)) return;
        lastShownStorage.set(id2, Date.now());
      }
      requestAnimationFrame(() => {
        if (window.getComputedStyle(element).maxHeight === "initial") return;
        element.style.maxHeight = "100vh";
      });
      notificationsContainer.prepend(element);
      if (!isSticky && delay !== Infinity) resetCloseTimer();
    })();
    return notification;
  }

  // lib/modules/penaltyBox.js
  var module7 = new Module("penaltyBox");
  var MIN_PENALTY = 1;
  var MAX_PENALTY = 100;
  module7.moduleName = "penaltyBoxName";
  module7.category = "coreCategory";
  module7.description = "penaltyBoxDesc";
  module7.options = {
    delayFeatures: {
      type: "boolean",
      value: true,
      description: "penaltyBoxDelayFeaturesDesc",
      title: "penaltyBoxDelayFeaturesTitle"
    },
    suspendFeatures: {
      type: "boolean",
      value: false,
      description: "penaltyBoxSuspendFeaturesDesc",
      title: "penaltyBoxSuspendFeaturesTitle"
    },
    features: {
      description: "penaltyBoxFeaturesDesc",
      title: "penaltyBoxFeaturesTitle",
      type: "table",
      advanced: true,
      addRowText: "penaltyBoxFeaturesAddRowText",
      fields: [
        {
          key: "moduleID",
          name: "moduleID",
          type: "text"
        },
        {
          key: "optionKey",
          name: "optionKey",
          type: "text"
        },
        {
          key: "monitoring",
          name: "penaltyBoxFeaturesMonitoring",
          type: "boolean",
          value: true
        },
        {
          key: "penalty",
          name: "penaltyBoxFeaturesPenalty",
          type: "text",
          value: "0"
        }
      ],
      value: []
    }
  };
  function alterFeaturePenalty(moduleID, optionKey, valueDelta) {
    if (isNaN(parseInt(valueDelta, 10))) {
      console.warn("Could not alter penalty for", moduleID, optionKey, " - bad value:", valueDelta);
      return MIN_PENALTY;
    }
    if (!isEnabled(module7)) {
      return MIN_PENALTY;
    }
    const value = getOrAddFeatures(moduleID, optionKey);
    if (!value.monitoring) return MIN_PENALTY;
    value.penalty = clamp_default(value.penalty + valueDelta, MIN_PENALTY, MAX_PENALTY);
    save2(module7.options.features);
    if (value.penalty >= MAX_PENALTY) {
      suspendFeature(moduleID, optionKey);
    }
    return value.penalty;
  }
  function stopMonitoringFeature(moduleID, optionKey) {
    const value = getOrAddFeatures(moduleID, optionKey);
    value.monitoring = false;
    value.penalty = MIN_PENALTY;
    save2(module7.options.features);
  }
  function getFeaturePenalty(moduleID, optionKey) {
    if (!isEnabled(module7)) {
      return MIN_PENALTY;
    }
    if (!module7.options.delayFeatures.value) {
      return MIN_PENALTY;
    }
    const value = getOrAddFeatures(moduleID, optionKey);
    if (!value.monitoring) {
      return MIN_PENALTY;
    }
    if (!value.penalty || MIN_PENALTY >= value.penalty) {
      return MIN_PENALTY;
    }
    return value.penalty;
  }
  function penalizedDelay(moduleID, optionKey, delayOption) {
    const penalty = getFeaturePenalty(moduleID, optionKey);
    if (!penalty || penalty === MIN_PENALTY) {
      return parseInt(delayOption.value, 10);
    }
    const max = parseInt(delayOption.penalizedValue || delayOption.value, 10) * 6;
    const initial3 = parseInt(delayOption.default, 10);
    const position = penalty / 100;
    return Math.min(max, (max - initial3) * position + initial3);
  }
  var getOrAddFeatures = (moduleID, optionKey) => table_exports2.getMatchingValueOrAdd(module7, "features", { moduleID, optionKey }, { penalty: 0 });
  function suspendFeature(moduleID, optionKey) {
    const featureModule = get4(moduleID);
    const option2 = featureModule.options[optionKey];
    if (!option2) {
      console.warn("Could not find option", moduleID, optionKey);
      return;
    }
    if (option2.type !== "boolean") {
      console.warn(`${module7.moduleID} could not disable option`, moduleID, optionKey);
      return;
    }
    const oldValue = option2.value;
    const newValue = !option2.value;
    set5(moduleID, optionKey, newValue);
    stopMonitoringFeature(moduleID, optionKey);
    const featureOptionLink = makeUrlHashLink(moduleID, optionKey);
    const notification = showNotification({
      moduleID: module7.moduleID,
      optionKey: "suspendFeatures",
      header: i18n("penaltyBoxSuspendFeaturesNotificationHeader"),
      message: `
			${i18n("penaltyBoxSuspendFeaturesNotificationMessage", featureOptionLink)}
			<p><a class="RESNotificationButtonBlue" id="penaltyBoxEnableFeature" href="#">
				${i18n("penaltyBoxSuspendFeaturesUndoButton")}
			</a></p>
		`.trim()
    });
    (0, import_jquery4.default)(notification.element).on("click", "#penaltyBoxEnableFeature", (e2) => {
      e2.preventDefault();
      notification.close();
      pardonSuspendedFeature(moduleID, optionKey, oldValue);
    });
  }
  function pardonSuspendedFeature(moduleID, optionKey, oldValue) {
    set5(moduleID, optionKey, oldValue);
    stopMonitoringFeature(moduleID, optionKey);
    const featureOptionLink = makeUrlHashLink(moduleID, optionKey);
    showNotification({
      moduleID: module7.moduleID,
      optionKey: "suspendFeatures",
      header: i18n("penaltyBoxSuspendFeaturesRevertNotificationHeader"),
      message: i18n("penaltyBoxSuspendFeaturesRevertNotificationMessage", featureOptionLink)
    });
  }

  // lib/modules/keyboardNav.js
  var keyboardNav_exports = {};
  __export(keyboardNav_exports, {
    module: () => module28
  });
  var import_jquery23 = __toESM(require_jquery(), 1);

  // lib/modules/commentNavigator.js
  var commentNavigator_exports = {};
  __export(commentNavigator_exports, {
    module: () => module22,
    move: () => move3,
    setCategory: () => setCategory,
    toggle: () => toggle4,
    updateCustomConditions: () => updateCustomConditions,
    updateFromSelected: () => updateFromSelected
  });

  // lib/modules/filteReddit/Case.js
  var Case = class _Case {
    static type;
    static text;
    staticthingToCriterion;
    staticparseCriterion;
    static async getSelectedEntryValue() {
      const selected = selectedThing_exports.current;
      if (!selected) throw new Error("No entry is currently selected.");
      let conditions;
      if (this.defaultConditions) {
        if (!this.thingToCriterion) throw Error("Case does not have method `thingToCriterion`");
        conditions = this.criterionToConditions(await this.thingToCriterion(selected));
      }
      const cased = this.fromConditions(conditions);
      const state = await cased.evaluate(selected);
      if (typeof state !== "boolean") throw new Error("Could not evaluate case against selected thing");
      return { conditions, state };
    }
    static criterionToConditions(criterion) {
      const parse2 = this.parseCriterion && this.parseCriterion.bind(this);
      if (!parse2) {
        throw new Error("Does not accept criterion");
      }
      if (!criterion && this.pattern && !this.pattern.startsWith("[")) {
        throw new Error("Requires criterion");
      }
      const parts = criterion.split(" & ");
      if (this.criterionOperators && criterion && parts.length > 1) {
        return getGroup("all", parts.map((v) => getConditions(this.type, parse2(v))));
      } else {
        return parse2(criterion);
      }
    }
    static fromConditions(from, propagateError = false) {
      let cased;
      const conditions = getConditions(from && from.type || this.type, from);
      const type = conditions.type;
      try {
        const CaseClass = get6(type);
        if (CaseClass.disabled) throw new Error(`${CaseClass.type} is disabled`);
        cased = new CaseClass(conditions);
      } catch (e2) {
        if (propagateError) throw e2;
        console.error(`Could not build case: ${e2.message}. Ignoring.`, e2);
        cased = new Inert(conditions);
      }
      return cased;
    }
    static buildRegex(val, { fullMatch = true } = {}) {
      if (!val) throw new Error("Pattern cannot be empty");
      if (string_exports.regexRegex.test(val)) {
        const [, str, flags] = string_exports.regexRegex.exec(val);
        return new RegExp(str, flags);
      } else {
        const patt = escapeRegExp_default(val);
        return new RegExp(fullMatch ? `^${patt}$` : patt, "i");
      }
    }
    staticdefaultConditions;
    static fields;
    static slow = 0;
    // Estimated slowness of case; higher value  slower
    staticreconcile;
    static get disabled() {
      return false;
    }
    // Determines where cases are available; usually set by Cases.populate
    static contexts;
    static validate(conditions) {
      const cased = _Case.fromConditions(conditions, true);
      if (!cased.isValid()) throw new Error("Invalid conditions");
      return true;
    }
    // For Filterline
    static unique = false;
    static variant = "basic";
    static pattern = "";
    static criterionOperators = false;
    // Create groups on encountering operators: ' & '  'and'
    static _customFilter;
    static getCustomFilter() {
      if (this._customFilter) return this._customFilter;
      throw new Error("Source not found");
    }
    trueText;
    falseText;
    constructor(conditions) {
      this.conditions = this.value = conditions;
    }
    isValid() {
      return true;
    }
    isEvaluatable() {
      return !(this instanceof Inert || this.constructor.disabled);
    }
    hasType(type) {
      return this.constructor.type === type;
    }
    conditions;
    value;
    evaluate(thing, values) {
      throw new Error("evaluate() must be implemented for all Case subclasses");
    }
    observers = /* @__PURE__ */ new Set();
    onObserve() {
    }
    // `true`  `refresh` callback registered
    observe(observer) {
      if (!this.observers.has(observer) && this.onObserve()) {
        this.observers.add(observer);
        return true;
      }
    }
    refresh(thing) {
      for (const o2 of this.observers) o2.refresh(thing);
    }
  };
  var PatternCase = class extends Case {
    static parseCriterion(input2) {
      return { patt: input2 };
    }
    static defaultConditions = { patt: "" };
    static pattern = "RegEx";
    static reconcile(values) {
      const variants = [];
      for (const v of values) {
        let variant;
        variantLoop:
          for (const possibleVariant of variants) {
            for (const key of Object.keys(v)) {
              if (key === "patt") continue;
              if (possibleVariant[key] !== v[key]) continue variantLoop;
            }
            variant = possibleVariant;
            break;
          }
        if (!variant) {
          variant = { ...v, patt: [] };
          variants.push(variant);
        }
        variant.patt.push(v.patt);
      }
      return variants;
    }
    build(fullMatchDefault, pattIfEmpty) {
      const { patt, fullMatch = fullMatchDefault } = this.conditions;
      const raw = Array.isArray(patt) ? patt : [patt];
      const plain = /* @__PURE__ */ new Set();
      const variants = {};
      for (let _patt of raw) {
        if (!_patt) {
          if (typeof pattIfEmpty === "string") _patt = pattIfEmpty;
          else if (raw.length === 1) throw new Error("Pattern cannot be empty");
          else continue;
        }
        if (string_exports.regexRegex.test(_patt)) {
          const [, str, flags = ""] = string_exports.regexRegex.exec(_patt);
          if (!variants[flags]) variants[flags] = [];
          variants[flags].push(str);
        } else {
          plain.add(escapeRegExp_default(_patt));
        }
      }
      if (plain.size) {
        const str = Array.from(plain).join("|");
        if (!variants.i) variants.i = [];
        variants.i.push(fullMatch ? `^(${str})$` : str);
      }
      return Object.entries(variants).map(([flags, sources]) => new RegExp(sources.join("|"), flags));
    }
  };

  // lib/modules/filteReddit/postCases/index.js
  var postCases_exports = {};
  __export(postCases_exports, {
    commentCount: () => CommentCount,
    commentsOpened: () => CommentsOpened,
    domain: () => Domain,
    hasExpando: () => Expando2,
    isLocked: () => IsLocked,
    isNSFW: () => IsNSFW,
    isSpoiler: () => IsSpoiler,
    isVisited: () => IsVisited,
    linkFlair: () => LinkFlair,
    newCommentCount: () => NewCommentCount,
    postAfter: () => PostAfter,
    postAge: () => PostAge,
    postTitle: () => PostTitle,
    postType: () => PostType,
    score: () => Score,
    selector: () => Selector,
    subreddit: () => Subreddit,
    userAttr: () => UserAttr,
    userFlair: () => UserFlair,
    userTag: () => UserTag,
    userVoteWeight: () => UserVoteWeight,
    username: () => Username,
    voteType: () => VoteType
  });

  // lib/modules/filteReddit/postCases/CommentCount.js
  var CommentCount = class extends Case {
    static text = "Comment count";
    static parseCriterion(input2) {
      return { op: ">=", val: parseInt(input2, 10) };
    }
    static thingToCriterion(thing) {
      return String(thing.getCommentCount() || 0);
    }
    static defaultConditions = { op: ">", val: 0 };
    static fields = ["post has ", { type: "select", options: "COMPARISON", id: "op" }, " ", { type: "number", id: "val" }, " comments"];
    static pattern = "integer";
    trueText = `comment count ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    falseText = `comment count ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
    isValid() {
      return Number.isInteger(this.value.val);
    }
    evaluate(thing) {
      const commentCount = thing.getCommentCount();
      if (isNaN(commentCount)) return null;
      return numericalCompare(this.value.op, commentCount, this.value.val);
    }
  };

  // lib/modules/newCommentCount.js
  var newCommentCount_exports = {};
  __export(newCommentCount_exports, {
    getNewCount: () => getNewCount,
    hasEntry: () => hasEntry,
    module: () => module8
  });
  var import_jquery5 = __toESM(require_jquery(), 1);
  var module8 = new Module("newCommentCount");
  module8.moduleName = "newCommentCountName";
  module8.category = "submissionsCategory";
  module8.description = "newCommentCountDesc";
  module8.options = {
    hideWhenUnchanged: {
      type: "boolean",
      value: true,
      description: "newCommentCountHideWhenUnchangedDesc",
      title: "newCommentCountHideWhenUnchangedTitle"
    },
    cleanComments: {
      type: "text",
      value: "30",
      description: "newCommentCountCleanCommentsDesc",
      title: "newCommentCountCleanCommentsTitle",
      advanced: true
    },
    subscriptionLength: {
      type: "text",
      value: "2",
      description: "newCommentCountSubscriptionLengthDesc",
      title: "newCommentCountSubscriptionLengthTitle"
    },
    showSubscribeButton: {
      type: "boolean",
      value: true,
      description: "newCommentCountShowSubscribeButtonDesc",
      title: "newCommentCountShowSubscribeButtonTitle"
    },
    notifyEditedPosts: {
      dependsOn: (options6) => options6.showSubscribeButton.value,
      type: "boolean",
      value: false,
      description: "newCommentCountNotifyEditedPostsDesc",
      title: "newCommentCountNotifyEditedPostsTitle",
      advanced: true
    },
    monitorPostsVisited: {
      type: "boolean",
      value: true,
      description: "newCommentCountMonitorPostsVisitedDesc",
      title: "newCommentCountMonitorPostsVisitedTitle",
      advanced: true
    },
    monitorPostsVisitedIncognito: {
      dependsOn: (options6) => options6.monitorPostsVisited.value,
      type: "boolean",
      value: false,
      description: "newCommentCountMonitorPostsVisitedIncognitoDesc",
      title: "newCommentCountMonitorPostsVisitedIncognitoTitle",
      advanced: true
    }
  };
  var entryStorage = storage_exports.wrapPrefix2("newCommentCount.", () => {
    throw new Error("Default value should never be retrieved");
  }, void 0, true);
  var subscriptionStorage = storage_exports.wrapBlob("RESmodules.newCommentCount.subscriptions", () => {
    throw new Error("Subscription not found");
  });
  module8.beforeLoad = () => {
    watchForThings(["post"], getNewCount, { immediate: true });
    watchForThings(["post"], displayNewCommentCount);
  };
  module8.contentStart = () => {
    const id2 = (execRegexes.comments(location.pathname) || [])[2];
    if (id2 && module8.options.showSubscribeButton.value) {
      addSubscriptionButton(id2);
    }
    addDashboardTab("newCommentsContents", "My Subscriptions", module8.moduleID, addDashboardFunctionality);
  };
  var listingThing;
  var currentCommentCount;
  module8.afterLoad = () => {
    if (!document.hidden) {
      checkSubscriptions();
    }
    if (isPageType("comments")) {
      listingThing = Thing.from(document.querySelector("#siteTable a.comments"));
      if (listingThing) {
        currentCommentCount = listingThing.getCommentCount();
        if (typeof currentCommentCount === "number") {
          setEntry(getId(listingThing), currentCommentCount);
          watchForThings(["comment"], updateCurrentCommentCountFromMyComment);
        }
      }
    }
    maybePruneOldEntries("newCommentCount", entryStorage, parseInt(module8.options.cleanComments.value, 10));
  };
  var getId = (thing) => thing.getFullname().split("_").slice(-1)[0];
  var hasEntry = (thing) => entryStorage.has(getId(thing));
  function setEntry(id2, newCommentCount) {
    if (!module8.options.monitorPostsVisited.value) return false;
    if (!module8.options.monitorPostsVisitedIncognito.value && isPrivateBrowsing()) return false;
    entryStorage.set(id2, {
      count: newCommentCount,
      updateTime: Date.now()
    });
  }
  var getNewCount = memoize_default(async (thing) => {
    const currentCount = thing.getCommentCount();
    if (typeof currentCount !== "number") return;
    const { count: lastOpenedCount } = await entryStorage.getNullable(getId(thing)) || {};
    if (typeof lastOpenedCount !== "number") return;
    return Math.max(currentCount - lastOpenedCount, 0);
  });
  async function displayNewCommentCount(thing) {
    const newCount = await getNewCount(thing);
    if (typeof newCount !== "number") return;
    if (!newCount && module8.options.hideWhenUnchanged.value) return;
    if (newCount) thing.element.classList.add("res-hasNewComments");
    (0, import_jquery5.default)(thing.getCommentCountElement()).append(`<span class="newComments">&nbsp;(${newCount} new)</span>`);
  }
  function updateCurrentCommentCountFromMyComment(thing) {
    const timestamp = thing.getTimestamp();
    const isRecent = timestamp && Date.now() - timestamp.getTime() < 1e4;
    const isMine = loggedInUser() === thing.getAuthor();
    if (isRecent && isMine && listingThing && typeof currentCommentCount === "number") {
      setEntry(getId(listingThing), ++currentCommentCount);
    }
  }
  var addSubscriptionButton = (id2) => {
    const button = string_exports.html`<span id="REScommentSubToggle" class="RESSubscriptionButton"></span>`;
    const refresh3 = mutex(async () => {
      if (await subscriptionStorage.has(id2)) {
        (0, import_jquery5.default)(button).html('<span class="res-icon">&#xF038;</span> unsubscribe').attr("title", "stop receiving notifications").addClass("unsubscribe");
        waitForEvent(button, "click").then(async () => {
          await unsubscribe(id2);
          showNotification({
            notificationID: "newCommentCountUnsubscribe",
            moduleID: "newCommentCount",
            message: "You are now unsubscribed from this thread."
          }, 3e3);
        }).then(refresh3);
      } else {
        (0, import_jquery5.default)(button).html('<span class="res-icon">&#xF03B;</span> subscribe').attr("title", "notify me of new comments").removeClass("unsubscribe");
        waitForEvent(button, "click").then(async () => {
          await subscribe(id2, currentCommentCount || 0, listingThing && listingThing.getPostEditTimestamp() || 0);
          showNotification({
            notificationID: "newCommentCountSubscribe",
            moduleID: "newCommentCount",
            optionKey: "subscriptionLength",
            message: `
						<p>
							You are now subscribed to this thread for ${module8.options.subscriptionLength.value} days.
							When new comments are posted you'll receive a notification.
						</p>
						<p><a href="/r/Dashboard#newCommentsContents">Manage subscriptions</a></p>
					`
          }, 5e3);
        }).then(refresh3);
      }
    });
    refresh3();
    new Promise(requestAnimationFrame).then(() => waitForDescendant(document.body, ".commentarea .panestack-title, .menuarea")).then((e2) => {
      e2.append(button);
    });
  };
  function subscribe(id2, newCommentCount, newEditedTime) {
    const now4 = Date.now();
    return subscriptionStorage.set(id2, {
      count: newCommentCount,
      subscriptionDate: now4,
      updateTime: now4,
      editedTime: newEditedTime,
      url: location.href.replace(location.hash, ""),
      title: document.title
    });
  }
  function unsubscribe(id2) {
    return subscriptionStorage.delete(id2);
  }
  async function checkSubscriptions() {
    const now4 = Date.now();
    for (const [id2, subscription] of Object.entries(await subscriptionStorage.getAll())) {
      const { subscriptionDate, updateTime } = subscription;
      if (now4 - subscriptionDate > DAY * parseInt(module8.options.subscriptionLength.value, 10)) {
        unsubscribe(id2);
      } else if (now4 - updateTime > 5 * MINUTE) {
        subscriptionStorage.patch(id2, { updateTime: now4 });
        checkThread(id2, subscription);
      }
    }
  }
  async function checkThread(id2, subscription) {
    const { num_comments: newCount, edited: newEditedTime } = await getPostMetadata({ id: id2 });
    const { count, editedTime, url, title } = subscription;
    if (newCount > count) {
      subscriptionStorage.patch(id2, { count: newCount });
      const notification = showNotification({
        header: "New comments",
        notificationID: "newCommentCount",
        moduleID: "newCommentCount",
        noDisable: true,
        message: `<p><a href="${url}">${escapeHTML(title)}</a></p>`
      }, Infinity);
      (0, import_jquery5.default)(notification.element).find(".RESNotificationContent").append(createButton(id2, "unsubscribe", notification.close));
    }
    if (module8.options.notifyEditedPosts.value && newEditedTime > editedTime) {
      subscriptionStorage.patch(id2, { editedTime: newEditedTime });
      const notification = showNotification({
        header: "Post edited",
        notificationID: "newCommentCount",
        moduleID: "newCommentCount",
        optionKey: "notifyEditedPosts",
        noDisable: true,
        message: `<p><a href="${url}">${escapeHTML(title)}</a></p>`
      }, 1e4);
      (0, import_jquery5.default)(notification.element).find(".RESNotificationContent").append(createButton(id2, "unsubscribe", notification.close));
    }
  }
  function createButton(id2, type, onClick2) {
    const $button = (0, import_jquery5.default)('<span class="RESSubscriptionButton">');
    let action;
    switch (type) {
      case "unsubscribe":
        $button.html('<span class="res-icon">&#xF038;</span> unsubscribe').attr("title", "stop receiving notifications").addClass("unsubscribe");
        action = () => unsubscribe(id2);
        break;
      case "renew":
        $button.html('<span class="res-icon">&#xF03B;</span> renew').attr("title", `renew for ${module8.options.subscriptionLength.value} days`);
        action = async () => {
          await subscriptionStorage.patch(id2, { subscriptionDate: Date.now() });
          showNotification({
            notificationID: "newCommentCountRenew",
            moduleID: "newCommentCount",
            optionKey: "subscriptionLength",
            message: `Subscription renewed for ${module8.options.subscriptionLength.value} days.`
          });
        };
        break;
      default:
        break;
    }
    const button = $button.get(0);
    waitForEvent(button, "click").then(action).then(onClick2);
    return button;
  }
  async function addDashboardFunctionality(tabPage) {
    const subscriptions = Object.entries(await subscriptionStorage.getAll());
    const rows = subscriptions.map(([id2, { subscriptionDate, updateTime, url, title }]) => {
      const [, subreddit2] = url && new URL(url).pathname.match(regexes.subreddit) || [];
      if (!subreddit2) return;
      const updated = new Date(updateTime);
      const expires = new Date(subscriptionDate + DAY * parseInt(module8.options.subscriptionLength.value, 10));
      return string_exports._html`
				<tr subscription-id="${id2}">
					<td><a href="${url}">${escapeHTML(title)}</a></td>
					<td><a href="/r/${subreddit2}">/r/${subreddit2}</a></td>
					<td><abbr title="${formatDateTime(updated)}">${formatRelativeTime(updated)}</abbr></td>
					<td><abbr title="${formatDateTime(expires)}">${formatRelativeTime(expires)}</abbr></td>
					<td></td>
				</tr>
			`;
    });
    const ele = string_exports.html`<div>
			<a href="/by_id/${subscriptions.map(([id2]) => `t3_${id2}`).join(",")}">as reddit link listing</a>
			<table id="newCommentsTable">
				<thead>
					<tr>
						<th>Submission</th>
						<th>Subreddit</th>
						<th>Last viewed</th>
						<th>Expires in</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody>
					${rows.length ? rows : string_exports._html`<td colspan="5">You are currently not subscribed to any threads. To subscribe to a thread, click the "subscribe" button found near the top of the comments page.</td>`}
				</tbody>
			</table>
		</div>`;
    (0, import_jquery5.default)(ele).on("click", "th", table_exports.sortByColumn);
    for (const row of ele.querySelectorAll("[subscription-id]")) {
      const id2 = row.getAttribute("subscription-id");
      row.querySelector("td:last-of-type").append(
        createButton(id2, "unsubscribe", () => addDashboardFunctionality(tabPage)),
        createButton(id2, "renew", () => addDashboardFunctionality(tabPage))
      );
    }
    empty(tabPage);
    tabPage.append(ele);
  }

  // lib/modules/filteReddit/postCases/NewCommentCount.js
  var NewCommentCount = class extends Case {
    static text = "New comment count";
    static parseCriterion(input2) {
      return { op: ">=", val: parseInt(input2, 10) };
    }
    static async thingToCriterion(thing) {
      return String((await hasEntry(thing) ? await getNewCount(thing) : thing.getCommentCount()) || 0);
    }
    static defaultConditions = { op: ">", val: 0 };
    static fields = ["has ", { type: "select", options: "COMPARISON", id: "op" }, " ", { type: "number", id: "val" }, " new comments"];
    static slow = 1;
    static get disabled() {
      return !isEnabled(newCommentCount_exports);
    }
    static pattern = "integer";
    trueText = `new comments ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    falseText = `new comments ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
    isValid() {
      return parseInt(this.value.val, 10) >= 0;
    }
    async evaluate(thing) {
      const newCount = await getNewCount(thing);
      const count = typeof newCount === "number" ? newCount : thing.getCommentCount();
      return numericalCompare(this.value.op, count, this.value.val);
    }
  };

  // lib/modules/filteReddit/postCases/CommentsOpened.js
  var CommentsOpened = class extends Case {
    static text = "Comments opened";
    static fields = ["comments page has been visited"];
    static slow = 2;
    static unique = true;
    trueText = "comments opened";
    async evaluate(thing) {
      if (await hasEntry(thing)) return true;
      const link = thing.getCommentsLink();
      if (!link) return null;
      return isURLVisited(link.href);
    }
  };

  // lib/modules/filteReddit/postCases/Domain.js
  var Domain = class extends PatternCase {
    static text = "Link domain name";
    static thingToCriterion(thing) {
      return thing.getPostDomain();
    }
    static fields = ["post links to the domain ", { type: "text", id: "patt" }];
    trueText = `domain ${this.conditions.patt}`;
    value = this.build(true);
    evaluate(thing) {
      const domain = thing.getPostDomain();
      if (!domain) return null;
      return this.value.some((v) => v.test(domain));
    }
  };

  // lib/modules/showImages.js
  var showImages_exports = {};
  __export(showImages_exports, {
    Media: () => Media,
    cachedRemoveNativePlayer: () => cachedRemoveNativePlayer,
    genericHosts: () => genericHosts,
    getLinkExpando: () => getLinkExpando,
    matchesTypes: () => matchesTypes,
    module: () => module9,
    move: () => move2,
    resize: () => resize,
    toggleMute: () => toggleMute,
    toggleThingExpandos: () => toggleThingExpandos,
    types: () => types,
    viewImagesButton: () => viewImagesButton
  });
  var import_jquery8 = __toESM(require_jquery(), 1);
  var import_dompurify2 = __toESM(require_purify(), 1);

  // lib/core/host.js
  var Host = class {
    moduleID;
    name;
    domains;
    permissions;
    logo;
    landingPage;
    attribution;
    options;
    detect;
    handleLink;
    getVideoData;
    constructor(moduleID, {
      name: name2,
      domains,
      permissions,
      logo,
      landingPage,
      attribution = true,
      options: options6,
      detect,
      handleLink,
      getVideoData
    }) {
      this.moduleID = moduleID;
      this.name = name2;
      this.domains = domains;
      this.permissions = permissions;
      this.logo = logo;
      this.landingPage = landingPage;
      this.attribution = attribution;
      this.options = options6;
      this.detect = detect;
      this.handleLink = handleLink;
      this.getVideoData = getVideoData;
    }
  };

  // lib/modules/hosts/index.js
  var hosts_exports = {};
  __export(hosts_exports, {
    aarli: () => aarli_default,
    adultswim: () => adultswim_default,
    archilogic: () => archilogic_default,
    archiveis: () => archiveis_default,
    bime: () => bime_default,
    clyp: () => clyp_default,
    codepen: () => codepen_default,
    coub: () => coub_default,
    dailymotion: () => dailymotion_default,
    defaultAudio: () => defaultAudio_default,
    defaultImage: () => defaultImage_default,
    defaultVideo: () => defaultVideo_default,
    derpibooru: () => derpibooru_default,
    deviantart: () => deviantart_default,
    dropbox: () => dropbox_default,
    facebookvideo: () => facebookvideo_default,
    fiveHundredPx: () => fiveHundredPx_default,
    flickr: () => flickr_default,
    gamerdvr: () => gamerdvr_default,
    getyarn: () => getyarn_default,
    gfycat: () => gfycat_default,
    gifyoutube: () => gifyoutube_default,
    giphy: () => giphy_default,
    github: () => github_default,
    googlemaps: () => googlemaps_default,
    gyazo: () => gyazo_default,
    hastebin: () => hastebin_default,
    iloopit: () => iloopit_default,
    imgflip: () => imgflip_default,
    imgur: () => imgur_default,
    instagram: () => instagram_default,
    ireddit: () => ireddit_default,
    jsfiddle: () => jsfiddle_default,
    liveleak: () => liveleak_default,
    livememe: () => livememe_default,
    makeameme: () => makeameme_default,
    memecrunch: () => memecrunch_default,
    memedad: () => memedad_default,
    navertv: () => navertv_default,
    onedrive: () => onedrive_default,
    pastebin: () => pastebin_default,
    peertube: () => peertube_default,
    photobucket: () => photobucket_default,
    pixiv: () => pixiv_default,
    poly: () => poly_default,
    pornhub: () => pornhub_default,
    ppy: () => ppy_default,
    redditbooru: () => redditbooru_default,
    redditgallery: () => redditgallery_default,
    redditmedia: () => redditmedia_default,
    redditpoll: () => redditpoll_default,
    reddituploads: () => reddituploads_default,
    redgifs: () => redgifs_default,
    ridewithgps: () => ridewithgps_default,
    simplecove: () => simplecove_default,
    snag: () => snag_default,
    soundcloud: () => soundcloud_default,
    spotify: () => spotify_default,
    steamcommunity: () => steamcommunity_default,
    steampowered: () => steampowered_default,
    strawpollcom: () => strawpollcom_default,
    strawpollme: () => strawpollme_default,
    streamable: () => streamable_default,
    streamja: () => streamja_default,
    streamvi: () => streamvi_default,
    streamwo: () => streamwo_default,
    supgif: () => supgif_default,
    supload: () => supload_default,
    tenor: () => tenor_default,
    tuckbot: () => tuckbot_default,
    tumblr: () => tumblr_default,
    twimg: () => twimg_default,
    twitch: () => twitch_default,
    twitchclips: () => twitchclips_default,
    twitter: () => twitter_default,
    vidble: () => vidble_default,
    vimeo: () => vimeo_default,
    vlipsy: () => vlipsy_default,
    vlive: () => vlive_default,
    vreddit: () => vreddit_default,
    wikipedia: () => wikipedia_default,
    xboxdvr: () => xboxdvr_default,
    xkcd: () => xkcd_default,
    youtube: () => youtube_default,
    znipe: () => znipe_default
  });

  // lib/modules/hosts/aarli.js
  var aarli_default = new Host("aarli", {
    name: "AAR Library",
    domains: ["aar.li"],
    logo: "https://aar.li/favicon.ico",
    detect: ({ pathname }) => /^\/a\/(\w+)/i.exec(pathname),
    async handleLink(href, [, aarId]) {
      const info = await ajax({
        url: "https://aar.li/api.php",
        query: { aarId },
        type: "json"
      });
      if (info.errors) {
        throw new Error(info.errors);
      }
      return {
        type: "GALLERY",
        title: info.title,
        caption: info.description + (info.previousurl ? string_exports.escape`<br/><a href="${info.previousurl}">Previous part.</a>` : ""),
        credits: string_exports.escape`AAR by <a href="${info.authorurl}">${info.author}</a>`,
        src: info.slides.map(({ desc, imglink }) => ({
          type: "IMAGE",
          caption: desc,
          src: imglink
        }))
      };
    }
  });

  // lib/modules/hosts/adultswim.js
  var adultswim_default = new Host("adultswim", {
    name: "Adult Swim",
    domains: ["adultswim.com"],
    logo: "https://www.adultswim.com/favicon.ico",
    detect: ({ pathname }) => /^\/videos\/([^\/]+\/[^\/]+)(?:\/|$)/i.exec(pathname),
    handleLink(href, [, path]) {
      return {
        type: "IFRAME",
        embed: `https://www.adultswim.com/utilities/embed/${path}`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/archilogic.js
  var archilogic_default = new Host("archilogic", {
    name: "archilogic",
    domains: ["spaces.archilogic.com"],
    logo: "https://about.archilogic.com/wp-content/uploads/2017/01/favicon-96x96.png",
    detect: ({ pathname }) => /^\/(3d|model)/.exec(pathname),
    handleLink(href) {
      const formattedUrl = href.replace("/model/", "/3d/").replace("http:", "https:");
      return {
        type: "IFRAME",
        embed: formattedUrl
      };
    }
  });

  // lib/modules/hosts/archiveis.js
  var archiveis_default = new Host("archive.is", {
    name: "archive.is",
    domains: ["archive.is"],
    logo: "https://archive.is/favicon.ico",
    detect: ({ pathname }) => /^\/(\w+)(?:\/|$)/i.exec(pathname),
    handleLink(href, [, code]) {
      return {
        type: "IMAGE",
        src: `https://archive.fo/${code}/scr.png`
      };
    }
  });

  // lib/modules/hosts/bime.js
  var bime_default = new Host("bime", {
    name: "Bime Analytics Dashboards",
    domains: ["bime.io"],
    logo: "https://a.bime.io/assets/favicons/favicon.ico",
    detect: ({ href }) => /https?:\/\/([^.]+)\.bime\.io(?:\/([a-z0-9_-]+))+/i.exec(href),
    handleLink: (href, [, user, dashboardId]) => ({
      type: "IFRAME",
      embed: `https://${user}.bime.io/dashboard/${dashboardId}`,
      expandoClass: "selftext",
      width: "960px",
      height: "540px"
    })
  });

  // lib/modules/hosts/clyp.js
  var clyp_default = new Host("clyp", {
    name: "clyp",
    domains: ["clyp.it"],
    logo: "https://d2cjvbryygm0lr.cloudfront.net/favicon.ico",
    detect: ({ pathname }) => /^\/(playlist\/)?([A-Za-z0-9]+)/i.exec(pathname),
    handleLink(href, [, playlist, id2]) {
      return {
        type: "IFRAME",
        embed: `https://clyp.it/${playlist ? "playlist/" : ""}${id2}/widget`,
        height: "160px",
        width: "600px"
      };
    }
  });

  // lib/modules/hosts/codepen.js
  var codepen_default = new Host("codepen", {
    name: "CodePen",
    domains: ["codepen.io"],
    attribution: false,
    // shown in embed
    detect: ({ pathname }) => /^\/(?!anon)([a-z0-9_-]+)\/(?:pen|full|details|debug)\/([a-z]+)\b/i.exec(pathname),
    handleLink(href, [, user, hash]) {
      return {
        type: "IFRAME",
        muted: true,
        height: "500px",
        width: "700px",
        expandoClass: "selftext",
        embed: `https://codepen.io/${user}/embed/${hash}`
      };
    }
  });

  // lib/modules/hosts/coub.js
  var coub_default = new Host("coub", {
    name: "Coub",
    domains: ["coub.com"],
    detect: ({ pathname }) => /^\/(?:view|embed)\/(\w+)(\.gifv)?/i.exec(pathname),
    handleLink(href, [, hash, isGifv]) {
      const src = isGifv ? `https://coub.com/view/${hash}.gifv?res=true` : `https://coub.com/embed/${hash}?autoplay=true&res=true`;
      return {
        type: "IFRAME",
        muted: !!isGifv,
        embed: src,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/dailymotion.js
  var dailymotion_default = new Host("dailymotion", {
    name: "dailymotion",
    domains: ["dailymotion.com"],
    logo: "https://static1.dmcdn.net/images/favicons/favicon-32x32.png.vb5b47df6329123929",
    detect: ({ href }) => /^https?:\/\/(?:(?:www|touch)\.)?dailymotion.com[\w\-\/:#]+video[\/=]([a-z0-9]+)/i.exec(href),
    handleLink(href, [, hash]) {
      const embed = `https://www.dailymotion.com/embed/video/${hash}?api=postMessage`;
      return {
        type: "IFRAME",
        embed,
        embedAutoplay: `${embed}&autoplay=1`,
        pause: "pause",
        play: "play",
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/defaultImage.js
  var defaultImage_default = new Host("defaultImage", {
    name: "defaultImage",
    domains: [],
    detect: ({ pathname }) => /\.(webp|gif|jpe?g|png|svg)$/i.test(pathname),
    handleLink(href) {
      return {
        type: "IMAGE",
        src: href
      };
    }
  });

  // lib/modules/hosts/defaultAudio.js
  var defaultAudio_default = new Host("defaultAudio", {
    name: "defaultAudio",
    domains: [],
    detect: ({ pathname }) => /\.(opus|weba|ogg|wav|mp3|flac)$/i.exec(pathname),
    handleLink(href, [, extension]) {
      if (extension === "weba") extension = "webm";
      if (extension === "opus") extension = "ogg";
      const format = `audio/${extension}`;
      return {
        type: "AUDIO",
        autoplay: true,
        loop: false,
        sources: [{
          file: href,
          type: format
        }]
      };
    }
  });

  // lib/modules/hosts/defaultVideo.js
  var defaultVideo_default = new Host("defaultVideo", {
    name: "defaultVideo",
    domains: [],
    detect: ({ pathname }) => /\.(webm|mp4|ogv|3gp|mkv)$/i.exec(pathname),
    handleLink(href, [, extension]) {
      if (extension === "ogv") extension = "ogg";
      const format = `video/${extension}`;
      return {
        type: "VIDEO",
        sources: [{
          source: href,
          type: format
        }]
      };
    }
  });

  // lib/modules/hosts/derpibooru.js
  var derpibooru_default = new Host("derpibooru", {
    name: "Derpibooru",
    logo: "https://derpibooru.org/favicon.ico",
    domains: [
      "derpibooru.org",
      "trixiebooru.org",
      "derpiboo.ru",
      // Deprecated. Used for old links only.
      "derpicdn.net"
      // direct links
    ],
    detect: ({ hostname, pathname }) => hostname === "derpicdn.net" ? /^\/img\/view\/\d+\/\d+\/\d+\/(\d+)[._]/i.exec(pathname) : /^\/(?:images\/)?(\d+)$/i.exec(pathname),
    handleLink: (() => {
      const fetchInfo = batch(async (requests) => {
        const maxDepth = 10;
        const { images } = await ajax({
          url: "https://derpibooru.org/api/v2/images/show.json",
          query: { ids: requests.map((r) => r.id).join(",") },
          type: "json"
        });
        const responseById = keyBy_default(images, (img) => img.id);
        return requests.map(({ id: id2, depth = 0 }) => {
          const result = responseById[id2];
          if (!result) {
            return new Error("No result");
          } else if (result.duplicate_of) {
            if (depth > maxDepth) {
              return new Error(`Exceeded max duplicate depth: ${maxDepth}`);
            }
            return fetchInfo({ id: result.duplicate_of, depth: depth + 1 });
          } else if (result.image) {
            return result;
          } else {
            return new Error("Image deleted or other error");
          }
        });
      }, { size: 50 });
      return async (href, [, id2]) => {
        const { image, description, source_url: source } = await fetchInfo({ id: id2 });
        return {
          type: "IMAGE",
          src: image,
          caption: description,
          credits: source ? string_exports.escape`Source: <a href="${source}">${source}</a>` : void 0
        };
      };
    })()
  });

  // lib/modules/hosts/deviantart.js
  var deviantart_default = new Host("deviantart", {
    name: "deviantART",
    logo: "https://i.deviantart.net/icons/da_favicon.ico",
    domains: ["deviantart.com", "fav.me", "sta.sh"],
    permissions: ["https://backend.deviantart.com/oembed"],
    detect: ({ href }) => /^https?:\/\/(?:fav\.me\/.*|sta\.sh.*|(?:.+\.)?deviantart\.com\/(?:(?:[\w-]+\/)?art\/.*|[^#]*#\/d.*))$/i.test(href),
    async handleLink(href) {
      const info = await ajax({
        url: "https://backend.deviantart.com/oembed",
        query: { url: href },
        type: "json"
      });
      switch (info.type) {
        case "photo":
        case "link":
          let src;
          if (info.fullsize_url) {
            src = info.fullsize_url;
          } else if (/\.(jpg|jpeg|gif|png)/i.test(info.url)) {
            src = info.url;
          } else {
            src = info.thumbnail_url;
          }
          return {
            type: "IMAGE",
            title: info.title,
            credits: `Art by: <a href="${info.author_url}">${info.author_name}</a> @ deviantART`,
            src
          };
        case "rich":
          return {
            type: "TEXT",
            title: info.title,
            src: info.html + (/[^\s\.]\s*$/.test(info.html) ? "..." : ""),
            credits: `<a href="${href}">Click here to read the full text</a> - Written By: <a href="${info.author_url}">${info.author_name}</a> @ deviantART`
          };
        default:
          throw new Error(`Unsupported deviantART post type: ${info.type}`);
      }
    }
  });

  // lib/modules/hosts/dropbox.js
  var dropbox_default = new Host("dropbox", {
    name: "dropbox",
    domains: ["dropbox.com"],
    logo: "https://cfl.dropboxstatic.com/static/images/favicon-vflk5FiAC.ico",
    detect(url) {
      for (const host of genericHosts) {
        const result = host.detect(url);
        if (result) return [host.handleLink, result];
      }
    },
    handleLink(href, [handler, result]) {
      const originalURL = new URL(href);
      return handler(`${originalURL.origin}${originalURL.pathname}?raw=1`, result);
    }
  });

  // lib/modules/hosts/facebookvideo.js
  var facebookvideo_default = new Host("facebookvideo", {
    name: "facebookvideo",
    domains: ["facebook.com"],
    attribution: false,
    // shown in embed
    detect: ({ pathname }) => /^\/([a-z0-9]+)\/(?:videos)\/([0-9]+)/i.exec(pathname),
    handleLink(href, [, channel, id2]) {
      const embed = `https://www.facebook.com/plugins/video.php?href=https://www.facebook.com/${channel}/videos/${id2}`;
      return {
        type: "IFRAME",
        embed,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/fiveHundredPx.js
  var fiveHundredPx_default = new Host("fiveHundredPx", {
    name: "fiveHundredPx",
    domains: ["500px.org", "500px.net", "500px.com"],
    logo: "https://assetcdn.500px.org/assets/favicon-1e8257b93fb787f8ceb66b5522ee853c.ico",
    detect: ({ href }) => /^https?:\/\/\w*cdn\.500px\.(?:net|com|org)\/(?:photo\/)?([0-9]+)\//.exec(href),
    handleLink(href, [, photoId]) {
      return {
        type: "IMAGE",
        src: href.replace(/\/[0-9]+\.jpg$/, "/5.jpg"),
        credits: `View original and details at: <a href="https://500px.com/photo/${photoId}">500px.com</a>`
      };
    }
  });

  // lib/modules/hosts/flickr.js
  function base58Encode(num) {
    const alpha = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
    let enc = "";
    let acc = num;
    do {
      const div = Math.floor(acc / 58);
      const mod = acc - 58 * div;
      enc = `${alpha[mod]}${enc}`;
      acc = div;
    } while (acc);
    return enc;
  }
  var flickr_default = new Host("flickr", {
    name: "flickr",
    domains: ["flickr.com", "flic.kr", "staticflickr.com"],
    permissions: ["https://www.flickr.com/services/oembed"],
    logo: "https://s.yimg.com/pw/favicon.ico",
    detect({ origin, href, pathname }) {
      if (origin.endsWith("staticflickr.com")) {
        const [, id2] = /(?:.+\/)?\d{4}\/(\d{10,})_/i.exec(pathname) || [];
        if (id2) return `https://flic.kr/p/${base58Encode(parseInt(id2, 10))}`;
      } else {
        return href;
      }
    },
    async handleLink(href, oembedTarget) {
      const info = await ajax({
        url: "https://www.flickr.com/services/oembed",
        query: { format: "json", url: oembedTarget },
        type: "json"
      });
      const validSuffix = /\.(jpg|jpeg|gif|png)/i;
      const src = validSuffix.test(oembedTarget) ? oembedTarget : (
        // The oembed provides usually proides a ~~low resolution image, while the original link often is to the highest one
        validSuffix.test(info.url) ? info.url : validSuffix.test(info.thumbnail_url) ? info.thumbnail_url : void 0
      );
      if (!src) {
        throw new Error("No image found.");
      }
      return {
        type: "IMAGE",
        title: info.title,
        credits: `Picture by: <a href="${info.author_url}">${info.author_name}</a> @ Flickr`,
        src
      };
    }
  });

  // lib/modules/hosts/gamerdvr.js
  var gamerdvr_default = new Host("gamerdvr", {
    name: "GamerDVR",
    domains: ["gamerdvr.com"],
    logo: "https://gamerdvr.com/assets/favicon-240671aabcbf14dcaa1f3f2b406091d2.png",
    detect: ({ pathname }) => /^\/(gamer\/[^\/]+\/\w+\/\d+)(?:\/|$)/.exec(pathname),
    handleLink(href, [, path]) {
      return {
        type: "IFRAME",
        embed: `https://gamerdvr.com/${path}/embed`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/getyarn.js
  var getyarn_default = new Host("getyarn", {
    name: "getyarn.io",
    logo: "https://getyarn.io/favicon.ico",
    domains: ["getyarn.io"],
    detect: ({ pathname }) => /\/yarn-clip\/(?:embed\/)?([\w\-]+)/i.exec(pathname),
    handleLink(href, [, code]) {
      const embed = `https://getyarn.io/yarn-clip/embed/${code}`;
      return {
        type: "IFRAME",
        embed: `${embed}?autoplay=false`,
        embedAutoplay: `${embed}?autoplay=true`,
        height: "600px",
        // size as per docs in https://getyarn.io/yarn-clip/embed-test/
        width: "768px",
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/gfycat.js
  var gfycat_default = new Host("gfycat", {
    name: "gfycat",
    domains: ["gfycat.com"],
    logo: "https://gfycat.com/favicon.ico",
    options: {
      useMobileGfycat: {
        title: "gfycatUseMobileGfycatTitle",
        description: "gfycatUseMobileGfycatDesc",
        value: false,
        type: "boolean"
      }
    },
    detect: ({ pathname }) => /^\/(?:(?:ifr|gifs\/detail)\/)?(\w+)(?:\.gif)?/i.exec(pathname),
    async handleLink(href, [, id2]) {
      const isMobileResolution = this.options.useMobileGfycat.value;
      const info = (await ajax({
        url: string_exports.encode`https://api.gfycat.com/v1/gfycats/${id2}`,
        type: "json",
        cacheFor: DAY
      })).gfyItem;
      return {
        type: "VIDEO",
        frameRate: info.frameRate,
        loop: true,
        muted: !info.hasAudio,
        playbackRate: +(href.match(/[?|&]speed=([\d\.]+)/i) || [void 0, 1])[1],
        poster: isMobileResolution ? info.mobilePosterUrl : info.posterUrl,
        sources: [isMobileResolution && {
          source: info.mobileUrl,
          type: "video/mp4"
        }, {
          source: info.webmUrl,
          type: "video/webm"
        }, {
          source: info.mp4Url,
          type: "video/mp4"
        }].filter((x) => x),
        time: +(href.match(/[?|&]frameNum=([\d]+)/i) || [void 0, 0])[1] / info.frameRate
      };
    }
  });

  // lib/modules/hosts/gifyoutube.js
  var gifyoutube_default = new Host("gifs", {
    name: "gifs.com",
    domains: ["gifs.com", "gifyoutube.com", "gifyt.com"],
    logo: "https://cdn.gifs.com/resources/favicon.png",
    detect: ({ href }) => /^https?:\/\/(?:beta\.|www\.)?(?:gifyoutube|gifyt)\.com\/gif\/(\w+)\.?/i.exec(href) || /^https?:\/\/share\.gifyoutube\.com\/(\w+)\.gif/i.exec(href),
    async handleLink(href, [, id2]) {
      const { sauce } = await ajax({
        url: `https://gifs.com/api/${id2}`,
        type: "json",
        cacheFor: DAY
      });
      return {
        type: "VIDEO",
        loop: true,
        fallback: `https://share.gifyoutube.com/${id2}.gif`,
        muted: true,
        source: sauce,
        sources: [{
          source: `https://share.gifyoutube.com/${id2}.webm`,
          type: "video/webm"
        }, {
          source: `https://share.gifyoutube.com/${id2}.mp4`,
          type: "video/mp4"
        }]
      };
    }
  });

  // lib/images/hosts/giphy-logo.png
  var giphy_logo_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGUAAAAkCAYAAACQePQGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABcVJREFUeNrsmr9LZFcUx4+bZKIJrBKbUZKMEAgSAo5sYzcjbGGzaBGCndoskkZh/wC1SRfUzq1U0lgEVLaRbRybXTu1SBAbFULUBLO6wiKSZPI+1xxz5857b96M4zor78D13Xd/nnO+55x77hvrRCTrlVWJqWboXqyCGJSYYlBiUGKKQbm79H5Y59TUt5JOfxZ5sYsf9yTx+4VsHh/L6IsXJccnk0np6ekpaFtfX5ft7W2pr683fel02rSfnJzIysqKHB4eSl9fn3nyzrj+/v6ree3t7dLV1SWbm5tmfYpNc3NzMjg4WNCmazc1NRXxwzrsZbefn5+b/fb29kJloZ+x8KT8tbW1STabNX25XK58UAAkk/kyMij7Px1LqiUReTwKhUmUAvMIxvvMzIxRPO8wT0HRKH9hYcHM4x1BGU9hPkIDIu8omTproFSbdE8Uzjr6zj7UGc96Lp/aTh1FT01NmXn2GNZkjPIxOztrQEAexgMcPMFfRZ7y3cXf8mb/WJKHr6Vn5eeSSu47bZBUQ0LSzc2Se/TItGWfPSs5D0GwGhhHmNbWVsM4SgYEiPrw8LDpZzzCoRgEh6gzhyfKUyBQmlqkrWht58m+rKOWr96h4/AgCEUqcHgbvPhZO/toOTo6MvPYA/5ZizmuoUQG5ZfEeyKpZo+RY1kfL63cLEA0NEljIiGZlpbIHqNWpQq23V9JhcAiXVAQXsOdKtUOKxquWI/wZbdreAN0JTsMoUCbD5cvP1lsY4M3niojcgSFrUigVIPGHzy4jOU7O7J3duY7BuuhwLAdqzUWa8hRy9VQRT+0tLRkFKljbAXbQPhZM2AyXkOhnju24l1jIeS5nmefWcy1PUm9krZSgLwVUMb+AyV3cBAICoy6zKrSR0dHjVDqEQoS1ke/AkQ/yqKucV4VOj4+XqA0BZfQiKLsMAjZiYB9INvt6gEuqZepBwK6awy3Csqr849l649L5hL3mr2/vxUxiNC2EpVQGAekKgsFAIiGMZTPXPUK+lCErSi/uK17ah/7kEAAqF+o0sPdbqfOfraC3THwZZ9N2h8FlLrQD5K5JyJkX2s73qgfygYl3dQnn9Z3mPqv51uyebIUX0Kue0+5DSIO66GooQ2L8/Omu0x4St635J7kJf/08hk0JqS033+Y//7rXVOoh431zo685955P/IAyXvnQsF43m2y+0uRB7LZL+p6QevSxlo2IYOXtBTM89Lhorne+RSoixv9zPJP/i9p/rDNFOpBxOE7OTkpqVTKt7+xsVHGxsZ8D9ZKqKOjw+xXjfXcrwPIQHJiZ5ZcGm1aW1vzzQhr5tsXDA8MDEQaWy1QbHDszKwSgqeJiYnCjNMzIL2vsL5tbKenp0VA1hQonBsjIyMFbcvLy9LZ2Sl1dXUyNDRkrAqan58vKUwQoTQtW1tboZZe0V3MU/z+/n6RsZE9uvIxNuzyeesHvasQAOBzhB3WKPYnkEqVZq+5u7tbEG6qJcvq6v9JbCaTMZdaVz43lNWcp2BJ7tmiGZheKCm0a70alh3p0uuFIM5yu4QRvE1PTxedheWErZpMidUbOByxtCDhr+MptieaL9tO2LluGGN9P++LErZq9p5yU1YflvlVi7hLkXktLi5WFLZqAhT3QoiV6WWxu7v7qt2O1dUkkoeg7AtFul4ZBq4S5wjJBJmdn6fWPCgI0Nvbe/VOpoLl6u8rN0V6TwjzEvZ3lRkFFD9je6c+swAKbm0fiBsbGyYtBhgSgaCzpRwivb47374OvhB52Sby5ycij8u/ZB1+kJS5+5cH6dmrj7w/xRZFRuLGYLzH9iC/ZOAuUzgoZ1+JJDxL/dyrP/6m7MVfe+Wlvjx/E+gtXBJdj/EjUs5qHszvJihviVA04OA1+ju9AkT8J5TpWROUGtvv7mePKBS2Xrnr6r2qUu8O/z0lpluh+J/xYlBiikGJQYkpBuUOE9kX/5OZjlVRO/SvAAMADC1T3Wo5vNkAAAAASUVORK5CYII=";

  // lib/modules/hosts/giphy.js
  var giphy_default = new Host("giphy", {
    name: "giphy",
    domains: ["giphy.com"],
    logo: giphy_logo_default,
    detect: ({ pathname }) => /^(?:\/gifs|\/media|)\/(?:\w+-)*([^/.]+)(?:\/|\.gif|$)/i.exec(pathname),
    async handleLink(href, [, id2]) {
      const { data: data2 } = await ajax({
        url: `https://api.giphy.com/v1/gifs/${id2}`,
        query: { api_key: "dc6zaTOxFJmzC" },
        type: "json"
      });
      return {
        type: "VIDEO",
        fallback: data2.images.original.url,
        loop: true,
        muted: true,
        sources: [{
          source: data2.images.original.mp4,
          type: "video/mp4"
        }]
      };
    }
  });

  // node_modules/snudown-js/dist/snudown.js
  function k(A) {
    var r = o(f2 = 1 + (A.length << 2)), a2 = t, i2 = r;
    if (0 < f2) {
      for (var f2 = i2 + f2 - 1, e2 = 0; e2 < A.length; ++e2) {
        var n = A.charCodeAt(e2);
        if ((n = 55296 <= n && n <= 57343 ? 65536 + ((1023 & n) << 10) | 1023 & A.charCodeAt(++e2) : n) <= 127) {
          if (f2 <= i2) break;
          a2[i2++] = n;
        } else {
          if (n <= 2047) {
            if (f2 <= i2 + 1) break;
            a2[i2++] = 192 | n >> 6;
          } else {
            if (n <= 65535) {
              if (f2 <= i2 + 2) break;
              a2[i2++] = 224 | n >> 12;
            } else {
              if (f2 <= i2 + 3) break;
              a2[i2++] = 240 | n >> 18, a2[i2++] = 128 | n >> 12 & 63;
            }
            a2[i2++] = 128 | n >> 6 & 63;
          }
          a2[i2++] = 128 | 63 & n;
        }
      }
      a2[i2] = 0;
    }
    return r;
  }
  function a(A, r, a2) {
    for (var i2 = k(r = "string" != typeof r ? "" : r), f2 = 0, e2 = 0; e2 < r.length; ++e2) {
      var n = r.charCodeAt(e2);
      n <= 127 ? f2++ : n <= 2047 ? f2 += 2 : 55296 <= n && n <= 57343 ? (f2 += 4, ++e2) : f2 += 3;
    }
    if (A = A(i2, e2 = f2, n = (a2 = "object" == typeof a2 && null !== a2 ? a2 : {}).nofollow ? 1 : 0, r = "string" == typeof a2.target ? k(a2.target) : 0, f2 = "string" == typeof a2.tocIdPrefix ? k(a2.tocIdPrefix) : 0, a2.enableToc ? 1 : 0)) {
      for (e2 = (a2 = A) + NaN, n = ""; !(e2 <= a2); ) {
        var o2, b2, w = t[a2++];
        if (!w) break;
        128 & w ? (o2 = 63 & t[a2++], 192 == (224 & w) ? n += String.fromCharCode((31 & w) << 6 | o2) : (b2 = 63 & t[a2++], (w = 224 == (240 & w) ? (15 & w) << 12 | o2 << 6 | b2 : (7 & w) << 18 | o2 << 12 | b2 << 6 | 63 & t[a2++]) < 65536 ? n += String.fromCharCode(w) : n += String.fromCharCode(55296 | (w -= 65536) >> 10, 56320 | 1023 & w))) : n += String.fromCharCode(w);
      }
      a2 = n;
    } else a2 = "";
    return c(A), c(f2), c(r), c(i2), a2;
  }
  var o;
  var i;
  var f;
  var c;
  var e = { Memory: function(A) {
    this.buffer = new ArrayBuffer(65536 * A.A);
  }, Module: function() {
  }, Instance: function(A, r) {
    this.exports = function(A2) {
      function r2(A3, r3, a3) {
        for (var i3, f3 = 0, e3 = r3, n2 = a3.length, o3 = r3 + (3 * n2 >> 2) - ("=" == a3[n2 - 2]) - ("=" == a3[n2 - 1]); f3 < n2; f3 += 4) r3 = w[a3.charCodeAt(f3 + 1)], i3 = w[a3.charCodeAt(f3 + 2)], A3[e3++] = w[a3.charCodeAt(f3)] << 2 | r3 >> 4, e3 < o3 && (A3[e3++] = r3 << 4 | i3 >> 2), e3 < o3 && (A3[e3++] = i3 << 6 | w[a3.charCodeAt(f3 + 3)]);
      }
      for (var a2, e2, n, M, b2, q, Y, l, C, k2, t2, o2, Q, h, W, w = new Uint8Array(123), i2 = 25; 0 <= i2; --i2) w[48 + i2] = 52 + i2, w[65 + i2] = i2, w[97 + i2] = 26 + i2;
      return w[43] = 62, w[47] = 63, e2 = (A2 = A2.a).a, n = e2.buffer, e2.grow = function(A3) {
        var r3 = n.byteLength / 65536 | 0;
        return r3 < (A3 = r3 + (0 | A3) | 0) && A3 < 65536 && (A3 = new ArrayBuffer(k2(A3, 65536)), new Int8Array(A3).set(M), M = new Int8Array(A3), b2 = new Int16Array(A3), q = new Int32Array(A3), Y = new Uint8Array(A3), l = new Uint16Array(A3), C = new Uint32Array(A3), n = A3, e2.buffer = n, a2 = Y), r3;
      }, M = new Int8Array(n), b2 = new Int16Array(n), q = new Int32Array(n), Y = new Uint8Array(n), l = new Uint16Array(n), C = new Uint32Array(n), k2 = Math.imul, t2 = Math.clz32, o2 = A2.b, Q = 18912, h = 0, r2(a2 = Y, 1024, "XGAqX3t9W10oKSMrLS4hOnwmPD4vXn4AdGJvZHkAZGl2AG5vc2NyaXB0AHRmb290AGZpZWxkc2V0AGlucwB0cgBwAGNhcHRpb24Acm93c3BhbgBjb2xzcGFuAGZvcm0AcmVkZGl0LmNvbQB1bABvbABkZWwAZGwAbWF0aAA8dGgAPGgAPC9oAGNlbGxwYWRkaW5nAGNlbGxzcGFjaW5nAGltZwBibG9ja3F1b3RlAGZpZ3VyZQBwcmUAc2NvcGUAaWZyYW1lAHN0eWxlAHRhYmxlADx0ZAB0aGVhZABhAHRvY18AListXwA8c3VwPgA8L3N1cD4APHA+ADwvc3Bhbj4APHN0cm9uZz48ZW0+ADwvZW0+ADxkZWw+ADwvZGVsPgA8bGk+ADxzdHJvbmc+ADwvZW0+PC9zdHJvbmc+ADxwcmU+PGNvZGU+ADwvY29kZT4APC9hPgAiLz4APHNwYW4gY2xhc3M9Im1kLXNwb2lsZXItdGV4dCI+ACBhbGlnbj0icmlnaHQiPgAgYWxpZ249ImxlZnQiPgAgYWxpZ249ImNlbnRlciI+ACZsb3o7ACZlbXB0eTsAJmNvcHk7ACZzaHk7ACZlcXVpdjsAJnBpdjsAJm51OwAmbXU7ACZ0YXU7ACZUYXU7ACZOdTsAJk11OwAmZXhpc3Q7ACZpcXVlc3Q7ACZsb3dhc3Q7ACZwYXJ0OwAmcXVvdDsAJm5vdDsAJnNkb3Q7ACZtaWRkb3Q7ACZpbnQ7ACZjZW50OwAmbHQ7ACZndDsAJnNlY3Q7ACZtaW51czsAJm9wbHVzOwAmaGVhcnRzOwAmYXBvczsAJmRpYW1zOwAmb3RpbWVzOwAmdGltZXM7ACZzcGFkZXM7ACZjbHViczsAJnVhcnI7ACZjcmFycjsAJnJhcnI7ACZsYXJyOwAmaGFycjsAJmRhcnI7ACZ1QXJyOwAmckFycjsAJmxBcnI7ACZoQXJyOwAmZEFycjsAJnJmbG9vcjsAJmxmbG9vcjsAJm9yOwAmZGFnZ2VyOwAmRGFnZ2VyOwAmbWFjcjsAJmJydmJhcjsAJnN1cDsAJmN1cDsAJnRoaW5zcDsAJmVuc3A7ACZlbXNwOwAmbmJzcDsAJnBlcnA7ACZ3ZWllcnA7ACZwcm9wOwAmYXN5bXA7ACZhbXA7ACZoZWxsaXA7ACZjYXA7ACZyc3F1bzsAJmxzcXVvOwAmcmRxdW87ACZsZHF1bzsAJmJkcXVvOwAmc2JxdW87ACZyc2FxdW87ACZsc2FxdW87ACZyYXF1bzsAJmxhcXVvOwAmZXVybzsAJm1pY3JvOwAmcmhvOwAmUmhvOwAmdGhvcm47ACZvbWljcm9uOwAmT21pY3JvbjsAJnNjYXJvbjsAJlNjYXJvbjsAJnVwc2lsb247ACZlcHNpbG9uOwAmVXBzaWxvbjsAJkVwc2lsb247ACZwbHVzbW47ACZub3RpbjsAJmlzaW47ACZpbmZpbjsAJnllbjsAJmN1cnJlbjsAJmFsZWZzeW07ACZ0aGV0YXN5bTsAJnN1bTsAJmxybTsAJnJsbTsAJnNpbTsAJm9yZG07ACZmcmFzbDsAJnl1bWw7ACZ1dW1sOwAmb3VtbDsAJml1bWw7ACZldW1sOwAmYXVtbDsAJll1bWw7ACZVdW1sOwAmT3VtbDsAJkl1bWw7ACZFdW1sOwAmQXVtbDsAJnVtbDsAJmJ1bGw7ACZmb3JhbGw7ACZwZXJtaWw7ACZyY2VpbDsAJmxjZWlsOwAmY2NlZGlsOwAmQ2NlZGlsOwAmY2VkaWw7ACZpZXhjbDsAJnJlYWw7ACZ6d2o7ACZ6d25qOwAmeGk7ACZwc2k7ACZQc2k7ACZwaTsAJm5pOwAmcGhpOwAmY2hpOwAmUGhpOwAmQ2hpOwAmWGk7ACZQaTsAJmV0aDsAJm9zbGFzaDsAJk9zbGFzaDsAJm5kYXNoOwAmbWRhc2g7ACZ1cHNpaDsAJmNvbmc7ACZhcmluZzsAJkFyaW5nOwAmcmFuZzsAJmxhbmc7ACZhbmc7ACZzemxpZzsAJm9lbGlnOwAmYWVsaWc7ACZPRWxpZzsAJkFFbGlnOwAmcmVnOwAmZGVnOwAmZm5vZjsAJm9yZGY7ACZzaWdtYWY7ACZ1Z3JhdmU7ACZvZ3JhdmU7ACZpZ3JhdmU7ACZlZ3JhdmU7ACZhZ3JhdmU7ACZVZ3JhdmU7ACZPZ3JhdmU7ACZJZ3JhdmU7ACZFZ3JhdmU7ACZBZ3JhdmU7ACZ5YWN1dGU7ACZ1YWN1dGU7ACZvYWN1dGU7ACZpYWN1dGU7ACZlYWN1dGU7ACZhYWN1dGU7ACZZYWN1dGU7ACZVYWN1dGU7ACZPYWN1dGU7ACZJYWN1dGU7ACZFYWN1dGU7ACZBYWN1dGU7ACZhY3V0ZTsAJnN1cGU7ACZvbGluZTsAJm5lOwAmcHJpbWU7ACZQcmltZTsAJmxlOwAmaW1hZ2U7ACZnZTsAJm90aWxkZTsAJm50aWxkZTsAJmF0aWxkZTsAJk90aWxkZTsAJk50aWxkZTsAJkF0aWxkZTsAJnRpbGRlOwAmZGl2aWRlOwAmdHJhZGU7ACZzdWJlOwAmcHJvZDsAJnBvdW5kOwAmYW5kOwAmdWNpcmM7ACZvY2lyYzsAJmljaXJjOwAmZWNpcmM7ACZhY2lyYzsAJlVjaXJjOwAmT2NpcmM7ACZJY2lyYzsAJkVjaXJjOwAmQWNpcmM7ACZjaXJjOwAmcmFkaWM7ACZuc3ViOwAmc3ViOwAmaW90YTsAJklvdGE7ACZkZWx0YTsAJkRlbHRhOwAmemV0YTsAJnRoZXRhOwAmVGhldGE7ACZiZXRhOwAmWmV0YTsAJkJldGE7ACZldGE7ACZFdGE7ACZwYXJhOwAma2FwcGE7ACZLYXBwYTsAJmdhbW1hOwAmR2FtbWE7ACZzaWdtYTsAJlNpZ21hOwAmbmFibGE7ACZhbHBoYTsAJkFscGhhOwAmb21lZ2E7ACZPbWVnYTsAJmxhbWJkYTsAJkxhbWJkYTsAJlRIT1JOOwAmRVRIOwAmIzM5OwAmIzQ3OwAmI3gyNzsAJnRoZXJlNDsAJmZyYWMzNDsAJmZyYWMxNDsAJnN1cDM7ACZzdXAyOwAmZnJhYzEyOwAmc3VwMTsAdDoAbWFpbHRvOgBoNgBoNQBoNABoMwBoMgBoMQBnaXQ6Ly8AbmV3czovLwBodHRwczovLwBpcmNzOi8vAHRzM3NlcnZlcjovLwBodHRwOi8vAGZ0cDovLwBtYWlsdG86Ly8Ac3RlYW06Ly8Ac3NoOi8vAG11bWJsZTovLwBpcmM6Ly8Ad3d3LgBhbGwtADxhIGhyZWY9IiMAIHJlbD0ibm9mb2xsb3ciACIgYWx0PSIAIHRhcmdldD0iADxwcmU+PGNvZGUgY2xhc3M9IgAgY29sc3Bhbj0iADxhIGhyZWY9IgAiIHRpdGxlPSIAIGlkPSIAPGltZyBzcmM9IgAiIAA8L3RoZWFkPjx0Ym9keT4KADwvZGl2PgoAPHRyPgoAPC90cj4KADxocj4KADxicj4KADwvcD4KADx1bD4KADwvbGk+CjwvdWw+CgA8b2w+CgA8L29sPgoAPHVsPgo8bGk+CgA8L2xpPgo8bGk+CgA8L3VsPgo8L2xpPgoAPC90aD4KADxibG9ja3F1b3RlPgoAPC9ibG9ja3F1b3RlPgoAPC9jb2RlPjwvcHJlPgoAPC90Ym9keT48L3RhYmxlPgoAPC90ZD4KADx0YWJsZT48dGhlYWQ+CgA8L2E+CgA8aHIvPgoAPGJyLz4KADxibG9ja3F1b3RlIGNsYXNzPSJtZC1zcG9pbGVyLXRleHQiPgoAPGRpdiBjbGFzcz0idG9jIj4KAAAAAAAAjw0AAHENAACXDQAAng0AAMcNAABiDQAAqA0AAMINAABpDQAAuA0AALENAAB6DQAAgg0AANwN"), r2(a2, 4016, "ag8AAEEEAAB1BAAAHgQAAHgEAADNBAAAag8AAGsEAABxBAAAWwQAAKQEAACvBAAAbgQAADEEAABqDwAAXw0AAGoPAABQDQAAtgQAAGoPAABqDwAAJAQAAFMNAAAiBAAAag8AAMcEAADABAAAVg0AADoEAABqDwAAag8AAGoPAABZDQAAag8AAGoPAABqDwAAag8AAFwNAABWBAAA77u/ACYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmCB4ZFA8KJiYmJiYmJiYmJgAmACYFBQUPACYmAA8KACYmDwAFJiYmJiYmJiYmJiYmACYAJgUFBQ8AJiYADwoAJiYPAAUmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmAAAAAAEAAEA="), r2(a2, 4452, "AgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAAN"), r2(a2, 4512, "MDEyMzQ1Njc4OUFCQ0RFRg=="), r2(a2, 4544, "AgICAgICAgICAAACAgACAgICAgICAgICAgICAgICAgIAAQABAQEAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB"), r2(a2, 4800, "ag8AABUGAABqBwAA+QwAAP8MAAA/BgAARAYAAGoPAAAHBwcHBwcHBwcAAAcHAAcHBwcHBwcHBwcHBwcHBwcHBwAAAQAAAAIDAAAAAAAAAAQ="), r2(a2, 4892, "BQAG"), r2(a2, 5104, "Dg=="), r2(a2, 5140, "DwAAABAAAAARAAAAEg=="), r2(a2, 5164, "EwAAAAAAAAAUAAAAFQAAABY="), r2(a2, 5196, "FwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACQAAAAPAAAAEAAAABEAAAASAAAAJQAAACYAAAAnAAAAKAAAABQAAAAVAAAAFgAAAAAAAAApAAAAAAAAACoAAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAPoGAAAcBgAAag8AAGoPAABqDwAAag8AADIGAABqDwAAag8AAGoPAABqDwAAawkAAFMIAABLCAAAag8AAGoPAADmBwAAag8AAGoPAABqDwAAag8AAIEJAABbBwAAag8AAGoPAABqDwAA4AcAAEQHAADsBwAALQcAAGoPAACHCQAAag8AAGoPAABqDwAAag8AAGoPAACjCwAAag8AAGoPAABqDwAAagcAAGoPAABqDwAAag8AAGoPAABxCQAAag8AAGoPAABqDwAAag8AAGoPAAAkDAAAag8AAGoPAAD0BwAAjQkAAGoPAABqDwAAag8AAGoPAACyCwAAIgYAAGoPAABqDwAA1AUAAJMJAAA9BwAAag8AAGoPAADvBQAAag8AADYHAADACwAAag8AAD8GAAABCQAAag8AAMgLAABqDwAAag8AACEHAAA+DQAAag8AABEIAABqDwAAeQcAAA4GAACqCwAACAgAAGoPAABqDwAAfAkAAGoPAAAFBgAA/gcAACcHAACZCQAAoQYAAGoPAADqBQAAag8AAHcJAABJDAAAag8AAGoPAADeBQAAFwwAANgLAABqDwAAag8AAHsIAABqDwAA6AsAAGoPAABqDwAAag8AAKkGAAC4CwAAag8AAGoPAACrBQAAvgYAAJQLAABqDwAAag8AAGoPAAB6DAAA0AsAAGoPAABqDwAAag8AALAGAAAPDAAAag8AAGoPAAAeDAAAngkAAIEMAAD8BQAAag8AAG4MAAAXCwAAIAkAAAwNAABqDwAAzAYAAJoGAACJDAAAag8AAGoPAADhBgAA0QcAAFEMAAAIDAAAag8AAOQFAABqDwAAKAkAAGoPAABqDwAA0wYAAJ4IAABqDwAAag8AAGoPAACMCAAAZgkAAA8LAAAwCQAAag8AAGoPAAAnDQAAag8AAFYLAABqDwAAxQYAAC4NAADOBQAATQsAAGoPAADABQAAag8AAAAMAABqDwAAag8AAGoPAABqDwAAag8AAGgIAABqDwAAag8AAGoPAADgCwAAtQoAAGoPAABqDwAAnAsAALEMAAC+CgAA2QUAAGoPAAAHCQAAHgsAADkJAABqDwAAhggAALkFAADGBQAAcQsAAGoPAABqDwAAag8AACsLAABfCwAAgwsAAGoPAABqDwAA+AsAAGgLAABqDwAAag8AAGoPAABqDwAAag8AAGkGAABqDwAAag8AAGoPAADQCgAAJgsAAHQMAAARBwAAmAgAAOsKAABqDwAAag8AACsMAACxBQAArAoAAGoPAABqDwAAuwgAAPQFAABqDwAAag8AAGoPAADCCAAAMwsAAMcKAABqDwAAfwcAADgGAABZCQAAXwkAABUGAACnBwAASQYAAFoIAAB4BgAAag8AAGoPAADTCQAA8AsAABgHAAA7CwAAhwcAADkKAACSBgAAag8AAGoPAABYBgAASwcAAGoPAADZCgAA2AcAAPgJAADQCAAAag8AAGoPAABEBgAAkggAAOUIAAAaCAAAag8AAFAGAAApBgAAtAgAANoJAAB6CwAAag8AAIsLAACvBwAAJAgAAGoPAACBBgAA8wwAAMkIAAD+CQAAHg0AAHAGAABqDwAAqQkAAGoPAAAGCwAAag8AAGoPAAC4BwAAOgwAAGoPAABqDwAAjwcAAIkGAABqDwAA4goAAGoPAADBBwAA6gkAAKUIAADoBgAAtwYAALsJAADXCAAAQgkAAKMJAABqDwAAlwcAAFIJAADrDAAAQggAAGoPAADJBwAA8QkAADIMAADxBgAAag8AAGoPAABZDAAAyQwAAP0KAABqDwAAag8AALIJAABACwAAUgcAAGoPAABqDwAAYAwAABYKAADaBgAAag8AAGoPAAD6CAAAYgcAAOIMAABqDwAAnwcAAEIMAAAuCAAA2QwAAGoPAABqDwAA3ggAAOIJAACjCgAAag8AAGcMAABqDwAAmQwAAGoPAABqDwAAag8AAGoPAABKCQAADgkAAGoPAABqDwAAag8AANEMAABqDwAAag8AAGoPAABqDwAAOAgAAPQKAABqDwAAag8AAPMIAABqDwAAFQ0AAGoPAABqDwAAag8AAGoPAAA1DQAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABiCAAAag8AAGoPAABqDwAAag8AAGoPAACtCAAAag8AAGoPAABqDwAAag8AAFIKAAAeCgAAag8AAGoPAABqDwAAWwoAAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAOwIAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AALkMAABqDwAAag8AABcJAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAbQoAAGoPAABqDwAAag8AAMMJAAB/CgAAag8AAGoPAABqDwAAag8AAEkKAABqDwAAywkAAGoPAABqDwAAag8AAGoPAABqDwAASAsAAGoPAABkCgAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAMgoAAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAJgoAAGoPAABqDwAAag8AAGoPAAAsCgAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAKkMAABqDwAAag8AAGoPAABqDwAAoQwAAMEMAABqDwAAag8AAGoPAABqDwAAag8AAGAGAAAGCgAAag8AAGoPAABqDwAAmgoAAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAHYKAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABwBwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAA4KAABqDwAAag8AAGoPAACRCgAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAACICgAAkQwAAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAAAIBwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAA/wYAAGoPAABqDwAAag8AAGoPAABqDwAAcQgAAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAGoPAABqDwAAag8AAEAKAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAF8AWgAAAAMDAwMDAwMDAwMDAwAAAwMDAwMDAwMDA3MAXgA3AAAAlgAZAAAAHgDDAAMDHgAeAAUAIwAtAC0AAwMKAAAAMgB9AAMDAwMFAFUASwADAwMDAwMDAwMDAwMoAEEAFAAZADwA8ADwAN8ACgBmABQAIwCHAAAABQAKALcAFAAFAAAAMgBLAAoASwCvAFUADwADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw=="), r2(a2, 8928, "4Ek="), r2(a2, 8944, "PgQAAH4EAADUBAAAzQQAABgEAADXBAAAKwQAAEME"), r2(a2, 8992, "UwQAAEsEAACUBAAAiAQAALoE"), (A2 = [null, function(A3, r3, a3) {
        A3 |= 0, q[32 + (a3 |= 0) >> 2] && N(A3, 3550, 15), q[a3 + 36 >> 2] && (N(A3, 3574, 9), m(A3, q[a3 + 36 >> 2]), F(A3, 34));
      }, function(A3, r3, a3, i3, f3, e3) {
        A3 |= 0, r3 |= 0;
        A: {
          r: {
            if (!(62 != (0 | (i3 = Y[0 | (a3 |= 0)])) | (e3 |= 0) >>> 0 < 4)) {
              if (33 != (0 | (f3 = Y[a3 + 1 | 0]))) break r;
              if (10 == (0 | (i3 = Y[a3 + 2 | 0])) | 32 == (0 | i3)) break A;
              var n2 = q[r3 + 56 >> 2];
              if (!n2) break A;
              for (i3 = a3 + 2 | 0, f3 = e3 - 2 | 0, a3 = 0; ; ) {
                if (f3 >>> 0 <= a3 >>> 0) break A;
                if (!(e3 = P(a3 + i3 | 0, f3 - a3 | 0, 60))) break A;
                if (!(f3 >>> 0 <= (a3 = a3 + e3 | 0) >>> 0 | 60 != Y[a3 + i3 | 0]) && 33 == Y[(e3 = a3 - 1 | 0) + i3 | 0]) return O(f3 = E(r3, 1), r3, i3, e3), A3 = 0 | W[0 | n2](A3, f3, q[r3 + 112 >> 2]), --q[r3 + 420 >> 2], 0 | (A3 ? a3 + 3 | 0 : 0);
                a3 = a3 + 1 | 0;
              }
            }
            if (e3 >>> 0 < 3) break A;
            f3 = Y[a3 + 1 | 0];
          }
          var o3 = a3 + 1 | 0;
          if ((0 | i3) != (0 | f3)) {
            if (10 == (0 | f3) | 32 == (0 | f3) | 126 == (64 | i3)) break A;
            return 0 | ((A3 = $51(A3, r3, o3, e3 - 1 | 0, i3)) ? A3 + 1 | 0 : 0);
          }
          if (!(e3 >>> 0 < 4)) {
            var b3 = a3 + 2 | 0;
            if ((0 | (f3 = Y[a3 + 2 | 0])) != (0 | i3)) {
              if (10 == (0 | f3) | 32 == (0 | f3)) break A;
              return 0 | ((A3 = a0(A3, r3, b3, e3 - 2 | 0, i3)) ? A3 + 2 | 0 : 0);
            }
            if (!(e3 >>> 0 < 5 || (0 | (f3 = Y[a3 + 3 | 0])) == (0 | i3) | 126 == (64 | i3) | 10 == (0 | f3) | 32 == (0 | f3))) r: {
              for (f3 = a3 + 3 | 0, n2 = e3 - 3 | 0, a3 = 0; ; ) {
                if (n2 >>> 0 <= a3 >>> 0) break r;
                var w2 = P(a3 + f3 | 0, n2 - a3 | 0, i3);
                if (!w2) break r;
                if ((0 | i3) == Y[0 | (w2 = f3 + (a3 = a3 + w2 | 0) | 0)] && !(10 == (0 | (w2 = Y[w2 - 1 | 0])) | 32 == (0 | w2))) break;
              }
              var k3 = a3 + 2 | 0;
              if ((0 | i3) != Y[(w2 = a3 + 1 | 0) + f3 | 0] | n2 >>> 0 <= k3 >>> 0 | !q[r3 + 84 >> 2] | (0 | i3) != Y[f3 + k3 | 0]) {
                if ((0 | i3) != Y[f3 + w2 | 0] | n2 >>> 0 <= w2 >>> 0) A3 = (r3 = (A3 = a0(A3, r3, b3, e3 - 2 | 0, i3)) - 1 | 0) >>> 0 <= A3 >>> 0 ? r3 : 0;
                else {
                  if (!(A3 = $51(A3, r3, o3, e3 - 1 | 0, i3))) break r;
                  A3 = A3 - 2 | 0;
                }
                if (A3) return A3 + 3 | 0;
              } else if (O(i3 = E(r3, 1), r3, f3, a3), A3 = 0 | W[q[r3 + 84 >> 2]](A3, i3, q[r3 + 112 >> 2]), --q[r3 + 420 >> 2], A3) return a3 + 6 | 0;
            }
          }
        }
        return 0;
      }, function(A3, r3, a3, i3, f3, e3) {
        A3 |= 0, r3 |= 0, a3 |= 0, e3 |= 0;
        var n2, o3 = 0;
        for (Q = n2 = Q - 16 | 0, f3 = 0; ; ) {
          if ((0 | f3) == (0 | e3)) f3 = e3;
          else if (96 == Y[a3 + f3 | 0]) {
            f3 = f3 + 1 | 0;
            continue;
          }
          break;
        }
        var b3 = f3;
        for (i3 = 0; ; ) {
          var w2 = e3 >>> 0 <= b3 >>> 0;
          if (w2 | f3 >>> 0 <= i3 >>> 0) break;
          i3 = 96 == Y[a3 + b3 | 0] ? i3 + 1 | 0 : 0, o3 = o3 + 1 | 0, b3 = b3 + 1 | 0;
        }
        A: if (!(i3 >>> 0 < f3 >>> 0 && (i3 = 0, w2))) for (e3 = b3 >>> 0 < f3 >>> 0 ? f3 : b3, i3 = f3; ; ) {
          r: {
            if ((0 | i3) != (0 | e3)) {
              if (32 == Y[a3 + i3 | 0]) break r;
              e3 = i3;
            }
            for (w2 = f3 >>> 0 < o3 >>> 0 ? f3 : o3, o3 = b3 - f3 | 0; ; ) {
              if ((i3 = o3) >>> 0 <= f3 >>> 0) i3 = w2;
              else if (32 == Y[(o3 = i3 - 1 | 0) + a3 | 0]) continue;
              break;
            }
            if (e3 >>> 0 < i3 >>> 0) {
              q[8 + n2 >> 2] = 0, q[12 + n2 >> 2] = 0, q[4 + n2 >> 2] = i3 - e3, q[n2 >> 2] = a3 + e3, i3 = 0 | W[q[r3 + 52 >> 2]](A3, n2, q[r3 + 112 >> 2]) ? b3 : 0;
              break A;
            }
            i3 = 0 | W[q[r3 + 52 >> 2]](A3, 0, q[r3 + 112 >> 2]) ? b3 : 0;
            break A;
          }
          i3 = i3 + 1 | 0;
        }
        return Q = 16 + n2 | 0, 0 | i3;
      }, function(A3, r3, a3, i3, f3, e3) {
        if (A3 |= 0, r3 |= 0, !(32 != Y[(a3 |= 0) - 1 | (f3 = 0)] | (0 | i3) >>> 0 < 2 | 32 != Y[a3 - 2 | 0])) {
          for (f3 = q[A3 + 4 >> 2]; f3 && 32 == Y[(f3 = f3 - 1 | 0) + q[A3 >> 2] | 0]; ) q[A3 + 4 >> 2] = f3;
          f3 = 0 != (0 | W[q[r3 + 72 >> 2]](A3, q[r3 + 112 >> 2]));
        }
        return 0 | f3;
      }, function(A3, r3, a3, i3, f3, e3) {
        A3 |= 0, r3 |= 0, a3 |= 0, e3 |= 0;
        var n2 = 0, o3 = 0, b3 = 0;
        A: {
          r: {
            a: {
              i: {
                if (0 | i3) {
                  var w2 = r3 + 420 | 0, k3 = q[w2 >> 2];
                  if (33 == Y[a3 - 1 | 0]) {
                    if (b3 = 1, q[r3 + 68 >> 2]) break i;
                    break a;
                  }
                } else k3 = q[(w2 = r3 + 420 | 0) >> 2];
                if (!q[r3 + 76 >> 2]) break a;
              }
              for (var c3 = e3 >>> 0 <= 1 ? 1 : e3, t3 = i3 = 1; ; ) {
                if ((0 | i3) == (0 | c3)) break a;
                i: {
                  f: if (10 == (0 | (f3 = Y[a3 + i3 | 0]))) n2 = 1;
                  else {
                    var D2 = i3 - 1 | 0;
                    if (92 != Y[D2 + a3 | 0]) {
                      switch (f3 - 91 | 0) {
                        case 0:
                          t3 = t3 + 1 | 0;
                          break f;
                        case 2:
                          break;
                        default:
                          break f;
                      }
                      if ((0 | t3) < 2) break i;
                      t3 = t3 - 1 | 0;
                    }
                  }
                  i3 = i3 + 1 | 0;
                  continue;
                }
                break;
              }
              f3 = c3 = i3 + 1 | 0;
              i: {
                f: {
                  e: {
                    for (; ; ) {
                      if (!(e3 >>> 0 <= f3 >>> 0)) {
                        var u2 = Y[a3 + f3 | 0];
                        if (10 == (0 | u2) | 32 == (0 | u2)) {
                          f3 = f3 + 1 | 0;
                          continue;
                        }
                        if (91 == (0 | u2)) break e;
                        if (40 == (0 | u2)) {
                          for (c3 = e3 - 1 | 0; ; ) {
                            if (e3 >>> 0 <= (f3 = (u2 = f3) + 1 | 0) >>> 0) u2 = c3, f3 = e3;
                            else if (10 == (0 | (n2 = Y[a3 + f3 | 0])) | 32 == (0 | n2)) continue;
                            break;
                          }
                          for (c3 = f3; ; ) {
                            if (e3 >>> 0 <= c3 >>> 0) break a;
                            n2 = 2;
                            n: {
                              var B2 = a3 + c3 | 0, g2 = Y[0 | B2];
                              if (92 != (0 | g2)) {
                                if (41 == (0 | g2)) {
                                  B2 = 0, n2 = c3;
                                  break f;
                                }
                                if (n2 = 1, c3 && !(32 != (0 | (B2 = Y[B2 - 1 | 0])) & 10 != (0 | B2)) && 34 == (0 | g2) | 39 == (0 | g2)) break n;
                              }
                              c3 = c3 + n2 | 0;
                              continue;
                            }
                            break;
                          }
                          for (n2 = o3 = c3 + (B2 = 1) | 0; ; ) {
                            if (e3 >>> 0 <= n2 >>> 0) break a;
                            var s2 = 2;
                            if (92 != (0 | (t3 = Y[a3 + n2 | 0]))) {
                              if (s2 = 1, (0 | t3) == (0 | g2)) B2 = 0;
                              else if (!(41 != (0 | t3) | B2)) {
                                for (e3 = (e3 = n2 - 1 | 0) >>> 0 < o3 >>> 0 ? e3 : o3, B2 = n2; ; ) {
                                  if ((B2 = B2 - 1 | 0) >>> 0 <= o3 >>> 0) t3 = Y[a3 + e3 | 0], B2 = e3;
                                  else if (10 == (0 | (t3 = Y[a3 + B2 | 0])) | 32 == (0 | t3)) continue;
                                  break;
                                }
                                if (34 == (0 | (e3 = 255 & t3)) | 39 == (0 | e3)) break f;
                                B2 = o3 = 0, c3 = n2;
                                break f;
                              }
                            }
                            n2 = n2 + s2 | 0;
                          }
                        }
                      }
                      break;
                    }
                    if (n2) {
                      for (u2 = E(r3, 1), f3 = 1; (0 | i3) != (0 | f3); ) 10 == (0 | (n2 = Y[0 | (e3 = a3 + f3 | 0)])) && (n2 = 32) == Y[e3 - 1 | 0] || F(u2, n2), f3 = f3 + 1 | 0;
                      n2 = q[u2 >> 2], f3 = q[u2 + 4 >> 2];
                    } else n2 = a3 + 1 | 0, f3 = D2;
                    if (!(f3 = m0(r3 + 116 | 0, n2, f3))) break a;
                    g2 = q[f3 + 8 >> 2], s2 = q[f3 + 4 >> 2];
                    break i;
                  }
                  for (f3 = c3 = f3 + 1 | 0; ; ) {
                    if (e3 >>> 0 <= f3 >>> 0) break a;
                    if (93 == Y[a3 + f3 | 0]) break;
                    f3 = f3 + 1 | 0;
                  }
                  if (u2 = r3 + 116 | 0, (0 | f3) == (0 | c3)) if (n2) {
                    for (B2 = E(r3, 1), c3 = 1; (0 | i3) != (0 | c3); ) 10 == (0 | (n2 = Y[0 | (e3 = a3 + c3 | 0)])) && (n2 = 32) == Y[e3 - 1 | 0] || F(B2, n2), c3 = c3 + 1 | 0;
                    n2 = q[B2 + 4 >> 2], e3 = q[B2 >> 2];
                  } else n2 = D2, e3 = a3 + 1 | 0;
                  else n2 = f3 - c3 | 0, e3 = a3 + c3 | 0;
                  if (!(e3 = m0(u2, e3, n2))) break a;
                  c3 = f3 + 1 | 0, g2 = q[e3 + 8 >> 2], s2 = q[e3 + 4 >> 2];
                  break i;
                }
                for (g2 = c3 >>> 0 < f3 >>> 0 ? c3 : f3; ; ) {
                  if ((t3 = c3) >>> 0 <= f3 >>> 0) e3 = Y[(c3 = g2 - 1 | 0) + a3 | 0], t3 = g2;
                  else if (10 == (0 | (e3 = Y[(c3 = t3 - 1 | 0) + a3 | 0])) | 32 == (0 | e3)) continue;
                  break;
                }
                s2 = g2 = 0, (f3 = 60 == Y[a3 + f3 | 0] ? u2 + 2 | 0 : f3) >>> 0 < (e3 = 62 == (255 & e3) ? c3 : t3) >>> 0 && N(s2 = E(r3, 1), a3 + f3 | 0, e3 - f3 | 0), o3 >>> 0 < B2 >>> 0 && N(g2 = E(r3, 1), a3 + o3 | 0, B2 - o3 | 0), c3 = n2 + 1 | 0;
              }
              if (i3 >>> (f3 = 0) < 2 || (f3 = E(r3, 1), b3 ? N(f3, a3 + 1 | 0, D2) : (q[r3 + 440 >> 2] = 1, O(f3, r3, a3 + 1 | 0, D2), q[r3 + 440 >> 2] = 0)), s2) {
                if (n0(i3 = E(r3, 1), s2), A3 = b3 ? ((a3 = q[A3 + 4 >> 2]) && 33 == Y[(a3 = a3 - 1 | 0) + q[A3 >> 2] | 0] && (q[A3 + 4 >> 2] = a3), 0 | W[q[r3 + 68 >> 2]](A3, i3, g2, f3, q[r3 + 112 >> 2])) : 0 | W[q[r3 + 76 >> 2]](A3, i3, g2, f3, q[r3 + 112 >> 2]), q[w2 >> 2] = k3, A3) break A;
                break r;
              }
            }
            q[w2 >> 2] = k3;
          }
          c3 = 0;
        }
        return 0 | c3;
      }, function(A3, r3, a3, i3, f3, e3) {
        A3 |= 0, r3 |= 0, a3 |= 0;
        var n2, o3 = 0, b3 = 0, w2 = 0;
        Q = n2 = Q - 16 | 0;
        A: if (!((e3 |= 0) >>> (i3 = 0) < 3) && 60 == Y[(i3 = 0) | a3]) {
          if (H(Y[(i3 = 47 == Y[a3 + 1 | 0] ? 2 : 1) + a3 | 0])) {
            for (; ; ) {
              if ((0 | i3) == (0 | e3)) i3 = e3;
              else if (H(f3 = Y[a3 + i3 | 0]) || !(3 < (f3 = f3 - 43 | 0) >>> 0 | 1 == (0 | f3))) {
                i3 = i3 + 1 | 0;
                continue;
              }
              break;
            }
            if (f3 = 1, !(i3 >>> 0 < 2)) {
              r: {
                var k3 = a3 + i3 | 0, c3 = Y[0 | k3];
                if (64 == (0 | c3)) {
                  var t3 = e3 - i3 | 0;
                  for (f3 = 0; ; ) {
                    if ((0 | f3) == (0 | t3)) break r;
                    a: if (!(H(o3 = Y[f3 + k3 | 0]) | o3 - 45 >>> 0 < 2)) {
                      switch (o3 - 62 | 0) {
                        case 2:
                          w2 = w2 + 1 | 0;
                          break a;
                        case 0:
                          if ((o3 = 1) != (0 | w2)) break r;
                          b3 = 1 + (i3 + f3 | 0) | 0, i3 = 2;
                          break A;
                        case 1:
                          break r;
                      }
                      if (95 != (0 | o3)) break r;
                    }
                    f3 = f3 + 1 | 0;
                  }
                }
              }
              if (58 != (0 | c3) | i3 >>> 0 < 3) f3 = i3;
              else if (!(e3 >>> 0 <= (f3 = i3 + 1 | 0) >>> 0)) {
                for (i3 = f3; ; ) {
                  if (e3 >>> 0 <= i3 >>> 0) {
                    i3 = o3 = 1;
                    break A;
                  }
                  r: {
                    if (92 != (0 | (o3 = Y[a3 + i3 | 0]))) {
                      switch (o3 - 32 | 0) {
                        default:
                          if (10 == (0 | o3) | 39 == (0 | o3) | 62 == (0 | o3)) break r;
                          break;
                        case 0:
                        case 2:
                          break r;
                        case 1:
                      }
                      o3 = 1;
                    } else o3 = 2;
                    i3 = o3 + i3 | 0;
                    continue;
                  }
                  break;
                }
                if (!(62 != (0 | o3) | i3 >>> 0 <= f3 >>> 0)) {
                  b3 = i3 + (o3 = 1) | 0, i3 = 1;
                  break A;
                }
                f3 = i3;
              }
            }
            for (i3 = e3 >>> 0 < f3 >>> 0 ? f3 : e3; ; ) {
              if ((0 | i3) == (0 | f3)) {
                i3 = o3 = 0;
                break A;
              }
              if (62 == Y[a3 + f3 | 0]) break;
              f3 = f3 + 1 | 0;
            }
            b3 = f3 >>> 0 < e3 >>> 0 ? f3 + 1 | 0 : 0;
          }
          i3 = o3 = 0;
        }
        q[8 + n2 >> 2] = 0, q[12 + n2 >> 2] = 0, q[n2 >> 2] = a3;
        A: {
          r: if (!((q[4 + n2 >> 2] = b3) >>> 0 < 3)) {
            if (!q[r3 + 48 >> 2] | !o3) {
              if (!(a3 = q[r3 + 80 >> 2])) break r;
              i3 = 0 | W[0 | a3](A3, n2, q[r3 + 112 >> 2]);
            } else f3 = E(r3, 1), q[4 + n2 >> 2] = b3 - 2, q[n2 >> 2] = a3 + 1, n0(f3, n2), i3 = 0 | W[q[r3 + 48 >> 2]](A3, f3, i3, q[r3 + 112 >> 2]), --q[r3 + 420 >> 2];
            if (i3) break A;
          }
          b3 = 0;
        }
        return Q = 16 + n2 | 0, 0 | b3;
      }, function(A3, r3, a3, i3, f3, e3) {
        var n2;
        return A3 |= 0, r3 |= 0, a3 |= 0, e3 |= 0, Q = i3 = Q - 16 | 0, q[8 + i3 >> 2] = 0, (f3 = 2) <= e3 >>> (q[12 + i3 >> 2] = 0) ? A0(1024, e3 = Y[a3 + 1 | 0], 24) ? (n2 = q[r3 + 100 >> 2]) ? (q[4 + i3 >> 2] = 1, q[i3 >> 2] = a3 + 1, W[0 | n2](A3, i3, q[r3 + 112 >> 2])) : F(A3, e3) : f3 = 0 : 1 == (0 | e3) && F(A3, Y[0 | a3]), Q = 16 + i3 | 0, 0 | f3;
      }, function(A3, r3, a3, i3, f3, e3) {
        A3 |= 0, r3 |= 0, a3 |= 0, e3 |= 0;
        var n2, o3, b3, w2, k3 = 0, c3 = 0, t3 = 0, D2 = 0, u2 = 0, B2 = (Q = o3 = Q - 16 | 0, q[8 + o3 >> 2] = 0, e3 >>> (q[12 + o3 >> 2] = 0) < 2 ? w2 = b3 = 1 : 35 != (0 | (i3 = Y[a3 + (b3 = 1) | 0])) | e3 >>> 0 <= (w2 = (u2 = 35 == (0 | i3)) ? 2 : 1) >>> 0 || (b3 = 120 != (0 | (i3 = y(Y[a3 + w2 | 0]))), w2 = (120 == (0 | i3)) + w2 | 0, u2 = 1), e3 >>> 0 < w2 >>> 0 ? w2 : e3);
        f3 = w2;
        A: {
          for (; ; ) {
            if (((i3 = 0) | f3) == (0 | B2)) break A;
            var g2 = M[a3 + f3 | 0];
            r: {
              a: {
                if (!b3) {
                  if (g2 - 48 >>> 0 < 10 | (32 | g2) - 97 >>> 0 < 6) break a;
                  break r;
                }
                if (u2) {
                  if (10 <= g2 - 48 >>> 0) break r;
                } else if (!H(g2)) break r;
              }
              f3 = f3 + 1 | 0;
              continue;
            }
            break;
          }
          if (!(f3 >>> 0 <= w2 >>> 0 | e3 >>> 0 <= f3 >>> 0 | 59 != (0 | g2))) {
            var s2 = f3 + 1 | 0;
            r: {
              if (u2) {
                if (7 < f3 - w2 >>> 0) break A;
                g2 = b3 ? 10 : 16, Q = n2 = Q - 16 | 0;
                a: if (e3 = Y[0 | (f3 = a3 + w2 | 0)]) {
                  i: {
                    for (; ; ) {
                      if (!U(e3 << 24 >> 24)) break i;
                      if (e3 = Y[f3 + 1 | 0], f3 = f3 + 1 | 0, !e3) break;
                    }
                    break a;
                  }
                  switch ((e3 &= 255) - 43 | 0) {
                    case 0:
                    case 2:
                      break;
                    default:
                      break a;
                  }
                  c3 = 45 == (0 | e3) ? -1 : 0, f3 = f3 + 1 | 0;
                }
                for (16 != (16 | g2) | 48 != Y[0 | f3] || (f3 = (e3 = 88 == (223 & Y[f3 + 1 | 0])) ? f3 + 2 | 0 : f3 + 1 | 0, g2 = e3 ? 16 : g2); ; ) {
                  if (e3 = -48, ((B2 = M[0 | f3]) - 48 & 255) >>> 0 < 10 || (e3 = -87, (B2 - 97 & 255) >>> 0 < 26) || (e3 = -55, !(25 < (B2 - 65 & 255) >>> 0))) {
                    var G2 = e3 + B2 | 0;
                    if (!((0 | g2) <= (0 | G2))) {
                      var m2 = B0(D2, e3 = 0, 0, 0), v2 = h, J2 = B0(k3, 0, B2 = g2, 0), P2 = h + (e3 = B0(0, 0, k3, 0)) | 0, C2 = h + 0 | 0, Z2 = m2, m2 = P2 >>> 0 < e3 >>> 0 ? 1 + C2 | 0 : C2, C2 = v2, v2 = e3 = Z2 + m2 | 0, B2 = B0(D2, 0, B2, 0) + P2 | 0;
                      e3 = h, C2 = v2 >>> 0 < m2 >>> 0 ? C2 + 1 | 0 : C2, q[8 + n2 >> 2] = P2 = (Z2 = B2 >>> 0 < P2 >>> 0 ? e3 + 1 | 0 : e3) + v2 | 0, q[12 + n2 >> 2] = P2 >>> 0 < Z2 >>> 0 ? C2 + 1 | 0 : C2, q[n2 >> 2] = J2, q[4 + n2 >> 2] = B2, q[8 + n2 >> 2] | q[12 + n2 >> 2] ? t3 = 1 : (B2 = B0(k3, D2, g2, 0), t3 = (C2 = -1 == (0 | (e3 = h)) & (-1 ^ G2) >>> 0 < B2 >>> 0) ? 1 : t3, e3 = (B2 = B2 + G2 | 0) >>> 0 < G2 >>> 0 ? e3 + 1 | 0 : e3, k3 = C2 ? k3 : B2, D2 = C2 ? D2 : e3), f3 = f3 + 1 | 0;
                      continue;
                    }
                  }
                  break;
                }
                Q = 16 + n2 | 0;
                a: {
                  i: {
                    f: {
                      if (t3) {
                        if (q[2678] = 68, k3 = -2147483648, c3) break i;
                      } else {
                        if (!D2 & k3 >>> 0 < 2147483648) break i;
                        if (c3) break f;
                      }
                      q[2678] = 68, f3 = 2147483647;
                      break a;
                    }
                    if (f3 = !D2 & k3 >>> 0 < 2147483649, k3 = -2147483648, !f3) {
                      q[2678] = 68, f3 = -2147483648;
                      break a;
                    }
                  }
                  f3 = (k3 ^ c3) - c3 | 0;
                }
                if (4294967277 < f3 - 32 >>> 0 | f3 >>> 0 < 9 | 55296 == (-2048 & f3) | 4294967293 < f3 - 13 >>> 0 | 65534 == (-2 & f3)) break A;
                if (f3 >>> 0 <= 1114111) break r;
                break A;
              }
              if ((g2 = 6) < (k3 = f3 - 3 | 0) >>> 0) break A;
              switch (e3 = 4, c3 = 5, 0 | k3) {
                default:
                  g2 = s2 + l[8400 + (Y[a3 + 6 | 0] << 1) >> 1] | 0;
                case 2:
                  c3 = l[8400 + (Y[a3 + 5 | 0] << 1) >> 1] + g2 | 0;
                case 1:
                  e3 = l[8400 + (Y[a3 + 4 | 0] << 1) >> 1] + c3 | 0;
                case 0:
              }
              if (770 < (e3 = l[8400 + (Y[a3 + 1 | 0] << 1) >> 1] + (l[8402 + (Y[a3 + 2 | 0] << 1) >> 1] + (l[8400 + (Y[a3 + 3 | 0] << 1) >> 1] + e3 | 0) | 0) | 0) >>> 0) break A;
              if (B2 = q[5312 + (e3 << 2) >> 2], Y[0 | a3] != Y[0 | B2]) break A;
              c3 = B2 + 1 | 0, e3 = f3;
              a: if (f3 = Y[(g2 = 0) | (t3 = a3 + 1 | 0)]) {
                for (; (k3 = Y[0 | c3]) && !(!(e3 = e3 - 1 | 0) | (0 | f3) != (0 | k3)); ) if (c3 = c3 + 1 | 0, f3 = Y[t3 + 1 | 0], t3 = t3 + 1 | 0, !f3) break a;
                g2 = f3;
              }
              if (Y[B2 + s2 | 0] | (255 & g2) - Y[0 | c3]) break A;
            }
            (i3 = q[r3 + 96 >> 2]) ? (q[4 + o3 >> 2] = s2, q[o3 >> 2] = a3, W[0 | i3](A3, o3, q[r3 + 112 >> 2])) : (F(A3, 38), u2 && F(A3, 35), b3 || F(A3, 120), N(A3, a3 + w2 | 0, s2 - w2 | 0)), i3 = s2;
          }
        }
        return Q = 16 + o3 | 0, 0 | i3;
      }, function(A3, r3, a3, i3, f3, e3) {
        A3 |= 0, a3 |= 0, i3 |= 0, e3 |= 0;
        var n2, o3 = 0;
        if (!(q[440 + (r3 |= 0) >> 2] | !q[r3 + 48 >> 2])) {
          var b3 = E(r3, 1);
          A: if (!(47 != Y[a3 + 1 | 0] | e3 >>> 0 < 4 | 47 != Y[a3 + 2 | 0])) for (f3 = 0; ; ) {
            r: {
              if ((0 | i3) != (0 | f3)) {
                if ((32 | Y[(-1 ^ f3) + a3 | 0]) - 97 >>> 0 < 26) break r;
                i3 = f3;
              }
              var w2 = a3 - i3 | 0;
              if (!b0(w2, i3 + e3 | 0)) break A;
              if (!(f3 = u0(a3 + 3 | 0, e3 - 3 | 0))) break A;
              for (n2 = (f3 = f3 + 3 | 0) >>> 0 < e3 >>> 0 ? e3 : f3; ; ) {
                a: {
                  if (f3 >>> 0 < e3 >>> 0) {
                    if (!U(Y[a3 + f3 | 0])) break a;
                  } else f3 = n2;
                  if (!(a3 = R(a3, f3))) break A;
                  N(b3, w2, a3 + i3 | 0), i3 >>> 0 <= (f3 = q[A3 + 4 >> 2]) >>> 0 && (q[A3 + 4 >> 2] = f3 - i3), W[q[r3 + 48 >> 2]](A3, b3, 1, q[r3 + 112 >> 2]), o3 = a3;
                  break A;
                }
                f3 = f3 + 1 | 0;
              }
            }
            f3 = f3 + 1 | 0;
          }
          --q[r3 + 420 >> 2];
        }
        return 0 | o3;
      }, function(A3, r3, a3, i3, f3, e3) {
        A3 |= 0, a3 |= 0, i3 |= 0, e3 |= 0;
        var n2, o3 = 0;
        if (!(q[440 + (r3 |= f3 = 0) >> 2] | !q[r3 + 48 >> 2])) {
          var b3 = E(r3, 1);
          A: {
            for (; ; ) {
              if ((0 | i3) == (0 | f3)) break A;
              if (!(n2 = Y[(-1 ^ f3) + a3 | 0]) || !H(n2) && !A0(1252, n2, 5)) break;
              f3 = f3 + 1 | 0;
            }
            i3 = f3;
          }
          if (i3) {
            var w2 = e3 - 1 | 0;
            f3 = n2 = 0;
            A: {
              for (; ; ) {
                if ((0 | f3) == (0 | e3)) break A;
                r: {
                  var k3 = Y[a3 + f3 | 0];
                  a: if (!H(k3)) {
                    switch (k3 - 45 | 0) {
                      default:
                        if (95 == (0 | k3)) break a;
                        if (64 != (0 | k3)) break r;
                        n2 = n2 + 1 | 0;
                        break a;
                      case 0:
                        break a;
                      case 1:
                    }
                    if (w2 >>> 0 <= f3 >>> 0) break r;
                    o3 = o3 + 1 | 0;
                  }
                  f3 = f3 + 1 | 0;
                  continue;
                }
                break;
              }
              e3 = f3;
            }
            !o3 | 1 != ((f3 = 0) | n2) | e3 >>> 0 < 2 || !(e3 = R(a3, e3)) || (N(b3, a3 - i3 | 0, i3 + e3 | 0), i3 >>> 0 <= (a3 = q[A3 + 4 >> 2]) >>> 0 && (q[A3 + 4 >> 2] = a3 - i3), W[q[r3 + 48 >> 2]](A3, b3, 2, q[r3 + 112 >> 2]), f3 = e3);
          } else f3 = 0;
          --q[r3 + 420 >> 2];
        }
        return 0 | f3;
      }, function(A3, r3, a3, i3, f3, e3) {
        if (A3 |= 0, a3 |= 0, i3 |= 0, e3 |= 0, !(q[440 + (r3 |= f3 = 0) >> 2] | !q[r3 + 76 >> 2])) {
          var n2 = E(r3, 1);
          A: {
            r: {
              a: {
                if (i3 && (94 <= (i3 = Y[a3 - 1 | 0]) - 33 >>> 0 || H(i3))) {
                  if (i3 = U(i3), e3 >>> 0 < 4) break r;
                  if (i3) break a;
                  break r;
                }
                if (e3 >>> 0 < 4) break r;
              }
              if (!v0(a3, 3529, 4) && (f3 = u0(a3, e3))) for (i3 = e3 >>> 0 < f3 >>> 0 ? f3 : e3; ; ) {
                a: {
                  if ((0 | i3) != (0 | f3)) {
                    if (!U(Y[a3 + f3 | 0])) break a;
                  } else f3 = i3;
                  if (!(f3 = R(a3, f3))) break r;
                  N(n2, a3, f3), N(a3 = E(r3, 1), 3471, 7), N(a3, q[n2 >> 2], q[n2 + 4 >> 2]), A3 = (q[r3 + 100 >> 2] ? (i3 = E(r3, 1), W[q[r3 + 100 >> 2]](i3, n2, q[r3 + 112 >> 2]), W[q[r3 + 76 >> 2]](A3, a3, 0, i3, q[r3 + 112 >> 2]), q[r3 + 420 >> 2] - 1 | 0) : (W[q[r3 + 76 >> 2]](A3, a3, 0, n2, q[r3 + 112 >> 2]), q[r3 + 420 >> 2])) - 1 | 0;
                  break A;
                }
                f3 = f3 + 1 | 0;
              }
            }
            f3 = 0, A3 = q[r3 + 420 >> 2];
          }
          q[r3 + 420 >> 2] = A3 - 1;
        }
        return 0 | f3;
      }, function(A3, r3, a3, i3, f3, e3) {
        A3 |= 0, a3 |= 0, i3 |= 0, f3 |= 0, e3 |= 0;
        var n2 = 0, o3 = 0;
        if (!(q[440 + (r3 |= 0) >> 2] | !q[r3 + 48 >> 2])) {
          var b3 = E(r3, 1);
          A: {
            r: {
              var w2 = D0(a3, i3, f3, e3, 114);
              a: if (w2) {
                5 <= e3 >>> 0 && (o3 = !g(a3 + 1 | 0, 3534, 4));
                var k3 = 1;
                i: {
                  f: for (; ; ) {
                    e: {
                      if ((n2 = k3 + 10 | 0) >>> 0 <= e3 >>> 0) {
                        var c3 = 10;
                        if (!g(a3 + k3 | 0, 1120, 10)) break e;
                      }
                      var t3 = (n2 = k3) + 2 | 0;
                      if (t3 >>> 0 < e3 >>> 0 && (n2 = g(a3 + k3 | 0, 3397, 2) ? k3 : t3), !H(Y[a3 + n2 | 0])) break a;
                      n2 = n2 + 1 | 0, c3 = 24;
                    }
                    for (t3 = e3 >>> 0 < n2 >>> 0 ? n2 : e3; ; ) {
                      e: {
                        n: {
                          if ((0 | n2) != (0 | t3)) {
                            var D2 = Y[a3 + n2 | 0];
                            if (H(D2) | 95 == (0 | D2)) break n;
                            t3 = n2;
                          }
                          if ((n2 = t3 - k3 | 0) >>> 0 < 2 | c3 >>> 0 < n2 >>> 0) break a;
                          if (e3 >>> 0 <= t3 >>> 0) break e;
                          if (43 != (0 | (n2 = Y[a3 + t3 | 0])) & !(45 == (0 | n2) & o3)) break e;
                          if (k3 = t3 + (n2 = 1) | 0, t3) continue f;
                          break i;
                        }
                        n2 = n2 + 1 | 0;
                        continue;
                      }
                      break;
                    }
                    break;
                  }
                  n2 = t3;
                }
                i: if (!(47 != Y[a3 + n2 | 0] | e3 >>> 0 <= n2 >>> 0)) for (t3 = e3 >>> 0 < n2 >>> 0 ? n2 : e3; ; ) {
                  if ((0 | n2) == (0 | t3)) {
                    n2 = t3;
                    break i;
                  }
                  f: if (!H(c3 = Y[a3 + n2 | 0])) {
                    switch (c3 - 45 | 0) {
                      case 1:
                        break i;
                      case 0:
                      case 2:
                        break f;
                    }
                    if (95 != (0 | c3)) break i;
                  }
                  n2 = n2 + 1 | 0;
                }
                if (N(b3, a3 - w2 | 0, n2 + w2 | 0), n2) break r;
              }
              if (!(e3 >>> 0 < 3 || !(w2 = D0(a3, i3, f3, e3, 117)) || (n2 = 2, !(H(i3 = Y[a3 + 1 | 0]) | 95 == (0 | i3)) & 45 != (0 | i3)))) {
                for (; ; ) {
                  a: {
                    if ((0 | e3) != (0 | n2)) {
                      i: if (!H(i3 = Y[a3 + n2 | 0])) {
                        switch (i3 - 45 | 0) {
                          case 1:
                            break a;
                          case 0:
                          case 2:
                            break i;
                        }
                        if (95 != (0 | i3)) break a;
                      }
                      n2 = n2 + 1 | 0;
                      continue;
                    }
                    n2 = e3;
                  }
                  break;
                }
                if (N(b3, a3 - w2 | 0, n2 + w2 | 0), n2) break r;
              }
              n2 = 0, A3 = q[r3 + 420 >> 2];
              break A;
            }
            i3 = E(r3, 1), 1 == (0 | w2) && F(i3, 47), N(i3, q[b3 >> 2], q[b3 + 4 >> 2]), w2 >>> 0 <= (a3 = q[A3 + 4 >> 2]) >>> 0 && (q[A3 + 4 >> 2] = a3 - w2), A3 = (q[r3 + 100 >> 2] ? (a3 = E(r3, 1), W[q[r3 + 100 >> 2]](a3, b3, q[r3 + 112 >> 2]), W[q[r3 + 76 >> 2]](A3, i3, 0, a3, q[r3 + 112 >> 2]), q[r3 + 420 >> 2] - 1 | 0) : (W[q[r3 + 76 >> 2]](A3, i3, 0, b3, q[r3 + 112 >> 2]), q[r3 + 420 >> 2])) - 1 | 0;
          }
          q[r3 + 420 >> 2] = A3 - 1;
        }
        return 0 | n2;
      }, function(A3, r3, a3, i3, f3, e3) {
        A3 |= 0, a3 |= 0;
        var n2 = 0;
        A: if (!(!q[92 + (r3 |= 0) >> 2] | (e3 |= 0) >>> 0 < 2)) {
          r: {
            a: {
              var o3 = Y[a3 + 1 | 0];
              if (40 == (0 | o3)) for (i3 = 2; ; ) {
                if ((0 | i3) == (0 | e3)) break A;
                f3 = 2;
                var b3 = a3 + i3 | 0;
                if (41 == Y[0 | b3] | 92 == Y[b3 - 1 | 0]) break a;
                i3 = i3 + 1 | 0;
              }
              for (f3 = i3 = 1; ; ) {
                if ((0 | i3) == (0 | e3)) break r;
                if (10 == (0 | (b3 = Y[a3 + i3 | 0])) | 32 == (0 | b3)) break;
                i3 = i3 + 1 | 0;
              }
              e3 = i3;
              break r;
            }
            e3 = i3;
          }
          if ((0 | f3) == (0 | e3)) return 0 | (40 == (0 | o3) ? 3 : 0);
          O(i3 = E(r3, 1), r3, a3 + f3 | 0, e3 - f3 | 0), W[q[r3 + 92 >> 2]](A3, i3, q[r3 + 112 >> 2]), --q[r3 + 420 >> 2], n2 = (40 == (0 | o3)) + e3 | 0;
        }
        return 0 | n2;
      }, function(A3, r3, a3, i3) {
        A3 |= 0, r3 |= 0, a3 |= 0;
        var f3, e3 = q[4 + (i3 |= 0) >> 2];
        e3 ? f3 = q[i3 + 8 >> 2] : (N(A3, 3928, 18), q[i3 + 8 >> 2] = f3 = a3 - 1 | 0, e3 = q[i3 + 4 >> 2]);
        A: {
          if ((0 | e3) < (0 | (a3 = a3 - f3 | 0))) for (; ; ) {
            if ((0 | a3) <= (0 | e3)) break A;
            N(A3, 3742, 10), e3 = q[i3 + 4 >> 2] + 1 | 0, q[i3 + 4 >> 2] = e3;
          }
          if ((0 | a3) < (0 | e3)) {
            for (N(A3, 3771, 6), e3 = q[i3 + 4 >> 2]; (0 | a3) < (0 | e3); ) N(A3, 3765, 12), e3 = q[i3 + 4 >> 2] - 1 | 0, q[i3 + 4 >> 2] = e3;
            N(A3, 3759, 5);
          } else N(A3, 3753, 11);
        }
        N(A3, 3539, 10), (a3 = q[i3 + 12 >> 2]) && m(A3, a3), N(A3, 1247, 4), q[i3 >> 2] = (a3 = q[i3 >> 2]) + 1, r0(A3, a3), N(A3, 1448, 2), r3 && D(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, 3870, 5);
      }, function(A3, r3, a3) {
        return r3 |= 0, N(A3 |= 0, 1348, 6), r3 && D(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, 1355, 7), 1;
      }, function(A3, r3, a3) {
        return 0 | f2(0 | A3, 0 | r3, 7, 1274, 30, 1372);
      }, function(A3, r3, a3) {
        return 0 | f2(0 | A3, 0 | r3, 9, 1333, 8, 1319);
      }, function(A3, r3, a3) {
        return 0 | f2(0 | A3, 0 | r3, 5, 1295, 4, 1290);
      }, function(A3, r3, a3, i3, f3) {
        return (i3 |= 0) && (r3 = q[i3 + 4 >> 2]) && N(0 | A3, q[i3 >> 2], r3), 1;
      }, function(A3, r3, a3) {
        return 0 | f2(0 | A3, 0 | r3, 14, 1328, 12, 1282);
      }, function(A3, r3, a3) {
        return 0 | f2(0 | A3, 0 | r3, 6, 1307, 5, 1301);
      }, function(A3, r3, a3) {
        return 0 | f2(0 | A3, 0 | r3, 6, 1263, 5, 1257);
      }, function(A3, r3) {
        A3 |= 0;
        for (var a3 = 0, i3 = q[4 + (r3 |= 0) >> 2]; 0 < (0 | i3); ) N(A3, 3716, 12), i3 = q[r3 + 4 >> 2] - 1 | 0, q[r3 + 4 >> 2] = i3, a3 = 1;
        a3 && N(A3, 3671, 7), q[r3 >> 2] = 0, q[r3 + 4 >> 2] = 0, q[r3 + 8 >> 2] = 0;
      }, function(A3, r3, a3, i3) {
        r3 |= 0, a3 |= 0;
        var f3, e3 = 0, n2 = 0;
        q[4 + (A3 |= 0) >> 2] && F(A3, 10);
        A: {
          if (!(!a3 | !q[a3 + 4 >> 2])) for (N(A3, 3584, 18); ; ) {
            r: {
              var o3 = q[a3 + 4 >> 2];
              if (e3 >>> 0 < o3 >>> 0) for (; ; ) {
                if ((0 | e3) == (0 | o3)) {
                  i3 = o3;
                  break r;
                }
                var b3 = q[a3 >> 2], w2 = Y[b3 + e3 | 0];
                if (U(w2)) e3 = e3 + 1 | 0;
                else for (i3 = e3 >>> 0 < o3 >>> 0 ? o3 : e3, f3 = e3; ; ) {
                  a: {
                    if (f3 >>> 0 < o3 >>> 0) {
                      if (!U(Y[f3 + b3 | 0])) break a;
                      i3 = f3;
                    }
                    n2 && (F(A3, 32), b3 = q[a3 >> 2]), D(A3, (f3 = (46 == (0 | w2)) + e3 | 0) + b3 | 0, i3 - f3 | 0);
                    break r;
                  }
                  f3 = f3 + 1 | 0;
                }
              }
              N(A3, 1448, 2);
              break A;
            }
            n2 = n2 + 1 | 0, e3 = i3 + 1 | 0;
          }
          N(A3, 1343, 11);
        }
        r3 && D(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, 3814, 14);
      }, function(A3, r3, a3) {
        r3 |= 0, q[4 + (A3 |= 0) >> 2] && F(A3, 10), N(A3, 3785, 13), r3 && N(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, 3799, 14);
      }, function(A3, r3, a3) {
        r3 |= 0, q[4 + (A3 |= 0) >> 2] && F(A3, 10), N(A3, 3890, 37), r3 && N(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, 3799, 14);
      }, function(A3, r3, a3) {
        A3 |= 0;
        var i3, f3 = 0;
        A: if (r3 |= 0) {
          for (a3 = q[r3 + 4 >> 2]; ; ) {
            if (i3 = a3) {
              if (10 == Y[(a3 = i3 - 1 | 0) + q[r3 >> 2] | 0]) continue;
            } else i3 = 0;
            break;
          }
          for (; ; ) {
            if ((0 | f3) == (0 | i3)) break A;
            if (10 != Y[(a3 = q[r3 >> 2]) + f3 | 0]) break;
            f3 = f3 + 1 | 0;
          }
          q[A3 + 4 >> 2] && (F(A3, 10), a3 = q[r3 >> 2]), N(A3, a3 + f3 | 0, i3 - f3 | 0), F(A3, 10);
        }
      }, function(A3, r3, a3, i3) {
        r3 |= 0, a3 |= 0, i3 |= 0, q[4 + (A3 |= 0) >> 2] && F(A3, 10);
        var f3 = q[i3 + 16 >> 2];
        N(A3, 1153, 2), r0(A3, a3), 64 & f3 ? (N(A3, 3634, 5), (f3 = q[i3 + 12 >> 2]) && m(A3, f3), N(A3, 1247, 4), i3 = q[(f3 = i3) >> 2], q[f3 >> 2] = i3 + 1, r0(A3, i3), N(A3, 1448, 2)) : N(A3, 1449, 1), r3 && N(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, 1156, 3), r0(A3, a3), N(A3, 3944, 2);
      }, function(A3, r3) {
        r3 |= 0, q[4 + (A3 |= 0) >> 2] && F(A3, 10), m(A3, 256 & q[r3 + 16 >> 2] ? 3876 : 3692);
      }, function(A3, r3, a3, i3) {
        r3 |= 0, a3 |= 0, q[4 + (A3 |= 0) >> 2] && F(A3, 10), N(A3, (a3 &= 1) ? 3729 : 3710, 5), r3 && N(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, a3 ? 3735 : 3722, 6);
      }, function(A3, r3, a3, i3) {
        if (r3 |= 0, N(A3 |= 0, 1314, 4), r3) {
          for (i3 = q[r3 >> 2], a3 = q[r3 + 4 >> 2]; ; ) {
            if (r3 = a3) {
              if (10 == Y[i3 + (a3 = r3 - 1 | 0) | 0]) continue;
            } else r3 = 0;
            break;
          }
          N(A3, i3, r3);
        }
        N(A3, 3771, 6);
      }, function(A3, r3, a3) {
        r3 |= 0, a3 |= 0;
        var i3, f3, e3 = 0;
        q[4 + (A3 |= 0) >> 2] && F(A3, 10);
        A: if (r3 && (i3 = q[r3 + 4 >> 2])) {
          for (f3 = q[r3 >> 2]; ; ) {
            if ((0 | i3) == (0 | e3)) break A;
            if (!U(Y[e3 + f3 | 0])) break;
            e3 = e3 + 1 | 0;
          }
          N(A3, 1270, 3);
          r: {
            if (128 & Y[a3 + 16 | 0]) for (; ; ) {
              if (i3 = e3, (f3 = q[r3 + 4 >> 2]) >>> 0 <= e3 >>> 0) break r;
              for (; ; ) {
                if ((0 | i3) == (0 | f3)) i3 = f3;
                else if (10 != Y[q[r3 >> 2] + i3 | 0]) {
                  i3 = i3 + 1 | 0;
                  continue;
                }
                break;
              }
              if (e3 >>> 0 < i3 >>> 0 && (N(A3, q[r3 >> 2] + e3 | 0, i3 - e3 | 0), f3 = q[r3 + 4 >> 2]), f3 - 1 >>> 0 <= i3 >>> 0) break r;
              M0(A3, a3), e3 = i3 + 1 | 0;
            }
            N(A3, q[r3 >> 2] + e3 | 0, q[r3 + 4 >> 2] - e3 | 0);
          }
          N(A3, 3704, 5);
        }
      }, function(A3, r3, a3, i3) {
        r3 |= 0, a3 |= 0, q[4 + (A3 |= 0) >> 2] && F(A3, 10), N(A3, 3854, 15), r3 && N(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, 3654, 16), a3 && N(A3, q[a3 >> 2], q[a3 + 4 >> 2]), N(A3, 3829, 17);
      }, function(A3, r3, a3) {
        r3 |= 0, N(A3 |= 0, 3679, 5), r3 && N(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, 3685, 6);
      }, function(A3, r3, a3, i3, f3) {
        r3 |= 0, f3 |= 0, N(A3 |= 0, (i3 = 4 & (a3 |= 0)) ? 1149 : 1235, 3), 2 <= (0 | f3) && (N(A3, 3603, 10), r0(A3, f3), N(A3, 3651, 2));
        A: {
          switch ((3 & a3) - 1 | 0) {
            case 2:
              N(A3, 1434, 16);
              break A;
            case 0:
              N(A3, 1419, 14);
              break A;
            case 1:
              N(A3, 1403, 15);
              break A;
          }
          N(A3, 1449, 1);
        }
        r3 && N(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, i3 ? 3778 : 3847, 6);
      }, function(A3, r3, a3, i3) {
        A3 |= 0, a3 |= 0, i3 |= 0;
        var f3 = 0;
        if ((r3 |= 0) && (e3 = q[r3 + 4 >> 2]) && (!(32 & Y[i3 + 16 | 0]) || (e3 = b0(q[r3 >> 2], e3), 2 == (0 | a3)) || e3)) {
          N(A3, 3614, 9), 2 == (0 | a3) && N(A3, 3400, 7), S(A3, q[r3 >> 2], q[r3 + 4 >> 2]), q[i3 + 28 >> 2] ? (F(A3, 34), W[q[i3 + 28 >> 2]](A3, r3, i3), F(A3, 62)) : N(A3, 1448, 2), a3 = q[r3 + 4 >> 2];
          A: {
            r: {
              for (; ; ) {
                if ((0 | a3) == (0 | f3) | 7 == (0 | f3)) break r;
                i3 = f3 + 3400 | 0;
                var e3, n2 = (e3 = q[r3 >> 2]) + f3 | 0, f3 = f3 + 1 | 0;
                if (Y[0 | n2] != M[0 | i3]) break;
              }
              D(A3, e3, a3);
              break A;
            }
            D(A3, q[r3 >> 2] + 7 | 0, a3 - 7 | 0);
          }
          N(A3, 1363, 4), f3 = 1;
        }
        return 0 | f3;
      }, function(A3, r3, a3, i3, f3) {
        A3 |= 0, a3 |= 0, i3 |= 0, f3 |= 0;
        var e3 = 0;
        return !(r3 |= 0) | !q[r3 + 4 >> 2] || (N(A3, 3640, 10), S(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, 3566, 7), i3 && (r3 = q[i3 + 4 >> 2]) && D(A3, q[i3 >> 2], r3), !a3 | !q[a3 + 4 >> 2] || (N(A3, 3624, 9), D(A3, q[a3 >> 2], q[a3 + 4 >> 2])), m(A3, 256 & q[f3 + 16 >> 2] ? 1368 : 1448), e3 = 1), 0 | e3;
      }, M0, function(A3, r3, a3, i3, f3) {
        var e3;
        if (A3 |= 0, a3 |= 0, i3 |= 0, f3 |= 0, r3 |= 0) {
          if (32 & Y[f3 + 16 | 0] && !b0(q[r3 >> 2], q[r3 + 4 >> 2])) return 0;
          N(A3, 3614, 9), (e3 = q[r3 + 4 >> 2]) && S(A3, q[r3 >> 2], e3);
        } else N(A3, 3614, 9);
        return !a3 | !q[a3 + 4 >> 2] || (N(A3, 3624, 9), D(A3, q[a3 >> 2], q[a3 + 4 >> 2])), q[f3 + 28 >> 2] ? (F(A3, 34), W[q[f3 + 28 >> 2]](A3, r3, f3), F(A3, 62)) : N(A3, 1448, 2), i3 && (r3 = q[i3 + 4 >> 2]) && N(A3, q[i3 >> 2], r3), N(A3, 1363, 4), 1;
      }, function(A3, r3, a3) {
        A3 |= 0, r3 |= 0;
        var i3, f3, e3 = 0;
        A: {
          r: {
            var n2 = q[16 + (a3 |= 0) >> 2];
            if (1024 & n2 && (i3 = q[a3 + 20 >> 2])) {
              for (; ; ) {
                var o3 = q[i3 + (e3 << 2) >> 2];
                if (!o3) break r;
                if (e3 = e3 + 1 | 0, c3 = c0(q[r3 >> 2], q[r3 + 4 >> 2], o3)) break;
              }
              var b3 = q[a3 + 24 >> 2];
              if (F(A3, 60), 2 == (0 | c3)) F(A3, 47), m(A3, o3);
              else {
                m(A3, o3), a3 = 0;
                for (var w2 = k0(o3), k3 = s(16), c3 = s(16); ; ) {
                  n2 = 0;
                  a: {
                    i: {
                      f: for (; ; ) {
                        for (f3 = 1; ; ) {
                          if (!f3) break a;
                          if (C[r3 + 4 >> 2] <= (w2 = w2 + 1 | 0) >>> 0) break a;
                          o3 = n2, e3 = a3;
                          e: {
                            n: {
                              o: {
                                b: {
                                  w: {
                                    switch ((i3 = M[q[r3 >> 2] + w2 | 0]) - 32 | 0) {
                                      case 1:
                                        break n;
                                      case 0:
                                        break b;
                                      case 2:
                                        break w;
                                    }
                                    switch (i3 - 61 | (f3 = 0)) {
                                      case 1:
                                        continue;
                                      case 0:
                                        break o;
                                    }
                                    if (39 != (0 | i3)) break n;
                                  }
                                  if (!o3) break i;
                                  if (a3 = i3, f3 = n2 = 1, !e3) continue;
                                  if (((n2 = 0) | a3) == (0 | e3)) break e;
                                  F(c3, a3), n2 = 1, a3 = e3;
                                  continue f;
                                }
                                if (!e3) break i;
                                F(c3, 32);
                                continue f;
                              }
                              if (f3 = n2 = 1, o3) break i;
                              continue;
                            }
                            if (f3 = 1, o3 && (n2 = 1, !o3 | !(a3 = e3))) continue;
                            F(o3 ? c3 : k3, i3), a3 = e3, n2 = o3;
                            continue;
                          }
                          break;
                        }
                        break;
                      }
                      for (; ; ) {
                        if (!(o3 = q[(n2 << 2) + b3 >> 2])) break i;
                        f: {
                          if (((e3 = 0) | (a3 = k0(o3))) == q[k3 + 4 >> 2]) for (; ; ) {
                            if ((0 | a3) == (0 | e3)) break f;
                            if (i3 = e3 + o3 | 0, f3 = q[k3 >> 2] + e3 | 0, e3 = e3 + 1 | 0, (0 | y(M[0 | i3])) != (0 | y(Y[0 | f3]))) break;
                          }
                          n2 = n2 + 1 | 0;
                          continue;
                        }
                        break;
                      }
                      !q[c3 + 4 >> 2] | !a3 || (F(A3, 32), D(A3, q[k3 >> 2], q[k3 + 4 >> 2]), m(A3, 3648), D(A3, q[c3 >> 2], q[c3 + 4 >> 2]), F(A3, 34));
                    }
                    q0(k3), q0(c3), a3 = 0;
                    continue;
                  }
                  break;
                }
                G(k3), G(c3);
              }
              F(A3, 62);
              break A;
            }
          }
          512 & n2 ? D(A3, q[r3 >> 2], q[r3 + 4 >> 2]) : 1 & n2 || 2 & n2 && c0(q[r3 >> 2], q[r3 + 4 >> 2], 1223) || (a3 = q[r3 + 4 >> 2], r3 = q[r3 >> 2], 8 & n2 && c0(r3, a3, 1245)) || 4 & n2 && c0(r3, a3, 1184) || N(A3, r3, a3);
        }
        return 1;
      }, function(A3, r3, a3) {
        (r3 |= 0) && D(0 | A3, q[r3 >> 2], q[r3 + 4 >> 2]);
      }, function(A3, r3) {
        q[(r3 |= 0) >> 2] = 0, q[r3 + 4 >> 2] = 0, q[r3 + 8 >> 2] = 0;
      }]).set = function(A3, r3) {
        this[A3] = r3;
      }, A2.get = function(A3) {
        return this[A3];
      }, { c: function() {
        for (var A3, r3, a3 = 0; q[9028 + (A3 = a3 << 4) >> 2] = r3 = 9024 + A3 | 0, q[9032 + A3 >> 2] = r3, 64 != (0 | (a3 = a3 + 1 | 0)); ) ;
        z(48);
      }, d: function(A3) {
        return 0 | c2(0 | A3);
      }, e: function(A3, r3, a3, i3, f3, e3) {
        var n2;
        return A3 |= 0, r3 |= 0, a3 |= 0, i3 |= 0, f3 |= 0, e3 |= 0, Y[10064] || (M[10064] = 1, n2 = L(10072, 805, 0), q[2556] = n2, n2 = L(10256, 805, 1), q[2559] = 10256, q[2558] = 10072, q[2557] = n2), 0 | e0(A3, r3, a3, i3, f3, 0, e3);
      }, f: function(A3, r3, a3, i3, f3, e3) {
        var n2;
        return A3 |= 0, r3 |= 0, a3 |= 0, i3 |= 0, f3 |= 0, e3 |= 0, Y[10068] || (M[10068] = 1, n2 = L(10408, 1825, 0), q[2560] = n2, n2 = L(10560, 1825, 1), q[2563] = 10560, q[2562] = 10408, q[2561] = n2), 0 | e0(A3, r3, a3, i3, f3, 1, e3);
      }, i: Z, o: W = A2 };
      function d(A3, r3, a3, i3) {
        var f3, e3, n2 = 0;
        Q = e3 = Q - 32 | 0;
        A: {
          var o3 = r3 + 408 | 0, b3 = r3 + 420 | 0;
          if (!(C[r3 + 432 >> 2] < q[o3 >> 2] + q[b3 >> 2] >>> 0)) r: for (; ; ) {
            if (i3 >>> 0 <= n2 >>> 0) break A;
            var w2 = a3 + n2 | 0, k3 = i3 - n2 | 0;
            if (t0(r3, w2, k3)) {
              var c3 = 6 <= k3 >>> 0 ? 6 : k3;
              for (D2 = 0; ; ) {
                a: {
                  if ((0 | D2) != (0 | c3)) {
                    if (35 == Y[D2 + w2 | 0]) break a;
                    c3 = D2;
                  }
                  for (var t3 = k3 >>> 0 < c3 >>> 0 ? c3 : k3, D2 = c3; ; ) {
                    i: {
                      if ((0 | D2) != (0 | t3)) {
                        if (32 == Y[D2 + w2 | 0]) break i;
                        t3 = D2;
                      }
                      for (var u2 = k3 >>> 0 < t3 >>> 0 ? t3 : k3, D2 = t3; ; ) {
                        f: {
                          if ((0 | D2) != (0 | u2)) {
                            if (10 != Y[D2 + w2 | 0]) break f;
                            u2 = D2;
                          }
                          for (f3 = u2; ; ) {
                            if (D2 = f3) {
                              if (35 == Y[(f3 = D2 - 1 | 0) + w2 | 0]) continue;
                            } else D2 = 0;
                            break;
                          }
                          e: {
                            for (; ; ) {
                              if (!(f3 = D2)) break e;
                              if (32 != Y[w2 + (D2 = f3 - 1 | 0) | 0]) break;
                            }
                            f3 >>> 0 <= t3 >>> 0 || (O(D2 = E(r3, 1), r3, t3 + w2 | 0, f3 - t3 | 0), (t3 = q[r3 + 16 >> 2]) && W[0 | t3](A3, D2, c3, q[r3 + 112 >> 2]), --q[b3 >> 2]);
                          }
                          n2 = u2 + n2 | 0;
                          continue r;
                        }
                        D2 = D2 + 1 | 0;
                      }
                    }
                    D2 = D2 + 1 | 0;
                  }
                }
                D2 = D2 + 1 | 0;
              }
            }
            if (!q[r3 + 12 >> 2] | 60 != Y[0 | w2] || !(t3 = x(A3, r3, w2, k3, 1))) if (t3 = I(w2, k3)) n2 = t3 + n2 | 0;
            else {
              if (_(w2, k3)) for ((t3 = q[r3 + 20 >> 2]) && W[0 | t3](A3, q[r3 + 112 >> 2]), t3 = i3 >>> 0 < n2 >>> 0 ? n2 : i3; ; ) {
                a: {
                  if ((0 | t3) != (0 | n2)) {
                    if (10 != Y[a3 + n2 | 0]) break a;
                    t3 = n2;
                  }
                  n2 = t3 + 1 | 0;
                  continue r;
                }
                n2 = n2 + 1 | 0;
              }
              a: if (4 & Y[r3 + 428 | 0] && (q[24 + e3 >> 2] = 0, q[28 + e3 >> 2] = 0, q[16 + e3 >> 2] = 0, u2 = X(w2, k3, 16 + e3 | (q[20 + e3 >> 2] = 0)))) for (f3 = k3 - 1 | 0, c3 = E(r3, 0); ; ) {
                i: {
                  if (u2 >>> 0 < k3 >>> 0) {
                    if (q[8 + e3 >> 2] = 0, q[12 + e3 >> 2] = 0, q[e3 >> 2] = 0, !(D2 = X(B2 = w2 + (t3 = u2) | (q[4 + e3 >> 2] = 0), k3 - t3 | 0, e3)) | q[4 + e3 >> 2]) break i;
                    u2 = D2 + u2 | 0;
                  }
                  if (!(t3 = q[c3 + 4 >> 2]) | 10 == Y[(t3 + q[c3 >> 2] | 0) - 1 | 0] || F(c3, 10), (t3 = q[r3 >> 2]) && W[0 | t3](A3, c3, q[20 + e3 >> 2] ? 16 + e3 | 0 : 0, q[r3 + 112 >> 2]), --q[o3 >> 2], !u2) break a;
                  n2 = u2 + n2 | 0;
                  continue r;
                }
                for (; ; ) {
                  if ((0 | f3) == (0 | (D2 = t3))) D2 = f3, t3 = k3;
                  else if (t3 = D2 + 1 | 0, 10 != Y[D2 + w2 | 0]) continue;
                  break;
                }
                D2 >>> 0 < u2 >>> 0 || (I(B2, D2 = t3 - u2 | 0) ? F(c3, 10) : N(c3, B2, D2)), u2 = t3;
              }
              if (2 & Y[r3 + 428 | 0]) {
                var B2 = 0, g2 = E(r3, 1), s2 = E(r3, 0), t3 = D2 = 0;
                a: {
                  i: {
                    for (; ; ) {
                      if ((0 | t3) == (0 | k3)) break i;
                      if (10 == (0 | (f3 = Y[t3 + w2 | 0]))) break;
                      t3 = t3 + 1 | 0, D2 = (124 == (0 | f3)) + D2 | 0;
                    }
                    if (c3 = t3, D2) {
                      f: {
                        for (; ; ) {
                          if (u2 = 0, !(f3 = c3)) break f;
                          if (!(10 == (0 | (u2 = Y[(c3 = f3 - 1 | 0) + w2 | 0])) | 32 == (0 | u2))) break;
                        }
                        u2 = f3;
                      }
                      var G2 = u2, u2 = D2 - (124 == Y[0 | w2]) | 0;
                      if (f3 && (u2 = u2 - (124 == Y[(w2 + G2 | 0) - 1 | 0]) | 0), C[r3 + 436 >> 2] < (f3 = u2 + 1 | (D2 = 0)) >>> 0) break a;
                      for (B2 = l0(f3, 4), u2 = k3 >>> 0 < (D2 = (D2 = t3 + 1 | 0) >>> 0 < k3 >>> 0 && 124 == Y[D2 + w2 | 0] ? t3 + 2 | 0 : D2) >>> 0 ? D2 : k3, t3 = D2; ; ) {
                        f: {
                          if ((0 | t3) != (0 | u2)) {
                            if (10 != Y[t3 + w2 | 0]) break f;
                            u2 = t3;
                          }
                          for (var m2 = u2 + w2 | 0, v2 = 0; ; ) {
                            e: {
                              if (!(f3 >>> 0 <= v2 >>> 0 | u2 >>> 0 <= D2 >>> 0)) for (; ; ) {
                                if ((0 | D2) == (0 | u2)) {
                                  t3 = Y[0 | m2], D2 = u2;
                                  break e;
                                }
                                if (32 != (0 | (t3 = Y[D2 + w2 | 0]))) break e;
                                D2 = D2 + 1 | 0;
                              }
                              if (v2 >>> 0 < f3 >>> 0) break i;
                              if (V(g2, r3, w2, G2, f3, B2, 4), !(D2 = u2 + 1 | 0)) break i;
                              for (; ; ) {
                                n: if (!(k3 >>> (c3 = 0) <= (t3 = D2) >>> 0)) {
                                  for (; ; ) {
                                    if ((0 | t3) == (0 | k3)) break n;
                                    if (10 == (0 | (u2 = Y[t3 + w2 | 0]))) break;
                                    t3 = t3 + 1 | 0, c3 = (124 == (0 | u2)) + c3 | 0;
                                  }
                                  if (c3) {
                                    V(s2, r3, D2 + w2 | 0, t3 - D2 | 0, f3, B2, 0), D2 = t3 + 1 | 0;
                                    continue;
                                  }
                                }
                                break;
                              }
                              if (!(t3 = q[r3 + 36 >> 2])) break a;
                              W[0 | t3](A3, g2, s2, q[r3 + 112 >> 2]);
                              break a;
                            }
                            c3 = 0, 58 == (255 & t3) && (q[(t3 = (v2 << 2) + B2 | 0) >> 2] |= c3 = 1, D2 = D2 + 1 | 0);
                            var J2 = ((t3 = u2 >>> 0 < D2 >>> 0 ? D2 : u2) - D2 | 0) + c3 | 0;
                            e: {
                              for (; ; ) {
                                if ((0 | D2) == (0 | t3)) break e;
                                n: {
                                  var P2 = Y[D2 + w2 | 0];
                                  if (45 != (0 | P2)) {
                                    if (58 == (0 | P2)) break n;
                                    t3 = D2, J2 = c3;
                                    break e;
                                  }
                                  c3 = c3 + 1 | 0, D2 = D2 + 1 | 0;
                                  continue;
                                }
                                break;
                              }
                              q[(t3 = (v2 << 2) + B2 | 0) >> 2] |= 2, J2 = c3 + 1 | 0, t3 = D2 + 1 | 0;
                            }
                            D2 = u2 >>> 0 < t3 >>> 0 ? t3 : u2;
                            e: {
                              n: {
                                for (; ; ) {
                                  if ((0 | D2) == (0 | t3)) break n;
                                  if (32 != (0 | (c3 = Y[t3 + w2 | 0]))) break;
                                  t3 = t3 + 1 | 0;
                                }
                                if (124 != ((D2 = 0) | c3)) break a;
                                if (J2) break e;
                                break a;
                              }
                              if (t3 = D2, !J2) break i;
                            }
                            v2 = v2 + 1 | 0, D2 = t3 + 1 | 0;
                          }
                        }
                        t3 = t3 + 1 | 0;
                      }
                    }
                  }
                  D2 = 0;
                }
                if (Z(B2), --q[b3 >> 2], --q[o3 >> 2], D2) {
                  n2 = D2 + n2 | 0;
                  continue;
                }
              }
              a: {
                i: {
                  if (o0(w2, k3)) for (u2 = E(r3, t3 = 0), B2 = J2 = 0; ; ) {
                    if (f3 = D2 = t3, k3 >>> 0 <= D2 >>> 0) break a;
                    for (; ; ) {
                      if (c3 = k3 >>> 0 <= (t3 = D2 + 1 | 0) >>> 0) t3 = k3;
                      else if (G2 = D2 + w2 | 0, D2 = t3, 10 != Y[0 | G2]) continue;
                      break;
                    }
                    if (v2 = o0(D2 = f3 + w2 | 0, G2 = t3 - f3 | 0)) f3 = f3 + v2 | 0;
                    else if (I(D2, G2)) {
                      if (c3) break i;
                      if (!o0(D2 = t3 + w2 | 0, c3 = k3 - t3 | 0) && !I(D2, c3)) break i;
                    }
                    t3 >>> 0 <= f3 >>> 0 || (D2 = f3 + w2 | 0, B2 ? (0 | (c3 = B2 + J2 | 0)) != (0 | D2) && J0(c3, D2, t3 - f3 | 0) : B2 = D2, J2 = (t3 + J2 | 0) - f3 | 0);
                  }
                  f: {
                    e: {
                      if (f0(w2, k3)) for (u2 = E(r3, t3 = 0), B2 = J2 = 0; ; ) {
                        if (f3 = D2 = t3, k3 >>> 0 <= D2 >>> 0) break f;
                        for (; ; ) {
                          if (c3 = k3 >>> 0 <= (t3 = D2 + 1 | 0) >>> 0) t3 = k3;
                          else if (G2 = D2 + w2 | 0, D2 = t3, 10 != Y[0 | G2]) continue;
                          break;
                        }
                        if (v2 = f0(D2 = f3 + w2 | 0, G2 = t3 - f3 | 0)) f3 = f3 + v2 | 0;
                        else if (I(D2, G2)) {
                          if (c3) break e;
                          if (!f0(D2 = t3 + w2 | 0, c3 = k3 - t3 | 0) && !I(D2, c3)) break e;
                        }
                        t3 >>> 0 <= f3 >>> 0 || (D2 = f3 + w2 | 0, B2 ? (0 | (c3 = B2 + J2 | 0)) != (0 | D2) && J0(c3, D2, t3 - f3 | 0) : B2 = D2, J2 = (t3 + J2 | 0) - f3 | 0);
                      }
                      if (P0(w2, k3)) {
                        for (c3 = k3 - 1 | 0, B2 = E(r3, u2 = 0); ; ) {
                          n: if (!(k3 >>> 0 <= (t3 = u2) >>> 0)) {
                            for (; ; ) {
                              if ((0 | c3) == (0 | (D2 = t3))) D2 = c3, t3 = k3;
                              else if (t3 = D2 + 1 | 0, 10 != Y[D2 + w2 | 0]) continue;
                              break;
                            }
                            if (G2 = P0(f3 = u2 + w2 | 0, J2 = t3 - u2 | 0)) f3 = u2 + G2 | 0;
                            else {
                              if (!I(f3, J2)) break n;
                              f3 = u2;
                            }
                            if (u2 = t3, D2 >>> 0 < f3 >>> 0) continue;
                            I(t3 = f3 + w2 | 0, D2 = u2 - f3 | 0) ? F(B2, 10) : N(B2, t3, D2);
                            continue;
                          }
                          break;
                        }
                        for (w2 = q[B2 + 4 >> 2]; w2 && 10 == Y[(w2 = w2 - 1 | 0) + q[B2 >> 2] | 0]; ) q[B2 + 4 >> 2] = w2;
                        F(B2, 10), (t3 = q[r3 >> 2]) && W[0 | t3](A3, B2, 0, q[r3 + 112 >> 2]), --q[o3 >> 2], n2 = u2 + n2 | 0;
                        continue;
                      }
                      if (w0(w2, k3)) {
                        n2 = j(A3, r3, w2, k3, 0) + n2 | 0;
                        continue;
                      }
                      if (i0(w2, k3)) {
                        n2 = j(A3, r3, w2, k3, 1) + n2 | 0;
                        continue;
                      }
                      J2 = k3 - 1 | 0, c3 = B2 = 0;
                      n: {
                        for (; ; ) {
                          if (!(k3 >>> 0 <= (D2 = f3 = c3) >>> 0)) {
                            for (; ; ) {
                              if ((0 | D2) == (0 | J2)) c3 = k3;
                              else if (t3 = D2 + w2 | 0, D2 = c3 = D2 + 1 | 0, 10 != Y[0 | t3]) continue;
                              break;
                            }
                            if (!o0(D2 = f3 + w2 | 0, c3 - f3 | 0)) {
                              if (I(D2, u2 = k3 - f3 | 0)) break n;
                              if (t3 = K(D2, u2)) {
                                B2 = t3;
                                break n;
                              }
                              if (!t0(r3, D2, u2) && !_(D2, u2) && !o0(D2, u2)) {
                                if (!(256 & (v2 = q[r3 + 428 >> 2]))) continue;
                                if (H(t3 = Y[0 | D2])) continue;
                                if (!i0(D2, u2) && !w0(D2, u2)) o: {
                                  if (!(!q[r3 + 12 >> 2] | 60 != (0 | t3))) {
                                    if (x(A3, r3, D2, u2, 0)) break o;
                                    v2 = q[r3 + 428 >> 2];
                                  }
                                  if (!(4 & v2)) continue;
                                  if (!X(D2, u2, 0)) continue;
                                }
                              }
                            }
                          }
                          break;
                        }
                        c3 = f3;
                      }
                      n: {
                        o: {
                          b: {
                            w: {
                              k: {
                                for (; ; ) {
                                  if (!(D2 = f3)) break k;
                                  if (10 != Y[(f3 = D2 - 1 | 0) + w2 | 0]) break;
                                }
                                if (f3 = D2, B2) break b;
                                O(f3 = E(r3, 0), r3, w2, D2);
                                break w;
                              }
                              if (D2 = 0, B2) break o;
                              O(f3 = E(r3, 0), r3, w2, 0);
                            }
                            if (t3 = o3, !(D2 = q[r3 + 32 >> 2])) break n;
                            W[0 | D2](A3, f3, q[r3 + 112 >> 2]), t3 = o3;
                            break n;
                          }
                          for (; ; ) {
                            if (f3 = (u2 = f3) - 1 | 0) {
                              if (10 != Y[f3 + w2 | 0]) continue;
                            } else f3 = 0, u2 = 1;
                            break;
                          }
                          for (; ; ) {
                            if (!(t3 = f3)) break o;
                            if (10 != Y[(f3 = t3 - 1 | 0) + w2 | 0]) break;
                          }
                          O(f3 = E(r3, 0), r3, w2, t3), (t3 = q[r3 + 32 >> 2]) && W[0 | t3](A3, f3, q[r3 + 112 >> 2]), --q[o3 >> 2], D2 = D2 - u2 | 0, w2 = u2 + w2 | 0;
                        }
                        O(f3 = E(r3, 1), r3, w2, D2), t3 = b3, (D2 = q[r3 + 16 >> 2]) && (W[0 | D2](A3, f3, B2, q[r3 + 112 >> 2]), t3 = b3);
                      }
                      --q[t3 >> 2], n2 = c3 + n2 | 0;
                      continue;
                    }
                    D2 = t3;
                  }
                  f3 = D2, d(u2, r3, B2, J2), (t3 = q[r3 + 8 >> 2]) && W[0 | t3](A3, u2, q[r3 + 112 >> 2]), --q[o3 >> 2], n2 = f3 + n2 | 0;
                  continue;
                }
                D2 = t3;
              }
              f3 = D2, d(u2, r3, B2, J2), (t3 = q[r3 + 4 >> 2]) && W[0 | t3](A3, u2, q[r3 + 112 >> 2]), --q[o3 >> 2], n2 = f3 + n2 | 0;
            }
            else n2 = t3 + n2 | 0;
          }
        }
        Q = 32 + e3 | 0;
      }
      function v(A3, r3, a3, i3) {
        var f3, e3, n2, o3 = 0;
        A: if (f3 = s(64)) {
          B(f3, a3), q[i3 + 140 >> 2] = 0, q[i3 + 144 >> 2] = 0, q[i3 + 132 >> 2] = 0, q[i3 + 136 >> 2] = 0, q[i3 + 124 >> 2] = 0, q[i3 + 128 >> 2] = 0, q[i3 + 116 >> 2] = 0, 3 <= a3 >>> (q[i3 + 120 >> 2] = 0) && (o3 = v0(r3, 4172, 3) ? 0 : 3);
          var b3 = i3 + 116 | 0;
          r: for (; ; ) {
            a: {
              i: {
                f: {
                  if (o3 >>> 0 < a3 >>> 0) {
                    var w2 = o3 + 3 | 0;
                    if (a3 >>> 0 <= w2 >>> 0) break a;
                    var k3 = 0, c3 = r3 + o3 | 0;
                    if (32 == Y[0 | c3] && 32 == Y[c3 + (k3 = 1) | 0] && 32 == Y[c3 + (k3 = 2) | 0] && (k3 = 3, 32 == Y[r3 + w2 | 0])) break a;
                    if (91 != Y[(c3 = o3 + k3 | 0) + r3 | 0]) break a;
                    for (k3 = n2 = c3 + 1 | 0; ; ) {
                      if (a3 >>> 0 <= k3 >>> 0) break a;
                      e: {
                        n: {
                          switch ((c3 = Y[r3 + k3 | 0]) - 10 | 0) {
                            case 1:
                            case 2:
                              break n;
                            case 0:
                            case 3:
                              break a;
                          }
                          if (93 == (0 | c3)) break e;
                        }
                        k3 = k3 + 1 | 0;
                        continue;
                      }
                      break;
                    }
                    if (a3 >>> 0 <= (c3 = k3 + 1 | 0) >>> 0 | 58 != Y[r3 + c3 | 0]) break a;
                    for (c3 = k3 + 2 | 0; ; ) {
                      if (a3 >>> 0 <= c3 >>> 0) {
                        c3 = a3;
                        break i;
                      }
                      e: {
                        var t3 = Y[r3 + c3 | 0];
                        if (32 != (0 | t3)) switch (t3 - 10 | 0) {
                          case 0:
                          case 3:
                            break e;
                          default:
                            break i;
                        }
                        c3 = c3 + 1 | 0;
                        continue;
                      }
                      break;
                    }
                    if (a3 >>> 0 <= (w2 = c3 + 1 | 0) >>> 0 | 13 != Y[r3 + w2 | 0]) break f;
                    c3 = 10 == (0 | t3) ? c3 + 2 | 0 : w2;
                    break i;
                  }
                  if (B(A3, (o3 = q[f3 + 4 >> 2]) + (o3 >>> 1 | 0) | 0), (r3 = q[i3 + 104 >> 2]) && W[0 | r3](A3, q[i3 + 112 >> 2]), o3) {
                    e: {
                      switch (Y[((k3 = q[f3 >> 2]) + o3 | 0) - 1 | 0] - 10 | 0) {
                        case 0:
                        case 3:
                          break e;
                      }
                      F(f3, 10), o3 = q[f3 + 4 >> 2], k3 = q[f3 >> 2];
                    }
                    d(A3, i3, k3, o3);
                  }
                  for ((r3 = q[i3 + 108 >> 2]) && W[0 | r3](A3, q[i3 + 112 >> 2]), G(f3), r3 = 0; ; ) {
                    if (8 == (0 | r3)) break A;
                    for (o3 = q[(r3 << 2) + b3 >> 2]; o3; ) A3 = q[o3 + 12 >> 2], G(q[o3 + 4 >> 2]), G(q[o3 + 8 >> 2]), Z(o3), o3 = A3;
                    r3 = r3 + 1 | 0;
                  }
                }
                c3 = w2;
              }
              for (w2 = a3 >>> 0 < c3 >>> 0 ? c3 : a3; ; ) {
                if ((0 | c3) == (0 | w2)) break a;
                if (32 != (0 | (t3 = Y[r3 + c3 | 0]))) break;
                c3 = c3 + 1 | 0;
              }
              for (c3 = e3 = (60 == (0 | t3)) + c3 | 0; ; ) {
                i: if (!(a3 >>> 0 <= c3 >>> 0)) {
                  f: {
                    switch ((w2 = Y[r3 + c3 | 0]) - 10 | 0) {
                      case 0:
                      case 3:
                        break i;
                      case 1:
                      case 2:
                        break f;
                    }
                    if (32 == (0 | w2)) break i;
                  }
                  c3 = c3 + 1 | 0;
                  continue;
                }
                break;
              }
              var D2 = 62 == Y[r3 + (w2 = c3 - 1 | 0) | 0] ? w2 : c3;
              i: {
                for (; ; ) {
                  f: if (!(a3 >>> 0 <= c3 >>> 0)) {
                    e: {
                      switch ((t3 = Y[r3 + c3 | (w2 = 0)]) - 32 | 0) {
                        case 2:
                        case 7:
                        case 8:
                          break i;
                        case 0:
                          break e;
                        case 1:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                          break a;
                      }
                      switch (t3 - 10 | 0) {
                        case 0:
                        case 3:
                          break f;
                        default:
                          break a;
                      }
                    }
                    c3 = c3 + 1 | 0;
                    continue;
                  }
                  break;
                }
                w2 = c3;
              }
              var u2 = c3 + 1 | 0;
              if (w2 = 10 != Y[r3 + c3 | 0] | a3 >>> 0 <= u2 >>> 0 || 13 != Y[r3 + u2 | 0] ? w2 : u2) {
                for (t3 = (c3 = w2 + 1 | 0) >>> 0 < a3 >>> 0 ? a3 : c3, c3 = w2; ; ) {
                  if (a3 >>> 0 <= (c3 = c3 + 1 | 0) >>> 0) c3 = t3;
                  else if (32 == Y[r3 + c3 | 0]) continue;
                  break;
                }
                u2 = c3 + 1 | 0;
              }
              i: {
                if (a3 >>> (t3 = 0) <= u2 >>> 0 || 6 < (c3 = Y[r3 + c3 | 0] - 34 | 0) >>> 0 | !(1 << c3 & 97)) u2 = 0;
                else {
                  for (c3 = u2 >>> 0 < a3 >>> 0 ? a3 : u2, t3 = u2; ; ) {
                    f: {
                      if ((0 | c3) != (0 | t3)) {
                        switch (Y[r3 + t3 | 0] - 10 | 0) {
                          case 0:
                          case 3:
                            break f;
                        }
                        t3 = t3 + 1 | 0;
                        continue;
                      }
                      t3 = c3;
                    }
                    break;
                  }
                  for (!(10 != Y[r3 + t3 | 0] | a3 >>> 0 <= (c3 = t3 + 1 | 0) >>> 0) & 13 == Y[r3 + c3 | 0] || (c3 = t3); ; ) {
                    if (!((t3 = t3 - 1 | 0) >>> 0 <= u2 >>> 0)) switch (Y[r3 + t3 | 0] - 32 | 0) {
                      case 2:
                      case 7:
                      case 9:
                        break i;
                      case 0:
                        continue;
                    }
                    break;
                  }
                  t3 = c3;
                }
                c3 = w2;
              }
              if (!(!c3 | (0 | e3) == (0 | D2)) && (w2 = l0(1, 16))) {
                if (o3 = C0(r3 + n2 | 0, k3 - n2 | 0), q[w2 >> 2] = o3, q[w2 + 12 >> 2] = q[(o3 = ((7 & o3) << 2) + b3 | 0) >> 2], q[o3 >> 2] = w2, k3 = s(o3 = D2 - e3 | 0), q[w2 + 4 >> 2] = k3, N(k3, r3 + e3 | 0, o3), o3 = c3, t3 >>> 0 <= u2 >>> 0) continue;
                k3 = w2, w2 = s(c3 = t3 - u2 | 0), q[k3 + 8 >> 2] = w2, N(w2, r3 + u2 | 0, c3);
                continue;
              }
            }
            for (c3 = a3 >>> 0 < o3 >>> 0 ? o3 : a3, w2 = o3; ; ) {
              a: {
                if ((0 | c3) != (0 | w2)) {
                  switch (Y[r3 + w2 | 0] - 10 | 0) {
                    case 0:
                    case 3:
                      break a;
                  }
                  w2 = w2 + 1 | 0;
                  continue;
                }
                w2 = c3;
              }
              break;
            }
            a: if (!(w2 >>> 0 <= o3 >>> 0)) for (c3 = w2 - o3 | 0, e3 = r3 + o3 | 0, t3 = o3 = 0; ; ) {
              if (c3 >>> 0 <= t3 >>> 0) break a;
              for (u2 = (c3 + o3 | 0) - t3 | 0, k3 = t3; ; ) {
                if ((0 | o3) == (0 | u2)) k3 = c3, o3 = u2;
                else if (9 != Y[k3 + e3 | 0]) {
                  o3 = o3 + 1 | 0, k3 = k3 + 1 | 0;
                  continue;
                }
                break;
              }
              if (t3 >>> 0 < k3 >>> 0 && N(f3, t3 + e3 | 0, k3 - t3 | 0), c3 >>> 0 <= k3 >>> 0) break a;
              for (; F(f3, 32), 3 & (o3 = o3 + 1 | 0); ) ;
              t3 = k3 + 1 | 0;
            }
            for (c3 = a3 >>> 0 < w2 >>> 0 ? w2 : a3, o3 = w2; ; ) {
              if ((0 | c3) == (0 | o3)) {
                o3 = c3;
                continue r;
              }
              a: {
                switch (Y[r3 + o3 | 0] - 10 | 0) {
                  case 0:
                    o3 = o3 + 1 | 0;
                    break a;
                  case 3:
                    break;
                  default:
                    continue r;
                }
                if (a3 >>> 0 <= (o3 = o3 + 1 | 0) >>> 0 | 10 == Y[r3 + o3 | 0]) continue;
              }
              F(f3, 10);
            }
          }
        }
      }
      function c2(A3) {
        var r3 = 0, a3 = 8;
        A: {
          r: if (!(4294967239 < A3 >>> 0)) for (; ; ) {
            var i3, f3, e3, a3 = a3 >>> 0 <= 8 ? 8 : a3, n2 = r3 = q[2515], o3 = q[2514], b3 = ((A3 = A3 >>> 0 <= 8 ? 8 : A3 + 3 & -4) >>> 0 <= 127 ? i3 = (A3 >>> 3 | 0) - 1 | 0 : (i3 = 110 + ((A3 >>> 29 - (f3 = t2(A3)) ^ 4) - (f3 << 2) | 0) | 0, A3 >>> 0 <= 4095 || (i3 = 63 <= (f3 = 71 + ((A3 >>> 30 - f3 ^ 2) - (f3 << 1) | 0) | 0) >>> 0 ? 63 : f3)), 31 & i3);
            if ((r3 = 32 <= (63 & i3) >>> 0 ? r3 >>> b3 | (f3 = 0) : (f3 = r3 >>> b3 | 0, ((1 << b3) - 1 & r3) << 32 - b3 | o3 >>> b3)) | f3) {
              for (; ; ) {
                if ((o3 = f3) | r3 ? (f3 = o3 - 1 | 0, f3 = 63 - (b3 = 32 == (0 | (f3 = t2((f3 = -1 != (0 | (b3 = r3 - 1 | 0)) ? f3 + 1 | 0 : f3) ^ o3))) ? t2(b3 ^ r3) + 32 | 0 : f3) | 0, h = 0 - (63 < b3 >>> 0) | 0) : (h = 0, f3 = 64), n2 = 31 & (b3 = f3), e3 = 32 <= (63 & b3) >>> 0 ? o3 >>> n2 | (f3 = 0) : (f3 = o3 >>> n2 | 0, ((1 << n2) - 1 & o3) << 32 - n2 | r3 >>> n2), (0 | (n2 = q[9032 + (b3 = (i3 = b3 + i3 | 0) << 4) >> 2])) != (0 | (o3 = b3 + 9024 | 0))) {
                  if (r3 = p(n2, a3, A3)) break r;
                  q[(r3 = q[n2 + 4 >> 2]) + 8 >> 2] = q[n2 + 8 >> 2], q[q[n2 + 8 >> 2] + 4 >> 2] = r3, q[n2 + 8 >> 2] = o3, q[n2 + 4 >> 2] = q[(r3 = b3 + 9028 | 0) >> 2], q[r3 >> 2] = n2, q[q[n2 + 4 >> 2] + 8 >> 2] = n2, i3 = i3 + 1 | 0, r3 = (1 & f3) << 31 | e3 >>> 1, f3 = f3 >>> 1 | 0;
                } else {
                  var w2 = q[2515], n2 = 31 & (r3 = 63 & (o3 = i3)), k3 = (n2 = 32 <= r3 >>> 0 ? -1 >>> n2 | (b3 = 0) : (b3 = -1 >>> n2 | 0) | (1 << n2) - 1 << 32 - n2, n2 &= -2, 31 & r3), c3 = (32 <= r3 >>> 0 ? (b3 = n2 << k3, n2 = 0) : (b3 = (1 << k3) - 1 & n2 >>> 32 - k3 | b3 << k3, n2 <<= k3), r3 = b3, b3 = 31 & (o3 = k3 = 0 - o3 & 63), 32 <= o3 >>> 0 ? (b3 = -1 << b3, o3 = 0) : b3 = (o3 = -1 << b3) | (1 << b3) - 1 & -1 >>> 32 - b3, o3 &= -2, 31 & k3), o3 = 32 <= k3 >>> 0 ? b3 >>> c3 | (k3 = 0) : (k3 = b3 >>> c3 | 0, ((1 << c3) - 1 & b3) << 32 - c3 | o3 >>> c3);
                  h = r3 | k3, q[2514] &= o3 |= n2, q[2515] = h & w2, r3 = 1 ^ e3;
                }
                if (!(f3 | r3)) break;
              }
              n2 = q[2515], o3 = q[2514];
            }
            a: {
              if (n2 | o3) {
                b3 = 63 - (32 == (0 | (r3 = t2(n2))) ? t2(o3) + 32 | 0 : r3) | 0, f3 = q[9032 + (r3 = b3 << 4) >> 2];
                i: if (!(!n2 & o3 >>> 0 < 1073741824) && (i3 = 99, (0 | (o3 = r3 + 9024 | 0)) != (0 | f3))) {
                  for (; ; ) {
                    if (!i3) break i;
                    if (r3 = p(f3, a3, A3)) break r;
                    if (i3 = i3 - 1 | 0, (0 | o3) == (0 | (f3 = q[f3 + 8 >> 2]))) break;
                  }
                  f3 = o3;
                }
                if (z(A3 + 48 | 0)) break a;
                if (!f3) break A;
                if ((0 | (o3 = 9024 + (b3 << 4) | 0)) == (0 | f3)) break A;
                for (; ; ) {
                  if (r3 = p(f3, a3, A3)) break r;
                  if ((0 | o3) == (0 | (f3 = q[f3 + 8 >> 2]))) break;
                }
                break A;
              }
              if (!z(A3 + 48 | 0)) break A;
            }
            if (r3 = 0, a3 - 1 & a3) break r;
            if (!(A3 >>> 0 <= 4294967239)) break;
          }
          return r3;
        }
        return 0;
      }
      function j(A3, r3, a3, i3, f3) {
        for (var e3, n2, o3, b3 = 0, w2 = E(r3, 0); ; ) {
          A: if (!(i3 >>> 0 <= b3 >>> 0)) {
            var k3 = i3 - b3 | 0, c3 = 3 <= k3 >>> 0 ? 3 : k3, t3 = a3 + b3 | 0, D2 = 0;
            r: {
              for (; ; ) {
                a: {
                  i: {
                    if ((0 | D2) != (0 | c3)) {
                      if (32 == Y[D2 + t3 | 0]) break i;
                      c3 = D2;
                    }
                    var u2 = w0(t3, k3);
                    if (!u2 && !(u2 = i0(t3, k3))) break A;
                    var B2 = k3 >>> 0 < u2 >>> 0 ? u2 : k3;
                    for (D2 = u2; ; ) {
                      f: {
                        if ((0 | D2) != (0 | B2)) {
                          if (10 != Y[(D2 + t3 | 0) - 1 | 0]) break f;
                          B2 = D2;
                        }
                        var g2, s2, G2 = E(r3, 1), m2 = E(r3, 1), v2 = (N(G2, u2 + t3 | 0, B2 - u2 | 0), 1 & f3), J2 = o3 = e3 = 0;
                        e: for (; ; ) {
                          for (D2 = 0; ; ) {
                            var P2 = D2;
                            if (k3 >>> 0 <= (D2 = n2 = B2) >>> 0) break r;
                            for (; ; ) {
                              if (k3 >>> 0 <= (B2 = D2 + 1 | 0) >>> 0) B2 = k3;
                              else if (u2 = D2 + t3 | 0, D2 = B2, 10 != Y[0 | u2]) continue;
                              break;
                            }
                            var D2 = 1, C2 = t3 + n2 | 0, Z2 = B2 - n2 | 0;
                            if (!I(C2, Z2)) break;
                          }
                          for (g2 = Z2 >>> (D2 = 0) <= B2 >>> 0 ? Z2 : 0; ; ) {
                            n: {
                              if ((u2 = 4) != (0 | D2) && (0 | (u2 = g2)) != (0 | D2)) {
                                if (32 == Y[(D2 + n2 | 0) + t3 | 0]) break n;
                                u2 = D2;
                              }
                              if (g2 = D2 = 0, (J2 = 4 & Y[r3 + 428 | 0] && X(u2 + C2 | 0, Z2 - u2 | 0, 0) ? !J2 : J2) || (D2 = w0(g2 = u2 + C2 | 0, s2 = Z2 - u2 | 0), g2 = i0(g2, s2)), (s2 = 1 & P2) & (0 != (0 | D2) & v2 | !v2 & 0 != (0 | g2))) break a;
                              if (D2 && !_(u2 + C2 | 0, Z2 - u2 | 0) || g2) {
                                if (o3 = s2 ? 1 : o3, (0 | u2) == (0 | c3)) break r;
                                e3 = e3 || q[G2 + 4 >> 2];
                              } else {
                                if (!u2 & P2) break a;
                                s2 && (F(G2, 10), o3 = 1);
                              }
                              N(G2, u2 + C2 | 0, Z2 - u2 | 0);
                              continue e;
                            }
                            D2 = D2 + 1 | 0;
                          }
                        }
                      }
                      D2 = D2 + 1 | 0;
                    }
                  }
                  D2 = D2 + 1 | 0;
                  continue;
                }
                break;
              }
              f3 |= 8;
            }
            if (u2 = 0 != (0 | e3) & e3 >>> 0 < (B2 = q[G2 + 4 >> 2]) >>> 0, D2 = q[G2 >> 2], 2 & (f3 = o3 ? 2 | f3 : f3) ? u2 ? (d(m2, r3, D2, e3), d(m2, r3, q[G2 >> 2] + e3 | 0, q[G2 + 4 >> 2] - e3 | 0)) : d(m2, r3, D2, B2) : u2 ? (O(m2, r3, D2, e3), d(m2, r3, q[G2 >> 2] + e3 | 0, q[G2 + 4 >> 2] - e3 | 0)) : O(m2, r3, D2, B2), (D2 = q[r3 + 28 >> 2]) && W[0 | D2](w2, m2, f3, q[r3 + 112 >> 2]), q[r3 + 420 >> 2] -= 2, b3 = b3 + n2 | 0, n2 && !(8 & f3)) continue;
          }
          break;
        }
        return (a3 = q[r3 + 24 >> 2]) && W[0 | a3](A3, w2, f3, q[r3 + 112 >> 2]), --q[r3 + 408 >> 2], b3;
      }
      function J(A3, r3) {
        var a3, i3 = 0;
        A: if (A3) if (r3) {
          if (!(4294967239 < r3 >>> 0)) {
            var f3 = r3 >>> 0 <= 8 ? 8 : r3 + 3 & -4;
            r3 = 8 + f3 | 0;
            r: {
              a: {
                var e3 = a3 = A3 - 4 | 0, n2 = q[e3 >> 2], o3 = n2 + e3 | 0, b3 = q[o3 >> 2], w2 = b3 + o3 | 0;
                i: {
                  f: {
                    if (q[w2 - 4 >> 2] != (0 | b3)) {
                      var k3 = r3 + e3 | 0;
                      if (k3 + 16 >>> 0 <= w2 >>> 0) {
                        q[(n2 = q[o3 + 4 >> 2]) + 8 >> 2] = q[o3 + 8 >> 2], q[q[o3 + 8 >> 2] + 4 >> 2] = n2, q[k3 >> 2] = o3 = w2 - k3 | 0, q[(k3 + (-4 & o3) | 0) - 4 >> 2] = 1 | o3, (n2 = q[k3 >> 2] - 8 | 0) >>> 0 <= 127 ? o3 = (n2 >>> 3 | 0) - 1 | 0 : (o3 = 110 + ((n2 >>> 29 - (w2 = t2(n2)) ^ 4) - (w2 << 2) | 0) | 0, n2 >>> 0 <= 4095 || (o3 = 63 <= (o3 = 71 + ((n2 >>> 30 - w2 ^ 2) - (w2 << 1) | 0) | 0) >>> 0 ? 63 : o3)), q[k3 + 4 >> 2] = 9024 + (n2 = o3 << 4), q[k3 + 8 >> 2] = q[(n2 = n2 + 9032 | 0) >> 2], q[n2 >> 2] = k3, q[q[k3 + 8 >> 2] + 4 >> 2] = k3, n2 = q[2515], k3 = 31 & o3, 32 <= (63 & o3) >>> 0 ? (o3 = 1 << k3, w2 = 0) : o3 = (w2 = 1 << k3) - 1 & 1 >>> 32 - k3, q[2514] |= w2, q[2515] = o3 | n2, q[e3 >> 2] = r3;
                        break a;
                      }
                      if (w2 >>> 0 < k3 >>> 0) break f;
                      q[(r3 = q[o3 + 4 >> 2]) + 8 >> 2] = q[o3 + 8 >> 2], q[q[o3 + 8 >> 2] + 4 >> 2] = r3, q[e3 >> 2] = r3 = n2 + b3 | 0;
                      break a;
                    }
                    if (r3 + 16 >>> 0 <= n2 >>> 0) {
                      q[e3 >> 2] = r3, q[(e3 + (-4 & r3) | 0) - 4 >> 2] = r3, q[(k3 = r3 + e3 | 0) >> 2] = r3 = n2 - r3 | 0, q[(k3 + (-4 & r3) | 0) - 4 >> 2] = 1 | r3, (o3 = q[k3 >> 2] - 8 | 0) >>> 0 <= 127 ? r3 = (o3 >>> 3 | 0) - 1 | 0 : (r3 = 110 + ((o3 >>> 29 - (e3 = t2(o3)) ^ 4) - (e3 << 2) | 0) | 0, o3 >>> 0 <= 4095 || (r3 = 63 <= (r3 = 71 + ((o3 >>> 30 - e3 ^ 2) - (e3 << 1) | 0) | 0) >>> 0 ? 63 : r3)), q[k3 + 4 >> 2] = 9024 + (o3 = r3 << 4), q[k3 + 8 >> 2] = q[(o3 = o3 + 9032 | 0) >> 2], q[o3 >> 2] = k3, q[q[k3 + 8 >> 2] + 4 >> 2] = k3, o3 = q[2515], k3 = 31 & r3, 32 <= (63 & r3) >>> 0 ? (r3 = 1 << k3, n2 = 0) : r3 = (n2 = 1 << k3) - 1 & 1 >>> 32 - k3, q[2514] |= n2, q[2515] = r3 | o3, k3 = 1;
                      break r;
                    }
                    if (k3 = 1, r3 >>> 0 <= n2 >>> 0) break i;
                  }
                  k3 = 0;
                }
                break r;
              }
              q[(e3 + (-4 & r3) | 0) - 4 >> 2] = r3, k3 = 1;
            }
            if (k3) break A;
            (r3 = c2(f3)) && (u(r3, A3, f3 >>> 0 < (i3 = q[a3 >> 2] - 8 | 0) >>> 0 ? f3 : i3), Z(A3), i3 = r3);
          }
          A3 = i3;
        } else Z(A3), A3 = 0;
        else A3 = c2(r3);
        return A3;
      }
      function x(A3, r3, a3, i3, f3) {
        var e3, n2 = 0;
        Q = e3 = Q - 16 | 0, q[8 + e3 >> 2] = 0;
        A: if (!(60 != Y[(q[12 + e3 >> 2] = 0) | (q[e3 >> 2] = a3)] | i3 >>> 0 < 2)) {
          var o3 = 1;
          r: {
            a: {
              i: {
                f: {
                  e: {
                    for (; ; ) {
                      if ((0 | i3) == (0 | o3)) break e;
                      var b3 = Y[a3 + o3 | 0];
                      if (32 == (0 | b3) | 62 == (0 | b3)) break;
                      o3 = o3 + 1 | 0;
                    }
                    if (!(9 < o3 - 2 >>> 0)) {
                      var w2 = a3 + 1 | 0, k3 = (1 != (0 | (o3 = o3 - 1 | 0)) ? o3 + Y[Y[a3 + 2 | 0] + 4177 | 0] | 0 : 1) + Y[(b3 = Y[0 | w2]) + 4176 | 0] | 0;
                      if (!(37 < k3 >>> 0 || 223 & (b3 ^ Y[0 | (b3 = q[4016 + (k3 << 2) >> 2])]) || g(w2, b3, o3) || Y[o3 + b3 | 0])) break f;
                    }
                  }
                  if (i3 >>> 0 < 6) break a;
                  if (33 != (0 | (o3 = Y[a3 + 1 | 0]))) break r;
                  if (45 != Y[a3 + 2 | 0] | 45 != Y[a3 + 3 | 0]) break A;
                  for (o3 = 5; ; ) {
                    if ((0 | i3) == (0 | o3)) {
                      o3 = i3;
                      break i;
                    }
                    if (!(45 != Y[(b3 = a3 + o3 | 0) - 2 | 0] | 45 != Y[b3 - 1 | 0]) & 62 == Y[0 | b3]) break i;
                    o3 = o3 + 1 | 0;
                  }
                }
                if (!(o3 = T(b3, a3, i3, 1))) {
                  if (!s0(b3, 1082)) break A;
                  if (!s0(b3, 1137)) break A;
                  if (!(o3 = T(b3, a3, i3, 0))) break A;
                }
                q[4 + e3 >> 2] = o3, f3 && (a3 = q[r3 + 12 >> 2]) && W[0 | a3](A3, e3, q[r3 + 112 >> 2]), n2 = o3;
                break A;
              }
              if (!(i3 >>> 0 <= (o3 = o3 + 1 | 0) >>> 0) && (b3 = I(a3 + o3 | 0, i3 - o3 | 0))) {
                if (q[4 + e3 >> 2] = n2 = o3 + b3 | 0, !f3) break A;
                if (!(a3 = q[r3 + 12 >> 2])) break A;
                W[0 | a3](A3, e3, q[r3 + 112 >> 2]), n2 = q[4 + e3 >> 2];
                break A;
              }
            }
            if (i3 >>> 0 < 5) break A;
            o3 = Y[a3 + 1 | 0];
          }
          if (!(104 != (255 & (32 | o3)) | 114 != (32 | Y[a3 + 2 | 0]))) {
            for (o3 = 3; ; ) {
              if ((0 | i3) == (0 | o3)) o3 = i3;
              else if (62 != Y[a3 + o3 | 0]) {
                o3 = o3 + 1 | 0;
                continue;
              }
              break;
            }
            !(i3 >>> 0 <= (o3 = o3 + 1 | 0) >>> 0) && (a3 = I(a3 + o3 | 0, i3 - o3 | 0)) && (q[4 + e3 >> 2] = n2 = a3 + o3 | 0, f3) && (a3 = q[r3 + 12 >> 2]) && (W[0 | a3](A3, e3, q[r3 + 112 >> 2]), n2 = q[4 + e3 >> 2]);
          }
        }
        return Q = 16 + e3 | 0, n2;
      }
      function X(A3, r3, a3) {
        var i3 = 0, f3 = 0;
        A: if (!(r3 >>> 0 < 3)) {
          var e3 = 0;
          if (!(r3 >>> 0 <= (e3 = 32 == Y[0 | A3] && 32 == Y[A3 + (e3 = 1) | 0] ? 32 == Y[A3 + 2 | 0] ? 3 : 2 : e3) + 2 >>> 0)) {
            var n2 = Y[A3 + e3 | 0];
            if (!(126 != (0 | n2) & 96 != (0 | n2))) {
              var o3 = r3 >>> 0 < e3 >>> 0 ? e3 : r3, b3 = o3 - e3 | 0;
              r: {
                a: {
                  i: {
                    for (; ; ) {
                      f: {
                        e: {
                          if ((0 | i3) != (0 | b3)) {
                            if ((0 | n2) == Y[A3 + e3 | 0]) break e;
                            b3 = i3, o3 = e3;
                          }
                          if (!o3 | b3 >>> 0 < 3) break A;
                          e3 = r3 >>> 0 < o3 >>> 0 ? o3 : r3, i3 = 0;
                          n: {
                            o: {
                              for (; ; ) {
                                if ((0 | e3) == (0 | o3)) break o;
                                b: {
                                  if (32 != (0 | (f3 = Y[0 | (b3 = A3 + o3 | 0)]))) {
                                    if (123 == (0 | f3)) break b;
                                    e3 = o3;
                                    break n;
                                  }
                                  o3 = o3 + 1 | 0;
                                  continue;
                                }
                                break;
                              }
                              for (; !(r3 >>> 0 <= (e3 = o3 + 1 | 0) >>> 0 || 10 == (0 | (f3 = Y[A3 + e3 | 0])) | 125 == (0 | f3)); ) i3 = i3 + 1 | 0, o3 = e3;
                              if (((f3 = 0) | r3) == (0 | e3) | 125 != Y[A3 + e3 | 0]) break A;
                              for (; ; ) {
                                if (e3 = b3 + 1 | 0, !i3) {
                                  i3 = 0;
                                  break a;
                                }
                                if (32 != (0 | (n2 = Y[0 | e3])) & 10 != (0 | n2)) break a;
                                i3 = i3 - 1 | 0, b3 = e3;
                              }
                            }
                            b3 = A3 + e3 | 0;
                          }
                          for (f3 = (i3 = r3 >>> 0 < e3 >>> 0 ? e3 : r3) - e3 | 0, o3 = 0; ; ) {
                            if ((0 | o3) == (0 | f3)) break i;
                            if (10 == (0 | (n2 = Y[A3 + e3 | 0])) | 32 == (0 | n2)) break f;
                            e3 = e3 + 1 | 0, o3 = o3 + 1 | 0;
                          }
                        }
                        e3 = e3 + 1 | 0, i3 = i3 + 1 | 0;
                        continue;
                      }
                      break;
                    }
                    i3 = e3, f3 = o3;
                  }
                  e3 = b3;
                  break r;
                }
                for (; ; ) {
                  a: {
                    if (i3) {
                      if (32 == (0 | (n2 = Y[i3 + b3 | 0])) | 10 == (0 | n2)) break a;
                      f3 = i3;
                    }
                    i3 = o3 + 2 | 0;
                    break r;
                  }
                  i3 = i3 - 1 | 0;
                }
              }
              for (a3 && (q[a3 + 4 >> 2] = f3, q[a3 >> 2] = e3), r3 = r3 >>> 0 < i3 >>> 0 ? i3 : r3, f3 = 0; ; ) {
                r: {
                  if ((0 | r3) == (0 | i3)) i3 = r3;
                  else {
                    if (32 == (0 | (a3 = Y[A3 + i3 | 0]))) break r;
                    if (10 != (0 | a3)) break A;
                  }
                  f3 = i3 + 1 | 0;
                  break A;
                }
                i3 = i3 + 1 | 0;
              }
            }
          }
        }
        return f3;
      }
      function P(A3, r3, a3) {
        var i3, f3 = 60 != (0 | a3), e3 = 1;
        A: {
          r: {
            a: for (; ; ) {
              if (r3 >>> 0 <= e3 >>> 0) break A;
              for (; ; ) {
                if ((0 | r3) == (0 | e3)) break A;
                var n2 = A3 + e3 | 0, o3 = Y[0 | n2];
                if ((0 | o3) == (0 | a3) | 91 == (0 | o3) | 96 == (0 | o3)) break;
                e3 = e3 + 1 | 0;
              }
              if (!(r3 >>> 0 <= e3 >>> 0 | f3 | 60 != (0 | o3)) && (o3 = 60, 33 == Y[n2 - 1 | 0])) break r;
              var b3 = 255 & o3;
              if ((0 | b3) == (0 | a3)) break r;
              if (!e3 | 92 != Y[n2 - 1 | 0]) {
                i: {
                  f: {
                    if (96 != (0 | b3)) {
                      if (91 != (0 | b3)) continue;
                      for (n2 = ((b3 = e3 + 1 | 0) >>> 0 < r3 >>> 0 ? r3 : b3) - 1 | 0, i3 = 0; ; ) {
                        if (r3 >>> 0 <= (b3 = e3 + 1 | 0) >>> 0) {
                          e3 = n2;
                          break f;
                        }
                        if (93 == (0 | (o3 = Y[A3 + b3 | 0]))) break f;
                        i3 = i3 || ((0 | a3) == (0 | o3) ? b3 : 0), e3 = b3;
                      }
                    }
                    for (b3 = (b3 = r3 - e3 | (i3 = 0)) >>> 0 <= r3 >>> 0 ? b3 : 0, o3 = 0; ; ) {
                      if ((0 | b3) == (0 | o3)) break i;
                      if (96 != Y[A3 + e3 | 0]) {
                        for (n2 = 0; !(r3 >>> 0 <= e3 >>> 0 | o3 >>> 0 <= n2 >>> 0); ) n2 = 96 == (0 | (b3 = Y[A3 + e3 | 0])) ? n2 + 1 | 0 : 0, i3 = i3 || ((0 | a3) == (0 | b3) ? e3 : 0), e3 = e3 + 1 | 0;
                        if (e3 >>> 0 < r3 >>> 0) continue a;
                        break i;
                      }
                      o3 = o3 + 1 | 0, e3 = e3 + 1 | 0;
                    }
                  }
                  for (e3 = e3 + 2 | 0; ; ) {
                    if (r3 >>> 0 <= e3 >>> 0) break i;
                    if (10 != (0 | (b3 = Y[A3 + e3 | 0])) & 32 != (0 | b3)) break;
                    e3 = e3 + 1 | 0;
                  }
                  f: {
                    if (40 != (0 | b3)) {
                      if (n2 = 93, 91 == (0 | b3)) break f;
                      if (i3) break i;
                      continue;
                    }
                    n2 = 41;
                  }
                  for (; ; ) {
                    if (r3 >>> 0 <= (b3 = e3 + 1 | 0) >>> 0) break i;
                    if ((0 | (o3 = Y[A3 + b3 | 0])) == (0 | n2)) break;
                    i3 = i3 || ((0 | a3) == (0 | o3) ? b3 : 0), e3 = b3;
                  }
                  e3 = e3 + 2 | 0;
                  continue;
                }
                break;
              }
              e3 = e3 + 1 | 0;
            }
            return i3;
          }
          return e3;
        }
        return 0;
      }
      function z(A3) {
        var r3 = q[2232], a3 = A3 + 7 & -8, i3 = r3 + a3 | 0, f3 = -1;
        if (i3 >>> 0 <= r3 >>> 0 && a3 || (n.byteLength / 65536 | 0) << 16 >>> 0 < i3 >>> 0 && !(0 | o2(0 | i3)) || (q[2232] = i3, f3 = r3), -1 != (0 | (r3 = f3))) {
          q[12 + (f3 = (i3 = A3 + r3 | 0) - 16 | 0) >> 2] = 16, q[f3 >> 2] = 16;
          var e3 = (A3 = q[2512]) ? q[A3 + 8 >> 2] : 0;
          A: {
            r: {
              if ((0 | e3) == (0 | r3)) {
                if (e3 = q[(a3 = r3 - (-2 & q[r3 - 4 >> 2]) | 0) - 4 >> 2], q[A3 + 8 >> 2] = i3, i3 = -16, !(1 & M[((A3 = a3 - (-2 & e3) | 0) + q[A3 >> 2] | 0) - 4 | 0])) break r;
                q[(i3 = q[A3 + 4 >> 2]) + 8 >> 2] = q[A3 + 8 >> 2], q[q[A3 + 8 >> 2] + 4 >> 2] = i3, q[A3 >> 2] = f3 = f3 - A3 | 0;
                break A;
              }
              q[r3 + 12 >> 2] = 16, q[r3 >> 2] = 16, q[r3 + 8 >> 2] = i3, q[r3 + 4 >> 2] = A3, q[2512] = r3, i3 = 16;
            }
            q[(A3 = i3 + r3 | 0) >> 2] = f3 = f3 - A3 | 0;
          }
          q[((-4 & f3) + A3 | 0) - 4 >> 2] = 1 | f3, (i3 = q[A3 >> 2] - 8 | 0) >>> 0 <= 127 ? f3 = (i3 >>> 3 | 0) - 1 | 0 : (f3 = 110 + ((i3 >>> 29 - (a3 = t2(i3)) ^ 4) - (a3 << 2) | 0) | 0, i3 >>> 0 <= 4095 || (f3 = 63 <= (f3 = 71 + ((i3 >>> 30 - a3 ^ 2) - (a3 << 1) | 0) | 0) >>> 0 ? 63 : f3)), q[A3 + 4 >> 2] = 9024 + (i3 = f3 << 4), q[A3 + 8 >> 2] = q[(i3 = i3 + 9032 | 0) >> 2], q[i3 >> 2] = A3, q[q[A3 + 8 >> 2] + 4 >> 2] = A3, i3 = q[2514], a3 = q[2515], A3 = 31 & f3, 32 <= (63 & f3) >>> 0 ? (f3 = 1 << A3, e3 = 0) : f3 = (e3 = 1 << A3) - 1 & 1 >>> 32 - A3, q[2514] = e3 | i3, q[2515] = f3 | a3;
        }
        return -1 != (0 | r3);
      }
      function V(A3, r3, a3, i3, f3, e3, n2) {
        var o3, b3, w2 = 0, k3 = 0;
        Q = o3 = Q - 16 | 0;
        A: if (!(!q[r3 + 44 >> 2] | !q[r3 + 40 >> 2])) {
          var c3 = E(r3, 1), w2 = i3 ? 124 == Y[0 | a3] : w2;
          r: for (; ; ) {
            a: {
              if (!(f3 >>> 0 <= k3 >>> 0 | i3 >>> 0 <= w2 >>> 0)) for (b3 = E(r3, 1); ; ) {
                if ((0 | i3) == (0 | w2)) {
                  w2 = i3;
                  break a;
                }
                if (32 != (0 | (D2 = Y[a3 + w2 | 0])) & 10 != (0 | D2)) break a;
                w2 = w2 + 1 | 0;
              }
              (0 | f3) != (0 | k3) && (q[8 + o3 >> 2] = 0, q[12 + o3 >> 2] = 0, q[o3 >> 2] = 0, q[4 + o3 >> 2] = 0, W[q[r3 + 44 >> 2]](c3, o3, q[(k3 << 2) + e3 >> 2] | n2, q[r3 + 112 >> 2], f3 - k3 | 0)), W[q[r3 + 40 >> 2]](A3, c3, q[r3 + 112 >> 2]), --q[r3 + 420 >> 2];
              break A;
            }
            for (var t3 = i3 >>> 0 < w2 >>> 0 ? w2 : i3, D2 = w2; ; ) {
              a: {
                if ((0 | D2) != (0 | t3)) {
                  if (124 != Y[a3 + D2 | 0]) break a;
                  t3 = D2;
                }
                for (var u2 = (w2 >>> 0 < (D2 = t3 - 1 | 0) >>> 0 ? w2 : D2) + 1 | 0, D2 = t3; ; ) {
                  var B2 = D2;
                  if ((D2 = D2 - 1 | 0) >>> 0 <= w2 >>> 0) B2 = u2;
                  else {
                    var g2 = Y[a3 + D2 | 0];
                    if (10 == (0 | g2) | 32 == (0 | g2)) continue;
                  }
                  break;
                }
                O(b3, r3, a3 + w2 | 0, B2 - w2 | 0), W[q[r3 + 44 >> 2]](c3, b3, q[(k3 << 2) + e3 >> 2] | n2, q[r3 + 112 >> 2], 0), --q[r3 + 420 >> 2], k3 = k3 + 1 | 0, w2 = t3 + 1 | 0;
                continue r;
              }
              D2 = D2 + 1 | 0;
            }
          }
        }
        Q = 16 + o3 | 0;
      }
      function R(A3, r3) {
        for (var a3, i3, f3, e3, n2, o3 = 0, b3 = 0, w2 = 0; ; ) {
          A: {
            if ((0 | r3) != (0 | o3)) {
              if (60 != Y[A3 + o3 | 0]) break A;
              r3 = o3;
            }
            for (; ; ) {
              if (!(a3 = r3)) return 0;
              r: {
                a: if (i3 = Y[(e3 = a3 - 1 | 0) + A3 | 0]) {
                  if (i3 >>> 0 <= 63 && (r3 = e3, o3 = 31 & i3, 32 <= (63 & i3) >>> 0 ? (f3 = 1 << o3, n2 = 0) : f3 = (n2 = 1 << o3) - 1 & 1 >>> 32 - o3, 1 & n2 | -2147463166 & f3)) continue;
                  i: {
                    f: {
                      e: {
                        if (59 != (0 | i3)) {
                          switch (r3 = 40, i3 - 39 | 0) {
                            case 0:
                              break f;
                            case 1:
                              break a;
                            case 2:
                              break i;
                          }
                          if ((r3 = 34) == (0 | i3)) break i;
                          if (93 == (0 | i3)) break e;
                          if (125 != (0 | i3)) break a;
                          r3 = 123;
                          break i;
                        }
                        for (o3 = a3 = a3 - 2 | 0; ; ) {
                          if (!o3) {
                            o3 = 0;
                            break r;
                          }
                          if (!((32 | Y[A3 + o3 | 0]) - 97 >>> 0 < 26)) break r;
                          o3 = o3 - 1 | 0;
                        }
                      }
                      r3 = 91;
                      break i;
                    }
                    r3 = 39;
                  }
                  for (o3 = 0; (0 | o3) != (0 | a3); ) b3 = ((0 | (f3 = Y[A3 + o3 | 0])) == (0 | i3) & (0 | r3) != (0 | f3)) + b3 | 0, o3 = o3 + 1 | 0, w2 = ((0 | r3) == (0 | f3)) + w2 | 0;
                  a3 = (0 | b3) == (0 | w2) ? a3 : e3;
                }
                return a3;
              }
              r3 = a3 >>> 0 <= o3 >>> 0 || 38 != Y[A3 + o3 | 0] ? e3 : o3;
            }
          }
          o3 = o3 + 1 | 0;
        }
      }
      function p(A3, r3, a3) {
        var i3, f3, e3 = A3 + 4 | 0, n2 = (e3 + r3 | 0) - 1 & 0 - r3;
        return n2 + a3 >>> 0 <= ((r3 = q[A3 >> 2]) + A3 | 0) - 4 >>> 0 ? (q[(i3 = q[A3 + 4 >> 2]) + 8 >> 2] = q[A3 + 8 >> 2], q[q[A3 + 8 >> 2] + 4 >> 2] = i3, (0 | e3) != (0 | n2) && (e3 = (n2 = n2 - e3 | 0) + q[(i3 = A3 - (-2 & q[A3 - 4 >> 2]) | 0) >> 2] | 0, q[i3 >> 2] = e3, q[(i3 + (-4 & e3) | 0) - 4 >> 2] = e3, q[(A3 = A3 + n2 | 0) >> 2] = r3 = r3 - n2 | 0), a3 + 24 >>> 0 <= r3 >>> 0 ? (q[(e3 = 8 + (A3 + a3 | 0) | 0) >> 2] = r3 = (r3 - a3 | 0) - 8 | 0, q[(e3 + (-4 & r3) | 0) - 4 >> 2] = 1 | r3, (n2 = q[e3 >> 2] - 8 | 0) >>> 0 <= 127 ? r3 = (n2 >>> 3 | 0) - 1 | 0 : (r3 = 110 + ((n2 >>> 29 - (i3 = t2(n2)) ^ 4) - (i3 << 2) | 0) | 0, n2 >>> 0 <= 4095 || (r3 = 63 <= (r3 = 71 + ((n2 >>> 30 - i3 ^ 2) - (i3 << 1) | 0) | 0) >>> 0 ? 63 : r3)), q[e3 + 4 >> 2] = 9024 + (n2 = r3 << 4), q[e3 + 8 >> 2] = q[(n2 = n2 + 9032 | 0) >> 2], q[n2 >> 2] = e3, q[q[e3 + 8 >> 2] + 4 >> 2] = e3, n2 = q[2514], i3 = q[2515], e3 = 31 & r3, e3 = 32 <= (63 & r3) >>> 0 ? (r3 = 1 << e3, 0) : (r3 = (f3 = 1 << e3) - 1 & 1 >>> 32 - e3, f3), q[2514] = e3 | n2, q[2515] = r3 | i3, q[A3 >> 2] = r3 = a3 + 8 | 0, q[((-4 & r3) + A3 | 0) - 4 >> 2] = r3) : q[(A3 + r3 | 0) - 4 >> 2] = r3, A3 + 4 | 0) : 0;
      }
      function L(A3, r3, a3) {
        return q[A3 + 112 >> 2] = 0, q[A3 + 116 >> 2] = 0, q[A3 + 120 >> 2] = 0, q[A3 + 124 >> 2] = 0, a3 ? (q[A3 + 128 >> 2] = 65, u(A3, 5088, 112)) : (q[A3 + 128 >> 2] = r3, a3 = u(A3, 5200, 112), 4 & r3 && (q[a3 + 68 >> 2] = 0), 8 & r3 && (q[a3 + 48 >> 2] = 0, q[a3 + 76 >> 2] = 0), 513 & r3 && (q[a3 + 12 >> 2] = 0)), q[A3 + 136 >> 2] = 8992, q[A3 + 132 >> 2] = 8944, q[A3 + 140 >> 2] = 1, (a3 = c2(444)) && (Y0((r3 = u(a3, A3, 112)) + 404 | 0, 4), Y0(r3 + 416 | 0, 8), Z0(r3 + 148 | 0, 256), q[r3 + 64 >> 2] | q[r3 + 60 >> 2] | q[r3 + 84 >> 2] && (M[r3 + 243 | 0] = 1, M[r3 + 190 | 0] = 1, M[r3 + 274 | 0] = 1, M[r3 + 210 | 0] = 1), q[r3 + 52 >> 2] && (M[r3 + 244 | 0] = 2), q[r3 + 72 >> 2] && (M[r3 + 158 | 0] = 3), q[r3 + 68 >> 2] | q[r3 + 76 >> 2] && (M[r3 + 239 | 0] = 4), q[r3 + 428 >> 2] = 155, q[r3 + 440 >> 2] = 0, q[r3 + 432 >> 2] = 16, q[r3 + 436 >> 2] = 64, q[r3 + 112 >> 2] = A3 + 112 | 0, M[r3 + 240 | 0] = 6, M[r3 + 208 | 0] = 5, M[r3 + 212 | 0] = 9, M[r3 + 186 | 0] = 7, M[r3 + 267 | 0] = 10, M[r3 + 206 | 0] = 8, M[r3 + 242 | 0] = 12, M[r3 + 195 | 0] = 11), a3;
      }
      function Z(A3) {
        var r3, a3, i3, f3, e3;
        (A3 |= 0) && (i3 = r3 = q[(a3 = A3 - 4 | 0) >> 2], f3 = a3, (0 | (A3 = -2 & (e3 = q[A3 - 8 >> 2]))) != (0 | e3) && (q[(i3 = q[4 + (f3 = a3 - A3 | 0) >> 2]) + 8 >> 2] = q[f3 + 8 >> 2], q[q[f3 + 8 >> 2] + 4 >> 2] = i3, i3 = A3 + r3 | 0), (0 | (a3 = q[(A3 = a3 + r3 | 0) >> 2])) != q[(A3 + a3 | 0) - 4 >> 2] && (q[(r3 = q[A3 + 4 >> 2]) + 8 >> 2] = q[A3 + 8 >> 2], q[q[A3 + 8 >> 2] + 4 >> 2] = r3, i3 = a3 + i3 | 0), q[f3 >> 2] = i3, q[((-4 & i3) + f3 | 0) - 4 >> 2] = 1 | i3, (a3 = q[f3 >> 2] - 8 | 0) >>> 0 <= 127 ? A3 = (a3 >>> 3 | 0) - 1 | 0 : (A3 = 110 + ((a3 >>> 29 - (i3 = t2(a3)) ^ 4) - (i3 << 2) | 0) | 0, a3 >>> 0 <= 4095 || (A3 = 63 <= (A3 = 71 + ((a3 >>> 30 - i3 ^ 2) - (i3 << 1) | 0) | 0) >>> 0 ? 63 : A3)), q[f3 + 4 >> 2] = 9024 + (a3 = A3 << 4), q[f3 + 8 >> 2] = q[(a3 = 9032 + a3 | 0) >> 2], q[a3 >> 2] = f3, q[q[f3 + 8 >> 2] + 4 >> 2] = f3, a3 = q[2514], i3 = q[2515], f3 = 31 & A3, 32 <= (63 & A3) >>> 0 ? (A3 = 1 << f3, r3 = 0) : A3 = (r3 = 1 << f3) - 1 & 1 >>> 32 - f3, q[2514] = r3 | a3, q[2515] = A3 | i3);
      }
      function T(A3, r3, a3, i3) {
        var f3 = 0, e3 = 0, n2 = r3 - 1 | 0, o3 = a3 - 1 | 0, b3 = k0(A3), w2 = b3 + 2 | 0, k3 = b3 + 3 | 0, c3 = 1;
        A: for (; ; ) {
          r: if (!(a3 >>> 0 <= c3 >>> 0)) for (; ; ) {
            a: {
              if ((0 | c3) == (0 | o3)) var t3 = o3, c3 = a3;
              else {
                var D2 = c3 + 1 | 0, t3 = Y[D2 + r3 | 0];
                if (60 != Y[r3 + c3 | 0] | 47 != (0 | t3)) break a;
                t3 = c3, c3 = D2;
              }
              if (!(!i3 | (0 | f3) <= 0) & 10 != Y[(r3 + t3 | 0) - 1 | 0]) continue A;
              if (a3 >>> 0 <= t3 + k3 >>> 0) break r;
              if ((D2 = 1 + (a3 - c3 | 0) | 0) >>> 0 <= k3 >>> 0) continue A;
              var u2 = c3 + n2 | 0;
              if (g(2 + u2 | 0, A3, b3) | 62 != Y[u2 + w2 | 0]) continue A;
              var B2 = I(k3 + u2 | 0, D2 - k3 | 0);
              if (!B2) continue A;
              if (!(D2 = (D2 = (B2 = k3 + B2 | 0) >>> 0 < D2 >>> 0 ? I(B2 + u2 | 0, D2 - B2 | 0) : 0) + B2 | 0)) continue A;
              e3 = D2 + t3 | 0;
              break r;
            }
            f3 = (10 == (0 | t3)) + f3 | 0, c3 = D2;
          }
          break;
        }
        return e3;
      }
      function O(A3, r3, a3, i3) {
        var f3, e3, n2 = 0, o3 = 0, b3 = 0, w2 = 0;
        Q = e3 = Q - 16 | 0, q[8 + e3 >> 2] = 0, q[12 + e3 >> 2] = 0, q[e3 >> 2] = 0, q[4 + e3 >> 2] = 0;
        A: if (!(C[r3 + 432 >> 2] < q[r3 + 408 >> 2] + q[r3 + 420 >> 2] >>> 0)) r: for (; ; ) {
          if (i3 >>> 0 <= o3 >>> 0) break A;
          for (f3 = i3 >>> 0 < n2 >>> 0 ? n2 : i3; ; ) {
            a: {
              if ((0 | n2) != (0 | f3)) {
                if (!(b3 = Y[148 + (Y[a3 + n2 | 0] + r3 | 0) | 0])) break a;
                f3 = n2;
              }
              var k3 = a3 + o3 | 0;
              if ((n2 = q[r3 + 100 >> 2]) ? (q[e3 >> 2] = k3, q[4 + e3 >> 2] = f3 - o3, W[0 | n2](A3, e3, q[r3 + 112 >> 2])) : N(A3, k3, f3 - o3 | 0), i3 >>> 0 <= f3 >>> 0) break A;
              o3 = (n2 = 0 | W[q[4448 + (b3 << 2) >> 2]](A3, r3, a3 + f3 | 0, f3 - w2 | 0, f3, i3 - f3 | 0)) + f3 | 0, w2 = n2 ? o3 : w2, n2 = n2 ? o3 : f3 + 1 | 0;
              continue r;
            }
            n2 = n2 + 1 | 0, b3 = 0;
          }
        }
        Q = 16 + e3 | 0;
      }
      function K(A3, r3) {
        var a3 = 0;
        A: {
          if (61 != (0 | (f3 = Y[0 | A3]))) {
            if (45 != (0 | f3)) break A;
            for (var i3 = r3 >>> 0 <= 1 ? 1 : r3, f3 = 1; ; ) {
              r: {
                if ((0 | f3) != (0 | i3)) {
                  if (45 == Y[A3 + f3 | 0]) break r;
                  i3 = f3;
                }
                for (f3 = r3 >>> 0 < i3 >>> 0 ? i3 : r3; ; ) {
                  if ((0 | f3) == (0 | i3)) return 2;
                  if (r3 = A3 + i3 | 0, i3 = i3 + 1 | 0, 32 != (0 | (r3 = Y[0 | r3]))) break;
                }
                a3 = (10 == (0 | r3)) << 1;
                break A;
              }
              f3 = f3 + 1 | 0;
            }
          }
          for (i3 = r3 >>> 0 <= 1 ? 1 : r3, f3 = 1; ; ) {
            r: {
              if ((0 | f3) != (0 | i3)) {
                if (61 == Y[A3 + f3 | 0]) break r;
                i3 = f3;
              }
              for (f3 = r3 >>> 0 < i3 >>> 0 ? i3 : r3, a3 = 1; ; ) {
                if ((0 | f3) == (0 | i3)) break A;
                if (r3 = A3 + i3 | 0, i3 = i3 + 1 | 0, 32 != (0 | (r3 = Y[0 | r3]))) break;
              }
              return 10 == (0 | r3);
            }
            f3 = f3 + 1 | 0;
          }
        }
        return a3;
      }
      function S(A3, r3, a3) {
        var i3, f3 = 0;
        for (Q = i3 = Q - 16 | 0, B(A3, (k2(a3, 12) >>> 0) / 10 | 0), M[13 + i3 | 0] = 37; ; ) {
          A: {
            var e3 = f3;
            if (!(a3 >>> 0 <= e3 >>> 0)) {
              for (; ; ) {
                if ((0 | a3) == (0 | e3)) e3 = a3;
                else if (1 == Y[Y[r3 + e3 | 0] + 4544 | 0]) {
                  e3 = e3 + 1 | 0;
                  continue;
                }
                break;
              }
              if (f3 >>> 0 < e3 >>> 0 && N(A3, r3 + f3 | 0, e3 - f3 | 0), !(a3 >>> 0 <= e3 >>> 0)) {
                if (2 == Y[(f3 = Y[r3 + e3 | 0]) + 4544 | 0]) break A;
                switch (f3 - 38 | 0) {
                  case 0:
                    N(A3, 1898, 5);
                    break A;
                  case 1:
                    N(A3, 3333, 6);
                    break A;
                }
                M[15 + i3 | 0] = Y[4512 + (15 & f3) | 0], M[14 + i3 | 0] = Y[4512 + (f3 >>> 4 | 0) | 0], N(A3, 13 + i3 | 0, 3);
                break A;
              }
            }
            Q = 16 + i3 | 0;
            break;
          }
          f3 = e3 + 1 | 0;
        }
      }
      function $51(A3, r3, a3, i3, f3) {
        if (!q[r3 + 64 >> 2]) return 0;
        var e3 = Y[0 | a3] == (0 | f3) ? Y[a3 + 1 | 0] == (0 | f3) : 0, n2 = 95 != (0 | f3);
        A: {
          for (; ; ) {
            var o3 = 0;
            if (i3 >>> 0 <= e3 >>> 0) break A;
            var b3 = P(a3 + e3 | 0, i3 - e3 | 0, f3);
            if (!b3) break A;
            if (i3 >>> 0 <= (e3 = e3 + b3 | 0) >>> 0) break A;
            if (Y[0 | (o3 = a3 + e3 | 0)] == (0 | f3) && !(10 == (0 | (o3 = Y[o3 - 1 | 0])) | 32 == (0 | o3)) && (!(1 & q[r3 + 428 >> 2]) | (0 | (o3 = e3 + 1 | 0)) == (0 | i3) | n2 || 10 == (0 | (b3 = Y[a3 + o3 | 0])) | 32 == (0 | b3) || !(94 <= b3 - 33 >>> 0) && !H(b3))) break;
          }
          O(i3 = E(r3, 1), r3, a3, e3), A3 = 0 | W[q[r3 + 64 >> 2]](A3, i3, q[r3 + 112 >> 2]), --q[r3 + 420 >> 2], o3 = A3 ? o3 : 0;
        }
        return o3;
      }
      function _(A3, r3) {
        var a3 = 0;
        A: if (!(r3 >>> 0 < 3)) {
          var i3 = 0;
          if (!(r3 >>> 0 <= (i3 = 32 == Y[0 | A3] && 32 == Y[A3 + (i3 = 1) | 0] ? 32 == Y[A3 + 2 | 0] ? 3 : 2 : i3) + 2 >>> 0)) {
            r: {
              var f3 = Y[A3 + i3 | 0];
              switch (f3 - 42 | 0) {
                case 1:
                case 2:
                  break A;
                case 0:
                case 3:
                  break r;
              }
              if (95 != (0 | f3)) break A;
            }
            for (a3 = r3 >>> 0 < i3 >>> 0 ? i3 : r3, r3 = 0; ; ) {
              r: {
                if ((0 | i3) != (0 | a3)) {
                  var e3 = Y[A3 + i3 | 0];
                  if (10 != (0 | e3)) {
                    if ((0 | f3) == (0 | e3)) {
                      r3 = r3 + 1 | 0;
                      break r;
                    }
                    if (32 == (0 | e3)) break r;
                    return;
                  }
                }
                a3 = 2 < r3 >>> 0;
                break A;
              }
              i3 = i3 + 1 | 0;
            }
          }
        }
        return a3;
      }
      function A0(A3, r3, a3) {
        var i3, f3 = 0 != (0 | a3);
        A: {
          r: {
            a: if (!(!(3 & A3) | !a3)) for (i3 = 255 & r3; ; ) {
              if ((0 | i3) == Y[0 | A3]) break r;
              if (f3 = 0 != (0 | (a3 = a3 - 1 | 0)), !(3 & (A3 = A3 + 1 | 0))) break a;
              if (!a3) break;
            }
            if (!f3) break A;
            if (!(Y[0 | A3] == (255 & r3) | a3 >>> 0 < 4)) for (f3 = k2(255 & r3, 16843009); ; ) {
              if ((-1 ^ (i3 = f3 ^ q[A3 >> 2])) & i3 - 16843009 & -2139062144) break r;
              if (A3 = A3 + 4 | 0, !(3 < (a3 = a3 - 4 | 0) >>> 0)) break;
            }
            if (!a3) break A;
          }
          for (r3 &= 255; ; ) {
            if ((0 | r3) == Y[0 | A3]) return A3;
            if (A3 = A3 + 1 | 0, !(a3 = a3 - 1 | 0)) break;
          }
        }
      }
      function r0(A3, r3) {
        var a3;
        Q = a3 = Q - 16 | 0, b2[6 + a3 >> 1] = 0, b2[8 + a3 >> 1] = 0, b2[10 + a3 >> 1] = 0, b2[12 + a3 >> 1] = 0, q[a3 >> 2] = 0;
        for (var i3 = ((f3 = r3 >> 31) ^ r3) - f3 | (q[4 + a3 >> 2] = 0), f3 = 0; ; ) {
          var e3 = f3, n2 = (i3 >>> 0) / 10 | 0, o3 = (M[a3 + f3 | 0] = k2(n2, 246) + i3 | 48, f3 = f3 + 1 | 0, 9 < i3 >>> 0), i3 = n2;
          if (!o3) break;
        }
        for ((i3 = 0) <= (0 | r3) ? f3 = e3 : M[a3 + f3 | 0] = 45; ; ) {
          if ((0 | f3) <= (0 | i3)) {
            m(A3, a3), Q = 16 + a3 | 0;
            break;
          }
          e3 = Y[0 | (r3 = a3 + i3 | 0)], M[0 | (n2 = r3)] = Y[0 | (r3 = a3 + f3 | 0)], M[0 | r3] = e3, f3 = f3 - 1 | 0, i3 = i3 + 1 | 0;
        }
      }
      function a0(A3, r3, a3, i3, f3) {
        var e3 = 0, n2 = 0, o3 = q[(126 == (0 | f3) ? 88 : 60) + r3 >> 2];
        A: if (o3) {
          for (; ; ) {
            if (i3 >>> 0 <= e3 >>> 0) break A;
            var b3 = P(a3 + e3 | 0, i3 - e3 | 0, f3);
            if (!b3) break A;
            if (!(i3 >>> 0 <= (e3 = 1 + (b3 = b3 + e3 | 0) | 0) >>> 0)) {
              var w2 = a3 + b3 | 0;
              if (!(!b3 | Y[a3 + e3 | 0] != (0 | f3) | Y[0 | w2] != (0 | f3) || 10 == (0 | (w2 = Y[w2 - 1 | 0])) | 32 == (0 | w2))) break;
            }
          }
          O(i3 = E(r3, 1), r3, a3, b3), A3 = 0 | W[0 | o3](A3, i3, q[r3 + 112 >> 2]), --q[r3 + 420 >> 2], n2 = A3 ? b3 + 2 | 0 : 0;
        }
        return n2;
      }
      function i0(A3, r3) {
        var a3, i3 = 0, f3 = r3 ? 32 == Y[0 | A3] : 0;
        A: if (!((Y[A3 + (f3 = (f3 = f3 >>> 0 < r3 >>> 0 ? (32 == Y[A3 + f3 | 0]) + f3 | 0 : f3) >>> 0 < r3 >>> 0 ? (32 == Y[A3 + f3 | 0]) + f3 | 0 : f3) | 0] - 58 & 255) >>> 0 < 246 | r3 >>> 0 <= f3 >>> 0)) for (a3 = r3 >>> 0 < f3 >>> 0 ? f3 : r3; ; ) {
          r: {
            if ((0 | f3) != (0 | a3)) {
              if ((Y[A3 + f3 | 0] - 48 & 255) >>> 0 <= 9) break r;
              a3 = f3;
            }
            if (r3 >>> 0 <= (f3 = a3 + 1 | 0) >>> 0) break A;
            var e3 = A3 + a3 | 0;
            if (46 != Y[0 | e3] | 32 != Y[A3 + f3 | 0]) break A;
            i3 = G0(e3, r3 - a3 | 0) ? 0 : a3 + 2 | 0;
            break A;
          }
          f3 = f3 + 1 | 0;
        }
        return i3;
      }
      function f0(A3, r3) {
        var a3, i3 = 0, f3 = r3 ? 32 == Y[0 | A3] : 0, e3 = (f3 = (f3 = f3 >>> 0 < r3 >>> 0 ? (32 == Y[A3 + f3 | 0]) + f3 | 0 : f3) >>> 0 < r3 >>> 0 ? (32 == Y[A3 + f3 | 0]) + f3 | 0 : f3) + 1 | 0;
        return r3 >>> 0 <= e3 >>> 0 || 62 != Y[0 | (a3 = A3 + f3 | 0)] | 33 != Y[A3 + e3 | 0] || (a3 = P(1 + a3 | 0, (-1 ^ f3) + r3 | 0, 60)) && !(r3 >>> 0 <= (a3 = f3 + a3 | 0) >>> 0 || 33 != Y[A3 + a3 | 0]) || r3 >>> 0 <= (i3 = f3 + 2 | 0) >>> 0 || 32 != Y[A3 + i3 | 0] ? i3 : f3 + 3 | 0;
      }
      function D(A3, r3, a3) {
        var i3 = 0, f3 = 0;
        for (B(A3, (k2(a3, 12) >>> 0) / 10 | 0); ; ) {
          A: {
            var e3 = i3;
            if (e3 >>> 0 < a3 >>> 0) {
              for (; ; ) {
                if ((0 | a3) == (0 | e3)) e3 = a3;
                else if (!(f3 = M[Y[r3 + e3 | 0] + 4832 | 0])) {
                  e3 = e3 + 1 | 0, f3 = 0;
                  continue;
                }
                break;
              }
              if (i3 >>> 0 < e3 >>> 0 && N(A3, r3 + i3 | 0, e3 - i3 | 0), e3 >>> 0 < a3 >>> 0) break A;
            }
            break;
          }
          47 == (0 | (i3 = Y[r3 + e3 | 0])) ? F(A3, 47) : 7 != Y[i3 + 4832 | 0] && m(A3, q[4800 + (f3 << 2) >> 2]), i3 = e3 + 1 | 0;
        }
      }
      function e0(A3, r3, a3, i3, f3, e3, n2) {
        var o3 = q[10236 + (e3 <<= 4) >> 2], b3 = q[e3 + 10228 >> 2], w2 = q[e3 + 10224 >> 2];
        return q[(e3 = q[e3 + 10232 >> 2]) + 148 >> 2] = i3, q[e3 + 144 >> 2] = a3, a3 = s(128), i3 = q[e3 + 128 >> 2], n2 && (q[o3 + 124 >> 2] = f3, v(a3, A3, r3, b3), q[o3 + 124 >> 2] = 0, q[e3 + 128 >> 2] |= 64), q[e3 + 124 >> 2] = f3, v(a3, A3, r3, w2), q[e3 + 128 >> 2] = i3, q[e3 + 124 >> 2] = 0, A3 = c2((r3 = q[a3 + 4 >> 2]) + 1 | 0), M[A3 + r3 | 0] = 0, (i3 = q[a3 >> 2]) && u(A3, i3, r3), G(a3), A3;
      }
      function n0(A3, r3) {
        for (var a3, i3, f3 = 0; ; ) {
          if (a3 = f3, !((i3 = q[r3 + 4 >> 2]) >>> 0 <= a3 >>> 0)) {
            for (; ; ) {
              if ((0 | a3) == (0 | i3)) a3 = i3;
              else if (92 != Y[q[r3 >> 2] + a3 | 0]) {
                a3 = a3 + 1 | 0;
                continue;
              }
              break;
            }
            if (f3 >>> 0 < a3 >>> 0 && (N(A3, q[r3 >> 2] + f3 | 0, a3 - f3 | 0), i3 = q[r3 + 4 >> 2]), !((f3 = i3) >>> 0 <= (i3 = a3 + 1 | 0) >>> 0)) {
              F(A3, Y[i3 + q[r3 >> 2] | 0]), f3 = a3 + 2 | 0;
              continue;
            }
          }
          break;
        }
      }
      function E(A3, r3) {
        var a3, i3 = 404 + (A3 = k2(r3, 12) + A3 | 0) | 0, f3 = q[A3 + 408 >> 2];
        return C[A3 + 412 >> 2] <= f3 >>> 0 || !(a3 = q[q[i3 >> 2] + (f3 << 2) >> 2]) ? (r3 = s(q[4436 + (r3 << 2) >> 2]), 0 <= (0 | g0(i3, q[A3 + 408 >> 2] << 1)) && (i3 = q[i3 >> 2], A3 = q[(f3 = A3) + 408 >> 2], q[f3 + 408 >> 2] = A3 + 1, q[i3 + (A3 << 2) >> 2] = r3), r3) : (q[A3 + 408 >> 2] = f3 + 1, q[a3 + 4 >> 2] = 0, a3);
      }
      function o0(A3, r3) {
        var a3 = r3 ? 32 == Y[0 | A3] : 0;
        (a3 = a3 >>> 0 < r3 >>> 0 ? (32 == Y[A3 + a3 | 0]) + a3 | 0 : a3) >>> 0 < r3 >>> 0 && (a3 = (32 == Y[A3 + a3 | 0]) + a3 | 0);
        A: {
          r: if (!(62 != Y[A3 + a3 | 0] | r3 >>> 0 <= a3 >>> 0 || r3 >>> 0 <= (r3 = a3 + 1 | 0) >>> 0)) {
            switch (Y[A3 + r3 | 0] - 32 | 0) {
              case 1:
                break r;
              case 0:
                break;
              default:
                break A;
            }
            return a3 + 2 | 0;
          }
          r3 = 0;
        }
        return r3;
      }
      function g(A3, r3, a3) {
        var i3, f3 = 0;
        if (!a3) return 0;
        var e3 = Y[0 | A3];
        A: if (e3) {
          for (; (i3 = Y[0 | r3]) && (a3 = a3 - 1 | 0) && ((0 | e3) == (0 | i3) || (0 | y(e3)) == (0 | y(i3))); ) if (r3 = r3 + 1 | 0, e3 = Y[A3 + 1 | 0], A3 = A3 + 1 | 0, !e3) break A;
          f3 = e3;
        }
        return y(255 & f3) - y(Y[0 | r3]) | 0;
      }
      function b0(A3, r3) {
        for (var a3, i3, f3 = 0; ; ) {
          A: {
            if (14 != (0 | f3)) {
              if (!(r3 >>> 0 <= (a3 = k0(i3 = q[3952 + (f3 << 2) >> 2])) >>> 0 || g(A3, i3, a3))) {
                if (i3 = 1, H(a3 = Y[A3 + a3 | 0])) break A;
                if (!(28 < (a3 = a3 - 35 | 0) >>> 0) && 1 << a3 & 268439553) break A;
              }
              f3 = f3 + 1 | 0;
              continue;
            }
            i3 = 0;
          }
          break;
        }
        return i3;
      }
      function w0(A3, r3) {
        var a3, i3, f3 = r3 ? 32 == Y[0 | A3] : 0, e3 = (f3 = (f3 = f3 >>> 0 < r3 >>> 0 ? (32 == Y[A3 + f3 | 0]) + f3 | 0 : f3) >>> 0 < r3 >>> 0 ? (32 == Y[A3 + f3 | 0]) + f3 | 0 : f3) + 1 | 0;
        return r3 >>> 0 <= e3 >>> 0 || 3 < (i3 = Y[0 | (a3 = A3 + f3 | 0)] - 42 | 0) >>> 0 | 2 == (0 | i3) | 32 != Y[A3 + e3 | 0] || G0(a3, r3 - f3 | 0) ? 0 : f3 + 2 | 0;
      }
      function k0(A3) {
        A: {
          if (3 & (a3 = A3)) for (; ; ) {
            if (!Y[0 | a3]) break A;
            if (!(3 & (a3 = a3 + 1 | 0))) break;
          }
          for (; ; ) {
            var r3 = a3, a3 = a3 + 4 | 0, i3 = q[r3 >> 2];
            if ((-1 ^ i3) & i3 - 16843009 & -2139062144) break;
          }
          for (; r3 = (a3 = r3) + 1 | 0, Y[0 | a3]; ) ;
        }
        return a3 - A3 | 0;
      }
      function c0(A3, r3, a3) {
        var i3, f3, e3, n2 = 0;
        A: if (!(60 != Y[0 | A3] | r3 >>> 0 < 3)) {
          for (i3 = f3 = 47 == Y[A3 + 1 | 0] ? 2 : 1; ; ) {
            if ((0 | r3) == (0 | i3)) break A;
            if (!(e3 = M[0 | a3])) break;
            if (Y[A3 + i3 | 0] != (0 | e3)) break A;
            a3 = a3 + 1 | 0, i3 = i3 + 1 | 0;
          }
          n2 = U(A3 = Y[A3 + i3 | 0]) || 62 == (0 | A3) ? f3 : 0;
        }
        return n2;
      }
      function t0(A3, r3, a3) {
        var i3 = 0;
        A: if (35 == Y[0 | r3] && (i3 = 1, 64 & Y[A3 + 428 | 0])) for (A3 = 6 <= a3 >>> 0 ? 6 : a3, i3 = 0; ; ) {
          r: {
            if ((0 | A3) != (0 | i3)) {
              if (35 == Y[r3 + i3 | 0]) break r;
              A3 = i3;
            }
            if (A3 >>> 0 < a3 >>> 0 && 32 != Y[A3 + r3 | (i3 = 0)]) break A;
            i3 = 1;
            break A;
          }
          i3 = i3 + 1 | 0;
        }
        return i3;
      }
      function D0(A3, r3, a3, i3, f3) {
        var e3 = 0;
        if (!(!r3 | i3 >>> 0 < 2 | Y[A3 - 1 | 0] != (255 & f3))) if ((e3 = 2) <= r3 >>> 0) {
          if (47 != (0 | (A3 = M[A3 - 2 | 0])) && (e3 = 1, 94 <= A3 - 33 >>> 0 || H(A3))) return 0 != (0 | U(A3));
        } else (47 != Y[A3 - 2 | 0] | a3 >>> 0 < 3 || 92 != Y[A3 - 3 | (e3 = 0)]) && (e3 = 1);
        return e3;
      }
      function u0(A3, r3) {
        var a3 = 0;
        if (!H(Y[0 | A3])) return 0;
        var i3 = (r3 = r3 - 1 | 0) >>> 0 <= 1 ? 1 : r3;
        for (r3 = 1; ; ) {
          A: {
            if ((0 | r3) != (0 | i3)) {
              var f3 = Y[A3 + r3 | 0];
              if (46 == (0 | f3)) {
                a3 = a3 + 1 | 0;
                break A;
              }
              if (H(f3) | 45 == (0 | f3)) break A;
            } else r3 = i3;
            return a3 ? r3 : 0;
          }
          r3 = r3 + 1 | 0;
        }
      }
      function B(A3, r3) {
        var a3, i3 = -1;
        A: if (!(16777216 < r3 >>> 0)) {
          var f3 = q[A3 + 8 >> 2];
          if (f3 >>> 0 < r3 >>> 0) {
            for (a3 = q[A3 + 12 >> 2]; (f3 = f3 + a3 | 0) >>> 0 < r3 >>> 0; ) ;
            if (!(r3 = J(q[A3 >> 2], f3))) break A;
            q[A3 + 8 >> 2] = f3, q[A3 >> 2] = r3;
          }
          i3 = 0;
        }
        return i3;
      }
      function B0(A3, r3, a3, i3) {
        var f3 = A3 >>> 16 | 0, e3 = k2(w2 = a3 >>> 16 | 0, f3), n2 = 65535 & a3, o3 = 65535 & A3, b3 = k2(n2, o3), w2 = (65535 & (f3 = (b3 >>> 16 | 0) + k2(f3, n2) | 0)) + k2(w2, o3) | 0;
        return h = (k2(r3, a3) + e3 | 0) + k2(A3, i3) + (f3 >>> 16) + (w2 >>> 16) | 0, 65535 & b3 | w2 << 16;
      }
      function g0(A3, r3) {
        if (!(r3 >>> 0 <= C[A3 + 8 >> 2])) {
          var a3 = J(q[A3 >> 2], r3 << 2);
          if (!a3) return -1;
          var i3 = q[A3 + 8 >> 2];
          Z0((i3 << 2) + a3 | 0, r3 - i3 << 2), q[A3 + 8 >> 2] = r3, q[A3 >> 2] = a3, C[A3 + 4 >> 2] <= r3 >>> 0 || (q[A3 + 4 >> 2] = r3);
        }
        return 0;
      }
      function s0(A3, r3) {
        var a3 = Y[0 | A3], i3 = Y[0 | r3];
        A: if (!(!a3 | (0 | i3) != (0 | a3))) for (; ; ) {
          if (i3 = Y[r3 + 1 | 0], !(a3 = Y[A3 + 1 | 0])) break A;
          if (r3 = r3 + 1 | 0, A3 = A3 + 1 | 0, (0 | a3) != (0 | i3)) break;
        }
        return a3 - i3 | 0;
      }
      function G0(A3, r3) {
        for (var a3 = 0; ; ) {
          if ((0 | r3) == (0 | a3)) a3 = r3;
          else if (10 != Y[A3 + a3 | 0]) {
            a3 = a3 + 1 | 0;
            continue;
          }
          break;
        }
        return (a3 = a3 + 1 | 0) >>> 0 < r3 >>> 0 && K(A3 + a3 | 0, r3 - a3 | 0);
      }
      function I(A3, r3) {
        for (var a3, i3 = 0, f3 = 0; ; ) {
          A: {
            r: {
              if ((0 | r3) == (0 | i3)) i3 = r3;
              else {
                if (32 == (0 | (a3 = Y[A3 + i3 | 0]))) break A;
                if (10 != (0 | a3)) break r;
              }
              f3 = i3 + 1 | 0;
            }
            return f3;
          }
          i3 = i3 + 1 | 0;
        }
      }
      function m0(A3, r3, a3) {
        for (a3 = A3 + ((7 & (A3 = C0(r3, a3))) << 2) | 0; ; ) {
          if (a3 = q[a3 >> 2]) {
            if ((0 | A3) != q[a3 >> 2]) {
              a3 = a3 + 12 | 0;
              continue;
            }
          } else a3 = 0;
          break;
        }
        return a3;
      }
      function N(A3, r3, a3) {
        A: {
          var i3 = q[A3 + 4 >> 2], f3 = i3 + a3 | 0;
          if (C[A3 + 8 >> 2] < f3 >>> 0) {
            if ((0 | B(A3, f3)) < 0) break A;
            i3 = q[A3 + 4 >> 2];
          }
          u(q[A3 >> 2] + i3 | 0, r3, a3), q[A3 + 4 >> 2] += a3;
        }
      }
      function v0(A3, r3, a3) {
        A: {
          for (; ; ) {
            var i3 = Y[0 | A3], f3 = Y[0 | r3];
            if ((0 | i3) != (0 | f3)) break A;
            if (r3 = r3 + 1 | 0, A3 = A3 + 1 | 0, !(a3 = a3 - 1 | 0)) break;
          }
          return;
        }
        return i3 - f3 | 0;
      }
      function F(A3, r3) {
        A: {
          var a3 = q[A3 + 4 >> 2], i3 = a3 + 1 | 0;
          if (C[A3 + 8 >> 2] < i3 >>> 0) {
            if ((0 | B(A3, i3)) < 0) break A;
            a3 = q[A3 + 4 >> 2];
          }
          M[q[A3 >> 2] + a3 | 0] = r3, q[A3 + 4 >> 2] += 1;
        }
      }
      function J0(A3, r3, a3) {
        if (A3 >>> 0 < r3 >>> 0) u(A3, r3, a3);
        else if (a3) for (A3 = A3 + a3 | 0, r3 = r3 + a3 | 0; M[0 | (A3 = A3 - 1 | 0)] = Y[0 | (r3 = r3 - 1 | 0)], a3 = a3 - 1 | 0; ) ;
      }
      function P0(A3, r3) {
        return 32 != Y[0 | A3] | r3 >>> 0 < 4 | 32 != Y[A3 + 1 | 0] | 32 != Y[A3 + 2 | 0] || (r3 = 4, 32 != Y[A3 + 3 | 0]) ? 0 : r3;
      }
      function u(A3, r3, a3) {
        var i3;
        if (a3) for (i3 = A3; M[0 | i3] = Y[0 | r3], i3 = i3 + 1 | 0, r3 = r3 + 1 | 0, a3 = a3 - 1 | 0; ) ;
        return A3;
      }
      function C0(A3, r3) {
        for (var a3 = 0, i3 = 0; (0 | r3) != (0 | a3); ) i3 = y(Y[A3 + a3 | 0]) + k2(i3, 65599) | 0, a3 = a3 + 1 | 0;
        return i3;
      }
      function f2(A3, r3, a3, i3, f3, e3) {
        return !r3 | !q[r3 + 4 >> 2] ? 0 : (N(A3, e3, f3), N(A3, q[r3 >> 2], q[r3 + 4 >> 2]), N(A3, i3, a3), 1);
      }
      function s(A3) {
        var r3;
        return (r3 = c2(16)) && (q[r3 + 8 >> 2] = 0, q[r3 >> 2] = 0, q[r3 + 4 >> 2] = 0, q[r3 + 12 >> 2] = A3), r3;
      }
      function Z0(A3, r3) {
        if (r3) for (; A3 = A3 + 1 | (M[0 | A3] = 0), r3 = r3 - 1 | 0; ) ;
      }
      function M0(A3, r3) {
        return m(0 | A3, 256 & q[16 + (0 | r3) >> 2] ? 3883 : 3698), 1;
      }
      function q0(A3) {
        A3 && (Z(q[A3 >> 2]), q[A3 + 8 >> 2] = 0, q[A3 >> 2] = 0, q[A3 + 4 >> 2] = 0);
      }
      function Y0(A3, r3) {
        q[A3 + 8 >> 2] = 0, q[A3 >> 2] = 0, q[A3 + 4 >> 2] = 0, g0(A3, r3);
      }
      function H(A3) {
        return (32 | A3) - 97 >>> 0 < 26 ? 1 : 0 != (A3 - 48 >>> 0 < 10 | 0);
      }
      function l0(A3, r3) {
        return (A3 = c2(r3 = k2(A3, r3))) && Z0(A3, r3), A3;
      }
      function y(A3) {
        return A3 - 65 >>> 0 < 26 ? 32 | A3 : A3;
      }
      function U(A3) {
        return 32 == (0 | A3) | A3 - 9 >>> 0 < 5;
      }
      function G(A3) {
        A3 && (Z(q[A3 >> 2]), Z(A3));
      }
      function m(A3, r3) {
        N(A3, r3, k0(r3));
      }
    }(r);
  }, instantiate: function(a2, i2) {
    return { then: function(A) {
      var r = new e.Module(a2);
      A({ k: new e.Instance(r, i2) });
    } };
  }, RuntimeError: Error };
  var b = new e.Memory({ A: 1, t: 256 });
  var t = new Uint8Array(b.buffer);
  e.instantiate({}.wasm, { a: { b: function(A) {
    var r = t.length;
    if (!(16777216 < (A >>>= 0))) for (var a2 = 1; a2 <= 4; a2 *= 2) {
      var i2 = Math.min(i2 = r * (1 + 0.2 / a2), A + 100663296), f2 = Math, e2 = f2.min, i2 = Math.max(A, i2);
      i2 += (65536 - i2 % 65536) % 65536;
      A: {
        var n = b.buffer;
        try {
          b.grow(e2.call(f2, 16777216, i2) - n.byteLength + 65535 >>> 16), t = new Uint8Array(b.buffer), i2 = 1;
          break A;
        } catch (A2) {
        }
        i2 = void 0;
      }
      if (i2) return true;
    }
    return false;
  }, a: b } }).then(function(A) {
    o = (A = A.k.exports).d, i = A.e, f = A.f, c = A.i, A.c();
  });
  function markdown(A, r) {
    return a(i, A, r);
  }
  function markdownWiki(A, r) {
    return a(f, A, r);
  }

  // lib/modules/hosts/github.js
  var github_default = new Host("github", {
    domains: ["gist.github.com"],
    logo: "https://assets-cdn.github.com/favicon.ico",
    name: "github gists",
    detect: ({ pathname }) => /^\/(?:[\w-]+\/)?([a-z0-9]{20,}|\d+)/i.exec(pathname),
    async handleLink(href, [, id2]) {
      const { files, description } = await ajax({
        url: `https://api.github.com/gists/${id2}`,
        type: "json",
        cacheFor: DAY
      });
      let src = "";
      for (const [filename, { content, language, truncated }] of Object.entries(files)) {
        src += string_exports.escape`<h5>${filename}:</h5>`;
        if (language === "Markdown") {
          src += markdown(content);
        } else {
          src += string_exports.escape`<pre><code>${content}</code></pre>`;
        }
        if (truncated) {
          src += "<p>&lt;file truncated&gt;</p>";
        }
      }
      return {
        type: "TEXT",
        title: description,
        src
      };
    }
  });

  // lib/modules/hosts/googlemaps.js
  var googlemaps_default = new Host("googlemaps", {
    domains: ["maps.google.ca", "maps.google.com", "google.co.uk", "google.com", "google.ca"],
    logo: "https://maps.google.com/favicon.ico",
    name: "Google Maps",
    detect: ({ host, searchParams, pathname }) => {
      if (host.startsWith("maps.") || pathname.startsWith("/maps")) {
        const coords = searchParams.get("ll") || searchParams.get("q");
        if (coords) {
          return [
            coords,
            searchParams.get("z"),
            searchParams.has("maptype") ? searchParams.get("maptype") : "roadmap"
          ];
        } else {
          const location2 = pathname.split("/").find((part) => part.startsWith("@"));
          if (location2) {
            const [long, lat, zoom] = location2.substring(1).split(",");
            return [
              `${long},${lat}`,
              zoom.endsWith("z") ? zoom : 16,
              // passing a meter zoom level to maps does not make it happy
              zoom.endsWith("z") ? "roadmap" : "satellite"
            ];
          }
        }
      }
    },
    handleLink(href, [coords, zoom, mapType]) {
      let embed = `https://www.google.com/maps/embed/v1/view?center=${coords}&key=AIzaSyCtnLZP1XwkgIK53Asx_5qtZa2k9eZcdDc`;
      if (zoom) embed += `&zoom=${zoom}`;
      if (mapType) embed += `&maptype=${mapType}`;
      return {
        type: "IFRAME",
        embed,
        muted: true
      };
    }
  });

  // lib/modules/hosts/gyazo.js
  var gyazo_default = new Host("gyazo", {
    name: "gyazo",
    domains: ["gyazo.com"],
    permissions: ["https://api.gyazo.com/api/oembed"],
    logo: "https://gyazo.com/favicon.ico",
    detect: ({ pathname }) => /^\/(\w{32})\b/i.exec(pathname),
    async handleLink(href, [, id2]) {
      const info = await ajax({
        url: "https://api.gyazo.com/api/oembed",
        query: { url: href },
        type: "json"
      });
      switch (info.type) {
        case "photo":
          return {
            type: "IMAGE",
            src: info.url
          };
        case "video":
          return {
            type: "VIDEO",
            muted: true,
            loop: true,
            fallback: `https://i.gyazo.com/${id2}.gif`,
            sources: [{
              source: `https://i.gyazo.com/${id2}.mp4`,
              type: "video/mp4"
            }]
          };
        default:
          throw new Error(`Invalid media type: ${info.type}`);
      }
    }
  });

  // lib/modules/hosts/hastebin.js
  var hastebin_default = new Host("hastebin", {
    name: "hastebin",
    domains: ["hastebin.com"],
    attribution: false,
    detect: ({ pathname }) => /^\/(?:raw\/)?([^\/]+)/i.exec(pathname),
    handleLink(href, [, filename]) {
      return {
        type: "IFRAME",
        expandoClass: "selftext",
        muted: true,
        embed: `https://hastebin.com/${filename}`,
        height: "500px",
        width: "800px"
      };
    }
  });

  // lib/modules/hosts/iloopit.js
  var iloopit_default = new Host("iloopit", {
    name: "iLoopit - gif maker",
    domains: ["iloopit.net"],
    logo: "https://iloopit.net/favicon.ico",
    detect: ({ href }) => /^https?:\/\/(\w+\.)?iloopit\.net\/.+?\/\?type=looplayer&loopid=(\d+)/i.exec(href) || /^https?:\/\/(\w+\.)?iloopit\.net(\/tube)?\/(\d+)\/.+?\/(\?type=(looplayer)|(embed))?/i.exec(href),
    handleLink(href) {
      let link = "";
      const testWithTitle = /iloopit\.net(?:\/tube)?\/(\d+)\/(.+)?\//;
      const titleResult = testWithTitle.exec(href);
      if (titleResult) {
        link = `https://iloopit.net/${titleResult[1]}/${titleResult[2]}/?type=embed`;
      } else {
        link = href.replace("type=looplayer", "type=embed");
      }
      return {
        type: "IFRAME",
        muted: true,
        embed: link,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/imgflip.js
  var imgflip_default = new Host("imgflip", {
    name: "imgflip",
    domains: ["imgflip.com"],
    logo: "https://imgflip.com/favicon02.png",
    detect: ({ pathname }) => /^\/(i|gif)\/([a-z0-9]+)/.exec(pathname),
    handleLink(href, [, type, id2]) {
      return {
        type: "IMAGE",
        src: `https://i.imgflip.com/${id2}.${type === "gif" ? "gif" : "jpg"}`
      };
    }
  });

  // lib/modules/hosts/imgur.js
  var imgur_default = new Host("imgur", {
    name: "imgur",
    domains: ["imgur.com"],
    logo: "https://i.imgur.com/favicon.ico",
    options: {
      preferResAlbums: {
        title: "imgurPreferResAlbumsTitle",
        description: "imgurPreferResAlbumsDesc",
        value: true,
        type: "boolean"
      },
      preferredImgurLink: {
        title: "imgurPreferredImgurLinkTitle",
        description: "imgurPreferredImgurLinkDesc",
        type: "enum",
        value: "share",
        values: [{
          name: "full page (imgur.com)",
          value: "share"
        }, {
          name: "direct image (i.imgur.com)",
          value: "direct"
        }]
      },
      imgurImageResolution: {
        title: "imgurImageResolutionTitle",
        description: "imgurImageResolutionDesc",
        type: "enum",
        value: "",
        // image id suffix
        values: [{
          name: "Full Resolution",
          value: ""
        }, {
          name: "Retina (1360px)",
          value: "r"
        }, {
          name: "Huge (1024px)",
          value: "h"
        }, {
          name: "Giant (680px)",
          value: "g"
        }, {
          name: "Large (640px)",
          value: "l"
        }]
      }
    },
    detect({ pathname, href }) {
      const cdnUrl = "https://i.imgur.com/";
      const apiPrefix = "https://api.imgur.com/3/";
      const apiId = "1d8d9b36339e0e2";
      const hashRe = /^https?:\/\/(?:i\.|m\.|edge\.|www\.)*imgur\.com\/(r\/\w+\/)*(?!gallery)(?!removalrequest)(?!random)(?!memegen)((?:\w{5}|\w{7})(?:[&,](?:\w{5}|\w{7}))*)(?:#\d+)?[a-z]?(\.(?:jpe?g|gifv?|png))?(\?.*)?$/i;
      const hostedHashRe = /^https?:(\/\/i\.\w+\.*imgur\.com\/)((?:\w{5}|\w{7})(?:[&,](?:\w{5}|\w{7}))*)(?:#\d+)?[a-z]?(\.(?:jpe?g|gif|png))?(\?.*)?$/i;
      const galleryHashRe = /^https?:\/\/(?:m\.|www\.)?imgur\.com\/gallery\/(?:(\w+)|(?:.*-)(\w+$))(?:[/#]|$)/i;
      const albumHashRe = /^https?:\/\/(?:m\.|www\.)?imgur\.com\/a\/(\w+)(?:[/#]|$)/i;
      if (pathname === "/rules" || pathname === "/inbox") return null;
      href = href.split("?")[0];
      let groups;
      if (groups = galleryHashRe.exec(href)) {
        const hash = groups[2];
        return () => _api(string_exports.encode`gallery/${hash}`).catch(() => _api(string_exports.encode`album/${hash}`));
      } else if (groups = albumHashRe.exec(href)) {
        if (this.options.preferResAlbums.value) {
          const hash = groups[1];
          return () => _api(string_exports.encode`album/${hash}`);
        }
      } else if (groups = hostedHashRe.exec(href)) {
        const hash = groups[2];
        return () => _handleImage(hash, href);
      } else if (groups = hashRe.exec(href)) {
        const [, subreddit2, hash] = groups;
        if (subreddit2) return () => _api(string_exports.encode`gallery/${subreddit2}${hash}`);
        if (hash.search(/[&,]/) > -1) {
          return () => _handleImageCollection(hash.split(/[&,]/), href);
        } else {
          return () => _handleImage(hash, href);
        }
      }
      return false;
      async function _api(endpoint) {
        const { data: data2 } = await ajax({
          url: apiPrefix + endpoint,
          type: "json",
          headers: {
            Authorization: `Client-ID ${apiId}`
          }
        });
        if (data2.error) {
          throw new Error(`Imgur API error: ${data2.error}`);
        }
        return data2;
      }
      function _mockImageAPI(hash, url) {
        let thisCdnUrl = cdnUrl;
        let matches2, extension;
        if (matches2 = hostedHashRe.exec(url)) {
          thisCdnUrl = matches2[1];
          extension = matches2[3];
        } else if (matches2 = hashRe.exec(url)) {
          extension = matches2[3];
        }
        if (!extension) {
          extension = ".jpg";
        }
        return {
          id: hash,
          animated: false,
          looping: false,
          has_sound: false,
          link: `${thisCdnUrl}${hash}${extension}`,
          type: `image/${extension}`,
          title: "",
          description: ""
        };
      }
      function _handleImage(hash, url) {
        const [, , , extension] = hashRe.exec(url) || [];
        if ([".png", ".jpg", ".jpeg"].includes(extension)) {
          return _mockImageAPI(hash, url);
        } else if (hostedHashRe.test(url)) {
          return _mockImageAPI(hash, url);
        } else {
          return _api(`image/${hash}`);
        }
      }
      function _handleImageCollection(hashes, url) {
        return {
          is_album: true,
          images: hashes.map((hash) => _mockImageAPI(hash, url)),
          title: "",
          description: "",
          type: ""
        };
      }
    },
    async handleLink(href, getInfo) {
      const baseUrl = "https://imgur.com/";
      const shareLinkPreferred = this.options.preferredImgurLink.value === "share";
      const resolutionSuffix = this.options.imgurImageResolution.value;
      const info = await getInfo();
      if (info.is_album) {
        return _handleAlbum(href, info);
      } else if (info.type.startsWith("video/")) {
        return _handleSingleVideo(info);
      } else if (info.link) {
        return _handleSingleImage(info);
      }
      throw new Error("could not handle info");
      function _handleAlbum(href2, info2) {
        return {
          type: "GALLERY",
          title: info2.title,
          caption: info2.description,
          src: info2.images.map((info3) => {
            const media = info3.type.startsWith("video/") ? _handleSingleVideo(info3) : _handleSingleImage(info3);
            media.href = shareLinkPreferred ? `${href2.split("#")[0]}#${info3.id}` : `${info3.link}`;
            return media;
          })
        };
      }
      function _handleSingleImage(info2) {
        const src = info2.link.replace(`/${info2.id}.`, `/${info2.id}${resolutionSuffix}.`);
        return {
          src,
          href: shareLinkPreferred ? `${baseUrl}${info2.id}` : `${info2.link}`,
          type: "IMAGE",
          caption: info2.description,
          title: info2.title
        };
      }
      function _handleSingleVideo(info2) {
        return {
          type: "VIDEO",
          href: shareLinkPreferred ? `${baseUrl}${info2.id}` : `${info2.link}`,
          fallback: info2.link,
          caption: info2.description,
          title: info2.title,
          loop: info2.looping !== false,
          // may be missing from API responses (randomly), so explicitly check for false
          muted: !info2.has_sound,
          sources: [{
            source: info2.link,
            type: info2.type
          }]
        };
      }
    }
  });

  // lib/modules/hosts/instagram.js
  var instagram_default = new Host("instagram", {
    name: "Instagram",
    domains: ["instagram.com", "instagr.am"],
    attribution: false,
    detect: ({ pathname }) => /^\/p\/([a-z0-9_\-]{10,})(?:\/|$)/i.exec(pathname),
    handleLink: (href, [, id2]) => ({
      type: "IFRAME",
      expandoClass: "image",
      embed: `https://instagram.com/p/${id2}/embed/captioned/`,
      width: "600px",
      height: "700px"
    })
  });

  // lib/modules/hosts/ireddit.js
  var ireddit_default = new Host("ireddit", {
    name: "i.redd.it",
    domains: ["i.redd.it"],
    attribution: false,
    detect({ pathname }, thing) {
      return /\.(webp|gif|jpe?g|png|svg)$/i.test(pathname) && thing && thing.isLinkPost() && thing.getFullname();
    },
    async handleLink(href, fullname) {
      let postMetadata = await getPostMetadata({ id: fullname.replace("t3_", "") });
      if (postMetadata.crosspost_parent_list && postMetadata.crosspost_parent_list.length > 0) {
        postMetadata = postMetadata.crosspost_parent_list[0];
      }
      if (!postMetadata.preview) throw new Error("Post has no preview.");
      const preview = postMetadata.preview.images[0];
      if (preview.variants.mp4) {
        return {
          type: "VIDEO",
          caption: postMetadata.selftext_html && postMetadata.selftext_html.replace(/<\/?p>/g, ""),
          loop: true,
          muted: true,
          fallback: preview.variants.gif && preview.variants.gif.source.url,
          sources: [{
            source: preview.variants.mp4.source.url,
            type: "video/mp4"
          }]
        };
      } else {
        return {
          type: "IMAGE",
          caption: postMetadata.selftext_html && postMetadata.selftext_html.replace(/<\/?p>/g, ""),
          src: preview.source.url
        };
      }
    }
  });

  // lib/modules/hosts/jsfiddle.js
  var jsfiddle_default = new Host("jsfiddle", {
    name: "jsfiddle",
    domains: ["jsfiddle.net"],
    logo: "https://jsfiddle.net/favicon.png",
    detect: ({ pathname }) => /^(\/(?:\w+\/(?!embedded\/))?[a-z0-9]{5,}(?:\/\d+)?(?=\/|$))(\/embedded\/[\w,]+\/)?/i.exec(pathname),
    handleLink(href, [, path, categories]) {
      return {
        type: "IFRAME",
        expandoClass: "selftext",
        muted: true,
        embed: `https://jsfiddle.net${path}${categories || "/embedded/result,js,resources,html,css/"}`,
        width: "800px",
        height: "500px"
      };
    }
  });

  // lib/modules/hosts/liveleak.js
  var liveleak_default = new Host("liveleak", {
    name: "LiveLeak",
    domains: ["liveleak.com"],
    logo: "https://www.liveleak.com/favicon.ico",
    detect: ({ pathname, search }) => pathname === "/view" && search,
    handleLink: (href, query) => ({
      type: "IFRAME",
      embed: `https://www.liveleak.com/ll_embed${query}`,
      embedAutoplay: `https://www.liveleak.com/ll_embed${query}&autostart=true`,
      fixedRatio: true
    })
  });

  // lib/modules/hosts/livememe.js
  var livememe_default = new Host("livememe", {
    name: "livememe",
    domains: ["livememe.com"],
    logo: "https://livememe.com/favicon.ico",
    detect: ({ pathname }) => /^\/(?!edit)(\w{7})(?:\/|$)/i.exec(pathname),
    handleLink(href, [, id2]) {
      return {
        type: "IMAGE",
        src: `https://e.lvme.me/${id2}.jpg`
      };
    }
  });

  // lib/modules/hosts/makeameme.js
  var makeameme_default = new Host("makeameme", {
    name: "makeameme",
    domains: ["makeameme.org"],
    logo: "https://makeameme.org/images/favicons/favicon-32x32.png",
    detect: ({ pathname }) => /^\/meme\/([\w\-]+)/i.exec(pathname),
    handleLink(href, [, id2]) {
      return {
        type: "IMAGE",
        src: `https://makeameme.org/media/created/${id2}.jpg`
      };
    }
  });

  // lib/modules/hosts/memecrunch.js
  var memecrunch_default = new Host("memecrunch", {
    name: "memecrunch",
    domains: ["memecrunch.com"],
    logo: "https://memecrunch.com/static/favicon.ico",
    detect: ({ pathname }) => /^\/meme\/([0-9A-Z]+)\/([\w\-]+)(\/image\.(png|jpg))?/i.exec(pathname),
    handleLink(href, [, id2, format]) {
      return {
        type: "IMAGE",
        src: `https://memecrunch.com/meme/${id2}/${format || "null"}/image.png`
      };
    }
  });

  // lib/modules/hosts/memedad.js
  var memedad_default = new Host("memedad", {
    name: "memedad",
    domains: ["memedad.com"],
    logo: "https://memedad.com/favicon.ico",
    detect: ({ pathname }) => /^\/meme\/([0-9]+)/i.exec(pathname),
    handleLink(href, [, id2]) {
      return {
        type: "IMAGE",
        src: `https://memedad.com/memes/${id2}.jpg`
      };
    }
  });

  // lib/modules/hosts/navertv.js
  var navertv_default = new Host("Naver", {
    name: "Naver",
    domains: ["tv.naver.com"],
    logo: "https://www.naver.com/favicon.ico?1",
    detect: ({ pathname }) => /^\/(?:v)\/([0-9]+)/i.exec(pathname),
    handleLink(href, [, id2]) {
      const embed = `https://tv.naver.com/embed/${id2}`;
      return {
        type: "IFRAME",
        embed,
        embedAutoplay: `${embed}?autoPlay=true`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/onedrive.js
  var onedrive_default = new Host("onedrive", {
    domains: ["onedrive.live.com", "1drv.ms"],
    name: "Microsoft OneDrive",
    detect: () => true,
    async handleLink(href) {
      const encodedUrl = `u!${btoa(href)}`.replace(/=+$/g, "").replace(/\//g, "_").replace(/\+/g, "-");
      const json = await ajax({
        url: `https://api.onedrive.com/v1.0/shares/${encodedUrl}/root?expand=children`,
        type: "json",
        cacheFor: DAY
      });
      if (json.children.length) {
        return {
          type: "GALLERY",
          src: json.children.map(processFile)
        };
      } else {
        return processFile(json);
      }
      function processFile({
        name: name2,
        description,
        webUrl,
        "@content.downloadUrl": src,
        file: { mimeType }
      }) {
        const type = mimeType.slice(0, mimeType.indexOf("/"));
        switch (type) {
          case "image":
            return {
              type: "IMAGE",
              title: name2,
              caption: description,
              src,
              href: webUrl
            };
          case "video":
            return {
              type: "VIDEO",
              title: name2,
              caption: description,
              loop: false,
              sources: [{
                source: src,
                type: mimeType
              }]
            };
          case "audio":
            return {
              type: "AUDIO",
              loop: false,
              sources: [{
                file: src,
                type: mimeType
              }]
            };
          default:
            throw new Error(`Invalid type: ${type}`);
        }
      }
    }
  });

  // lib/modules/hosts/pastebin.js
  var pastebin_default = new Host("pastebin", {
    name: "pastebin",
    domains: ["pastebin.com"],
    attribution: false,
    detect: ({ href }) => /^https?:\/\/(?:www\.)?pastebin\.com\/(?:raw\.php\?i=|index\/)?([a-z0-9]{8})/i.exec(href),
    handleLink(href, [, id2]) {
      return {
        type: "IFRAME",
        expandoClass: "selftext",
        muted: true,
        embed: `https://pastebin.com/embed_iframe.php?i=${id2}`,
        height: "500px",
        width: "700px"
      };
    }
  });

  // lib/modules/hosts/peertube.js
  var peertube_default = new Host("peertube", {
    name: "peertube",
    domains: [
      "peervideo.net",
      "peertube.social",
      "peertube.mastodon.host",
      "evertron.tv",
      "mplayer.demouliere.eu",
      "cloud.allplayer.tk",
      "video.tedomum.net",
      "peertube.fr",
      "hostyour.tv",
      "videobit.cc",
      "videoshare.cc",
      "peertube.openstreetmap.fr",
      "video.ploud.fr",
      "tube.kdy.ch",
      "lostpod.space",
      "pe.ertu.be",
      "peertube.live",
      "peer.tube",
      "watching.cypherpunk.observer",
      "queertube.org",
      "exode.me",
      "framatube.org",
      "peervideo.net"
    ],
    attribution: false,
    detect: ({ hostname, pathname }) => {
      const [, route, , id2] = pathname.split("/");
      if (route === "videos") {
        return [hostname, id2];
      }
    },
    handleLink(href, [hostname, id2]) {
      const embed = `https://${hostname}/videos/embed/${id2}`;
      return {
        type: "IFRAME",
        embed,
        embedAutoplay: `${embed}?autoplay=true`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/photobucket.js
  var photobucket_default = new Host("photobucket", {
    name: "photobucket",
    domains: ["photobucket.com"],
    logo: "https://pic2.pbsrc.com/common/favicon.ico",
    detect: ({ href }) => /([is]?)[0-9]+|media|smg|img(?=.photobucket.com)/i.exec(href),
    async handleLink(href, [, prefix]) {
      let src = href.replace(".html", "");
      if (prefix !== "i") {
        const { imageUrl } = await ajax({
          url: "https://api.photobucket.com/v2/media/fromurl",
          query: { url: src },
          type: "json"
        });
        src = imageUrl.replace("http:", "https:");
      }
      return {
        type: "IMAGE",
        src
      };
    }
  });

  // lib/modules/hosts/pixiv.js
  var pixiv_default = new Host("pixiv", {
    name: "pixiv",
    domains: ["pixiv.net"],
    logo: "https://www.pixiv.net/favicon.ico",
    detect: ({ pathname, search }) => pathname === "/member_illust.php" && /illust_id=(\d+)/.exec(search) || /(?:\/en|^)\/artworks\/(\d+)\/?$/.exec(pathname),
    handleLink(href, [, id2]) {
      return {
        type: "IFRAME",
        expandoClass: "image",
        muted: true,
        embed: `https://embed.pixiv.net/embed_mk2.php?id=${id2}&size=large`,
        width: "700px",
        height: "700px"
      };
    }
  });

  // lib/modules/hosts/poly.js
  var poly_default = new Host("poly", {
    name: "Poly",
    domains: ["poly.google.com"],
    // Embed already contains attribution
    attribution: false,
    detect: ({ pathname }) => /^\/view\/([a-zA-Z0-9-]+)\/?$/i.exec(pathname),
    handleLink(href, [, id2]) {
      return {
        type: "IFRAME",
        embed: `https://poly.google.com/view/${id2}/embed`
      };
    }
  });

  // lib/modules/hosts/pornhub.js
  var pornhub_default = new Host("pornhub", {
    name: "Pornhub",
    domains: [
      "www.pornhub.com",
      "www.pornhubpremium.com"
    ],
    attribution: false,
    detect: ({ searchParams }) => searchParams.get("viewkey"),
    handleLink(href, path) {
      const url = `https://www.pornhub.com/embed/${path}`;
      return {
        type: "IFRAME",
        embed: url,
        embedAutoplay: `${url}?autoplay=1`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/ppy.js
  var ppy_default = new Host("ppy.sh", {
    name: "ppy.sh",
    domains: ["osu.ppy.sh"],
    logo: "https://s.ppy.sh/favicon.ico",
    detect: ({ pathname }) => /^\/ss\/(\d+(?:\/[0-9a-f]+)?)/i.exec(pathname),
    handleLink(href, [, code]) {
      return {
        type: "IMAGE",
        src: `https://osu.ppy.sh/ss/${code}`
      };
    }
  });

  // lib/modules/hosts/redditbooru.js
  var redditbooru_default = new Host("redditbooru", {
    name: "redditbooru",
    domains: ["redditbooru.com"],
    logo: "https://redditbooru.com/favicon.ico",
    detect: ({ pathname }) => /^\/gallery\/([\w]+)(\/[\w\-]+)?/i.exec(pathname),
    async handleLink(href, [, id2, base36]) {
      if (base36) {
        id2 = parseInt(id2, 36);
      }
      const info = await ajax({
        url: "https://redditbooru.com/images/",
        query: { postId: id2 },
        type: "json"
      });
      if (!info.length) {
        throw new Error("Gallery was empty.");
      }
      const src = info.map(({ caption, cdnUrl, sourceUrl: sourceUrl2 }) => ({
        type: "IMAGE",
        title: caption,
        src: cdnUrl,
        caption: sourceUrl2 ? `Source: <a href="${sourceUrl2}">${sourceUrl2}</a>` : ""
      }));
      return {
        type: "GALLERY",
        title: info[0].title,
        src
      };
    }
  });

  // lib/modules/hosts/redditgallery.js
  var redditgallery_default = new Host("redditgallery", {
    name: "redditgallery",
    domains: ["reddit.com"],
    attribution: false,
    detect({ pathname }) {
      return pathname.match(/^\/gallery\/(\w+)/);
    },
    async handleLink(href, [, id2]) {
      const {
        media_metadata = {},
        selftext_html,
        gallery_data: {
          items: items2 = []
        } = {}
      } = await getPostMetadata({ id: id2 });
      const pieces = filterMap(items2, ({ media_id, caption }) => {
        const { m } = media_metadata[media_id] || {};
        const type = m.startsWith("image") ? "IMAGE" : "Unknown";
        return type === "IMAGE" ? [{ type, caption, src: `https://i.redd.it/${media_id}.${m.substr(6)}` }] : void 0;
      });
      if (!pieces.length) throw new Error("Gallery has no valid pieces.");
      return { type: "GALLERY", src: pieces, caption: selftext_html && selftext_html.replace(/<\/?p>/g, "") };
    }
  });

  // lib/modules/hosts/redditmedia.js
  var redditmedia_default = new Host("redditmedia", {
    name: "redditmedia",
    domains: ["redditmedia.com"],
    attribution: false,
    detect: ({ hostname, searchParams }) => hostname !== "pixel.redditmedia.com" && searchParams,
    handleLink(href, searchParams) {
      if (searchParams.get("fm") === "mp4") {
        return {
          type: "VIDEO",
          loop: true,
          muted: true,
          sources: [{
            source: href,
            type: "video/mp4"
          }]
        };
      }
      return {
        type: "IMAGE",
        src: href
      };
    }
  });

  // lib/modules/hosts/redditpoll.js
  var redditpoll_default = new Host("redditpoll", {
    name: "redditpoll",
    domains: ["reddit.com"],
    attribution: false,
    detect({ pathname }) {
      return pathname.match(/^\/poll\/(\w+)/);
    },
    handleLink(href, [, id2]) {
      return {
        type: "IFRAME",
        expandoClass: "selftext",
        embed: `https://www.reddit.com/poll/${id2}`,
        height: "500px",
        width: "700px"
      };
    }
  });

  // lib/modules/hosts/reddituploads.js
  var reddituploads_default = new Host("reddituploads", {
    name: "reddituploads",
    domains: ["reddituploads.com"],
    attribution: false,
    detect: () => true,
    handleLink(href) {
      return {
        type: "IMAGE",
        src: href
      };
    }
  });

  // lib/modules/hosts/redgifs.js
  var redgifs_default = new Host("redgifs", {
    name: "redgifs",
    domains: ["redgifs.com"],
    logo: "https://redgifs.com/assets/favicon.ico",
    detect: ({ pathname }) => /^\/(?:(?:ifr|watch)\/)(\w+)/i.exec(pathname),
    async handleLink(href, [, id2]) {
      const embed = `https://redgifs.com/ifr/${id2}`;
      try {
        const info = (await ajax({
          url: string_exports.encode`https://api.redgifs.com/v1/gfycats/${id2}`,
          type: "json",
          cacheFor: DAY
        })).gfyItem;
        let height = info.height;
        let width = info.width;
        const ratio = width / height;
        const maxSize = 600;
        if (height > width) {
          height = Math.min(height, maxSize);
          width = parseInt(ratio * height, 10);
        } else {
          width = Math.min(width, maxSize);
          height = parseInt(width / ratio, 10);
        }
        return {
          type: "IFRAME",
          embed: `${embed}?autoplay=0`,
          embedAutoplay: embed,
          fixedRatio: false,
          width: `${width}px`,
          height: `${height}px`,
          muted: true
        };
      } catch (error) {
        return {
          type: "IFRAME",
          embed: `${embed}?autoplay=0`,
          embedAutoplay: embed,
          fixedRatio: true,
          muted: true
        };
      }
    }
  });

  // lib/modules/hosts/ridewithgps.js
  var ridewithgps_default = new Host("ridewithgps", {
    name: "ridewithgps",
    domains: ["ridewithgps.com"],
    attribution: false,
    detect: ({ pathname }) => /^\/(trips|routes)\/(\d+)/i.exec(pathname),
    handleLink(href, [, type, id2]) {
      return {
        type: "IFRAME",
        embed: `https://ridewithgps.com/${type}/${id2}/embed`
      };
    }
  });

  // lib/modules/hosts/simplecove.js
  var simplecove_default = new Host("simplecove", {
    name: "SimpleCove",
    domains: ["simplecove.com"],
    logo: "https://simplecove.com/static/images/reslogo.jpg",
    detect: ({ pathname }) => /^\/(\d+)/i.exec(pathname),
    async handleLink(elem, [, id2]) {
      const data2 = await ajax({
        url: `https://www.simplecove.com/resapi/${id2}`,
        type: "json"
      });
      const images = data2.map((x) => ({
        src: x.photo_src.replace("http:", "https:"),
        caption: x.photo_caption,
        type: "IMAGE"
      }));
      return {
        type: "GALLERY",
        src: images
      };
    }
  });

  // lib/modules/hosts/snag.js
  var snag_default = new Host("snag", {
    name: "snag.gy",
    logo: "https://snaggys3static-snaggy.netdna-ssl.com/favicon.png",
    domains: ["snag.gy"],
    detect: ({ pathname }) => /^\/(\w+)(?:\.(\w+))?$/i.exec(pathname),
    handleLink(href, [, id2, extension]) {
      return {
        type: "IMAGE",
        src: `https://i.snag.gy/${id2}.${extension || "jpg"}`
      };
    }
  });

  // lib/modules/hosts/soundcloud.js
  var soundcloud_default = new Host("soundcloud", {
    name: "soundcloud",
    domains: ["soundcloud.com"],
    logo: "https://a-v2.sndcdn.com/assets/images/sc-icons/favicon-2cadd14b.ico",
    detect: () => true,
    handleLink(href) {
      return {
        type: "IFRAME",
        embed: string_exports.encode`https://w.soundcloud.com/player/?url=${href}`,
        height: "166px",
        width: "700px",
        pause: '{"method":"pause"}',
        play: '{"method":"play"}'
      };
    }
  });

  // lib/modules/hosts/spotify.js
  var spotify_default = new Host("spotify", {
    name: "spotify",
    domains: ["spotify.com"],
    logo: "https://spotify.com/favicon.ico",
    /*
    * Match the following:
    * https://open.spotify.com/track/id
    * https://play.spotify.com/artist/id
    * https://play.spotify.com/album/id
    * https://open.spotify.com/user/someUser/playlist/id
    * TODO: Check username restrictions, match with something better than \w+
    */
    detect: ({ href }) => /^https:\/\/(?:open|play)\.spotify\.com\/((?:track|artist|album|user\/\w+\/playlist)\/[a-zA-z0-9]+)$/i.exec(href),
    handleLink(href, [, uri]) {
      return {
        type: "IFRAME",
        embed: `https://embed.spotify.com/?uri=spotify:${uri.replace(/\//g, ":")}`
      };
    }
  });

  // lib/modules/hosts/steamcommunity.js
  var steamcommunity_default = new Host("steamcommunity", {
    name: "Steam Community",
    logo: "https://store.steampowered.com/favicon.ico",
    domains: ["steamcommunity.com"],
    detect: ({ pathname, searchParams }) => pathname.startsWith("/sharedfiles/filedetails") && searchParams.get("id"),
    permissions: ["https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/*"],
    async handleLink(href, id2) {
      const {
        response: {
          publishedfiledetails: [{
            title,
            description: caption,
            preview_url: previewUrl,
            file_url: fileUrl,
            filename
          }]
        }
      } = await ajax({
        method: "POST",
        url: "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v0001/?format=json",
        data: { itemcount: "1", "publishedfileids[0]": id2 },
        type: "json"
      });
      if (!filename) throw new Error("Response missing filename. (Private Steam Community profile?)");
      return {
        type: "IMAGE",
        title,
        caption,
        src: [".png", ".jpg", ".gif"].some((ext) => filename.endsWith(ext)) ? fileUrl : previewUrl
      };
    }
  });

  // lib/modules/hosts/steampowered.js
  var steampowered_default = new Host("steampowered", {
    name: "Steam",
    logo: "https://store.steampowered.com/favicon.ico",
    domains: ["steampowered.com", "steamusercontent.com"],
    detect: ({ pathname }) => /^\/ugc\/(\d{15,20}\/\w{40})(?:$|\/)/i.exec(pathname),
    handleLink(href, [pathname]) {
      return {
        type: "IMAGE",
        src: `http://images.akamai.steamusercontent.com${pathname}`
      };
    }
  });

  // lib/modules/hosts/strawpollcom.js
  var strawpollcom_default = new Host("strawpoll.com", {
    name: "strawpoll.com",
    domains: ["strawpoll.com"],
    attribution: false,
    detect: ({ pathname }) => /^\/(?:embed\/)?([a-z0-9]+)/i.exec(pathname),
    handleLink(href, [, id2]) {
      return {
        type: "IFRAME",
        expandoClass: "selftext",
        muted: true,
        embed: `https://strawpoll.com/embed/${id2}`,
        height: "450px",
        width: "700px"
      };
    }
  });

  // lib/modules/hosts/strawpollme.js
  var strawpollme_default = new Host("strawpoll", {
    name: "strawpoll.me",
    domains: ["strawpoll.me"],
    attribution: false,
    detect: ({ pathname }) => /^\/(?:embed_\d\/)?(\d+)/i.exec(pathname),
    handleLink(href, [, uid]) {
      return {
        type: "IFRAME",
        expandoClass: "selftext",
        muted: true,
        embed: `https://www.strawpoll.me/embed_1/${uid}`,
        height: "500px",
        width: "700px"
      };
    }
  });

  // lib/modules/hosts/streamable.js
  var streamable_default = new Host("streamable", {
    name: "streamable",
    domains: ["streamable.com"],
    logo: "https://cdn-e2.streamable.com/static/14a98f7cb1ddc5213329c039dc39cac543ba410f/img/favicon.ico",
    detect: ({ pathname }) => /^\/(?:[es]\/)?(\w+)(?:\/\w+)?$/i.exec(pathname),
    async handleLink(href, [, hash]) {
      const {
        title,
        files: { mp4: { url } },
        thumbnail_url: thumbnail,
        source
      } = await ajax({
        url: `https://api.streamable.com/videos/${hash}`,
        type: "json"
      });
      return {
        type: "VIDEO",
        title,
        loop: true,
        sources: [{
          source: url,
          type: "video/mp4"
        }],
        poster: thumbnail,
        source
      };
    }
  });

  // lib/modules/hosts/streamja.js
  var streamja_default = new Host("streamja", {
    name: "streamja",
    domains: ["streamja.com"],
    logo: "https://streamja.com/favicon.ico",
    detect: ({ pathname }) => /^\/([^\/]+)$/i.exec(pathname),
    handleLink(href, [, code]) {
      const embed = `https://streamja.com/embed/${code}`;
      return {
        type: "IFRAME",
        embed,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/streamvi.js
  var streamvi_default = new Host("streamvi", {
    name: "streamvi",
    domains: ["streamvi.com"],
    logo: "https://streamvi.com/assets/logo.png",
    detect: ({ searchParams }) => {
      const code = searchParams.get("video");
      if (code) return [code.toString()];
    },
    handleLink(href, [code]) {
      return {
        type: "VIDEO",
        loop: true,
        sources: [{
          source: `https://cdn.streamvi.com/uploads/${code}.mp4`,
          type: "video/mp4"
        }],
        poster: `https://cdn.streamvi.com/uploads/${code}.jpg`
      };
    }
  });

  // lib/modules/hosts/streamwo.js
  var streamwo_default = new Host("streamwo", {
    name: "streamwo",
    domains: ["streamwo.com"],
    logo: "https://streamwo.com/favicon.png",
    detect: ({ pathname }) => /^\/([^\/]+)$/i.exec(pathname),
    handleLink(href, [, code]) {
      return {
        type: "VIDEO",
        loop: true,
        sources: [{
          source: `https://playbain.com/${code}.mp4`,
          type: "video/mp4"
        }]
      };
    }
  });

  // lib/modules/hosts/supgif.js
  var supgif_default = new Host("supgif", {
    name: "Supgif",
    domains: ["supgif.com"],
    attribution: false,
    detect: ({ pathname }) => /^\/c\/([\w\-]+)/i.exec(pathname),
    handleLink(href, [, id2]) {
      return {
        type: "IFRAME",
        embed: `https://www.supgif.com/embed/${id2}`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/supload.js
  var supload_default = new Host("supload", {
    name: "supload",
    domains: ["supload.com"],
    logo: "https://supload.com/favicon.ico",
    detect: ({ pathname }) => /^\/([A-Za-z0-9_-]+)/i.exec(pathname),
    async handleLink(href, [, id2]) {
      const data2 = await ajax({
        url: "https://www.supload.com/oembed",
        query: { url: `https://supload.com/${id2}`, format: "json" },
        type: "json",
        cacheFor: DAY
      });
      if (data2.type === "photo") {
        return {
          type: "IMAGE",
          src: data2.url
        };
      } else {
        return {
          type: "VIDEO",
          loop: true,
          muted: true,
          sources: [{
            source: data2.webmUrl,
            type: "video/webm"
          }, {
            source: data2.mp4Url,
            type: "video/mp4"
          }]
        };
      }
    }
  });

  // lib/modules/hosts/tenor.js
  var tenor_default = new Host("tenor", {
    name: "tenor",
    domains: ["tenor.co"],
    logo: "https://www.tenor.co/favicon.ico",
    detect: (() => {
      const alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      const alphabetMap = alphabet.split("").reduce((obj, c2, i2) => {
        obj[c2] = i2;
        return obj;
      }, {});
      function parseViewShortId(s) {
        return s.split("").reduce((n, c2) => n * alphabet.length + alphabetMap[c2], 0);
      }
      return ({ hostname, pathname }) => {
        if (hostname === "tenor.co") {
          const pathMatch = /^\/([a-zA-Z0-9]+)\.gif$/i.exec(pathname);
          return pathMatch && { id: parseViewShortId(pathMatch[1]) };
        } else if (hostname === "media.tenor.co") {
          return { id: null };
        } else {
          const pathMatch = /^\/view\/.+\-(\d+)(\.gif)?$/i.exec(pathname);
          return pathMatch && { id: pathMatch[1] };
        }
      };
    })(),
    async handleLink(href, { id: id2 }) {
      if (id2 === null) {
        return {
          type: "IMAGE",
          src: href
        };
      }
      const { results: [gif] } = await ajax({
        url: "https://api.tenor.co/v1/gifs",
        query: { key: "JJHDC7UK73EH", ids: id2 },
        type: "json"
      });
      return {
        type: "IMAGE",
        src: gif.media[0].gif.url,
        title: gif.h1_title,
        caption: gif.generatedcaption
      };
    }
  });

  // lib/modules/hosts/tuckbot.js
  var tuckbot_default = new Host("tuckbot", {
    name: "TuckBot.tv",
    domains: ["tuckbot.tv"],
    attribution: false,
    // sample URL: https://tuckbot.tv/#/watch/gq09xf
    detect: ({ hostname, hash }) => {
      const [, route, redditPostId] = hash.split("/");
      if (route === "watch") return [hostname, redditPostId];
    },
    handleLink(_href, [, id2]) {
      return {
        type: "IFRAME",
        embed: `https://tuckbot.tv/#/embed/${id2}`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/tumblr.js
  var tumblr_default = new Host("tumblr", {
    name: "tumblr",
    domains: ["tumblr.com"],
    permissions: ["https://api.tumblr.com/v2/blog/*/posts"],
    logo: "https://secure.assets.tumblr.com/images/favicons/favicon.ico",
    detect({ hostname, pathname }) {
      const pathMatch = /^\/(?:post|image)\/(\d+)(?:\/|$)/i.exec(pathname);
      return pathMatch && [hostname, pathMatch[1]];
    },
    async handleLink(href, [blog, id2]) {
      const { response } = await ajax({
        url: `https://api.tumblr.com/v2/blog/${blog}/posts`,
        query: {
          api_key: "WeJQquHCAasi5EzaN9jMtIZkYzGfESUtEvcYDeSMLICveo3XDq",
          id: id2,
          filter: "raw"
        },
        type: "json"
      });
      const post = response.posts[0];
      function render(string) {
        return post.format === "markdown" ? markdown(string) : string;
      }
      const defaults2 = {
        title: post.title,
        caption: post.caption,
        credits: `Posted by: <a href="${response.blog.url}">${response.blog.name}</a> @ Tumblr`
      };
      switch (post.type) {
        case "photo":
          if (!post.photos.length) throw new Error("No images in gallery.");
          return {
            type: "GALLERY",
            ...defaults2,
            src: post.photos.map((photo) => ({
              type: "IMAGE",
              src: photo.original_size.url,
              caption: photo.caption
            }))
          };
        case "text":
          return {
            type: "TEXT",
            ...defaults2,
            src: render(post.body)
          };
        case "quote":
          return {
            type: "TEXT",
            ...defaults2,
            credits: post.source,
            src: `<blockquote><p>${render(post.text)}</p></blockquote>`
          };
        case "link":
          return {
            type: "TEXT",
            ...defaults2,
            title: `<a href="${post.url}">${post.title}</a>`,
            src: render(post.description)
          };
        case "chat":
          return {
            type: "TEXT",
            ...defaults2,
            src: post.dialogue.reduce((prev, { label, phrase }) => `${prev}<blockquote><p><b>${label}</b> ${phrase}</p></blockquote>`, "")
          };
        case "answer":
          const asking = post.asking_url ? `<a href="${post.asking_url}">${post.asking_name}</a>` : post.asking_name;
          return {
            type: "TEXT",
            ...defaults2,
            src: `<blockquote><p>${asking} sent: ${post.question}</p></blockquote>${render(post.answer)}`
          };
        default:
          throw new Error(`Unsupported post type: ${post.type}`);
      }
    }
  });

  // lib/modules/hosts/twimg.js
  var twimg_default = new Host("twimg", {
    name: "twimg",
    domains: ["pbs.twimg.com"],
    logo: "https://twitter.com/favicon.ico",
    detect: ({ pathname }) => /^\/media\/[\w\-]+\.\w+/i.test(pathname),
    handleLink(href) {
      return {
        type: "IMAGE",
        src: href
      };
    }
  });

  // lib/modules/hosts/twitch.js
  var twitch_default = new Host("twitch", {
    name: "twitch.tv",
    domains: ["twitch.tv"],
    logo: "https://www.twitch.tv/favicon.ico",
    detect: ({ href }) => /^https?:\/\/(?:www\.)?twitch\.tv\/(\w+)(?:\/([cbv])\/([0-9]+))?\/?(?:\?t=(?:([0-9]+)h)?(?:([0-9]+)m)?(?:([0-9]+)s)?)?$/i.exec(href),
    handleLink(href, [, channel, typeId, videoId, h, m, s]) {
      const channelOrVideo = videoId ? `video=${typeId.replace("b", "a")}${videoId}` : `channel=${channel}`;
      const embed = `https://player.twitch.tv/?${channelOrVideo}&parent=${location.hostname}&time=${+h || 0}h${+m || 0}m${+s || 0}s`;
      return {
        type: "IFRAME",
        embed: `${embed}&autoplay=false`,
        embedAutoplay: `${embed}&autoplay=true`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/twitchclips.js
  var twitchclips_default = new Host("twitchclips", {
    name: "twitch.tv clips",
    domains: ["twitch.tv"],
    logo: "https://www.twitch.tv/favicon.ico",
    // clips.twitch.tv domain:
    // 	 require capital first character for old-style URLs to avoid ambiguity
    //   old: /username/NameOfClip
    //   new: /NameOfClip
    //        /NameOfClip/edit (bad link to private edit page, but Twitch redirects so we should handle it)
    //        /NameOfClip-aBc123dEf
    //        /NameOfClip-aBc123dEf-gHi456jKl (there are clips with more than one sets of hyphen groups)
    //        /NameOfClip-aBc123dEf--gHi456jKl- (hyphens may appear more than once, and can appear at the end)
    // (www.)twitch.tv domain:
    //   support clip name as a subcomponent of a channel URL
    //   ex: www.twitch.tv/<CHANNEL_NAME>/clip/<CLIP_NAME>
    detect: ({ hostname, pathname }) => hostname === "clips.twitch.tv" ? /^\/(\w+(?:\/[A-Z]\w+)?(?:[\-\w]*))(?:\/|$)/.exec(pathname) : /^\/\w+\/clip\/(\w+(?:\/[A-Z]\w+)?(?:[\-\w]*))(?:\/|$)/.exec(pathname),
    handleLink(href, [, clipId]) {
      const embed = `https://clips.twitch.tv/embed?clip=${clipId}&parent=${location.hostname}`;
      return {
        type: "IFRAME",
        embed: `${embed}&autoplay=false`,
        embedAutoplay: `${embed}&autoplay=true`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/twitter.js
  var import_jquery6 = __toESM(require_jquery(), 1);
  var twitter_default = new Host("twitter", {
    name: "twitter",
    domains: ["twitter.com", "x.com"],
    permissions: ["https://publish.twitter.com/oembed"],
    attribution: false,
    detect: ({ href }) => /^https?:\/\/(?:mobile\.)?(twitter|x)\.com\/(?:#!\/)?[\w]+\/status\/?[\w]+/i.exec(href.replace("x.com", "twitter.com")),
    async handleLink(href, [url]) {
      const { html: html2 } = await ajax({
        url: "https://publish.twitter.com/oembed",
        query: { url, omit_script: true },
        type: "json"
      });
      const $dummy = (0, import_jquery6.default)("<div>");
      return {
        type: "GENERIC_EXPANDO",
        muted: true,
        expandoClass: "selftext",
        generate: () => $dummy[0],
        onAttach: () => {
          $dummy.html(html2);
        }
      };
    }
  });

  // lib/modules/hosts/vidble.js
  var vidble_default = new Host("vidble", {
    name: "vidble",
    domains: ["vidble.com"],
    logo: "https://vidble.com/assets/ico/favicon.ico",
    detect: ({ pathname }) => /^\/(show|album)\/([a-z0-9]+)/i.exec(pathname),
    async handleLink(href, [, type, hash]) {
      switch (type) {
        case "show":
          return {
            type: "IMAGE",
            src: `https://vidble.com/${hash}_med.jpg`
          };
        case "album":
          const urlObj = new URL(href);
          const { pics } = await ajax({
            url: string_exports.encode`https://vidble.com/album/album/${hash}?json=1`,
            type: "json"
          });
          if (!pics.length) throw new Error("No images in gallery.");
          const src = pics.map((src2, i2) => {
            urlObj.hash = `#pic_${i2}`;
            return {
              type: "IMAGE",
              src: src2,
              href: urlObj.href
            };
          });
          return {
            type: "GALLERY",
            src
          };
        default:
          throw new Error(`This should never happen. Invalid type: ${type}`);
      }
    }
  });

  // lib/modules/hosts/vimeo.js
  var vimeo_default = new Host("vimeo", {
    name: "vimeo",
    domains: ["vimeo.com"],
    attribution: false,
    detect: ({ pathname }) => /^\/([0-9]+)(?:\/|$)/i.exec(pathname),
    handleLink(href, [, id2]) {
      const embed = `https://player.vimeo.com/video/${id2}`;
      return {
        type: "IFRAME",
        embed,
        embedAutoplay: `${embed}?autoplay=true`,
        pause: '{"method":"pause"}',
        play: '{"method":"play"}',
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/vlipsy.js
  var vlipsy_default = new Host("vlipsy", {
    name: "Vlipsy",
    domains: ["vlipsy.com"],
    logo: "https://vlipsy.com/favicon.ico",
    detect: ({ pathname }) => /^\/vlip\/(?:\w+-)*(\w+)$/.exec(pathname),
    handleLink(href, [, id2]) {
      return {
        type: "IFRAME",
        embed: `https://vlipsy.com/embed/${id2}`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/vlive.js
  var vlive_default = new Host("vlive", {
    name: "VLive",
    domains: ["vlive.tv"],
    logo: "https://www.vlive.tv/favicon.ico",
    detect: ({ pathname }) => /^\/(?:video)\/([0-9]+)/i.exec(pathname),
    handleLink(href, [, id2]) {
      const embed = `https://vlive.tv/embed/${id2}`;
      return {
        type: "IFRAME",
        embed,
        embedAutoplay: `${embed}?autoPlay=true`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/vreddit.js
  var vreddit_default = new Host("vreddit", {
    name: "v.redd.it",
    domains: ["v.redd.it"],
    permissions: ["https://*.redd.it/*"],
    attribution: false,
    options: {
      forceReplaceNativeExpando: {
        title: "showImagesForceReplaceNativeExpandoTitle",
        description: "showImagesForceReplaceNativeExpandoDesc",
        value: false,
        type: "boolean"
      },
      minimumVideoBandwidth: {
        title: "showImagesVredditMinimumVideoBandwidthTitle",
        description: "showImagesVredditMinimumVideoBandwidthDesc",
        value: "3000",
        // In kB/s
        type: "text",
        advanced: true
      }
    },
    detect({ pathname }, thing) {
      return thing && { fullname: thing.getFullname(), id: pathname.slice(1) };
    },
    async handleLink(href, { fullname, id: id2 }) {
      const originalPlaylistUrl = `https://v.redd.it/${id2}/DASHPlaylist.mpd`;
      const mpd = await ajax({ url: originalPlaylistUrl });
      const manifest = new DOMParser().parseFromString(mpd, "text/xml");
      const minBandwidth = parseInt(this.options.minimumVideoBandwidth.value, 10) * 1e3;
      const reps = Array.from(manifest.querySelectorAll("Representation[frameRate]"));
      const videoSourcesByBandwidth = sortBy_default(reps, (rep) => parseInt(rep.getAttribute("bandwidth"), 10)).reverse().filter((rep, i2, arr) => {
        const bandwidth = parseInt(rep.getAttribute("bandwidth"), 10);
        return rep === arr[0] || bandwidth >= minBandwidth;
      });
      for (const rep of difference_default(reps, videoSourcesByBandwidth)) rep.remove();
      for (const rep of manifest.querySelectorAll("Representation")) {
        const baseURLElement = rep.querySelector("BaseURL");
        baseURLElement.textContent = new URL(baseURLElement.textContent, originalPlaylistUrl).href;
      }
      const muted = !manifest.querySelector("AudioChannelConfiguration");
      if (!videoSourcesByBandwidth.length) throw new Error("Video has no valid sources");
      let postMetadata = await getPostMetadata({ id: fullname.replace("t3_", "") });
      if (postMetadata.crosspost_parent_list && postMetadata.crosspost_parent_list.length > 0) {
        postMetadata = postMetadata.crosspost_parent_list[0];
      }
      const sources = muted && id2 ? videoSourcesByBandwidth.map((rep) => ({
        source: rep.querySelector("BaseURL").textContent,
        type: "video/mp4"
      })) : [{
        source: new XMLSerializer().serializeToString(manifest),
        type: "application/dash+xml"
      }];
      return {
        type: "VIDEO",
        loop: true,
        caption: postMetadata.selftext_html && postMetadata.selftext_html.replace(/<\/?p>/g, ""),
        muted,
        sources
      };
    }
  });

  // lib/modules/hosts/wikipedia.js
  var import_jquery7 = __toESM(require_jquery(), 1);

  // lib/core/metadata/index.js
  var announcementsSubreddit = downcast("RESAnnouncements", "string");
  var name = downcast("Reddit Enhancement Suite", "string");
  var version3 = downcast("5.24.7", "string");
  var isBeta = Boolean(downcast("false", "string"));
  var isPatch = Boolean(downcast("true", "string"));
  var isMinor = Boolean(downcast("false", "string"));
  var isMajor = Boolean(downcast("false", "string"));
  var updatedURL = downcast("https://redditenhancementsuite.com/releases/#v5.24.7", "string");
  var homepageURL = downcast("https://redditenhancementsuite.com", "string");

  // lib/modules/hosts/wikipedia.js
  var req = (url) => ajax({
    url,
    type: "json",
    headers: {
      // See https://www.mediawiki.org/wiki/API:Main_page#Identifying_your_client
      "Api-User-Agent": `Reddit-Enhancement-Suite/${version3} ( ${homepageURL} )`
    }
  });
  var wikipedia_default = new Host("wikipedia", {
    name: "wikipedia",
    domains: ["wikipedia.org", "wikipedia.com"],
    logo: "https://en.wikipedia.org/static/favicon/wikipedia.ico",
    detect: (url) => url.pathname.startsWith("/wiki/") && {
      article: url.pathname.substr(6),
      // remove "/wiki/"
      language: url.host.split(".")[0],
      hash: decodeURIComponent(url.hash.substr(1))
    },
    async handleLink(href, { language, article, hash }) {
      if (language === "www" || language === "wikipedia") language = "en";
      const { index: sectionId = 0 } = hash && (await req(`https://${language}.wikipedia.org/w/api.php?action=parse&format=json&prop=sections&page=${article}&origin=*`)).parse.sections.find(({ anchor: anchor2 }) => anchor2 === hash) || {};
      const { parse: html2 } = await req(`https://${language}.wikipedia.org/w/api.php?action=parse&format=json&prop=text|displaytitle&section=${sectionId}&page=${article}&origin=*`);
      const cleanDoc = new DOMParser().parseFromString(html2.text["*"], "text/html");
      for (const e2 of cleanDoc.querySelectorAll(".metadata, .hatnote, .mw-editsection, .mw-ext-cite-error, .mwe-math-mathml-inline, .reference, .references")) e2.remove();
      for (const e2 of cleanDoc.querySelectorAll("a")) {
        e2.href = new URL(e2.getAttribute("href"), `https://${language}.wikipedia.org/wiki/${article}`).href;
      }
      return {
        type: "TEXT",
        title: (0, import_jquery7.default)("<div>", { html: html2.displaytitle || html2.title }).text(),
        // get title without html (jquery got quite unhappy when brackets appeared)
        src: cleanDoc.body.innerHTML
      };
    }
  });

  // lib/modules/hosts/xboxdvr.js
  var xboxdvr_default = new Host("xboxdvr", {
    name: "XboxDVR",
    domains: ["xboxdvr.com"],
    logo: "https://gamerdvr.com/assets/favicon-240671aabcbf14dcaa1f3f2b406091d2.png",
    detect: ({ pathname }) => /^\/(gamer\/[^\/]+\/\w+\/\d+)(?:\/|$)/.exec(pathname),
    handleLink(href, [, path]) {
      return {
        type: "IFRAME",
        embed: `https://xboxdvr.com/${path}/embed`,
        fixedRatio: true
      };
    }
  });

  // lib/modules/hosts/xkcd.js
  var xkcd_default = new Host("xkcd", {
    name: "xkcd",
    domains: ["xkcd.com"],
    permissions: ["https://xkcd.com/*/info.0.json"],
    logo: "https://xkcd.com/favicon.ico",
    detect: ({ hostname, pathname }) => (
      // primarily to exclude what-if.xkcd.com
      ["xkcd.com", "www.xkcd.com"].includes(hostname) && /^\/([0-9]+)(?:\/|$)/i.exec(pathname)
    ),
    async handleLink(href, [, id2]) {
      const { title, alt, img } = await ajax({
        url: `https://xkcd.com/${id2}/info.0.json`,
        type: "json"
      });
      return {
        type: "IMAGE",
        title,
        caption: alt,
        src: img
      };
    }
  });

  // lib/modules/hosts/youtube.js
  var youtube_default = new Host("youtube", {
    name: "youtube",
    attribution: false,
    domains: ["youtube.com", "youtu.be"],
    detect: ({ pathname, hostname, searchParams }) => {
      const split = pathname.substring(1).split("/");
      if (split[0] === "channel" && split[2] === "live") return [`live_stream?channel=${split[1]}`, searchParams];
      if (split[0] === "shorts") return [split[1], searchParams];
      if (hostname.endsWith("youtu.be")) return [split[0], searchParams];
      const vParam = searchParams.get("v");
      if (vParam) return [vParam, searchParams];
      if (/watch|embed|v/i.exec(split[0])) return [split[1], searchParams];
      const uParam = searchParams.get("u");
      if (split[0] === "attribution_link" && uParam !== null) {
        const vParam2 = new URLSearchParams(uParam.split("?")[1]).get("v");
        if (vParam2) return [vParam2, searchParams];
      }
    },
    handleLink(href, [id2, searchParams]) {
      const url = new URL(`https://www.youtube.com/embed/${id2}`);
      url.searchParams.set("version", "3");
      url.searchParams.set("rel", "0");
      url.searchParams.set("enablejsapi", "1");
      const tParam = searchParams.get("t");
      if (tParam) {
        let start2 = 0;
        const timeBlocks = { h: 3600, m: 60, s: 1 };
        const timeRe = /[0-9]+[hms]/ig;
        const timeMatch = tParam.match(timeRe);
        if (timeMatch) {
          for (const ts of timeMatch) {
            const unit = timeBlocks[ts.slice(-1)];
            const amount = parseInt(ts.slice(0, -1), 10);
            start2 += unit * amount;
          }
        } else {
          start2 = parseInt(tParam, 10);
          if (isNaN(start2)) start2 = 0;
        }
        url.searchParams.set("start", String(start2));
      }
      for (const k2 of ["end", "start", "list"]) {
        const param = searchParams.get(k2);
        if (param) url.searchParams.set(k2, param);
      }
      return {
        type: "IFRAME",
        embed: url.href,
        embedAutoplay: `${url.href}&autoplay=1`,
        pause: '{"event":"command","func":"stopVideo","args":""}',
        play: '{"event":"command","func":"playVideo","args":""}',
        fixedRatio: true
      };
    },
    getVideoData: batch(async (ids) => {
      const { items: items2 } = await ajax({
        url: "https://www.googleapis.com/youtube/v3/videos",
        query: {
          id: [...ids].sort().join(","),
          // sorted to improve cache hit likelyhood
          part: ["id", "contentDetails", "snippet", "statistics"].join(","),
          fields: `items(${["id", "contentDetails(duration)", "snippet(title,publishedAt)", "statistics(viewCount)"].join(",")})`,
          key: "AIzaSyB8ufxFN0GapU1hSzIbuOLfnFC0XzJousw"
        },
        type: "json",
        cacheFor: DAY
      });
      return ids.map((id2) => {
        const data2 = items2.find(({ id: _id }) => _id === id2);
        try {
          const { contentDetails: { duration: rawDuration }, snippet: { title, publishedAt }, statistics: { viewCount } } = data2;
          const duration = ["0"].concat(rawDuration.match(/^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/i).slice(1)).map((time) => `0${time || 0}`.slice(-2)).filter((time, i2, { length }) => +time !== 0 || i2 >= length - 2).join(":");
          return { title, duration, publishedAt, viewCount };
        } catch (e2) {
        }
      });
    }, { size: 50, delay: 750 })
  });

  // lib/modules/hosts/znipe.js
  var znipe_default = new Host("znipe", {
    name: "ZnipeTV",
    domains: ["beta.znipe.tv", "www.znipe.tv"],
    logo: "https://assets.znipe.tv/icons/favicon.jpg",
    detect: ({ searchParams }) => {
      const mParam = searchParams.get("m");
      if (mParam) return ["m", mParam];
      const vParam = searchParams.get("v");
      if (vParam) return ["v", vParam];
    },
    handleLink(href, [clipType, clipId]) {
      return {
        type: "IFRAME",
        embed: `https://beta.znipe.tv/watch?${clipType}=${clipId}`
      };
    }
  });

  // lib/modules/showImages/templates.js
  var audioTemplate = ({ loop, sources }) => string_exports.html`
	<div>
		<audio controls ${loop && "loop"}>
			${sources.map(({ file, type }) => string_exports._html`
				<source src="${file}" type="${type}">
			`)}
		</audio>
	</div>
`;
  var galleryTemplate = ({ title, caption, credits, src }) => string_exports.html`
	<div class="res-gallery">
		${title && string_exports._html`
		<h3 class="res-title res-gallery-title">${title}</h3>
		`}
		${caption && string_exports._html`
		<div class="res-caption res-gallery-caption">${string_exports.safe(caption)}</div>
		`}
		${credits && string_exports._html`
		<div class="res-credits">${string_exports.safe(credits)}</div>
		`}
		<div class="res-step-container">
			<div class="res-step res-step-previous" role="button"></div>
			<div class="res-step-progress">
				<span class="res-step-position">1</span> of ${src.length}
			</div>
			<div class="res-step res-step-next" role="button"></div>
			<div class="res-gallery-to-filmstrip" title="View as filmstrip" role="button"></div>
		</div>
		<div class="res-gallery-pieces"></div>
		<div class="res-gallery-below">
			<div>
				<div class="res-expando-siteAttribution"></div>
				<div class="res-gallery-increase-concurrent"></div>
			</div>
		</div>
	</div>
`;
  var imageTemplate = ({ title, caption, credits, src, href, openInNewWindow }) => string_exports.html`
	<div class="res-image">
		${title && string_exports._html`
		<h4 class="res-title">${title}</h4>
		`}
		${caption && string_exports._html`
		<div class="res-caption">${string_exports.safe(caption)}</div>
		`}
		${credits && string_exports._html`
		<div class="res-credits">${string_exports.safe(credits)}</div>
		`}
		<a class="res-expando-link noKeyNav" href="${href}" ${openInNewWindow && string_exports._html`target="_blank" rel="noopener noreferrer"`}>
			<img class="res-image-media" src="${src}">
		</a>
	</div>
`;
  var iframeTemplate = ({ url, width, height }) => string_exports.html`
	<div class="res-iframe-expando">
		<div>
			<iframe src="${url}" style="width: ${width}; height: ${height}" allowFullscreen="true"></iframe>
			<div class="res-iframe-expando-drag-handle">
				<div class="res-icon"></div>
				<div class="res-expando-siteAttribution"></div>
			</div>
		</div>
	</div>
`;
  var textTemplate = ({ title, credits, src }) => string_exports.html`
	<div class="res-text usertext-body">
		${title && string_exports._html`
		<h3 class="res-title">${title}</h3>
		`}
		<div class="res-text-media md">${string_exports.safe(src)}</div>
		${credits && string_exports._html`
		<div class="res-credits">${string_exports.safe(credits)}</div>
		`}
	</div>
`;
  var videoTemplate = ({
    title,
    caption,
    credits,
    source,
    poster,
    hasAudio,
    loop,
    reversable,
    formattedPlaybackRate
  }) => string_exports.html`
	<div class="res-video">
		${title && string_exports._html`
		<h4 class="res-title">${title}</h4>
		`}
		${caption && string_exports._html`
		<div class="res-caption">${string_exports.safe(caption)}</div>
		`}
		${credits && string_exports._html`
		<div class="res-credits">${string_exports.safe(credits)}</div>
		`}
		<div class="res-video-container">
			<video preload="auto" ${!hasAudio && "muted"} ${loop && "loop"} poster="${poster}"></video>
			<div hidden class="res-video-error"></div>
			<div class="res-video-interface">
				<div class="res-video-progress">
					<div class="res-video-position"></div>
					<div class="res-video-position-thumb"></div>
				</div>
				<div class="res-video-main">
					<div class="res-video-controls" hidden>
						<div title="Toggle pause" class="res-icon res-video-button res-video-toggle-pause"></div>
						${reversable && string_exports._html`
						<div title="Reverse video" class="res-icon res-video-button res-video-reverse"></div>
						`}
						${hasAudio && string_exports._html`
							<div title="Adjust volume" class="res-icon res-video-button res-video-volume">
								<div class="res-video-volume-level">
									<div class="res-video-volume-percentage"></div>
								</div>
							</div>
						`}
						<div class="res-video-controls-group res-video-current-time">
							<div title="Select previous frame" class="res-icon res-video-button res-video-time-decrease"></div>
							<div class="res-video-time">0.00s</div>
							<div title="Select next frame" class="res-icon res-video-button res-video-time-increase"></div>
						</div>
						<div class="res-video-controls-group res-video-playback-rate">
							<div title="Decrease speed by 10%" class="res-icon res-video-button res-video-speed-decrease"></div>
							<div class="res-video-speed">${string_exports.safe(formattedPlaybackRate)}</div>
							<div title="Increase speed by 10%" class="res-icon res-video-button res-video-speed-increase"></div>
						</div>
					</div>
					<div class="res-video-info">
						<a class="res-video-link res-video-source" href="${source}" rel="noopener noreferrer">source</a>
						<div class="res-expando-siteAttribution"></div>
					</div>
				</div>
			</div>
		</div>
	</div>
`;
  var mediaControlsTemplate = ({ x, y, downloadUrl, lookupUrl, clippy }) => string_exports.html`
	<div class="res-media-with-controls-wrapper">
		<div class="res-media-controls res-media-controls-${x} res-media-controls-${y}">
			<button class="res-icon gearIcon" title="Settings" data-action="showImageSettings"></button>
			<button class="res-media-controls-rotate res-media-controls-rotate-left res-icon" title="Rotate image counter-clockwise" data-action="rotateLeft"></button>
			<button class="res-media-controls-rotate res-media-controls-rotate-right res-icon" title="Rotate image clockwise" data-action="rotateRight"></button>
			${downloadUrl && string_exports._html`
			<button class="res-media-controls-download res-icon" title="Download image" data-action="download"></button>
			`}
			${lookupUrl && string_exports._html`
			<button class="res-media-controls-lookup res-icon" title="Reverse image search" data-action="imageLookup"></button>
			`}
			${clippy && string_exports._html`
			<button class="res-media-controls-clippy" title="Show educational info" data-action="clippy"></button>
			`}
		</div>
	</div>
`;
  var siteAttributionTemplate = ({ url, name: name2, logoUrl, settingsLink }) => string_exports.html`
	<cite class="res-expando-siteAttribution">
		<a href="${url}" target="_blank" rel="noopener noreferer">
			${logoUrl && string_exports._html`<img src="${logoUrl}" alt="Hosted on ${name2}" title="Hosted on ${name2}" />`}
			<span>hosted on ${name2}</span>
			<a href="${settingsLink}" class="gearIcon" title="Disable or change settings for ${name2}"></a>
		</a>
	</cite>
`;
  var crosspostMetadataTemplate = (data2) => string_exports.html`
	<div class="crosspost-preview res-crosspost-preview">
		<div class="crosspost-preview-header">
			<a href="${data2.url}" class="content-link may-blank" data-event-action="title" tabindex="1"></a>
			<div class="text-content">
				<p class="title">${data2.crosspostRootTitle}</p>
				<div class="crosspost-preview-tagline tagline">
					<span>${i18n("numPoints", parseInt(data2.crosspostRootScore, 10))}</span>
					<span class="dot"></span>
					<a href="/r/${data2.crosspostRootSubreddit}/comments/${(data2.targetParentFullname || "").slice(3)}" class="comments may-blank">${i18n("numComments", parseInt(data2.crosspostRootNumComments, 10))}</a>
					<span class="dot"></span>
					${i18n("submittedAtTime")} <time>${data2.crosspostRootTime}</time>
					${i18n("submittedByAuthor")} <a href="/user/${data2.crosspostRootAuthor}/" class="author may-blank">${data2.crosspostRootAuthor}</a>
					${i18n("submittedToSubreddit")} <a href="/r/${data2.crosspostRootSubreddit}/" class="subreddit hover may-blank">r/${data2.crosspostRootSubreddit}</a>
				</div>
			</div>
		</div>
	</div>
`;

  // lib/modules/showImages/expando.js
  var expandos = /* @__PURE__ */ new Map();
  var activeExpandos = /* @__PURE__ */ new Set();
  var opened = /* @__PURE__ */ new Set();
  var Expando = class _Expando {
    static expandoSelector = ".expando-button, .search-expando-button";
    static getEntryExpandoFrom(thing) {
      if (!thing) return null;
      const button = thing.entry.querySelector(".expando-button");
      if (!button) return null;
      let expando2 = expandos.get(button);
      if (!expando2) {
        const box = thing.entry.querySelector(".expando");
        if (!box) return null;
        const buttonPlaceholder = document.createElement("span");
        const boxPlaceholder = document.createElement("span");
        expando2 = {
          button,
          get open() {
            return button.classList.contains("expanded");
          },
          collapse() {
            if (this.open) this.toggle();
          },
          expand() {
            if (!this.open) this.toggle();
          },
          toggle() {
            click(button);
          },
          detach() {
            button.replaceWith(buttonPlaceholder);
            box.replaceWith(boxPlaceholder);
          },
          reattach() {
            buttonPlaceholder.replaceWith(button);
            boxPlaceholder.replaceWith(box);
          },
          types: [
            "native",
            button.classList.contains("selftext") ? "selftext" : (
              // This may be muted, depending on its content (not possible to know before expanding)
              (box.dataset.cachedhtml || "").match(/\bvideo-player\b/) ? ["video", "non-muted"] : (box.dataset.cachedhtml || "").match(/\<iframe\b/) ? ["iframe", "non-muted"] : ["image", "muted"]
            )
            // $FlowIssue Array#flat
          ].flat().filter(Boolean),
          ready: true
        };
        expandos.set(button, expando2);
      }
      return expando2;
    }
    static getTextExpandosFrom(thing) {
      if (!thing) return [];
      const md = thing.entry.querySelector(".md");
      if (!md) return [];
      return filterMap(Array.from(md.querySelectorAll(_Expando.expandoSelector)), (v) => {
        const exp = expandos.get(v);
        if (exp) return [exp];
      });
    }
    static getAllExpandosFrom(thing) {
      return compact_default([..._Expando.getTextExpandosFrom(thing), _Expando.getEntryExpandoFrom(thing)]);
    }
    href;
    inText;
    ready = false;
    lock = null;
    box;
    button;
    open = false;
    expandWanted = false;
    expandCallbacks = [];
    media;
    generateMedia;
    types = [];
    buttonInfo = {
      title: "Expando is not yet ready",
      mediaClass: ""
    };
    constructor(href) {
      this.href = href;
      this.box = document.createElement("div");
      this.box.classList.add("res-expando-box");
      this.box.hidden = true;
      this.button = document.createElement("a");
      this.button.addEventListener("click", () => this.toggle());
      this.updateButton();
      new MutationObserver(() => {
        this.updateButton();
      }).observe(this.button, { attributes: true });
      expandos.set(this.button, this);
    }
    onExpand(callback) {
      this.expandCallbacks.push(callback);
    }
    updateButton() {
      let { mediaClass, title } = this.buttonInfo;
      if (this.lock) {
        mediaClass = "expando-button-requires-permission";
        title = "Click to request required permissions";
      }
      const classList = [
        "expando-button",
        ...mediaClass.split(" ") || ["expando-button-loading"],
        this.open || this.expandWanted ? "expanded" : "collapsed"
      ].filter(Boolean);
      if (!this.expandWanted && !this.open && opened.has(this.href)) {
        classList.push("expando-button-duplicate");
        title += " (link has already been opened)";
      }
      const btn = this.button;
      for (const v of btn.classList) if (!classList.includes(v)) btn.classList.remove(v);
      for (const v of classList) if (!btn.classList.contains(v)) btn.classList.add(v);
      if (btn.title !== title) btn.title = title;
    }
    initialize(options6) {
      this.generateMedia = options6.generateMedia;
      this.buttonInfo = options6.buttonInfo;
      this.types = options6.types;
      this.ready = true;
      if (this.expandWanted) this.expand();
      else this.updateButton();
    }
    getDuplicates() {
      return Array.from(expandos.values()).filter((v) => v !== this && v.href === this.href && document.contains(v.button));
    }
    async setLock(lock) {
      this.lock = lock;
      this.updateButton();
      await lock.promise;
      this.lock = null;
      this.updateButton();
    }
    toggle() {
      if (this.open) this.collapse();
      else this.expand();
    }
    expand() {
      if (this.lock || !this.ready) {
        this.expandWanted = true;
        if (this.lock) this.lock.open();
        this.updateButton();
        return;
      }
      this.box.hidden = false;
      this.attachMedia();
      if (this.media) this.media.expand();
      this.open = true;
      this.expandWanted = false;
      this.updateButton();
      for (const callback of this.expandCallbacks) callback();
      opened.add(this.href);
      for (const duplicate of this.getDuplicates()) duplicate.updateButton();
    }
    collapse() {
      this.box.hidden = true;
      this.open = false;
      this.expandWanted = false;
      this.updateButton();
      if (this.media) {
        this.media.collapse();
      }
    }
    attachMedia() {
      const wrapper = this.box.firstElementChild || document.createElement("div");
      if (!this.generateMedia) throw new Error("Cannot attach media without `generateMedia`");
      this.media = this.media || this.generateMedia();
      wrapper.append(this.media.element);
      wrapper.classList.add("res-expando-box-inner");
      this.box.append(wrapper);
      if (
        /*:: this.media && */
        this.media.onAttach
      ) this.media.onAttach();
      activeExpandos.add(this);
    }
    isAttached() {
      return document.body.contains(this.button) && document.body.contains(this.box);
    }
    destroy() {
      if (this.box) {
        this.box.remove();
        delete this.box;
      }
      if (this.button) {
        expandos.delete(this.button);
        this.button.remove();
        delete this.button;
      }
      this.empty();
    }
    empty() {
      if (this.media) {
        this.media.element.remove();
        delete this.media;
      }
      if (this.button) {
        if (this.open) this.collapse();
        else this.updateButton();
      }
      activeExpandos.delete(this);
    }
  };

  // lib/modules/showImages.js
  var siteModules = new Map(
    Object.values(hosts_exports).map((host) => [host.moduleID, downcast(host, Host)])
    // ensure that all hosts are instances of `Host`
  );
  var genericHosts = [siteModules.get("defaultImage"), siteModules.get("defaultVideo"), siteModules.get("defaultAudio")].map((host) => downcast(host, Host));
  var module9 = new Module("showImages");
  module9.moduleName = "showImagesName";
  module9.category = "productivityCategory";
  module9.description = "showImagesDesc";
  module9.bodyClass = true;
  module9.options = {
    mediaBrowse: {
      title: "showImagesMediaBrowseTitle",
      type: "boolean",
      value: true,
      description: "showImagesMediaBrowseDesc"
    },
    browsePreloadCount: {
      title: "showImagesBrowsePreloadCountTitle",
      type: "text",
      value: "1",
      description: "showImagesBrowsePreloadCountDesc",
      dependsOn: (options6) => options6.mediaBrowse.value
    },
    galleryPreloadCount: {
      title: "showImagesGalleryPreloadCountTitle",
      type: "text",
      value: "2",
      description: "showImagesGalleryPreloadCountDesc"
    },
    collapseInlineMedia: {
      title: "showImagesCollapseInlineMediaTitle",
      type: "boolean",
      value: false,
      description: "showImagesCollapseInlineMediaDesc"
    },
    conserveMemory: {
      title: "showImagesConserveMemoryTitle",
      type: "boolean",
      value: true,
      description: "showImagesConserveMemoryDesc"
    },
    maxWidth: {
      title: "showImagesMaxWidthTitle",
      type: "text",
      value: "100%",
      description: "showImagesMaxWidthDesc",
      advanced: true
    },
    maxHeight: {
      title: "showImagesMaxHeightTitle",
      type: "text",
      value: "80%",
      description: "showImagesMaxHeightDesc",
      advanced: true
    },
    displayOriginalResolution: {
      title: "showImagesDisplayOriginalResolutionTitle",
      type: "boolean",
      value: false,
      description: "showImagesDisplayOriginalResolutionDesc"
    },
    selfTextMaxHeight: {
      title: "showImagesSelfTextMaxHeightTitle",
      type: "text",
      value: "0",
      description: "showImagesSelfTextMaxHeightDesc",
      advanced: true
    },
    commentMaxHeight: {
      title: "showImagesCommentMaxHeightTitle",
      type: "text",
      value: "0",
      description: "showImagesCommentMaxHeightDesc",
      advanced: true
    },
    autoMaxHeight: {
      title: "showImagesAutoMaxHeightTitle",
      type: "boolean",
      value: false,
      description: "showImagesAutoMaxHeightDesc",
      dependsOn: (options6) => !!parseInt(options6.selfTextMaxHeight.value, 10) || !!parseInt(options6.commentMaxHeight.value, 10),
      advanced: true
    },
    openInNewWindow: {
      title: "showImagesOpenInNewWindowTitle",
      type: "boolean",
      value: true,
      description: "showImagesOpenInNewWindowDesc"
    },
    hideNSFW: {
      title: "showImagesHideNSFWTitle",
      type: "boolean",
      value: false,
      description: "showImagesHideNSFWDesc"
    },
    highlightNSFWButton: {
      title: "showImagesHighlightNSFWButtonTitle",
      type: "boolean",
      value: true,
      description: "showImagesHighlightNSFWButtonDesc",
      bodyClass: true
    },
    highlightSpoilerButton: {
      title: "showImagesHighlightSpoilerButtonTitle",
      type: "boolean",
      value: true,
      description: "showImagesHighlightSpoilerButtonDesc",
      bodyClass: true
    },
    imageZoom: {
      title: "showImagesImageZoomTitle",
      type: "boolean",
      value: true,
      description: "showImagesImageZoomDesc"
    },
    imageMove: {
      title: "showImagesImageMoveTitle",
      type: "boolean",
      value: true,
      description: "showImagesImageMoveDesc"
    },
    mediaControls: {
      title: "showImagesMediaControlsTitle",
      type: "boolean",
      value: true,
      description: "showImagesMediaControlsDesc"
    },
    mediaControlsPosition: {
      title: "showImagesMediaControlsPositionTitle",
      dependsOn: (options6) => options6.mediaControls.value,
      type: "enum",
      value: "top-left",
      values: [{
        name: "Top left",
        value: "top-left"
      }, {
        name: "Top right",
        value: "top-right"
      }, {
        name: "Bottom left.",
        value: "bottom-left"
      }, {
        name: "Bottom right.",
        value: "bottom-right"
      }],
      description: "showImagesMediaControlsPositionDesc"
    },
    clippy: {
      title: "showImagesClippyTitle",
      dependsOn: (options6) => options6.mediaControls.value,
      type: "boolean",
      value: true,
      description: "showImagesClippyDesc"
    },
    crossposts: {
      title: "showImagesCrosspostsTitle",
      description: "showImagesCrosspostsDescription",
      type: "enum",
      value: "withMetadata",
      values: [{
        name: "Do not replace Reddit crosspost expando",
        value: "none"
      }, {
        name: "Show with original post's metadata",
        value: "withMetadata"
      }, {
        name: "Show without metadata",
        value: "plain"
      }]
    },
    displayImageCaptions: {
      title: "showImagesDisplayImageCaptionsTitle",
      type: "boolean",
      value: true,
      description: "showImagesDisplayImageCaptionsDesc",
      advanced: true,
      bodyClass: true
    },
    captionsPosition: {
      title: "showImagesCaptionsPositionTitle",
      dependsOn: (options6) => options6.displayImageCaptions.value,
      type: "enum",
      value: "titleAbove",
      values: [{
        name: "Display all captions above image.",
        value: "allAbove"
      }, {
        name: "Display title and caption above image, credits below.",
        value: "creditsBelow"
      }, {
        name: "Display title above image, caption and credits below.",
        value: "titleAbove"
      }, {
        name: "Display all captions below image.",
        value: "allBelow"
      }],
      description: "showImagesCaptionsPositionDesc",
      advanced: true,
      bodyClass: true
    },
    markVisited: {
      title: "showImagesMarkVisitedTitle",
      type: "boolean",
      value: true,
      description: "showImagesMarkVisitedDesc",
      advanced: true
    },
    markSelftextVisited: {
      title: "showImagesMarkSelftextVisitedTitle",
      dependsOn: (options6) => options6.markVisited.value,
      type: "boolean",
      value: false,
      description: "showImagesMarkSelftextVisitedDesc",
      advanced: true
    },
    sfwHistory: {
      title: "showImagesSfwHistoryTitle",
      dependsOn: (options6) => options6.markVisited.value,
      type: "enum",
      value: "add",
      values: [{
        name: "Add links to history",
        value: "add"
      }, {
        name: "Do not add or color links.",
        value: "none"
      }],
      description: "showImagesSfwHistoryDesc"
    },
    galleryRememberWidth: {
      title: "showImagesGalleryRememberWidthTitle",
      dependsOn: (options6) => options6.imageZoom.value,
      type: "boolean",
      value: true,
      description: "showImagesGalleryRememberWidthDesc"
    },
    galleryAsFilmstrip: {
      title: "showImagesGalleryAsFilmstripTitle",
      type: "boolean",
      value: false,
      description: "showImagesGalleryAsFilmstripDesc"
    },
    filmstripLoadIncrement: {
      title: "showImagesFilmstripLoadIncrementTitle",
      dependsOn: (options6) => options6.galleryAsFilmstrip.value,
      type: "text",
      value: "30",
      description: "showImagesFilmstripLoadIncrementDesc"
    },
    useSlideshowWhenLargerThan: {
      title: "showImagesUseSlideshowWhenLargerThanTitle",
      dependsOn: (options6) => options6.galleryAsFilmstrip.value,
      type: "text",
      value: "0",
      description: "showImagesUseSlideshowWhenLargerThanDesc"
    },
    showViewImagesTab: {
      title: "showImagesShowViewImagesTabTitle",
      type: "boolean",
      value: true,
      description: "showImagesShowViewImagesTabDesc"
    },
    autoExpandTypes: {
      title: "showImagesAutoExpandTypesTitle",
      type: "enum",
      value: "any",
      values: [{
        name: "Images (but occasionally also .gif)",
        value: "image"
      }, {
        name: "Images, text",
        value: "image text"
      }, {
        name: "Images, text, galleries, and muted videos",
        value: "image text gallery video"
      }, {
        name: "All muted expandos (includes iframes)",
        value: "any"
      }],
      description: "showImagesAutoExpandTypesDesc"
    },
    autoExpandSelfText: {
      title: "showImagesAutoExpandSelfTextTitle",
      type: "boolean",
      value: true,
      description: "showImagesAutoExpandSelfTextDesc"
    },
    autoExpandSelfTextFirstVisibleNonMuted: {
      title: "showImagesAutoExpandSelfTextFirstVisibleNonMutedTitle",
      dependsOn: (options6) => options6.autoExpandSelfText.value,
      type: "boolean",
      value: true,
      description: "showImagesAutoExpandSelfTextFirstVisibleNonMutedDesc"
    },
    autoExpandSelfTextNSFW: {
      title: "showImagesAutoExpandSelfTextNSFWTitle",
      dependsOn: (options6) => options6.autoExpandSelfText.value,
      type: "boolean",
      value: false,
      description: "showImagesAutoExpandSelfTextNSFWDesc"
    },
    showSiteAttribution: {
      title: "showImagesShowSiteAttributionTitle",
      type: "boolean",
      value: true,
      description: "showImagesShowSiteAttributionDesc"
    },
    expandoCommentRedirects: {
      title: "showImagesExpandoCommentRedirectsTitle",
      type: "enum",
      value: "expando",
      values: [{
        name: "Do nothing",
        value: "nothing"
      }, {
        name: "Create expandos",
        value: "expando"
      }, {
        name: "Create expandos, redirect the link back to the image",
        value: "rewrite"
      }],
      description: "showImagesExpandoCommentRedirectsDesc"
    },
    startVideosMuted: {
      title: "showImagesStartVideosMutedTitle",
      type: "boolean",
      value: false,
      description: "showImagesStartVideosMutedDesc"
    },
    maxSimultaneousPlaying: {
      title: "showImagesMaxSimultaneousPlayingTitle",
      type: "text",
      value: "0",
      description: "showImagesMaxSimultaneousPlayingDesc"
    },
    autoplayVideo: {
      title: "showImagesAutoplayVideoTitle",
      type: "boolean",
      value: true,
      description: "showImagesAutoplayVideoDesc"
    },
    hidePinnedRedditVideos: {
      title: "showImagesHidePinnedRedditVideosTitle",
      type: "boolean",
      value: false,
      description: "showImagesHidePinnedRedditVideosDesc",
      bodyClass: true
    },
    ...Array.from(siteModules.values()).reduce((options6, siteModule) => {
      if (genericHosts.includes(siteModule)) return options6;
      const key = siteModuleOptionKey(siteModule);
      options6[key] = {
        title: siteModule.name,
        description: "showImagesHostToggleDesc",
        value: true,
        type: "boolean"
      };
      if (siteModule.options) {
        Object.assign(options6, siteModule.options);
        Object.values(siteModule.options).map((v) => {
          const origDependsOn = v.dependsOn;
          v.dependsOn = (options7) => options7[key].value && (!origDependsOn || origDependsOn());
        });
      }
      return options6;
    }, {})
  };
  var localStorageKeyRemoveNativePlayer = "RES_forceReplaceNativeExpando";
  var cachedRemoveNativePlayer = () => localStorage?.getItem(localStorageKeyRemoveNativePlayer) === "true";
  module9.onInit = () => {
    if (isAppType("r2")) {
      const cachedValue = cachedRemoveNativePlayer();
      if (cachedValue) {
        console.log("Removing Reddit's native video player");
        stopPageContextScript((script) => /^\/?videoplayer\./.test(new URL(script.src, location.origin).pathname), "head", true);
        stopPageContextScript((script) => !!script.innerHTML.match("RedditVideoPlayer"), pagePhases_exports.contentStart.then(() => document.querySelector("#siteTable")), false);
      }
      loadOptions.then(() => {
        const actualValue = isRunning(module9) && isSiteModuleEnabled(vreddit_default) && vreddit_default.options && vreddit_default.options.forceReplaceNativeExpando.value;
        if (actualValue !== cachedValue) {
          console.warn("The localStorage value for site module `forceReplaceNativeExpando` was outdated. The video player may not work.");
          localStorage.setItem(localStorageKeyRemoveNativePlayer, String(actualValue));
        }
      });
    }
  };
  module9.exclude = [
    /^\/ads\/[\-\w\._\?=]*/i,
    "submit",
    /^\/subreddits/i
  ];
  module9.beforeLoad = () => {
    const selfTextMaxHeight = parseInt(module9.options.selfTextMaxHeight.value, 10);
    if (selfTextMaxHeight) {
      addCSS(`
			.selftext.expanded ~ * .md {
				max-height: ${selfTextMaxHeight}px;
				overflow-y: auto !important;
				position: relative;
			}
		`);
    }
    const commentMaxHeight = parseInt(module9.options.commentMaxHeight.value, 10);
    if (commentMaxHeight) {
      addCSS(`
			.comment .md {
				max-height: ${commentMaxHeight}px;
				overflow-y: auto !important;
				position: relative;
			}
		`);
    }
    watchForElements(["selfText"], null, scanBody);
    watchForThings(["comment", "message"], (thing) => scanBody(thing.getTextBody()), { id: module9 });
    watchForThings(["post"], (thing) => checkElementForMedia(thing.getPostLink()), { id: module9 });
    watchForRedditEvents("comment", (placeholder, { _: { update: update3 } }) => {
      if (update3) return;
      const comment = placeholder.closest(".Comment");
      scanBody(comment);
    });
    watchForRedditEvents("postAuthor", (placeholder, { _: { update: update3 } }) => {
      if (update3) return;
      const body = placeholder.closest('[data-test-id="post-content"]');
      if (body && body.querySelector(".media-element")) return;
      scanBody(body);
    });
  };
  module9.contentStart = () => {
    if (module9.options.showViewImagesTab.value && isAppType("r2")) {
      viewImagesButton();
    }
    if (module9.options.mediaBrowse.value) {
      selectedThing_exports.addListener(mediaBrowse, "instantly");
    }
    if (module9.options.autoMaxHeight.value) {
      (0, import_jquery8.default)(document.body).on("mediaResize", ".thing > .entry", updateParentHeight);
    }
  };
  module9.go = () => {
    if (isPageType("wiki")) scanBody(document.querySelector(".wiki-page-content"));
    const spotlight = document.querySelector("#siteTable_organic");
    if (spotlight) {
      const nextprev = spotlight.querySelector(".nextprev");
      if (nextprev) {
        nextprev.addEventListener("click", () => {
          const open4 = spotlight.querySelector(".expando-button.expanded");
          if (open4) open4.click();
        });
      }
    }
  };
  module9.afterLoad = () => {
    if (module9.options.conserveMemory.value) {
      enableConserveMemory();
    }
  };
  function siteModuleOptionKey(siteModule) {
    const id2 = siteModule.moduleID;
    return `display_${id2}`;
  }
  function isSiteModuleEnabled(siteModule) {
    const key = siteModuleOptionKey(siteModule);
    return !module9.options[key] || module9.options[key].value;
  }
  var sitesMap = once_default(
    () => Array.from(siteModules.values()).filter(isSiteModuleEnabled).reduce((map, siteModule) => {
      for (const domain of siteModule.domains) {
        map.set(domain, (map.get(domain) || []).concat(siteModule));
      }
      return map;
    }, /* @__PURE__ */ new Map())
  );
  function* modulesForHostname(hostname) {
    do {
      for (const m of sitesMap().get(hostname) || []) yield m;
    } while (hostname = hostname.replace(/^.+?(\.|$)/, ""));
    for (const m of genericHosts) yield m;
  }
  function enableConserveMemory() {
    const fullscreenActive = () => !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement);
    const rootMargin = "50% 100000%";
    const boxMap = /* @__PURE__ */ new WeakMap();
    const ioBox = new IntersectionObserver((entries) => {
      for (const { isIntersecting, target } of entries) {
        if (!isIntersecting && fullscreenActive()) return;
        const { media } = downcast(boxMap.get(target), Expando);
        if (media) media.setLoaded(isIntersecting);
        else ioBox.unobserve(target);
      }
    }, { rootMargin });
    const buttonMap = /* @__PURE__ */ new WeakMap();
    const ioButton = new IntersectionObserver((entries) => {
      if (fullscreenActive()) return;
      for (const { isIntersecting, target } of entries) {
        const expando2 = downcast(buttonMap.get(target), Expando);
        const { open: open4 } = expando2;
        if (!isIntersecting && !open4) {
          ioButton.unobserve(target);
          expando2.empty();
        }
      }
    }, { rootMargin });
    window.addEventListener("scroll", idleThrottle(() => {
      for (const expando2 of activeExpandos.values()) {
        if (expando2.isAttached()) {
          const { box, media, button } = expando2;
          if (!media) continue;
          if (media.supportsUnload()) {
            ioBox.observe(box);
          } else {
            ioBox.unobserve(box);
          }
          boxMap.set(box, expando2);
          ioButton.observe(button);
          buttonMap.set(button, expando2);
        } else {
          expando2.destroy();
        }
      }
    }));
  }
  var autoExpandActive = false;
  var mediaBrowseModeActive = false;
  var viewImagesButton = once_default(() => createElement_exports.tabMenuItem({
    text: "show images",
    className: "res-show-images",
    onChange: (active) => {
      autoExpandActive = active;
      for (const expando2 of expandos.values()) {
        if (!(expando2 instanceof Expando && expando2.ready && expando2.button.offsetParent)) continue;
        const open4 = isExpandWanted(expando2);
        if (open4) expando2.expand();
        else if (!autoExpandActive) expando2.collapse();
      }
    }
  }));
  async function toggleThingExpandos(thing, { scrollOnToggle } = {}) {
    const gate = thing.entry.querySelector(".expando-gate__show-once");
    if (gate) {
      gate.click();
      return;
    }
    const expandos2 = Expando.getAllExpandosFrom(thing);
    if (!expandos2.length) return;
    const openExpandos = expandos2.filter((v) => v.open);
    if (openExpandos.length) {
      for (const expando2 of openExpandos) expando2.collapse();
      if (scrollOnToggle) {
        scrollToElement(thing.entry, null, { scrollStyle: "directional", restrictDirectionTo: "up" });
      }
    } else {
      for (const expando2 of expandos2) {
        const lock = expando2 instanceof Expando && expando2.lock;
        if (lock) {
          lock.open();
          await lock.promise;
        }
        if (!(expando2 instanceof Expando) || isExpandWanted(expando2, { thing, autoExpandFirstVisibleNonMutedInThing: true, autoExpand: true, autoExpandTypes: [], ignoreDuplicatesScope: thing.entry })) {
          expando2.expand();
        }
      }
      if (scrollOnToggle) {
        scrollToElement(thing.entry, null, { scrollStyle: "top", restrictDirectionTo: "down" });
      }
    }
  }
  var preloadExpandos = idleThrottle((fromThing, direction, preloadCount = parseInt(module9.options.browsePreloadCount.value, 10)) => {
    const pieces = [];
    let target = fromThing;
    do {
      const expando2 = Expando.getEntryExpandoFrom(target);
      if (expando2 && expando2 instanceof Expando) pieces.push(expando2);
    } while ((target = target.getNext({ direction })) && pieces.length <= preloadCount);
    preloadMedia(pieces);
  });
  function mediaBrowse(selected, unselected, options6) {
    if (!selected || !options6.allowMediaBrowse || autoExpandActive) return;
    const oldExpando = Expando.getEntryExpandoFrom(unselected);
    const newExpando = Expando.getEntryExpandoFrom(selected);
    if (oldExpando) {
      mediaBrowseModeActive = oldExpando.expandWanted || oldExpando.open;
      oldExpando.collapse();
    }
    if (mediaBrowseModeActive && newExpando) {
      newExpando.expand();
      options6.scrollStyle = "top";
      preloadExpandos(selected, options6.direction);
    }
  }
  function hasEntryAnyExpandedNonMuted(thing) {
    return Expando.getTextExpandosFrom(thing).some(
      (expando2) => expando2.types.includes("non-muted") && (expando2.open || expando2.expandWanted)
    );
  }
  var types = ["selftext", "video", "image", "iframe", "gallery", "native", "muted", "non-muted"];
  function matchesTypes(wantedTypes, expandoTypes = types) {
    return !wantedTypes.length || !!intersection_default(expandoTypes, wantedTypes).length;
  }
  function isExpandWanted(expando2, {
    thing,
    autoExpand = autoExpandActive,
    autoExpandTypes = module9.options.autoExpandTypes.value.replace("any", "").split(" ").filter(Boolean),
    ignoreDuplicates = true,
    ignoreDuplicatesScope,
    onlyExpandMuted = true,
    autoExpandFirstVisibleNonMutedInThing = false,
    treatVideosAsMutedIfStartingMuted = true
  } = {}) {
    if (ignoreDuplicates) {
      const duplicates = expando2.getDuplicates().filter((v) => activeExpandos.has(v));
      if (duplicates.length) {
        if (!ignoreDuplicatesScope) return false;
        if (duplicates.some((v) => ignoreDuplicatesScope.contains(v.button))) return false;
      }
    }
    const expandoIsNonMuted = expando2.types.includes("non-muted");
    const typeCriteriaOK = matchesTypes(autoExpandTypes, expando2.types);
    const muteCriteriaOK = !(onlyExpandMuted && expandoIsNonMuted) || treatVideosAsMutedIfStartingMuted && expando2.types.includes("video") && module9.options.startVideosMuted.value || autoExpandFirstVisibleNonMutedInThing && elementInViewport(expando2.button) && !hasEntryAnyExpandedNonMuted(thing);
    return autoExpand && muteCriteriaOK && typeCriteriaOK;
  }
  function resolveMediaUrl(element, thing) {
    if (module9.options.expandoCommentRedirects.value !== "nothing" && thing && element.classList.contains("title")) {
      if (thing.element.dataset.isGallery === "true") {
        const galleryId = thing.getFullname().replace("t3_", "");
        return new URL(`/gallery/${galleryId}`, location.href);
      }
      const dataUrl = thing.element.getAttribute("data-url");
      const fullDataUrl = dataUrl && new URL(dataUrl, location.href);
      const commentLink = thing.getCommentsLink();
      if (fullDataUrl && commentLink && fullDataUrl.href !== commentLink.href) {
        return fullDataUrl;
      }
    }
    return new URL(element.href, location.href);
  }
  function promptSiteModulePermissions(siteModule) {
    const { name: name2, permissions = [] } = siteModule;
    const urlStripRe = /((?:\w+\.)+\w+)(?=\/|$)/i;
    const message = string_exports.html`<div>
		<p>In order to inline expand content from ${name2}, RES needs permission to access these sites:</p>
		<p><code>${permissions.map((url) => `${urlStripRe.exec(url)[0]}`).join(", \n")}</code></p>
		<p>Be assured RES does not access/modify any of your information on these domains - it only accesses the public API.</p>
		<hr>
		<p>If you prefer not to use RES' expando for these sites, you may:</p>
		<button>Disable this host</button>
	</div>`;
    const notification = showNotification({
      header: "Permission required",
      moduleID: "permissions",
      closeDelay: Infinity,
      message
    });
    const disableHostButton = message.querySelector("button");
    return Promise.race([
      permissions_exports.request(permissions).catch(() => new Promise(() => {
      })),
      waitForEvent(disableHostButton, "click").then(() => {
        const opt = module9.options[siteModuleOptionKey(siteModule)];
        opt.value = false;
        save2(opt);
        return Promise.reject(new Error("Host disabled"));
      })
    ]).finally(() => {
      notification.close();
    });
  }
  var generateSiteModuleLock = memoize_default(async (siteModule) => {
    if (!siteModule.permissions || await permissions_exports.has(siteModule.permissions)) return;
    let resolve, reject;
    return {
      promise: new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      }),
      open: () => promptSiteModulePermissions(siteModule).then(resolve, reject)
    };
  });
  function scanBody(element) {
    if (!element) return;
    const promises = [...element.querySelectorAll("a")].filter((link) => {
      const existingContent = link.querySelector("img, video");
      if (existingContent && module9.options.collapseInlineMedia.value && existingContent.matches('[src^="https://external-preview.redd.it"')) {
        if (existingContent.hasAttribute("src")) {
          link.href = existingContent.getAttribute("src");
        }
        existingContent.replaceWith(string_exports.html`<i>Collapsed inline media</i>`);
        return true;
      }
      return !existingContent;
    }).map((link) => checkElementForMedia(downcast(link, HTMLAnchorElement)));
    return Promise.allSettled(promises);
  }
  var linksMap = /* @__PURE__ */ new WeakMap();
  function getLinkExpando(link) {
    return linksMap.get(link);
  }
  var inText = (element) => !!element.closest(".md, .search-result-footer");
  async function checkElementForMedia(element) {
    const thing = Thing.from(element);
    const entryExpando = !inText(element) && Expando.getEntryExpandoFrom(thing);
    const nativeExpando = entryExpando instanceof Expando ? null : entryExpando;
    if (module9.options.hideNSFW.value && thing && thing.isNSFW()) {
      if (nativeExpando) nativeExpando.detach();
      return;
    }
    if (nativeExpando) {
      trackNativeExpando(nativeExpando, element, thing);
    }
    if (thing && thing.isCrosspost() && module9.options.crossposts.value === "none") {
      return;
    }
    const mediaUrl = resolveMediaUrl(element, thing);
    if (mediaUrl && module9.options.expandoCommentRedirects.value === "rewrite") {
      element.href = mediaUrl.href;
      element.removeAttribute("data-inbound-url");
    }
    for (const siteModule of modulesForHostname(mediaUrl.hostname)) {
      const detectResult = siteModule.detect(mediaUrl, thing);
      if (!detectResult) continue;
      if (nativeExpando) {
        const forceReplaceNativeExpandoOption = siteModule.options && siteModule.options.forceReplaceNativeExpando;
        if (nativeExpando.open && !(forceReplaceNativeExpandoOption && forceReplaceNativeExpandoOption.value)) {
          console.log("Native expando has already been opened; skipping.", element.href);
          return;
        }
        nativeExpando.detach();
      }
      const expando2 = new Expando(mediaUrl.href);
      placeExpando(expando2, element, thing);
      expando2.onExpand(() => {
        trackMediaLoad(element, thing);
      });
      linksMap.set(element, expando2);
      const lock = await generateSiteModuleLock(siteModule);
      if (lock) expando2.setLock(lock);
      try {
        if (lock) await lock.promise;
        await completeExpando(expando2, thing, siteModule, detectResult);
        break;
      } catch (e2) {
        console.error(`showImages: could not create expando for ${mediaUrl.href}`, e2);
        if (nativeExpando) nativeExpando.reattach();
        expando2.destroy();
        linksMap.delete(element);
      }
    }
  }
  function placeExpando(expando2, element, thing) {
    if (!inText(element) && thing && thing.getTitleElement()) {
      if (element.parentElement) element.parentElement.after(expando2.button);
      const sibling = expando2.button.nextElementSibling;
      if (sibling && sibling.classList.contains("expando-button")) sibling.after(expando2.button);
      thing.entry.appendChild(expando2.box);
    } else {
      (0, import_jquery8.default)(element).add((0, import_jquery8.default)(element).next(".keyNavAnnotation")).last().after(expando2.box).after((0, import_jquery8.default)('<span class="res-freetext-expando">').append(expando2.button));
    }
  }
  async function completeExpando(expando2, thing, siteModule, detectResult) {
    const mediaOptions = await siteModule.handleLink(expando2.href, detectResult);
    if (mediaOptions.title && thing && string_exports.areSimilar(mediaOptions.title, thing.getTitle())) {
      mediaOptions.title = "";
    }
    const attribution = module9.options.showSiteAttribution.value && thing && thing.isPost() && !thing.isSelfPost() && siteModule.domains.length && siteModule.attribution !== false;
    const isMuted = (media) => media.muted || ["IMAGE", "TEXT"].includes(media.type);
    const muted = mediaOptions.type === "GALLERY" ? mediaOptions.src.every(isMuted) : isMuted(mediaOptions);
    expando2.initialize({
      types: [
        mediaOptions.type,
        muted ? "muted" : "non-muted",
        ...(mediaOptions.expandoClass || "").split(" ")
      ].filter((v) => v).map((s) => s.toLowerCase()),
      buttonInfo: getMediaButtonInfo(mediaOptions),
      generateMedia() {
        const media = generateMedia(mediaOptions, { href: expando2.href });
        if (module9.options.crossposts.value === "withMetadata" && thing && thing.isCrosspost()) {
          media.element.prepend(crosspostMetadataTemplate(thing.element.dataset));
        }
        if (attribution) addSiteAttribution(siteModule, media);
        return media;
      }
    });
    expando2.button.setAttribute("data-host", siteModule.moduleID);
    expando2.box.setAttribute("data-host", siteModule.moduleID);
    const hideButton = thing && thing.getHideElement();
    if (hideButton) hideButton.addEventListener("click", () => {
      expando2.destroy();
    });
    if (thing && thing.isComment()) {
      expando2.onExpand(once_default(() => {
        let wasOpen;
        (0, import_jquery8.default)([thing, ...thing.getParents()].map((e2) => e2.entry)).find(".tagline > .expand, > .buttons .toggleChildren").click(() => {
          if (thing.isContentVisible()) {
            if (wasOpen && expando2.media) expando2.expand();
          } else {
            wasOpen = expando2.open;
            if (expando2.open) expando2.collapse();
          }
        });
      }));
    }
    expando2.onExpand(() => {
      const lightbox = expando2.media.element.closest("#overlayScrollContainer");
      if (lightbox) lightbox.firstChild.style.overflowY = "initial";
    });
    expando2.button.addEventListener("mousedown", () => {
      preloadMedia([expando2]);
    });
    if (!expando2.open) {
      let autoExpand;
      let autoExpandFirstVisibleNonMutedInThing;
      if (module9.options.autoExpandSelfText.value && inText(expando2.button) && thing && thing.isSelfPost() && !isPageType("comments")) {
        const dontAutoExpandNSFW = !module9.options.autoExpandSelfTextNSFW.value && thing.isNSFW();
        autoExpand = !dontAutoExpandNSFW;
        autoExpandFirstVisibleNonMutedInThing = module9.options.autoExpandSelfTextFirstVisibleNonMuted.value;
      }
      if (isExpandWanted(expando2, { thing, autoExpand, autoExpandFirstVisibleNonMutedInThing })) {
        expando2.expand();
      }
    }
  }
  function updateParentHeight(e2) {
    const thing = Thing.checkedFrom(e2.currentTarget);
    const basisHeight = thing.isSelfPost() && parseInt(module9.options.selfTextMaxHeight.value, 10) || thing.isComment() && parseInt(module9.options.commentMaxHeight.value, 10) || 0;
    if (basisHeight > 0) {
      const expandoHeight = Array.from(thing.entry.querySelectorAll(".res-expando-box, .expando-button.expanded")).reduce((a2, b2) => a2 + b2.getBoundingClientRect().height, 0);
      thing.getTextBody().style.maxHeight = `${basisHeight + expandoHeight}px`;
    }
  }
  function trackNativeExpando(expando2, element, thing) {
    if (!module9.options.markSelftextVisited.value && expando2.button.classList.contains("selftext")) return;
    const trackLoad = once_default(() => trackMediaLoad(element, thing));
    if (expando2.open) trackLoad();
    else expando2.button.addEventListener("click", trackLoad);
  }
  function getMediaButtonInfo(options6) {
    let title = "";
    let type = options6.type;
    if (options6.type === "GALLERY") {
      if (options6.src.length === 1) {
        type = options6.src[0].type;
      } else {
        title += `${options6.src.length} items in gallery`;
      }
    }
    const defaultClass = {
      IMAGE: "image",
      GALLERY: "image gallery",
      TEXT: "selftext",
      VIDEO: options6.muted ? "video-muted" : "video",
      IFRAME: options6.muted ? "video-muted" : "video",
      AUDIO: "video",
      // yes, still class "video", that's what reddit uses.
      GENERIC_EXPANDO: "selftext"
    }[type];
    return {
      title,
      mediaClass: options6.expandoClass || defaultClass
    };
  }
  var lastPreloadIndex = 0;
  function preloadMedia(pieces) {
    const index2 = ++lastPreloadIndex;
    return forEachSeq(pieces, (piece) => {
      if (!piece.generateMedia) return;
      if (lastPreloadIndex !== index2) return;
      piece.media = piece.media || piece.generateMedia();
      return piece.media.ready;
    });
  }
  function generateMedia(options6, context) {
    if (options6.credits) options6.credits = import_dompurify2.default.sanitize(options6.credits);
    if (options6.caption) options6.caption = import_dompurify2.default.sanitize(options6.caption);
    switch (options6.type) {
      case "GALLERY":
        return new Gallery(options6, context);
      case "IMAGE":
        return new Image(options6, context);
      case "TEXT":
        return new Text(options6);
      case "IFRAME":
        return new Iframe(options6);
      case "VIDEO":
        return new Video(options6, context);
      case "AUDIO":
        return new Audio(options6);
      case "GENERIC_EXPANDO":
        return new Generic(options6);
      default:
        throw new Error(`Unreachable: invalid media type ${options6.type}`);
    }
  }
  var observed = /* @__PURE__ */ new WeakMap();
  var resizeObserver = new ResizeObserver((entries) => {
    for (const { target, contentRect } of entries) {
      const callback = observed.get(target);
      if (callback) callback(contentRect);
    }
  });
  var Media = class {
    element;
    ready;
    onAttach;
    isAttached() {
      return document.body.contains(this.element);
    }
    expand() {
      this.setLoaded(true);
    }
    collapse() {
      this.setLoaded(false);
    }
    onResize = [];
    resizing;
    rotationState = 0;
    supportsUnload() {
      return false;
    }
    _loaded = true;
    _unload() {
    }
    _restore() {
    }
    setLoaded(state) {
      if (state === this._loaded) return;
      this._loaded = state;
      if (state) this._restore();
      else this._unload();
    }
    makeIndependent(element) {
      const wrapper = document.createElement("div");
      const independent = document.createElement("div");
      element.replaceWith(wrapper);
      wrapper.appendChild(independent);
      independent.appendChild(element);
      independent.classList.add("res-media-independent");
      wrapper.style.willChange = "height";
      this.resizing = (contentRect = element.getBoundingClientRect()) => {
        for (const callback of this.onResize) callback(contentRect);
        wrapper.style.height = `${contentRect.height}px`;
      };
      this.onResize.push((contentRect) => {
        this.element.dispatchEvent(new CustomEvent("mediaResize", { detail: contentRect, bubbles: true }));
      });
      observed.set(element, (contentRect) => {
        if (!this._loaded) return;
        if (this.resizing) this.resizing(contentRect);
      });
      resizeObserver.observe(element);
      waitForEvent(element, "mediaManuallyMovedVertically").then(() => {
        resizeObserver.unobserve(element);
      });
    }
    keepVisible(element) {
      element.classList.add("res-element-keep-visible");
      const basisLeft = once_default(() => downcast(element.parentElement, HTMLElement).getBoundingClientRect().left);
      let isAligned = false;
      this.onResize.push(({ width: elementWidth }) => {
        const { width: viewportWidth } = getViewportSize();
        if (!isAligned && basisLeft() + elementWidth < viewportWidth) return;
        const { left: elementLeft, right: elementRight } = element.getBoundingClientRect();
        const deltaLeft = elementLeft - basisLeft();
        if (elementWidth > viewportWidth) {
          isAligned = true;
          move2(element, -elementLeft, 0);
        } else if (elementRight - deltaLeft > viewportWidth) {
          isAligned = true;
          move2(element, viewportWidth - elementRight, 0);
        } else if (deltaLeft) {
          isAligned = false;
          move2(element, -deltaLeft, 0);
        }
      });
    }
    setMaxSize(element) {
      let value = module9.options.maxWidth.value;
      let isPercentage2 = value.endsWith("%");
      const maxWidth = (isPercentage2 ? getViewportSize().width / 100 : 1) * parseInt(value, 10);
      if (maxWidth) element.style.maxWidth = `${maxWidth}px`;
      value = module9.options.maxHeight.value;
      isPercentage2 = value.endsWith("%");
      const maxHeight = (isPercentage2 ? getViewportSize().height / 100 : 1) * parseInt(value, 10);
      if (maxHeight) element.style.maxHeight = `${maxHeight}px`;
    }
    makeZoomable(element, dragInitiater = element, absoluteSizing = false) {
      if (!module9.options.imageZoom.value) return;
      element.classList.add("res-media-zoomable");
      let initialWidth, initialHeight, initialDiagonal, left, top;
      function getDiagonal(x, y) {
        const w = Math.max(1, x - left);
        const h = Math.max(1, y - top);
        return Math.round(Math.hypot(w, h));
      }
      addDragListener({
        media: this.element,
        element: dragInitiater,
        atShiftKey: false,
        onStart: (x, y) => {
          ({ left, top, width: initialWidth, height: initialHeight } = element.getBoundingClientRect());
          initialDiagonal = getDiagonal(x, y);
        },
        onMove: (x, y, deltaX, deltaY) => {
          const conversionFactor = this.rotationState % 2 ? initialHeight / initialWidth : 1;
          if (absoluteSizing) {
            const { width, height } = element.getBoundingClientRect();
            resize(element, (width + deltaX) * conversionFactor, (height + deltaY) / conversionFactor);
          } else {
            const newWidth = getDiagonal(x, y) / initialDiagonal * initialWidth;
            resize(element, newWidth * conversionFactor);
          }
        }
      });
    }
    makeMovable(element, dragInitiater = element) {
      if (!module9.options.imageMove.value) return;
      element.classList.add("res-media-movable");
      addDragListener({
        media: this.element,
        element: dragInitiater,
        atShiftKey: true,
        onMove(x, y, deltaX, deltaY) {
          move2(element, deltaX, deltaY);
        }
      });
    }
    addControls(element, lookupUrl, downloadUrl) {
      if (!module9.options.mediaControls.value) return element;
      const [y, x] = module9.options.mediaControlsPosition.value.split("-");
      const wrapper = mediaControlsTemplate({ clippy: module9.options.clippy.value, lookupUrl, downloadUrl, x, y });
      element.replaceWith(wrapper);
      wrapper.appendChild(element);
      element.classList.add("res-media-rotatable");
      const compensateTransformedSize = () => {
        const { width, height } = element.getBoundingClientRect();
        Object.assign(wrapper.style, { width: `${width}px`, height: `${height}px` });
      };
      const compensateTransformedSizeObserver = new ResizeObserver(compensateTransformedSize);
      const updateRotation = () => {
        compensateTransformedSizeObserver.observe(element);
        element.setAttribute("rotation", String(positiveModulo(this.rotationState, 4)));
        compensateTransformedSize();
      };
      wrapper.querySelector(".res-media-controls").addEventListener("click", (e2) => {
        switch (e2.target.dataset.action) {
          case "rotateLeft":
            --this.rotationState;
            updateRotation();
            break;
          case "rotateRight":
            ++this.rotationState;
            updateRotation();
            break;
          case "download":
            permissions_exports.request(["downloads"]).then(() => {
              const re = /(?:\.([^.]+))?$/;
              const ext = re.exec(downloadUrl);
              const thing = Thing.from(wrapper);
              let title = thing && thing.getTitle();
              if (title && ext) {
                let extension = ext[1];
                if (extension.includes("?")) extension = extension.split("?")[0];
                title = title.replace(/[*|?:"~<>\\\/]|(\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/gi, "");
                title = title.trim();
                const filename = `${title}.${extension}`;
                download(downloadUrl, filename);
              } else download(downloadUrl);
            });
            break;
          case "imageLookup":
            lookupUrl = new URL(downcast(lookupUrl, "string"), location.href).href;
            openNewTab(string_exports.encode`https://images.google.com/searchbyimage?client=app&image_url=${lookupUrl}`);
            break;
          case "showImageSettings":
            open3(module9.moduleID, "mediaControls");
            break;
          case "clippy":
            e2.target.textContent = [
              module9.options.imageZoom.value && "drag to resize",
              module9.options.imageMove.value && "shift-drag to move"
            ].filter(Boolean).join(" or ");
            module9.options.clippy.value = false;
            save2(module9.options.clippy);
            break;
          default:
            break;
        }
        e2.stopPropagation();
        e2.preventDefault();
      });
      return wrapper;
    }
  };
  var Gallery = class extends Media {
    filmstripLoadIncrement = parseInt(module9.options.filmstripLoadIncrement.value, 10) || Infinity;
    preloadCount = parseInt(module9.options.galleryPreloadCount.value, 10) || 0;
    individualCtrl;
    msgPosition;
    ctrlToFilmstrip;
    ctrlConcurrentIncrease;
    pieces;
    lastRevealedPiece = null;
    filmstripActive;
    rememberResizeWidth;
    lastResizedWidth;
    constructor(options6, context) {
      super();
      this.element = galleryTemplate({
        title: options6.title,
        caption: options6.caption,
        credits: options6.credits,
        src: options6.src
      });
      const piecesContainer = this.element.querySelector(".res-gallery-pieces");
      this.individualCtrl = this.element.querySelector(".res-step-container");
      const ctrlPrev = this.individualCtrl.querySelector(".res-step-previous");
      const ctrlNext = this.individualCtrl.querySelector(".res-step-next");
      this.msgPosition = this.individualCtrl.querySelector(".res-step-position");
      this.ctrlToFilmstrip = this.individualCtrl.querySelector(".res-gallery-to-filmstrip");
      this.ctrlConcurrentIncrease = this.element.querySelector(".res-gallery-increase-concurrent");
      this.pieces = options6.src.map((src) => ({
        generateMedia: () => generateMedia(src, context),
        media: null,
        wrapper: string_exports.html`<div hidden></div>`
      }));
      piecesContainer.append(...this.pieces.map(({ wrapper }) => wrapper));
      const slideshowWhenLargerThan = parseInt(module9.options.useSlideshowWhenLargerThan.value, 10) || Infinity;
      this.filmstripActive = module9.options.galleryAsFilmstrip.value && this.pieces.length < slideshowWhenLargerThan;
      if (this.filmstripActive || this.pieces.length === 1) {
        this.ready = this.expandFilmstrip();
        this.ctrlConcurrentIncrease.addEventListener("click", () => this.expandFilmstrip());
      } else {
        this.ready = this.changeSlideshowPiece(0);
        ctrlPrev.addEventListener("click", () => {
          this.changeSlideshowPiece(-1);
        });
        ctrlNext.addEventListener("click", () => {
          this.changeSlideshowPiece(1);
        });
        waitForEvent(this.ctrlToFilmstrip, "click").then(() => {
          const currentIndex = this.pieces.indexOf(this.lastRevealedPiece);
          if (currentIndex > 0) {
            const showFromBeginning = document.createElement("div");
            showFromBeginning.textContent = "Show earlier pieces";
            showFromBeginning.style.cursor = "pointer";
            piecesContainer.before(showFromBeginning);
            showFromBeginning.addEventListener("click", () => {
              this.expandFilmstrip({ revealFrom: 0, revealTo: currentIndex });
              showFromBeginning.remove();
            });
          }
          this.expandFilmstrip();
          this.ctrlConcurrentIncrease.addEventListener("click", () => this.expandFilmstrip());
        });
      }
    }
    shouldRememberResizeWidth() {
      return module9.options.galleryRememberWidth.value && !this.filmstripActive;
    }
    rememberWidth(piece) {
      const resizedElement = piece.media && piece.media.element.querySelector(".res-media-zoomable");
      const resizedWidth = resizedElement && parseInt(resizedElement.style.width, 10);
      if (resizedWidth) this.lastResizedWidth = resizedWidth;
    }
    restoreWidth(piece) {
      if (!this.lastResizedWidth) return;
      const resizeElement = piece.media && piece.media.element.querySelector(".res-media-zoomable");
      if (resizeElement) resize(resizeElement, this.lastResizedWidth);
    }
    revealPiece(piece) {
      if (this.shouldRememberResizeWidth() && this.lastRevealedPiece) this.rememberWidth(this.lastRevealedPiece);
      this.lastRevealedPiece = piece;
      piece.media = piece.media || piece.generateMedia();
      const { media, wrapper } = piece;
      if (!media.isAttached()) wrapper.appendChild(media.element);
      wrapper.hidden = false;
      if (this.shouldRememberResizeWidth()) this.restoreWidth(piece);
      if (this.isAttached()) media.expand();
    }
    preloadAhead() {
      const preloadFrom = this.pieces.indexOf(this.lastRevealedPiece);
      const preloadTo = Math.min(preloadFrom + this.preloadCount + 1, this.pieces.length);
      return preloadMedia(this.pieces.slice(preloadFrom, preloadTo));
    }
    async expandFilmstrip({
      revealFrom = this.lastRevealedPiece ? this.pieces.indexOf(this.lastRevealedPiece) + 1 : 0,
      revealTo = Math.min(revealFrom + this.filmstripLoadIncrement, this.pieces.length)
    } = {}) {
      this.individualCtrl.remove();
      this.ctrlConcurrentIncrease.hidden = true;
      await forEachSeq(this.pieces.slice(revealFrom, revealTo), (piece) => {
        this.revealPiece(piece);
        return piece.media && piece.media.ready;
      });
      if (revealTo < this.pieces.length) {
        this.ctrlConcurrentIncrease.innerText = `Show next ${Math.min(this.filmstripLoadIncrement, this.pieces.length - revealTo)} pieces`;
        this.ctrlConcurrentIncrease.hidden = false;
      }
      return this.preloadAhead();
    }
    changeSlideshowPiece(step) {
      const previous2 = this.lastRevealedPiece;
      const previousIndex = previous2 ? this.pieces.indexOf(previous2) : 0;
      let newIndex2 = previousIndex + step;
      newIndex2 = positiveModulo(newIndex2, this.pieces.length);
      this.individualCtrl.setAttribute("first-piece", String(newIndex2 === 0));
      this.individualCtrl.setAttribute("last-piece", String(newIndex2 === this.pieces.length - 1));
      this.msgPosition.innerText = String(newIndex2 + 1);
      this.revealPiece(this.pieces[newIndex2]);
      if (previous2) {
        const { media, wrapper } = previous2;
        if (!media) throw new Error();
        media.collapse();
        wrapper.hidden = true;
      }
      return this.preloadAhead();
    }
    supportsUnload() {
      return true;
    }
    setLoaded(state) {
      for (const { wrapper, media } of this.pieces) {
        if (!wrapper?.hidden && media && media.supportsUnload()) media.setLoaded(state);
      }
    }
    collapse() {
      for (const { media } of this.pieces) {
        if (media) media.collapse();
      }
    }
  };
  var Image = class extends Media {
    image;
    src;
    constructor({
      title,
      caption,
      credits,
      src,
      href
    }, context) {
      super();
      this.src = src;
      this.element = imageTemplate({
        title,
        caption,
        credits,
        src,
        href: href || context.href,
        openInNewWindow: module9.options.openInNewWindow.value
      });
      this.image = downcast(this.element.querySelector("img.res-image-media"), HTMLImageElement);
      const anchor2 = this.element.querySelector("a.res-expando-link");
      this.ready = waitForEvent(this.image, "load", "error");
      this.image.addEventListener("error", () => {
        this.element.classList.add("res-media-load-error");
      });
      if (module9.options.displayOriginalResolution.value) {
        this.image.addEventListener("load", () => {
          this.image.title = `${this.image.naturalWidth} \xD7 ${this.image.naturalHeight} px`;
        });
      }
      this.setMaxSize(this.image);
      const wrapper = this.addControls(anchor2, src, src);
      this.makeZoomable(this.image);
      this.makeMovable(wrapper);
      this.keepVisible(wrapper);
      this.makeIndependent(wrapper);
    }
    supportsUnload() {
      return true;
    }
    _unload() {
      this.image.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    }
    _restore() {
      this.image.src = this.src;
    }
  };
  var Iframe = class extends Media {
    loaded = false;
    loadPromise;
    iframe;
    pauseCommand;
    playCommand;
    constructor({
      embed,
      embedAutoplay,
      width = "640px",
      height = "360px",
      fixedRatio = false,
      pause: pauseCommand,
      play: playCommand
    }) {
      super();
      this.pauseCommand = pauseCommand;
      this.playCommand = playCommand;
      this.element = iframeTemplate({
        url: module9.options.autoplayVideo.value && embedAutoplay ? embedAutoplay : embed,
        width,
        height
      });
      this.iframe = downcast(this.element.querySelector("iframe"), HTMLIFrameElement);
      const iframeWrapper = downcast(this.element.firstElementChild, HTMLElement);
      const dragHandle = this.element.querySelector(".res-iframe-expando-drag-handle");
      this.onAttach = () => {
        this.loadPromise = waitForEvent(this.iframe, "load").then(() => {
          if (this.isAttached() && this.element.offsetParent) {
            this.loaded = true;
          } else {
            return Promise.reject(new Error("Iframe is not visible"));
          }
        });
      };
      this.makeZoomable(this.iframe, dragHandle, !fixedRatio);
      this.makeMovable(iframeWrapper, dragHandle);
      this.keepVisible(iframeWrapper);
      this.makeIndependent(iframeWrapper);
    }
    async expand() {
      if (module9.options.autoplayVideo.value && this.playCommand) {
        await this.loadPromise;
        try {
          this.iframe.contentWindow.postMessage(this.playCommand, "*");
        } catch (e2) {
          console.error('Could not post "play" command to iframe', this, e2);
        }
      }
    }
    collapse() {
      if (this.loaded && this.pauseCommand) {
        try {
          this.iframe.contentWindow.postMessage(this.pauseCommand, "*");
          return;
        } catch (e2) {
          console.error('Could not post "pause" command to iframe', this, e2);
        }
      }
      this.element.remove();
      this.loaded = false;
    }
  };
  var Text = class extends Media {
    constructor({
      title,
      credits,
      src
    }) {
      super();
      this.element = textTemplate({
        title,
        credits,
        src: import_dompurify2.default.sanitize(src)
      });
    }
  };
  var Audio = class extends Media {
    autoplay;
    audio;
    constructor({
      autoplay = false,
      loop,
      sources
    }) {
      super();
      this.autoplay = autoplay;
      this.element = audioTemplate({
        loop,
        sources
      });
      this.audio = downcast(this.element.querySelector("audio"), HTMLAudioElement);
    }
    collapse() {
      if (!this.isAttached()) return;
      this.autoplay = !this.audio.paused;
      if (!this.audio.paused) this.audio.pause();
    }
    expand() {
      if (this.autoplay) this.audio.play();
    }
  };
  var Generic = class extends Media {
    constructor(options6) {
      super();
      this.onAttach = options6.onAttach;
      this.element = document.createElement("div");
      this.element.appendChild(options6.generate());
    }
    // Always remove content, in case it contains audio or other unwanted things
    collapse() {
      this.element.remove();
    }
  };
  var trackVisitNative = batch(async (things2) => {
    if (!document.body.classList.contains("gold")) return;
    if (isPrivateBrowsing()) return;
    await ajax({
      method: "POST",
      url: "/api/store_visits",
      data: { links: things2.map((t2) => t2.getFullname()).join(",") }
    });
  }, { delay: 1e4, size: 50 });
  function trackMediaLoad(link, thing) {
    if (!module9.options.markVisited.value) return;
    if (thing) trackVisitNative(thing);
    if (!(thing && thing.isNSFW() && module9.options.sfwHistory.value !== "add")) {
      addURLToHistory(link.href);
    }
  }
  function addSiteAttribution(siteModule, media) {
    const $element = (0, import_jquery8.default)(siteAttributionTemplate({
      name: siteModule.name,
      url: siteModule.landingPage || `https://${siteModule.domains[0]}`,
      logoUrl: siteModule.logo,
      settingsLink: makeUrlHash(module9.moduleID, siteModuleOptionKey(siteModule))
    }));
    const $replace = (0, import_jquery8.default)(".res-expando-siteAttribution", media.element);
    if ($replace.length) {
      $element.replaceAll($replace);
    } else {
      $element.addClass("res-expando-siteAttribution-generic").appendTo(media.element);
    }
  }
  function addDragListener({ media, element, atShiftKey, onStart, onMove }) {
    let hasFrameExecution = false;
    const setFrameExecution = (() => {
      const throttle4 = frameThrottle(() => {
        hasFrameExecution = false;
      });
      return () => {
        throttle4();
        hasFrameExecution = true;
      };
    })();
    let isActive, hasMoved, lastX, lastY;
    const handleMove = (e2) => {
      const movementX = e2.clientX - lastX;
      const movementY = e2.clientY - lastY;
      if (!movementX && !movementY) {
        return;
      } else if (1 & ~e2.buttons) {
        stop();
        return;
      } else if (atShiftKey !== e2.shiftKey) {
        isActive = false;
        ({ clientX: lastX, clientY: lastY } = e2);
        return;
      }
      if (!isActive) {
        if (onStart) onStart(lastX, lastY);
        isActive = true;
        hasMoved = true;
        requestAnimationFrame(() => {
          media.classList.add("res-media-dragging");
        });
      }
      if (hasFrameExecution) return;
      setFrameExecution();
      onMove(e2.clientX, e2.clientY, movementX, movementY);
      ({ clientX: lastX, clientY: lastY } = e2);
    };
    function handleClick(e2) {
      if (hasMoved) e2.preventDefault();
    }
    function stop() {
      requestAnimationFrame(() => {
        media.classList.remove("res-media-dragging");
      });
      document.removeEventListener("mousemove", handleMove);
      document.removeEventListener("mouseup", stop);
      setTimeout(() => document.removeEventListener("click", handleClick));
    }
    function initiate(e2) {
      if (e2.button !== 0) return;
      ({ clientX: lastX, clientY: lastY } = e2);
      hasMoved = false;
      isActive = false;
      document.addEventListener("mousemove", handleMove);
      document.addEventListener("mouseup", stop);
      document.addEventListener("click", handleClick);
      e2.preventDefault();
    }
    element.addEventListener("mousedown", initiate);
  }
  var mutedVideoManager = once_default(() => {
    const maxSimultaneousPlaying = parseInt(module9.options.maxSimultaneousPlaying.value, 10) || Infinity;
    const videos = [];
    const updatePlay = frameThrottle(() => {
      const all2 = videos.filter((media) => !(media.video.paused && !media.autoPaused) && (media.video.muted || !media.video.volume)).map((media) => {
        const video = media.video;
        const thing = Thing.from(video);
        return {
          media,
          visibility: getPercentageVisibleYAxis(video),
          top: video.getBoundingClientRect().top,
          selected: Number(thing && thing.isSelected())
        };
      });
      const notVisible = all2.filter(({ visibility }) => visibility === 0);
      for (const { media } of notVisible) media.setAutoPause(true);
      without_default(all2, ...notVisible).sort((a2, b2) => b2.selected - a2.selected || b2.visibility - a2.visibility || a2.top - b2.top).forEach(({ media }, index2) => {
        media.setAutoPause(index2 >= maxSimultaneousPlaying);
      });
    });
    let intervalId = null;
    return {
      observe(video) {
        videos.push(video);
        updatePlay();
        if (intervalId === null) intervalId = setInterval(updatePlay, 100);
      },
      unobserve(video) {
        pull_default(videos, video);
        if (!videos.length && intervalId) {
          clearInterval(intervalId);
          intervalId = null;
        }
      }
    };
  });
  var Video = class _Video extends Media {
    static volumeStorage = storage_exports.wrap("showImages.video.volume", 1);
    video;
    autoplay;
    time;
    frameRate;
    autoPaused;
    dashPlayer;
    _loaded = false;
    constructor({
      title,
      caption,
      credits,
      fallback,
      frameRate = 24,
      href,
      loop = false,
      muted = false,
      playbackRate = 1,
      poster,
      reversable = false,
      reversed = false,
      source,
      sources,
      time = 0
    }, context) {
      super();
      this.autoplay = muted || module9.options.autoplayVideo.value;
      this.time = time;
      this.frameRate = frameRate;
      this.element = videoTemplate({
        title,
        caption,
        credits,
        source: source || href || context.href,
        // Prevent poster from flashing before the video is ready when autoplaying
        poster: !this.autoplay && poster || "",
        hasAudio: !muted,
        loop,
        reversable,
        formattedPlaybackRate: this.formatMultilineNumber(playbackRate, "x")
      });
      this.video = downcast(this.element.querySelector("video"), HTMLVideoElement);
      const container2 = this.element.querySelector(".res-video-container");
      const msgError = this.element.querySelector(".res-video-error");
      const displayError = (message) => {
        msgError.hidden = false;
        msgError.textContent = `Could not play video: ${message}`;
      };
      const sourceElements = filterMap(sources, (v) => {
        if (this.video.canPlayType(v.type)) {
          const source2 = document.createElement("source");
          source2.src = v.source;
          source2.type = v.type;
          if (v.reverse) source2.dataset.reverse = v.reverse;
          return [source2];
        } else {
          if (v.type === "application/dash+xml") {
            this.dashPlayer = loadScript("/dash.mediaplayer.min.js").then(() => {
              dashjs.skipAutoCreate = true;
              const player = dashjs.MediaPlayer().create();
              const url = URL.createObjectURL(new Blob([v.source], { type: "application/dash+xml" }));
              player.initialize();
              player.setAutoPlay(false);
              player.attachView(this.video);
              player.attachSource(url);
              return {
                stop: () => player.attachSource(null),
                continue: () => player.attachSource(url)
              };
            });
            return [document.createElement("span")];
          }
        }
      });
      if (!sourceElements.length) {
        if (fallback) {
          return new Image({
            // eslint-disable-line no-constructor-return
            type: "IMAGE",
            title,
            caption,
            credits,
            src: fallback
          }, context);
        } else {
          displayError("No playable sources were found");
        }
      }
      this.video.append(...sourceElements);
      this.video.addEventListener("play", () => {
        empty(msgError);
        msgError.hidden = true;
      });
      this.video.addEventListener("stalled", () => {
        displayError("Loading stalled");
      });
      this.video.addEventListener("error", () => {
        displayError("Unknown error");
      });
      if (reversed) this.reverse();
      this.ready = Promise.race([
        // 'ended' is not triggered when the video loops
        waitForEvent(this.video, "ended"),
        waitForEvent(this.video, "error"),
        waitForEvent(this.video, "canplaythrough")
      ]);
      const setPlayIcon = () => {
        if (!this.video.paused) this.element.setAttribute("playing", "");
        else this.element.removeAttribute("playing");
      };
      this.video.addEventListener("pause", () => {
        setPlayIcon();
      });
      this.video.addEventListener("play", setPlayIcon);
      this.video.addEventListener("loadedmetadata", () => {
        if (this.time !== this.video.currentTime) this.video.currentTime = this.time;
      });
      this.video.playbackRate = playbackRate;
      this.video.addEventListener("mousedown", (e2) => {
        if (this.video.hasAttribute("controls")) {
          const { height, top } = this.video.getBoundingClientRect();
          let controlsBottomHeight = 0;
          if (true) controlsBottomHeight = 40;
          if (height - controlsBottomHeight < e2.clientY - top) {
            e2.stopImmediatePropagation();
          }
        }
      });
      this.video.addEventListener("dblclick", async () => {
        if (document.fullscreen) return;
        const initialControlsState = this.video.controls;
        this.video.controls = true;
        const enterFullscreenPromise = waitForEvent(this.video, "fullscreenchange", "fullscreenerror");
        this.video.requestFullscreen();
        await enterFullscreenPromise;
        if (document.fullscreen) await waitForEvent(this.video, "fullscreenchange", "dblclick");
        if (document.fullscreen) document.exitFullscreen();
        this.video.controls = initialControlsState;
      });
      Promise.all([waitForEvent(this.element, "mouseenter"), waitForEvent(this.video, "canplay")]).then(() => this.addVideoControls());
      new MutationObserver(
        () => this.element.classList.toggle("res-video-has-native-controls", this.video.hasAttribute("controls"))
      ).observe(this.video, { attributes: true });
      if (!loop && this.autoplay) {
        waitForEvent(this.video, "ended").then(() => this.stopAutoplay());
      }
      if (!muted) {
        if (module9.options.startVideosMuted.value) this.video.muted = true;
        Promise.all([waitForEvent(this.video, "canplay"), _Video.volumeStorage.get()]).then(([, volume]) => {
          this.video.volume = volume;
        });
      }
      this.setMaxSize(this.video);
      this.makeZoomable(this.video);
      this.addControls(this.video, void 0, sourceElements[0].getAttribute("src"));
      this.makeMovable(container2);
      this.keepVisible(container2);
      this.makeIndependent(container2);
    }
    reverse() {
      this.time = this.video.duration - this.video.currentTime;
      if (isNaN(this.time)) this.time = 0;
      for (const v of this.video.querySelectorAll("source")) {
        [v.src, v.dataset.reverse] = [v.dataset.reverse, v.src];
      }
      this.video.load();
      this.video.play();
      this.element.toggleAttribute("reversed");
    }
    formatMultilineNumber(value, suffix) {
      return `${value.toFixed(2).replace(
        ".",
        ".\u200B"
        /* zwsp */
      )}${suffix}`;
    }
    addVideoControls() {
      const ctrlContainer = this.element.querySelector(".res-video-controls");
      const ctrlReverse = ctrlContainer.querySelector(".res-video-reverse");
      const ctrlTogglePause = ctrlContainer.querySelector(".res-video-toggle-pause");
      const ctrlSpeedDecrease = ctrlContainer.querySelector(".res-video-speed-decrease");
      const ctrlSpeedIncrease = ctrlContainer.querySelector(".res-video-speed-increase");
      const ctrlTimeDecrease = ctrlContainer.querySelector(".res-video-time-decrease");
      const ctrlTimeIncrease = ctrlContainer.querySelector(".res-video-time-increase");
      const progress = this.element.querySelector(".res-video-progress");
      const indicatorPosition = progress.querySelector(".res-video-position");
      const ctrlPosition = progress.querySelector(".res-video-position-thumb");
      const msgSpeed = ctrlContainer.querySelector(".res-video-speed");
      const msgTime = ctrlContainer.querySelector(".res-video-time");
      ctrlContainer.hidden = false;
      this.video.addEventListener("click", (e2) => {
        this.togglePlay();
        e2.preventDefault();
      });
      ctrlTogglePause.addEventListener("click", () => this.togglePlay());
      if (ctrlReverse) ctrlReverse.addEventListener("click", () => this.reverse());
      ctrlSpeedDecrease.addEventListener("click", () => {
        this.video.playbackRate /= 1.1;
      });
      ctrlSpeedIncrease.addEventListener("click", () => {
        this.video.playbackRate *= 1.1;
      });
      ctrlTimeDecrease.addEventListener("click", () => {
        this.video.currentTime -= 1 / this.frameRate;
      });
      ctrlTimeIncrease.addEventListener("click", () => {
        this.video.currentTime += 1 / this.frameRate;
      });
      this.video.addEventListener("ratechange", () => {
        msgSpeed.textContent = this.formatMultilineNumber(this.video.playbackRate, "x");
      });
      this.video.addEventListener("timeupdate", () => {
        indicatorPosition.style.left = `${this.video.currentTime / this.video.duration * 100}%`;
        msgTime.textContent = this.formatMultilineNumber(this.video.currentTime, "s");
      });
      progress.addEventListener("mousemove", (e2) => {
        let left = e2.offsetX;
        if (e2.target === ctrlPosition) {
          left += e2.target.offsetLeft;
        }
        ctrlPosition.style.left = `${left}px`;
        if (e2.buttons === 1) ctrlPosition.click();
      });
      ctrlPosition.addEventListener("click", (e2) => {
        const percentage = (e2.target.offsetLeft + e2.target.clientWidth / 2) / progress.clientWidth;
        this.video.currentTime = this.video.duration * percentage;
      });
      const ctrlVolume = ctrlContainer.querySelector(".res-video-volume");
      if (ctrlVolume) {
        const ctrlVolumeLevel = ctrlVolume.querySelector(".res-video-volume-level");
        const volumePercentage = ctrlVolume.querySelector(".res-video-volume-percentage");
        const updateVolume = (e2) => {
          const base = ctrlVolumeLevel.clientHeight;
          const click2 = base - e2.offsetY;
          const level = Math.min(click2 / base, 1);
          if (level > 0.01) {
            this.video.volume = level;
            this.video.muted = false;
            _Video.volumeStorage.set(level);
          }
        };
        ctrlVolume.addEventListener("click", () => {
          this.video.muted = !this.video.muted;
        });
        ctrlVolumeLevel.addEventListener("mousemove", (e2) => {
          if (e2.buttons === 1) updateVolume(e2);
        });
        ctrlVolumeLevel.addEventListener("click", (e2) => {
          updateVolume(e2);
          e2.stopPropagation();
        });
        const refresh3 = () => {
          ctrlVolume.setAttribute("level", this.video.muted || !this.video.volume ? "0" : String(Math.ceil(this.video.volume * 3)));
          volumePercentage.style.height = `${this.video.volume * 100}%`;
        };
        this.video.addEventListener("volumechange", refresh3);
        refresh3();
      }
    }
    togglePlay() {
      if (this.video.paused) this.video.play();
      else this.video.pause();
      if (this.video.paused) this.stopAutoplay();
    }
    stopAutoplay() {
      this.autoplay = false;
    }
    setAutoPause(state) {
      this.autoPaused = state;
      if (state !== this.video.paused) {
        if (state) this.video.pause();
        else this.video.play();
      }
    }
    supportsUnload() {
      return this.video.paused;
    }
    async _unload() {
      if (!this.isAttached()) return;
      if (!this.video.paused) this.video.pause();
      this.time = this.video.currentTime;
      if (this.dashPlayer) {
        (await this.dashPlayer).stop();
      } else {
        this.video.setAttribute("src", "");
        this.video.load();
      }
      mutedVideoManager().unobserve(this);
    }
    async _restore() {
      if (this.dashPlayer) {
        (await this.dashPlayer).continue();
      } else if (this.video.hasAttribute("src")) {
        this.video.removeAttribute("src");
        this.video.load();
      }
      this.video.currentTime = this.time;
      if (this.video.readyState === 0) await waitForEvent(this.video, "loadedmetadata");
      if (this.autoplay) this.video.play();
      mutedVideoManager().observe(this);
    }
  };
  function move2(ele, deltaX, deltaY) {
    ele.style.marginLeft = `${((parseFloat(ele.style.marginLeft) || 0) + deltaX).toFixed(2)}px`;
    ele.style.marginTop = `${((parseFloat(ele.style.marginTop) || 0) + deltaY).toFixed(2)}px`;
    if (deltaY) ele.dispatchEvent(new CustomEvent("mediaManuallyMovedVertically", { bubbles: true }));
  }
  function resize(ele, newWidth, newHeight) {
    if (newWidth < 20) return;
    if (typeof newHeight === "number") {
      ele.style.height = `${newHeight}px`;
    } else if (ele.style.height) {
      const { width, height } = ele.getBoundingClientRect();
      ele.style.height = `${(height / width * newWidth).toFixed(2)}px`;
    }
    ele.style.width = `${newWidth}px`;
    ele.style.maxWidth = ele.style.maxHeight = "none";
  }
  function toggleMute(ele) {
    const video = downcast(ele.querySelector("video"), HTMLVideoElement);
    if (video) {
      video.muted = !video.muted;
    }
  }

  // lib/modules/filteReddit/postCases/Expando.js
  var Expando2 = class extends Case {
    static text = "Expando";
    static parseCriterion(input2) {
      return { types: input2.split(/[\s|]/).filter(Boolean) };
    }
    static thingToCriterion(thing) {
      const expando2 = thing.isPost() ? Expando.getEntryExpandoFrom(thing) : Expando.getTextExpandosFrom(thing)[0];
      return expando2 && expando2.types.join(" & ") || "";
    }
    static defaultConditions = { types: [] };
    static fields = ["post has expando, and (if specified) expando types intersects with ", { type: "checkset", items: types, id: "types" }];
    static slow = 9;
    // In order to evaluate whether an expando matches, the expando must be built first (which is slow due to API requests)
    static pattern = `[(${types.join("|")})]`;
    static criterionOperators = true;
    trueText = this.conditions.types.length ? `expando ${this.conditions.types.join("|")}` : "expando";
    isValid() {
      return matchesTypes(this.value.types);
    }
    _matches(e2) {
      if (!e2) return false;
      if (!e2.ready) return null;
      return matchesTypes(this.value.types, e2.types);
    }
    _waitTillReady(thing) {
      const completeTask = thing.tasks.byId.get(module9);
      if (completeTask) {
        const promise = completeTask();
        if (!(promise instanceof Promise)) return;
        return Promise.race([
          promise.catch(() => {
          }),
          new Promise((res, rej) => {
            setTimeout(rej, 1500);
          })
        ]).catch(() => {
          promise.finally(() => {
            this.refresh();
          });
        });
      }
    }
    async evaluate(thing) {
      await this._waitTillReady(thing);
      if (thing.isPost()) {
        const expando2 = Expando.getEntryExpandoFrom(thing);
        return this._matches(expando2);
      } else {
        const expandos2 = Expando.getTextExpandosFrom(thing);
        const res = expandos2.map(this._matches.bind(this));
        if (res.some(Boolean)) return true;
        if (res.some((v) => v === null)) return null;
        return false;
      }
    }
    onObserve() {
      return true;
    }
  };

  // lib/modules/filteReddit/postCases/IsLocked.js
  var IsLocked = class extends Case {
    static text = "Locked";
    static fields = ["post is locked"];
    static unique = true;
    trueText = "locked";
    evaluate(thing) {
      return thing.isLocked();
    }
  };

  // lib/modules/filteReddit/postCases/IsNSFW.js
  var IsNSFW = class extends Case {
    static text = "NSFW";
    static fields = ["post is marked NSFW"];
    static unique = true;
    trueText = "nsfw";
    evaluate(thing) {
      return thing.isNSFW();
    }
  };

  // lib/modules/filteReddit/postCases/IsSpoiler.js
  var IsSpoiler = class extends Case {
    static text = "Spoiler";
    static fields = ["post is marked spoiler"];
    static unique = true;
    trueText = "spoiler";
    evaluate(thing) {
      return thing.isSpoiler();
    }
  };

  // lib/modules/filteReddit/postCases/IsVisited.js
  var IsVisited = class extends Case {
    static text = "Visited";
    static fields = ["link has been visited"];
    static slow = 2;
    static unique = true;
    trueText = "visited";
    evaluate(thing) {
      if (thing.element.classList.contains("visited")) return true;
      const link = thing.getPostLink();
      const dataUrl = thing.element.getAttribute("data-url");
      if (!link && !dataUrl) return null;
      return link && isURLVisited(link.href) || dataUrl !== link.href && isURLVisited(dataUrl);
    }
  };

  // lib/modules/filteReddit/postCases/LinkFlair.js
  var LinkFlair = class extends PatternCase {
    static text = "Link flair";
    static thingToCriterion(thing) {
      return thing.getPostFlairText();
    }
    static fields = ["post has link flair matching ", { type: "text", id: "patt" }];
    static pattern = "[RegEx]";
    trueText = `link flair ${this.conditions.patt}`.trim();
    value = this.build(false, "/./");
    evaluate(thing) {
      const text = thing.getPostFlairText();
      return this.value.some((v) => v.test(text));
    }
  };

  // lib/modules/filteReddit/postCases/PostAfter.js
  var PostAfter = class extends Case {
    static text = "Post after";
    static parseCriterion(input2) {
      return { patt: input2 };
    }
    static thingToCriterion(thing) {
      return thing.getTimestamp().toISOString();
    }
    static defaultConditions = { patt: (/* @__PURE__ */ new Date()).toISOString() };
    static fields = ["posted after date ", { type: "text", id: "patt" }];
    static pattern = "Date \u2014 string representing a RFC2822 or ISO 8601 date";
    trueText = `after ${this.conditions.patt}`;
    value = new Date(this.conditions.patt);
    isValid() {
      return !isNaN(this.value);
    }
    evaluate(thing) {
      const postTime = thing.getTimestamp();
      if (!postTime) return null;
      return postTime >= this.value;
    }
  };

  // lib/modules/filteReddit/postCases/PostAge.js
  var qualifiers = [["Y", 12], ["M", 30.44], ["d", 24], ["h", 60], ["m", 60], ["s", 1e3]];
  var now2 = /* @__PURE__ */ new Date();
  function prettifyAge(remainder) {
    let remainderQualifier = "";
    for (const [qualifier, multiplier] of qualifiers.slice().reverse()) {
      if (remainder < multiplier) break;
      remainder /= multiplier;
      remainderQualifier = qualifier;
    }
    return remainder.toFixed(2) + remainderQualifier;
  }
  var PostAge = class extends Case {
    static text = "Post age";
    static parseCriterion(input2) {
      let age = parseInt(input2, 10);
      if (isNaN(age)) throw new Error("Invalid age");
      const ageQualifier = input2.match(/Y|M|d|h|m|s/).at(0) || "s";
      age = dropWhile_default(qualifiers, ([qualifier]) => qualifier !== ageQualifier).reduce((a2, [, multiplier]) => a2 * multiplier, age);
      return { op: "<=", age };
    }
    static thingToCriterion(thing) {
      const remainder = now2 - new Date(thing.getTimestamp());
      if (isNaN(remainder)) throw new Error("Could not determine Thing date");
      return prettifyAge(remainder);
    }
    static defaultConditions = { op: "<=", age: 4 * 60 * 60 * 1e3 };
    static fields = ["post is ", { type: "select", options: "COMPARISON", id: "op" }, " ", { type: "duration", id: "age" }, " old"];
    static pattern = "x[(Y|M|d|h|m)] \u2014 where x is the number of seconds or Y year, M month, h hour, m minute (case sensitive)";
    trueText = `age ${prettyOperator(this.conditions.op)} ${prettifyAge(this.conditions.age)}`;
    falseText = `age ${prettyOperator(inverseOperator(this.conditions.op))} ${prettifyAge(this.conditions.age)}`;
    evaluate(thing) {
      const postTime = thing.getTimestamp();
      if (!postTime) return null;
      return numericalCompare(this.value.op, now2 - postTime, this.value.age);
    }
  };

  // lib/modules/filteReddit/postCases/PostTitle.js
  var PostTitle = class extends PatternCase {
    static text = "Post title";
    static fields = ["post's title contains ", { type: "text", id: "patt" }];
    trueText = `title contains ${this.conditions.patt}`;
    value = this.build(false);
    evaluate(thing) {
      const title = thing.getTitle();
      return this.value.some((v) => v.test(title));
    }
  };

  // lib/modules/filteReddit/postCases/PostType.js
  var options = [
    ["link post", "link"],
    ["self post", "self"]
  ];
  var PostType = class extends Case {
    static text = "Post type";
    static parseCriterion(input2) {
      return { kind: input2 };
    }
    static defaultConditions = { kind: "link" };
    static fields = ["post is a ", { type: "select", id: "kind", options }];
    static pattern = `(${options.map(([, cls]) => cls).join("|")})`;
    trueText = `type ${this.conditions.kind}`;
    isValid() {
      return options.map(([, cls]) => cls).includes(this.value.kind);
    }
    evaluate(thing) {
      switch (this.value.kind) {
        case "link":
          return thing.isLinkPost();
        case "self":
          return thing.isSelfPost();
        default:
          return null;
      }
    }
  };

  // lib/modules/filteReddit/postCases/Score.js
  var Score = class extends Case {
    static text = "Score";
    static defaultConditions = { op: ">", val: 0 };
    static fields = ["post has ", { type: "select", options: "COMPARISON", id: "op" }, " ", { type: "number", id: "val" }, " points"];
    static parseCriterion(input2) {
      return { op: ">=", val: parseInt(input2, 10) };
    }
    static thingToCriterion(thing) {
      return String(thing.getScore());
    }
    static pattern = "integer";
    trueText = `score ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    falseText = `score ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
    isValid() {
      return Number.isInteger(this.value.val);
    }
    evaluate(thing) {
      const score = thing.getScore();
      if (isNaN(score)) return null;
      return numericalCompare(this.value.op, score, this.value.val);
    }
  };

  // lib/modules/filteReddit/postCases/Selector.js
  var import_jquery9 = __toESM(require_jquery(), 1);
  var Selector = class extends Case {
    static text = "Selector";
    static parseCriterion(input2) {
      return { patt: input2 };
    }
    static defaultConditions = { patt: "" };
    static fields = ["thing matches jQuery selector ", { type: "text", id: "patt" }];
    static slow = 10;
    // Can cause reflow, e.g. by using `:contains()`
    static pattern = "string";
    trueText = `$('${this.conditions.patt.replace(/\'/g, "\\'")}')`;
    falseText = `$(':not(${this.conditions.patt.replace(/\'/g, "\\'")}'))`;
    isValid() {
      return this.value.patt && !!(0, import_jquery9.default)(this.value.patt);
    }
    evaluate(thing) {
      return (0, import_jquery9.default)(thing.element).is(this.value.patt) || (0, import_jquery9.default)(thing.entry).is(this.value.patt) || !!(0, import_jquery9.default)(thing.entry).has(this.value.patt).length;
    }
  };

  // lib/modules/filteReddit/postCases/Subreddit.js
  var Subreddit = class extends PatternCase {
    static text = "Subreddit";
    static thingToCriterion(thing) {
      return thing.getSubreddit();
    }
    static fields = ["posted in /r/", { type: "text", id: "patt" }];
    trueText = `in ${this.conditions.patt}`;
    value = this.build(true);
    evaluate(thing) {
      const subreddit2 = thing.getSubreddit();
      if (!subreddit2) return null;
      return this.value.some((v) => v.test(subreddit2));
    }
  };

  // lib/modules/filteReddit/postCases/UserAttr.js
  var options2 = [
    ["a friend", "friend"],
    ["a moderator", "moderator"],
    ["an admin", "admin"],
    ["me", "me"],
    ["op", "submitter"]
  ];
  var UserAttr = class extends Case {
    static text = "User attribute";
    static parseCriterion(input2) {
      return { attr: input2 };
    }
    static fields = ["user is ", { type: "select", id: "attr", options: options2 }];
    static defaultConditions = { attr: "friend" };
    static pattern = `(${options2.map(([, cls]) => cls).join("|")})`;
    trueText = `by ${this.conditions.attr}`;
    isValid() {
      return options2.map(([, cls]) => cls).includes(this.value.attr);
    }
    evaluate(thing) {
      if (this.value.attr === "me") {
        const myName = loggedInUser();
        const author = thing.getAuthor();
        if (!myName || !author) return null;
        return author.trim().toLowerCase() === myName.trim().toLowerCase();
      } else {
        const element = thing.getAuthorElement();
        if (!element) return null;
        return element.classList.contains(this.value.attr);
      }
    }
  };

  // lib/modules/filteReddit/postCases/UserFlair.js
  var UserFlair = class extends PatternCase {
    static text = "User flair";
    static thingToCriterion(thing) {
      return thing.getUserFlairText();
    }
    static fields = ["author of this post has flair matching ", { type: "text", id: "patt" }];
    static pattern = "[RegEx]";
    trueText = `user flair ${this.conditions.patt}`.trim();
    value = this.build(false, "/./");
    evaluate(thing) {
      const text = thing.getUserFlairText();
      return this.value.some((v) => v.test(text));
    }
  };

  // lib/modules/userTagger.js
  var userTagger_exports = {};
  __export(userTagger_exports, {
    Tag: () => Tag,
    applyToUser: () => applyToUser,
    module: () => module13,
    tags: () => tags
  });
  var import_jquery12 = __toESM(require_jquery(), 1);

  // lib/modules/filteReddit.js
  var filteReddit_exports = {};
  __export(filteReddit_exports, {
    addCustomFilter: () => addCustomFilter,
    addExternalFilter: () => addExternalFilter,
    addOndemandCase: () => addOndemandCase,
    defaultFilters: () => defaultFilters,
    ensureFilterlineVisible: () => ensureFilterlineVisible,
    filterlinePromise: () => filterlinePromise,
    listFilters: () => listFilters,
    module: () => module11,
    saveFilterlineStateAsDefault: () => saveFilterlineStateAsDefault,
    updateCustomFilter: () => updateCustomFilter
  });

  // lib/modules/customToggles.js
  var import_jquery10 = __toESM(require_jquery(), 1);
  var module10 = new Module("customToggles");
  module10.moduleName = "customTogglesName";
  module10.category = "coreCategory";
  module10.description = "customTogglesDesc";
  module10.options = {
    toggle: {
      description: "customTogglesToggleDesc",
      title: "customTogglesToggleTitle",
      type: "table",
      fields: [{
        key: "id",
        name: "id",
        type: "hidden",
        get value() {
          return `~${performance.timing.navigationStart + performance.now()}`;
        }
      }, {
        key: "enabled",
        name: "enabled",
        type: "boolean",
        value: true
      }, {
        key: "text",
        name: "text",
        type: "text"
      }],
      value: []
    }
  };
  var toggles = /* @__PURE__ */ new Map();
  var customToggles = [];
  module10.beforeLoad = () => {
    for (const instance of module10.options.toggle.value) {
      const [key, initialEnabled, text] = instance;
      if (toggles.has(key)) {
        console.error(`A toggle with key ${key} already exists`, instance);
        continue;
      }
      const toggle7 = new Toggle(key, text, initialEnabled);
      customToggles.push(toggle7);
      toggle7.onStateChange(() => {
        instance[1] = toggle7.enabled;
        (0, import_jquery10.default)(module10).trigger(import_jquery10.default.Event("toggle"));
      });
      toggle7.onToggle(() => {
        save2(module10.options.toggle);
      });
      toggle7.addMenuItem();
    }
  };
  module10.contentStart = () => {
    registerCommandLine();
  };
  var Toggle = class {
    text;
    enabled;
    stateChangeCallbacks = [];
    // Invoked on all tabs
    toggleCallbacks = [];
    // Invoked on the tab which caused the change
    multicast;
    constructor(key, text, enabled2) {
      this.text = text;
      this.enabled = enabled2;
      this.multicast = multicast(frameThrottle((enabled3) => {
        this.toggle("multicast", enabled3);
      }), { local: false, name: `toggle.${key}` });
      toggles.set(key, this);
    }
    toggle(type = "manual", state = !this.enabled) {
      if (this.enabled === state) return;
      this.enabled = state;
      for (const callback of this.stateChangeCallbacks) callback();
      if (type !== "multicast") {
        for (const callback of this.toggleCallbacks) callback(type);
        if (type !== "autoLocal") this.multicast(state);
      }
    }
    onStateChange(callback) {
      this.stateChangeCallbacks.push(callback);
    }
    onToggle(callback) {
      this.toggleCallbacks.push(callback);
    }
    addMenuItem(title = `Toggle ${this.text}`, order = 9, on2, off2) {
      addMenuItem(
        once_default(() => {
          const item = string_exports.html`<div title="${title}">${this.text || "\xA0"}</div>`;
          const toggle7 = createElement_exports.toggleButton(void 0, this.text, this.enabled, on2, off2);
          item.append(toggle7);
          this.onStateChange(() => {
            toggle7.classList.toggle("enabled", this.enabled);
          });
          return item;
        }),
        (e2) => {
          this.toggle();
          e2.stopPropagation();
        },
        order
      );
    }
    addCLI(commandPredicate) {
      registerCommand(
        commandPredicate,
        `${commandPredicate} - toggle ${this.text}`,
        () => ` ${this.enabled ? "Disable" : "Enable"} ${this.text}`,
        () => {
          this.toggle();
        }
      );
    }
    buildCheckbox() {
      const checkbox = document.createElement("input");
      checkbox.setAttribute("type", "checkbox");
      checkbox.checked = this.enabled;
      checkbox.addEventListener("change", () => {
        this.toggle("manual", checkbox.checked);
      });
      this.onStateChange(() => {
        checkbox.checked = this.enabled;
      });
      return checkbox;
    }
  };
  function registerCommandLine() {
    const getMatchingToggles = (val) => Array.from(toggles.values()).filter(({ text }) => text.toLowerCase().match(val.toLowerCase())).sort(({ text: a2 }, { text: b2 }) => a2.localeCompare(b2));
    const bestMatch = (val) => sortBy_default(getMatchingToggles(val), ({ text }) => text.toLowerCase().indexOf(val.toLowerCase()))[0];
    registerCommand(
      "toggle",
      "toggle - toggle any custom toggle",
      (command, val) => getMatchingToggles(val).length ? `Toggle ${getMatchingToggles(val).map((toggle7) => toggle7 === bestMatch(val) ? `<b>${toggle7.text}</b>` : toggle7.text).join("|")}` : `No toggles matching <i>${val}</i>`,
      (command, val) => {
        const match = getMatchingToggles(val)[0];
        if (match) match.toggle();
        else return `${val} does not match a valid toggle`;
      }
    );
  }
  function toggleActive(key) {
    const toggle7 = toggles.get(key);
    return !!toggle7 && toggle7.enabled;
  }
  var getToggles = () => (stage_exports.get(module10.moduleID) || module10.options).toggle.value.map(([key, , text]) => ({ key, text }));

  // lib/modules/filteReddit/Filterline.js
  var import_jquery11 = __toESM(require_jquery(), 1);

  // lib/modules/filteReddit/Filter.js
  var Filter = class {
    id;
    name;
    parent;
    updatePromise;
    BaseCase;
    case;
    state;
    active = false;
    element;
    effects = {};
    constructor(id2, BaseCase, name2, conditions = null, state = true, effects = {}) {
      this.id = id2;
      this.BaseCase = BaseCase;
      this.name = name2;
      this.state = state;
      Object.assign(this.effects, pickBy_default(effects, Boolean));
      this.setCase(BaseCase.fromConditions(conditions));
    }
    isActive() {
      return !!this.getEffects().length && this.case.isEvaluatable();
    }
    createElement() {
    }
    setParent(parent2) {
      this.parent = parent2;
    }
    getStateText(state = this.state, cased = this.case) {
      return state !== false ? this.name || cased.trueText || (this.BaseCase.text || this.BaseCase.type).toLowerCase() : this.name && `\xAC ${this.name}` || cased.falseText || `\xAC ${this.getStateText(true, cased)}`;
    }
    getSaveValues() {
      const values = { type: this.BaseCase.type, state: this.state, effects: this.effects };
      if (this.BaseCase.variant === "basic") {
        values.conditions = this.case.conditions;
        if (this.name && this.name !== this.case.trueText) {
          values.name = this.name;
        }
      }
      return values;
    }
    remove() {
      for (const effect of Object.keys(this.effects)) this.effects[effect] = false;
      if (this.parent) this.parent.removeFilter(this);
    }
    getEffects() {
      return Object.entries(this.effects).filter(([, enabled2]) => enabled2).map(([name2]) => name2);
    }
    setCase(newCase) {
      this.case = newCase;
      this.active = this.isActive();
      if (this.active) this.case.observe(this);
    }
    update(state = this.state, conditions, effects = {}, describeOnly = false) {
      const cased = conditions === void 0 ? this.case : this.BaseCase.fromConditions(conditions, true);
      if (!cased.isValid()) throw new Error("Invalid conditions");
      if (describeOnly) {
        return `Show only posts which matches "${this.getStateText(state, cased)}"`;
      }
      this.state = state;
      Object.assign(this.effects, effects);
      this.setCase(cased);
      this.refresh();
      if (this.parent) this.parent.save();
    }
    refresh = (thing) => {
      if (!this.parent) return;
      this.updatePromise = this.parent.refresh(this, thing ? [thing] : void 0);
    };
    async updateByInputConstruction({
      criterion,
      disableFilter,
      reverseActive,
      fromSelected
    }, describeOnly = false) {
      if (disableFilter) {
        if (describeOnly) return "Disable filter";
        return this.update(void 0, void 0, { hide: false });
      }
      let state, conditions;
      if (fromSelected) {
        ({ state, conditions } = await this.BaseCase.getSelectedEntryValue());
      } else {
        if (criterion) conditions = this.BaseCase.criterionToConditions(criterion);
        state = this.state;
      }
      if (reverseActive) state = !state;
      return this.update(state, conditions, { hide: true }, describeOnly);
    }
    matches = fastAsync(function* (thing) {
      try {
        const result = yield this.case.evaluate(thing);
        return result === null ? false : this.state === !result;
      } catch (e2) {
        return false;
      }
    });
    getMatchingEntry(thing) {
      return this.case.conditions;
    }
    removeEntry(entry, effect) {
      this.update(void 0, void 0, { [effect]: false });
    }
    async buildReasonElement(thing, effect) {
      const entry = await this.getMatchingEntry(thing);
      const element = string_exports.html`
			<div class="res-thing-filter-remove-matching-entry" title="${JSON.stringify(entry, null, "  ")}">
				${effect}: ${this.getStateText(!this.state)}  click to remove matching filter entry
			</div>
		`;
      element.addEventListener("click", () => {
        this.removeEntry(entry, effect);
      });
      return element;
    }
  };

  // lib/modules/filteReddit/ExternalFilter.js
  var ExternalFilter = class extends Filter {
    toggleEffects = ["hide"];
    isActive() {
      return this.case.constructor.type !== "false" && super.isActive();
    }
    createElement() {
      this.element = string_exports.html`
			<div class="res-filterline-external-filter" type="${this.BaseCase.type}">
				<div>${this.name || this.BaseCase.type}</div>
			</div>
		`;
      if (module11.options.hasOwnProperty(this.BaseCase.type)) {
        this.element.prepend(string_exports.html`${string_exports.safe(
          makeUrlHashLink(module11.moduleID, this.BaseCase.type, " ", "gearIcon")
        )}`);
      }
      const setActive = (active) => {
        const effects = this.toggleEffects.reduce((acc, val) => {
          acc[val] = active;
          return acc;
        }, {});
        this.update(void 0, void 0, effects);
      };
      if (isUseful(this.case.constructor.type)) {
        const t2 = createElement_exports.toggleButton(setActive, null, this.isActive(), "", "");
        this.element.appendChild(t2);
      }
    }
  };

  // lib/modules/filteReddit/LineFilter.js
  var LineFilter = class extends Filter {
    initialConditions;
    constructor(id2, BaseCase, name2, conditions = null, state = true, effects = {}) {
      if (BaseCase.variant === "ondemand") {
        const externOpts = BaseCase._customFilter && BaseCase._customFilter.opts;
        if (externOpts) {
          if (!name2) ({ name: name2 } = externOpts);
          if (!effects.hasOwnProperty("propagate")) {
            const { propagate } = externOpts;
            Object.assign(effects, { propagate });
          }
        }
      }
      super(id2, BaseCase, name2, conditions, state, effects);
    }
    update(state = this.state, conditions, effects, describeOnly) {
      if (this.BaseCase.variant === "ondemand" && conditions && !describeOnly) {
        updateCustomFilter(this.BaseCase.getCustomFilter(), { body: conditions });
        conditions = null;
      }
      const message = super.update(state, conditions, effects, describeOnly);
      if (this.element) this.refreshElement();
      return message;
    }
    setParent(parent2) {
      super.setParent(parent2);
      this.getBuilder.cache.clear();
    }
    createElement() {
      this.element = string_exports.html`<div class="res-filterline-filter" type="${this.BaseCase.type}"></div>`;
      this.refreshElement();
      this.element.addEventListener("click", () => {
        if (!this.effects.hide) this.update(void 0, void 0, { hide: true });
        else if (this.state) this.update(false, void 0, { hide: true });
        else this.update(true, void 0, { hide: false });
      });
      this.element.addEventListener("contextmenu", (e2) => {
        if (this.effects.hide) this.update(void 0, void 0, { hide: false });
        else this.remove();
        e2.preventDefault();
      });
      this.element.addEventListener("mouseenter", async () => {
        await new Promise((res) => {
          setTimeout(res, 150);
        });
        if (this.element.matches(":hover")) this.showInfocard();
      });
      this.element.addEventListener("click", () => infocard("filterline-filter").resetShowTimer());
      this.element.addEventListener("contextmenu", () => infocard("filterline-filter").resetShowTimer());
    }
    showInfocard(immediately = false) {
      const card = infocard("filterline-filter");
      if (card.visible) immediately = true;
      card.target(this.element).options({ width: 570, openDelay: immediately ? 0 : 550, pin: pin.bottom }).populateWith(this.populateHover.bind(this)).begin();
    }
    refreshElement() {
      this.element.setAttribute("text", this.getStateText());
      this.element.classList.toggle("res-filterline-filter-disabled", this.BaseCase.variant !== "basic" && !this.case.isEvaluatable());
      this.element.classList.toggle("res-filterline-filter-hiding", this.case.isEvaluatable() && !!this.effects.hide);
    }
    // Memoize in order to preserve the builder when infocard closes
    getBuilder = memoize_default((filterline2, card) => {
      const builderCases = getByContext(filterline2.thingType);
      let lastConditions = this.case.conditions;
      if (this.BaseCase.variant === "ondemand") {
        Object.assign(builderCases, getByContext("browse"));
        lastConditions = this.BaseCase.getCustomFilter().body;
      }
      if (!this.initialConditions) this.initialConditions = lastConditions;
      const $builderBlock = caseBuilder_exports.drawBuilderBlock(lastConditions, builderCases, false);
      $builderBlock.on("change input", frameThrottle(() => {
        const conditions = caseBuilder_exports.readBuilderBlock($builderBlock, builderCases);
        if (!isEqual_default(lastConditions, conditions)) {
          lastConditions = conditions;
          this.update(void 0, conditions);
          const lastFocus = $builderBlock.get(0).contains(document.activeElement) && document.activeElement;
          if (lastFocus) card.refresh().then(() => lastFocus.focus());
        }
      }));
      sortable_core_esm_default.create($builderBlock.get(0), { handle: ".handle" });
      return {
        get builder() {
          return $builderBlock.get(0);
        },
        isCaseChanged: () => !isEqual_default(this.initialConditions, lastConditions)
      };
    });
    populateHover(card) {
      const { parent: filterline2 } = this;
      if (!filterline2) throw new Error("Filter not attached");
      const redraw = () => {
        this.getBuilder.cache.clear();
        card.refresh();
      };
      const head = string_exports.html`
			<div class="res-filterline-filter-hover-preamble">
				<span>Filter ${this.BaseCase.text}</span>
				<div class="res-filterline-filter-hover-group" group="case-actions">
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
			</div>
		`;
      const body = string_exports.html`
			<div class="res-filterline-filter-hover">
				<span class="res-filterline-filter-hover-options"></span>
				<span>For posts (<span class="res-filterline-filter-hover-number-matches"></span>) ${this.state ? "not " : ""}matching:</span>
				<div class="builderItem"></div>
				<div class="res-filterline-filter-hover-notice">${// Keep element empty when no text due to :empty selector
      this.BaseCase.variant === "ondemand" && 'By adding browse context conditions such as "Date", "Logged in user", and "Custom toggle", you control where and when this filter is available.'}</div>
				<div class="res-filterline-filter-hover-group" group="match-effects">
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
				<div class="res-filterline-filter-hover-group" group="match-actions" hidden>
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
		`;
      const { builder, isCaseChanged } = this.getBuilder(filterline2, card);
      body.querySelector(".builderItem").appendChild(builder);
      setTimeout(() => {
        if (!builder.contains(document.activeElement)) {
          const e2 = [...builder.querySelectorAll("input"), ...builder.querySelectorAll("select")].find((e3) => e3.offsetParent);
          if (e2) e2.focus();
        }
      });
      if (filterline2.thingType === "comment") {
        const options6 = body.querySelector(".res-filterline-filter-hover-options");
        const propagate = string_exports.html`<label style="display: flex; align-items: center;"><input style="margin-right: 3px;" type="checkbox" ${this.effects.propagate && "checked"}>Also hide children</label>`;
        options6.append(propagate);
        waitForEvent(propagate, "change").then(() => {
          this.update(void 0, void 0, { propagate: downcast(propagate.querySelector("input"), HTMLInputElement).checked });
        }).then(redraw);
      }
      function addButton(container2, text, groupName, action) {
        const button = string_exports.html`<button class="res-filterline-filter-hover-button" action="${action}">${text}</button>`;
        const group = downcast(container2.querySelector(`[group=${groupName}]`), HTMLElement);
        group.hidden = false;
        const buttons = downcast(group.querySelector(".res-filterline-filter-hover-buttons"), HTMLElement);
        buttons.appendChild(button);
        return waitForEvent(button, "click");
      }
      if (this.BaseCase.variant === "basic" && this.BaseCase === Group) {
        addButton(head, "To on-demand", "case-actions", "to-ondemand").then(() => {
          const conditions = getGroup("all", [
            getConditions("currentLocation"),
            getGroup(this.state ? "all" : "none", [this.case.conditions])
          ]);
          if (!this.name) this.name = window.prompt("Filter name:");
          this.BaseCase = addOndemandCase(
            addCustomFilter({
              body: resolveGroup(conditions, false, true),
              opts: {
                ondemand: true,
                name: this.name
              }
            })
          );
          this.update(true, null);
        }).then(redraw);
      }
      if (isCaseChanged()) {
        addButton(head, "Reset change", "case-actions", "reset").then(() => {
          this.update(void 0, this.initialConditions);
        }).then(redraw);
      }
      if (this.BaseCase.variant === "ondemand" || this.BaseCase === Group) {
        addButton(head, "Rename", "case-actions", "rename").then(() => {
          const name2 = window.prompt("New filter name:", this.case.trueText);
          if (!name2) return;
          if (this.BaseCase.variant === "ondemand") {
            const customFilter = this.BaseCase.getCustomFilter();
            updateCustomFilter(customFilter, { opts: { name: name2 } });
          }
          this.name = name2;
          this.update();
        }).then(redraw);
      }
      addButton(head, "Invert", "case-actions", "invert").then(() => {
        this.update(!this.state);
      }).then(redraw);
      addButton(head, "Remove", "case-actions", "remove").then(() => {
        this.remove();
      }).then(card.close.bind(card));
      addButton(body, this.effects.hide ? "Don't hide" : "Hide", "match-effects", `hide-${this.effects.hide ? "false" : "true"}`).then(() => {
        this.update(void 0, void 0, { hide: !this.effects.hide });
      }).then(redraw);
      addButton(body, this.effects.highlight ? "Don't highlighting" : "Highlight", "match-effects", "highlight").then(() => {
        this.update(void 0, void 0, { highlight: !this.effects.highlight });
      }).then(redraw);
      if (isRunning(commentNavigator_exports) && !this.effects.hide) {
        addButton(body, "Navigate by", "match-actions", "navigate-by").then(() => {
          updateCustomConditions(getGroup(this.state ? "none" : "all", [this.case.conditions]));
          setCategory("custom");
          card.close();
        });
      }
      asyncFilter(Array.from(filterline2.things), async (thing) => await this.matches(thing)).then((matches2) => {
        const numberSpan = body.querySelector(".res-filterline-filter-hover-number-matches");
        numberSpan.textContent = String(matches2.length);
        if (filterline2.thingType === "post" && matches2.length) {
          addButton(body, "Permanently hide", "match-actions", "native-hide").then(() => {
            filterline2.hidePermanently(matches2);
          });
        }
      });
      return [head, body];
    }
  };

  // lib/modules/filteReddit/Filterline.js
  var Filterline = class {
    things = /* @__PURE__ */ new Set();
    thingType;
    storage;
    filters = [];
    sortedFilters = [];
    // Filters sorted by slowness
    currentMatches = /* @__PURE__ */ new Map();
    permanentlyHiddenThings = /* @__PURE__ */ new Set();
    displayReasons = false;
    element;
    dropdown;
    preamble;
    filterContainer;
    poweredElement;
    permanentlyHideCheckbox;
    initialized = false;
    constructor(storage3, thingType3) {
      this.storage = storage3;
      this.thingType = thingType3;
    }
    // Initialize once things are being processed
    isInitialized() {
      if (this.initialized) return true;
      if (!this.things.size || !this.getActiveFilters().length) return false;
      this.initialized = true;
      this.sortedFilters = sortBy_default(this.filters, ({ case: { constructor: { slow } } }) => slow);
      if (this.thingType === "post") {
        delete this.availableEffects.collapse;
        delete this.availableEffects.propagate;
      }
      return true;
    }
    isPowered() {
      return !document.documentElement.classList.contains("res-filters-disabled");
    }
    togglePowered = (powered = !this.isPowered()) => {
      bodyClasses_exports.toggle(!powered, "res-filters-disabled");
      this.poweredElement.checked = powered;
    };
    createElement() {
      const element = this.element = string_exports.html`
			<div class="res-filterline">
				<div class="res-filterline-preamble"></div>
				<div class="res-filterline-filters">
					<input type="checkbox" ${this.isPowered() && "checked"} class="res-filterline-toggle-powered" title="Stop filtering temporarily"></input>
				</div>
			</div>
		`;
      this.preamble = element.querySelector(".res-filterline-preamble");
      this.filterContainer = element.querySelector(".res-filterline-filters");
      this.addFilterElements(this.filters);
      waitForEvent(this.preamble, "mouseenter", "click").then(() => this.createDropdown());
      this.poweredElement = downcast(element.querySelector(".res-filterline-toggle-powered"), HTMLInputElement);
      this.poweredElement.addEventListener("change", () => {
        this.togglePowered();
      });
    }
    addFilterElements(filters) {
      for (const filter of filters) {
        if (filter instanceof ExternalFilter) continue;
        filter.createElement();
        this.filterContainer.appendChild(filter.element);
      }
    }
    getFiltersOfCase(CaseClass) {
      return this.filters.filter((v) => v.BaseCase === CaseClass);
    }
    getPickable() {
      return Object.values(getByContext(this.thingType, false)).filter((v) => !v.disabled && v.variant !== "external");
    }
    createDropdown() {
      const element = string_exports.html`
			<div class="res-filterline-dropdown">
				<div class="res-filterline-dropdown-other"></div>
				<div class="res-filterline-dropdown-toggles">
					<div class="res-filterline-display-match-reason">
						<label>
							<input type="checkbox" ${this.displayReasons && "checked"}">
							<span>Show matching filters</span>
						</label>
					</div>
				</div>
				<div class="res-filterline-show-help">
					Usage information
				</div>
			</div>
		`;
      this.preamble.append(element);
      this.preamble.addEventListener("mouseenter", () => {
        infocard("filterline-filter").close();
      });
      function addDetails(summary, className2, ...elements) {
        const e2 = string_exports.html`<details class="${className2}"><summary>${summary}</summary></details>`;
        e2.append(...elements);
        element.querySelector(".res-filterline-dropdown-other").append(e2);
      }
      addDetails(
        "Modify external filters",
        "res-filterline-external",
        ...this.filters.filter((filter) => filter instanceof ExternalFilter).map((filter) => {
          filter.createElement();
          return filter.element;
        })
      );
      const dp = groupBy_default(without_default(this.getPickable(), Group), (v) => v.variant);
      for (const [name2, CaseClasses] of Object.entries(dp)) {
        addDetails(
          `New ${name2} filter`,
          `res-filterline-new-${name2}`,
          ...CaseClasses.sort((a2, b2) => a2.type.localeCompare(b2.type)).map((CaseClass) => this.createNewFilterElement(CaseClass))
        );
      }
      const _getAsConditions = this.getAsConditions.bind(this);
      addDetails(
        "New complex filter",
        "res-filterline-new-group",
        this.createNewFilterElement(Group, "Copy active filters", { get conditions() {
          return _getAsConditions();
        } }),
        ...Group.fields[0].options.map((op) => this.createNewFilterElement(Group, `Matches ${op}`, { conditions: { op, of: [] } }))
      );
      addDetails(
        "Use as default",
        "res-filterline-set-default",
        ...defaultFilters.map(({ type, text }) => {
          const e2 = string_exports.html`<div class="res-filterline-dropdown-action">${text}</div>`;
          e2.addEventListener("click", () => saveFilterlineStateAsDefault(type));
          return e2;
        }),
        (() => {
          const e2 = string_exports.html`<div class="res-filterline-dropdown-action">Reset this Filterline</div>`;
          e2.addEventListener("click", () => {
            this.storage.delete();
            if (confirm("Reload page to restore default")) location.reload();
          });
          return e2;
        })()
      );
      const displayReasonsCheckbox = downcast(element.querySelector(".res-filterline-display-match-reason input"), HTMLInputElement);
      displayReasonsCheckbox.addEventListener("change", () => {
        this.toggleDisplayReasons(displayReasonsCheckbox.checked);
      });
      if (this.thingType === "post" && loggedInUser()) {
        const permanentlyHide = string_exports.html`
				<div class="res-filterline-permanently-hide">
					<label>
						<input type="checkbox">
						<span>Permanently hide</span>
					</label>
				</div>
			`;
        const checkbox = this.permanentlyHideCheckbox = downcast(permanentlyHide.querySelector("input"), HTMLInputElement);
        this.updatePermanentlyHideCheckbox();
        permanentlyHide.addEventListener("click", async () => {
          checkbox.disabled = true;
          await (this.permanentlyHiddenThings.size ? this.unhidePermanently() : this.hidePermanently());
          checkbox.disabled = false;
        });
        element.querySelector(".res-filterline-dropdown-toggles").append(permanentlyHide);
      }
      downcast(element.querySelector(".res-filterline-show-help"), HTMLElement).addEventListener("click", () => {
        showFeatureTip("filterlineVisible");
      });
    }
    updatePermanentlyHideCheckbox() {
      if (!this.permanentlyHideCheckbox) return;
      this.permanentlyHideCheckbox.checked = this.permanentlyHideCheckbox.indeterminate = false;
      if (!this.permanentlyHiddenThings.size) return;
      if (this.getThings("hide").length === this.permanentlyHiddenThings.size) this.permanentlyHideCheckbox.checked = true;
      else this.permanentlyHideCheckbox.indeterminate = true;
    }
    createNewFilterElement(CaseClass, text = CaseClass.text, newOpts) {
      let fromSelected = false;
      const element = string_exports.html`<div class="res-filterline-dropdown-action res-filterline-filter-new" type="${CaseClass.type}">${text}</div>`;
      element.addEventListener("click", () => {
        const existing = CaseClass.unique && this.getFiltersOfCase(CaseClass)[0];
        let filter;
        if (existing) {
          if (!(existing instanceof LineFilter)) throw new Error();
          filter = existing;
        } else {
          filter = downcast(this.createFilter({ type: CaseClass.type, add: true, ...newOpts }), LineFilter);
        }
        if (fromSelected) filter.updateByInputConstruction({ fromSelected });
        else filter.showInfocard(true);
      });
      if (CaseClass.thingToCriterion || !CaseClass.defaultConditions) {
        const c2 = string_exports.html`<div class="res-filterline-filter-new-from-selected" title="From selected entry"></div>`;
        c2.addEventListener("click", () => {
          fromSelected = true;
          setTimeout(() => {
            fromSelected = false;
          });
        });
        element.append(c2);
      }
      return element;
    }
    async hidePermanently(things2 = this.getThings("hide")) {
      await Promise.all(difference_default(things2, Array.from(this.permanentlyHiddenThings)).map((thing) => hide2(thing)));
      for (const v of things2) this.permanentlyHiddenThings.add(v);
      this.updatePermanentlyHideCheckbox();
      showNotification({
        moduleID: module11.moduleID,
        notificationID: "hideThings",
        message: string_exports.html`<div><p>Reddit has now hidden ${things2.length} things. Undo by unchecking the checkbox in the menu.</p><p><a href="/user/me/hidden/">See all hidden posts</a></p>`
      });
    }
    async unhidePermanently(things2 = [...this.permanentlyHiddenThings]) {
      await Promise.all(intersection_default(things2, Array.from(this.permanentlyHiddenThings)).map((thing) => unhide(thing)));
      for (const v of things2) this.permanentlyHiddenThings.delete(v);
      this.updatePermanentlyHideCheckbox();
      showNotification({
        moduleID: module11.moduleID,
        notificationID: "unhideThings",
        message: `${things2.length} things are no longer hidden.`
      });
    }
    getAsConditions(hasEffect = "hide") {
      const extracted = filterMap(this.filters, (v) => v.effects[hasEffect] && v instanceof LineFilter && [v] || void 0);
      return resolveGroup(
        getGroup(
          "all",
          extracted.map((v) => v.state ? v.case.conditions : getGroup("none", [v.case.conditions]))
        ),
        false,
        true
      );
    }
    deferredFilters = {};
    resumeDeferredTypes(types2) {
      Object.entries(this.deferredFilters).filter(([, { type }]) => types2.includes(type)).forEach(([id2]) => this.createFilterFromStateValues(id2));
    }
    restoreState(filters) {
      for (const [id2, opts] of Object.entries(filters)) {
        try {
          if (opts.type === "inert") throw new Error("Requested inert filter. This state is likely due to a bug. Ignoring.");
          const filter = this.getFilter(id2);
          if (filter) throw new Error(`Filter with id ${id2} already exists`);
          const CaseClass = has4(opts.type) && get6(opts.type);
          if (CaseClass && !CaseClass.disabled && // External filter are created directly
          CaseClass.variant !== "external") {
            this.createFilterFromStateValues(id2, opts);
          } else {
            this.deferredFilters[id2] = opts;
          }
        } catch (e2) {
          console.error("Could not create filter", id2, opts);
          this.storage.deletePath("filters", id2);
        }
      }
    }
    createFilterFromStateValues(id2, opts) {
      const deferredOpts = this.deferredFilters[id2];
      delete this.deferredFilters[id2];
      return this.createFilter({ id: id2, ...opts, ...deferredOpts, add: true, save: false });
    }
    save = idleThrottle(async () => {
      const filters = this.filters.reduce((acc, v) => {
        acc[v.id] = v.getSaveValues();
        return acc;
      }, { ...this.deferredFilters });
      await this.storage.deletePath("filters");
      await this.storage.patch({ filters, lastUsed: Date.now() });
    });
    getCLI() {
      const deconstruct = (val) => {
        const [, modifiers, key, criterion] = val.match(/^([^\w]*)(\w*)(.*)/);
        return {
          key,
          criterion: criterion.trim(),
          disableFilter: !!modifiers.match("/"),
          reverseActive: !!modifiers.match("!"),
          asNewFilter: !!modifiers.match("\\+"),
          fromSelected: !!modifiers.match("=")
        };
      };
      const findMatchingCases = (val) => this.getPickable().sort((a2, b2) => a2.variant.localeCompare(b2.variant) || a2.type.localeCompare(b2.type)).map((CaseClass) => ({
        // on-demand cases' type name are hard to discern
        name: CaseClass.variant === "ondemand" ? CaseClass.text : CaseClass.type,
        cls: CaseClass
      })).filter(({ name: name2 }) => name2.toLowerCase().match(val.toLowerCase()));
      let filter;
      async function getTip2(val) {
        const deconstructed = deconstruct(val);
        const { key, asNewFilter } = deconstructed;
        const bestMatch = key && sortBy_default(findMatchingCases(key), ({ name: name2 }) => name2.toLowerCase().indexOf(key.toLowerCase()))[0];
        const { cls: MatchedCase } = bestMatch || {};
        let message;
        if (bestMatch) {
          try {
            const lastFilter = this.getFiltersOfCase(MatchedCase).slice(-1)[0];
            filter = lastFilter && !asNewFilter ? lastFilter : this.createFilter({ type: MatchedCase.type });
            const actionDescription = await filter.updateByInputConstruction(deconstructed, true);
            message = `${filter.parent ? `Modify "${filter.getStateText(filter.state)}"` : "New filter"}: ${actionDescription}`;
          } catch (e2) {
            message = `Error: ${e2.message}`;
          }
        } else {
          filter = null;
          message = "No filter selected.";
        }
        return [
          "<pre>",
          "Syntax: [modifiers] filterName [criterion]",
          "",
          message,
          "",
          "Filters:",
          ...findMatchingCases("").map(
            (v) => ` ${MatchedCase === v.cls ? `<b>${v.name}</b>` : v.name} ${v.cls.pattern}`
          ),
          "",
          "Modifiers:",
          " / \u2014 disable the filter",
          " ! \u2014 reverse the active state",
          " + \u2014 create as new filter",
          " = \u2014 use the currently selected post's data as criterion",
          "",
          "Examples:",
          " =postAfter   \u2192 filter posts older than selected",
          " +=!postAfter \u2192 new filter, filter posts younger than selected",
          "</pre>"
        ].join("\n");
      }
      function executeCommand2(val) {
        if (!filter) return;
        if (!filter.parent) this.addFilter(filter);
        filter.updateByInputConstruction(deconstruct(val));
        filter = null;
      }
      return { getTip: getTip2.bind(this), executeCommand: executeCommand2.bind(this) };
    }
    createFilter(opts) {
      const {
        Filter: Filter2 = LineFilter,
        id: id2 = `~${performance.timing.navigationStart + performance.now()}`,
        // timestamp, so that filters will restored in the same order as they initially were created
        add: add4 = false,
        save: save3 = true,
        type,
        criterion,
        effects,
        name: name2,
        state
      } = opts;
      let { conditions } = opts;
      if (this.deferredFilters.hasOwnProperty(id2)) return this.createFilterFromStateValues(id2, opts);
      const CaseClass = get6(type);
      if (CaseClass.unique) {
        const [existing] = this.getFiltersOfCase(CaseClass);
        if (existing) return existing;
      }
      if (!conditions && criterion) {
        conditions = CaseClass.criterionToConditions(criterion);
      }
      const filter = new Filter2(id2, CaseClass, name2, conditions, state, effects);
      if (add4) {
        this.addFilter(filter);
        if (save3) this.save();
      }
      return filter;
    }
    addFilter(filter) {
      filter.setParent(this);
      this.filters.push(filter);
      if (this.isInitialized()) {
        this.sortedFilters.push(filter);
        this.refresh(filter);
      }
      if (this.filterContainer) this.addFilterElements([filter]);
    }
    async removeFilter(filter) {
      if (filter.element) filter.element.remove();
      if (this.isInitialized()) await this.refresh(filter);
      pull_default(this.filters, filter);
      pull_default(this.sortedFilters, filter);
      this.save();
    }
    getFilter(id2) {
      return this.filters.find((filter) => filter.id === id2);
    }
    getActiveFilters() {
      return this.filters.filter((v) => v.active);
    }
    availableEffects = {
      propagate: (thing, match) => {
        thing.element.classList.toggle("res-thing-hide-children", !!match);
        this._refreshAfterChange();
      },
      highlight: (thing, match) => {
        thing.entry.classList.toggle("res-thing-filterline-highlight", !!match);
      },
      hide: (thing, match) => {
        thing.setHideFilter(match);
        this._refreshAfterChange();
      },
      placeholder: (thing, match) => {
        function removePlaceholders() {
          thing.element.classList.remove("res-thing-has-placeholder");
          for (const ele of thing.entry.querySelectorAll(".res-thing-placeholder-message")) ele.remove();
        }
        function replaceWithPlaceholder(ele) {
          if (!ele) return;
          const placeholder = string_exports.html`<span class="res-thing-placeholder-message">
					<span class="res-icon">&#xF093;</span> Content ignored. Click to show anyway.
				</span>`;
          ele.after(placeholder);
          thing.element.classList.add("res-thing-has-placeholder");
          waitForEvent(placeholder, "click").then(removePlaceholders);
        }
        if (match) {
          replaceWithPlaceholder(thing.getTitleElement());
          replaceWithPlaceholder(thing.getTextBody());
        } else {
          removePlaceholders();
        }
        this._refreshAfterChange();
      },
      collapse: (thing, match) => {
        thing.setCommentCollapse(!!match, "filterline", true);
        this._refreshAfterChange();
      }
    };
    _refreshAfterChange = frameThrottle(() => {
      selectedThing_exports.refresh();
      this.checkEmptyState();
    });
    getFiltersToTest(currentFilter, invokedByFilter) {
      if (!invokedByFilter) return this.sortedFilters;
      const invokedByFilterIndex = this.sortedFilters.indexOf(invokedByFilter);
      const currentFilterIndex = this.sortedFilters.indexOf(currentFilter);
      if (!currentFilter) {
        return [invokedByFilter];
      } else if (currentFilter === invokedByFilter) {
        return this.sortedFilters.slice(invokedByFilterIndex);
      } else if (currentFilterIndex > invokedByFilterIndex) {
        return [invokedByFilter, currentFilter];
      } else {
        return [];
      }
    }
    refreshThing = keyedMutex(fastAsync(function* (thing, invokedByFilter) {
      if (!this.currentMatches.has(thing)) this.currentMatches.set(thing, {});
      const currentMatches = this.currentMatches.get(thing);
      const activeEffects = Object.keys(this.availableEffects);
      const allFilters = [...new Set(activeEffects.map((effect) => this.getFiltersToTest(currentMatches[effect], invokedByFilter)).flat())].sort((a2, b2) => this.sortedFilters.indexOf(a2) - this.sortedFilters.indexOf(b2));
      const refreshEffects = activeEffects.filter((effect) => !// Only update effects that the current filter has touched
      (invokedByFilter && !invokedByFilter.effects.hasOwnProperty(effect) || // Don't update effects whose current matched filter will not be tested
      currentMatches[effect] && !allFilters.includes(currentMatches[effect])));
      const updateEffect = (effect, filter) => {
        const old = currentMatches[effect];
        if (filter == old) return;
        currentMatches[effect] = filter;
        this.availableEffects[effect](thing, filter);
        if (this.displayReasons) this.refreshDisplayReasonsChunked([thing]);
      };
      for (const filter of allFilters.filter((v) => this.getActiveFilters().includes(v))) {
        const effects = filter.getEffects().filter((v) => refreshEffects.includes(v));
        if (effects.length && (yield filter.matches(thing))) {
          for (const effect of effects) updateEffect(effect, filter);
          pull_default(refreshEffects, ...effects);
        }
      }
      for (const effect of refreshEffects) {
        updateEffect(effect, null);
      }
    }));
    refresh(invokedByFilter, things2 = Array.from(this.things)) {
      return Promise.all(things2.map((thing) => this.refreshThing(thing, invokedByFilter)));
    }
    addThing(thing) {
      this.things.add(thing);
      if (this.isInitialized()) return this.refreshThing(thing);
    }
    getThings(withEffect) {
      return Array.from(this.currentMatches.entries()).filter(([, effects]) => effects[withEffect]).map(([thing]) => thing);
    }
    checkEmptyState = (() => {
      let notification;
      const showNotification2 = debounce_default(() => {
        const info = (0, import_jquery11.default)("<p>").text(i18n("filteRedditEmptyNotificationInfo"));
        const toggle7 = (0, import_jquery11.default)("<button>").text(i18n("filteRedditEmptyNotificationToggleShowReason")).click(() => {
          this.toggleDisplayReasons();
        });
        notification = showNotification({
          moduleID: module11.moduleID,
          notificationID: "everyThingHidden",
          header: i18n("filteRedditEmptyNotificationHeader"),
          message: (0, import_jquery11.default)("<div>").append(info).append(toggle7).get(0),
          closeDelay: Infinity
        });
      }, 3e3);
      return () => {
        if (Array.from(this.things).some((v) => v.isVisible())) {
          showNotification2.cancel();
          if (notification) notification.close();
        } else if (!this.displayReasons && Array.from(this.currentMatches.values()).some((v) => v.hide)) {
          showNotification2();
        }
      };
    })();
    toggleDisplayReasons(newState = !this.displayReasons) {
      this.displayReasons = newState;
      this.refreshDisplayReasonsChunked(this.things);
      bodyClasses_exports.toggle(this.displayReasons, "res-display-match-reason");
    }
    refreshDisplayReasonsChunked = forEachChunked(this.refreshDisplayReasons.bind(this));
    async refreshDisplayReasons(thing) {
      const reasons = this.displayReasons ? await Promise.all(
        Object.entries(this.currentMatches.get(thing) || {}).map(([effect, filter]) => filter && filter.buildReasonElement(thing, effect)).filter(Boolean)
      ) : [];
      thing.setFilterReasons(reasons);
    }
  };

  // lib/modules/filteReddit.js
  var module11 = new Module("filteReddit");
  module11.moduleName = "filteRedditName";
  module11.category = "subredditsCategory";
  module11.description = "filteRedditDesc";
  module11.keywords = ["filterreddit"];
  module11.options = {
    hideUntilProcessed: {
      type: "boolean",
      value: true,
      description: "filteRedditHideUntilProcessedDesc",
      title: "filteRedditHideUntilProcessedTitle",
      advanced: true
    },
    NSFWfilter: {
      type: "boolean",
      value: false,
      description: "filteRedditNSFWfilterDesc",
      title: "filteRedditNSFWfilterTitle"
    },
    allowNSFW: {
      type: "table",
      addRowText: "filteRedditAddSubreddits",
      description: "filteRedditAllowNSFWDesc",
      title: "filteRedditAllowNSFWTitle",
      fields: [{
        key: "subreddits",
        name: "filteRedditSubreddits",
        type: "list",
        listType: "subreddits"
      }, {
        key: "where",
        name: "filteRedditAllowNSFWWhere",
        type: "enum",
        values: [{
          name: "filteRedditEverywhere",
          value: "everywhere"
        }, {
          name: "filteRedditAllowNSFWWhenBrowsingSubreddit",
          value: "visit"
        }],
        value: "everywhere"
      }],
      value: []
    },
    NSFWQuickToggle: {
      type: "boolean",
      value: true,
      description: "filteRedditNSFWQuickToggleDesc",
      title: "filteRedditNSFWQuickToggleTitle",
      advanced: true
    },
    showFilterline: {
      type: "boolean",
      value: false,
      description: "filteRedditShowFilterlineDesc",
      title: "filteRedditShowFilterlineTitle"
    },
    excludeOwnPosts: {
      type: "boolean",
      value: true,
      description: "filteRedditExcludeOwnPostsDesc",
      title: "filteRedditExcludeOwnPostsTitle"
    },
    excludeModqueue: {
      type: "boolean",
      value: true,
      description: "filteRedditExcludeModqueueDesc",
      title: "filteRedditExcludeModqueueTitle"
    },
    excludeUserPages: {
      type: "boolean",
      value: false,
      description: "filteRedditExcludeUserPagesDesc",
      title: "filteRedditExcludeUserPagesTitle"
    },
    keywords: {
      type: "table",
      addRowText: "filteRedditAddFilter",
      fields: [{
        key: "keyword",
        name: "filteRedditKeyword",
        type: "text"
      }, {
        key: "applyTo",
        name: "filteRedditApplyTo",
        type: "enum",
        values: [{
          name: "filteRedditEverywhere",
          value: "everywhere"
        }, {
          name: "filteRedditEverywhereBut",
          value: "exclude"
        }, {
          name: "filteRedditOnlyOn",
          value: "include"
        }],
        value: "everywhere"
      }, {
        key: "subreddits",
        name: "subreddits",
        type: "list",
        listType: "subreddits"
      }, {
        key: "unlessKeyword",
        name: "unlessKeyword",
        type: "text"
      }],
      value: [],
      description: "filteRedditKeywordsDesc",
      title: "filteRedditKeywordsTitle"
    },
    subreddits: {
      type: "table",
      addRowText: "filteRedditAddFilter",
      fields: [{
        key: "subreddit",
        name: "filteRedditSubredditsSubreddits",
        type: "text"
      }],
      value: [],
      description: "filteRedditSubredditsDesc",
      title: "filteRedditSubredditsTitle",
      onChange() {
        if (module11.options.useRedditFilters.value) {
          reconcileNativeFilters();
        }
      }
    },
    filterSubredditsFrom: {
      type: "enum",
      value: "everywhere-except-subreddit",
      values: [{
        name: "filteRedditFilterSubredditsEverywhereButSubreddit",
        value: "everywhere-except-subreddit"
      }, {
        name: "filteRedditEverywhere",
        value: "everywhere"
      }, {
        name: "filteRedditFilterSubredditsAllPopularAndDomain",
        value: "legacy"
      }],
      description: "filteRedditFilterSubredditsFromDesc",
      title: "filteRedditFilterSubredditsFromTitle"
    },
    useRedditFilters: {
      type: "boolean",
      value: false,
      description: "filteRedditUseRedditFiltersDesc",
      title: "filteRedditUseRedditFiltersTitle",
      onChange() {
        if (module11.options.useRedditFilters.value) {
          reconcileNativeFilters();
        }
      }
    },
    forceSyncFilters: {
      type: "button",
      text: "filteRedditForceSyncFiltersLabel",
      description: "filteRedditForceSyncFiltersDesc",
      title: "filteRedditForceSyncFiltersTitle",
      callback() {
        return reconcileNativeFilters({ warnNotLoggedIn: true });
      }
    },
    comments: {
      type: "table",
      addRowText: "filteRedditAddFilter",
      fields: [{
        key: "keyword",
        name: "filteRedditKeyword",
        type: "text"
      }, {
        key: "applyTo",
        name: "filteRedditApplyTo",
        type: "enum",
        values: [{
          name: "filteRedditEverywhere",
          value: "everywhere"
        }, {
          name: "filteRedditEverywhereBut",
          value: "exclude"
        }, {
          name: "filteRedditOnlyOn",
          value: "include"
        }],
        value: "everywhere"
      }, {
        key: "subreddits",
        name: "subreddits",
        type: "list",
        listType: "subreddits"
      }],
      value: [],
      description: "filteRedditCommentContentDesc",
      title: "filteRedditCommentContentTitle"
    },
    commentsHideReplies: {
      type: "boolean",
      value: false,
      description: "filteRedditCommentContentHideRepliesDesc",
      title: "filteRedditCommentContentHideRepliesTitle"
    },
    users: {
      type: "table",
      addRowText: "filteRedditAddFilter",
      fields: [{
        key: "username",
        name: "filteRedditUsername",
        type: "text"
      }],
      value: [],
      description: "filteRedditUsersDesc",
      title: "filteRedditUsersTitle"
    },
    usersMatchAction: {
      type: "enum",
      value: "hide",
      values: [{
        name: "Hidden",
        value: "hide"
      }, {
        name: "Replaced with placeholder",
        value: "placeholder"
      }],
      description: "filteRedditUsersMatchActionDesc",
      title: "filteRedditUsersMatchActionTitle"
    },
    usersMatchRepliesAction: {
      type: "enum",
      value: "collapse",
      values: [{
        name: "Kept visible",
        value: ""
      }, {
        name: "Collapsed",
        value: "collapse"
      }, {
        name: "Hidden",
        value: "propagate"
      }],
      description: "filteRedditUsersMatchRepliesActionDesc",
      title: "filteRedditUsersMatchRepliesActionTitle"
    },
    domains: {
      type: "table",
      addRowText: "filteRedditAddFilter",
      fields: [{
        key: "keyword",
        name: "filteRedditKeyword",
        type: "text"
      }, {
        key: "applyTo",
        name: "filteRedditApplyTo",
        type: "enum",
        values: [{
          name: "filteRedditEverywhere",
          value: "everywhere"
        }, {
          name: "filteRedditEverywhereBut",
          value: "exclude"
        }, {
          name: "filteRedditOnlyOn",
          value: "include"
        }],
        value: "everywhere"
      }, {
        key: "subreddits",
        name: "filteRedditSubreddits",
        type: "list",
        listType: "subreddits"
      }],
      value: [],
      description: "filteRedditDomainsDesc",
      title: "filteRedditDomainsTitle"
    },
    flair: {
      type: "table",
      addRowText: "filteRedditAddFilter",
      fields: [{
        key: "keyword",
        name: "filteRedditKeyword",
        type: "text"
      }, {
        key: "applyTo",
        name: "filteRedditApplyTo",
        type: "enum",
        values: [{
          name: "filteRedditEverywhere",
          value: "everywhere"
        }, {
          name: "filteRedditEverywhereBut",
          value: "exclude"
        }, {
          name: "filteRedditOnlyOn",
          value: "include"
        }],
        value: "everywhere"
      }, {
        key: "subreddits",
        name: "filteRedditSubreddits",
        type: "list",
        listType: "subreddits"
      }],
      value: [],
      description: "filteRedditFlairDesc",
      title: "filteRedditFlairTitle"
    },
    customFiltersP: {
      type: "builder",
      description: "filteRedditCustomFiltersDesc",
      title: "filteRedditCustomFiltersPTitle",
      value: [],
      addItemText: "filteRedditAddCustomFilter",
      defaultTemplate() {
        return {
          note: "",
          ver: 3,
          body: getConditions("group"),
          id: `customFilter-${Date.now()}`,
          opts: {
            ondemand: false,
            name: ""
          }
        };
      },
      customOptionsFields: [
        ["Name: ", { type: "text", id: "name" }],
        [{ type: "check", id: "ondemand", label: "On-demand only" }]
      ],
      get cases() {
        populatePrimitives();
        return { ...getByContext("post"), ...getByContext("browse") };
      }
    },
    customFiltersC: {
      type: "builder",
      description: "filteRedditCustomFiltersDesc",
      title: "filteRedditCustomFiltersCTitle",
      value: [],
      addItemText: "filteRedditAddCustomFilter",
      defaultTemplate() {
        return {
          note: "",
          ver: 3,
          body: getConditions("group"),
          id: `customFilter-${Date.now()}`,
          opts: {
            ondemand: false,
            name: "",
            propagate: false
          }
        };
      },
      customOptionsFields: [
        ["Name: ", { type: "text", id: "name" }],
        [{ type: "check", id: "ondemand", label: "On-demand only" }],
        [{ type: "check", id: "propagate", label: "Also hide replies" }]
      ],
      get cases() {
        populatePrimitives();
        return { ...getByContext("comment"), ...getByContext("browse") };
      }
    }
  };
  module11.include = [
    "linklist",
    "modqueue",
    "profile",
    "comments",
    "commentsLinklist",
    "search"
  ];
  var featureTips = {
    filterline: {
      message: `
RES allows you to easily apply complex filters to post listings and comments. To toggle Filterline, click on the tab.
	`,
      title: "Filterline",
      position: 6,
      quiet: true
    },
    filterlineVisible: {
      // Wrap as to avoid loading markdown unnecessarily
      message: () => markdown(`
* Click once on a filter to enable it (e.g. clicking \`expando\` will only show posts with embedded media).
* Click again to only show posts which do not not match.
* A third click makes the filter inactive.
* To clear a filter, right-click on it.
* **Hover** on it to modify conditions, highlight or permanently hide all matches.

To find more filters and options, hover on icon to the left.

You can use the currently selected post as a basis for a new filter. To do this, click on **=** to the right of the filter name.

**Complex filter** creates filters which matches when \`none\`, \`one\`, \`any\`, or \`all\` of the subfilters matches. Click \`To on-demand\` to make these filters available on other pages.

**Use as default** lets you store the current filters to be used on other pages.

To see why a post is hidden, open dropdown and check **Show filter-reason**. This also gives you the opportunity to remove an external filter so that you don't have to look for it in the settings console.

You can use the command line to manipulate Filterline. Enter it by pressing the key \`f\`.
		`),
      title: "Filterline \u2014 how to use it",
      position: 7,
      options: [{
        moduleID: "filteReddit",
        key: "showFilterline"
      }]
    }
  };
  var pageID = fullLocation();
  var filterlineStorage = storage_exports.wrap(`filterline.${pageID}`, {});
  var thingType = isPageType("comments", "commentsLinklist") ? "comment" : "post";
  var customFilterVariant = thingType === "post" ? "customFiltersP" : "customFiltersC";
  var createStateFromTypes = (types2) => types2.reduce((acc, v, i2) => {
    if (v) acc[`!${i2}`] = { type: v };
    return acc;
  }, {});
  var defaultFilters = [];
  if (thingType === "comment") {
    if (currentSubreddit()) {
      defaultFilters.push({
        type: "subreddit",
        text: "On this subreddit",
        storage: storage_exports.wrap(`RESmodules.filteReddit.commentDefault-${String(currentSubreddit())}`, null)
      });
    }
    defaultFilters.push({
      type: "everywhere",
      text: "Everywhere",
      storage: storage_exports.wrap("RESmodules.filteReddit.commentDefault", createStateFromTypes([
        "hasExpando",
        "score",
        "isRead",
        "postAge"
      ]))
    });
  } else if (thingType === "post") {
    defaultFilters.push({
      type: "everywhere",
      text: "Everywhere",
      storage: storage_exports.wrap("RESmodules.filteReddit.postDefault", createStateFromTypes([
        "isNSFW",
        "isSpoiler",
        "isVisited",
        "commentsOpened",
        "hasExpando",
        "score"
      ]))
    });
  }
  var nsfwToggle;
  var filterline;
  var visible;
  var _filterlineResolve;
  var filterlinePromise = new Promise((res) => {
    _filterlineResolve = res;
  });
  var ensureFilterlineVisible;
  var initialState = (async () => {
    const state = filterlineStorage.get();
    const _default = Promise.all(defaultFilters.map(({ storage: storage3 }) => storage3.get())).then((v) => v.find(Boolean));
    let { filters, visible: visible2, lastUsed } = await state;
    if (!filters || !Object.values(filters).length) filters = await _default;
    return { filters, visible: visible2, lastUsed };
  })();
  module11.beforeLoad = async () => {
    updateNsfwBodyClass(module11.options.NSFWfilter.value);
    nsfwToggle = new Toggle("nsfwMode", i18n("nsfwSwitchToggleText"), module11.options.NSFWfilter.value);
    nsfwToggle.onToggle(() => {
      module11.options.NSFWfilter.value = nsfwToggle.enabled;
      save2(module11.options.NSFWfilter);
    });
    nsfwToggle.onStateChange(() => {
      updateNsfwBodyClass(nsfwToggle.enabled);
    });
    nsfwToggle.addCLI("nsfw");
    watchForThings(["post"], updateNsfwThingClass, { immediate: true });
    populatePrimitives(["browse", thingType]);
    filterline = new Filterline(filterlineStorage, thingType);
    const { filters, visible: _visible, lastUsed } = await initialState;
    filterline.restoreState(filters);
    populateFromOptions();
    _filterlineResolve(filterline);
    const hideUntilProcessed = module11.options.hideUntilProcessed.value && filterline.getActiveFilters().length;
    watchForThings([thingType], async (thing) => {
      if (!shouldFilter(thing)) return;
      if (hideUntilProcessed) thing.element.classList.add("res-thing-filter-unprocessed");
      try {
        await filterline.addThing(thing);
      } catch (e2) {
        console.error(e2);
      }
      if (hideUntilProcessed) thing.element.classList.remove("res-thing-filter-unprocessed");
    }, { immediate: true, id: "filter" });
    if (module11.options.excludeModqueue.value && isPageType("modqueue") || module11.options.excludeUserPages.value && isPageType("profile")) filterline.togglePowered(false);
    visible = typeof _visible === "boolean" ? _visible : module11.options.showFilterline.value || filterline.getActiveFilters().some((v) => !(v instanceof ExternalFilter));
    if (lastUsed) requestIdleCallback(() => {
      filterlineStorage.patch({ lastUsed: Date.now() });
    });
  };
  module11.contentStart = () => {
    makeFilterlineInteractable();
    if (module11.options.NSFWQuickToggle.value) {
      nsfwToggle.addMenuItem(i18n("nsfwSwitchToggleTitle"), 8);
    }
    registerSubredditFilterCommand();
  };
  var shouldFilter = (thing) => !(module11.options.excludeOwnPosts.value && data.username && currentUserProfile() !== data.username && data.username === thing.getAuthor());
  function makeFilterlineInteractable() {
    const insertFilterline = once_default(() => {
      filterline.createElement();
      if (isAppType("r2")) {
        waitForDescendant(document.body, isPageType("comments") ? ".comments-page .nestedlisting" : "#siteTable, .search-result-listing").then((sibling) => sibling.before(filterline.element));
      } else {
        filterlineTab.append(filterline.element);
      }
      addFeatureTip("filterlineVisible", { ...featureTips.filterlineVisible, attachTo: filterline.element });
    });
    const filterlineTab = createElement_exports.tabMenuItem({
      text: "",
      title: "Toggle Filterline visibility",
      className: "res-toggle-filterline-visibility",
      checked: visible,
      onChange: (active) => {
        visible = active;
        if (visible) {
          insertFilterline();
          scrollToElement(filterline.element, null, { scrollStyle: "legacy" });
        }
        if (filterline.element) filterline.element.hidden = !visible;
        filterlineStorage.patch({ visible });
      }
    });
    ensureFilterlineVisible = () => {
      if (!visible) filterlineTab.click();
    };
    const { getTip: getTip2, executeCommand: executeCommand2 } = filterline.getCLI();
    registerCommand(
      /(fl|filterline)/,
      "fl - modify Filterline",
      (cmd, val) => getTip2(val),
      (cmd, val) => {
        ensureFilterlineVisible();
        executeCommand2(val);
      }
    );
    registerCommand(
      /fp/,
      "fp - toggle filtering",
      () => "Toggle filtering",
      () => {
        ensureFilterlineVisible();
        filterline.poweredElement.click();
      }
    );
    addFeatureTip("filterline", {
      ...featureTips.filterline,
      attachTo: filterlineTab,
      continuation: () => {
        ensureFilterlineVisible();
        return "filterlineVisible";
      }
    });
    if (visible) insertFilterline();
  }
  var ListFilter = class {
    externalKey;
    get list() {
      return module11.options[this.externalKey].value;
    }
    filter;
    constructor(externalKey) {
      this.externalKey = externalKey;
    }
    initialize(caseType, additionalCriteria, useEffects = ["hide"]) {
      const _listFilter = this;
      const sources = /* @__PURE__ */ new Map();
      const getConditions2 = () => {
        sources.clear();
        return resolveGroup(getGroup("any", this.list.map((v) => {
          const c2 = getStringMatchConditions(v, caseType, additionalCriteria);
          sources.set(c2, v);
          return c2;
        })));
      };
      this.filter = addExternalFilter(this.externalKey, i18n(module11.options[this.externalKey].title), getConditions2, class extends ExternalFilter {
        constructor(id2, BaseCase, name2, conditions, state, effects = {}) {
          const _effects = useEffects.reduce((acc, val) => {
            acc[val] = typeof effects[val] === "boolean" ? effects[val] : true;
            return acc;
          }, {});
          super(id2, BaseCase, name2, conditions, state, _effects);
          this.toggleEffects = useEffects;
        }
        async getMatchingEntry(thing) {
          const matching = Array.from(sources.keys()).map((v) => Case.fromConditions(v).evaluate(thing) && sources.get(v));
          return (await Promise.all(matching)).filter(Boolean);
        }
        removeEntry(entries) {
          _listFilter.toggleEntry(false, ...entries);
        }
      });
    }
    // Note this is only a basic search for the string; `getMatchingEntry` also tests regexes
    findEntry(matchString) {
      return this.list.find(([str]) => str.toLowerCase() === matchString.toLowerCase());
    }
    toggleEntry(newState, ...entries) {
      if (newState) {
        this.list.push(...entries);
      } else {
        pull_default(this.list, ...entries);
      }
      save2(module11.options[this.externalKey]);
      if (this.filter) return this.filter.update(void 0, null);
    }
    includesString(matchString) {
      return !!this.findEntry(matchString);
    }
    async toggleString(matchString, newState = !this.includesString(matchString)) {
      if (selectedThing_exports.current) selectedThing_exports.current.anchor();
      await this.toggleEntry(newState, this.findEntry(matchString) || [matchString]);
    }
  };
  var listFilters = {
    users: new ListFilter("users"),
    subreddits: new ListFilter("subreddits"),
    keywords: new ListFilter("keywords"),
    domains: new ListFilter("domains"),
    flair: new ListFilter("flair"),
    comments: new ListFilter("comments")
  };
  function addExternalFilter(id2, name2, getConditions2, Filter2 = ExternalFilter) {
    const cased = createAdHoc(id2, getConditions2, "external", thingType);
    return filterline.createFilter({ Filter: Filter2, id: id2, name: name2, type: cased.type, state: false, add: true, save: false });
  }
  function populateFromOptions() {
    const customFilters = groupBy_default(
      module11.options[customFilterVariant].value,
      ({ opts: { ondemand } = {} }) => ondemand ? "ondemand" : "always"
    );
    if (customFilters.ondemand) {
      const cases = customFilters.ondemand.map((v) => addOndemandCase(v, true));
      filterline.resumeDeferredTypes(cases.map(({ type }) => type));
    }
    addExternalFilter(customFilterVariant, i18n(module11.options[customFilterVariant].title), () => ({ type: "false" }));
    for (const customFilter of customFilters.always || []) {
      const conditions = resolveGroup(customFilter.body);
      if (!isUseful(conditions.type)) continue;
      addExternalFilter(customFilter.id, (customFilter.opts || {}).name, () => conditions, class extends ExternalFilter {
        constructor(id2, BaseCase, name2, conditions2, state, effects) {
          const propagate = !!(customFilter.opts && customFilter.opts.propagate);
          super(id2, BaseCase, name2, conditions2, state, { hide: true, propagate, ...effects });
        }
      });
    }
    if (!isPageType("profile")) {
      const effects = [
        module11.options.usersMatchAction.value,
        module11.options.usersMatchRepliesAction.value
      ].filter(Boolean);
      listFilters.users.initialize("username", void 0, effects);
    }
    if (thingType === "post") {
      listFilters.keywords.initialize("postTitle");
      listFilters.domains.initialize("domain", { fullMatch: false });
      if (module11.options.filterSubredditsFrom.value === "everywhere" || module11.options.filterSubredditsFrom.value === "everywhere-except-subreddit" && !currentSubreddit() || isCurrentSubreddit("all") || isCurrentSubreddit("popular") || currentDomain() || isCurrentMultireddit("me/f/all")) {
        listFilters.subreddits.initialize("subreddit");
      }
      listFilters.flair.initialize("linkFlair");
    } else {
      listFilters.comments.initialize("commentContent", void 0, ["hide", module11.options.commentsHideReplies.value ? "propagate" : null].filter(Boolean));
    }
  }
  function addOndemandCase(customFilter, onlyUseful = false) {
    const getConditions2 = () => resolveGroup(customFilter.body);
    if (!onlyUseful || isUseful(getConditions2().type)) {
      return createAdHoc(customFilter.id, getConditions2, "ondemand", thingType, customFilter);
    } else {
      return Inert;
    }
  }
  function addCustomFilter({ body, opts }) {
    const customFilter = {
      note: `From ${fullLocation()}`,
      ver: 3,
      id: `customFilter-${Date.now()}`,
      body,
      opts
    };
    module11.options[customFilterVariant].value.unshift(customFilter);
    save2(module11.options[customFilterVariant]);
    return customFilter;
  }
  function updateCustomFilter(customFilter, val) {
    extendDeep(customFilter, val);
    save2(module11.options[customFilterVariant]);
  }
  async function saveFilterlineStateAsDefault(type) {
    const { storage: storage3 } = defaultFilters.find((v2) => v2.type === type) || {};
    if (!storage3) throw new Error(`Could not find storage for type ${type}`);
    const v = await filterlineStorage.get();
    let { filters } = structuredClone(v) || {};
    if (isEmpty_default(filters)) filters = null;
    await storage3.set(filters);
    showNotification("Saved.", 1e3);
  }
  function getStringMatchConditions(source, caseType, additionalCriteria) {
    const [matchString = "", applyTo = "everywhere", applyList = "", except = ""] = source;
    const mainFilter = {
      type: caseType,
      patt: matchString,
      ...additionalCriteria
    };
    if (source.length === 1) return mainFilter;
    let applyToConditions;
    if (applyTo !== "everywhere") {
      const subreddits2 = applyList.split(",");
      if (subreddits2.findIndex((v) => !v) !== -1) {
        console.error("Filter must have subreddits specified", source);
        return { type: "false" };
      }
      applyToConditions = getGroup(applyTo === "exclude" ? "none" : "any", [
        // /r/all special case
        // (nothing is posted to /r/all, but we could be browsing it)
        subreddits2.includes("all") ? {
          type: "currentSub",
          patt: "all"
        } : null,
        // and the same for /r/popular
        subreddits2.includes("popular") ? {
          type: "currentSub",
          patt: "popular"
        } : null,
        // normal subreddit include/exclude
        ...subreddits2.map((sr) => ({
          type: "subreddit",
          patt: sr
        }))
      ].filter(Boolean));
    }
    return getGroup("all", [
      // applyTo filtering
      applyToConditions || null,
      // main filter
      mainFilter,
      // filter exclusions
      except && except.length && getGroup("none", [{
        type: caseType,
        patt: except,
        ...additionalCriteria
      }]) || null
    ].filter(Boolean));
  }
  var reconcileNativeFilters = (() => {
    const MAX_RETRIES = 5;
    const getTopScore = batch(async (requests) => {
      const resp = await ajax({
        url: `/r/${requests.map((r) => r.sub).join("+")}/top.json`,
        query: { t: "day", limit: 100 },
        type: "json"
      });
      if (!resp.data.children.length) {
        return requests.map(() => 0);
      }
      const topScoreBySub = new Map(
        resp.data.children.reverse().map((post) => [post.data.subreddit.toLowerCase(), post.data.score])
      );
      return requests.map(({ sub, depth = 0 }) => {
        const score = topScoreBySub.get(sub.toLowerCase());
        if (score !== void 0) {
          return score;
        } else if (depth > MAX_RETRIES) {
          return 0;
        } else {
          return getTopScore({ sub, depth: depth + 1 });
        }
      });
    }, { size: 100, delay: 2e3 });
    async function sortByPopularity(subreddits2) {
      const scores = await Promise.all(subreddits2.map((sub) => getTopScore({ sub })));
      return sortBy_default(zip_default(subreddits2, scores), ([, score]) => score).map(([sub]) => sub).filter(Boolean).reverse();
    }
    return mutex(async ({ warnNotLoggedIn = false } = {}) => {
      const user = data.username;
      if (!user) {
        if (warnNotLoggedIn) {
          showNotification({
            moduleID: module11.moduleID,
            notificationID: "filterSyncNotLoggedIn",
            header: "Filters not synced",
            message: "You must log in to sync filters."
          });
        }
        console.warn("Not syncing filters, not logged in...");
        return;
      }
      showNotification({
        moduleID: module11.moduleID,
        notificationID: "filterSyncStarted",
        message: "Filter sync started..."
      });
      const { data: { subreddits: subreddits2 } } = await ajax({
        url: `/api/filter/user/${user}/f/all`,
        type: "json"
      });
      const existing = subreddits2.map(({ name: name2 }) => name2.toLowerCase());
      const desired = (await sortByPopularity(
        module11.options.subreddits.value.map(([sr]) => sr).filter((sr) => !string_exports.regexRegex.test(sr)).map((name2) => name2.toLowerCase())
      )).slice(0, 100);
      const toRemove = difference_default(existing, desired).length;
      const toAdd = difference_default(desired, existing).length;
      if (!toRemove && !toAdd) {
        showNotification({
          moduleID: module11.moduleID,
          optionKey: "useRedditFilters",
          notificationID: "filterSyncNoneAddedOrRemoved",
          closeDelay: 5e3,
          header: "No filters synced",
          message: `
					Either no subreddit filters were changed, or you have more than 100 subreddits filtered.
					Reddit's native /r/all filtering is limited to 100 subreddits.
				`
        });
        return;
      }
      try {
        await ajax({
          method: "PUT",
          url: `/api/filter/user/${user}/f/all`,
          data: {
            model: JSON.stringify({
              subreddits: desired.map((name2) => ({ name: name2 }))
            })
          }
        });
      } catch (e2) {
        console.error(e2);
        showNotification({
          moduleID: module11.moduleID,
          optionKey: "useRedditFilters",
          notificationID: "filterSyncError",
          header: "Error syncing filters",
          message: `Filters could not be synced: ${e2}`
        });
        return;
      }
      showNotification({
        moduleID: module11.moduleID,
        optionKey: "useRedditFilters",
        notificationID: "filterSyncSuccess",
        header: "Successfully synced filters",
        message: `Removed ${toRemove} and added ${toAdd} filters.`
      });
    });
  })();
  var subredditAllowNsfwOption = once_default(() => indexOptionTable(module11.options.allowNSFW, 0, (key) => key.toLowerCase()));
  var allowAllNsfw = memoize_default((subreddit2) => {
    const currOptionValue = subredditAllowNsfwOption()[subreddit2.toLowerCase()];
    return currOptionValue && currOptionValue[0][1] === "visit";
  });
  function allowNSFW(postSubreddit, currSubreddit = currentSubreddit()) {
    if (!module11.options.allowNSFW.value || !module11.options.allowNSFW.value.length) return false;
    if (currSubreddit && allowAllNsfw(currSubreddit)) {
      return true;
    }
    if (!postSubreddit) postSubreddit = currSubreddit;
    if (!postSubreddit) return false;
    const postOptionValue = subredditAllowNsfwOption()[postSubreddit.toLowerCase()];
    if (postOptionValue) {
      if (postOptionValue[0][1] === "everywhere") {
        return true;
      } else {
        return (currSubreddit || "").split("+").includes(postSubreddit);
      }
    }
    return false;
  }
  function updateNsfwThingClass(thing) {
    if (thing.isNSFW()) {
      if (allowNSFW(thing.getSubreddit(), currentSubreddit())) {
        thing.element.classList.add("allowOver18");
      }
      thing.element.classList.add("over18");
    }
  }
  function updateNsfwBodyClass(filterOn) {
    bodyClasses_exports.toggle(filterOn, "hideOver18");
  }
  function registerSubredditFilterCommand() {
    const getSubreddit = (val) => val || selectedThing_exports.current && selectedThing_exports.current.getSubreddit() || currentSubreddit() || "";
    registerCommand(
      /^f(?:ilter)?/,
      "f[ilter] [subreddit] - toggle subreddit filter",
      (cmd, val) => {
        const subreddit2 = getSubreddit(val);
        return `toggle subreddit filter for: ${subreddit2}`;
      },
      (cmd, val) => {
        const subreddit2 = getSubreddit(val);
        if (!subreddit2) return "no subreddit specified or post selected";
        listFilters.subreddits.toggleString(subreddit2);
      }
    );
  }

  // lib/modules/nightMode.js
  var import_suncalc = __toESM(require_suncalc(), 1);
  var module12 = new Module("nightMode");
  module12.moduleName = "nightModeName";
  module12.category = "appearanceCategory";
  module12.description = "nightModeDesc";
  module12.options = {
    nightModeOn: {
      type: "boolean",
      value: false,
      description: "nightModeNightModeOnDesc",
      title: "nightModeNightModeOnTitle"
    },
    nightSwitch: {
      type: "boolean",
      value: true,
      description: "nightModeNightSwitchDesc",
      title: "nightModeNightSwitchTitle",
      advanced: true
    },
    automaticNightMode: {
      type: "enum",
      value: "none",
      values: [{
        name: "nightModeAutomaticNightModeNone",
        value: "none"
      }, {
        name: "nightModeAutomaticNightModeAutomatic",
        value: "automatic"
      }, {
        name: "nightModeAutomaticNightModeUser",
        value: "user"
      }, {
        name: "nightModeAutomaticNightModeSystem",
        value: "system"
      }],
      description: "nightModeAutomaticNightModeDesc",
      title: "nightModeAutomaticNightModeTitle"
    },
    nightModeStart: {
      type: "text",
      value: "20:00",
      description: "nightModeNightModeStartDesc",
      title: "nightModeNightModeStartTitle",
      dependsOn: (options6) => options6.automaticNightMode.value === "user"
    },
    nightModeEnd: {
      type: "text",
      value: "6:00",
      description: "nightModeNightModeEndDesc",
      title: "nightModeNightModeEndTitle",
      dependsOn: (options6) => options6.automaticNightMode.value === "user"
    },
    nightModeOverrideHours: {
      type: "text",
      value: "8",
      description: "nightModeNightModeOverrideHoursDesc",
      title: "nightModeNightModeOverrideHoursTitle",
      dependsOn: (options6) => options6.automaticNightMode.value !== "none"
    },
    useSubredditStyles: {
      type: "boolean",
      value: false,
      description: "nightModeUseSubredditStylesDesc",
      title: "nightModeUseSubredditStylesTitle",
      advanced: true
    },
    subredditStylesWhitelist: {
      type: "list",
      value: "",
      listType: "subreddits",
      description: "nightModeSubredditStylesWhitelistDesc",
      title: "nightModeSubredditStylesWhitelistTitle"
    },
    coloredLinks: {
      type: "boolean",
      bodyClass: true,
      value: false,
      description: "nightModeColoredLinksDesc",
      title: "nightModeColoredLinksTitle"
    }
  };
  var localStorageKey = "RES_nightMode";
  var nightModeActive = () => typeof localStorage === "object" && !!localStorage.getItem(localStorageKey);
  var nightmodeOverrideStorage = storage_exports.wrap("RESmodules.nightMode.nightModeOverrideStart", null);
  var toggle3;
  module12.onInit = () => {
    if (nightModeActive()) addStyle2();
  };
  module12.beforeLoad = () => {
    toggle3 = new Toggle("nightMode", i18n("nightModeToggleText"), module12.options.nightModeOn.value);
    toggle3.onToggle((type) => {
      save2(module12.options.nightModeOn);
      if (type === "manual") nightmodeOverrideStorage.set(Date.now());
    });
    toggle3.onStateChange(() => {
      module12.options.nightModeOn.value = toggle3.enabled;
      refreshStyle();
      refreshSubredditStyleCompatability();
    });
    toggle3.addCLI("ns");
    if (module12.options.nightSwitch.value) toggle3.addMenuItem(i18n("nightModeToggleTitle"), 7, "\u263D", "\u2600");
    if (module12.options.automaticNightMode.value !== "none") {
      refreshAutomaticNightMode();
    }
    refreshSubredditStyleCompatability();
  };
  module12.always = () => {
    refreshStyle();
  };
  var id = `nightMode.compatibleSubredditStyle.${currentSubreddit() || ""}`;
  var compatibleSubredditStyle = session_exports.get(id).then((compatible) => typeof compatible === "boolean" ? compatible : !nightModeActive());
  var onUpdate = [];
  async function refreshSubredditStyleCompatability() {
    const subreddit2 = currentSubreddit();
    if (!subreddit2) return;
    const isAllowedByOptions = async () => {
      await loadOptions;
      if (!nightModeActive()) {
        return true;
      }
      if (module12.options.useSubredditStyles.value) {
        return true;
      }
      const isWhitelisted = module12.options.subredditStylesWhitelist.value.split(",").includes(subreddit2.toLowerCase());
      if (isWhitelisted) {
        return true;
      }
    };
    const hasSidebarIndicator = async () => {
      const query = () => !!document.querySelector('.side a[href$="#/RES_SR_Config/NightModeCompatible"]');
      return query() || await pagePhases_exports.bodyStart.then(query) || await waitForChild(document.body, ".side").then(query) || pagePhases_exports.contentStart.then(query);
    };
    compatibleSubredditStyle = !subreddit2 || // not in a subreddit, vanilla reddit is compatible
    ["all", "popular", "friends", "mod"].includes(subreddit2) || // special-case subreddits are always compatible
    await isAllowedByOptions() || await hasSidebarIndicator();
    const compatible = await compatibleSubredditStyle;
    for (const callback of onUpdate) callback();
    session_exports.set(id, compatible);
  }
  async function toggledSubredditStyle(toggledOn) {
    const currSub = currentSubreddit();
    if (!nightModeActive() || !currSub) {
      return;
    }
    const subreddit2 = currSub.toLowerCase();
    const whitelist = module12.options.subredditStylesWhitelist.value.split(",");
    if (toggledOn && !compatibleSubredditStyle) {
      if (!whitelist.includes(subreddit2)) {
        whitelist.push(subreddit2);
      }
    } else if (!toggledOn) {
      pull_default(whitelist, subreddit2);
    }
    module12.options.subredditStylesWhitelist.value = whitelist.join(",");
    save2(module12.options.subredditStylesWhitelist);
    await refreshSubredditStyleCompatability();
  }
  async function refreshAutomaticNightMode() {
    const nightModeOverrideStart = await nightmodeOverrideStorage.get();
    const nightModeOverrideLength = HOUR * parseFloat(module12.options.nightModeOverrideHours.value);
    const nightModeOverrideEnd = (parseInt(nightModeOverrideStart, 10) || 0) + nightModeOverrideLength;
    if (Date.now() <= nightModeOverrideEnd) return;
    toggle3.toggle("auto", await isTimeForNightMode());
  }
  function getGeolocation() {
    return new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(
        (position) => resolve(position.coords),
        reject
      );
    });
  }
  async function getNightModeTimes() {
    switch (module12.options.automaticNightMode.value) {
      case "automatic":
        try {
          const { latitude, longitude } = await getGeolocation();
          const { sunrise, sunset } = (0, import_suncalc.getTimes)(/* @__PURE__ */ new Date(), latitude, longitude);
          return { startingTime: sunset, endingTime: sunrise };
        } catch (err) {
          console.warn("Failed to init automatic night mode:", err);
          switch (err.code) {
            case err.PERMISSION_DENIED:
              if (!location.protocol.startsWith("http")) throw err;
              return alert_exports.open(i18n("nightModeAutomaticNightModeDenied", "confirm"), { cancelable: true }).then(() => {
                module12.options.automaticNightMode.value = "none";
                save2(module12.options.automaticNightMode);
                return {
                  startingTime: /* @__PURE__ */ new Date(0),
                  endingTime: /* @__PURE__ */ new Date(0)
                };
              });
            case err.POSITION_UNAVAILABLE:
            case err.TIMEOUT:
            case err.UNKNOWN_ERROR:
            default:
              throw err;
          }
        }
      case "user":
        return {
          startingTime: timeStringToDate(module12.options.nightModeStart.value),
          endingTime: timeStringToDate(module12.options.nightModeEnd.value)
        };
      default:
        throw new Error(`Invalid automaticNightMode value: ${module12.options.automaticNightMode.value}`);
    }
  }
  async function isTimeForNightMode() {
    if (module12.options.automaticNightMode.value === "system") {
      return window.matchMedia("(prefers-color-scheme: dark)").matches;
    }
    const currentTime = /* @__PURE__ */ new Date();
    const { startingTime, endingTime } = await getNightModeTimes();
    if (startingTime <= endingTime) {
      return startingTime <= currentTime && currentTime < endingTime;
    } else {
      return startingTime <= currentTime || currentTime < endingTime;
    }
  }
  function timeStringToDate(timeString) {
    const [hour, minute] = timeString.split(":").map((s) => parseInt(s, 10));
    const date = /* @__PURE__ */ new Date();
    date.setHours(
      hour,
      minute,
      0,
      0
      /* ms */
    );
    return date;
  }
  var className = () => {
    switch (appType()) {
      case "r2":
      case "options":
        return "res-nightmode";
      case "d2x":
        return "res-d2x-nightmode";
      default:
        throw new Error(`Impossible appType: ${appType()}`);
    }
  };
  var addStyle2 = () => bodyClasses_exports.add(className());
  var removeStyle = () => bodyClasses_exports.remove(className());
  var refreshStyle = () => {
    if (isRunning(module12) && module12.options.nightModeOn.value) {
      addStyle2();
      localStorage.setItem(localStorageKey, "true");
    } else {
      removeStyle();
      localStorage.removeItem(localStorageKey);
    }
  };

  // lib/modules/userTagger.js
  var module13 = new Module("userTagger");
  var bgToTextColorMap = {
    none: "inherit",
    aqua: "black",
    black: "white",
    blue: "white",
    cornflowerblue: "white",
    fuchsia: "white",
    gray: "white",
    green: "white",
    lime: "black",
    maroon: "white",
    navy: "white",
    olive: "white",
    orange: "white",
    orangered: "white",
    pink: "black",
    purple: "white",
    red: "white",
    silver: "black",
    teal: "white",
    white: "black",
    yellow: "black"
  };
  module13.moduleName = "userTaggerName";
  module13.category = "usersCategory";
  module13.description = "userTaggerDesc";
  module13.options = {
    showTaggingIcon: {
      title: "userTaggerShowTaggingIconTitle",
      type: "boolean",
      value: true,
      description: "userTaggerShowTaggingIconDesc"
    },
    storeSourceLink: {
      title: "userTaggerStoreSourceLinkTitle",
      type: "boolean",
      value: true,
      description: "userTaggerStoreSourceLinkDesc",
      advanced: true
    },
    useCommentsLinkAsSource: {
      title: "userTaggerUseCommentsLinkAsSourceTitle",
      type: "boolean",
      value: true,
      description: "userTaggerUseCommentsLinkAsSourceDesc",
      advanced: true
    },
    trackVoteWeight: {
      title: "userTaggerTrackVoteWeightTitle",
      type: "boolean",
      value: true,
      description: "userTaggerTrackVoteWeightDesc",
      advanced: true
    },
    vwNumber: {
      title: "userTaggerVwNumberTitle",
      type: "boolean",
      value: true,
      description: "userTaggerVWNumberDesc",
      advanced: true,
      dependsOn: (options6) => options6.trackVoteWeight.value
    },
    truncateTag: {
      title: "userTaggerTruncateTagTitle",
      type: "boolean",
      value: true,
      description: "userTaggerTruncateTagDesc",
      advanced: true
    },
    presetTags: {
      title: "userTaggerPresetTagsTitle",
      type: "table",
      addRowText: "+add preset",
      fields: [{
        key: "text",
        name: "text",
        type: "text"
      }, {
        key: "color",
        name: "color",
        type: "select",
        value: "none",
        values: Object.entries(bgToTextColorMap).map(([k2, v]) => ({
          name: k2,
          value: k2,
          style: `color: ${v}; background-color: ${k2};`
        }))
      }],
      value: [],
      description: "userTaggerPresetTagsDesc",
      advanced: true
    }
  };
  var tagStorage = storage_exports.wrapPrefix("tag.", () => null, (user) => user.toLowerCase(), true);
  module13.beforeLoad = () => {
    watchForThings(null, (thing) => {
      const ele = thing.getAuthorElement();
      if (ele) applyFromElement(ele);
    });
    watchForElements(["page", "selfText"], usernameSelector, applyFromElement);
    watchForRedditEvents("postAuthor", (element, { author, _: { update: update3 } }) => {
      if (update3) return;
      for (const tag of element.getElementsByClassName("RESUserTag")) tag.remove();
      applyToUser(element, { username: author });
    });
    watchForRedditEvents("commentAuthor", (element, { author, _: { update: update3 } }) => {
      if (update3) return;
      applyToUser(element, { username: author });
    });
    watchForRedditEvents("userHovercard", (element, { user: { username }, _: { update: update3 } }) => {
      if (update3) return;
      applyToUser(element, { username, renderTaggingIcon: false });
    });
  };
  module13.contentStart = () => {
    if (module13.options.trackVoteWeight.value && loggedInUser()) {
      attachVoteHandler();
    }
    registerCommandLine2();
    addDashboardTab("userTaggerContents", i18n("userTaggerMyUserTags"), module13.moduleID, addDashboardFunctionality2);
  };
  function applyFromElement(element) {
    const username = getUsernameFromLink(element);
    if (username) return applyToUser(element, { username });
  }
  function applyToUser(element, {
    username,
    renderTaggingIcon = module13.options.showTaggingIcon.value && username !== loggedInUser(),
    renderVoteWeight = module13.options.trackVoteWeight.value && username !== loggedInUser()
  } = {}) {
    const tag = Tag.getUnfilled(username);
    tag.add(element, { renderVoteWeight, renderTaggingIcon });
    tag.fill();
  }
  var tags = /* @__PURE__ */ new Map();
  var Tag = class _Tag {
    static defaultTagElement = /* @__PURE__ */ ((e2) => () => e2().cloneNode(true))(once_default(() => _Tag.buildTagElement()));
    static buildTagElement({ text, color } = {}) {
      return string_exports.html`
			<span class="RESUserTag">
				<a
					class="userTagLink ${text || color ? "hasTag" : "RESUserTagImage"} ${module13.options.truncateTag.value ? "truncateTag" : ""}"
					${(text || color) && string_exports._html`style="background-color: ${color || "none"}; color: ${bgToTextColorMap[color || "none"]} !important;"`}
					title="${text || "set a tag"}"
					href="javascript:void 0"
				>${text || "\xA0"}</a>
			</span>
		`;
    }
    static async getStored() {
      return Object.entries(await tagStorage.getAll()).map(([k2, v]) => {
        const tag = _Tag.getUnfilled(k2);
        tag.load(v);
        return tag;
      });
    }
    static getUnfilled(id2) {
      let tag = tags.get(id2);
      if (!tag) {
        tag = new _Tag(id2);
        tags.set(id2, tag);
      }
      return tag;
    }
    static async get(id2) {
      const tag = _Tag.getUnfilled(id2);
      await tag.fill();
      return tag;
    }
    id;
    text = null;
    link = null;
    color = null;
    votesUp = 0;
    votesDown = 0;
    get ignored() {
      return listFilters.users.includesString(this.id);
    }
    instances = [];
    constructor(id2 = "~dummy") {
      this.id = id2;
    }
    fill = once_default(async () => {
      const data2 = await tagStorage.get(this.id);
      if (data2) {
        if (Object.keys(this.getBaseDifference(data2)).length) {
          this.load(data2);
        } else {
          this.delete();
        }
      }
    });
    load(data2) {
      if (data2.color !== void 0) this.color = data2.color;
      else if (data2.color === "none") this.color = null;
      if (data2.link !== void 0) this.link = data2.link;
      if (data2.text !== void 0) this.text = data2.text;
      if (data2.votesDown !== void 0) this.votesDown = data2.votesDown;
      if (data2.votesUp !== void 0) this.votesUp = data2.votesUp;
      for (const instance of this.instances) this.render(instance);
    }
    extract() {
      return {
        color: this.color,
        link: this.link,
        text: this.text,
        votesDown: this.votesDown,
        votesUp: this.votesUp
      };
    }
    save() {
      tagStorage.set(this.id, this.getBaseDifference());
    }
    getBaseDifference(data2 = this.extract()) {
      const base = new _Tag().extract();
      return pickBy_default(data2, (v, k2) => base[k2] !== v);
    }
    delete() {
      tagStorage.delete(this.id);
    }
    add(element, { renderTaggingIcon, renderVoteWeight, append = isAppType("d2x") } = {}) {
      const instance = this.instances.find((v) => v.element === element) || { element };
      instance.append = append;
      if (!this.instances.includes(instance)) this.instances.push(instance);
      if (renderTaggingIcon) instance.renderTaggingIcon = true;
      if (renderVoteWeight) instance.renderVoteWeight = true;
      this.render(instance);
    }
    get votes() {
      return this.votesUp - this.votesDown;
    }
    ignore({ showNotice = true } = {}) {
      if (showNotice) {
        showNotification({
          moduleID: module13.moduleID,
          notificationID: "addedToIgnoreList",
          message: `
					<p>Now ignoring content posted by ${this.id}.</p>
					${isPageType("inbox") ? `
						<p>If you wish to block ${this.id} from sending you messages, go to <a href="/message/messages/">your messages</a> and click 'block user' underneath their last message.</p>
						<p><a href="https://www.reddit.com/r/changelog/comments/ijfps/reddit_change_users_may_block_other_users_that/">About blocking users</a>.</p>
					` : ""}
				`,
          closeDelay: 5e3
        });
      }
      listFilters.users.toggleString(this.id, true);
      if (!this.text) this.load({ text: "ignored" });
      this.save();
    }
    unignore() {
      listFilters.users.toggleString(this.id, false);
      if (this.text === "ignored") this.load({ text: null });
      this.save();
    }
    openPrompt(instance) {
      if (this.link === null && module13.options.storeSourceLink.value) {
        this.link = getLinkBasedOnTagLocation(instance.element);
      }
      infocard("userTagger").target(instance.tagger || instance.element).options({ openDelay: 0, width: 350, closeOnMouseOut: false }).populateWith((card) => populateDialog(this, card)).begin();
    }
    render(instance) {
      if (instance.vw) instance.vw.remove();
      if (instance.renderVoteWeight && (this.votesUp || this.votesDown)) {
        instance.vw = preventCloning(string_exports.html`
				<a
					class="voteWeight"
					href="javascript:void 0"
					title="${i18n("userTaggerYourVotesFor", this.id, `+${this.votesUp} -${this.votesDown}`)}"
					style="${getVoteWeightStyle(this)}"
				>${module13.options.vwNumber.value ? `[${this.votes > 0 ? "+" : ""}${this.votes}]` : "[vw]"}</a>
			`);
        instance.vw.addEventListener("click", () => this.openPrompt(instance));
        if (instance.append) {
          (instance.tagger || instance.element).appendChild(instance.vw);
        } else {
          (instance.tagger || instance.element).after(instance.vw);
        }
      }
      if (instance.tagger) instance.tagger.remove();
      if (this.text || this.color || instance.renderTaggingIcon) {
        instance.tagger = preventCloning(this.text || this.color ? _Tag.buildTagElement(this) : _Tag.defaultTagElement());
        instance.tagger.addEventListener("click", () => this.openPrompt(instance));
        if (instance.append) {
          instance.element.appendChild(instance.tagger);
        } else {
          instance.element.after(instance.tagger);
        }
      }
    }
  };
  function populateDialog(tag, card) {
    const head = string_exports.html`<div class="userTagger-dialog-head">
		<span class="res-icon">&#xF0AC;</span>
		<span>${tag.id}</span>
		<span class="res-usertag-ignore"></span>
		</div>
	</div>`;
    const colors = Object.entries(bgToTextColorMap).map(([color, textColor]) => ({
      textColor,
      color
    }));
    const presetTags = module13.options.presetTags.value;
    const body = string_exports.html`
		<form id="userTaggerToolTip">
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerText">Text</label>
				<input class="fieldPair-text" type="text" id="userTaggerText" value="${tag.text}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerColor">Color</label>
				<select id="userTaggerColor">
					${colors.map(({ textColor, color }) => string_exports._html`
						<option style="color: ${textColor}; background-color: ${color}" value="${color}" ${tag.color === color && string_exports._html`selected`}>${color}</option>
					`)}
				</select>
			</div>
			<div class="fieldPair" style="flex-wrap: wrap">
				<label class="fieldPair-label" for="userTaggerPreview">Preview</label>
				<span id="userTaggerPreview"></span>
				<a id="userTaggerPresetSaveAs" title="save as preset" href="javascript:void 0">save as preset</a>
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerLink">
					<span class="userTaggerOpenLink">
						<a title="open link" href="javascript:void 0">Source URL</a>
					</span>
				</label>
				<input class="fieldPair-text" type="text" id="userTaggerLink" value="${tag.link}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerVotesUp" title="Upvotes you have given this redditor">Upvotes</label>
				<input type="number" style="width: 50px;" id="userTaggerVotesUp" value="${tag.votesUp}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerVotesDown" title="Downvotes you have given this redditor">Downvotes</label>
				<input type="number" style="width: 50px;" id="userTaggerVotesDown" value="${tag.votesDown}">
			</div>
			<div class="fieldPair" ${!presetTags.length && "hidden"}>
				<label class="fieldPair-label" for="userTaggerPresetTags">Presets</label>
				<span id="userTaggerPresetTags"></span>
			</div>
			<div class="res-usertagger-footer">
				<a href="/r/dashboard#userTaggerContents" target="_blank" rel="noopener noreferer">View tagged users</a>
				<input type="submit" id="userTaggerSave" value=" save tag">
			</div>
		</form>
	`;
    const elements = {
      color: downcast(body.querySelector("#userTaggerColor"), HTMLSelectElement),
      presetSaveAs: downcast(body.querySelector("#userTaggerPresetSaveAs"), HTMLAnchorElement),
      presetTag: downcast(body.querySelector("#userTaggerPresetTags"), HTMLElement),
      presetFieldPair: downcast(body.querySelector("#userTaggerPresetTags").parentElement, HTMLElement),
      link: downcast(body.querySelector("#userTaggerLink"), HTMLInputElement),
      openLink: downcast(body.querySelector(".userTaggerOpenLink a"), HTMLAnchorElement),
      preview: downcast(body.querySelector("#userTaggerPreview"), HTMLElement),
      save: downcast(body.querySelector("#userTaggerSave"), HTMLElement),
      text: downcast(body.querySelector("#userTaggerText"), HTMLInputElement),
      votesDown: downcast(body.querySelector("#userTaggerVotesDown"), HTMLInputElement),
      votesUp: downcast(body.querySelector("#userTaggerVotesUp"), HTMLInputElement)
    };
    head.querySelector(".res-usertag-ignore").append(
      createElement_exports.toggleButton(
        (ignore) => {
          const textShouldBeUpdated = extract().text === tag.text;
          if (ignore) tag.ignore();
          else tag.unignore();
          if (textShouldBeUpdated) elements.text.value = tag.text || "";
          updateTagPreview();
        },
        "userTaggerIgnore",
        tag.ignored,
        "\uF038",
        "\uF03B",
        false,
        true
      )
    );
    function extract() {
      return {
        color: elements.color.value !== "none" ? elements.color.value : null,
        link: elements.link.value || null,
        text: elements.text.value || null,
        votesDown: parseInt(elements.votesDown.value, 10) || 0,
        votesUp: parseInt(elements.votesUp.value, 10) || 0
      };
    }
    function updateTagPreview() {
      empty(elements.preview);
      elements.preview.appendChild(Tag.buildTagElement(extract()));
    }
    function buildPresetTagElement(text, color) {
      const element = Tag.buildTagElement({ text, color });
      element.addEventListener("click", () => {
        tag.load({ text, color });
        tag.save();
        card.close();
      });
      return element;
    }
    function saveAsPreset() {
      const { text, color } = extract();
      if (text || color) {
        elements.presetFieldPair.hidden = false;
        elements.presetTag.append(buildPresetTagElement(text, color));
        module13.options.presetTags.value.push([String(text), String(color)]);
        save2(module13.options.presetTags);
      } else {
        window.alert("Tag text must be specified in order to save as preset.");
      }
    }
    elements.openLink.addEventListener("click", () => openNewTabs("none", ...elements.link.value.split(/\s/)));
    elements.presetTag.append(...presetTags.map(([text, color]) => buildPresetTagElement(text, color)));
    elements.presetSaveAs.addEventListener("click", () => saveAsPreset());
    (0, import_jquery12.default)(body).on("change input click", updateTagPreview);
    body.addEventListener("submit", (e2) => {
      e2.preventDefault();
      tag.load(extract());
      tag.save();
      card.close();
    });
    updateTagPreview();
    setTimeout(() => {
      elements.text.setSelectionRange(elements.text.value.length, elements.text.value.length);
      elements.text.focus();
    });
    return [head, body];
  }
  function registerCommandLine2() {
    let tag;
    registerCommand(
      "tag",
      `tag [text] - ${i18n("userTaggerCommandLineDescription")}`,
      async (command, val) => {
        const username = selectedThing_exports.current && selectedThing_exports.current.getAuthor();
        tag = username && await Tag.get(username);
        return tag ? i18n(val ? "userTaggerTagUserAs" : "userTaggerTagUser", tag.id, val) : i18n("userTaggerTagCanNotSetTag");
      },
      (command, val) => {
        if (tag) {
          tag.load({ text: val });
          tag.save();
        } else {
          return i18n("userTaggerTagCanNotSetTag");
        }
      }
    );
  }
  function attachVoteHandler() {
    document.body.addEventListener("click", (e2) => {
      if (e2.button !== 0) return;
      if (e2.target.classList.contains("arrow")) {
        handleVoteClick(e2.target);
      }
    }, true);
  }
  async function handleVoteClick(arrow) {
    const $this = (0, import_jquery12.default)(arrow);
    const $otherArrow = $this.siblings(".arrow");
    if ($this.hasClass("archived")) {
      return;
    }
    let up = 0;
    let down = 0;
    if ($this.hasClass("up")) {
      up = 1;
      if ($otherArrow.hasClass("downmod")) {
        down = -1;
      }
    } else if ($this.hasClass("upmod")) {
      up = -1;
    } else if ($this.hasClass("down")) {
      down = 1;
      if ($otherArrow.hasClass("upmod")) {
        up = -1;
      }
    } else if ($this.hasClass("downmod")) {
      down = -1;
    }
    const thing = Thing.checkedFrom(arrow);
    const username = thing.getAuthor();
    if (username === loggedInUser()) return;
    const tag = username && await Tag.get(username);
    if (!tag) throw new Error("No tag");
    tag.load({
      votesUp: tag.votesUp + up,
      votesDown: tag.votesDown + down
    });
    tag.save();
  }
  function getLinkBasedOnTagLocation(obj) {
    const thing = Thing.from(obj);
    if (!thing) return "";
    const link = !module13.options.useCommentsLinkAsSource.value && thing.getTitleElement() || thing.getCommentPermalink();
    return link ? link.href : "";
  }
  function getVoteWeightStyle({ votes, votesUp, votesDown }) {
    let red = 255;
    let green = 255;
    let blue = 255;
    let alpha = 1;
    if (votesUp > votesDown) {
      red = Math.max(0, 255 - 8 * votes);
      green = 255;
      blue = Math.max(0, 255 - 8 * votes);
      alpha = Math.abs(votes) / (votesUp + votesDown);
    } else if (votesUp < votesDown) {
      red = 255;
      green = Math.max(0, 255 - Math.abs(8 * votes));
      blue = Math.max(0, 255 - Math.abs(8 * votes));
      alpha = Math.abs(votes) / (votesUp + votesDown);
    }
    const color = `rgba(${red}, ${green}, ${blue}, ${0.2 + alpha * 0.8})`;
    return nightModeActive() ? `color: ${color};` : `background-color: ${color};`;
  }
  async function addDashboardFunctionality2(tabPage) {
    const headers = {
      username: i18n("userTaggerUsername"),
      tag: i18n("userTaggerTag"),
      color: i18n("userTaggerColor"),
      votesDown: i18n("userTaggerVotesDown"),
      votesUp: i18n("userTaggerVotesUp"),
      delete: ""
    };
    const data2 = await Tag.getStored();
    const getRow = (tag) => {
      const tagSpan = document.createElement("span");
      tag.add(tagSpan, { renderTaggingIcon: true, append: true });
      const deleteSpan = string_exports.html`<span class="res-icon res-right deleteIcon" data-icon="&#xf056;"></span>`;
      deleteSpan.addEventListener("click", () => {
        alert_exports.open(i18n("userTaggerAreYouSureYouWantToDeleteTag", tag.id), { cancelable: true }).then(() => {
          tag.delete();
          pull_default(data2, tag);
          table2.refresh();
        });
      });
      return {
        username: string_exports.html`<a href="/user/${tag.id}">${tag.id}</a>`,
        tag: tagSpan,
        color: string_exports.html`<span style="color: ${tag.color || "initial"}">${tag.color ? tag.color : ""}</span>`,
        votesDown: tag.votesDown,
        votesUp: tag.votesUp,
        delete: deleteSpan
      };
    };
    const table2 = new table_exports.RESTable(headers, data2, getRow, { sortBy: "username" });
    const element = document.createElement("div");
    element.append(
      table2.createSearchElement((tag) => tag.id, "Username", true),
      table2.createSearchElement((tag) => tag.text, "Tag"),
      table2.createSelectFilterElement([
        { name: i18n("userTaggerAllUsers"), filter: () => true, initialSelected: false },
        { name: i18n("userTaggerTaggedUsers"), filter: (tag) => tag.text || tag.color, initialSelected: true }
      ]),
      table2.createPaginationElement(),
      table2.element
    );
    tabPage.append(element);
  }

  // lib/modules/filteReddit/postCases/UserTag.js
  var UserTag = class extends PatternCase {
    static text = "User tag";
    static async thingToCriterion(thing) {
      const author = thing.getAuthor();
      return author && (await Tag.get(author)).text || "";
    }
    static fields = ["author of this post has tag matching ", { type: "text", id: "patt" }];
    static pattern = "[RegEx]";
    trueText = `user tag ${this.conditions.patt}`.trim();
    value = this.build(true, "/./");
    async evaluate(thing) {
      const author = thing.getAuthor();
      if (!author) return null;
      const tag = (await Tag.get(author)).text;
      return tag ? this.value.some((v) => v.test(tag)) : false;
    }
  };

  // lib/modules/filteReddit/postCases/UserVoteWeight.js
  var UserVoteWeight = class extends Case {
    static text = "User vote weight";
    static parseCriterion(input2) {
      return { op: ">=", val: parseInt(input2, 10) };
    }
    static async thingToCriterion(thing) {
      const username = thing.getAuthor();
      if (!username) throw new Error("No username");
      return String((await Tag.get(username)).votes || 0);
    }
    static defaultConditions = { op: ">", val: 0 };
    static fields = ["user's vote weight is ", { type: "select", options: "COMPARISON", id: "op" }, " ", { type: "number", id: "val" }, " votes"];
    static slow = 1;
    static get disabled() {
      return !isEnabled(userTagger_exports) || !module13.options.trackVoteWeight.value;
    }
    static pattern = "integer";
    trueText = `vote weight ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    falseText = `vote weight ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
    isValid() {
      return Number.isInteger(this.value.val);
    }
    async evaluate(thing) {
      const username = thing.getAuthor();
      if (!username) return null;
      return numericalCompare(this.value.op, (await Tag.get(username)).votes, this.value.val);
    }
  };

  // lib/modules/filteReddit/postCases/Username.js
  var Username = class extends PatternCase {
    static text = "Username";
    static thingToCriterion(thing) {
      return thing.getAuthor();
    }
    static fields = ["posted by /u/", { type: "text", id: "patt" }];
    trueText = `by ${this.conditions.patt}`;
    value = this.build(true);
    evaluate(thing) {
      const user = thing.getAuthor();
      if (!user) return null;
      return this.value.some((v) => v.test(user));
    }
  };

  // lib/modules/filteReddit/postCases/VoteType.js
  var options3 = [
    ["upvoted", "upvote"],
    ["downvoted", "downvote"],
    ["not voted", "unvoted"]
  ];
  var VoteType = class extends Case {
    static text = "Vote type";
    static parseCriterion(input2) {
      return { kind: input2 };
    }
    static defaultConditions = { kind: "unvoted" };
    static fields = ["post is ", { type: "select", id: "kind", options: options3 }, " by me"];
    static pattern = `(${options3.map(([, cls]) => cls).join("|")})`;
    trueText = (options3.find(([, cls]) => cls === this.conditions.kind) || [])[0];
    isValid() {
      return options3.map(([, cls]) => cls).includes(this.value.kind);
    }
    evaluate(thing) {
      switch (this.value.kind) {
        case "upvote":
          return thing.isUpvoted();
        case "downvote":
          return thing.isDownvoted();
        case "unvoted":
          return thing.isUnvoted();
        default:
          throw new Error("Invalid option");
      }
    }
  };

  // lib/modules/filteReddit/commentCases/index.js
  var commentCases_exports = {};
  __export(commentCases_exports, {
    commentContent: () => CommentContent,
    commentLength: () => CommentLength,
    depth: () => Depth,
    hasExpando: () => Expando2,
    isDeleted: () => IsDeleted,
    isRead: () => IsRead,
    postAfter: () => PostAfter,
    postAge: () => PostAge,
    score: () => Score,
    selector: () => Selector,
    subreddit: () => Subreddit,
    userAttr: () => UserAttr,
    userFlair: () => UserFlair,
    userTag: () => UserTag,
    userVoteWeight: () => UserVoteWeight,
    username: () => Username,
    voteType: () => VoteType
  });

  // lib/modules/filteReddit/commentCases/CommentContent.js
  var CommentContent = class extends PatternCase {
    static text = "Comment content";
    static parseCriterion(input2) {
      return { patt: input2 };
    }
    static fields = ["comment contains ", { type: "text", id: "patt" }];
    trueText = `comment contains ${this.conditions.patt}`;
    value = this.build(false);
    evaluate(thing) {
      const body = thing.getTextBody();
      if (!body) return null;
      return this.value.some((v) => v.test(body.textContent));
    }
  };

  // lib/modules/filteReddit/commentCases/CommentLength.js
  var options4 = ["characters", "words"];
  var CommentLength = class extends Case {
    static text = "Comment length";
    static parseCriterion(input2) {
      return { op: ">=", kind: "words", val: parseInt(input2, 10) };
    }
    static fields = ["comment length is ", { type: "select", options: "COMPARISON", id: "op" }, " ", { type: "number", id: "val" }, " ", { type: "select", id: "kind", options: options4 }];
    static defaultConditions = { op: ">", kind: "words", val: 0 };
    static pattern = "integer";
    trueText = `length ${prettyOperator(this.conditions.op)} ${this.conditions.val} ${this.conditions.kind}`;
    falseText = `length ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val} ${this.conditions.kind}`;
    isValid() {
      return Number.isInteger(this.value.val);
    }
    evaluate(thing) {
      const md = thing.entry.querySelector(".md");
      if (!md) return null;
      switch (this.value.kind) {
        case "characters":
          return numericalCompare(this.value.op, md.textContent.length, this.value.val);
        case "words":
          return numericalCompare(this.value.op, md.textContent.split(" ").length, this.value.val);
        default:
          throw new Error("Invalid option");
      }
    }
  };

  // lib/modules/filteReddit/commentCases/Depth.js
  var Depth = class extends Case {
    static text = "Comment depth";
    static parseCriterion(input2) {
      return { op: "==", val: parseInt(input2, 10) };
    }
    static thingToCriterion(thing) {
      return String(thing.getParents().length);
    }
    static defaultConditions = { op: ">", val: 0 };
    static fields = ["comment's depth ", { type: "select", options: "COMPARISON", id: "op" }, " ", { type: "number", id: "val" }];
    static pattern = "integer";
    trueText = `depth ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    falseText = `depth ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
    isValid() {
      return this.value.val >= 0;
    }
    evaluate(thing) {
      const depth = thing.getParents().length;
      return numericalCompare(this.value.op, depth, this.value.val);
    }
  };

  // lib/modules/filteReddit/commentCases/IsDeleted.js
  var IsDeleted = class extends Case {
    static text = "Deleted";
    static fields = ["comment is deleted"];
    static unique = true;
    trueText = "deleted";
    evaluate(thing) {
      return thing.isDeleted();
    }
  };

  // lib/modules/readComments.js
  var readComments_exports = {};
  __export(readComments_exports, {
    add: () => add2,
    isRead: () => isRead,
    module: () => module14
  });
  var module14 = new Module("readComments");
  module14.moduleName = "readCommentsName";
  module14.category = "commentsCategory";
  module14.description = "readCommentsDesc";
  module14.options = {
    cleanComments: {
      type: "text",
      value: "30",
      description: "readCommentsCleanCommentsDesc",
      title: "readCommentsCleanCommentsTitle",
      advanced: true
    },
    monitorSelected: {
      type: "boolean",
      value: true,
      description: "readCommentsMonitorSelectedDesc",
      title: "readCommentsMonitorSelectedTitle"
    },
    monitorWhenIncognito: {
      type: "boolean",
      value: false,
      dependsOn: () => module14.options.monitorSelected.value,
      description: "readCommentsMonitorWhenIncognitoDesc",
      title: "readCommentsMonitorWhenIncognitoTitle",
      advanced: true
    }
  };
  module14.include = ["comments", "commentsLinklist"];
  var currentId = (execRegexes.comments(location.pathname) || [])[2] || location.pathname;
  var entryStorage2 = storage_exports.wrapPrefix("readComments.", () => ({
    updateTime: Date.now(),
    ids: {}
  }));
  var initial = entryStorage2.get(currentId);
  var initialReadIds;
  module14.beforeLoad = async () => {
    initialReadIds = await initial.then(({ ids }) => new Set(Object.keys(ids)));
    maybeHidePrevious();
    if (module14.options.monitorSelected.value) {
      if (!module14.options.monitorWhenIncognito.value && isPrivateBrowsing()) return;
      selectedThing_exports.addListener((current2) => {
        if (current2.isComment() && current2.isVisible()) add2(current2);
      }, "beforePaint");
    }
    maybePruneOldEntries("readComments", entryStorage2, parseInt(module14.options.cleanComments.value, 10));
  };
  async function maybeHidePrevious() {
    if (!initialReadIds.size) return;
    const filterline2 = await filterlinePromise;
    const filter = filterline2.createFilter({ type: "isRead", id: "isRead" });
    if (filter.state === false && filter.effects.hide) return;
    await new Promise((res) => {
      watchForThings(["comment"], (thing) => {
        if (isRead(thing)) res();
      });
    });
    const hideButton = document.createElement("button");
    hideButton.textContent = "Hide read comments";
    hideButton.addEventListener("click", () => {
      filter.update(false, void 0, {
        hide: true
        /* `, propagate: true` may be desirable */
      });
      if (!filter.parent) filterline2.addFilter(filter);
      if (ensureFilterlineVisible) ensureFilterlineVisible();
      notification.close();
    });
    const notification = showNotification({
      moduleID: module14.moduleID,
      notificationID: "hideRead",
      header: "Previously read comments",
      message: hideButton,
      closeDelay: 8e3
    });
  }
  var _add = batch((ids) => entryStorage2.patch(
    currentId,
    { ids: ids.reduce((acc, id2) => {
      acc[id2] = true;
      return acc;
    }, {}), updateTime: Date.now() }
  ), { size: Infinity, delay: 5e3, flushBeforeUnload: true });
  var add2 = (thing) => {
    if (!initialReadIds) throw new Error("readComments module is not initialized");
    const id2 = thing.getFullname();
    _add(id2);
  };
  var isRead = (thing) => {
    if (!initialReadIds) throw new Error();
    return initialReadIds.has(thing.getFullname());
  };

  // lib/modules/filteReddit/commentCases/IsRead.js
  var IsRead = class extends Case {
    static text = "Read";
    static fields = ["comment is read"];
    static get disabled() {
      return !isEnabled(readComments_exports);
    }
    static unique = true;
    trueText = "read";
    evaluate(thing) {
      return isRead(thing);
    }
  };

  // lib/modules/filteReddit/browseCases/index.js
  var browseCases_exports = {};
  __export(browseCases_exports, {
    browsingFrontPage: () => BrowsingFrontPage,
    currentLocation: () => CurrentLocation,
    currentMulti: () => CurrentMulti,
    currentSub: () => CurrentSub,
    currentUserProfile: () => CurrentUserProfile,
    date: () => Date2,
    dow: () => Dow,
    loggedInAs: () => LoggedInAs,
    toggle: () => Toggle2
  });

  // lib/modules/filteReddit/browseCases/BrowsingFrontPage.js
  var BrowsingFrontPage = class extends Case {
    static text = "Browsing the front page";
    static fields = ["when browsing the front page"];
    evaluate() {
      return isPageType("linklist") && !currentSubreddit() && !currentMultireddit() && !currentUserProfile();
    }
  };

  // lib/modules/filteReddit/browseCases/CurrentLocation.js
  var CurrentLocation = class extends Case {
    static text = "When browsing in location";
    static defaultConditions = { patt: fullLocation() };
    static fields = ["when browsing ", { type: "text", id: "patt" }];
    evaluate() {
      return fullLocation() === this.value.patt;
    }
  };

  // lib/modules/filteReddit/browseCases/CurrentMulti.js
  var CurrentMulti = class extends Case {
    static text = "When browsing a multireddit";
    static defaultConditions = { user: "", name: "" };
    static fields = ["when browsing /u/", { type: "text", id: "user" }, "/m/", { type: "text", id: "name" }];
    value = {
      name: Case.buildRegex(this.conditions.name),
      user: Case.buildRegex(this.conditions.user)
    };
    evaluate() {
      const rawMulti = currentMultireddit();
      if (!rawMulti) return false;
      const parts = /^(?:user\/)?([a-z0-9_-]+)\/m\/([a-z0-9_-]+)$/i.exec(rawMulti);
      if (!parts) return false;
      const [, user, multi] = parts;
      if (user === "me" && this.conditions.name === "me") {
        return this.value.name.test(multi);
      } else {
        return this.value.user.test(user) && this.value.name.test(multi);
      }
    }
  };

  // lib/modules/filteReddit/browseCases/CurrentUserProfile.js
  var CurrentUserProfile = class extends Case {
    static text = "When browsing a user profile";
    static defaultConditions = { patt: "" };
    static fields = ["when browsing /u/", { type: "text", id: "patt" }, "'s posts"];
    value = Case.buildRegex(this.conditions.patt);
    evaluate() {
      const user = currentUserProfile();
      return !!user && this.value.test(user);
    }
  };

  // lib/modules/filteReddit/browseCases/CurrentSub.js
  var CurrentSub = class extends Case {
    static text = "When browsing a subreddit";
    static defaultConditions = { patt: "" };
    static fields = ["when browsing /r/", { type: "text", id: "patt" }];
    value = Case.buildRegex(this.conditions.patt);
    evaluate() {
      const sub = currentSubreddit();
      return !!sub && this.value.test(sub);
    }
  };

  // lib/modules/filteReddit/browseCases/Date.js
  var options5 = [
    ["before", "<"],
    ["on or after", ">="]
  ];
  var Date2 = class extends Case {
    static text = "Date";
    static defaultConditions = { op: "<", date: "2020-12-30" };
    static fields = ["today is ", { type: "select", options: options5, id: "op" }, " ", { type: "text", id: "date" }];
    value = { op: this.conditions.op, date: dayjs(this.conditions.date) };
    isValid() {
      return this.value.date.isValid();
    }
    evaluate() {
      return this.value.op === "<" === dayjs().isBefore(this.value.date);
    }
  };

  // lib/modules/filteReddit/browseCases/Dow.js
  var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var Dow = class extends Case {
    static text = "Day of week";
    static defaultConditions = { days: [] };
    static fields = ["current day of the week is ", { type: "checkset", items: days, id: "days" }];
    evaluate() {
      const currentDOW = days[(/* @__PURE__ */ new Date()).getDay()];
      return this.value.days.includes(currentDOW);
    }
  };

  // lib/modules/filteReddit/browseCases/LoggedInAs.js
  var LoggedInAs = class extends Case {
    static text = "Logged in user";
    static defaultConditions = { loggedInAs: "" };
    // Don't try to fetch current username as the default value, as that may trigger `loggedInUser` prematurely
    static fields = ["logged in as /u/", { type: "text", id: "loggedInAs" }];
    value = Case.buildRegex(this.conditions.loggedInAs);
    async evaluate() {
      await pagePhases_exports.contentStart;
      const myName = loggedInUser();
      return !!myName && this.value.test(myName);
    }
  };

  // lib/modules/filteReddit/browseCases/Toggle.js
  var getOptions = () => getToggles().map(({ key, text }) => [text, key]);
  var Toggle2 = class extends Case {
    static text = "Custom toggle";
    static defaultConditions = { toggleName: getOptions()[0] || "" };
    // TODO Migrate `toggleName` to `key`
    static fields = [
      "custom toggle ",
      { type: "select", id: "toggleName", get options() {
        return getOptions();
      } },
      " is enabled"
    ];
    evaluate() {
      const key = this.value.toggleName;
      return toggleActive(key);
    }
  };

  // lib/modules/filteReddit/cases.js
  var Inert = class extends Case {
    isValid() {
      return false;
    }
    evaluate() {
      console.error("Evaluating inert case");
      return false;
    }
  };
  var True = class extends Case {
    static text = "True";
    static fields = ["always true"];
    evaluate() {
      return true;
    }
  };
  var False = class extends Case {
    static text = "False";
    static fields = ["always false"];
    evaluate() {
      return false;
    }
  };
  var Group = class extends Case {
    static text = "Group of conditions";
    static fields = [
      { type: "select", options: ["none", "any", "one", "all"], id: "op" },
      " of these are true:",
      { type: "multi", include: "all", id: "of" }
    ];
    static defaultConditions = { op: "all", of: [] };
    static slow = 1;
    // May be considerably slower depending on children
    _cases = this.conditions.of.map((v) => Case.fromConditions(v));
    // TODO This is unnecessary for some external filters
    trueText = this._cases.length && this.toCriterion(this.conditions.op, this._cases) || "empty group";
    toCriterion(op, cases) {
      const symbol = (op === "any" || op === "none") && "\u2228" || op === "one" && "\u2295" || "\u2227";
      let str = cases.map((v) => v.trueText).join(` ${symbol} `);
      if (cases.length > 1) str = `(${str})`;
      return op === "none" ? `\xAC ${str}` : str;
    }
    isValid() {
      return this._cases.every((v) => v.isValid());
    }
    value = (() => {
      const op = this.conditions.op;
      const [NONE, ANY, ONE, ALL] = [op === "none", op === "any", op === "one", op === "all"];
      const evaluators = this._cases.sort((a2, b2) => a2.constructor.slow - b2.constructor.slow).map((cased) => cased.evaluate.bind(cased));
      return fastAsync(function* (thing) {
        let seenTrue = false;
        for (const evaluator of evaluators) {
          if (yield evaluator(thing)) {
            if (NONE) return false;
            else if (ANY) return true;
            else if (ONE && seenTrue) return false;
            seenTrue = true;
          } else {
            if (ALL) return false;
          }
        }
        if (NONE) return true;
        else if (ANY) return false;
        else if (ONE) return seenTrue;
        else return true;
      });
    })();
    hasType(type) {
      return super.hasType(type) || this._cases.some((v) => v.hasType(type));
    }
    evaluate(thing) {
      return this.value(thing);
    }
    onObserve() {
      return this._cases.map((v) => v.observe(this)).some((v) => v);
    }
  };
  var falseConditions = { type: "false" };
  var trueConditions = { type: "true" };
  var inertConditions = { type: "inert" };
  function resolveGroup(initial3, precompute = true, keepGroup = false) {
    let seenTrue = false;
    let of = [];
    let op = initial3.op;
    for (let v of initial3.of) {
      if (!has4(v.type)) {
        console.error(`Type ${v.type} is not available`);
        return inertConditions;
      }
      if (v.type === "group") v = resolveGroup(v, precompute);
      if (!keepGroup && precompute && !available[v.type].prototype.evaluate.length) {
        const match = Case.fromConditions(v).evaluate();
        if (typeof match === "boolean") {
          if (match) {
            if (op === "none") return falseConditions;
            if (op === "any") return trueConditions;
            if (op === "one" && seenTrue) return falseConditions;
            seenTrue = true;
          } else {
            if (op === "all") return falseConditions;
          }
          continue;
        }
      }
      of.push(v);
    }
    if (op === "one" && seenTrue) {
      op = "none";
    }
    if (!keepGroup) {
      if (of.length === 1) {
        const p = of[0];
        if (op !== "none") {
          return p;
        } else if (p.type === "group") {
          if (p.op === "none") {
            p.op = "any";
            return p;
          } else if (p.op === "any" || p.op === "all") {
            p.op = "none";
            return p;
          }
        }
      }
      if (!of.length) {
        if (op === "none") return trueConditions;
        if (op === "any") return falseConditions;
        if (op === "one") return falseConditions;
        if (op === "all") return trueConditions;
      }
    }
    if (precompute && (op === "any" || op === "none")) {
      const l = of.length;
      const typeSorted = of.sort((a2, b2) => a2.type === b2.type ? 0 : a2.type > b2.type ? 1 : -1);
      of = [];
      for (let i2 = 0; i2 < l; i2++) {
        const a2 = typeSorted[i2];
        const cls = available[a2.type];
        const reconcile = cls.reconcile;
        if (reconcile) {
          const values = [a2];
          let b2;
          while ((b2 = typeSorted[i2 + 1]) && a2.type === b2.type) {
            i2++;
            values.push(b2);
          }
          of.push(...reconcile(values));
        } else {
          of.push(a2);
        }
      }
    }
    return { type: "group", op, of };
  }
  function getConditions(type, conditions) {
    return { type, ...available[type] && available[type].defaultConditions, ...conditions };
  }
  function getGroup(op, of) {
    return getConditions("group", { op, of });
  }
  function createAdHoc(type, getConditions2, variant, context, customFilter) {
    const { opts: { name: name2 = type } = {} } = customFilter || {};
    class AdHoc extends Case {
      static text = name2;
      // Generate new conditions each time in order to avoid caching, as
      // `getConditions` can return updated values, e.g. if a external filter has been removed
      static get defaultConditions() {
        return getConditions2();
      }
      static unique = true;
      static variant = variant;
      static _customFilter = customFilter;
    }
    add3(type, AdHoc, context);
    if (type !== AdHoc.type) console.warn("Type name was changed from", name2, "to", AdHoc.type);
    return AdHoc;
  }
  var available = {};
  function getUniqueTypeName(name2) {
    if (typeof name2 !== "string") name2 = "";
    while (!name2 || has4(name2)) {
      name2 += randomHash();
    }
    return name2;
  }
  function add3(type, c2, ...contexts) {
    if (!type || available.hasOwnProperty(type) && c2 !== available[type]) {
      type = getUniqueTypeName(type);
    }
    c2.type = type;
    if (!c2.contexts) c2.contexts = [];
    c2.contexts.push(...contexts);
    available[type] = c2;
  }
  var primitives = /* @__PURE__ */ new Set();
  function populatePrimitives(types2 = ["post", "comment", "browse"]) {
    function fill(cases, ...contexts) {
      for (const [k2, v] of Object.entries(cases)) {
        add3(k2, v, ...contexts);
        primitives.add(v);
      }
    }
    fill({
      inert: Inert,
      false: False,
      true: True
    });
    fill({ group: Group }, "post", "comment", "browse");
    if (types2.includes("post")) fill(postCases_exports, "post");
    if (types2.includes("comment")) fill(commentCases_exports, "comment");
    if (types2.includes("browse")) fill(browseCases_exports, "browse");
  }
  function filterThings(things2, conditions) {
    if (!conditions) return things2;
    const cased = Case.fromConditions(conditions);
    return asyncFilter(
      things2,
      /*:: async */
      (thing) => cased.evaluate(thing)
    );
  }
  var has4 = (type) => available.hasOwnProperty(type);
  var get6 = (type) => has4(type) ? available[type] : Inert;
  var getByContext = (context, primitivesOnly = true) => pickBy_default(available, (v) => v.contexts.includes(context) && (!primitivesOnly || primitives.has(v)));
  var isUseful = (type) => typeof type === "string" && has4(type) && ![Inert.type, False.type, True.type].includes(type);

  // lib/modules/userInfo.js
  var import_jquery18 = __toESM(require_jquery(), 1);

  // lib/modules/quickMessage.js
  var quickMessage_exports = {};
  __export(quickMessage_exports, {
    messageLinkEventHandler: () => messageLinkEventHandler,
    module: () => module19,
    openQuickMessageDialog: () => openQuickMessageDialog
  });
  var import_jquery17 = __toESM(require_jquery(), 1);

  // lib/modules/commentTools.js
  var import_jquery15 = __toESM(require_jquery(), 1);

  // lib/modules/accountSwitcher.js
  var module15 = new Module("accountSwitcher");
  module15.moduleName = "accountSwitcherName";
  module15.category = "myAccountCategory";
  module15.description = "accountSwitcherDesc";
  module15.options = {
    keepLoggedIn: {
      type: "boolean",
      value: false,
      description: "accountSwitcherKeepLoggedInDesc",
      title: "accountSwitcherKeepLoggedInTitle",
      keywords: ["remember"]
    },
    accounts: {
      type: "table",
      addRowText: "accountSwitcherAddAccount",
      fields: [{
        key: "username",
        name: "accountSwitcherUsername",
        type: "text"
      }, {
        key: "password",
        name: "accountSwitcherPassword",
        type: "password"
      }, {
        key: "2fa",
        name: "accountSwitcherRequiresOtp",
        type: "boolean",
        value: false
      }],
      value: [],
      description: "accountSwitcherAccountsDesc",
      title: "accountSwitcherAccountsTitle"
    },
    updateOtherTabs: {
      type: "boolean",
      description: "accountSwitcherUpdateOtherTabsDesc",
      title: "accountSwitcherUpdateOtherTabsTitle",
      value: true,
      advanced: true
    },
    reloadOtherTabs: {
      type: "boolean",
      description: "accountSwitcherReloadOtherTabsDesc",
      title: "accountSwitcherReloadOtherTabsTitle",
      value: false,
      advanced: true
    },
    showCurrentUserName: {
      type: "boolean",
      value: false,
      description: "accountSwitcherShowCurrentUserNameDesc",
      title: "accountSwitcherShowCurrentUserNameTitle",
      advanced: true
    },
    dropDownStyle: {
      type: "enum",
      values: [{
        name: "accountSwitcherSnoo",
        value: "alien"
      }, {
        name: "accountSwitcherSimpleArrow",
        value: "arrow"
      }],
      value: "alien",
      description: "accountSwitcherDropDownStyleDesc",
      title: "accountSwitcherDropDownStyleTitle",
      advanced: true,
      bodyClass: true
    },
    showUserDetails: {
      type: "boolean",
      value: true,
      description: "accountSwitcherShowUserDetailsDesc",
      title: "accountSwitcherShowUserDetailsTitle",
      advanced: true
    },
    showKarma: {
      type: "boolean",
      value: true,
      description: "accountSwitcherShowKarmaDesc",
      title: "accountSwitcherShowKarmaTitle",
      advanced: true,
      dependsOn: (options6) => options6.showUserDetails.value
    },
    showGold: {
      type: "boolean",
      value: true,
      description: "accountSwitcherShowGoldDesc",
      title: "accountSwitcherShowGoldTitle",
      advanced: true,
      dependsOn: (options6) => options6.showUserDetails.value
    }
  };
  var hover;
  var accounts = once_default(
    () => module15.options.accounts.value.reduce((acc, v) => {
      acc[v[0].toLowerCase()] = {
        text: v[0],
        storedPassword: v[1],
        requiresOtp: v[2]
      };
      return acc;
    }, {})
  );
  module15.contentStart = () => {
    const downArrow = module15.options.dropDownStyle.value === "alien" ? string_exports.html`<span id="RESAccountSwitcherIcon" role="button"></span>` : string_exports.html`<span id="RESAccountSwitcherIcon" role="button"><span class="downArrow"></span></span>`;
    downArrow.addEventListener("click", () => hover.begin());
    downArrow.addEventListener("dblclick", manageAccounts);
    const userLink = document.querySelector("#header-bottom-right > span.user > a");
    if (userLink) {
      userLink.style.marginRight = "2px";
      userLink.after(downArrow);
    } else {
      addFloater(downArrow, { order: 3 });
    }
    hover = dropdownList(module15.moduleID).options({
      className: "RESAccountSwitcherDropdown",
      openDelay: 0,
      offsetHeight: 5
    }).populateWith(createAccountMenu).target(downArrow);
    let username;
    registerCommand(
      /^sw$/,
      `sw [username] - ${i18n("accountSwitcherCliHelp")}`,
      (command, val) => {
        const usernames = Object.keys(accounts()).filter((username2) => username2.startsWith(val.toLowerCase()));
        username = usernames.includes(val) ? val : usernames[0];
        return `${i18n("accountSwitcherCliSwitchToUsernamePrompt")} ${val}${without_default(usernames, val).length ? `[${usernames.map((v) => v.replace(val, "")).filter(Boolean).join("|")}]` : ""}`;
      },
      () => {
        if (username) switchTo(username);
        else manageAccounts();
      }
    );
  };
  async function createAccountMenu() {
    const accountMenu = document.createDocumentFragment();
    const users = await Promise.all(
      Object.entries(accounts()).map(async ([username, { text }]) => ({
        text,
        username,
        active: username.localeCompare(loggedInUser() || "", { sensitivity: "base" }) === 0,
        data: module15.options.showUserDetails.value && (await getUserInfo(username).catch((e2) => {
          console.error("Error loading userinfo for", username, e2);
          return {};
        })).data || {}
      }))
    );
    for (const { text, username, active, data: data2 } of users) {
      if (!module15.options.showCurrentUserName.value && active) continue;
      const goldExpDate = data2.gold_expiration && new Date(data2.gold_expiration * 1e3);
      const element = string_exports.html`
			<li class="accountName ${active && "active"}" role="button">
				<span style="margin-right: auto;">${text}</span>
				${module15.options.showKarma.value && data2.link_karma && string_exports._html`
					<span style="margin-left: 4px">(${data2.link_karma} &middot; ${data2.comment_karma})</span>
				`}
				${module15.options.showGold.value && data2.is_gold && string_exports._html`
					<span style="all: initial; margin-left: 4px; line-height: 0;" class="gilded-icon" title="${goldExpDate && i18n("accountSwitcherGoldUntil", formatDate(goldExpDate), formatDateDiff(/* @__PURE__ */ new Date(), goldExpDate))}"></span>
				`}
				<a style="margin-left: 4px" onclick="event.stopPropagation()" href="/user/${username}" class="res-icon linkIcon"></a>
			</li>
		`;
      element.addEventListener("click", async () => {
        bodyClasses_exports.add("res-accountSwitcher-in-progress");
        try {
          await switchTo(username);
        } catch (e2) {
          bodyClasses_exports.remove("res-accountSwitcher-in-progress");
          console.error(e2);
        }
      });
      accountMenu.append(element);
    }
    {
      const element = string_exports.html`<li class="addAccount">+ add account</li>`;
      element.addEventListener("click", manageAccounts);
      accountMenu.append(element);
    }
    return [accountMenu];
  }
  var switchTo = mutex(async (username) => {
    const { storedPassword, requiresOtp } = accounts()[username];
    const logoutPromise = isLoggedIn() && ajax({ method: "POST", url: "/logout" });
    const password = storedPassword ? storedPassword : window.prompt(i18n("accountSwitcherPasswordPrompt", username));
    let otp;
    if (requiresOtp) {
      otp = {
        otp: window.prompt(i18n("accountSwitcherOptPrompt", username))
      };
    }
    await logoutPromise;
    const { success, jquery } = await ajax({
      method: "POST",
      url: "/api/login",
      data: {
        user: username,
        passwd: password,
        ...otp,
        rem: module15.options.keepLoggedIn.value ? "on" : "off"
      },
      type: "json"
    }).catch((e2) => {
      showNotification({
        moduleID: "accountSwitcher",
        message: i18n("accountSwitcherAccountSwitchError")
      });
      throw e2;
    });
    if (module15.options.updateOtherTabs.value) {
      switchedAccountElsewhere(success ? username : null);
    }
    if (success) {
      reloadPage();
    } else {
      const jqueryRpc = JSON.stringify(jquery);
      const message = jqueryRpc.includes("PASSWORD") && i18n("accountSwitcherLoginError", username) || jqueryRpc.includes("RATELIMIT") && i18n("accountSwitcherRateLimitError", username) || jqueryRpc.includes("WRONG_OTP") && i18n("accountSwitcherOTPError", username) || i18n("accountSwitcherUnknownError", username, jqueryRpc);
      alert_exports.open(message, { cancelable: true }).then(manageAccounts);
      throw new Error(message);
    }
  });
  var switchedAccountElsewhere = multicast((username) => {
    const hasDraft = Array.from(document.getElementsByTagName("textarea")).some((textarea) => textarea.value);
    if (!hasDraft && module15.options.reloadOtherTabs.value) {
      reloadPage();
      return;
    }
    let message = username ? i18n("accountSwitcherUserSwitched", username) : i18n("accountSwitcherLoggedOut");
    if (hasDraft) {
      message += ` ${i18n("accountSwitcherDraft", loggedInUser() || "")}`;
    }
    message += ` <p><a class="RESNotificationButtonBlue" href="${location.pathname}">${i18n("accountSwitcherReload")}</a></p>`;
    showNotification({
      moduleID: "accountSwitcher",
      optionKey: "updateOtherTabs",
      message
    });
  }, { name: "switchedAccountElsewhere", local: false, crossContext: false });
  function manageAccounts() {
    hover.close();
    open3(module15.moduleID, "accounts");
  }
  function reloadPage() {
    history.pushState({}, "");
    location.reload();
  }

  // lib/modules/submitIssue.js
  var import_jquery14 = __toESM(require_jquery(), 1);
  var module16 = new Module("submitIssue");
  module16.moduleName = "submitIssueName";
  module16.category = "aboutCategory";
  module16.alwaysEnabled = true;
  module16.sort = -7;
  module16.description = "submitIssueDesc";
  module16.include = ["submit"];
  var subreddits = ["enhancement", "resissues"];
  var subredditsForDiagnostics = ["beta", "help", "resbetatesting"];
  module16.go = () => {
    checkIfSubmitting();
  };
  var submitWizardTemplate = ({ foolin: foolin2, settings, bugs, requests }) => string_exports.html`
	<div>
		${foolin2 && string_exports._html`
			<h2>Enjoy April Fool's</h2>
			<p>RES can't turn off any of Reddit's shenanigans. However, <a href="/r/Enhancement/wiki/faq/srstyle" target="_blank" rel="noopener noreferer">you can turn off subreddit styles</a>.</p>
		`}

		<h2>Something is broken in RES. How do I fix it?</h2>

		<p>Take a minute to read through other posts. Someone might have already posted a solution.</p>

		<ol id="RESKnownBugs">
			${bugs.map(({ url, title }) => string_exports._html`
				<li>
					<a target="_blank" rel="noopener noreferer" href="${url}">${title}</a>
				</li>
			`)}
		</ol>

		<p><a href="/r/RESissues/submit/" class="blueButton">Ask how to fix RES</a></p>

		<p>Please write some text about:</p>
		<dl>

			<dt>What makes this happen?</dt>
			<dd>
				clicking a button, opening an image preview, ...
			</dd>


			<dt>Where does this happen?</dt>
			<dd>
				in a particular subreddit, on comments pages, on frontpage (reddit.com), on /r/all, ...
			</dd>

			<dt>Screenshot/video of problem</dt>
			<dd>
				<a href="https://www.take-a-screenshot.org/" target="_blank" rel="noreferer noopener">Take a screenshot</a>, <a href="https://imgur.com/upload">upload it</a>, and copy-paste the link here.
			</dd>
		</dl>


		<h2>How do I customize or use RES features?</h2>
		<p>If you want to disable certain features of RES, try searching in <a href="${settings}">RES settings</a>, your account's <a href="/prefs">reddit preferences</a>, or <a href="/r/Enhancement/search?q=restrict_sr=on">posts in r/Enhancement</a>.</p>

		<p><a href="/r/Enhancement/submit/" class="blueButton">Get guidance on using RES</a></p>


		<h2>I have a suggestion.</h2>

		<p>Look for similar ideas before posting:</p>
		<ol id="RESKnownFeatureRequests">
			${requests.map(({ url, title }) => string_exports._html`
				<li>
					<a target="_blank" rel="noopener noreferer" href="${url}">${title}</a>
				</li>
			`)}
		</ol>
		<p><a href="/r/Enhancement/submit/" class="blueButton">Post a request</a></p>


		<h2>I found a security issue.</h2>
		<p>Please report security issues privately using modmail.</p>
		<p><a href="/message/compose/?to=/r/Enhancement" class="blueButton">Report a security issue</a></p>
	</div>
`;
  var submitIssueDefaultBody = `
*What's up?*
???


*Where does it happen?*
???


*Screenshots or mock-ups*
???


*What browser extensions are installed?*
???
`.trim();
  var diagnostics = once_default(() => `

- Night mode: ${String(nightModeActive())}
- RES Version: ${version3}
- Browser: ${browserDetect_exports.browser}
- Browser Version: ${browserDetect_exports.version}
- Cookies Enabled: ${String(navigator.cookieEnabled)}
- Reddit beta: ${String((0, import_jquery14.default)(".beta-hint").length > 0)}

`);
  function checkIfSubmitting() {
    const subredditInput = document.getElementById("sr-autocomplete");
    const selfText = document.querySelector(".usertext-edit textarea");
    if (subredditInput) {
      let check2 = function() {
        const subreddit2 = subredditInput.value;
        if (subreddits.includes(subreddit2.toLowerCase())) {
          showWizard();
          injectTemplate(selfText);
        } else {
          if (hideWizard) hideWizard();
        }
      };
      check2();
      subredditInput.addEventListener("change", (e2) => {
        if (e2.res) return;
        check2();
      });
      (0, import_jquery14.default)("#suggested-reddits .sr-suggestion").on("click", () => setTimeout(check2, 500));
    }
    if (selfText && subredditInput) {
      (0, import_jquery14.default)(selfText).add(subredditInput).on("blur", () => {
        const subreddit2 = subredditInput.value;
        if ([...subreddits, ...subredditsForDiagnostics].includes(subreddit2.toLowerCase())) {
          const diagnosticsStripped = diagnostics().replace(/\s/g, "");
          const selfTextStripped = selfText.value.replace(/\s/g, "");
          if (!selfTextStripped.includes(diagnosticsStripped)) {
            selfText.value += diagnostics();
            (0, import_jquery14.default)(selfText).trigger("input");
          }
        } else {
          selfText.value = selfText.value.replace(diagnostics(), "");
          (0, import_jquery14.default)(selfText).trigger("input");
        }
      });
    }
  }
  function updateSubreddit(subreddit2) {
    const input2 = document.querySelector("#sr-autocomplete");
    input2.value = subreddit2;
    const e2 = new Event("change");
    e2.res = true;
    input2.dispatchEvent(e2);
  }
  function injectTemplate(selfText) {
    if (selfText && !selfText.value) {
      selfText.value = submitIssueDefaultBody;
    }
  }
  async function wizard() {
    const [bugs, requests] = await Promise.all([
      fetchLinks("/r/Enhancement/wiki/knownbugs.json"),
      fetchLinks("/r/Enhancement/wiki/knownrequests.json")
    ]);
    return submitWizardTemplate({
      foolin: foolin(),
      bugs,
      requests,
      settings: makeUrlHash()
    });
  }
  var guiderId = "RESSubmitWizard";
  var hideWizard;
  async function showWizard() {
    const { guiders: guiders2 } = (init_guiders(), __toCommonJS(guiders_exports));
    const guider = guiders2.get(guiderId);
    if (guider) {
      guiders2.show(guider.id);
      return;
    }
    const description = await wizard();
    const buttonCustomHTML = `
		<footer>
			<small>
				<a href="/r/RESissues/wiki/knownissues">known issues</a>
				|  <a href="/r/RESissues/wiki/postanissue">troubleshooting</a>
			</small>
		</footer>
	`;
    guiders2.createGuider({
      attachTo: ".submit .usertext",
      description,
      buttonCustomHTML,
      id: guiderId,
      // offset: { left: -200, top: 120 },
      position: 3,
      title: "What are you posting about?"
    }).show();
    hideWizard = () => guiders2.hideAll();
    (0, import_jquery14.default)(document.body).on("click", '#RESSubmitWizard a[href$="/submit/"]', (e2) => {
      const match = e2.currentTarget.pathname.match(regexes.submit);
      if (!match) return;
      updateSubreddit(match[1]);
      e2.preventDefault();
    });
  }
  async function fetchLinks(url) {
    try {
      const { data: data2 } = await ajax({ url, type: "json" });
      return parseObjectList(data2 && data2.content_md);
    } catch (e2) {
      return [];
    }
  }
  function parseObjectList(text) {
    if (!text) {
      return [];
    }
    const items2 = text.split(/\s*-{3,}\s*/).filter((x) => x.match(/[^\s\n]/));
    return items2.map((dictText) => {
      const item = {};
      const dictMapping = dictText.replace(/\r/g, "").split("\n");
      for (const rawLine of dictMapping) {
        const line = import_jquery14.default.trim(rawLine).split(":");
        if (line.length > 0) {
          const key = line.shift();
          if (key) {
            item[key] = line.join(":");
          }
        }
      }
      return item;
    });
  }
  function foolin() {
    const now4 = /* @__PURE__ */ new Date();
    return now4.getMonth() === 2 && now4.getDate() > 30 || now4.getMonth() === 3 && now4.getDate() <= 2;
  }

  // lib/modules/commentTools.js
  var module17 = new Module("commentTools");
  module17.moduleName = "commentToolsName";
  module17.category = "commentsCategory";
  module17.description = "commentToolsDesc";
  module17.options = {
    userAutocomplete: {
      type: "boolean",
      value: true,
      description: "commentToolsUserAutoCompleteDesc",
      title: "commentToolsUserAutoCompleteTitle",
      keywords: ["autosuggest"],
      advanced: true
    },
    subredditAutocomplete: {
      type: "boolean",
      value: true,
      description: "commentToolsSubredditAutocompleteDesc",
      title: "commentToolsSubredditAutocompleteTitle",
      keywords: ["autosuggest"],
      advanced: true
    },
    wikiAutocomplete: {
      type: "boolean",
      value: true,
      description: "commentToolsWikiAutocompleteDesc",
      title: "commentToolsWikiAutocompleteTitle",
      advanced: true
    },
    formattingToolButtons: {
      type: "boolean",
      value: true,
      description: "commentToolsFormattingToolButtonsDesc",
      title: "commentToolsFormattingToolButtonsTitle"
    },
    keyboardShortcuts: {
      dependsOn: (options6) => options6.formattingToolButtons.value,
      type: "boolean",
      value: true,
      description: "commentToolsKeyboardShortcutsDesc",
      title: "commentToolsKeyboardShortcutsTitle"
    },
    boldKey: {
      dependsOn: (options6) => options6.keyboardShortcuts.value,
      type: "keycode",
      value: [66, false, true, false, false],
      // ctrl-b
      description: "commentToolsBoldKeyDesc",
      title: "commentToolsBoldKeyTitle"
    },
    italicKey: {
      dependsOn: (options6) => options6.keyboardShortcuts.value,
      type: "keycode",
      value: [73, false, true, false, false],
      // ctrl-i
      description: "commentToolsItalicKeyDesc",
      title: "commentToolsItalicKeyTitle"
    },
    strikeKey: {
      dependsOn: (options6) => options6.keyboardShortcuts.value,
      type: "keycode",
      value: [83, false, true, false, false],
      // ctrl-s
      description: "commentToolsStrikeKeyDesc",
      title: "commentToolsStrikeKeyTitle"
    },
    superKey: {
      dependsOn: (options6) => options6.keyboardShortcuts.value,
      type: "keycode",
      value: [187, false, true, true, false],
      // ctrl-+ (ctrl-shift-=)
      description: "commentToolsSuperKeyDesc",
      title: "commentToolsSuperKeyTitle"
    },
    linkKey: {
      dependsOn: (options6) => options6.keyboardShortcuts.value,
      type: "keycode",
      value: [75, false, true, false, false],
      // ctrl-k
      description: "commentToolsLinkKeyDesc",
      title: "commentToolsLinkKeyTitle"
    },
    quoteKey: {
      dependsOn: (options6) => options6.keyboardShortcuts.value,
      type: "keycode",
      value: [190, false, true, true, false],
      // ctrl-> (strl-shift-.)
      description: "commentToolsQuoteKeyDesc",
      title: "commentToolsQuoteKeyTitle"
    },
    ctrlEnterSubmitsComments: {
      type: "boolean",
      value: true,
      description: "commentToolsCtrlEnterSubmitsCommentsDesc",
      title: "commentToolsCtrlEnterSubmitsCommentsTitle"
    },
    ctrlEnterSavesLiveThreads: {
      type: "boolean",
      value: true,
      description: "commentToolsCtrlEnterSavesLiveThreadsDesc",
      title: "commentToolsCtrlEnterSavesLiveThreadsTitle"
    },
    ctrlEnterSubmitsPosts: {
      type: "boolean",
      value: true,
      description: "commentToolsCtrolEnterSubmitsPostsDesc",
      title: "commentToolsCtrolEnterSubmitsPostsTitle"
    },
    commentingAs: {
      type: "boolean",
      value: true,
      description: "commentToolsCommentingAsDesc",
      title: "commentToolsCommentingAsTitle"
    },
    highlightIfAltAccount: {
      dependsOn: (options6) => options6.commentingAs.value,
      type: "boolean",
      value: true,
      description: "commentToolsHighlightIfAltAccountDesc",
      title: "commentToolsHighlightIfAltAccountTitle"
    },
    showInputLength: {
      type: "boolean",
      value: true,
      description: "commentToolsShowInputLengthDesc",
      title: "commentToolsShowInputLengthTitle",
      advanced: true,
      bodyClass: true
    },
    macroButtons: {
      type: "boolean",
      value: true,
      description: "commentToolsMacroButtonsDesc",
      title: "commentToolsMacroButtonsTitle",
      bodyClass: true
    },
    macros: {
      dependsOn: (options6) => options6.macroButtons.value,
      type: "table",
      addRowText: "commentToolsAddShortcut",
      fields: [{
        key: "label",
        name: "commentToolsLabel",
        type: "text"
      }, {
        key: "text",
        name: "commentToolsText",
        type: "textarea"
      }, {
        key: "category",
        name: "commentToolsCategory",
        type: "text"
      }, {
        key: "key",
        name: "commentToolsKey",
        type: "keycode"
      }],
      value: [
        ["reddiquette", "[reddiquette](https://support.reddithelp.com/hc/articles/205926439-Reddiquette) ", void 0, void 0],
        ["Promote RES", '[Reddit Enhancement Suite](https://redditenhancementsuite.com "also /r/Enhancement") ', void 0, void 0],
        ["Current timestamp", "{{now}} ", void 0, void 0]
      ],
      description: "commentToolsMacrosDesc",
      title: "commentToolsMacrosTitle"
    },
    keepMacroListOpen: {
      dependsOn: (options6) => options6.macroButtons.value,
      type: "boolean",
      value: false,
      description: "commentToolsKeepMacroListOpenDesc",
      title: "commentToolsKeepMacroListOpenTitle",
      advanced: true
    },
    macroPlaceholders: {
      dependsOn: (options6) => options6.macroButtons.value,
      type: "boolean",
      value: true,
      description: "commentToolsMacroPlaceholdersDesc",
      title: "commentToolsMacroPlaceholdersTitle"
    },
    enabledOnBanMessages: {
      type: "boolean",
      value: true,
      description: "commentToolsEnableOnBanMessagesDesc",
      title: "commentToolsEnableOnBanMessagesTitle",
      advanced: true
    }
  };
  module17.include = [
    "comments",
    "inbox",
    "submit",
    "profile",
    "modqueue",
    "subredditAbout",
    "liveThread",
    /^\/r\/[\-\w\.]+\/wiki\/(?:create|edit)(\/\w+)?/i
  ];
  var SUBMIT_LIMITS = {
    STYLESHEET: 128 * 1024,
    SIDEBAR: 10240,
    DESCRIPTION: 500,
    WIKI: 512 * 1024,
    COMMENT: 1e4,
    LIVE_COMMENT: 4096,
    POST: 4e4,
    POST_TITLE: 300,
    BAN_MESSAGE: 1e3
  };
  var macroCallbackTable = [];
  var macroKeyTable = [];
  module17.contentStart = () => {
    (0, import_jquery15.default)(document.body).on("focus", commentTextareaSelector, attachEditorToUsertext);
    initializeCtrlEnterToSubmit();
    initializeLengthCounters();
    initializeAutocomplete();
  };
  function initializeCtrlEnterToSubmit() {
    if (module17.options.ctrlEnterSubmitsComments.value) {
      onCtrlEnter(
        ".usertext-edit textarea, #BigEditor textarea, #wiki_page_content",
        (e2) => {
          const currentForm = (0, import_jquery15.default)(e2.currentTarget).closest("form");
          const saveButton = currentForm.find(".save")[0] || currentForm.find("#wiki_save_button")[0] || (0, import_jquery15.default)(".BEFoot button")[0];
          if (saveButton) click(saveButton);
        }
      );
    }
    if (module17.options.ctrlEnterSavesLiveThreads.value) {
      onCtrlEnter(
        ".usertext-edit textarea",
        () => {
          const saveButton = (0, import_jquery15.default)("#new-update-form .save-button button")[0];
          if (saveButton) click(saveButton);
        }
      );
    }
    if (module17.options.ctrlEnterSubmitsPosts.value) {
      onCtrlEnter(
        "#title-field textarea, #text-field textarea, #url, #sr-autocomplete, input.captcha",
        () => {
          const $captcha = (0, import_jquery15.default)("input.captcha:not(.cap-text)");
          if ($captcha.length && $captcha.val() === "") {
            $captcha.focus();
          } else {
            click((0, import_jquery15.default)(".spacer .btn")[0]);
          }
        }
      );
    }
  }
  function initializeLengthCounters() {
    if (module17.options.showInputLength.value) {
      (0, import_jquery15.default)(document.body).on("input", ".usertext-edit textarea, #title-field textarea, #BigEditor textarea, #wiki_page_content, #ban_message", function() {
        updateCounter(this);
      });
      (0, import_jquery15.default)(".submit-page #title-field span.title").prepend('<span class="RESCharCounter" title="character limit: 0/300">0/300</span>');
    }
  }
  var initializeEditorTools = once_default(() => {
    (0, import_jquery15.default)(document.body).on("click", "div.markdownEditor-wrapper a:not(.userTagLink)", function(e2) {
      e2.preventDefault();
      const index2 = parseInt((0, import_jquery15.default)(this).attr("data-macro-index"), 10);
      const box = findTextareaForElement(this);
      if (!box) {
        console.error("Failed to locate textarea.");
        return;
      }
      const handler = macroCallbackTable[index2];
      if (!handler) {
        throw new Error(`No macro callback at index: ${index2}.`);
      }
      handler(box);
      box.focus();
      box.dispatchEvent(new Event("input", { bubbles: true, cancelable: true }));
    }).on("click", ".RESMacroDropdownTitle", function(e2) {
      const thisCat = e2.currentTarget;
      if (thisCat.classList.contains("openMacro")) {
        thisCat.classList.remove("openMacro");
      } else {
        (0, import_jquery15.default)(".RESMacroWrappingSpan span").removeClass("openMacro");
        thisCat.classList.add("openMacro");
      }
      (0, import_jquery15.default)(this).next().css({
        top: `${thisCat.offsetTop + thisCat.offsetHeight}px`,
        left: `${thisCat.offsetLeft + thisCat.offsetWidth - thisCat.nextSibling.offsetWidth}px`
      });
    });
    if (module17.options.keyboardShortcuts.value) {
      (0, import_jquery15.default)(document.body).on("keydown", ".usertext-edit textarea, #BigEditor textarea, #wiki_page_content, #ban_message", function(e2) {
        if (e2.key === NAMED_KEYS.Escape) {
          this.blur();
          e2.preventDefault();
          return;
        }
        for (const [testedKeyArray, macroIndex] of macroKeyTable) {
          if (checkKeysForEvent(e2, testedKeyArray)) {
            const handler = macroCallbackTable[macroIndex];
            handler(this);
            this.dispatchEvent(new Event("input", { bubbles: true, cancelable: true }));
            e2.preventDefault();
            return;
          }
        }
      });
    }
  });
  var commentTextareaSelector = [
    "textarea[name=text]",
    "textarea[name=description]",
    "textarea[name=public_description]",
    "textarea[name=body]",
    "textarea[name=ban_message]",
    "textarea[name=content]",
    "textarea[name=title]"
  ].join(":not([readonly]),");
  function getFieldLimit(elem) {
    switch (elem.name) {
      case "title":
        return SUBMIT_LIMITS.POST_TITLE;
      case "text":
        if (isPageType("submit") || (0, import_jquery15.default)(elem).closest(".thing").hasClass("self")) {
          return SUBMIT_LIMITS.POST;
        }
        return SUBMIT_LIMITS.COMMENT;
      case "description":
        return SUBMIT_LIMITS.SIDEBAR;
      case "body":
        return SUBMIT_LIMITS.LIVE_COMMENT;
      case "public_description":
        return SUBMIT_LIMITS.DESCRIPTION;
      case "content":
        return SUBMIT_LIMITS.WIKI;
      case "ban_message":
        return SUBMIT_LIMITS.BAN_MESSAGE;
      // case 'description_conflict_old':
      // case 'public_description_conflict_old':
      default:
        return 1337;
    }
  }
  function attachEditorToUsertext() {
    if (this.hasAttribute("commentTools-initialized")) return;
    this.setAttribute("commentTools-initialized", true);
    if (this.hasAttribute("data-max-length")) {
      return;
    }
    const limit = getFieldLimit(this);
    this.setAttribute("data-limit", limit);
    if (this.name === "title") {
      return;
    }
    if (this.id === "ban_message" && !module17.options.enabledOnBanMessages.value) {
      return;
    }
    if (this.id === "ban_message") {
      this.style.width = "500px";
      this.style.height = "100px";
    }
    const bar = makeEditBar();
    if (this.id === "wiki_page_content" || this.id === "ban_message") {
      (0, import_jquery15.default)(this).parent().prepend(bar);
    } else {
      (0, import_jquery15.default)(this).parent().before(bar);
    }
    updateCounter(this);
  }
  function updateCounter(textarea) {
    const length = (0, import_jquery15.default)(textarea).val().length;
    const limit = textarea.getAttribute("data-limit");
    const counter2 = (0, import_jquery15.default)(textarea).parent().parent().find(".RESCharCounter");
    counter2.attr("title", `character limit: ${length}/${limit}`);
    counter2.text(`${length}/${limit}`);
    if (length > limit) {
      counter2.addClass("tooLong");
    } else {
      counter2.removeClass("tooLong");
    }
  }
  var cachedEditBar;
  function makeEditBar() {
    initializeEditorTools();
    if (cachedEditBar) {
      return (0, import_jquery15.default)(cachedEditBar).clone();
    }
    const $editBar = (0, import_jquery15.default)('<div class="markdownEditor">');
    const wrappedEditBar = (0, import_jquery15.default)('<div class="markdownEditor-wrapper">').append($editBar);
    if (module17.options.commentingAs.value) {
      const commentingAsMessage = location.href.match(/^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/about\/banned\/?/i) ? "Moderating as" : "Speaking as";
      const commentingAs = (0, import_jquery15.default)('<div class="commentingAs">').html(`${commentingAsMessage}: `).append(
        (0, import_jquery15.default)("#header-bottom-right .user a:first").clone().wrap('<span class="commentingAsUser"></span>').parent()
      );
      const loggedIn = loggedInUser();
      if (loggedIn && isRunning(userTagger_exports)) {
        applyToUser(commentingAs.find("a")[0], { username: loggedIn, renderVoteWeight: false });
      }
      if (module17.options.highlightIfAltAccount.value && module15.options.accounts.value.length && loggedIn && loggedIn.toLowerCase() !== module15.options.accounts.value[0][0].toLowerCase()) {
        commentingAs.addClass("highlightedAltAccount");
      }
      wrappedEditBar.append(commentingAs);
    }
    if (module17.options.formattingToolButtons.value) {
      const shortcuts = module17.options.keyboardShortcuts.value;
      $editBar.append(makeEditButton("<b>Bold</b>", `bold${shortcuts ? ` (${niceKeyCode(module17.options.boldKey.value)})` : ""}`, module17.options.boldKey.value, "btn-bold", (box) => {
        wrapSelection(box, "**", "**");
      }));
      $editBar.append(makeEditButton("<i>Italic</i>", `italic${shortcuts ? ` (${niceKeyCode(module17.options.italicKey.value)})` : ""}`, module17.options.italicKey.value, "btn-italic", (box) => {
        wrapSelection(box, "*", "*");
      }));
      $editBar.append(makeEditButton("<del>strike</del>", `strike${shortcuts ? ` (${niceKeyCode(module17.options.strikeKey.value)})` : ""}`, module17.options.strikeKey.value, "btn-strike", (box) => {
        wrapSelection(box, "~~", "~~");
      }));
      $editBar.append(makeEditButton("<sup>sup</sup>", `super${shortcuts ? ` (${niceKeyCode(module17.options.superKey.value)})` : ""}`, module17.options.superKey.value, "btn-superscript", (box) => {
        wrapSelectedWords(box, "^");
      }));
      $editBar.append(makeEditButton("Link", `link${shortcuts ? ` (${niceKeyCode(module17.options.linkKey.value)})` : ""}`, module17.options.linkKey.value, "btn-link", (box) => {
        linkSelection(box);
      }));
      $editBar.append(makeEditButton(">Quote", `quote${shortcuts ? ` (${niceKeyCode(module17.options.quoteKey.value)})` : ""}`, module17.options.quoteKey.value, "btn-quote", (box) => {
        wrapSelectedLines(box, "> ", "");
      }));
      $editBar.append(makeEditButton('<span style="font-family: monospace">Code</span>', "code", null, "btn-code", (box) => {
        wrapSelectedLines(box, "    ", "");
      }));
      $editBar.append(makeEditButton("&bull;Bullets", "bullet list", null, "btn-list-unordered", (box) => {
        wrapSelectedLines(box, "* ", "");
      }));
      $editBar.append(makeEditButton("1.Numbers", "number list", null, "btn-list-ordered", (box) => {
        wrapSelectedLines(box, "1. ", "");
      }));
      $editBar.append(makeEditButton('<span style="border: 1px black solid;">Table</span>', "table", null, "btn-table", (box) => {
        const selectedText = box.value.substring(box.selectionStart, box.selectionEnd).replace(/^[\s]+/, "").replace(/[\s]+$/, "").split("\n");
        let isTable;
        if (selectedText.length >= 2) {
          if (selectedText[0].includes("|")) {
            selectedText[0] = selectedText[0].replace(/^\|/, "").replace(/\|\s+$/, "");
            const numSeparator = selectedText[0].split("|").length;
            isTable = true;
            selectedText[1] = selectedText[1].replace(/\|[^|\-]+$/, "");
            selectedText[1] = selectedText[1].replace(/-/g, "--");
            if (!selectedText[1].includes("-|") && !selectedText[1].includes("|-")) {
              isTable = false;
            }
            selectedText[1] = selectedText[1].replace(/^\]+/, "").replace(/[\s|]+$/, "");
            if (selectedText[1].split("-|-").length < numSeparator) {
              isTable = false;
            }
            if (/[^|\-]/.test(selectedText[1])) {
              isTable = false;
            }
            if (isTable) {
              for (const i2 of range(2, selectedText.length)) {
                if (!selectedText[i2].includes("|")) {
                  isTable = false;
                  break;
                }
                selectedText[i2] = selectedText[i2].replace(/^\|/, "").replace(/[\s|]+$/, "");
                if (selectedText[i2].split("|").length !== numSeparator) {
                  isTable = false;
                  break;
                }
              }
            }
          }
        }
        let startTable;
        if (isTable) {
          startTable = selectedText.reduce((prevTable, currText, i2) => {
            if (i2 === 1) {
              return prevTable;
            }
            return `${prevTable}<tr><td>${escapeHTML(currText).replace(/\|/g, "</td><td>")}</td></tr>`;
          }, "");
        } else {
          startTable = "<tr><td>Foo</td><td>Bar</td></tr><tr><td>Foo</td><td>Bar</td></tr>";
        }
        const element = string_exports.html`<div><div class="buttonContainer"></div><table class="commentPreview" contenteditable="true">${string_exports.safe(startTable)}</table></div>`;
        alert_exports.open(element, { cancelable: true }).then(() => {
          let generatedTable = "\n\n";
          let generatedTableSeparation = "";
          (0, import_jquery15.default)("tr:first td", element).each(function() {
            const text = (0, import_jquery15.default)(this).text().replace(/[\n|]/g, "");
            generatedTable += `${text} | `;
            generatedTableSeparation += "-".repeat(text.length);
            generatedTableSeparation += "|";
          });
          generatedTableSeparation = generatedTableSeparation.substr(0, generatedTableSeparation.length - 1);
          generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}
${generatedTableSeparation}
`;
          (0, import_jquery15.default)("tr:gt(0)", element).each(function() {
            (0, import_jquery15.default)(this).find("td").each(function() {
              generatedTable += `${(0, import_jquery15.default)(this).text().replace(/[\n|]/g, "")} | `;
            });
            generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}
`;
          });
          if (isTable) {
            replaceSelection(box, generatedTable);
          } else {
            wrapSelection(box, generatedTable, "");
          }
          (0, import_jquery15.default)(box).trigger("input");
        });
        const addRow = alert_exports.makeButton("+ Row");
        const remRow = alert_exports.makeButton("- Row");
        const addCol = alert_exports.makeButton("+ Col");
        const remCol = alert_exports.makeButton("- Col");
        addRow.addEventListener("click", () => {
          const nbCol = (0, import_jquery15.default)("tr:first td", element).length;
          const newRow = "<td>text</td>".repeat(nbCol);
          (0, import_jquery15.default)("table", element).append(`<tr>${newRow}</tr>`);
        });
        remRow.addEventListener("click", () => {
          if ((0, import_jquery15.default)("tr", element).length > 1) {
            (0, import_jquery15.default)("table tr:last", element).remove();
          }
        });
        addCol.addEventListener("click", () => {
          (0, import_jquery15.default)("table tr", element).append("<td>text</td>");
        });
        remCol.addEventListener("click", () => {
          if ((0, import_jquery15.default)("tr:first td", element).length > 1) {
            (0, import_jquery15.default)("table tr td:last-of-type", element).remove();
          }
        });
        const $buttonContainer = (0, import_jquery15.default)(".buttonContainer", element);
        $buttonContainer.append(addRow);
        $buttonContainer.append(remRow);
        $buttonContainer.append(addCol);
        $buttonContainer.append(remCol);
      }));
    }
    if (module17.options.showInputLength.value) {
      const $counter = (0, import_jquery15.default)('<span class="RESCharCounter" title="character limit: 0/?????">0/?????</span>');
      $editBar.prepend($counter);
    }
    if (module17.options.macroButtons.value) {
      buildMacroDropdowns(wrappedEditBar);
      const addMacroButton = makeEditButton(i18n(module17.options.macros.addRowText), null, null, "btn-macro btn-macro-add", () => {
        open3(module17.moduleID, "macros");
        (0, import_jquery15.default)(".RESMacroWrappingSpan span").removeClass("openMacro");
      });
      addButtonToMacroGroup("", addMacroButton);
    }
    cachedEditBar = wrappedEditBar;
    return cachedEditBar;
  }
  var macroDropDownTable = /* @__PURE__ */ new Map();
  function getMacroGroup(groupName) {
    groupName = (groupName || "").toString().trim() || "macros";
    let macroGroup = macroDropDownTable.get(groupName);
    if (macroGroup === void 0) {
      macroGroup = {};
      macroGroup.titleButton = (0, import_jquery15.default)(`<span class="RESMacroDropdownTitle">${groupName}</span>`);
      macroGroup.container = (0, import_jquery15.default)('<span class="RESMacroDropdown"></span>');
      macroGroup.dropdown = (0, import_jquery15.default)('<ul class="RESMacroDropdownList"></ul>');
      macroGroup.container.append(macroGroup.dropdown);
      macroDropDownTable.set(groupName, macroGroup);
    }
    return macroGroup;
  }
  function addButtonToMacroGroup(groupName, button) {
    const group = getMacroGroup(groupName);
    group.dropdown.append((0, import_jquery15.default)("<li>").append(button));
  }
  function getDebugMacros() {
    if (!isCurrentSubreddit("Enhancement", "RESissues")) return [];
    return [
      ["RES modified settings", "\n\n{{resmodifiedsettings}}\n", null, null],
      ["RES diagnostics", "{{resdiagnostics}}", null, null]
    ];
  }
  function buildMacroDropdowns(editBar) {
    const macros = [...module17.options.macros.value, ...getDebugMacros()];
    for (const [title, text, category, key] of macros) {
      const button = makeEditButton(title, null, key, "btn-macro", (box) => {
        macroSelection(box, text);
      });
      addButtonToMacroGroup(category, button);
    }
    const $macroWrapper = (0, import_jquery15.default)('<span class="RESMacroWrappingSpan">');
    const defaultGroup = getMacroGroup("");
    $macroWrapper.append(defaultGroup.titleButton);
    $macroWrapper.append(defaultGroup.container);
    for (const [category, macroGroup] of macroDropDownTable) {
      if (category === "macros") {
        continue;
      }
      $macroWrapper.append(macroGroup.titleButton);
      $macroWrapper.append(macroGroup.container);
    }
    editBar.append($macroWrapper);
  }
  function makeEditButton(label, title, key, cls, handler) {
    if (label === null) {
      label = "unlabeled";
    }
    if (title === null) {
      title = "";
    }
    const macroButtonIndex = macroCallbackTable.length;
    const button = string_exports.html`<a class="edit-btn ${cls}" title="${title}" href="#" tabindex="1" data-macro-index="${macroButtonIndex}">${label}</a>`;
    if (key && key[0] !== null) {
      macroKeyTable.push([key, macroButtonIndex]);
    }
    macroCallbackTable[macroButtonIndex] = handler;
    return button;
  }
  function linkSelection(box) {
    let url = prompt("Enter the URL:", "");
    if (url) {
      url = url.replace(/[\(\)]/g, "\\$&");
      wrapSelection(box, "[", `](${url})`, (text) => text.replace(/[\[\]\(\)]/g, "\\$&"));
    }
  }
  function macroSelection(box, macroText) {
    if (!module17.options.keepMacroListOpen.value) {
      (0, import_jquery15.default)(".RESMacroWrappingSpan span").removeClass("openMacro");
    }
    if (module17.options.macroPlaceholders.value) {
      const formatText = (selectedText) => fillPlaceholders(box, macroText, selectedText);
      wrapSelection(box, "", "", formatText);
    } else {
      wrapSelection(box, macroText, "");
    }
  }
  function fillPlaceholders(box, macroText, selectedText) {
    const placeholders = macroText.match(/\{\{\w+\}\}/g);
    if (placeholders) {
      const completedPlaceholders = /* @__PURE__ */ new Set();
      for (const placeholder of placeholders) {
        if (completedPlaceholders.has(placeholder)) {
          continue;
        }
        completedPlaceholders.add(placeholder);
        const placeholderInnerText = placeholder.substring(2, placeholder.length - 2).toLowerCase();
        let value;
        try {
          value = getMagicPlaceholderValue(placeholderInnerText, macroText, selectedText, box);
        } catch (e2) {
          console.error("Error getting magic placeholder value", placeholderInnerText);
          console.error(e2);
        }
        if (value === void 0) {
          value = promptForPlaceholderValue(placeholder, macroText);
        }
        if (value === null) {
          break;
        }
        macroText = macroText.replace(new RegExp(placeholder, "g"), value);
      }
    }
    return macroText;
  }
  function getMagicPlaceholderValue(placeholder, macroText, selectedText, box) {
    const handler = magicPlaceholders.find((current2) => current2.matches.includes(placeholder));
    if (handler) {
      return handler.handle(macroText, selectedText, box);
    }
  }
  var magicPlaceholders = [
    {
      matches: ["subreddit"],
      handle(macroText, selectedText, box) {
        const thing = Thing.from(box);
        const subreddit2 = thing && thing.getSubreddit();
        if (subreddit2) {
          return `/r/${subreddit2}`;
        }
      }
    },
    {
      matches: ["me", "my_username"],
      handle() {
        const username = loggedInUser();
        if (username) {
          return `/u/${username}`;
        }
      }
    },
    {
      matches: ["op", "op_username"],
      handle(macroText, selectedText, box) {
        let profile;
        if (isPageType("comments")) {
          profile = document.querySelector(".sitetable .author");
        } else {
          let $next = (0, import_jquery15.default)(box);
          let furthest = $next;
          do {
            if ($next && $next.length) furthest = $next;
            $next = $next.parent().closest(".sitetable");
          } while ($next.length);
          profile = furthest.find(".author")[0];
        }
        if (profile) {
          const match = profile.pathname.match(regexes.profile);
          if (!match) throw new Error(`Invalid profile link: ${profile.href}`);
          return `/u/${match[1]}`;
        }
      }
    },
    {
      matches: ["url"],
      handle() {
        return location.href;
      }
    },
    {
      matches: ["reply_to", "reply_to_username"],
      handle(macroText, selectedText, box) {
        let $base = (0, import_jquery15.default)(box);
        const isEditing = $base.closest(".thing, .entry").hasClass("entry");
        if (isEditing) {
          $base = $base.closest(".thing").parent();
        }
        const profile = $base.closest(".thing").find(".entry .author")[0];
        if (!profile) {
          return getMagicPlaceholderValue("op", macroText, selectedText, box);
        } else {
          const match = profile.pathname.match(regexes.profile);
          if (!match) throw new Error(`Invalid profile link: ${String(profile)}`);
          return `/u/${match[1]}`;
        }
      }
    },
    {
      matches: ["selected", "selection"],
      handle(macroText, selectedText) {
        return selectedText;
      }
    },
    {
      matches: ["now"],
      handle() {
        const date = /* @__PURE__ */ new Date();
        return date.toTimeString();
      }
    },
    {
      matches: ["today"],
      handle() {
        const date = /* @__PURE__ */ new Date();
        return date.toDateString();
      }
    },
    {
      matches: ["linkflair"],
      handle() {
        if (isPageType("comments")) {
          return document.querySelector(".linkflairlabel").textContent;
        }
      }
    },
    {
      matches: ["escaped"],
      handle(macroText, selectedText) {
        return selectedText.replace(/[\[\]()\\\*\^~\-_.]/g, "\\$&").replace(/^([ ]{0,3})>/gm, "$1\\>");
      }
    },
    {
      matches: ["resmodifiedsettings"],
      handle() {
        return getModifiedText();
      }
    },
    {
      matches: ["resdiagnostics"],
      handle() {
        return diagnostics();
      }
    }
  ];
  function promptForPlaceholderValue(placeholder, macroText) {
    const display = `${macroText}


Enter replacement for ${placeholder}:`;
    const value = placeholder;
    return prompt(display, value);
  }
  function wrapSelection(box, prefix, suffix, escapeFunction) {
    if (!box) {
      return;
    }
    const scrollTop = box.scrollTop;
    const selectionStart = box.selectionStart;
    const selectionEnd = box.selectionEnd;
    const text = box.value;
    const beforeSelection = text.substring(0, selectionStart);
    let selectedText = text.substring(selectionStart, selectionEnd);
    const afterSelection = text.substring(selectionEnd);
    let trailingSpace = "";
    let cursor = selectedText.length - 1;
    while (cursor > 0 && selectedText[cursor] === " ") {
      trailingSpace += " ";
      cursor--;
    }
    selectedText = selectedText.substring(0, cursor + 1);
    if (typeof escapeFunction === "function") {
      selectedText = escapeFunction(selectedText);
    }
    box.value = beforeSelection + prefix + selectedText + suffix + trailingSpace + afterSelection;
    box.selectionEnd = beforeSelection.length + prefix.length + selectedText.length;
    if (selectionStart === selectionEnd) {
      box.selectionStart = box.selectionEnd;
    } else {
      box.selectionStart = beforeSelection.length + prefix.length;
    }
    box.scrollTop = scrollTop;
  }
  function replaceSelection(box, replacement) {
    if (!box) {
      return;
    }
    const scrollTop = box.scrollTop;
    const selectionStart = box.selectionStart;
    const selectionEnd = box.selectionEnd;
    const text = box.value;
    const beforeSelection = text.substring(0, selectionStart);
    const afterSelection = text.substring(selectionEnd);
    box.value = beforeSelection + replacement + afterSelection;
    box.selectionEnd = beforeSelection.length + replacement.length;
    box.scrollTop = scrollTop;
  }
  function wrapSelectedLines(box, prefix, suffix) {
    const scrollTop = box.scrollTop;
    let selectionStart = box.selectionStart;
    let selectionEnd = box.selectionEnd;
    const text = box.value;
    let startPosition = 0;
    const lines = text.split("\n");
    for (const i2 of range(0, lines.length)) {
      let lineStart = startPosition;
      let lineEnd = lineStart + lines[i2].length;
      if (selectionStart <= lineStart && lineStart <= selectionEnd || selectionStart <= lineEnd && lineEnd <= selectionEnd || // Check if either end of the selection is within the line
      lineStart <= selectionStart && selectionStart <= lineEnd || lineStart <= selectionEnd && selectionEnd <= lineEnd) {
        lines[i2] = prefix + lines[i2] + suffix;
        let startMovement = 0;
        let endMovement = 0;
        if (lineStart < selectionStart) {
          startMovement += prefix.length;
        }
        if (lineEnd < selectionStart) {
          startMovement += suffix.length;
        }
        if (lineStart < selectionEnd) {
          endMovement += prefix.length;
        }
        if (lineEnd < selectionEnd) {
          endMovement += suffix.length;
        }
        selectionStart += startMovement;
        selectionEnd += endMovement;
        lineStart += prefix.length;
        lineEnd += prefix.length + suffix.length;
      }
      startPosition = lineEnd + 1;
    }
    box.value = lines.join("\n");
    box.selectionStart = selectionStart;
    box.selectionEnd = selectionEnd;
    box.scrollTop = scrollTop;
  }
  function wrapSelectedWords(box, prefix) {
    const scrollTop = box.scrollTop;
    let selectionStart = box.selectionStart;
    const selectionEnd = box.selectionEnd;
    const text = box.value;
    const beforeSelection = text.substring(0, selectionStart);
    const selectedWords = text.substring(selectionStart, selectionEnd).split(" ");
    const afterSelection = text.substring(selectionEnd);
    let selectionModify = 0;
    for (const i2 of range(0, selectedWords.length)) {
      if (selectedWords[i2] !== "") {
        if (selectedWords[i2].includes("\n")) {
          const newLinePosition = selectedWords[i2].lastIndexOf("\n") + 1;
          selectedWords[i2] = selectedWords[i2].substring(0, newLinePosition) + prefix + selectedWords[i2].substring(newLinePosition);
          selectionModify += prefix.length;
        }
        if (selectedWords[i2].charAt(0) !== "\n") {
          selectedWords[i2] = prefix + selectedWords[i2];
        }
        selectionModify += prefix.length;
      } else if (selectedWords[i2] === "" && selectedWords.length === 1) {
        selectedWords[i2] = prefix + selectedWords[i2];
        selectionModify += prefix.length;
        selectionStart += prefix.length;
      }
    }
    box.value = beforeSelection + selectedWords.join(" ") + afterSelection;
    box.selectionStart = selectionStart;
    box.selectionEnd = selectionEnd + selectionModify;
    box.scrollTop = scrollTop;
  }
  var autoCompleteMatchRegExp = /(^|\W)\/?(?:r\/([\w]+)\/)?(wiki|w|r|u)\/([-\w]+)$/;
  function initializeAutocomplete() {
    if (!module17.options.subredditAutocomplete.value && !module17.options.userAutocomplete.value && !module17.options.wikiAutocomplete.value) return;
    (0, import_jquery15.default)(document.body).on("input", ".usertext .usertext-edit textarea, #BigText, #wiki_page_content", debounce_default(async (e2) => {
      const textarea = e2.currentTarget;
      const prefixText = textarea.value.slice(0, textarea.selectionStart);
      const [, , subreddit2, [type] = [], query] = autoCompleteMatchRegExp.exec(prefixText) || [];
      const completions = query && (type === "u" && module17.options.userAutocomplete.value && await getUserCompletions(query) || type === "r" && module17.options.subredditAutocomplete.value && await getSubredditCompletions(query) || type === "w" && module17.options.wikiAutocomplete.value && await getWikiCompletions(query, subreddit2 || currentSubreddit() || "")) || [];
      autoComplete(textarea)(completions);
    }, 100));
  }
  var autoComplete = memoize_default((textarea) => {
    const element = string_exports.html`<div id="autocomplete_dropdown" class="drop-choices srdrop"></div>`;
    let entries = [];
    let index2 = 0;
    element.addEventListener("click", (e2) => {
      const text = (e2.target.closest(".choice") || e2.target).textContent;
      const caretPos = textarea.selectionStart;
      let left = textarea.value.substr(0, caretPos);
      const right = textarea.value.substr(caretPos);
      left = left.replace(autoCompleteMatchRegExp, `$1${text} `);
      textarea.value = left + right;
      textarea.selectionStart = textarea.selectionEnd = left.length;
      textarea.focus();
      textarea.dispatchEvent(new Event("input", { bubbles: true, cancelable: true }));
    });
    const updateSelection = () => {
      for (const entry of entries) entry.classList.remove("selectedItem");
      entries[index2 % entries.length].classList.add("selectedItem");
    };
    const remove3 = () => {
      element.remove();
      textarea.removeEventListener("keydown", navigate);
      textarea.removeEventListener("blur", remove3);
    };
    const navigate = (e2) => {
      if (e2.metaKey || e2.shiftKey || e2.ctrlKey || e2.altKey) return;
      if (!document.contains(element)) return;
      switch (e2.key) {
        case NAMED_KEYS.Down:
        case NAMED_KEYS.Right:
          e2.preventDefault();
          index2++;
          updateSelection();
          return;
        case NAMED_KEYS.Up:
        case NAMED_KEYS.Left:
          e2.preventDefault();
          index2--;
          updateSelection();
          return;
        case NAMED_KEYS.Tab:
        case NAMED_KEYS.Enter:
          e2.preventDefault();
          entries[index2 % entries.length].click();
          return;
        case NAMED_KEYS.Escape:
          e2.preventDefault();
          e2.stopImmediatePropagation();
          remove3();
          break;
        default:
          break;
      }
    };
    return (matches2) => {
      if (!matches2.length || document.activeElement !== textarea) {
        remove3();
        return;
      }
      empty(element);
      entries = matches2.slice(0, 20).map((text) => string_exports.html`<a class="choice">${text}</a>`);
      element.append(...entries);
      index2 = 0;
      updateSelection();
      if (!document.contains(element)) {
        const textareaOffset = (0, import_jquery15.default)(textarea).offset();
        textareaOffset.left += (0, import_jquery15.default)(textarea).width();
        (0, import_jquery15.default)(element).css(textareaOffset);
        document.body.append(element);
        textarea.addEventListener("keydown", navigate);
        textarea.addEventListener("blur", () => {
          setTimeout(() => {
            if (document.activeElement !== textarea) remove3();
          }, 200);
        });
      }
    };
  });
  async function getSubredditCompletions(query) {
    const { names: names2 } = await ajax({
      method: "POST",
      url: "/api/search_reddit_names.json",
      query: { query },
      // for the cache
      data: { query },
      type: "json",
      cacheFor: DAY
    });
    return names2.map((name2) => `/r/${name2}`);
  }
  var loadAllTags = once_default(() => Tag.getStored());
  async function getUserCompletions(query) {
    await loadAllTags();
    return Array.from(tags.values()).filter(({ id: id2 }) => id2.toLowerCase().startsWith(query.toLowerCase())).filter(({ text, votesUp, instances: instances2 }) => text || votesUp || instances2.length).sort((a2, b2) => Number(b2.instances.length > a2.instances.length) || a2.id.localeCompare(b2.id)).map(({ id: id2 }) => `/u/${id2}`);
  }
  async function getWikiCompletions(query, subreddit2) {
    const { data: wikiPages } = await ajax({
      method: "GET",
      url: `/r/${subreddit2}/wiki/pages.json`,
      type: "json",
      cacheFor: DAY
    });
    return wikiPages.filter((wikiPage) => wikiPage.toLowerCase().startsWith(query.toLowerCase())).map((wikiPage) => `/r/${subreddit2}/wiki/${wikiPage}`);
  }
  function findTextareaForElement(elem) {
    const textarea = (0, import_jquery15.default)(elem).closest(".usertext-edit, #BigEditor, .wiki-page-content, #banned").find("textarea").filter("#BigText, [name=text], [name=description], [name=public_description], [name=body], #wiki_page_content, #ban_message").get(0);
    return textarea;
  }
  function onCtrlEnter(selector, callback) {
    (0, import_jquery15.default)(document.body).on("keydown", selector, (e2) => {
      if (e2.key === NAMED_KEYS.Enter && (e2.ctrlKey || e2.metaKey)) {
        e2.preventDefault();
        callback(e2);
      }
    });
  }

  // lib/modules/usernameHider.js
  var usernameHider_exports = {};
  __export(usernameHider_exports, {
    getDisplayText: () => getDisplayText,
    module: () => module18
  });
  var import_jquery16 = __toESM(require_jquery(), 1);
  var module18 = new Module("usernameHider");
  module18.moduleName = "usernameHiderName";
  module18.category = "myAccountCategory";
  module18.disabledByDefault = true;
  module18.description = "usernameHiderDesc";
  module18.options = {
    displayText: {
      title: "usernameHiderDisplayTextTitle",
      type: "text",
      value: "~anonymous~",
      description: "usernameHiderDisplayTextDesc"
    },
    perAccountDisplayText: {
      title: "usernameHiderPerAccountDisplayTextTitle",
      type: "table",
      addRowText: "+add account",
      fields: [{
        key: "username",
        name: "username",
        type: "text"
      }, {
        key: "displayText",
        name: "displayText",
        type: "text"
      }],
      value: [],
      description: "usernameHiderPerAccountDisplayTextDesc"
    },
    hideAllUsernames: {
      title: "usernameHiderHideAllUsernamesTitle",
      advanced: true,
      type: "boolean",
      value: true,
      description: "usernameHiderHideAllUsernamesDesc"
    },
    hideAccountSwitcherUsernames: {
      title: "usernameHiderHideAccountSwitcherUsernamesTitle",
      advanced: true,
      type: "boolean",
      value: true,
      description: "usernameHiderHideAccountSwitcherUsernamesDesc"
    },
    showUsernameOnHover: {
      title: "usernameHiderShowUsernameOnHoverTitle",
      type: "boolean",
      value: false,
      description: "usernameHiderShowUsernameOnHoverDesc"
    }
  };
  var substitutes = once_default(() => new Map([
    [(loggedInUser() || "").toLowerCase(), module18.options.displayText.value],
    ...module18.options.perAccountDisplayText.value.map(([username, substitute]) => [username.toLowerCase(), substitute])
  ]));
  var getDisplayText = (username, alt = username) => substitutes().get(username.toLowerCase()) || alt;
  module18.contentStart = () => {
    for (const username of new Set([
      loggedInUser(),
      ...module18.options.hideAllUsernames.value ? module18.options.perAccountDisplayText.value.map(([username2]) => username2) : [],
      ...module18.options.hideAccountSwitcherUsernames.value ? module15.options.accounts.value.map(([username2]) => username2) : []
    ].filter(Boolean)).values()) {
      hideUsername(username, getDisplayText(username, module18.options.displayText.value));
    }
  };
  function hideUsername(user, displayText) {
    if (!displayText || user === displayText) return;
    const userHref = `[href*="/user/${user}"]`;
    addCSS(`
		p.tagline > a${userHref},
		#header .user > a${userHref},
		.titlebox .tagline a.author${userHref},
		.commentingAsUser a${userHref},
		a.author${userHref},
		.bottom a${userHref} {
			line-height: 0;
			font-size: 0;
		}

		p.tagline > a${userHref}::after,
		#header .user > a${userHref}::after,
		.titlebox .tagline a.author${userHref}::after,
		.commentingAsUser a${userHref}::after,
		a.author${userHref}::after,
		.bottom a${userHref}::after {
			content: "${displayText}";
			letter-spacing: normal;
			font-size: 10px;
			background-color: inherit;
			border-radius: inherit;
			padding: inherit;
		}

		a.author${userHref}::after {
			margin-right: 0.5em;
		}

		.commentingAsUser a${userHref}::after {
			font-size: small;
		}
	`);
    if (module18.options.showUsernameOnHover.value) {
      addCSS(`
			p.tagline > a${userHref}:hover,
			#header .user > a${userHref}:hover,
			.titlebox .tagline a.author${userHref}:hover,
			.commentingAsUser a${userHref}:hover,
			a.author${userHref}:hover,
			.bottom a${userHref}:hover {
				line-height: inherit;
				font-size: inherit;
			}

			p.tagline > a${userHref}:hover::after,
			#header .user > a${userHref}:hover::after,
			.titlebox .tagline a.author${userHref}:hover::after,
			.commentingAsUser a${userHref}:hover::after,
			a.author${userHref}:hover::after,
			.bottom a${userHref}:hover::after {
				content: none;
			}
		`);
    }
    const curatedBy = document.querySelector(".multi-details > h2 a");
    if (curatedBy) {
      const curatedByUsername = curatedBy.pathname.match(regexes.profile);
      if (curatedByUsername && curatedByUsername[1].toLowerCase() === user.toLowerCase()) {
        curatedBy.textContent = curatedBy.textContent.replace(user, displayText);
        if (module18.options.showUsernameOnHover.value) {
          (0, import_jquery16.default)(curatedBy).on("mouseenter", function() {
            this.textContent = this.textContent.replace(displayText, user);
          }).on("mouseleave", function() {
            this.textContent = this.textContent.replace(user, displayText);
          });
        }
      }
    }
  }

  // lib/modules/quickMessage.js
  var module19 = new Module("quickMessage");
  module19.moduleName = "quickMessageName";
  module19.category = "usersCategory";
  module19.description = "quickMessageDesc";
  module19.options = {
    openQuickMessage: {
      title: "quickMessageOpenQuickMessageTitle",
      type: "keycode",
      value: [77, false, true, false, false],
      // control-m
      description: "quickMessageOpenQuickMessageDesc"
    },
    defaultSubject: {
      title: "quickMessageDefaultSubjectTitle",
      type: "text",
      value: "",
      description: "quickMessageDefaultSubjectDesc"
    },
    sendAs: {
      title: "quickMessageSendAsTitle",
      type: "enum",
      values: [{
        name: "Current user",
        value: "user"
      }, {
        name: "Current subreddit",
        value: "sub"
      }, {
        name: "Last selected",
        value: "last"
      }, {
        name: "Last selected (this page load)",
        value: "temporary"
      }],
      value: "user",
      description: "quickMessageSendAsDesc"
    },
    handleContentLinks: {
      title: "quickMessageHandleContentLinksTitle",
      type: "boolean",
      value: true,
      description: "quickMessageHandleContentLinksDesc"
    },
    handleSideLinks: {
      title: "quickMessageHandleSideLinksTitle",
      type: "boolean",
      value: true,
      description: "quickMessageHandleSideLinksDesc"
    },
    linkToCurrentPage: {
      title: "quickMessageLinkToCurrentPageTitle",
      type: "boolean",
      value: true,
      description: "quickMessageLinkToCurrentPageDesc"
    }
  };
  var lastSentAsStorage = storage_exports.wrapPrefix("RESmodules.quickMessage.lastSentAs.", () => null);
  module19.contentStart = () => {
    registerCommand(
      (cmd, val) => cmd === "qm" && /^(?:([^\s]+)(?:\s(.*))?)?$/.exec(val),
      "qm [recipient [message]] - open quick message dialog",
      (command, val, [, to, body]) => {
        if (body) {
          return `quick message to ${to}: ${body}`;
        } else if (to) {
          return `quick message to ${to}`;
        }
        return "quick message";
      },
      (command, val, [, to, body]) => {
        openQuickMessageDialog({ to, body });
      }
    );
    window.addEventListener("keydown", (e2) => {
      if (checkKeysForEvent(e2, module19.options.openQuickMessage.value)) {
        e2.preventDefault();
        openQuickMessageDialog();
      }
    }, true);
    if (module19.options.handleContentLinks.value) {
      (0, import_jquery17.default)('div.content[role="main"]').on("click", 'a[href*="/message/compose"]', messageLinkEventHandler);
    }
    if (module19.options.handleSideLinks.value) {
      (0, import_jquery17.default)("div.side").on("click", 'a[href*="/message/compose"]', messageLinkEventHandler);
    }
  };
  var quickMessageDialog = once_default(() => {
    const $dialog = (0, import_jquery17.default)(string_exports.html`
		<div id="quickMessage">
			<div id="quickMessageDialog" class="RESDialogSmall">
				<h3>Send Message<a class="gearIcon" href="${makeUrlHash(module19.moduleID)}"></a></h3>
				<div id="quickMessageDialogClose" class="RESCloseButton RESCloseButtonTopRight"></div>
				<div id="quickMessageDialogContents" class="RESDialogContents clear">
					<form name="quickMessageDialogForm" action="">
						<label for="quickMessageDialogFrom">From</label>
						<select id="quickMessageDialogFrom"></select>
						<label for="quickMessageDialogTo">To</label>
						<input type="text" id="quickMessageDialogTo" value=""/>
						<label for="quickMessageDialogSubject">Subject</label>
						<input type="text" id="quickMessageDialogSubject" value=""/>
						<label for="quickMessageDialogBody">Body</label>
						<textarea id="quickMessageDialogBody"></textarea>
						<div class="clear"></div>
						<input type="button" id="quickMessageDialogSend" value=" send message"/>
						<a href="/message/compose" class="fullMessageForm blueButton">open full message form</a>
					</form>
				</div>
			</div>
		</div>
	`);
    const from = downcast($dialog.find("#quickMessageDialogFrom").get(0), HTMLSelectElement);
    const to = downcast($dialog.find("#quickMessageDialogTo").get(0), HTMLInputElement);
    const subject = downcast($dialog.find("#quickMessageDialogSubject").get(0), HTMLInputElement);
    const body = downcast($dialog.find("#quickMessageDialogBody").get(0), HTMLTextAreaElement);
    $dialog.find("#quickMessageDialogClose").on("click", (e2) => {
      e2.preventDefault();
      closeQuickMessageDialog();
    });
    $dialog.get(0).addEventListener("keydown", (e2) => {
      if (e2.key === NAMED_KEYS.Escape) {
        e2.preventDefault();
        closeQuickMessageDialog();
      }
    }, true);
    $dialog.find("#quickMessageDialogSend").get(0).addEventListener("click", (e2) => {
      e2.preventDefault();
      sendMessage2();
    }, true);
    onCtrlEnter("#quickMessageDialog", sendMessage2);
    $dialog.find("a.fullMessageForm").on("mousedown focus", (e2) => {
      (0, import_jquery17.default)(e2.currentTarget).attr("href", getFullMessageFormUrl());
    }).on("click", closeQuickMessageDialog);
    $dialog.find("a").on("keypress", (e2) => {
      if (e2.key === NAMED_KEYS.Enter) {
        e2.currentTarget.click();
      }
    });
    from.addEventListener("change", () => {
      const val = from.value;
      updateModeratorIcon(val.startsWith("/r/"));
      const loggedIn = loggedInUser();
      if (loggedIn) lastSentAsStorage.set(loggedIn, val);
    });
    $dialog.appendTo(document.body);
    return { $dialog, from, to, subject, body };
  });
  function updateModeratorIcon(state) {
    quickMessageDialog().$dialog.find("label[for=quickMessageDialogFrom]").toggleClass("moderator", state);
  }
  function messageLinkEventHandler(e2) {
    const { searchParams, pathname } = new URL(downcast(e2.target, HTMLAnchorElement).href, location.href);
    const hasModifier = e2.ctrlKey || e2.altKey || e2.metaKey || e2.shiftKey;
    if (e2.button === 0 && !hasModifier && regexes.composeMessage.test(pathname)) {
      e2.preventDefault();
      const srMatch = regexes.subreddit.exec(pathname);
      openQuickMessageDialog({
        from: srMatch ? `/r/${srMatch[1]}` : void 0,
        to: searchParams.get("to") || "",
        subject: searchParams.get("subject") || "",
        body: searchParams.get("message") || ""
      });
      return true;
    }
  }
  async function getValidSendFrom() {
    const username = loggedInUser();
    if (!username) {
      return [];
    }
    const users = [{
      name: `/u/${username}`,
      displayText: `/u/${isRunning(usernameHider_exports) ? getDisplayText(username) : username}`
    }];
    if (isModeratorAnywhere()) {
      const { data: data2 } = await ajax({
        url: "/subreddits/mine/moderator.json",
        query: {
          limit: 1e3,
          show: "all",
          user: loggedInUser() || ""
          // for the cache
        },
        type: "json",
        cacheFor: HOUR
      });
      const modSubs = data2.children.map(({ data: data3 }) => {
        const name2 = data3.url.slice(0, -1);
        return { name: name2, displayText: name2 };
      });
      users.push(...modSubs);
    }
    return users;
  }
  var setUpSendFromDropdown = once_default(async () => {
    const senders = await getValidSendFrom();
    for (const { name: name2, displayText } of senders) {
      const currentOption = document.createElement("option");
      currentOption.value = name2;
      currentOption.text = displayText;
      quickMessageDialog().from.add(currentOption);
    }
    quickMessageDialog().from.disabled = senders.length < 2;
  });
  function focusFirstEmpty() {
    Array.from(quickMessageDialog().$dialog.find("input, textarea")).find((ele, i2, { length }) => (
      /*::
      	(ele instanceof HTMLInputElement ||
      	ele instanceof HTMLTextAreaElement) &&
      */
      !ele.value || i2 === length - 1
    )).focus();
  }
  async function updateSelectedSender(desiredUser, loggedIn) {
    const sendAsOptions = Array.from(quickMessageDialog().from.options).map((ele) => (0, import_jquery17.default)(ele).text().toLowerCase());
    let indexToSelect = sendAsOptions.indexOf(desiredUser.toLowerCase());
    if (indexToSelect === -1) {
      switch (module19.options.sendAs.value) {
        case "sub":
          const sub = currentSubreddit();
          if (sub) indexToSelect = sendAsOptions.indexOf(`/r/${sub.toLowerCase()}`);
          break;
        case "last":
          const lastSelected = await lastSentAsStorage.get(loggedIn);
          if (lastSelected) {
            indexToSelect = sendAsOptions.indexOf(lastSelected.toLowerCase());
          }
          break;
        case "temporary":
          indexToSelect = quickMessageDialog().from.selectedIndex;
          break;
        // case 'user':
        default:
          indexToSelect = 0;
          break;
      }
    }
    quickMessageDialog().from.selectedIndex = indexToSelect !== -1 ? indexToSelect : 0;
    updateModeratorIcon(quickMessageDialog().from.value.startsWith("/r/"));
  }
  async function openQuickMessageDialog({ from = "", to = "", subject = module19.options.defaultSubject.value, body = module19.options.linkToCurrentPage.value ? location.href : "" } = {}) {
    const loggedIn = loggedInUser();
    if (!loggedIn) {
      showNotification({
        moduleID: "quickMessage",
        notificationID: "quickMessageNoUser",
        header: "Not Logged In.",
        closeDelay: 3e3,
        message: "You must log in to use the quick message dialog."
      });
      return;
    }
    await setUpSendFromDropdown();
    await updateSelectedSender(from, loggedIn);
    quickMessageDialog().to.value = to;
    quickMessageDialog().subject.value = subject;
    quickMessageDialog().body.value = body;
    quickMessageDialog().$dialog.fadeIn(300);
    focusFirstEmpty();
  }
  function closeQuickMessageDialog() {
    quickMessageDialog().$dialog.fadeOut(300);
    for (const ele of quickMessageDialog().$dialog.find("input, textarea, button")) {
      ele.blur();
    }
  }
  function getFullMessageFormUrl() {
    const subreddit2 = quickMessageDialog().from.value.startsWith("/r/") ? quickMessageDialog().from.value : "";
    return subreddit2 + string_exports.encode`/message/compose?to=${quickMessageDialog().to.value}&subject=${quickMessageDialog().subject.value}&message=${quickMessageDialog().body.value}`;
  }
  var presetSendErrors = {
    NO_USER: "No recipient specified.",
    NO_SUBJECT: "No subject specified.",
    NO_TEXT: "Message body is empty.",
    BAD_CAPTCHA: '<p>Sorry, reddit requires you to enter a captcha to send messages. This is usually because your account is brand new or has low karma.</p><b>Click on "open full message form" and try again (your message will be preserved).</b>',
    TOO_LONG: "Either your subject (max 100 characters) or body (max 10,000 characters) is too long."
  };
  async function sendMessage2() {
    const from = quickMessageDialog().from.value;
    try {
      const { json: { errors } } = await ajax({
        method: "POST",
        url: "/api/compose",
        data: {
          api_type: "json",
          from_sr: from.includes("/r/") ? from.slice(3) : "",
          subject: quickMessageDialog().subject.value,
          text: quickMessageDialog().body.value,
          to: quickMessageDialog().to.value
        },
        type: "json"
      });
      if (errors[0]) {
        showNotification({
          moduleID: "quickMessage",
          notificationID: "quickMessageSendError",
          header: "Message not sent.",
          closeDelay: 15e3,
          message: presetSendErrors[errors[0][0]] || `${errors[0][0]} : ${errors[0][1]}`
          // errors[0][0] is the error name, [1] is reddit's description of the error
        });
      } else {
        closeQuickMessageDialog();
      }
    } catch (e2) {
      showNotification({
        moduleID: "quickMessage",
        notificationID: "failedToSendQuickMessage",
        header: "Sending Failed!",
        closeDelay: 15e3,
        message: 'Reddit is likely under heavy load. Either wait a minute or click on "open full message form" and try again (your message will be preserved).'
      });
      throw e2;
    }
  }

  // lib/modules/userHighlight.js
  var module21 = new Module("userHighlight");
  module21.moduleName = "userHighlightName";
  module21.category = "usersCategory";
  module21.description = "userHighlightDesc";
  module21.bodyClass = true;
  module21.options = {
    highlightSelf: {
      title: "userHighlightHighlightSelfTitle",
      type: "boolean",
      value: false,
      description: "userHighlightHighlightSelfDesc"
    },
    selfColor: {
      title: "userHighlightSelfColorTitle",
      type: "color",
      value: "#b8860b",
      description: "userHighlightSelfColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightSelf.value
    },
    selfColorHover: {
      title: "userHighlightSelfColorHoverTitle",
      type: "color",
      value: "#8a6508",
      description: "userHighlightSelfColorHoverDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightSelf.value
    },
    highlightOP: {
      title: "userHighlightHighlightOPTitle",
      type: "boolean",
      value: true,
      description: "userHighlightHighlightOPDesc"
    },
    OPColor: {
      title: "userHighlightOPColorTitle",
      type: "color",
      value: "#0055df",
      description: "userHighlightOPColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightOP.value
    },
    OPColorHover: {
      title: "userHighlightOPColorHoverTitle",
      type: "color",
      value: "#4e7eab",
      description: "userHighlightOPColorHoverDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightOP.value
    },
    highlightAdmin: {
      title: "userHighlightHighlightAdminTitle",
      type: "boolean",
      value: true,
      description: "userHighlightHighlightAdminDesc"
    },
    adminColor: {
      title: "userHighlightAdminColorTitle",
      type: "color",
      value: "#ff0011",
      description: "userHighlightAdminColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightAdmin.value
    },
    adminColorHover: {
      title: "userHighlightAdminColorHoverTitle",
      type: "color",
      value: "#b3000c",
      description: "userHighlightAdminColorHoverDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightAdmin.value
    },
    highlightAlum: {
      title: "userHighlightHighlightAlumTitle",
      type: "boolean",
      value: true,
      description: "userHighlightHighlightAlumDesc"
    },
    alumColor: {
      title: "userHighlightAlumColorTitle",
      type: "color",
      value: "#be1337",
      description: "userHighlightAlumColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightAlum.value
    },
    alumColorHover: {
      title: "userHighlightAlumColorHoverTitle",
      type: "color",
      value: "#8f0e29",
      description: "userHighlightAlumColorHoverDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightAlum.value
    },
    highlightFriend: {
      title: "userHighlightHighlightFriendTitle",
      type: "boolean",
      value: true,
      description: "userHighlightHighlightFriendDesc"
    },
    friendColor: {
      title: "userHighlightFriendColorTitle",
      type: "color",
      value: "#ff4500",
      description: "userHighlightFriendColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightFriend.value
    },
    friendColorHover: {
      title: "userHighlightFriendColorHoverTitle",
      type: "color",
      value: "#b33000",
      description: "userHighlightFriendColorHoverDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightFriend.value
    },
    highlightMod: {
      title: "userHighlightHighlightModTitle",
      type: "boolean",
      value: true,
      description: "userHighlightHighlightModDesc"
    },
    modColor: {
      title: "userHighlightModColorTitle",
      type: "color",
      value: "#228822",
      description: "userHighlightModColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightMod.value
    },
    modColorHover: {
      title: "userHighlightModColorHoverTitle",
      type: "color",
      value: "#134913",
      description: "userHighlightModColorHoverDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightMod.value
    },
    highlightOpMentions: {
      title: "userHighlightOpMentionsTitle",
      type: "boolean",
      value: true,
      description: "userHighlightOpMentionsDesc"
    },
    opMentionsColor: {
      title: "userHighlightOpMentionsColorTitle",
      type: "color",
      value: "#6d4731",
      description: "userHighlightOpMentionsColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightOpMentions.value
    },
    opMentionsHover: {
      title: "userHighlightOpMentionsHoverTitle",
      type: "color",
      value: "#c4946e",
      description: "userHighlightOpMentionsHoverDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightOpMentions.value
    },
    highlightFirstCommenter: {
      title: "userHighlightHighlightFirstCommenterTitle",
      type: "boolean",
      value: false,
      description: "userHighlightHighlightFirstCommenterDesc"
    },
    dontHighlightFirstComment: {
      title: "userHighlightDontHighlightFirstCommentTitle",
      type: "boolean",
      value: true,
      description: "userHighlightDontHighlightFirstCommentDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightFirstCommenter.value
    },
    firstCommentColor: {
      title: "userHighlightFirstCommentColorTitle",
      type: "color",
      value: "#46b6cc",
      description: "userHighlightFirstCommentColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightFirstCommenter.value
    },
    firstCommentColorHover: {
      title: "userHighlightFirstCommentColorHoverTitle",
      type: "color",
      value: "#72d2e5",
      description: "userHighlightFirstCommentColorHoverDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightFirstCommenter.value
    },
    fontColor: {
      title: "userHighlightFontColorTitle",
      type: "color",
      value: "#ffffff",
      description: "userHighlightFontColorDesc",
      advanced: true
    },
    autoColorUsernames: {
      title: "userHighlightAutoColorUsernamesTitle",
      type: "boolean",
      value: false,
      description: "userHighlightAutoColorUsernamesDesc"
    },
    autoColorUsing: {
      title: "userHighlightAutoColorUsingTitle",
      description: "userHighlightAutoColorUsingDesc",
      type: "enum",
      value: "hash-userid-notbright",
      values: [{
        name: "Random color, not too bright, consistent for each user; night mode-friendly",
        value: "hash-userid-notbright"
      }, {
        name: "Simple random color, consistent for each user. (original)",
        value: "hash-userid"
      }, {
        name: "All black or, in night mode, all light gray.",
        value: "monochrome"
      }],
      advanced: true,
      dependsOn: (options6) => options6.autoColorUsernames.value
    },
    generateHoverColors: {
      title: "userHighlightGenerateHoverColorsTitle",
      type: "button",
      text: "Generate",
      callback: generateHoverColors,
      description: "userHighlightGenerateHoverColorsDesc",
      advanced: true
    }
  };
  module21.beforeLoad = () => {
    if (module21.options.autoColorUsernames.value) {
      watchForThings(["post", "comment", "message"], updateNewUsernames, { immediate: true });
    }
    if (module21.options.highlightFirstCommenter.value) {
      watchForThings(["comment"], updateFirstComments, { immediate: true });
    }
    if (module21.options.highlightFriend.value) {
      highlight("friend", module21.options.friendColor.value, module21.options.friendColorHover.value);
    }
    if (module21.options.highlightOP.value) {
      highlight("submitter", module21.options.OPColor.value, module21.options.OPColorHover.value);
    }
    if (module21.options.highlightMod.value) {
      highlight("moderator", module21.options.modColor.value, module21.options.modColorHover.value);
    }
    if (module21.options.highlightAdmin.value) {
      highlight("admin", module21.options.adminColor.value, module21.options.adminColorHover.value);
    }
    if (module21.options.highlightAlum.value) {
      highlight("alum", module21.options.alumColor.value, module21.options.alumColorHover.value);
    }
    if (module21.options.highlightOpMentions.value && isPageType("comments")) {
      watchForElements(["selfText"], null, (selftext) => {
        const thing = Thing.from(selftext);
        const author = thing && thing.getAuthor();
        highlightMentionedUsers(selftext, module21.options.opMentionsColor.value, module21.options.opMentionsHover.value, author);
      }, { immediate: true });
    }
  };
  module21.contentStart = () => {
    const username = loggedInUser();
    if (module21.options.highlightSelf.value && username) {
      highlight(`author[href$="/${username}"]`, module21.options.selfColor.value, module21.options.selfColorHover.value);
    }
  };
  function highlightMentionedUsers(element, color, hoverColor, ...exclude) {
    Array.from(element.querySelectorAll("a")).map(getUsernameFromLink).filter(Boolean).filter((user) => !exclude.includes(user)).forEach((user) => highlight(`author[href$="/${user}" i]`, color, hoverColor));
  }
  function updateFirstComments(thing) {
    if (!thing.isTopLevelComment()) return;
    const idClass = Array.from(thing.element.classList).find((cls) => cls.startsWith("id-t1_"));
    if (!idClass) return;
    const author = thing.getAuthorElement();
    if (!author) return;
    const authorClass = Array.from(author.classList).find((cls) => cls.startsWith("id-t2_"));
    if (authorClass) {
      const container2 = `.${idClass}${module21.options.dontHighlightFirstComment.value ? " .child" : ""}`;
      highlight(
        authorClass,
        module21.options.firstCommentColor.value,
        module21.options.firstCommentColorHover.value,
        container2
      );
    }
  }
  function updateNewUsernames(thing) {
    const element = thing.getAuthorElement();
    if (!element) return;
    const idClass = Array.from(element.classList).find((cls) => cls.startsWith("id-t2_"));
    if (!idClass) return;
    const colorGetter = autoColorUsing[module21.options.autoColorUsing.value];
    const color = colorGetter(idClass);
    doTextColor(idClass, color);
  }
  var autoColorUsing = {
    "hash-userid-notbright"(idClass) {
      const hash = hashCode(idClass);
      const r = (hash & 16711680) >> 16;
      const g = (hash & 65280) >> 8;
      const b2 = hash & 255;
      const lum = Math.round(r * 0.299 + g * 0.587 + b2 * 0.114);
      const minLum = 102;
      const maxLum = 170;
      let color = [r, g, b2];
      let nightmodeColor = [r, g, b2];
      if (lum < minLum) {
        const scale = minLum / lum;
        nightmodeColor = [
          Math.round(r * scale),
          Math.round(g * scale),
          Math.round(b2 * scale)
        ];
      } else if (lum > maxLum) {
        const scale = maxLum / lum;
        color = [
          Math.round(r * scale),
          Math.round(g * scale),
          Math.round(b2 * scale)
        ];
      }
      color = `rgb(${color.join(",")})`;
      nightmodeColor = `rgb(${nightmodeColor.join(",")})`;
      return {
        color,
        nightmodeColor
      };
    },
    "hash-userid"(idClass) {
      let hash = 5381;
      for (const char of idClass) {
        hash = (hash << 5) + hash + char.charCodeAt(0);
      }
      const r = (hash & 16711680) >> 16;
      const g = (hash & 65280) >> 8;
      const b2 = hash & 255;
      const color = `rgb(${[r, g, b2].join(",")})`;
      return {
        color
      };
    },
    monochrome() {
      return {
        color: "black",
        nightmodeColor: "#ccc"
      };
    }
  };
  function highlightUser(userid) {
    return highlight(
      `author.id-t2_${userid}`,
      module20.options.highlightColor.value,
      module20.options.highlightColorHover.value
    );
  }
  var css2 = [];
  var throttled = throttle2(() => {
    addCSS(css2.splice(0, css2.length).join("\n"));
  });
  var batch2 = (v) => {
    css2.push(v);
    throttled();
  };
  function highlight(selector, color, hoverColor, container2 = "") {
    batch2(`
${container2} .tagline .author.${selector},
${container2} .crosspost-preview-tagline .author.${selector} {
	color: ${module21.options.fontColor.value} !important;
	font-weight: bold;
	padding: 0 2px 0 2px;
	border-radius: 3px;
	background-color: ${color} !important;
}
${container2} .collapsed .tagline .author.${selector},
${container2} .collapsed .crosspost-preview-tagline .author.${selector} {
	color: white !important;
	background-color: #AAA !important;
}
${container2} .tagline .author.${selector}:hover,
${container2} .crosspost-preview-tagline .author.${selector}:hover {
	background-color: ${hoverColor} !important;
	text-decoration: none !important;
}
	`);
  }
  function doTextColor(selector, colorData) {
    const color = colorData.color;
    const nightmodeColor = colorData.nightmodeColor || colorData.color;
    batch2(`
.tagline .author.${selector} {
	color: ${color} !important;
}
.res-nightmode .tagline .author.${selector} {
	color: ${nightmodeColor} !important;
}
	`);
  }
  function generateHoverColor(color) {
    if (!/^#[0-9A-F]{6}$/i.test(color)) throw new Error("Input color must be a six digit hex value");
    let R = parseInt(color.substr(1, 2), 16);
    let G = parseInt(color.substr(3, 2), 16);
    let B = parseInt(color.substr(5, 2), 16);
    R = Math.round(0.75 * R) + 256;
    G = Math.round(0.75 * G) + 256;
    B = Math.round(0.75 * B) + 256;
    return `#${R.toString(16).substr(1)}${G.toString(16).substr(1)}${B.toString(16).substr(1)}`;
  }
  function generateHoverColors() {
    try {
      for (const option2 of ["selfColor", "OPColor", "adminColor", "friendColor", "modColor", "firstCommentColor", "alumColor"]) {
        const current2 = (stage_exports.get(module21.moduleID) || module21.options)[option2].value;
        set5(module21.moduleID, option2, generateHoverColor(current2));
      }
      alert_exports.open("Saved, but not yet updated in settings console. Reload page without saving to see new values.");
    } catch (e2) {
      alert_exports.open(i18n("userHighlightColorCouldNotBeGenerated"));
    }
  }

  // lib/modules/userInfo.js
  var module20 = new Module("userInfo");
  module20.moduleName = "userInfoName";
  module20.category = "usersCategory";
  module20.description = "userInfoDesc";
  module20.options = {
    hoverInfo: {
      title: "userInfoHoverInfoTitle",
      type: "boolean",
      value: true,
      description: "userInfoHoverInfoDesc"
    },
    useQuickMessage: {
      title: "userInfoUseQuickMessageTitle",
      type: "boolean",
      value: true,
      description: "userInfoUseQuickMessageDesc",
      dependsOn: (options6) => options6.hoverInfo.value
    },
    hoverDelay: {
      title: "userInfoHoverDelayTitle",
      type: "text",
      value: "800",
      description: "userInfoHoverDelayDesc",
      advanced: true,
      dependsOn: (options6) => options6.hoverInfo.value
    },
    fadeDelay: {
      title: "userInfoFadeDelayTitle",
      type: "text",
      value: "200",
      description: "userInfoFadeDelayDesc",
      advanced: true,
      dependsOn: (options6) => options6.hoverInfo.value
    },
    fadeSpeed: {
      title: "userInfoFadeSpeedTitle",
      type: "text",
      value: "0.7",
      description: "userInfoFadeSpeedDesc",
      advanced: true,
      dependsOn: (options6) => options6.hoverInfo.value
    },
    gildComments: {
      title: "userInfoGildCommentsTitle",
      type: "boolean",
      value: true,
      description: "userInfoGildCommentsDesc",
      advanced: true,
      dependsOn: (options6) => options6.hoverInfo.value
    },
    highlightButton: {
      title: "userInfoHighlightButtonTitle",
      type: "boolean",
      value: true,
      description: "userInfoHighlightButtonDesc",
      advanced: true,
      dependsOn: (options6) => options6.hoverInfo.value
    },
    highlightColor: {
      title: "userInfoHighlightColorTitle",
      type: "color",
      value: "#5544cc",
      description: "userInfoHighlightColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightButton.value
    },
    highlightColorHover: {
      title: "userInfoHighlightColorHoverTitle",
      type: "color",
      value: "#6677aa",
      description: "userInfoHighlightColorHoverDesc",
      advanced: true,
      dependsOn: (options6) => options6.highlightButton.value
    }
  };
  var highlightedUsers = {};
  module20.contentStart = () => {
    if (module20.options.hoverInfo.value) {
      infocard(module20.moduleID).options({
        width: 475,
        openDelay: parseFloat(module20.options.hoverDelay.value),
        fadeDelay: parseFloat(module20.options.fadeDelay.value),
        fadeSpeed: parseFloat(module20.options.fadeSpeed.value)
      }).populateWith(showUserInfo).watch(usernameSelector);
    }
  };
  async function showUserInfo(card) {
    const username = getUsernameFromLink(card.getCheckedTarget());
    if (!username) {
      console.error(i18n("userInfoInvalidUsernameLink"));
      return;
    }
    const thing = Thing.from(card.getCheckedTarget());
    let data2;
    try {
      ({ data: data2 } = await getUserInfo(username));
    } catch (e2) {
      return [null, i18n("userInfoUserNotFound")];
    }
    if (data2.is_suspended) {
      return [null, i18n("userInfoUserSuspended")];
    }
    const d = new Date(data2.created_utc * 1e3);
    const header = string_exports.html`
		<div>
			<a href="/user/${data2.name}">/u/${data2.name}</a>
		 	(<a href="/user/${data2.name}/submitted/">${i18n("userInfoLinks")}</a>)
		 	(<a href="/user/${data2.name}/comments/">${i18n("userInfoComments")}</a>)
		</div>
	`;
    if (loggedInUser()) {
      const button = createElement_exports.fancyToggleButton(
        i18n("userInfoAddRemoveFriends"),
        "",
        () => data2.is_friend,
        async (state) => {
          ajax({
            method: "POST",
            url: `/api/${state ? "friend" : "unfriend"}`,
            data: {
              type: "friend",
              name: data2.name,
              container: `t2_${(await getUserInfo()).data.id}`
            }
          });
          ajax.invalidate({ url: `/user/${data2.name}/about.json` });
        }
      );
      button.style.marginLeft = "12px";
      header.appendChild(button);
    }
    card.populate([header]);
    const $body = (0, import_jquery18.default)('<div id="authorInfoToolTip" />');
    let userHTML = string_exports.escape`
		<div class="fieldPair"><div class="fieldPair-label">${i18n("userInfoRedditorSince")}</div> <div class="fieldPair-text">${formatDate(d)} (${formatDateDiff(d)})</div></div>
		<div class="fieldPair"><div class="fieldPair-label">${i18n("userInfoPostKarma")}</div> <div class="fieldPair-text">${formatNumber(data2.link_karma)}</div></div>
		<div class="fieldPair"><div class="fieldPair-label">${i18n("userInfoCommentKarma")}</div> <div class="fieldPair-text">${formatNumber(data2.comment_karma)}</div></div>
	`;
    const userTaggerEnabled = isRunning(userTagger_exports);
    const userTag = userTaggerEnabled && await Tag.get(data2.name);
    if (userTaggerEnabled) {
      userHTML += `<div class="fieldPair"><div class="fieldPair-label">${i18n("userInfoUserTag")}</div> <div class="fieldPair-text" style="display:flex"><a class="author" style="display: none;" href="/u/${data2.name}"/></div></div>`;
    }
    if (userTag && userTag.link) {
      const links = userTag.link.split(/\s/).reduce((acc, url) => acc + string_exports.escape`<a target="_blank" rel="noopener noreferer" href="${url}">${url.replace(/^https?:\/\/(www\.)?/, "")}</a>`, "");
      userHTML += `<div class="fieldPair"><div class="fieldPair-label">${i18n("userInfoLink")}</div> <div class="fieldPair-text">${links}</div></div>`;
    }
    userHTML += string_exports.escape`
		<div class="clear"></div>
		<div class="bottomButtons">
			<a target="_blank" rel="noopener noreferer" class="blueButton composeButton" href="/message/compose/?to=${data2.name}"><img src="https://redditstatic.s3.amazonaws.com/mailgray.png"> ${i18n("userInfoSendMessage")}</a>
	`;
    if (data2.is_gold) {
      userHTML += string_exports.escape`<a target="_blank" rel="noopener noreferer" class="blueButton" href="/gold/about">${i18n("userInfoUserHasRedditGold")}</a>`;
    } else {
      userHTML += string_exports.escape`<a target="_blank" rel="noopener noreferer" id="gildUser" class="blueButton" href="/gold?goldtype=gift&recipient=${data2.name}">${i18n("userInfoGiftRedditGold")}</a>`;
    }
    if (module20.options.highlightButton.value) {
      const isHighlight = !highlightedUsers[data2.id];
      userHTML += string_exports.escape`<div class="${isHighlight ? "blueButton" : "redButton"}" id="highlightUser" data-userid="${data2.id}">${isHighlight ? i18n("userInfoHighlight") : i18n("userInfoUnhighlight")}</div>`;
    }
    if (userTag) {
      const getButton = () => string_exports.html`<div class="${userTag.ignored ? "redButton" : "blueButton"}" id="ignoreUser">&empty; ${userTag.ignored ? i18n("userInfoUnignore") : i18n("userInfoIgnore")}</div>`;
      $body.on("click", "#ignoreUser", (e2) => {
        if (e2.currentTarget.classList.contains("blueButton")) userTag.ignore();
        else userTag.unignore();
        e2.currentTarget.replaceWith(getButton());
      });
      userHTML += getButton().outerHTML;
    }
    userHTML += '<div class="clear"></div></div>';
    $body.append(userHTML);
    if (userTag) {
      userTag.add(downcast($body.find(".author").get(0), HTMLAnchorElement), { renderTaggingIcon: true });
    }
    if (module20.options.highlightButton.value) {
      $body.find("#highlightUser").on("click", ({ currentTarget }) => {
        const userid = currentTarget.getAttribute("data-userid");
        toggleUserHighlight(currentTarget, userid, thing);
      });
    }
    if (module20.options.gildComments.value && thing && thing.isComment()) {
      $body.find("#gildUser").on("click", (e2) => {
        if (!thing || e2.ctrlKey || e2.metaKey || e2.shiftKey) return;
        card.close();
        const giveGold = thing.entry.querySelector(".give-gold");
        click(giveGold);
        e2.preventDefault();
      });
    }
    if (module20.options.useQuickMessage.value && isRunning(quickMessage_exports)) {
      $body.find("a.composeButton").on("click", (e2) => {
        if (e2.which === 1) {
          e2.preventDefault();
          let entryUrl;
          if (module19.options.linkToCurrentPage.value && thing) {
            const permalink = thing.getCommentPermalink();
            if (permalink) {
              entryUrl = permalink.href;
              if (!entryUrl.includes("?context=")) entryUrl += "?context=10";
            }
          }
          openQuickMessageDialog({
            to: data2.name,
            body: entryUrl
          });
          card.close();
        }
      });
    }
    return [null, $body];
  }
  function toggleUserHighlight(authorInfoToolTipHighlight, userid, thing) {
    if (highlightedUsers[userid]) {
      highlightedUsers[userid].remove();
      delete highlightedUsers[userid];
      toggleUserHighlightButton(authorInfoToolTipHighlight, true);
    } else {
      highlightedUsers[userid] = highlightUser(userid);
      toggleUserHighlightButton(authorInfoToolTipHighlight, false);
    }
    if (isRunning(commentNavigator_exports) && module22.options.openOnHighlightUser.value) {
      setCategory("highlighted", true);
      if (thing) updateFromSelected(thing);
      toggle4(false, true);
    }
  }
  function toggleUserHighlightButton(authorInfoToolTipHighlight, canHighlight) {
    (0, import_jquery18.default)(authorInfoToolTipHighlight).toggleClass("blueButton", canHighlight).toggleClass("redButton", !canHighlight).text(canHighlight ? i18n("userInfoHighlight") : i18n("userInfoUnhighlight"));
  }

  // lib/modules/wheelBrowse.js
  var module23 = new Module("wheelBrowse");
  module23.moduleName = "wheelBrowseName";
  module23.category = "browsingCategory";
  module23.description = "wheelBrowseDesc";
  var behavior;
  module23.contentStart = () => {
    if (!behavior && isPageType("linklist")) useLinklistBehavior();
    if (!behavior) return;
    const wheelBrowseWidget = string_exports.html`<div hidden class="res-wheel-browse"></div>`;
    const onWheel = behavior(wheelBrowseWidget);
    selectedThing_exports.addListener((current2) => {
      wheelBrowseWidget.hidden = !current2;
    }, "instantly");
    wheelBrowseWidget.addEventListener("wheel", (e2) => {
      e2.stopImmediatePropagation();
      e2.preventDefault();
      onWheel(e2.deltaY > 0 ? "down" : "up", e2);
    });
    addFloater(wheelBrowseWidget, { order: -1 });
  };
  function setCallback(v) {
    behavior = v;
  }
  function useLinklistBehavior() {
    const galleryPart = string_exports.html`<div hidden class="res-wheel-browse-gallery"></div>`;
    let media;
    function updateGalleryPart(direction) {
      const expando2 = Expando.getEntryExpandoFrom(selectedThing_exports.current);
      media = expando2 && expando2.media;
      galleryPart.hidden = !(media && media.element.classList.contains("res-gallery-slideshow") && // Do not show the gallery scroll widget when at the end of the gallery
      (!(direction === "down" && media.element.querySelector("[last-piece=true]")) && !(direction === "up" && media.element.querySelector("[first-piece=true]"))));
    }
    setCallback((wheelBrowseWidget) => {
      wheelBrowseWidget.addEventListener("click", () => open3(module23.moduleID));
      wheelBrowseWidget.addEventListener("mouseenter", () => {
        updateGalleryPart();
      });
      wheelBrowseWidget.append(galleryPart);
      return (direction, { target }) => {
        if (target === wheelBrowseWidget) {
          selectedThing_exports.move(direction, { allowMediaBrowse: true, scrollStyle: "top" });
        } else if (target === galleryPart) {
          const clicker = media && media.element.querySelector(direction === "down" ? ".res-gallery-next" : ".res-gallery-previous");
          if (clicker) clicker.click();
          updateGalleryPart(direction);
        }
      };
    });
  }

  // lib/modules/commentNavigator.js
  var module22 = new Module("commentNavigator");
  module22.moduleName = "commentNavName";
  module22.category = "commentsCategory";
  module22.description = "commentNavDesc";
  module22.options = {
    showByDefault: {
      type: "boolean",
      value: false,
      description: "commentNavigatorShowByDefaultDesc",
      title: "commentNavigatorShowByDefaultTitle"
    },
    showOnKeyboardMove: {
      type: "boolean",
      value: false,
      description: "commentNavigatorShowOnKeyboardMoveDesc",
      title: "commentNavigatorShowOnKeyboardMoveTitle"
    },
    skipReadComments: {
      type: "boolean",
      value: false,
      description: "commentNavigatorSkipReadCommentsDesc",
      title: "commentNavigatorSkipReadCommentsTitle"
    },
    openOnHighlightUser: {
      type: "boolean",
      value: true,
      description: "commentNavigatorOpenOnHighlightUserDesc",
      title: "commentNavigatorOpenOnHighlightUserTitle",
      advanced: true
    },
    popularConditions: {
      type: "text",
      value: JSON.stringify({ type: "commentLength", op: ">", kind: "words", val: 0 }),
      description: "commentNavigatorPopularConditionsDesc",
      title: "commentNavigatorPopularConditionsTitle",
      advanced: true
    }
  };
  module22.include = [
    "comments"
  ];
  module22.contentStart = () => {
    skipReadComments = module22.options.skipReadComments.value;
    selectedThing_exports.addListener((selected) => {
      readComments.add(selected);
    }, "instantly");
    installEntryElement();
    if (module22.options.showByDefault.value) {
      commentNav();
    }
    setCallback((wheelBrowseWidget) => {
      wheelBrowseWidget.addEventListener("click", () => {
        toggle4();
      });
      return (direction) => {
        if (direction === "up") move3("up");
        else move3("down");
      };
    });
    const getMatchingCategory = async (val) => val && (await getCategories()).find(({ category }) => category.startsWith(val));
    registerCommand(
      "nav",
      "nav [sortType] - open the comment navigator",
      async (command, val) => {
        const { category: matchingCategory = "" } = await getMatchingCategory(val) || {};
        return `navigate comments by [(${(await getCategories()).map(({ category }) => matchingCategory === category ? `<b>${category}</b>` : category).join("|")})]`;
      },
      async (command, val) => {
        const { category: matchingCategory = "" } = await getMatchingCategory(val) || {};
        if (matchingCategory) setCategory(matchingCategory);
        toggle4(false, true);
      }
    );
  };
  var initialize = once_default((source) => {
    watchForThings(["comment"], () => {
      getPosts.cache.clear();
    });
    selectedThing_exports.addListener(updateFromSelected, "instantly");
    if (selectedThing_exports.current) updateFromSelected(selectedThing_exports.current);
    if (source === "keyboard" && !module22.options.showOnKeyboardMove.value) commentNav().close();
  });
  var sortTypes2 = {
    custom: {
      title: "Navigate custom category",
      conditions: { type: "false" }
      // Must be updated by `updateCustomCategory`
    },
    comment: {
      title: "Navigate comments",
      conditions: { type: "true" }
    },
    submitter: {
      title: "Navigate comments made by the post submitter",
      conditions: { type: "userAttr", attr: "submitter" }
    },
    moderator: {
      title: "Navigate comments made by moderators",
      conditions: { type: "userAttr", attr: "moderator" }
    },
    friend: {
      title: "Navigate comments made by users on your friends list",
      conditions: { type: "userAttr", attr: "friend" }
    },
    me: {
      title: "Navigate comments made by you",
      conditions: { type: "userAttr", attr: "me" }
    },
    admin: {
      title: "Navigate comments made by reddit admins",
      conditions: { type: "userAttr", attr: "admin" }
    },
    highlighted: {
      title: "Navigate comments made by highlighted user",
      getElements() {
        const highlightedUserSelector = Object.keys(highlightedUsers).map((key) => `.author.id-t2_${key}`).join(", ");
        return highlightedUserSelector ? document.querySelectorAll(highlightedUserSelector) : [];
      }
    },
    tagged: {
      title: "Navigate comments made by tagged users",
      getElements: () => document.querySelectorAll(".tagline .userTagLink.hasTag")
    },
    gilded: {
      title: "Navigate through gilded comments",
      getElements: () => document.querySelectorAll(".gilded-icon")
    },
    IAmA: {
      title: "Navigate through questions that have been answered by the submitter (most useful in /r/IAmA)",
      getThings: async () => filterMap(await getPosts("submitter"), (thing) => thing.parent ? [thing.parent] : void 0)
    },
    images: {
      title: "Navigate through comments with images",
      conditions: { type: "hasExpando", types: ["image"] }
    },
    videos: {
      title: "Navigate through comments with videos",
      conditions: { type: "hasExpando", types: ["video"] }
    },
    popular: {
      title: "Navigate through comments in order of highest vote total",
      async getThings() {
        return filterMap(await getPosts("comment"), (thing) => {
          const score = thing.getScore();
          if (typeof score === "number") {
            return [[score, thing]];
          }
        }).sort((a2, b2) => b2[0] - a2[0]).map(([, thing]) => thing);
      },
      get conditions() {
        return JSON.parse(module22.options.popularConditions.value);
      },
      nonlinear: true
    },
    new: {
      title: "Navigate through new comments (Reddit Gold users only)",
      getElements: () => document.querySelectorAll(".new-comment"),
      disabled: () => !document.body.querySelector(".gold-accent.comment-visits-box")
    },
    upvoted: {
      title: "Navigate through comments you upvoted",
      conditions: { type: "voteType", kind: "upvote" }
    }
  };
  function updateCustomConditions(conditions) {
    sortTypes2.custom.conditions = conditions;
  }
  function getCategories() {
    return Promise.all(
      Object.entries(sortTypes2).filter(([, { disabled }]) => !disabled || !disabled()).map(async ([category, { title }]) => ({
        category,
        selected: category === currentCategory,
        size: (await getVisiblePosts(category)).length,
        title
      }))
    ).then(
      (v) => v.filter(({ size, selected }) => selected || size)
    );
  }
  var getPosts = memoize_default(async (category) => {
    const { getElements, getThings, conditions } = sortTypes2[category];
    let things2;
    if (getThings) {
      things2 = [...new Set(await getThings())];
    } else if (getElements) {
      things2 = [...new Set(Array.from(getElements()).map((e2) => Thing.from(e2)).filter(Boolean))];
    } else {
      things2 = Thing.things().filter((thing) => thing.isComment());
    }
    return filterThings(things2, conditions);
  });
  var getVisiblePosts = (category = currentCategory) => getPosts(category).then((v) => v.filter((thing) => (!skipReadComments || !readComments.has(thing)) && thing.isContentVisible()));
  var lastNavigatedTo = null;
  var readComments = /* @__PURE__ */ new Set();
  var skipReadComments;
  var currentCategory = isCurrentSubreddit("IAmA", "casualiama") ? "IAmA" : "popular";
  var isOpen = false;
  var commentNav = once_default(() => {
    const box = string_exports.html`
		<div id="REScommentNavBox">
			<select id="commentNavBy">
				<option selected value="${currentCategory}">${currentCategory}</option>
			</select>
			<label style="margin-top: 2px; display: flex; align-items: center;"><input id="commentNavSkipReadComments" style="margin-right: 3px;" type="checkbox" ${skipReadComments && "checked"}>Skip read</label>
			<details id="commentNavByConditions" hidden>
				<summary>Conditions</summary>
		<div class="builderItem"></div>
			</details>
			<hr style="margin-bottom: 0">
			<div id="commentNavButtons">
				<button id="commentNavUp">&#x25B2;</button>
				<div id="commentNavPostCount"></div>
				<button id="commentNavDown">&#x25BC;</button>
			</div>
		</div>
	`;
    const skipReadCommentsEle = downcast(box.querySelector("#commentNavSkipReadComments"), HTMLInputElement);
    skipReadCommentsEle.addEventListener("change", () => {
      skipReadComments = skipReadCommentsEle.checked;
      if (selectedThing_exports.current) updateFromSelected(selectedThing_exports.current);
    });
    const select = downcast(box.querySelector("#commentNavBy"), HTMLSelectElement);
    select.addEventListener("focus", async () => {
      empty(select);
      const categories = await getCategories();
      select.append(
        ...categories.map(({ category, selected, size }) => string_exports.html`
				<option ${selected && "selected"} value="${category}">${category}<span> (${size})</span></option>
			`)
      );
    }, true);
    select.addEventListener("keyup", ({ which }) => {
      if (which === 27) select.blur();
    });
    select.addEventListener("change", () => {
      const selectedItem = select.options.item(select.selectedIndex);
      if (selectedItem !== null) {
        setCategory(selectedItem.value);
      }
      updateBuilder();
    });
    const postCount = box.querySelector("#commentNavPostCount");
    postCount.addEventListener("click", () => moveTo(lastNavigatedTo));
    const up = downcast(box.querySelector("#commentNavUp"), HTMLButtonElement);
    up.addEventListener("click", () => move3("up"));
    const down = downcast(box.querySelector("#commentNavDown"), HTMLButtonElement);
    down.addEventListener("click", () => move3("down"));
    addFloater(box, { separate: true });
    const ele = box.querySelector("#commentNavByConditions");
    ele.addEventListener("click", once_default(() => {
      const builderCases = getByContext("comment");
      const group = resolveGroup(getGroup("any", [sortTypes2[currentCategory].conditions]), true, true);
      const $builderBlock = caseBuilder_exports.drawBuilderBlock(group, builderCases, false);
      $builderBlock.on("change input", frameThrottle(() => {
        module22.options.popularConditions.value = JSON.stringify(caseBuilder_exports.readBuilderBlock($builderBlock, builderCases));
        save2(module22.options.popularConditions);
        setCategory(currentCategory, true);
      }));
      const wrapper = ele.querySelector(".builderItem");
      wrapper.append($builderBlock.get(0));
    }));
    const updateBuilder = () => {
      ele.hidden = currentCategory !== "popular";
    };
    function refresh3(index2, length, lastNavigatedToIndex) {
      up.disabled = lastNavigatedToIndex <= 0;
      down.disabled = lastNavigatedToIndex >= length - 1;
      postCount.textContent = length ? `${lastNavigatedToIndex === index2 ? "" : "~"}${lastNavigatedToIndex + 1}/${length}` : "none";
    }
    function open4() {
      isOpen = true;
      box.hidden = false;
    }
    function close3() {
      isOpen = false;
      box.hidden = true;
    }
    initialize();
    updateBuilder();
    isOpen = true;
    return {
      select,
      refresh: refresh3,
      open: open4,
      close: close3
    };
  });
  async function installEntryElement() {
    await new Promise(requestAnimationFrame);
    const location2 = await waitForDescendant(document.body, ".commentarea .panestack-title, .menuarea");
    const commentNavToggle = string_exports.html`<div class="res-commentNavToggle">navigate by</div>`;
    const choices = string_exports.html`<div class="res-commentNavToggle-choices"><div>`;
    commentNavToggle.append(choices);
    location2.append(commentNavToggle);
    commentNavToggle.addEventListener("mouseenter", async () => {
      empty(choices);
      const categories = await getCategories();
      choices.append(...categories.map(({ category, title, size }) => {
        const element = string_exports.html`
				<div class="res-commentNavToggle-type" title="${title}" category="${category}">${category} (${size})</div>
			`;
        element.addEventListener("click", () => {
          setCategory(category);
        });
        return element;
      }));
    });
  }
  async function updateFromSelected(selected) {
    const posts = await getVisiblePosts();
    if (posts.includes(selected) && // Non-linear comment categories are not sorted by distance from top,
    // so do not disturb the selection by automatically updating
    (!sortTypes2[currentCategory].nonlinear || // But allow change if `selected` is adjecent to `lastNavigatedTo`
    Math.abs(posts.indexOf(lastNavigatedTo) - posts.indexOf(selected)) <= 1)) {
      lastNavigatedTo = selected;
    }
    commentNav().refresh(posts.indexOf(selected), posts.length, posts.indexOf(lastNavigatedTo));
  }
  function setCategory(category, keepSelected = false) {
    currentCategory = category;
    lastNavigatedTo = null;
    commentNav().select.value = category;
    getPosts.cache.delete(currentCategory);
    if (keepSelected) {
      move3("refresh");
    } else {
      move3("top");
    }
  }
  function toggle4(focus = false, open4 = !isOpen) {
    if (!open4) {
      commentNav().close();
    } else {
      commentNav().open();
      if (focus) commentNav().select.focus();
    }
  }
  async function move3(change, source) {
    initialize(source);
    if (!sortTypes2[currentCategory].nonlinear) {
      const all2 = Thing.things();
      const lastNavigatedToIndex = all2.indexOf(lastNavigatedTo);
      const selectedIndex = all2.indexOf(selectedThing_exports.current);
      if (change === "down" && selectedIndex < lastNavigatedToIndex || change === "up" && selectedIndex > lastNavigatedToIndex) {
        moveTo(lastNavigatedTo);
        return;
      }
    }
    const visible2 = await getVisiblePosts();
    if (change === "top") {
      moveTo(visible2[0]);
    } else {
      const all2 = [...await getPosts(currentCategory)];
      if (change === "up") all2.reverse();
      const comment = all2.slice(all2.indexOf(lastNavigatedTo) + (change === "refresh" ? 0 : 1)).find((v) => visible2.includes(v));
      moveTo(comment);
    }
  }
  function moveTo(thing) {
    if (!thing) return;
    lastNavigatedTo = thing;
    selectedThing_exports.set(thing, { scrollStyle: "top" }, true);
  }

  // lib/modules/easterEgg.js
  var import_jquery19 = __toESM(require_jquery(), 1);
  var module24 = new Module("easterEgg");
  module24.moduleName = "easterEggName";
  module24.category = "coreCategory";
  module24.description = "easterEggDesc";
  module24.hidden = true;
  var konami;
  module24.contentStart = () => {
    konami = createKonami(() => {
      const $baconBit = (0, import_jquery19.default)("<div>", { id: "baconBit" }).appendTo(document.body);
      showNotification({
        header: "RES Easter Eggies!",
        message: "Mmm, bacon!",
        moduleID: module24.moduleID,
        notificationID: "konami"
      });
      setTimeout(() => $baconBit.addClass("makeitrain"), 500);
    });
  };
  function konamiActive() {
    return !!konami && konami.almostThere;
  }
  function createKonami(callback) {
    const konami2 = {
      input: "",
      pattern: "38384040373937396665",
      almostThere: false,
      prepattern: "383840403739373966",
      load: () => {
        document.addEventListener("keydown", (event) => {
          konami2.input += event.keyCode;
          if (konami2.input.length > konami2.pattern.length) {
            konami2.input = konami2.input.substr(konami2.input.length - konami2.pattern.length);
          }
          if (konami2.input === konami2.pattern) {
            konami2.code();
            konami2.input = "";
            event.preventDefault();
          } else if (konami2.input === konami2.prepattern || konami2.input.substr(2, konami2.input.length) === konami2.prepattern) {
            konami2.almostThere = true;
            setTimeout(() => {
              konami2.almostThere = false;
              konami2.input = "";
            }, 2e3);
          }
        }, false);
      },
      code: () => {
      }
    };
    if (typeof callback === "function") {
      konami2.code = callback;
      konami2.load();
    }
    return konami2;
  }

  // lib/modules/hideChildComments.js
  var hideChildComments_exports = {};
  __export(hideChildComments_exports, {
    module: () => module25,
    toggle: () => toggle5,
    toggleAll: () => toggleAll
  });
  var module25 = new Module("hideChildComments");
  module25.moduleName = "hideChildCommentsName";
  module25.category = "commentsCategory";
  module25.description = "hideChildCommentsDesc";
  module25.options = {
    automatic: {
      type: "boolean",
      value: false,
      description: "hideChildCommentsAutomaticDesc",
      title: "hideChildCommentsAutomaticTitle"
    },
    nested: {
      type: "boolean",
      value: true,
      description: "hideChildCommentsNestedDesc",
      title: "hideChildCommentsNestedTitle"
    },
    hideNested: {
      dependsOn: (options6) => options6.nested.value,
      type: "boolean",
      value: false,
      description: "hideChildCommentsHideNestedDesc",
      title: "hideChildCommentsHideNestedTitle"
    }
  };
  module25.include = [
    "comments"
  ];
  var initialHide;
  var toggleAllButton;
  module25.beforeLoad = () => {
    initialHide = module25.options.automatic.value && // ensure we're not in a permalinked post..
    !/\/comments\/(?:\w+)\/(?:\w+)\/(\w+)/.test(location.pathname);
    watchForThings(["comment"], addToggleChildrenButton);
    watchForThings(["post"], addToggleAllButton);
  };
  var addToggleAllButton = once_default((thing) => {
    const menu = thing.getButtons();
    if (!menu) return;
    function toggle7(action) {
      const includeChildren = module25.options.nested.value && module25.options.hideNested.value;
      const selector = includeChildren ? ".thing.comment" : ".nestedlisting > .thing.comment";
      forEachChunked(document.querySelectorAll(`${selector} > .entry .toggleChildren[action=${action}]`), (toggle8) => {
        toggle8.click();
      });
      if (action === "hide") {
        initialHide = true;
        a2.setAttribute("action", "show");
        a2.setAttribute("title", "Show all comments.");
        a2.dataset.text = i18n("hideChildCommentsShowAllLinkLabel");
      } else {
        initialHide = false;
        a2.setAttribute("action", "hide");
        a2.setAttribute("title", "Show only replies to original poster.");
        a2.dataset.text = i18n("hideChildCommentsHideAllLinkLabel");
      }
    }
    const li = document.createElement("li");
    const a2 = document.createElement("a");
    a2.setAttribute("href", "#");
    a2.setAttribute("class", "noCtrlF res-toggleAllChildren");
    a2.addEventListener("click", (e2) => {
      e2.preventDefault();
      toggle7(a2.getAttribute("action"));
    });
    toggleAllButton = a2;
    toggle7(initialHide ? "hide" : "show");
    li.appendChild(a2);
    menu.appendChild(li);
  });
  function addToggleChildrenButton(comment) {
    if (!module25.options.nested.value && !comment.isTopLevelComment()) return;
    if (!comment.getNumberOfChildren()) return;
    const children = comment.element.querySelector("div.child > .sitetable");
    const menu = comment.getButtons();
    if (!children || !menu) return;
    function toggle7(action) {
      if (action === "hide") {
        children.style.display = "none";
        a2.dataset.text = i18n("hideChildCommentsShowLinkLabel", comment.getNumberOfChildren());
        a2.setAttribute("action", "show");
      } else {
        children.style.display = "";
        a2.dataset.text = i18n("hideChildCommentsHideLinkLabel");
        a2.setAttribute("action", "hide");
      }
      comment.element.classList.toggle("res-children-hidden", action === "hide");
    }
    const li = document.createElement("li");
    const a2 = document.createElement("a");
    a2.setAttribute("href", "#");
    a2.setAttribute("class", "toggleChildren noCtrlF");
    a2.addEventListener("click", (e2) => {
      e2.preventDefault();
      toggle7(a2.getAttribute("action"));
    });
    const hide3 = initialHide && (module25.options.hideNested.value || comment.isTopLevelComment());
    toggle7(hide3 ? "hide" : "show");
    li.appendChild(a2);
    menu.appendChild(li);
  }
  function toggleAll() {
    const button = toggleAllButton;
    if (!button) throw new Error("Toggle all button not found");
    button.click();
  }
  function toggle5(thing) {
    const button = thing.entry.querySelector("a.toggleChildren");
    if (!button) throw new Error("Toggle button not found");
    button.click();
  }

  // lib/modules/neverEndingReddit.js
  var neverEndingReddit_exports = {};
  __export(neverEndingReddit_exports, {
    getNextPrevLinks: () => getNextPrevLinks,
    loadNextPage: () => loadNextPage,
    module: () => module26
  });
  var module26 = new Module("neverEndingReddit");
  module26.moduleName = "nerName";
  module26.category = "browsingCategory";
  module26.description = "nerDesc";
  module26.options = {
    returnToPrevPage: {
      type: "boolean",
      value: true,
      description: "nerReturnToPrevPageDesc",
      title: "nerReturnToPrevPageTitle"
    },
    autoLoad: {
      type: "boolean",
      value: true,
      description: "nerAutoLoadDesc",
      title: "nerAutoLoadTitle"
    },
    pauseAfterEvery: {
      dependsOn: (options6) => options6.autoLoad.value,
      type: "text",
      value: "0",
      description: "nerPauseAfterEveryDesc",
      title: "nerPauseAfterEveryTitle"
    },
    showPauseButton: {
      dependsOn: (options6) => options6.autoLoad.value,
      type: "boolean",
      value: true,
      description: "nerShowPauseButtonDesc",
      title: "nerShowPauseButtonTitle"
    },
    reversePauseIcon: {
      dependsOn: (options6) => options6.autoLoad.value && options6.showPauseButton.value,
      type: "boolean",
      value: false,
      description: "nerReversePauseIconDesc",
      title: "nerReversePauseIconTitle",
      advanced: true
    },
    showServerInfo: {
      type: "boolean",
      value: false,
      description: "nerShowServerInfoDesc",
      title: "nerShowServerInfoTitle",
      advanced: true,
      bodyClass: true
    }
  };
  module26.exclude = [
    "wiki",
    "comments",
    "d2x"
  ];
  module26.shouldRun = () => !isCurrentSubreddit("dashboard");
  var pauseReasonStorage = storage_exports.wrap("RESmodules.neverEndingReddit.pauseReason", void 0);
  var pauseReason;
  var initialLoadPromise;
  module26.contentStart = async () => {
    if (module26.options.returnToPrevPage.value) {
      const { ner: { number, url } = {} } = history.state || {};
      if (number && url && isNerUrl()) {
        initialLoadPromise = loadPage(url, number, pagePhases_exports.contentLoaded).catch(console.error);
      }
    }
    if (module26.options.autoLoad.value) {
      setPause(await pauseReasonStorage.get());
    }
  };
  module26.go = async () => {
    pages[0] = { url: location.pathname, container: container(), nextPageUrl: retrieveNextPageUrl(container()) };
    if (module26.options.returnToPrevPage.value) {
      selectedThing_exports.addListener(setReturnToPage, "instantly");
    }
    await initialLoadPromise;
    prepareNextPageLoad(false);
  };
  var container = once_default(() => getLastSiteTable() || document.createElement("div"));
  var pages = [];
  function retrieveNextPageUrl(container2) {
    const { buttons, next } = getNextPrevLinks(container2);
    if (buttons) buttons.hidden = true;
    return next;
  }
  var getNextPageUrl = (page = pages.slice(-1)[0]) => page.nextPageUrl;
  var loadNextPage = () => {
  };
  var refreshAutoLoad;
  function prepareNextPageLoad(displayEndBanner = true) {
    const nextPageUrl = getNextPageUrl();
    if (!nextPageUrl) {
      if (displayEndBanner) endNER("No more pages");
      return;
    }
    const pauseAfterPages = parseInt(module26.options.pauseAfterEvery.value, 10);
    if (module26.options.autoLoad.value && pauseAfterPages) {
      if (pages.length % pauseAfterPages === 0) setPause("pauseAfterEvery");
      else if (pauseReason === "pauseAfterEvery") setPause(null);
    }
    const startPromise = new Promise((res) => {
      loadNextPage = res;
    });
    const donePromise = startPromise.then(() => loadPage(nextPageUrl, pages.length)).then(prepareNextPageLoad).catch((e2) => {
      endNER(`Could not load the next page: ${e2.message}`);
      console.error(e2);
    });
    createLoaderWidget(startPromise, donePromise);
    if (refreshAutoLoad) refreshAutoLoad(false);
  }
  var pauseButton = once_default(() => {
    const element = string_exports.html`<span id="NREPause" title="Pause / Restart Never Ending Reddit"></span>`;
    element.addEventListener("click", () => setPause(pauseReason ? null : "manual"));
    addFloater(element, { container: "visibleAfterScroll" });
    return element;
  });
  function setPause(source) {
    if (module26.options.showPauseButton.value) {
      pauseButton().classList.toggle("paused", module26.options.reversePauseIcon.value === !source);
    }
    pauseReason = source;
    if (pauseReason) pauseReasonStorage.set(source);
    else pauseReasonStorage.delete();
    if (refreshAutoLoad) refreshAutoLoad();
  }
  var pageMarkers = document.getElementsByClassName("NERPageMarker");
  var isNerUrl = () => location.hash.startsWith(RES_NER_PAGE_HASH);
  function setReturnToPage(selected) {
    if (!document.contains(selected.element)) return;
    let number = 0;
    const earlierMarkers = [...pageMarkers].filter((_marker) => selected.element.compareDocumentPosition(_marker) & 3);
    if (earlierMarkers.length) number = parseInt(earlierMarkers.slice(-1)[0].dataset.number, 10);
    const { ner: saved } = history.state || {};
    if (saved && saved.number === number) return;
    if (earlierMarkers.length > 1) history.scrollRestoration = "manual";
    const page = pages[number];
    history.replaceState(
      { ...history.state, ner: { number, url: page.url, nextPageUrl: page.nextPageUrl } },
      `${document.title}${number ? `- page ${number + 1}` : ""}`,
      number ? `${RES_NER_PAGE_HASH}=${number + 1}` : `${location.pathname}${location.search}${isNerUrl() ? "" : location.hash}`
    );
  }
  function getLastSiteTable(body = document.body) {
    const selector = ".sitetable, .search-result-group";
    const elements = Array.from(body.querySelectorAll(selector)).reverse();
    for (const element of elements) {
      if (!element.parentElement || !element.parentElement.closest(selector)) return element;
    }
  }
  function getNextPrevLinks(ele = document.body) {
    const buttons = ele.matches(".modactionlisting") ? (
      // /about/log differs from other pages
      ele.nextElementSibling
    ) : ele.querySelector(".nav-buttons");
    return buttons ? {
      buttons,
      next: (buttons.querySelector("a[rel~=next]") || {}).href,
      prev: (buttons.querySelector("a[rel~=prev]") || {}).href
    } : {};
  }
  function setLoaderWidgetActionText(widget) {
    empty(widget);
    widget.append(...string_exports.html`<span>
		<h2>
			Never Ending Reddit
			${string_exports.safe(makeUrlHashLink(module26.moduleID, void 0, " ", "gearIcon"))}
		</h2>
		<p>
			Click here to just load the next page;
			${pauseReason ? string_exports.safe(`or click ${pauseButton().outerHTML} in the top right corner;`) : null}
		</p>
		<p>
			<a id="NERStaticLink" href="${getNextPageUrl() || ""}">or open next page</a> (and clear Never-Ending stream)
		</p>
	</span>`.children);
  }
  function createLoaderWidget(startPromise, donePromise) {
    const widget = document.createElement("div");
    widget.id = "progressIndicator";
    widget.className = "neverEndingReddit";
    widget.addEventListener("click", (e2) => {
      if (e2.target.tagName === "A") return;
      loadNextPage();
    });
    startPromise.then(({ scrollToLoadWidget = false } = {}) => {
      empty(widget);
      widget.append(string_exports.html`<span class="RESLoadingSpinner"></span>`);
      if (scrollToLoadWidget) scrollToElement(widget, null, { scrollStyle: "middle", direction: "down" });
    });
    const removeWidget2 = () => widget.remove();
    donePromise.finally(removeWidget2);
    const prefetchIo = new IntersectionObserver(([{ isIntersecting }]) => {
      if (!isIntersecting) return;
      prefetchNextPage();
    }, { rootMargin: "100%" });
    prefetchIo.observe(widget);
    const displayPauseReason = once_default(
      (pauseReason2) => showNotification({
        moduleID: module26.moduleID,
        notificationID: pauseReason2,
        message: pauseReason2 === "pauseAfterEvery" ? `
				<p>Time for a break!</p>
				<p>Never-Ending Reddit has been paused because you've passed ${module26.options.pauseAfterEvery.value} pages.</p>
			` : `<p>Never-Ending Reddit is paused. Click ${pauseButton().outerHTML} button in the top right corner to unpause it.</p>`
      })
    );
    const pauseReasonIo = new IntersectionObserver(([{ isIntersecting }]) => {
      if (isIntersecting && pauseReason) displayPauseReason(pauseReason);
    }, { threshold: [1] });
    const loadNextPageIo = new IntersectionObserver(([{ isIntersecting }]) => {
      if (!isIntersecting) return;
      loadNextPage();
    }, { threshold: [1] });
    refreshAutoLoad = (updateWidget2 = true) => {
      const enabled2 = module26.options.autoLoad.value && !pauseReason;
      if (enabled2) loadNextPageIo.observe(widget);
      else loadNextPageIo.disconnect();
      if (updateWidget2) setLoaderWidgetActionText(widget);
      pauseReasonIo.observe(widget);
    };
    setLoaderWidgetActionText(widget);
    startPromise.then(() => {
      prefetchIo.disconnect();
      loadNextPageIo.disconnect();
      pauseReasonIo.disconnect();
      refreshAutoLoad = null;
    });
    pages.slice(-1)[0].container.append(widget);
  }
  var fetchPage = memoize_default((url) => ajax({ url, cacheFor: HOUR }));
  var prefetchNextPage = () => {
    const url = getNextPageUrl();
    if (url) fetchPage(url);
  };
  async function loadPage(url, number, waitToAppendPromise) {
    const html2 = (await fetchPage(url)).replace(/<style(.|\s)*?>|<link(.|\s)*?>|<script(.|\s)*?\/script>/g, "");
    const document2 = new DOMParser().parseFromString(html2, "text/html");
    if (data.username && data.username !== documentLoggedInUser(document2.body)) {
      throw new Error("Page loaded was not for current user");
    }
    const newSiteTable = getLastSiteTable(document2.body);
    if (!newSiteTable) throw Error("Could not find any siteTable");
    const noresults = newSiteTable.querySelector("#noresults");
    if (noresults) throw new Error(noresults.textContent);
    for (const { name: name2 } of newSiteTable.attributes) newSiteTable.removeAttribute(name2);
    pages[number] = { url, container: newSiteTable, nextPageUrl: retrieveNextPageUrl(newSiteTable) };
    await waitToAppendPromise;
    registerPage(newSiteTable);
    const pageMarker = string_exports.html`<div class="NERPageMarker" data-number="${number}">
		<a href="${pages[number].url}">Page ${number + 1}</a>
		${string_exports.safe(makeUrlHashLink(module26.moduleID, void 0, " ", "gearIcon"))}
	</div>`;
    const firstLen = [...container().getElementsByClassName("rank")].slice(-1)[0]?.textContent.length || 0;
    const lastLen = [...newSiteTable.getElementsByClassName("rank")].slice(-1)[0]?.textContent.length || 0;
    if (lastLen > firstLen) {
      addCSS(`body.res > .content .link .rank { width: ${(lastLen * 1.1).toFixed(1)}ex; }`);
    }
    container().append(pageMarker, newSiteTable);
    window.dispatchEvent(new Event("neverEndingLoad", { bubbles: true, cancelable: true }));
  }
  function endNER(text) {
    container().append(string_exports.html`<div class="NERPageMarker NERPageMarkerLast">
		${text}
		${string_exports.safe(makeUrlHashLink(module26.moduleID, void 0, " ", "gearIcon"))}
		<p class="nextprev">
			<a href="${location.href.split("#")[0]}">start over</a>
			<a href="${getNextPageUrl() || ""}">try again</a>
			<a target="_blank" rel="noopener noreferer" href="/r/Enhancement/wiki/faq/never_ending_reddit">learn more</a>
			<a href="/r/random">random subreddit</a>
		</p>
	</div>`);
  }

  // lib/modules/noParticipation.js
  var noParticipation_exports = {};
  __export(noParticipation_exports, {
    isVotingBlocked: () => isVotingBlocked,
    module: () => module27,
    nonNpLocation: () => nonNpLocation,
    notifyNoVote: () => notifyNoVote
  });
  var import_jquery20 = __toESM(require_jquery(), 1);
  var module27 = new Module("noParticipation");
  var urls = {
    moreinfo: "https://www.reddit.com/r/NoParticipation/wiki/intro"
  };
  module27.moduleName = "noPartName";
  module27.description = "noPartDesc";
  module27.category = "subredditsCategory";
  module27.options = {
    disableVoteButtons: {
      type: "boolean",
      value: false,
      description: "noPartDisableVoteButtonsDesc",
      title: "noPartDisableVoteButtonsTitle",
      bodyClass: true
    },
    disableCommentTextarea: {
      type: "boolean",
      value: false,
      description: "noPartDisableCommentTextareaDesc",
      title: "noPartDisableCommentTextareaTitle",
      bodyClass: true
    },
    evenIfSubscriber: {
      type: "boolean",
      value: false,
      description: "noPartEvenIfSubscriberDesc",
      title: "noPartEvenIfSubscriberTitle"
    },
    escapeNP: {
      type: "boolean",
      value: true,
      description: "noPartEscapeNPDesc",
      title: "noPartEscapeNPTitle"
    }
  };
  module27.shouldRun = () => isNpHostname(location.hostname);
  var boilerplateNotificationText = `
	<p>
		<div class="RES-spoiler">
			<label class="RES-spoiler-title">Hover here for more details</label>
			<div class="RES-spoiler-contents">
				You came to this page by following a <a href="${urls.moreinfo}" target="_blank" rel="noopener noreferer">NP</a> link, so you may be interfering with normal conversation.
				Please respect reddit's <a href="https://reddit.com/rules" target="_blank" rel="noopener noreferer">rules</a> by not commenting or voting. Violating these rules may get you banned.
				<a href="${urls.moreinfo}" target="_blank" rel="noopener noreferer">Find out more</a>
			</div>
		</div>
	</p>
`;
  var noParticipationActive;
  module27.contentStart = () => {
    if (module27.options.escapeNP.value) {
      (0, import_jquery20.default)(document.body).on("mousedown", "a", removeNpFromLink);
    }
    if (isNPIrrelevant()) {
      notifyNpIrrelevant();
    } else if (loggedInUser()) {
      if (isPageType("comments", "linklist") && !(document.body.classList.contains("front-page") || document.body.classList.contains("profile-page"))) {
        applyNoParticipationMode();
      } else {
        notifyNpIrrelevant();
      }
    }
  };
  function isNpHostname(hostname) {
    return /^(?:\w+-)?np(?:-\w+)?\./i.test(hostname);
  }
  function removeNpFromLink(e2) {
    const target = e2.currentTarget;
    if (!target.getAttribute("href").startsWith("/") && target.matches(".md a")) return;
    if (target.hostname.endsWith("np.reddit.com")) {
      target.hostname = "www.reddit.com";
    }
  }
  function isNPIrrelevant() {
    return !isPageType("comments") || isSubscriber() && !module27.options.evenIfSubscriber.value;
  }
  function isVotingBlocked() {
    return noParticipationActive && module27.options.disableVoteButtons.value;
  }
  function isSubscriber() {
    return document.body.classList.contains("subscriber");
  }
  function nonNpLocation(href = location.href) {
    const nonNpUrl = new URL(href, location.href);
    if (isNpHostname(nonNpUrl.hostname)) nonNpUrl.hostname = "www.reddit.com";
    return nonNpUrl.href;
  }
  function notifyNpIrrelevant() {
    const message = isSubscriber() ? `You're browsing in <a href="${urls.moreinfo}" target="_blank" rel="noopener noreferer">No Participation</a> mode, but you're a subscriber here.` : `You're still browsing in <a href="${urls.moreinfo}" target="_blank" rel="noopener noreferer">No Participation</a> mode, but it's no longer necessary.`;
    showNotification({
      moduleID: module27.moduleID,
      notificationID: "ok-participation",
      closeDelay: 3e3,
      header: "Okay to Participate",
      message: `${message} <p><a href="${nonNpLocation()}">Click here to return to normal reddit</a></p>`
    });
  }
  function notifyNpActive() {
    const message = isSubscriber() ? `
			<span class="res-icon">&#xF15A;</span>
			Please think before you comment or vote, and remember the subreddit's rules.
			Although you subscribe to this subreddit, you can still derail a particular thread.
			<p><a href="${nonNpLocation()}">Click here to return to normal reddit.</a></p>
		` : `
			<strong>
				<span class="res-icon">&#xF15A;</span>
				Do not vote or comment.
			</strong>
		`;
    showNotification({
      moduleID: module27.moduleID,
      notificationID: "no-participation",
      closeDelay: 1e4,
      header: "No Participation",
      message: `${message}${boilerplateNotificationText}`
    });
  }
  var votedOnButtons = [];
  async function notifyNoVote(voteButton) {
    const canUndoVote = voteButton && !voteButton.matches(".upmod, .downmod");
    if (voteButton) votedOnButtons.push(voteButton);
    const notification = await showNotification({
      moduleID: module27.moduleID,
      optionKey: "disableVoteButtons",
      cooldown: 5e3,
      header: "No Participation",
      message: `
			<strong><span class="res-icon">&#xF15A;</span> Do not vote.</strong>
			${boilerplateNotificationText}
			${canUndoVote ? '<p><button type="button" class="redButton" data-action="revertvote">Undo vote</button></p>' : ""}
		`
    });
    if (notification) {
      (0, import_jquery20.default)(notification.element).find("[data-action=revertvote]").on("click", () => {
        revertVote(votedOnButtons);
        notification.close();
      });
    }
  }
  var notifyNoComment = once_default(() => {
    showNotification({
      moduleID: module27.moduleID,
      optionKey: "disableCommentTextarea",
      header: "No Participation",
      message: `<strong><span class="res-icon">&#xF15A;</span> Do not comment.</strong>${boilerplateNotificationText}`
    });
  });
  function applyNoParticipationMode() {
    noParticipationActive = true;
    notifyNpActive();
    bodyClasses_exports.add("res-noParticipation");
    watchForVote();
    (0, import_jquery20.default)(document.body).on("keydown", commentTextareaSelector, (e2) => {
      notifyNoComment();
      if (module27.options.disableCommentTextarea.value) {
        downcast(e2.currentTarget, HTMLTextAreaElement).disabled = true;
      }
    });
  }
  function watchForVote() {
    (0, import_jquery20.default)(document.body).on("click", ".arrow", (e2) => {
      if (e2.currentTarget.classList.contains("up") || e2.currentTarget.classList.contains("down")) {
        notifyNoVote(e2.currentTarget);
      }
    });
  }
  function revertVote(voteButtons) {
    voteButtons.forEach((voteButton, index2) => {
      setTimeout(
        () => {
          if (voteButton.classList.contains("upmod") || voteButton.classList.contains("downmod")) {
            click(voteButton);
          }
        },
        index2 * 2e3
        /* respect API limits */
      );
    });
    showNotification({
      moduleID: module27.moduleID,
      optionKey: "disableVoteButtons",
      header: "No Participation",
      message: `
			${voteButtons.length > 1 ? "Your votes are being reverted." : "Your vote has been reverted."}
			Please remember not to vote!
			<p><a href="${urls.moreinfo}" target="_blank" rel="noopener noreferer">Find out more</a></p>
		`
    });
  }

  // lib/modules/saveComments.js
  var saveComments_exports = {};
  __export(saveComments_exports, {
    module: () => module29,
    showEducationalNotification: () => showEducationalNotification
  });
  var import_jquery21 = __toESM(require_jquery(), 1);
  var module29 = new Module("saveComments");
  module29.moduleName = "saveCommentsName";
  module29.description = "saveCommentsDesc";
  module29.category = "commentsCategory";
  module29.exclude = [
    "submit"
  ];
  var savedCommentStorage = storage_exports.wrapBlob("RESmodules.saveComments.savedComments", () => {
    throw new Error("Saved comment not found");
  });
  module29.beforeLoad = () => {
    watchForThings(["comment"], (thing) => {
      const sibling = thing.entry.querySelector(".comment-save-button");
      if (!sibling) return;
      sibling.after(saveElement());
    });
  };
  module29.contentStart = () => {
    if (isPageType("profile")) {
      createElement_exports.tabMenuItem({
        text: "saved - RES",
        onChange: () => {
          location.href = "/r/dashboard/#savedComments";
        }
      });
    }
    addDashboardTab("savedComments", "Saved Comments", module29.moduleID, async (tabPage) => (0, import_jquery21.default)(tabPage).append(await drawSavedComments()));
  };
  var saveElement = /* @__PURE__ */ ((e2) => () => preventCloning(e2().cloneNode(true)))(once_default(() => {
    (0, import_jquery21.default)(document.body).on("click", "li.saveComments", ({ currentTarget }) => {
      if (currentTarget.classList.contains("saved-RES")) return;
      const thing = Thing.checkedFrom(currentTarget);
      saveComment(thing);
      const a2 = currentTarget.firstElementChild;
      requestAnimationFrame(() => {
        a2.dataset.text = "saved-RES";
        a2.href = "/r/dashboard#savedComments";
      });
    });
    return string_exports.html`
		<li class="saveComments">
			<a class="RES-save noCtrlF" href="javascript:void 0" title="Save using RES - which is local only, but preserves the full text in case someone edits/deletes it" data-text="save-RES"></a>
		</li>
	`;
  }));
  async function saveComment(thing) {
    const permaLink = thing.getCommentPermalink();
    if (!permaLink) throw new Error("Comment lacks permalink");
    const textBody = thing.getTextBody();
    if (!textBody) throw new Error("Comment text body not found");
    const id2 = thing.getFullname().split("_").slice(-1)[0];
    if ((await savedCommentStorage.getAll()).hasOwnProperty(id2)) return;
    const comment = (0, import_jquery21.default)(textBody).clone();
    comment.find(".keyNavAnnotation, .expando-button, .res-expando-box, script, .userTagLink").remove();
    savedCommentStorage.set(id2, {
      href: permaLink.href,
      username: thing.getAuthor() || "[deleted]",
      comment: comment.html(),
      timeSaved: (/* @__PURE__ */ new Date()).toString()
    });
  }
  var savedCommentsTemplate = ({ comments, keyNavTip, moduleDescription }) => string_exports.html`
	<div id="res-saveComments" class="sitetable linklisting">
		${!comments.length && string_exports._html`
			<div class="res-module-description md">
				<h1>Saving comments with RES</h1>
				${string_exports.safe(markdown(moduleDescription))}
			</div>
		`}
		${keyNavTip && keyNavTip.map(({ keyNavHash, savePostKey, saveCommentKey, saveRESKey }) => string_exports._html`
			<div class="res-module-tip infobar">
				<p><i>Keyboard Shortcuts</i> <a class="gearIcon" href="${keyNavHash}" title="RES settings"></a></p>
				<ul>
					<li><b>${savePostKey}</b>: save a submission.</li>
					<li><b>${saveCommentKey}</b>: save a comment (to your reddit account).</li>
					<li><b>${saveRESKey}</b>: save a comment with RES.</li>
				</ul>
			</div>
		`)}
		<div class="res-saveComments-list">
			${comments.map(({ id: id2, link, username, dateTime, date, timeAgo, body }) => string_exports._html`
				<div class="entry res-savedComment">
					<div class="savedCommentHeader">
						<a href="${link}">
							<b>${username}</b>
							- saved <date title="${dateTime}" datetime="${date}">${timeAgo}</date> ago
						</a>
					</div>
					<div class="savedCommentBody md">${string_exports.safe(body)}</div>
					<div class="savedCommentFooter">
						<ul class="flat-list buttons">
							<li><a href="${link}">permalink</a></li>
							<li><a class="unsaveComment" href="#" data-unsaveID="${id2}">unsave-RES</a></li>
						</ul>
					</div>
				</div>
			`)}
		</div>
	</div>
`;
  var drawSavedComments = once_default(async () => {
    const savedComments = await savedCommentStorage.getAll();
    const comments = Object.entries(savedComments).map(([id2, { comment, href, username, timeSaved }]) => {
      const date = new Date(timeSaved);
      return {
        id: id2,
        link: href,
        username,
        date: formatDate(date),
        dateTime: formatDateTime(date),
        timeAgo: formatDateDiff(date),
        body: (typeof comment === "string" ? comment : "").replace(/<(script|iframe|video)(.|\s)*?\/(script|iframe|video)>/g, "")
      };
    });
    return (0, import_jquery21.default)(savedCommentsTemplate({
      moduleDescription: i18n(module29.description),
      keyNavTip: isEnabled(keyboardNav_exports) && [{
        keyNavHash: makeUrlHash(module28.moduleID, "savePost"),
        savePostKey: niceKeyCode(module28.options.savePost.value),
        saveCommentKey: niceKeyCode(module28.options.saveComment.value),
        saveRESKey: niceKeyCode(module28.options.saveRES.value)
      }],
      comments
    })).on("click", ".unsaveComment", (e2) => {
      e2.preventDefault();
      savedCommentStorage.delete(e2.currentTarget.dataset.unsaveid);
      e2.currentTarget.textContent = "removed";
    });
  });
  function showEducationalNotification() {
    showNotification({
      moduleID: module29.moduleID,
      optionKey: "savePost",
      notificationID: "saveRES-educational",
      closeDelay: 1e4,
      cooldown: 3 * WEEK,
      header: "Saving Posts and Comments",
      message: `
			<p>
				The keyboard shortcuts <b>"${niceKeyCode(module28.options.savePost.value)}"</b> (posts) and <b>"${niceKeyCode(module28.options.saveComment.value)}"</b> (comments) will save a post/comment to your reddit account (same as the "save" button).
				It will be accessible from anywhere that you're logged in, but the original text will not be preserved if it is edited or deleted.
			</p>
			<p>
				The keyboard shortcut <b>"${niceKeyCode(module28.options.saveRES.value)}"</b> will save a comment to RES (same as the "save-RES" button).
				It will only be available locally, but the original text will be preserved if the comment is edited or deleted.
			</p>
			<p>These shortcuts can be changed in the ${makeUrlHashLink(module28.moduleID, "savePost", "settings console")}.<p>
		`
    });
  }

  // lib/modules/showParent.js
  var showParent_exports = {};
  __export(showParent_exports, {
    module: () => module30,
    startHover: () => startHover
  });
  var import_jquery22 = __toESM(require_jquery(), 1);
  var module30 = new Module("showParent");
  module30.moduleName = "showParentName";
  module30.category = "myAccountCategory";
  module30.description = "showParentDesc";
  module30.options = {
    hoverDelay: {
      title: "showParentHoverDelayTitle",
      type: "text",
      value: "500",
      description: "showParentHoverDelayDesc",
      advanced: true
    },
    fadeDelay: {
      title: "showParentFadeDelayTitle",
      type: "text",
      value: "200",
      description: "showParentFadeDelayDesc",
      advanced: true
    },
    fadeSpeed: {
      title: "showParentFadeSpeedTitle",
      type: "text",
      value: "0.7",
      description: "showParentFadeSpeedDesc",
      advanced: true
    },
    direction: {
      title: "showParentDirectionTitle",
      type: "enum",
      value: "down",
      values: [{
        name: "Above",
        value: "up"
      }, {
        name: "Below",
        value: "down"
      }],
      description: "showParentDirectionDesc",
      bodyClass: true
    }
  };
  module30.include = [
    "comments"
  ];
  var hover2;
  module30.contentStart = () => {
    hover2 = infocard(module30.moduleID).options({
      openDelay: parseFloat(module30.options.hoverDelay.value),
      fadeDelay: parseFloat(module30.options.fadeDelay.value),
      fadeSpeed: parseFloat(module30.options.fadeSpeed.value)
    }).populateWith((card) => showCommentHover(Thing.checkedFrom(card.getCheckedTarget())));
    hover2.watch(".comment .buttons :not(:first-child) .bylink");
  };
  function startHover(button) {
    if (hover2) hover2.target(button).begin();
  }
  function handleVoteClick2() {
    const $this = (0, import_jquery22.default)(this);
    const voteClasses = {
      up: "likes",
      none: "unvoted",
      down: "dislikes"
    };
    const id2 = $this.parent().parent().attr("data-fullname");
    let direction = /(up|down)(?:mod)?/.exec(this.className);
    if (!direction) return;
    direction = direction[1];
    const $targetButton = (0, import_jquery22.default)(`.content .thing.id-${id2}`).children(".midcol").find(`.arrow.${direction}, .arrow.${direction}mod`);
    if ($targetButton.length !== 1) {
      console.error(
        "When attempting to find %s arrow for comment %s %d elements were returned",
        direction,
        id2,
        $targetButton.length
      );
      return;
    }
    function removeClickHandlers(event) {
      event.stopPropagation();
    }
    $targetButton.on("click", removeClickHandlers);
    $targetButton.click();
    $targetButton.off("click", removeClickHandlers);
    const $midcol = $this.parent();
    let startDir = "none";
    for (const [key, value] of Object.entries(voteClasses)) {
      if ($midcol.hasClass(value)) {
        startDir = key;
        break;
      }
    }
    const newDir = direction === startDir ? "none" : direction;
    $midcol.parent().children(`.${voteClasses[startDir]}`).removeClass(voteClasses[startDir]).addClass(voteClasses[newDir]);
    $midcol.find(".up, .upmod").toggleClass("upmod", newDir === "up").toggleClass("up", newDir !== "up");
    $midcol.find(".down, .downmod").toggleClass("downmod", newDir === "down").toggleClass("down", newDir !== "down");
  }
  function showCommentHover(thing) {
    const direction = module30.options.direction.value;
    let $parents = (0, import_jquery22.default)(thing.element).parents(".thing").clone();
    let topParentURL = "";
    if ($parents.length === 0) {
      topParentURL = (0, import_jquery22.default)(thing.element).find('[data-event-action="parent"]').first().attr("data-href-url");
    } else {
      const topParentId = $parents.last().attr("data-fullname");
      topParentURL = (0, import_jquery22.default)(`[data-fullname="${topParentId}"] > .entry [data-event-action="parent"]`).first().attr("data-href-url");
    }
    if (direction === "up") {
      $parents = (0, import_jquery22.default)($parents.get().reverse());
    }
    $parents.addClass("comment parentComment").removeClass("thing even odd");
    $parents.children(".child").remove();
    $parents.each(function() {
      const $this = (0, import_jquery22.default)(this);
      $this.off("click");
      let id2 = $this.attr("data-fullname");
      if (id2) {
        id2 = id2.slice(3);
        $this.find("> .entry .tagline").append(`<a class="bylink parentlink" href="#${id2}">goto comment</a>`);
      }
    });
    $parents.find(".parent").remove();
    $parents.find(".usertext-body").show();
    $parents.find(".flat-list.buttons").remove();
    $parents.find(".usertext-edit").remove();
    $parents.find(".RESUserTag").remove();
    $parents.find(".voteWeight").remove();
    $parents.find(".collapsed").remove();
    $parents.find(".expand").remove();
    $parents.find("form").attr("id", "");
    $parents.find(".arrow").on("click", handleVoteClick2);
    $parents.find(".res-expando-box, .expando-button").remove();
    $parents.find(".keyNavAnnotation").remove();
    const $container = (0, import_jquery22.default)('<div class="parentCommentWrapper">');
    $container.append($parents);
    if (topParentURL) {
      $container.append(`<a class="bylink" href="${topParentURL}">View parent comment</a>`);
    }
    $parents.slice(0, -1).after('<div class="parentArrow">reply to</div>');
    return ["Parents", $container];
  }

  // lib/modules/singleClick.js
  var singleClick_exports = {};
  __export(singleClick_exports, {
    invokeOnPostMap: () => invokeOnPostMap,
    module: () => module31
  });
  var module31 = new Module("singleClick");
  module31.moduleName = "singleClickName";
  module31.category = "browsingCategory";
  module31.description = "singleClickDesc";
  module31.options = {
    openOrder: {
      title: "singleClickOpenOrderTitle",
      type: "enum",
      values: [{
        name: "open comments then link",
        value: "commentsfirst"
      }, {
        name: "open link then comments",
        value: "linkfirst"
      }],
      value: "commentsfirst",
      description: "singleClickOpenOrderDesc"
    },
    hideLEC: {
      title: "singleClickHideLECTitle",
      type: "boolean",
      value: true,
      description: "singleClickHideLECDesc",
      advanced: true
    },
    openFrontpage: {
      title: "singleClickOpenFrontpageTitle",
      type: "boolean",
      value: false,
      description: "singleClickOpenFrontpageDesc",
      dependsOn: (options6) => !options6.hideLEC.value
    },
    openBackground: {
      title: "singleClickOpenBackgroundTitle",
      type: "boolean",
      value: false,
      description: "singleClickOpenBackgroundDesc"
    }
  };
  module31.exclude = [
    "comments"
  ];
  var invokeOnPostMap = /* @__PURE__ */ new WeakMap();
  module31.beforeLoad = () => {
    watchForThings(["post"], (thing) => {
      const urls2 = /* @__PURE__ */ new Set([thing.getPostUrl()]);
      if (thing.isLinkPost()) {
        const a2 = thing.getCommentsLink();
        if (a2) urls2.add(a2.href);
      } else if (module31.options.openFrontpage.value) {
        const frontpageLink = thing.getSubredditLink();
        if (frontpageLink) urls2.add(frontpageLink.href);
      }
      const ordered = (module31.options.openOrder.value === "commentsfirst" ? [...urls2].reverse() : [...urls2]).filter(Boolean);
      const open4 = (focused) => {
        openNewTabs(focused, ...ordered);
      };
      invokeOnPostMap.set(thing, open4);
      if (!ordered.length || module31.options.hideLEC.value && ordered.length === 1) return;
      const text = ordered.length === 1 ? "[l=c]" : "[l+c]";
      const ele = string_exports.html`<li><a href="javascript:void(0)" class="noCtrlF" data-text="${text}"></a></li>`;
      ele.firstElementChild.addEventListener("auxclick", (e2) => {
        e2.preventDefault();
      });
      ele.firstElementChild.addEventListener("mouseup", (e2) => {
        if (e2.button !== 0 && e2.button !== 1) return;
        e2.preventDefault();
        const focused = !e2.button && !e2.ctrlKey && !module31.options.openBackground.value;
        open4(focused);
      });
      thing.getButtons().append(ele);
    });
  };

  // lib/modules/keyboardNav.js
  var module28 = new Module("keyboardNav");
  module28.moduleName = "keyboardNavName";
  module28.category = "browsingCategory";
  module28.description = "keyboardNavDesc";
  module28.options = {
    linearScrollStyle: {
      type: "enum",
      values: [{
        name: "directional",
        value: "directional"
      }, {
        name: "page up/down",
        value: "page"
      }, {
        name: "lock to top",
        value: "top"
      }, {
        name: "in middle",
        value: "middle"
      }, {
        name: "adopt top",
        value: "adopt"
      }, {
        name: "legacy",
        value: "legacy"
      }],
      value: "directional",
      description: "keyboardNavLinearScrollStyleDesc",
      title: "keyboardNavLinearScrollStyleTitle"
    },
    nonLinearScrollStyle: {
      type: "enum",
      values: [{
        name: "directional",
        value: "directional"
      }, {
        name: "page up/down",
        value: "page"
      }, {
        name: "lock to top",
        value: "top"
      }, {
        name: "in middle",
        value: "middle"
      }, {
        name: "adopt top",
        value: "adopt"
      }, {
        name: "legacy",
        value: "legacy"
      }],
      value: "legacy",
      description: "keyboardNavNonLinearScrollStyleDesc",
      title: "keyboardNavNonLinearScrollStyleTitle"
    },
    linkNumbers: {
      type: "boolean",
      value: true,
      description: "keyboardNavLinkNumbersDesc",
      title: "keyboardNavLinkNumbersTitle"
    },
    linkNumberPosition: {
      dependsOn: (options6) => options6.linkNumbers.value,
      type: "enum",
      values: [{
        name: "Place on right",
        value: "right"
      }, {
        name: "Place on left",
        value: "left"
      }],
      value: "right",
      description: "keyboardNavLinkNumberPositionDesc",
      title: "keyboardNavLinkNumberPositionTitle",
      advanced: true
    },
    linkToggleExpando: {
      dependsOn: (options6) => options6.linkNumbers.value,
      type: "boolean",
      value: true,
      description: "keyboardNavLinkToggleExpandoDesc",
      title: "keyboardNavLinkToggleExpandoTitle"
    },
    linkNumberAltModeModifier: {
      dependsOn: (options6) => options6.linkNumbers.value,
      type: "enum",
      values: [{
        name: "none",
        value: "none"
      }, {
        name: "Shift",
        value: "shift"
      }, {
        name: "Alt",
        value: "alt"
      }],
      value: "alt",
      description: "keyboardNavLinkNumberAltModeModifierDesc",
      title: "keyboardNavLinkNumberAltModeModifierTitle",
      advanced: true
    },
    linkNewTab: {
      dependsOn: (options6) => options6.linkNumbers.value,
      type: "boolean",
      value: true,
      description: "keyboardNavLinkNewTabDesc",
      title: "keyboardNavLinkNewTabTitle",
      advanced: true
    },
    onHideMoveDown: {
      type: "boolean",
      value: true,
      description: "keyboardNavOnHideMoveDownDesc",
      title: "keyboardNavOnHideMoveDownTitle",
      advanced: true
    },
    onVoteMoveDown: {
      type: "boolean",
      value: false,
      description: "keyboardNavOnVoteMoveDownDesc",
      title: "keyboardNavOnVoteMoveDownTitle",
      advanced: true
    },
    onVoteCommentMoveDown: {
      type: "boolean",
      value: false,
      description: "keyboardNavOnVoteCommentMoveDownDesc",
      title: "keyboardNavOnVoteCommentMoveDownTitle",
      advanced: true
    },
    followLinkNewTabFocus: {
      type: "boolean",
      value: true,
      description: "keyboardNavFollowLinkNewTabFocusDesc",
      title: "keyboardNavFollowLinkNewTabFocusTitle"
    },
    toggleHelp: {
      type: "keycode",
      value: [191, false, false, true, false],
      // ? (note the true in the shift slot)
      description: "keyboardNavToggleHelpDesc",
      title: "keyboardNavToggleHelpTitle",
      callback() {
        toggleKeyNavHelp();
      }
    },
    toggleCmdLine: {
      type: "keycode",
      requiresModules: [commandLine_exports],
      value: [190, false, false, false, false],
      // .
      description: "keyboardNavToggleCmdLineDesc",
      title: "keyboardNavToggleCmdLineTitle",
      callback() {
        toggle2();
      }
    },
    enterFilterCommandLine: {
      type: "keycode",
      requiresModules: [commandLine_exports, filteReddit_exports],
      value: [70, false, false, false, false],
      // f
      description: "keyboardNavEnterFilterCommandLineDesc",
      title: "keyboardNavEnterFilterCommandLineTitle",
      callback() {
        open2("fl ");
      }
    },
    hide: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile"],
      value: [72, false, false, false, false],
      // h
      description: "keyboardNavHideDesc",
      title: "keyboardNavHideTitle",
      callback: hideLink
    },
    moveUp: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile", "search"],
      value: [75, false, false, false, false],
      // k
      description: "keyboardNavMoveUpDesc",
      title: "keyboardNavMoveUpTitle",
      callback() {
        selectedThing_exports.move("up", { allowMediaBrowse: true, scrollStyle: module28.options.linearScrollStyle.value });
      }
    },
    moveDown: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile", "search"],
      value: [74, false, false, false, false],
      // j
      description: "keyboardNavMoveDownDesc",
      title: "keyboardNavMoveDownTitle",
      callback() {
        selectedThing_exports.move("down", { allowMediaBrowse: true, scrollStyle: module28.options.linearScrollStyle.value }, moveDownFallback);
      }
    },
    moveUpComment: {
      type: "keycode",
      include: ["comments", "commentsLinklist", "inbox"],
      value: [75, false, false, false, false],
      // k
      description: "keyboardNavMoveUpCommentDesc",
      title: "keyboardNavMoveUpCommentTitle",
      callback() {
        selectedThing_exports.move("up", { scrollStyle: module28.options.linearScrollStyle.value });
      }
    },
    moveDownComment: {
      type: "keycode",
      include: ["comments", "commentsLinklist", "inbox"],
      value: [74, false, false, false, false],
      // j
      description: "keyboardNavMoveDownCommentDesc",
      title: "keyboardNavMoveDownCommentTitle",
      callback() {
        selectedThing_exports.move("down", { scrollStyle: module28.options.linearScrollStyle.value });
      }
    },
    moveTop: {
      type: "keycode",
      include: ["linklist", "commentsLinklist", "modqueue", "profile", "inbox", "search"],
      value: [75, false, false, true, false],
      // shift-k
      description: "keyboardNavMoveTopDesc",
      title: "keyboardNavMoveTopTitle",
      callback() {
        selectedThing_exports.move("top", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    moveBottom: {
      type: "keycode",
      include: ["linklist", "commentsLinklist", "modqueue", "profile", "inbox", "search"],
      value: [74, false, false, true, false],
      // shift-j
      description: "keyboardNavMoveBottomDesc",
      title: "keyboardNavMoveBottomTitle",
      callback() {
        selectedThing_exports.move("bottom", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    moveUpSibling: {
      type: "keycode",
      include: ["comments"],
      value: [75, false, false, true, false],
      // shift-k
      description: "keyboardNavMoveUpSiblingDesc",
      title: "keyboardNavMoveUpSiblingTitle",
      callback() {
        selectedThing_exports.move("upSibling", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    moveDownSibling: {
      type: "keycode",
      include: ["comments"],
      value: [74, false, false, true, false],
      // shift-j
      description: "keyboardNavMoveDownSiblingDesc",
      title: "keyboardNavMoveDownSiblingTitle",
      callback() {
        selectedThing_exports.move("downSibling", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    moveDownParentSibling: {
      type: "keycode",
      include: ["comments"],
      value: [74, true, false, false, false],
      // alt-j
      description: "keyboardNavMoveDownParentSiblingDesc",
      title: "keyboardNavMoveDownParentSiblingTitle",
      callback() {
        selectedThing_exports.move("downParentSibling", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    moveUpThread: {
      type: "keycode",
      include: ["comments"],
      value: [75, true, false, true, false],
      // shift-alt-k
      description: "keyboardNavMoveUpThreadDesc",
      title: "keyboardNavMoveUpThreadTitle",
      callback() {
        selectedThing_exports.move("upThread", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    moveDownThread: {
      type: "keycode",
      include: ["comments"],
      value: [74, true, false, true, false],
      // shift-alt-j
      description: "keyboardNavMoveDownThreadDesc",
      title: "keyboardNavMoveDownThreadTitle",
      callback() {
        selectedThing_exports.move("downThread", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    moveToTopComment: {
      type: "keycode",
      include: ["comments"],
      value: [84, false, false, false, false],
      // t
      description: "keyboardNavMoveToTopCommentDesc",
      title: "keyboardNavMoveToTopCommentTitle",
      callback() {
        selectedThing_exports.move("toTopComment", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    moveToParent: {
      type: "keycode",
      include: ["comments"],
      value: [80, false, false, false, false],
      // p
      description: "keyboardNavMoveToParentDesc",
      title: "keyboardNavMoveToParentTitle",
      callback() {
        selectedThing_exports.move("toParent", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    undoMove: {
      type: "keycode",
      value: [90, false, true, false, false],
      // ctrl-z
      description: "keyboardNavUndoMoveDesc",
      title: "keyboardNavUndoMoveTitle",
      callback() {
        selectedThing_exports.move("previous", { scrollStyle: module28.options.nonLinearScrollStyle.value });
      }
    },
    showParents: {
      type: "keycode",
      requiresModules: [showParent_exports],
      value: [80, false, false, true, false],
      // p
      description: "keyboardNavShowParentsDesc",
      title: "keyboardNavShowParentsTitle",
      callback(selected = getSelected()) {
        startHover(assertElement(selected.element.querySelector('.buttons .bylink[href^="#"]')));
      }
    },
    followLink: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile", "comments", "search"],
      value: [13, false, false, false, false],
      // enter
      description: "keyboardNavFollowLinkDesc",
      title: "keyboardNavFollowLinkTitle",
      callback() {
        followLink();
      }
    },
    followLinkNewTab: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile", "comments", "search"],
      value: [13, false, false, true, false],
      // shift-enter
      description: "keyboardNavFollowLinkNewTabDesc",
      title: "keyboardNavFollowLinkNewTabTitle",
      callback() {
        followLink(true);
      }
    },
    toggleExpando: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [88, false, false, false, false],
      // x
      description: "keyboardNavToggleExpandoDesc",
      title: "keyboardNavToggleExpandoTitle",
      callback(selected = getSelected()) {
        toggleThingExpandos(selected, {
          scrollOnToggle: module28.options.scrollOnExpando.value
        });
      }
    },
    scrollOnExpando: {
      type: "boolean",
      value: true,
      description: "keyboardNavScrollOnExpandoDesc",
      title: "keyboardNavScrollOnExpandoTitle",
      advanced: true
    },
    imageSizeUp: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [187, false, false, false, false],
      // = -- 61 in firefox
      description: "keyboardNavImageSizeUpDesc",
      title: "keyboardNavImageSizeUpTitle",
      callback() {
        imageResize({ factor: 1.3 });
      }
    },
    imageSizeDown: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [189, false, false, false, false],
      // - -- 173 in firefox
      description: "keyboardNavImageSizeDownDesc",
      title: "keyboardNavImageSizeDownTitle",
      callback() {
        imageResize({ factor: 1 / 1.3 });
      }
    },
    imageSizeUpFine: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [187, false, false, true, false],
      // shift-=
      description: "keyboardNavImageSizeUpFineDesc",
      title: "keyboardNavImageSizeUpFineTitle",
      callback() {
        imageResize({ factor: 1.1 });
      }
    },
    imageSizeDownFine: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [189, false, false, true, false],
      // shift--
      description: "keyboardNavImageSizeDownFineDesc",
      title: "keyboardNavImageSizeDownFineTitle",
      callback() {
        imageResize({ factor: 1 / 1.1 });
      }
    },
    imageSizeAnyHeight: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [39, false, false, true, false],
      // shift-right
      description: "keyboardNavImageSizeAnyHeightDesc",
      title: "keyboardNavImageSizeAnyHeightTitle",
      callback() {
        imageResize({ removeHeightRestriction: true });
      }
    },
    imageMoveUp: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [38, false, true, false, false],
      // ctrl-up
      description: "keyboardNavImageMoveUpDesc",
      title: "keyboardNavImageMoveUpTitle",
      callback() {
        imageMove(0, -50);
      }
    },
    imageMoveDown: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [40, false, true, false, false],
      // ctrl-down
      description: "keyboardNavImageMoveDownDesc",
      title: "keyboardNavImageMoveDownTitle",
      callback() {
        imageMove(0, 50);
      }
    },
    imageMoveLeft: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [37, false, true, false, false],
      // ctrl-left
      description: "keyboardNavImageMoveLeftDesc",
      title: "keyboardNavImageMoveLeftTitle",
      callback() {
        imageMove(-50, 0);
      }
    },
    imageMoveRight: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [39, false, true, false, false],
      // ctrl-right
      description: "keyboardNavImageMoveRightDesc",
      title: "keyboardNavImageMoveRightTitle",
      callback() {
        imageMove(50, 0);
      }
    },
    previousGalleryImage: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [219, false, false, false, false],
      // [
      description: "keyboardNavPreviousGalleryImageDesc",
      title: "keyboardNavPreviousGalleryImageTitle",
      callback() {
        navigateGallery("previous");
      }
    },
    nextGalleryImage: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [221, false, false, false, false],
      // ]
      description: "keyboardNavNextGalleryImageDesc",
      title: "keyboardNavNextGalleryImageTitle",
      callback() {
        navigateGallery("next");
      }
    },
    scrollOnGalleryNavigate: {
      type: "boolean",
      value: true,
      description: "keyboardNavScrollOnGalleryNavigateDesc",
      title: "keyboardNavScrollOnGalleryNavigateTitle",
      advanced: true
    },
    toggleViewImages: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [88, false, false, true, false],
      // shift-x
      description: "keyboardNavToggleViewImagesDesc",
      title: "keyboardNavToggleViewImagesTitle",
      callback() {
        viewImagesButton().click();
      }
    },
    toggleMuteVideo: {
      type: "keycode",
      requiresModules: [showImages_exports],
      value: [77, false, false, false, false],
      // m
      description: "keyboardNavToggleMuteVideoDesc",
      title: "keyboardNavToggleMuteVideoTitle",
      callback() {
        videoToggleMute();
      }
    },
    toggleChildren: {
      type: "keycode",
      include: [
        "comments",
        "inbox"
        /* mostly modmail */
      ],
      value: [13, false, false, false, false],
      // enter
      description: "keyboardNavToggleChildrenDesc",
      title: "keyboardNavToggleChildrenTitle",
      callback: toggleChildren
    },
    followComments: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile", "search"],
      value: [67, false, false, false, false],
      // c
      description: "keyboardNavFollowCommentsDesc",
      title: "keyboardNavFollowCommentsTitle",
      callback() {
        followComments();
      }
    },
    followCommentsNewTab: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile", "search"],
      value: [67, false, false, true, false],
      // shift-c
      description: "keyboardNavFollowCommentsNewTabDesc",
      title: "keyboardNavFollowCommentsNewTabTitle",
      callback() {
        followComments(true);
      }
    },
    followLinkAndCommentsNewTab: {
      type: "keycode",
      requiresModules: [singleClick_exports],
      value: [76, false, false, false, false],
      // l
      description: "keyboardNavFollowLinkAndCommentsNewTabDesc",
      title: "keyboardNavFollowLinkAndCommentsNewTabTitle",
      callback() {
        invokeOnPostMap.get(getSelected())(true);
      }
    },
    followLinkAndCommentsNewTabBG: {
      type: "keycode",
      requiresModules: [singleClick_exports],
      value: [76, false, false, true, false],
      // shift-l
      description: "keyboardNavFollowLinkAndCommentsNewTabBGDesc",
      title: "keyboardNavFollowLinkAndCommentsNewTabBGTitle",
      callback() {
        invokeOnPostMap.get(getSelected())(false);
      }
    },
    upVote: {
      type: "keycode",
      include: ["linklist", "commentsLinklist", "modqueue", "profile", "comments", "inbox", "search"],
      value: [65, false, false, false, false],
      // a
      description: "keyboardNavUpVoteDesc",
      title: "keyboardNavUpVoteTitle",
      mustBeLoggedIn: true,
      callback() {
        vote("upmod");
      }
    },
    downVote: {
      type: "keycode",
      include: ["linklist", "commentsLinklist", "modqueue", "profile", "comments", "inbox", "search"],
      value: [90, false, false, false, false],
      // z
      description: "keyboardNavDownVoteDesc",
      title: "keyboardNavDownVoteTitle",
      mustBeLoggedIn: true,
      callback() {
        vote("downmod");
      }
    },
    upVoteWithoutToggling: {
      type: "keycode",
      include: ["linklist", "commentsLinklist", "modqueue", "profile", "comments", "inbox", "search"],
      value: [65, false, false, true, false],
      // a
      description: "keyboardNavUpVoteWithoutTogglingDesc",
      title: "keyboardNavUpVoteWithoutTogglingTitle",
      mustBeLoggedIn: true,
      callback() {
        vote("upmod", true);
      }
    },
    downVoteWithoutToggling: {
      type: "keycode",
      include: ["linklist", "commentsLinklist", "modqueue", "profile", "comments", "inbox", "search"],
      value: [90, false, false, true, false],
      // z
      description: "keyboardNavDownVoteWithoutTogglingDesc",
      title: "keyboardNavDownVoteWithoutTogglingTitle",
      mustBeLoggedIn: true,
      callback() {
        vote("downmod", true);
      }
    },
    savePost: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile", "comments"],
      value: [83, false, false, false, false],
      // s
      description: "keyboardNavSavePostDesc",
      title: "keyboardNavSavePostTitle",
      mustBeLoggedIn: true,
      callback() {
        click(getFirstElementInThingByQuery(".link-save-button a, .link-unsave-button a", ASSERT));
      }
    },
    saveComment: {
      type: "keycode",
      include: ["comments", "commentsLinklist"],
      value: [83, false, false, true, false],
      // shift-s
      description: "keyboardNavSaveCommentDesc",
      title: "keyboardNavSaveCommentTitle",
      mustBeLoggedIn: true,
      callback() {
        click(getFirstElementInThingByQuery(".comment-save-button > a", ASSERT));
      }
    },
    saveRES: {
      type: "keycode",
      requiresModules: [saveComments_exports],
      value: [83, false, false, false, false],
      // s
      description: "keyboardNavSaveRESDesc",
      title: "keyboardNavSaveRESTitle",
      callback() {
        click(getFirstElementInThingByQuery(".saveComments, .unsaveComments", ASSERT));
        showEducationalNotification();
      }
    },
    reply: {
      type: "keycode",
      include: ["comments", "inbox"],
      value: [82, false, false, false, false],
      // r
      description: "keyboardNavReplyDesc",
      title: "keyboardNavReplyTitle",
      mustBeLoggedIn: true,
      callback: reply
    },
    edit: {
      type: "keycode",
      include: ["comments", "profile"],
      value: [69, false, false, false, false],
      // e
      description: "keyboardNavEditDesc",
      title: "keyboardNavEditTitle",
      mustBeLoggedIn: true,
      callback() {
        click(getFirstElementInThingByQuery(".entry .edit-usertext", ASSERT, getSelected()));
      }
    },
    showChildComments: {
      type: "keycode",
      requiresModules: [hideChildComments_exports],
      value: [67, false, false, false, false],
      // c
      description: "keyboardNavShowChildCommentsDesc",
      title: "keyboardNavShowChildCommentsTitle",
      callback(selected = getSelected()) {
        toggle5(selected);
      }
    },
    showAllChildComments: {
      type: "keycode",
      requiresModules: [hideChildComments_exports],
      value: [67, false, false, true, false],
      // shift-c
      description: "keyboardNavShowAllChildCommentsDesc",
      title: "keyboardNavShowAllChildCommentsTitle",
      callback() {
        toggleAll();
      }
    },
    followPermalink: {
      type: "keycode",
      include: ["comments", "commentsLinklist", "inbox"],
      value: [89, false, false, false, false],
      // y
      description: "keyboardNavFollowPermalinkDesc",
      title: "keyboardNavFollowPermalinkTitle",
      callback() {
        followPermalink();
      }
    },
    followPermalinkNewTab: {
      type: "keycode",
      include: ["comments", "commentsLinklist", "inbox"],
      value: [89, false, false, true, false],
      // shift-y
      description: "keyboardNavFollowPermalinkNewTabDesc",
      title: "keyboardNavFollowPermalinkNewTabTitle",
      callback() {
        followPermalink(true);
      }
    },
    followSubreddit: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile", "search"],
      value: [82, false, false, false, false],
      // r
      description: "keyboardNavFollowSubredditDesc",
      title: "keyboardNavFollowSubredditTitle",
      callback() {
        followSubreddit();
      }
    },
    followSubredditNewTab: {
      type: "keycode",
      include: ["linklist", "modqueue", "profile", "search"],
      value: [82, false, false, true, false],
      // shift-r
      description: "keyboardNavFollowSubredditNewTabDesc",
      title: "keyboardNavFollowSubredditNewTabTitle",
      callback() {
        followSubreddit(true);
      }
    },
    followProfile: {
      type: "keycode",
      include: ["linklist", "comments", "commentsLinklist", "inbox", "modqueue", "search"],
      value: [85, false, false, false, false],
      // u
      description: "keyboardNavFollowProfileDesc",
      title: "keyboardNavFollowProfileTitle",
      callback() {
        followProfile();
      }
    },
    followProfileNewTab: {
      type: "keycode",
      include: ["linklist", "comments", "commentsLinklist", "inbox", "modqueue", "search"],
      value: [85, false, false, true, false],
      // shift-u
      description: "keyboardNavFollowProfileNewTabDesc",
      title: "keyboardNavFollowProfileNewTabTitle",
      callback() {
        followProfile(true);
      }
    },
    toggleCommentNavigator: {
      type: "keycode",
      requiresModules: [commentNavigator_exports],
      value: [78, false, false, false, false],
      // N
      description: "keyboardNavToggleCommentNavigatorDesc",
      title: "keyboardNavToggleCommentNavigatorTitle",
      callback() {
        toggle4(true);
      }
    },
    commentNavigatorMoveUp: {
      type: "keycode",
      requiresModules: [commentNavigator_exports],
      value: [38, false, false, true, false],
      // shift+up arrow
      description: "keyboardNavCommentNavigatorMoveUpDesc",
      title: "keyboardNavCommentNavigatorMoveUpTitle",
      callback() {
        move3("up", "keyboard");
      }
    },
    commentNavigatorMoveDown: {
      type: "keycode",
      requiresModules: [commentNavigator_exports],
      value: [40, false, false, true, false],
      // shift+down arrow
      description: "keyboardNavCommentNavigatorMoveDownDesc",
      title: "keyboardNavCommentNavigatorMoveDownTitle",
      callback() {
        move3("down", "keyboard");
      }
    },
    focusOnSearchBox: {
      type: "keycode",
      value: [191, true, false, false, false],
      // alt-/
      description: "keyboardNavFocusOnSearchBoxDesc",
      title: "keyboardNavFocusOnSearchBoxTitle",
      callback() {
        document.querySelector('#search input[name="q"]').focus();
      }
    },
    useGoMode: {
      type: "boolean",
      value: true,
      description: "keyboardNavUseGoModeDesc",
      title: "keyboardNavUseGoModeTitle"
    },
    goMode: {
      type: "keycode",
      value: [71, false, false, false, false],
      // g
      description: "keyboardNavGoModeDesc",
      title: "keyboardNavGoModeTitle",
      dependsOn: (options6) => options6.useGoMode.value,
      callback() {
        if (module28.options.useGoMode.value) toggleGoMode();
      }
    },
    inbox: {
      type: "keycode",
      value: [73, false, false, false, false],
      // i
      description: "keyboardNavInboxDesc",
      title: "keyboardNavInboxTitle",
      callback() {
        navigateTo2("/message/inbox/", { leaveNP: true });
      },
      goMode: true
    },
    inboxNewTab: {
      type: "keycode",
      value: [73, false, false, true, false],
      // shift+i
      description: "keyboardNavInboxNewTabDesc",
      title: "keyboardNavInboxNewTabTitle",
      callback() {
        navigateTo2("/message/inbox/", { newWindow: true, leaveNP: true });
      },
      goMode: true
    },
    modmail: {
      type: "keycode",
      value: [77, false, false, false, false],
      // m
      description: "keyboardNavModmailDesc",
      title: "keyboardNavModmailTitle",
      callback() {
        navigateTo2("/message/moderator/", { leaveNP: true });
      },
      goMode: true
    },
    modmailNewTab: {
      type: "keycode",
      value: [77, false, false, true, false],
      // shift+m
      description: "keyboardNavModmailNewTabDesc",
      title: "keyboardNavModmailNewTabTitle",
      callback() {
        navigateTo2("/message/moderator/", { newWindow: true, leaveNP: true });
      },
      goMode: true
    },
    profile: {
      type: "keycode",
      value: [85, false, false, false, false],
      // u
      description: "keyboardNavProfileDesc",
      title: "keyboardNavProfileTitle",
      callback() {
        const user = loggedInUser();
        if (user) navigateTo2(`/user/${user}`, { leaveNP: true });
      },
      goMode: true
    },
    profileNewTab: {
      type: "keycode",
      value: [85, false, false, true, false],
      // shift+u
      description: "keyboardNavProfileNewTabDesc",
      title: "keyboardNavProfileNewTabTitle",
      callback() {
        const user = loggedInUser();
        if (user) navigateTo2(`/user/${user}`, { newWindow: true, leaveNP: true });
      },
      goMode: true
    },
    frontPage: {
      type: "keycode",
      value: [70, false, false, false, false],
      // f
      description: "keyboardNavFrontPageDesc",
      title: "keyboardNavFrontPageTitle",
      callback() {
        navigateTo2("/", { leaveNP: true });
      },
      goMode: true
    },
    slashAll: {
      type: "keycode",
      value: [65, true, false, false, false],
      // alt-a
      description: "keyboardNavSlashAllDesc",
      title: "keyboardNavSlashAllTitle",
      callback() {
        navigateTo2("/r/all", { leaveNP: true });
      },
      goMode: true
    },
    subredditFrontPage: {
      type: "keycode",
      value: [70, false, false, true, false],
      // shift-f
      description: "keyboardNavsSubredditFrontPageDesc",
      title: "keyboardNavsSubredditFrontPageTitle",
      callback() {
        const sub = currentSubreddit();
        if (sub) navigateTo2(`/r/${sub}`, { leaveNP: false });
      },
      goMode: true
    },
    random: {
      type: "keycode",
      value: [89, true, false, false, false],
      // alt-y   SO RANDOM
      description: "keyboardNavRandomDesc",
      title: "keyboardNavRandomTitle",
      callback() {
        navigateTo2("/r/random", { leaveNP: true });
      },
      goMode: true
    },
    nextPage: {
      type: "keycode",
      include: ["linklist", "commentsLinklist", "modqueue", "profile", "inbox"],
      value: [78, false, false, false, false],
      // n
      description: "keyboardNavNextPageDesc",
      title: "keyboardNavNextPageTitle",
      callback() {
        if (isRunning(neverEndingReddit_exports)) {
          loadNextPage({ scrollToLoadWidget: true });
        } else {
          const next = getNextPrevLinks().next;
          if (next) location.href = next;
        }
      },
      goMode: true
    },
    prevPage: {
      type: "keycode",
      include: ["linklist", "commentsLinklist", "modqueue", "profile", "inbox"],
      value: [80, false, false, false, false],
      // p
      description: "keyboardNavPrevPageDesc",
      title: "keyboardNavPrevPageTitle",
      callback() {
        if (isRunning(neverEndingReddit_exports)) {
        } else {
          const prev = getNextPrevLinks().prev;
          if (prev) location.href = prev;
        }
      },
      goMode: true
    },
    overviewLegacy: {
      type: "keycode",
      include: ["d2x", "profile"],
      value: [79, false, false, true, false],
      // shift+o
      description: "keyboardNavOverviewLegacyDesc",
      title: "keyboardNavOverviewLegacyTitle",
      callback() {
        const currentUser = currentUserProfile();
        if (currentUser) navigateTo2(`/user/${currentUser}/overview`, { leaveNP: true });
      },
      goMode: true
    },
    profileView: {
      type: "keycode",
      include: ["d2x", "profile"],
      value: [80, false, false, true, false],
      // shift+p
      description: "keyboardNavProfileViewDesc",
      title: "keyboardNavProfileViewTitle",
      callback() {
        const currentUser = currentUserProfile();
        if (currentUser) navigateTo2(`/user/${currentUser}`, { leaveNP: true });
      },
      goMode: true
    }
    // numbers and numpad numbers are used to access links (see getLinkKeys)
  };
  module28.beforeLoad = () => {
    registerCommandLine3();
    if (module28.options.linkNumbers.value) {
      selectedThing_exports.addListener(updateLinkAnnotations, "instantly");
      watchForElements(["selfText"], null, (element) => {
        const thing = Thing.from(element);
        if (selectedThing_exports.current === thing) updateLinkAnnotations(thing);
      });
    }
  };
  module28.contentStart = () => {
    window.addEventListener("keydown", handleKeyPress, true);
  };
  function registerCommandLine3() {
    registerCommand(
      /\d+/,
      "[number] - navigates to the link with that number (if annotation exists) or rank (link pages)",
      () => {
      },
      (command) => {
        const number = parseInt(command, 10);
        const annotation = linkAnnotations[number - 1];
        if (annotation) {
          if (!document.contains(annotation.link)) {
            console.log("Annotation refers to removed link; ignoring");
            return;
          }
          openLink(number - 1);
        } else {
          followLinkByRank(number);
        }
      }
    );
  }
  var linkAnnotations = [];
  function updateLinkAnnotations(selected) {
    for (const { annotation } of linkAnnotations) annotation.remove();
    linkAnnotations = Array.from(selected && selected.entry.querySelectorAll("div.md a:not(.noKeyNav)") || []).filter((link) => !isCommentCode(link) && !isEmptyLink(link)).map((link, i2) => {
      const number = i2 + 1;
      const title = number < 10 ? `press ${number} to open link` : number === 10 ? "press 0 to open link" : `press ${niceKeyCode(module28.options.toggleCmdLine.value)} then ${number} and Enter to open link`;
      const annotation = string_exports.html`<span class="noCtrlF keyNavAnnotation" data-text="[${number}]" title="${title}"></span>`;
      if (module28.options.linkNumberPosition.value === "right") link.after(annotation);
      else link.before(annotation);
      return { annotation, link };
    });
  }
  function toggleKeyNavHelp() {
    const slideSpeed = 400;
    if (!drawHelp().attr("shown")) {
      drawHelp().attr("shown", "false");
      drawHelp().css({ right: "-350px" });
      drawHelp().show();
    }
    if (drawHelp().attr("shown") === "true") {
      drawHelp().animate({
        right: "-350px"
      }, slideSpeed);
      drawHelp().attr("shown", "false");
    } else {
      drawHelp().animate({
        right: "20px"
      }, slideSpeed);
      drawHelp().attr("shown", "true");
    }
  }
  var drawHelp = once_default(() => {
    const keys3 = filterMap(getActiveCommandOptions(), (opt) => {
      let keyCode = niceKeyCode(opt.value);
      if (opt.goMode && module28.options.useGoMode.value) {
        keyCode = `${niceKeyCode(module28.options.goMode.value)} \u2192 ${keyCode}`;
      }
      return [{ keyCode, description: i18n(opt.description) }];
    });
    return (0, import_jquery23.default)(string_exports.html`
		<div id="keyHelp">
			<table>
				<thead>
					<tr><th>Key</th><th>Function</th></tr>
				</thead>
				<tbody>
					${keys3.map(({ keyCode, description }) => string_exports._html`
						<tr><td>${keyCode}</td><td>${description}</td></tr>
					`)}
				</tbody>
			</table>
		</div>
	`).appendTo(document.body);
  });
  function getLinkKeys() {
    const altModeModifier = module28.options.linkNumberAltModeModifier.value;
    const keys3 = [];
    function addKey(key, index2) {
      keys3.push({
        value: [key, false, false, false, false],
        // number
        callback() {
          openLink(index2);
        }
      });
      if (altModeModifier !== "none") {
        keys3.push({
          value: [key, altModeModifier === "alt", false, altModeModifier === "shift", false],
          // alt-number | shift-number
          callback() {
            openLink(index2, true);
          }
        });
      }
    }
    if (module28.options.linkNumbers.value) {
      [49, 50, 51, 52, 53, 54, 55, 56, 57, 48].forEach(addKey);
      [97, 98, 99, 100, 101, 102, 103, 104, 105, 96].forEach(addKey);
    }
    return keys3;
  }
  var getActiveCommandOptions = once_default(
    () => filterMap(Object.values(module28.options), (option2) => {
      if (option2.type === "keycode" && option2.callback && (!option2.dependsOn || option2.dependsOn(module28.options)) && (!option2.include || matchesPageLocation(option2.include)) && (!option2.mustBeLoggedIn || loggedInUser()) && (!option2.requiresModules || option2.requiresModules.every(isRunning))) {
        return [option2];
      }
    })
  );
  var _commandLookup = once_default(() => {
    const lookup = {};
    for (const option2 of [...getActiveCommandOptions(), ...getLinkKeys()]) {
      const hash = hashKeyArray(option2.value);
      if (!lookup[hash]) {
        lookup[hash] = [];
      }
      lookup[hash].push(option2);
    }
    return lookup;
  });
  function handleKeyPress(e2) {
    if (konamiActive()) return;
    if (document.activeElement && ["A", "BUTTON"].includes(document.activeElement.tagName)) {
      const hasDefaultBehavior = [
        NAMED_KEYS.Tab,
        NAMED_KEYS.Enter,
        NAMED_KEYS.Space
      ].includes(e2.key);
      if (hasDefaultBehavior) return;
    } else if (document.activeElement && document.activeElement.tagName !== "BODY") {
      return;
    }
    const hash = hashKeyEvent(e2);
    const options6 = (_commandLookup()[hash] || []).filter((v) => {
      if (v.goMode) return module28.options.useGoMode.value === goModeActive;
      else return !goModeActive;
    });
    if (options6.length) {
      handleCallbacks(options6);
      e2.preventDefault();
      e2.target.blur();
    }
  }
  async function handleCallbacks(options6) {
    if (options6.some((v) => v.goMode)) {
      if (goModeActive) toggleGoMode();
      if (options6.length > 1) {
        const shortcut = niceKeyCode(options6[0].value);
        options6 = await promptUniqueShortcut(shortcut, options6);
      }
    }
    for (const option2 of options6) {
      try {
        option2.callback();
      } catch (e2) {
        console.error("Could not execute callback", i18n(option2.title), e2);
      }
    }
  }
  var promptUniqueShortcut = memoize_default(async (shortcut, options6) => {
    const question = i18n("keyboardNavAmbiguousShortcutPrompt", i18n(module28.moduleName), `<i>${shortcut}</i>`, "<br><br>", `<i>${shortcut}</i>`);
    const optionButtons = options6.map(
      (option2) => [option2, (0, import_jquery23.default)(`<button style="width: 100%; margin-top: 2px;">${i18n(option2.description)}</button>`).get(0)]
    );
    const followUp = i18n("keyboardNavAmbiguousShortcutPromptFollowUp", makeUrlHashLink(module28.moduleID, void 0, i18n(module28.moduleName)));
    const message = (0, import_jquery23.default)(`<div>${question}</div>`).append(optionButtons.map(([, button]) => button)).append(`<br><br><small>(${followUp})</small>`).get(0);
    const notification = showNotification({
      moduleID: module28.moduleID,
      header: "Ambiguous shortcut",
      message,
      noDisable: true,
      closeDelay: Infinity
    });
    const preservedOption = await Promise.race(
      optionButtons.map(([option2, button]) => waitForEvent(button, "click").then(() => option2))
    );
    for (const option2 of without_default(options6, preservedOption)) {
      option2.value = [-1, false, false, false, false];
      save2(option2);
    }
    notification.close();
    return [preservedOption];
  });
  function getSelected() {
    const selected = selectedThing_exports.current;
    if (!selected) throw new Error("A entry must be selected");
    if (!selected.isVisible()) throw new Error("Entry must be visible");
    return selected;
  }
  var ASSERT = true;
  var NOASSERT = false;
  function assertElement(element) {
    if (!element) throw new Error("Element not available");
    return element;
  }
  function getFirstElementInThingByQuery(query, assertExistance, thing = getSelected()) {
    const element = thing.entry.querySelector(query);
    return assertExistance ? assertElement(element) : element;
  }
  function getElementsInThingByQuery(query, assertLength, thing = getSelected()) {
    const elements = Array.from(thing.entry.querySelectorAll(query));
    if (assertLength) assertElement(elements[0]);
    return elements;
  }
  function getMostVisibleElementInThingByQuery(query, assertLength, thing) {
    return maxBy_default(getElementsInThingByQuery(query, assertLength, thing), getPercentageVisibleYAxis);
  }
  function hideLink(selected = getSelected()) {
    const hide3 = assertElement(selected.getHideElement());
    if (module28.options.onHideMoveDown.value) {
      selectedThing_exports.move("down", { allowMediaBrowse: true, scrollStyle: "none" }, moveDownFallback);
    }
    click(hide3);
  }
  function followSubreddit(newWindow = false, selected = getSelected()) {
    const a2 = downcast(assertElement(selected.getSubredditLink()), HTMLAnchorElement);
    navigateTo2(a2.href, { newWindow, leaveNP: true });
  }
  function followProfile(newWindow = false, selected = getSelected()) {
    navigateTo2(selected.getAuthorUrl(), { newWindow, leaveNP: true });
  }
  function toggleChildren(selected = getSelected()) {
    if (selected.element.classList.contains("link")) return;
    click(assertElement(
      // 'continue this thread' links
      getFirstElementInThingByQuery("span.deepthread > a", NOASSERT, selected) || // check if this is a "show more comments" box, or just contracted content...
      getFirstElementInThingByQuery("span.morecomments > a", NOASSERT, selected) || // find out if this is a collapsed or uncollapsed view...
      getFirstElementInThingByQuery("a.expand", NOASSERT, selected)
    ));
  }
  function imageResize({ factor = 1, removeHeightRestriction = false }) {
    const mostVisible = getMostVisibleElementInThingByQuery(".res-media-zoomable", ASSERT);
    if (removeHeightRestriction) mostVisible.style.maxHeight = "none";
    resize(mostVisible, mostVisible.clientWidth * factor);
  }
  function imageMove(deltaX, deltaY) {
    const mostVisible = getMostVisibleElementInThingByQuery(".res-media-movable", ASSERT);
    move2(mostVisible, deltaX, deltaY);
  }
  function videoToggleMute() {
    const mostVisible = getMostVisibleElementInThingByQuery(".res-video-container", ASSERT);
    toggleMute(mostVisible);
  }
  function navigateGallery(direction) {
    const gallery = getMostVisibleElementInThingByQuery(".res-gallery", ASSERT);
    assertElement(gallery.querySelector(`.res-step-${direction}`)).click();
    if (module28.options.scrollOnGalleryNavigate.value) {
      scrollToElement(assertElement(gallery.querySelector(".res-gallery-pieces")), null, { scrollStyle: "directional", restrictDirectionTo: "up" });
    }
  }
  function followLink(newWindow = false, selected = getSelected()) {
    if (isPageType("comments") && !selected.element.classList.contains("link")) return;
    const a2 = selected.getPostLink();
    navigateTo2(a2.href, { newWindow });
  }
  function followLinkByRank(num) {
    const target = Thing.visibleThings().find((v) => v.getRank() === num);
    if (!target) throw new Error(`Could not find visible entry at rank ${num}`);
    selectedThing_exports.set(target);
    followLink();
  }
  function followPermalink(newWindow = false) {
    const a2 = downcast(getFirstElementInThingByQuery("a.bylink", ASSERT), HTMLAnchorElement);
    navigateTo2(a2.href, { newWindow });
  }
  function followComments(newWindow = false, selected = getSelected()) {
    const a2 = assertElement(selected.getCommentsLink());
    navigateTo2(a2.href, { newWindow });
  }
  function vote(way, preventToggle = false, selected = getSelected()) {
    const button = assertElement(way === "upmod" ? selected.getUpvoteButton() : selected.getDownvoteButton());
    if (button.classList.contains("archived")) {
    } else if (isVotingBlocked()) {
      notifyNoVote();
    } else if (!preventToggle || !button.classList.contains(way)) {
      click(button);
    }
    if (selected.isComment()) {
      if (module28.options.onVoteCommentMoveDown.value) module28.options.moveDownComment.callback();
    } else {
      if (module28.options.onVoteMoveDown.value) module28.options.moveDown.callback();
    }
  }
  function reply(selected = getSelected()) {
    if (selected.element.classList.contains("link") && isPageType("comments")) {
      const $target = (0, import_jquery23.default)(".usertext-edit textarea[name=text]:first");
      if ($target.filter(":visible").length) {
        $target.focus();
        return;
      }
    }
    click(assertElement(
      // User can reply directly here, so open/focus the reply form
      getFirstElementInThingByQuery(".buttons a[onclick*=reply]", NOASSERT, selected) || // User cannot reply directly from this page, so go to where they can reply
      getFirstElementInThingByQuery(".buttons a.comments, .buttons a.bylink", NOASSERT, selected)
    ));
  }
  function navigateTo2(href, options6) {
    if (options6.leaveNP && isEnabled(noParticipation_exports) && module27.options.escapeNP.value) {
      href = nonNpLocation(href);
    }
    if (options6.newWindow) {
      openNewTab(href, module28.options.followLinkNewTabFocus.value);
    } else {
      location.href = href;
    }
  }
  var goModePanel = once_default(() => {
    const goModes = getActiveCommandOptions().filter((opt) => opt.goMode).map((opt) => ({ key: i18n(opt.title), niceKeyCode: niceKeyCode(opt.value) }));
    return (0, import_jquery23.default)(string_exports.html`
		<div id="goModePanel" class="RESDialogSmall">
			<h3>Press a key to go:</h3>
			<div class="RESCloseButton RESCloseButtonTopRight"></div>
			<div class="RESDialogContents">
				<table>
					${goModes.map(({ niceKeyCode: niceKeyCode2, key }) => string_exports._html`
						<tr>
							<td>${niceKeyCode2}</td>
							<td class="arrow">&rarr;</td>
							<td>${key}</td>
						</tr>
					`)}
				</table>
			</div>
		</div>
	`).find(".RESCloseButton").click(toggleGoMode).end();
  });
  var goModeActive = false;
  function toggleGoMode() {
    goModeActive = !goModeActive;
    if (goModeActive) {
      (0, import_jquery23.default)(document.body).on("keyup", handleGoModeEscapeKey);
      goModePanel().appendTo(document.body).fadeIn();
    } else {
      goModePanel().fadeOut();
      (0, import_jquery23.default)(document.body).off("keyup", handleGoModeEscapeKey);
    }
  }
  function handleGoModeEscapeKey(event) {
    if (event.key === NAMED_KEYS.Escape) {
      toggleGoMode();
    }
  }
  function moveDownFallback() {
    const bump = isRunning(neverEndingReddit_exports) && (!selectedThing_exports.current || [selectedThing_exports.current, void 0].includes(Thing.visibleThings().slice(-1)[0]));
    if (bump) loadNextPage({ scrollToLoadWidget: true });
  }
  function openLink(index2, altMode = false) {
    const link = linkAnnotations[index2] && linkAnnotations[index2].link;
    if (!link) throw Error(`Link annotation ${index2} is not available`);
    const expando2 = getLinkExpando(link);
    if (expando2 && module28.options.linkToggleExpando.value !== altMode) {
      click(expando2.button);
    } else if (isSettingsUrl(link.href)) {
      update2(link);
    } else if (module28.options.linkNewTab.value) {
      openNewTab(link.href, module28.options.followLinkNewTabFocus.value);
    } else {
      location.href = link.href;
    }
  }

  // lib/modules/RESTips.js
  var module32 = new Module("RESTips");
  module32.moduleName = "resTipsName";
  module32.category = "aboutCategory";
  module32.description = "resTipsDesc";
  module32.options = {
    menuItem: {
      title: "RESTipsMenuItemTitle",
      type: "boolean",
      value: true,
      description: "RESTipsMenuItemDesc"
    },
    dailyTip: {
      title: "RESTipsDailyTipTitle",
      type: "boolean",
      value: true,
      description: "RESTipsDailyTipDesc"
    },
    newFeatureTips: {
      title: "RESTipsNewFeatureTipsTitle",
      type: "boolean",
      value: true,
      description: "RESTipsNewFeatureTipsDesc"
    }
  };
  module32.include = ["r2"];
  var featureTipsStorage = storage_exports.wrapPrefix("RESTips.featureTips.", () => ({ enabled: true }));
  var lastTooltipStorage = storage_exports.wrap("RESLastToolTip", 0);
  module32.contentStart = () => {
    if (module32.options.menuItem.value) {
      addMenuItem(
        () => string_exports.html`<span>${i18n("tipsAndTricks")}</span>`,
        () => {
          showOrdinaryTip("random");
        }
      );
    }
  };
  var allowFeatureTips;
  var featureTips2 = /* @__PURE__ */ new Map();
  var featureTipReadyPromise = new Promise((resolve) => {
    allowFeatureTips = () => resolve(true);
  });
  module32.afterLoad = async () => {
    const showsDailyTip = module32.options.dailyTip.value && await dailyTip();
    if (module32.options.newFeatureTips.value && !showsDailyTip) allowFeatureTips();
  };
  var newFeatureTipsCheckbox = once_default(
    () => (0, import_jquery24.default)('<label><input type="checkbox" name="disableNewFeatureTipsCheckbox" checked />Show these tips when new features appear</label>').click((e2) => {
      module32.options.newFeatureTips.value = e2.currentTarget.querySelector("input").checked;
      save2(module32.options.newFeatureTips);
    })
  );
  var addFeatureTip = memoize_default(async (id2, tip) => {
    tip.onHide = () => {
      featureTipsStorage.set(id2, { enabled: false });
    };
    featureTips2.set(id2, tip);
    tips.push(tip);
    if (!tip.quiet && await featureTipReadyPromise && await featureTipsStorage.get(id2).then(({ enabled: enabled2 }) => enabled2)) showFeatureTip(id2);
  });
  var showFeatureTip = mutex((id2) => {
    const tip = featureTips2.get(id2);
    if (!tip) {
      console.error("Feature tip is not added", id2);
      return;
    }
    if (tip.attachTo instanceof Element && !elementInViewport(tip.attachTo)) {
      console.log("Ignoring feature tip whose attachment element is not visible:", tip);
      return;
    }
    return showTip(tip, {
      title: "New feature",
      classString: "res-featureTip",
      buttonCustomHTML: newFeatureTipsCheckbox(),
      buttons: []
    });
  });
  async function dailyTip() {
    const lastCheck = await lastTooltipStorage.get();
    const now4 = Date.now();
    const delay = penalizedDelay(module32.moduleID, "dailyTip", {
      value: DAY,
      default: DAY
    });
    if (now4 - lastCheck > delay) {
      lastTooltipStorage.set(now4);
      if (lastCheck === 0) {
        await showOrdinaryTip();
      } else {
        alterFeaturePenalty(module32.moduleID, "dailyTip", clamp_default(MAX_PENALTY / tips.length, 3, 8));
        await showOrdinaryTip("random");
      }
      return true;
    }
    return false;
  }
  function generateContent({ message, keyboard, options: options6 }) {
    const description = [];
    if (typeof message === "function") description.push(message());
    else if (typeof message === "string") description.push(message);
    if (keyboard) {
      const disabled = !isEnabled(keyboardNav_exports);
      description.push(`<h2 class="keyboardNav${disabled ? "keyboardNavDisabled" : ""}">`);
      description.push(`Keyboard Navigation${disabled ? " (disabled)" : ""}`);
      description.push("</h2>");
      const keyboardTable = createElement_exports.table(keyboard, generateContentKeyboard);
      if (keyboardTable) description.push(keyboardTable);
    }
    if (options6) {
      for (const option2 of options6) {
        description.push('<h2 class="settingsPointer">');
        description.push('<span class="gearIcon"></span> RES Settings');
        description.push("</h2>");
        const optionTable = createElement_exports.table(option2, generateContentOption);
        if (optionTable) description.push(optionTable);
      }
    }
    return (0, import_jquery24.default)("<div />").html(description.join("\n"));
  }
  function generateContentKeyboard(keyboardNavOption) {
    const keyCode = niceKeyCode(module28.options[keyboardNavOption].value);
    if (!keyCode) return false;
    const description = [];
    description.push("<tr>");
    description.push(`<td><code>${keyCode.toLowerCase()}</code></td>`);
    description.push(`<td>${keyboardNavOption}</td>`);
    description.push("</tr><tr>");
    description.push("<td>&nbsp;</td>");
    description.push(`<td>${i18n(module28.options[keyboardNavOption].description)}</td>`);
    description.push("</tr>");
    return description;
  }
  function generateContentOption(option2) {
    const mod = getUnchecked(option2.moduleID);
    if (!mod) return false;
    const description = [];
    description.push("<tr>");
    description.push(`<td>${i18n(mod.category)}</td>`);
    description.push("<td>");
    description.push(makeUrlHashLink(option2.moduleID, void 0, i18n(mod.moduleName)));
    description.push("</td>");
    description.push("<td>");
    description.push(option2.key ? makeUrlHashLink(option2.moduleID, option2.key) : "&nbsp;");
    description.push("</td>");
    if (option2.key && mod.options[option2.key]) {
      description.push("</tr><tr>");
      description.push(`<td colspan="3">${i18n(mod.options[option2.key].description)}</td>`);
    }
    description.push("</tr>");
    return description;
  }
  var tips = [{
    message: `
		Welcome to RES, a community-driven unofficial browser extension for Reddit. You can turn on, turn off, or change options for RES features using the gear icon link at the top right.
		<p>For feature requests, or just help getting a question answered, be sure to subscribe to <a href="/r/Enhancement">/r/Enhancement</a>.</p>
		<p>If RES has enhanced your reddit experience, please show your appreciation by <a href="${RES_SETTINGS_HASH}/contribute">donating or contributing!</a></p>
		`,
    attachTo: "#RESSettingsButton",
    position: 5
  }, {
    message: "Click the tag icon next to a user to tag that user with any name you like - you can also color code the tag.",
    attachTo: ".RESUserTagImage",
    position: 3,
    options: [{ moduleID: "userTagger" }]
  }, {
    message: 'If your RES data gets deleted or you move to a new computer, you can restore it from backup. <br><br><b>Firefox</b> especially sometimes loses your RES settings and data. <br><br><a href="/r/Enhancement/wiki/backing_up_res_settings" target="_blank" rel="noopener noreferer">Learn where RES stores your data and settings</a></p>',
    title: "Back up your RES data!"
  }, {
    message: `Don't forget to subscribe to <a href="/r/Enhancement">/r/Enhancement</a> to keep up to date on the latest versions of RES or suggest features! For bug reports, submit to <a href="/r/RESIssues">/r/RESIssues</a>`
  }, {
    message: "Don't want to see posts containing certain keywords? Want to filter out certain subreddits from /r/all? Try the filteReddit module!",
    options: [{ moduleID: "filteReddit" }]
  }, {
    message: "Keyboard Navigation is one of the most underutilized features in RES. You should try it!",
    options: [{ moduleID: "keyboardNav" }],
    keyboard: "toggleHelp"
  }, {
    message: 'Did you know you can configure the appearance of a number of things in RES? For example: Selected Entry lets you configure the look of the "selected" box, and commentBoxes lets you configure the borders / shadows.',
    options: [{
      moduleID: "selectedEntry",
      key: "setColors"
    }, {
      moduleID: "commentStyle",
      key: "commentBoxes"
    }]
  }, {
    message: "Do you subscribe to a ton of subreddits? Give the subreddit tagger a try; it can make your homepage a bit more readable.",
    options: [{
      moduleID: "subRedditTagger"
    }]
  }, {
    message: "If you haven't tried it yet, Keyboard Navigation is great. Just hit ? while browsing for instructions.",
    options: [{
      moduleID: "keyboardNav"
    }],
    keyboard: "toggleHelp"
  }, {
    message: "Roll over a user's name to get information about them such as their karma, and how long they've been a reddit user.",
    options: [{
      moduleID: "userInfo",
      key: "hoverInfo"
    }]
  }, {
    message: 'Hover over the "parent" link in comments pages to see the text of the parent being referred to.',
    options: [{
      moduleID: "showParent"
    }]
  }, {
    message: "You can configure the color and style of the User Highlighter module if you want to change how the highlights look.",
    options: [{
      moduleID: "userHighlight"
    }]
  }, {
    message: "Not a fan of how comments pages look? You can change the appearance in the Style Tweaks module",
    options: [{
      moduleID: "styleTweaks"
    }]
  }, {
    message: "Don't like the style in a certain subreddit? RES gives you a checkbox to disable styles individually - check the right sidebar!"
  }, {
    message: "Looking for posts by submitter, post with photos, or posts in IAmA form? Try out the comment navigator."
  }, {
    message: 'Have you seen the <a href="/r/Dashboard">RES Dashboard</a>? It allows you to do all sorts of great stuff, like keep track of lower traffic subreddits, and manage your <a href="/r/Dashboard#userTaggerContents">user tags</a> and <a href="/r/Dashboard#newCommentsContents">thread subscriptions</a>!',
    options: [{
      moduleID: "dashboard"
    }]
  }, {
    message: "Sick of seeing these tips?  They only show up once every 24 hours, but you can disable that in the RES Tips and Tricks preferences.",
    options: [{
      moduleID: "RESTips"
    }]
  }, {
    message: 'Did you know that there is now a "keep me logged in" option in the Account Switcher? Turn it on if you want to stay logged in to Reddit when using the switcher!',
    options: [{
      moduleID: "accountSwitcher",
      key: "keepLoggedIn"
    }]
  }, {
    message: "See that little [vw] next to users you've voted on?  That's their vote weight - it moves up and down as you vote the same user up / down.",
    options: [{
      moduleID: "userTagger",
      key: "vwNumber"
    }]
  }];
  var dailyTipsCheckbox = once_default(
    () => (0, import_jquery24.default)(`<label><input type="checkbox" name="disableDailyTipsCheckbox" ${module32.options.dailyTip.value ? "checked" : ""} />Show these tips once every 24 hours</label>`).click((e2) => {
      module32.options.dailyTip.value = e2.currentTarget.querySelector("input").checked;
      save2(module32.options.dailyTip);
    })
  );
  var lastTip;
  function showOrdinaryTip(change) {
    alterFeaturePenalty(module32.moduleID, "dailyTip", 1);
    let currTipIndex = Math.max(tips.indexOf(lastTip), 0);
    let tip;
    while (!tip || tip.attachTo && !(0, import_jquery24.default)(tip.attachTo).is(":visible")) {
      if (change === "random") currTipIndex = random_default(tips.length);
      else if (change === "prev") currTipIndex -= 1;
      else if (change === "next") currTipIndex += 1;
      else change = "next";
      currTipIndex = positiveModulo(currTipIndex, tips.length);
      tip = tips[currTipIndex];
    }
    return showTip(tip, {
      buttons: [{
        name: "Prev",
        onclick: () => showOrdinaryTip("prev")
      }, {
        name: "Next",
        onclick: () => showOrdinaryTip("next")
      }],
      onClose() {
        alterFeaturePenalty(module32.moduleID, "dailyTip", 4);
      },
      classString: "res-ordinaryTip",
      buttonCustomHTML: dailyTipsCheckbox(),
      title: "RES Tips and Tricks"
    });
  }
  function showTip(tip, guiderObj) {
    const { continuation } = lastTip = tip;
    if (continuation) {
      const origGuiderObj = { ...guiderObj };
      const onclick = async () => {
        const upcomingId = continuation();
        let nextTip;
        while (!(nextTip = featureTips2.get(upcomingId))) {
          await new Promise((r) => {
            setTimeout(r, 100);
          });
        }
        showTip(nextTip, origGuiderObj);
      };
      guiderObj.buttons = [...guiderObj.buttons, { name: "More", onclick }];
    }
    const attachTo = tip.attachTo && (0, import_jquery24.default)(tip.attachTo).get(0) || null;
    const toggleIncreasedZIndex = (state) => {
      if (attachTo) attachTo.classList.toggle("restips-increased-z-index", state);
    };
    return new Promise((resolve) => {
      const { guiders: guiders2 } = (init_guiders(), __toCommonJS(guiders_exports));
      guiders2.hideAll();
      guiders2.createGuider({
        id: `res-guider-${performance.now()}`,
        // guiders.js' randomization interval is [0..999], and merges buttons on collision
        closeOnEscape: true,
        xButton: true,
        description: generateContent(tip),
        ...guiderObj,
        ...tip,
        onHide() {
          if (tip.onHide) tip.onHide();
          toggleIncreasedZIndex(false);
          resolve();
        },
        attachTo
      });
      toggleIncreasedZIndex(true);
      guiders2.show();
    });
  }

  // lib/modules/about.js
  var module33 = new Module("about");
  module33.moduleName = "aboutName";
  module33.category = "aboutCategory";
  module33.sort = -10;
  module33.alwaysEnabled = true;
  module33.description = "aboutDesc";
  module33.options = {
    presets: {
      type: "button",
      description: "aboutOptionsPresets",
      title: "aboutOptionsPresetsTitle",
      text: createElement_exports.icon(61762),
      callback: { moduleID: "presets" }
    },
    backup: {
      type: "button",
      description: "aboutOptionsBackup",
      title: "aboutOptionsBackupTitle",
      text: createElement_exports.icon(61529),
      callback: { moduleID: "backupAndRestore" }
    },
    searchSettings: {
      type: "button",
      description: "aboutOptionsSearchSettings",
      title: "aboutOptionsSearchSettingsTitle",
      text: createElement_exports.icon(61591),
      callback: { moduleID: "search" }
    },
    announcements: {
      type: "button",
      description: "aboutOptionsAnnouncements",
      title: "aboutOptionsAnnouncementsTitle",
      text: createElement_exports.icon(61704),
      callback: "/r/RESAnnouncements/new"
    },
    donate: {
      type: "button",
      description: "aboutOptionsDonate",
      title: "aboutOptionsDonateTitle",
      text: createElement_exports.icon(61700),
      callback: "https://redditenhancementsuite.com/contribute/"
    },
    bugs: {
      type: "button",
      description: "aboutOptionsBugs",
      title: "aboutOptionsBugsTitle",
      text: createElement_exports.icon(61443),
      callback: "/r/RESIssues/wiki/postanissue"
    },
    suggestions: {
      type: "button",
      description: "aboutOptionsSuggestions",
      title: "aboutOptionsSuggestionsTitle",
      text: createElement_exports.icon(61558),
      callback: "/r/Enhancement"
    },
    faq: {
      type: "button",
      description: "aboutOptionsFAQ",
      title: "aboutOptionsFAQTitle",
      text: createElement_exports.icon(61651),
      callback: "/r/Enhancement/wiki/index"
    },
    code: {
      type: "button",
      description: "aboutOptionsCode",
      title: "aboutOptionsCodeTitle",
      text: createElement_exports.icon(61539),
      callback: "https://github.com/honestbleeps/Reddit-Enhancement-Suite"
    },
    contributors: {
      type: "button",
      description: "aboutOptionsContributors",
      title: "aboutOptionsContributorsTitle",
      text: createElement_exports.icon(61512),
      callback: "https://redditenhancementsuite.com/about"
    },
    privacy: {
      type: "button",
      description: "aboutOptionsPrivacy",
      title: "aboutOptionsPrivacyTitle",
      text: createElement_exports.icon(61634),
      callback: "/r/Enhancement/wiki/about/privacy"
    },
    license: {
      type: "button",
      description: "aboutOptionsLicense",
      title: "aboutOptionsLicenseTitle",
      text: createElement_exports.icon(61651),
      callback: "https://www.gnu.org/licenses/gpl-3.0.html"
    }
  };

  // lib/modules/announcements.js
  var module34 = new Module("announcements");
  module34.moduleName = "announcementsName";
  module34.category = "coreCategory";
  module34.description = "announcementsDesc";
  module34.hidden = true;
  var subreddit = announcementsSubreddit;
  var sourceUrl = `/r/${subreddit}/new.json?limit=1`;
  var viewUrl = `/r/${subreddit}/new`;
  var markedReadDate = storage_exports.wrap("RESmodules.announcement.markedReadDate", 0);
  var lastUnreadDate = storage_exports.wrap("RESmodules.announcement.lastUnreadDate", 0);
  var lastID = storage_exports.wrap("RESModules.announcement.lastAnnouncementID", null);
  var archiveAfter = 31 * DAY;
  var pizzazzAfter = 29 * DAY;
  var recheckPostAfter = HOUR;
  var now3 = Date.now();
  var biff;
  module34.go = async () => {
    if (isCurrentSubreddit(subreddit)) {
      setMarkedRead();
    } else {
      const post = await postForNotification();
      if (post) {
        notify(post);
      }
    }
  };
  async function postForNotification() {
    const post = await getLatestPost();
    if (!post) {
      return false;
    }
    cacheLatestPost(post);
    const result = await shouldNotify(post);
    return result ? post : false;
  }
  async function shouldNotify(post) {
    const createdDate = post.created_utc * 1e3;
    if (createdDate + archiveAfter <= now3) {
      return false;
    }
    if (createdDate <= await markedReadDate.get()) {
      return false;
    }
    if (!isPostRelevant(post)) {
      return false;
    }
    return true;
  }
  var notify = once_default(async (post) => {
    const url = post.id ? `/comments/${post.id}` : viewUrl;
    const withPizzazz = await lastUnreadDate.get() + pizzazzAfter < now3;
    const title = post.author ? i18n("announcementsNewPostByUser", subreddit, post.author) : i18n("announcementsNewPost", subreddit);
    addAnnouncementBiff(post, url, title, withPizzazz);
    const hasSeenNotification = await lastUnreadDate.has();
    if (hasSeenNotification) {
      addMenuItem(
        () => string_exports.html`<span title="${title}">
				new announcement!
				<span data-action="preventOpenNewTab" class="RESMenuItemButton res-icon"></span>
			</span>`,
        (e2) => {
          setMarkedRead();
          if (e2.target.closest('[data-action="preventOpenNewTab"]')) return;
          openNewTab(url);
        },
        -8
      );
    }
  });
  async function cacheLatestPost(post) {
    if (post.id !== await lastID.get()) {
      lastID.set(post.id);
      lastUnreadDate.set(now3);
    }
  }
  function addAnnouncementBiff(post, url, title, withPizzazz) {
    biff = string_exports.html`<a id="RESAnnouncementAlert" class="${withPizzazz ? "important" : ""}" href="${url}" target="_blank">`;
    biff.append(createElement_exports.icon(61558, "span", "", title));
    biff.addEventListener("click", setMarkedRead);
    addFloater(biff, { container: "inNavbar" });
  }
  async function getLatestPost() {
    const { data: { children: [{ data: data2 }] } } = await ajax({
      url: sourceUrl,
      type: "json",
      cacheFor: recheckPostAfter
    });
    return data2;
  }
  function setMarkedRead() {
    markedReadDate.set(now3);
    if (biff) biff.remove();
  }
  function isPostRelevant(post) {
    if (!/chrome|safari|firefox|opera|edge/i.test(post.title)) {
      return true;
    }
    if (post.title.toLowerCase().includes("firefox".toLowerCase())) {
      return true;
    }
    return false;
  }

  // lib/modules/autoHide.js
  var module35 = new Module("autoHide");
  module35.moduleName = "autoHideName";
  module35.category = "browsingCategory";
  module35.description = "autoHideDesc";
  module35.options = {
    mustBeVisibleDuration: {
      type: "text",
      value: "2000",
      description: "autoHideMustBeVisibleDurationDesc",
      title: "autoHideMustBeVisibleDurationTitle"
    },
    types: {
      type: "enum",
      values: [{
        name: "All",
        value: ""
      }, {
        name: "Only comments",
        value: "comment"
      }, {
        name: "Only link posts",
        value: "post"
      }],
      value: "comment",
      description: "autoHideTypesDesc",
      title: "autoHideTypesTitle"
    }
  };
  var thingType2 = isPageType("comments", "commentsLinklist") ? "comment" : "post";
  var hidePost = batch(
    (posts) => send(HIDE, posts),
    { size: 50, delay: 5e3, flushBeforeUnload: true }
  );
  module35.shouldRun = () => !isPrivateBrowsing();
  module35.beforeLoad = () => {
    if (module35.options.types.value && thingType2 !== module35.options.types.value) return;
    if (thingType2 === "comment" && !isRunning(readComments_exports)) {
      console.warn("Auto-hiding comments requires readComments");
      return;
    }
    const mustBeVisibleDuration = parseFloat(module35.options.mustBeVisibleDuration.value) || 0;
    const pending = /* @__PURE__ */ new Map();
    const io = new IntersectionObserver((entries) => {
      for (const { target, isIntersecting } of entries) {
        const thing = Thing.checkedFrom(target);
        const id2 = pending.get(thing);
        if (isIntersecting) {
          pending.set(thing, setTimeout(() => {
            if (thingType2 === "post") hidePost(thing);
            else add2(thing);
            io.unobserve(target);
            pending.delete(thing);
          }, mustBeVisibleDuration));
        } else if (id2) {
          pending.delete(thing);
          clearTimeout(id2);
        }
      }
    }, { threshold: [0], rootMargin: "0px 0px -30px 0px" });
    watchForThings([thingType2], (thing) => {
      if (thingType2 === "post" && !isLoggedIn()) return;
      io.observe(thing.entry);
    });
  };

  // lib/modules/backupAndRestore/serialization.js
  function serialize(settings) {
    const object = {
      SCHEMA_VERSION: 2,
      data: settings
    };
    return JSON.stringify(object);
  }
  function deserialize(string) {
    const object = JSON.parse(string);
    switch (object.SCHEMA_VERSION) {
      case 1: {
        const { SCHEMA_VERSION, ...settings } = object;
        return settings;
      }
      case 2: {
        const { data: settings } = object;
        return settings;
      }
      default: {
        const { SCHEMA_VERSION, ...encoded } = object;
        return mapValues_default(encoded, (v, k2) => {
          try {
            return JSON.parse(v);
          } catch (e2) {
            console.warn("Could not parse:", k2, "falling back to raw string.");
            return v;
          }
        });
      }
    }
  }

  // lib/modules/backupAndRestore/providers/index.js
  var providers_exports = {};
  __export(providers_exports, {
    Dropbox: () => Dropbox,
    File: () => File,
    GoogleDrive: () => GoogleDrive,
    OneDrive: () => OneDrive
  });

  // lib/modules/backupAndRestore/providers/Provider.js
  var Provider = class {
    static key = "abstract";
    static text = "Abstract";
    static notifyBackupDone = true;
    static supportsAutomaticBackups = false;
    init({}) {
      return Promise.resolve(this);
    }
    read() {
      throw new Error("unimplemented");
    }
    write(data2) {
      throw new Error("unimplemented");
    }
  };

  // lib/modules/backupAndRestore/providers/File.js
  var File = class extends Provider {
    static key = "file";
    static text = "backupAndRestoreProvidersFile";
    static notifyBackupDone = false;
    // Browser indicates it by downloading the file
    read() {
      return new Promise((resolve, reject) => {
        const link = document.createElement("input");
        link.type = "file";
        link.accept = ".resbackup, .json";
        let loading = false;
        link.addEventListener("change", () => {
          loading = true;
          const file = link.files[0];
          const reader = new FileReader();
          reader.onload = () => {
            resolve(reader.result);
          };
          reader.readAsText(file);
        });
        Promise.all([waitForEvent(window, "mousemove"), waitForEvent(window, "focus")]).then(() => requestIdleCallback(() => {
          if (loading) return;
          if (!link.files.length) reject(new Error("No file selected."));
        }));
        link.click();
      });
    }
    write(data2) {
      const blob = new Blob([data2], { type: "application/json" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      const date = /* @__PURE__ */ new Date();
      link.download = `RES-${date.toISOString().split("T")[0]}-${Math.round(date.getTime() / 1e3)}-${version3.replace(/\./g, "_")}.resbackup`;
      click(link);
      return Promise.resolve();
    }
  };

  // lib/modules/backupAndRestore/providers/GoogleDrive.js
  var FILE = "res-storage.json";
  var FOLDER = "appDataFolder";
  var GoogleDrive = class extends Provider {
    static key = "googledrive";
    static text = "Google Drive";
    static supportsAutomaticBackups = true;
    accessToken;
    async init({ googleLoginHint }) {
      this.accessToken = await launchAuthFlow({
        domain: `https://accounts.google.com/signin/oauth?login_hint=${googleLoginHint}`,
        clientId: "568759524377-nv0o2u4afuuulkfcjd7f6guf27qkevpt.apps.googleusercontent.com",
        scope: "https://www.googleapis.com/auth/drive.appdata",
        permissions: true ? ["https://www.googleapis.com/drive/v3/*"] : ["https://www.googleapis.com/drive/v3/*", "https://accounts.google.com/signin/oauth"]
      }, async (message) => {
        await alert_exports.open(`
				<p><b>RES needs your permission to backup to Google Drive.</b></p>
				<p>${message}</p>
			`, { cancelable: true });
      });
      return this;
    }
    async getExistingFile() {
      const { files: [file] } = await ajax({
        method: "GET",
        url: "https://www.googleapis.com/drive/v3/files",
        query: { fields: "files(id)", q: `name="${FILE}"`, spaces: FOLDER },
        headers: { Authorization: `Bearer ${this.accessToken}` },
        type: "json"
      });
      return file;
    }
    async getOrCreateFile() {
      const existingFile = await this.getExistingFile();
      if (existingFile) return existingFile;
      return ajax({
        method: "POST",
        url: "https://www.googleapis.com/drive/v3/files",
        query: { fields: "id" },
        data: JSON.stringify({ name: FILE, parents: [FOLDER] }),
        headers: { "Content-Type": "application/json", Authorization: `Bearer ${this.accessToken}` },
        type: "json"
      });
    }
    async read() {
      const file = await this.getExistingFile();
      if (!file) throw new Error("Could not find backup.");
      return ajax({
        method: "GET",
        url: `https://www.googleapis.com/drive/v3/files/${file.id}`,
        query: { alt: "media" },
        headers: { "Content-Type": "application/json", Authorization: `Bearer ${this.accessToken}` }
      });
    }
    async write(data2) {
      const { id: id2 } = await this.getOrCreateFile();
      await ajax({
        method: "PATCH",
        url: `https://www.googleapis.com/upload/drive/v3/files/${id2}`,
        query: { uploadType: "media" },
        data: data2,
        headers: { "Content-Type": "application/json", Authorization: `Bearer ${this.accessToken}` },
        type: "json"
      });
    }
  };

  // lib/modules/backupAndRestore/providers/OneDrive.js
  var FILE2 = "res-storage.json";
  var OneDrive = class extends Provider {
    static key = "onedrive";
    static text = "OneDrive";
    static supportsAutomaticBackups = true;
    accessToken;
    async init({}) {
      this.accessToken = await launchAuthFlow({
        domain: "https://login.live.com/oauth20_authorize.srf",
        clientId: true ? "7f246fc1-2a98-4687-8931-69fbd6228e4f" : "a1f95f80-0129-475b-9894-dfbb94f5ff1c",
        scope: "onedrive.appfolder",
        permissions: true ? [] : ["https://login.live.com/oauth20_authorize.srf"]
      }, async (message) => {
        await alert_exports.open(`
				<p><b>RES needs your permission to backup to OneDrive.</b></p>
				<p>${message}</p>
			`, { cancelable: true });
      });
      return this;
    }
    async getMetadata() {
      try {
        return await ajax({
          method: "GET",
          url: `https://api.onedrive.com/v1.0/drive/special/approot:/${FILE2}`,
          // `id` is necessary because the first thing selected can't start with @
          // and I have no idea how to escape it (quoting, backslash, etc. don't work...)
          query: { select: "id,@content.downloadUrl" },
          headers: { Authorization: `Bearer ${this.accessToken}` },
          type: "json"
        });
      } catch (e2) {
        if (e2.status === 404) {
          throw new Error("Could not find backup.");
        } else {
          throw e2;
        }
      }
    }
    async read() {
      const file = await this.getMetadata();
      return ajax({
        method: "GET",
        url: file["@content.downloadUrl"]
      });
    }
    async write(data2) {
      await ajax({
        method: "PUT",
        url: `https://api.onedrive.com/v1.0/drive/special/approot:/${FILE2}:/content`,
        data: data2,
        headers: { Authorization: `Bearer ${this.accessToken}` },
        type: "json"
      });
    }
  };

  // lib/modules/backupAndRestore/providers/Dropbox.js
  var FILE3 = "/res-storage.json";
  var Dropbox = class extends Provider {
    static key = "dropbox";
    static text = "Dropbox";
    static supportsAutomaticBackups = true;
    accessToken;
    async init({}) {
      this.accessToken = await launchAuthFlow({
        domain: "https://www.dropbox.com/oauth2/authorize",
        clientId: "tdevom9o5xn0hnt",
        permissions: true ? [] : ["https://www.dropbox.com/oauth2/authorize"]
      }, async (message) => {
        await alert_exports.open(`
				<p><b>RES needs your permission to backup to Dropbox.</b></p>
				<p>${message}</p>
			`, { cancelable: true });
      });
      return this;
    }
    async read() {
      try {
        return await ajax({
          method: "POST",
          url: "https://content.dropboxapi.com/2/files/download",
          query: { arg: JSON.stringify({ path: FILE3 }) },
          headers: { Authorization: `Bearer ${this.accessToken}` }
        });
      } catch (e2) {
        if (e2.status === 409) {
          throw new Error("Could not find backup.");
        } else {
          throw e2;
        }
      }
    }
    async write(data2) {
      await ajax({
        method: "POST",
        url: "https://content.dropboxapi.com/2/files/upload",
        query: { arg: JSON.stringify({ path: FILE3, mode: "overwrite", mute: true }) },
        data: data2,
        headers: { "Content-Type": "application/octet-stream", Authorization: `Bearer ${this.accessToken}` },
        type: "json"
      });
    }
  };

  // lib/modules/backupAndRestore.js
  var module36 = new Module("backupAndRestore");
  module36.moduleName = "backupName";
  module36.category = "aboutCategory";
  module36.sort = -8;
  module36.alwaysEnabled = true;
  module36.description = "backupDesc";
  module36.options = {
    backup: {
      type: "button",
      values: Object.values(providers_exports).map((p) => ({
        text: p.text,
        callback: () => getProvider(p).then(backup)
      })),
      description: "backupAndRestoreBackupDesc",
      title: "backupAndRestoreBackupTitle"
    },
    restore: {
      type: "button",
      values: Object.values(providers_exports).map((p) => ({
        text: p.text,
        callback: () => getProvider(p).then(restore)
      })),
      description: true ? "backupAndRestoreRestoreDescFirefox" : "backupAndRestoreRestoreDesc",
      title: "backupAndRestoreRestoreTitle"
    },
    reloadWarning: {
      type: "enum",
      value: "warn",
      values: [{
        name: "backupAndRestoreReloadWarningNone",
        value: "none"
      }, {
        name: "backupAndRestoreReloadWarningWarn",
        value: "warn"
      }, {
        name: "backupAndRestoreReloadWarningAuto",
        value: "auto"
      }],
      description: "backupAndRestoreReloadWarningDesc",
      title: "backupAndRestoreReloadWarningTitle"
    },
    automaticBackups: {
      type: "enum",
      value: "none",
      values: [
        {
          name: "backupAndRestoreAutomaticBackupsNone",
          value: "none"
        },
        ...Object.values(providers_exports).filter((p) => p.supportsAutomaticBackups).map((p) => ({
          name: p.text,
          value: p.key
        }))
      ],
      description: "backupAndRestoreAutomaticBackupsDesc",
      title: "backupAndRestoreAutomaticBackupsTitle",
      onChange() {
        lastCheckStorage.set(0);
        handleAutomaticSync();
      }
    },
    syncFrequency: {
      type: "text",
      value: "0.25",
      description: "backupAndRestoreSyncFrequencyDesc",
      title: "backupAndRestoreSyncFrequencyTitle",
      dependsOn: (options6) => options6.automaticBackups.value !== "none"
    },
    automaticRestore: {
      type: "boolean",
      value: true,
      description: "backupAndRestoreAutomaticRestoreDesc",
      title: "backupAndRestoreAutomaticRestoreTitle",
      dependsOn: (options6) => options6.automaticBackups.value !== "none"
    },
    warnBeforeAutomaticRestore: {
      type: "boolean",
      value: true,
      description: "backupAndRestoreWarnBeforeAutomaticRestoreDesc",
      title: "backupAndRestoreWarnBeforeAutomaticRestoreTitle",
      dependsOn: (options6) => options6.automaticBackups.value !== "none" && options6.automaticRestore.value
    },
    googleAccount: {
      type: "text",
      value: "",
      description: "backupAndRestoreGoogleAccountDesc",
      title: "backupAndRestoreGoogleAccountTitle",
      advanced: true
    }
  };
  module36.afterLoad = async () => {
    await handleAutomaticSync();
  };
  function getProvider(providerClass) {
    return new providerClass().init({
      // eslint-disable-line new-cap
      googleLoginHint: module36.options.googleAccount.value
    });
  }
  var lastModifiedStorage = storage_exports.wrapPrefix("backup.lastModified.", () => 0);
  var lastCheckStorage = storage_exports.wrap("backup.lastCheck", 0);
  async function handleAutomaticSync() {
    const automaticProviderKey = module36.options.automaticBackups.value;
    if (automaticProviderKey === "none") return;
    const providerClass = Object.values(providers_exports).find((p) => p.key === automaticProviderKey);
    if (!providerClass) throw new Error(`Can't find provider with key ${automaticProviderKey}`);
    const now4 = Date.now();
    const lastCheck = await lastCheckStorage.get();
    if (now4 - lastCheck < parseFloat(module36.options.syncFrequency.value) * HOUR) return;
    if (!await lastCheckStorage.compareAndSet(lastCheck, now4)) return;
    const provider = await getProvider(providerClass);
    let restored = false;
    if (module36.options.automaticRestore.value) {
      let remoteBackup;
      const lastModifiedKey = lastModifiedStorage._keyGen(providerClass.key);
      try {
        remoteBackup = deserialize(await provider.read());
      } catch (e2) {
        console.warn("Failed to read automatic backup:", e2);
        remoteBackup = { [lastModifiedKey]: 0 };
      }
      if (remoteBackup[lastModifiedKey] > await lastModifiedStorage.get(providerClass.key)) {
        await restore(provider, module36.options.warnBeforeAutomaticRestore.value ? "automatic" : "none");
        restored = true;
      }
    }
    if (!restored) {
      await backup(provider);
    }
  }
  async function backup(provider) {
    const { key, text, notifyBackupDone } = provider.constructor;
    await lastModifiedStorage.set(key, Date.now());
    const storage3 = await storage_exports.getAll();
    await provider.write(serialize(storage3));
    if (notifyBackupDone) {
      showNotification({
        message: i18n("backupAndRestoreSavedNotification", text),
        notificationID: "backupAndRestoreSaved",
        moduleID: module36.moduleID,
        closeDelay: 1e3
      });
    }
  }
  async function restore(provider, alertType = "normal") {
    const { key, name: name2 } = provider.constructor;
    const data2 = await provider.read();
    const storage3 = deserialize(data2);
    const isAutomatic = alertType === "automatic";
    if (alertType !== "none") {
      const lastModifiedKey = lastModifiedStorage._keyGen(key);
      const backupDate = storage3[lastModifiedKey];
      let size;
      try {
        size = new Intl.NumberFormat(locale, { style: "unit", unit: "byte", notation: "compact", unitDisplay: "narrow" }).format(data2.length);
      } catch (e2) {
        size = `${data2.length / 1e6} MB`;
      }
      try {
        await alert_exports.open(`
			${isAutomatic ? `
				<p><b>${i18n("backupAndRestoreFoundBackup", name2)}</b></p>
				<br>
			` : ""}
			<p>${i18n("backupAndRestoreBackupOverwriteWarning")}</p>
			<br>
			${isAutomatic ? `
				<p>${i18n("backupAndRestoreAfterCancel")}</p>
				<br>
			` : ""}
			${backupDate ? `
				<p>${i18n("backupAndRestoreBackupDate", formatDateTime(new Date(backupDate)))}</p>
			` : ""}
			<p>${i18n("backupAndRestoreBackupSize", size)}</p>
		`, { cancelable: true });
      } catch (e2) {
        if (isAutomatic) {
          open3(module36.moduleID, "automaticBackups");
        }
        return;
      }
    }
    await storage_exports.setMultiple(storage3);
    await lastCheckStorage.set(Date.now());
    await sendMessage("runMigrations");
    postRestore(module36.options.reloadWarning.value);
    await alert_exports.open(i18n("backupAndRestoreImported"));
    postRestore.local("auto");
  }
  var postRestore = multicast((operation) => {
    switch (operation) {
      case "warn":
        alert_exports.open(i18n("backupAndRestoreImportedOtherTabs"), { cancelable: true }).then(() => location.reload(), () => {
        });
        break;
      case "auto":
        location.reload();
        break;
      case "none":
      default:
        break;
    }
  }, { name: "restore-settings-warning", local: false });

  // lib/modules/betteReddit.js
  var import_jquery26 = __toESM(require_jquery(), 1);

  // lib/modules/subredditManager.js
  var subredditManager_exports = {};
  __export(subredditManager_exports, {
    createShortcutToggleButton: () => createShortcutToggleButton,
    getMultiCounts: () => getMultiCounts,
    module: () => module37,
    subscribeToSubreddit: () => subscribeToSubreddit
  });
  var import_jquery25 = __toESM(require_jquery(), 1);
  var module37 = new Module("subredditManager");
  module37.moduleName = "subredditManName";
  module37.category = "subredditsCategory";
  module37.description = "subredditManDesc";
  module37.include = ["r2"];
  module37.bodyClass = true;
  module37.options = {
    subredditShortcut: {
      title: "subredditManagerSubredditShortcutTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerSubredditShortcutDesc"
    },
    shortcutsPerAccount: {
      title: "subredditManagerShortcutsPerAccountTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerShortcutsPerAccountDesc"
    },
    alwaysApplySuffixToMulti: {
      title: "subredditManagerAlwaysApplySuffixToMultiTitle",
      type: "boolean",
      value: false,
      description: "subredditManagerAlwaysApplySuffixToMultiDesc"
    },
    dropdownEditButton: {
      title: "subredditManagerDropdownEditButtonTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerDropdownEditButtonDesc"
    },
    shortcutDropdownDelay: {
      title: "subredditManagerShortcutDropdownDelayTitle",
      type: "text",
      value: "200",
      description: "subredditManagerShortcutDropdownDelayDesc"
    },
    shortcutEditDropdownDelay: {
      title: "subredditManagerShortcutEditDropdownDelayTitle",
      dependsOn: (options6) => options6.dropdownEditButton.value,
      type: "text",
      value: "3000",
      description: "subredditManagerShortcutEditDropdownDelayDesc"
    },
    allowLowercase: {
      title: "subredditManagerAllowLowercaseTitle",
      type: "boolean",
      value: false,
      description: "subredditManagerAllowLowercaseDesc",
      bodyClass: true
    },
    linkDashboard: {
      title: "subredditManagerLinkDashboardTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkDashboardDesc"
    },
    linkAll: {
      title: "subredditManagerLinkAllTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkAllDesc"
    },
    linkFront: {
      title: "subredditManagerLinkFrontTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkFrontDesc"
    },
    linkPopular: {
      title: "subredditManagerLinkPopularTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkPopularDesc"
    },
    linkProfilePosts: {
      title: "subredditManagerLinkProfilePostsTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkProfilePostsDesc"
    },
    linkRandom: {
      title: "subredditManagerLinkRandomTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkRandomDesc"
    },
    linkMyRandom: {
      title: "subredditManagerLinkMyRandomTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkMyRandomDesc"
    },
    linkRandNSFW: {
      title: "subredditManagerLinkRandNSFWTitle",
      type: "boolean",
      value: false,
      description: "subredditManagerLinkRandNSFWDesc"
    },
    linkUsers: {
      title: "subredditManagerLinkUsersTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkUsersDesc"
    },
    linkFriends: {
      title: "subredditManagerLinkFriendsTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkFriendsDesc"
    },
    linkMod: {
      title: "subredditManagerLinkModTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkModDesc"
    },
    linkModqueue: {
      title: "subredditManagerLinkModqueueTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkModqueueDesc"
    },
    linkSaved: {
      title: "subredditManagerLinkSavedTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLinkSavedDesc"
    },
    buttonEdit: {
      title: "subredditManagerButtonEditTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerButtonEditDesc"
    },
    lastUpdate: {
      title: "subredditManagerLastUpdateTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerLastUpdateDesc"
    },
    storeSubredditVisit: {
      title: "subredditManagerStoreSubredditVisitTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerStoreSubredditVisitDesc",
      advanced: true
    },
    storeSubredditVisitIncognito: {
      title: "subredditManagerStoreSubredditVisitIncognitoTitle",
      dependsOn: (options6) => options6.storeSubredditVisit.value,
      type: "boolean",
      value: false,
      description: "subredditManagerStoreSubredditVisitIncognitoDesc",
      advanced: true
    },
    displayMultiCounts: {
      title: "subredditManagerDisplayMultiCountsTitle",
      type: "boolean",
      value: true,
      description: "subredditManagerDisplayMultiCountsDesc"
    }
  };
  var subredditBar;
  var shortcutsContainer;
  var $subredditGroupDropdown;
  var subredditGroupDropdownUL;
  var subredditGroupDropdownRefItem;
  var $editShortcutDialog;
  var deleteButton;
  var originalShortcuts;
  var mySubredditShortcuts = [];
  var subredditsLastViewedStorage = storage_exports.wrap(() => `RESmodules.subredditManager.subredditsLastViewed.${loggedInUser() || "null"}`, {});
  var subredditShortcutsStorage = storage_exports.wrap(() => {
    const username = module37.options.shortcutsPerAccount.value ? loggedInUser() : null;
    return `RESmodules.subredditManager.subredditShortcuts.${username || "null"}`;
  }, []);
  var loadShortcuts = async () => {
    mySubredditShortcuts = await subredditShortcutsStorage.get();
  };
  var initialShortcutsLoad = once_default(loadShortcuts);
  module37.beforeLoad = () => {
    pagePhases_exports.bodyStart.then(async (body) => {
      const headerArea = await waitForDescendant(body, "#sr-header-area");
      await waitForDescendant(headerArea, ".sr-list");
      createSubredditBar(headerArea);
    });
  };
  module37.contentStart = () => {
    fillStaticShortcuts();
    initialShortcutsLoad().then(redrawShortcuts);
    if (module37.options.subredditShortcut.value) {
      createElement_exports.sidebarSubscribeButtonWrappers().forEach((wrapper) => {
        const button = createShortcutToggleButton(wrapper.getAttribute("subreddit"));
        initialShortcutsLoad().then(() => button.dispatchEvent(new CustomEvent("refresh")));
        button.classList.add("RESshortcutside");
        wrapper.append(button);
      });
    }
    watchForThings(["subreddit"], async (thing) => {
      await initialShortcutsLoad();
      const titleElement = thing.getTitleElement();
      const container2 = thing.element.querySelector(".midcol");
      if (!titleElement || !container2) return;
      const [, subreddit2] = regexes.subreddit.exec(titleElement.pathname) || [];
      if (!subreddit2) return;
      container2.append(createShortcutToggleButton(subreddit2));
    });
  };
  module37.afterLoad = () => {
    if (module37.options.lastUpdate.value && document.getElementsByClassName("listing-chooser").length) {
      lastUpdate();
    }
    const subreddit2 = currentSubreddit();
    if (subreddit2) {
      requestAnimationFrame(() => {
        setLastViewtime(subreddit2);
      });
    }
  };
  function createShortcutToggleButton(subreddit2) {
    return createElement_exports.fancyToggleButton(
      i18n("subredditInfoAddRemoveShortcut"),
      i18n("subredditInfoAddThisSubredditToShortcuts"),
      () => mySubredditShortcuts.some((shortcut) => shortcut.subreddit.toLowerCase() === subreddit2.toLowerCase()),
      (state) => {
        if (state) addSubredditShortcut(subreddit2);
        else removeSubredditShortcut(subreddit2);
        redrawShortcuts();
      }
    );
  }
  var followSubredditShortcut = debounce_default((url) => {
    location.href = url;
  }, 300);
  var hideSubredditGroupDropdownTimer;
  var showSubredditGroupDropdownTimer;
  var dragSrc;
  function redrawShortcuts() {
    shortcutsContainer.textContent = "";
    const currentSub = (currentSubreddit() || "").toLowerCase().split("+").sort().join("+");
    const isCurrent = (sub) => {
      const sortedSubs = sub.replace(/\?\+/g, "+").split("+").sort();
      return sortedSubs.some((v) => isCurrentSubreddit(v)) || currentSub === sortedSubs.join("+");
    };
    for (const shortcut of mySubredditShortcuts) {
      const thisShortCut = document.createElement("a");
      thisShortCut.setAttribute("data-subreddit", shortcut.subreddit);
      thisShortCut.classList.add("subbarlink");
      if (isCurrent(shortcut.subreddit)) thisShortCut.classList.add("RESShortcutsCurrentSub");
      thisShortCut.setAttribute("href", `/r/${shortcut.subreddit.replace(/(?:\?\+.*|\?$)/, "")}`);
      thisShortCut.textContent = shortcut.displayName;
      thisShortCut.addEventListener("click", (e2) => {
        if (e2.button !== 0 || e2.ctrlKey || e2.metaKey || e2.altKey || e2.shiftKey) {
          return true;
        } else {
          e2.preventDefault();
          followSubredditShortcut(e2.currentTarget.href);
        }
      });
      thisShortCut.addEventListener("dblclick", (e2) => {
        e2.preventDefault();
        followSubredditShortcut.cancel();
        hideSubredditGroupDropdown();
        editSubredditShortcut(e2.currentTarget, e2);
      });
      thisShortCut.addEventListener("mouseover", (e2) => {
        clearTimeout(hideSubredditGroupDropdownTimer);
        showSubredditGroupDropdown(e2.currentTarget);
      });
      thisShortCut.addEventListener("mouseout", () => {
        clearTimeout(showSubredditGroupDropdownTimer);
        hideSubredditGroupDropdownTimer = setTimeout(() => hideSubredditGroupDropdown(), 500);
      });
      thisShortCut.addEventListener("dragstart", function(e2) {
        this.style.opacity = "0.4";
        followSubredditShortcut.cancel();
        dragSrc = this;
        e2.dataTransfer.effectAllowed = "move";
        addTrashBin(this);
      });
      thisShortCut.addEventListener("dragenter", () => {
        thisShortCut.style.outline = "1px dashed black";
      });
      thisShortCut.addEventListener("dragleave", () => {
        thisShortCut.style.outline = "";
      });
      thisShortCut.addEventListener("dragover", (e2) => {
        e2.preventDefault();
        if ($subredditGroupDropdown) {
          $subredditGroupDropdown.hide();
        }
        e2.dataTransfer.dropEffect = "move";
      });
      thisShortCut.addEventListener("drop", function() {
        const srcSubreddit = dragSrc.dataset.subreddit;
        const dstSubreddit = this.dataset.subreddit;
        const src = mySubredditShortcuts.find(({ subreddit: subreddit2 }) => srcSubreddit === subreddit2);
        const dst = mySubredditShortcuts.find(({ subreddit: subreddit2 }) => dstSubreddit === subreddit2);
        if (!src || !dst) throw new Error();
        pull_default(mySubredditShortcuts, src);
        mySubredditShortcuts.splice(mySubredditShortcuts.indexOf(dst), 0, src);
        redrawShortcuts();
        saveLatestShortcuts();
      });
      thisShortCut.addEventListener("dragend", function() {
        this.style.opacity = "";
        this.classList.remove("srOver");
        removeTrashBin();
      });
      const sep = document.createElement("span");
      sep.setAttribute("class", "separator");
      sep.textContent = "-";
      shortcutsContainer.append(sep);
      shortcutsContainer.append(thisShortCut, sep);
    }
    if (mySubredditShortcuts.length) {
      shortcutsContainer.style.textTransform = "";
    } else {
      shortcutsContainer.style.textTransform = "none";
      shortcutsContainer.textContent = "add shortcuts from the my subreddits menu at left or click the button by the subreddit name, drag and drop to sort";
    }
  }
  function showSubredditGroupDropdown(obj) {
    let subreddits2 = [];
    let suffix = "";
    if (obj.getAttribute && obj.getAttribute("data-subreddit").includes("+")) {
      let cleanSubreddits = obj.getAttribute("data-subreddit");
      if (cleanSubreddits.indexOf("/") > cleanSubreddits.lastIndexOf("+") || module37.options.alwaysApplySuffixToMulti.value) {
        let pos;
        if ((pos = cleanSubreddits.lastIndexOf("?")) > cleanSubreddits.lastIndexOf("+")) {
          suffix = cleanSubreddits.substr(pos);
          cleanSubreddits = cleanSubreddits.substr(0, pos);
        }
        if ((pos = cleanSubreddits.lastIndexOf("/")) > cleanSubreddits.lastIndexOf("+")) {
          suffix = cleanSubreddits.substr(pos) + suffix;
          cleanSubreddits = cleanSubreddits.substr(0, pos);
        }
      }
      subreddits2 = cleanSubreddits.replace(/\?\+/g, "+").split("+");
    }
    if (!(subreddits2.length || module37.options.dropdownEditButton.value)) {
      return;
    }
    let delay;
    if (subreddits2.length) {
      delay = parseInt(module37.options.shortcutDropdownDelay.value, 10);
    } else {
      delay = parseInt(module37.options.shortcutEditDropdownDelay.value, 10);
    }
    clearTimeout(showSubredditGroupDropdownTimer);
    showSubredditGroupDropdownTimer = setTimeout(
      () => _showSubredditGroupDropdown(obj, subreddits2, suffix),
      delay
    );
  }
  function _showSubredditGroupDropdown(obj, subreddits2, suffix) {
    subredditGroupDropdownRefItem = obj;
    if (!$subredditGroupDropdown) {
      $subredditGroupDropdown = (0, import_jquery25.default)("<div>", { id: "RESSubredditGroupDropdown" });
      subredditGroupDropdownUL = document.createElement("ul");
      $subredditGroupDropdown.append(subredditGroupDropdownUL);
      if (module37.options.dropdownEditButton.value) {
        $subredditGroupDropdown.append(`
				<div class="RESShortcutsEditButtons">
					<a href="#" class="delete res-icon" title="delete">&#xF155;</a>
					<a href="#" class="edit res-icon" title="edit">&#xF139;</a>
				</div>
			`);
      }
      $subredditGroupDropdown.appendTo(document.body);
      $subredditGroupDropdown.on("mouseout", () => {
        hideSubredditGroupDropdownTimer = setTimeout(() => {
          hideSubredditGroupDropdown();
        }, 500);
      });
      $subredditGroupDropdown.on("mouseover", () => {
        clearTimeout(hideSubredditGroupDropdownTimer);
      });
      $subredditGroupDropdown.on("click", ".edit", (e2) => {
        e2.preventDefault();
        hideSubredditGroupDropdown();
        editSubredditShortcut(subredditGroupDropdownRefItem, e2);
      });
      $subredditGroupDropdown.on("click", ".delete", (e2) => {
        e2.preventDefault();
        hideSubredditGroupDropdown();
        editSubredditShortcut(subredditGroupDropdownRefItem, e2);
        deleteButton.click();
      });
    }
    (0, import_jquery25.default)(subredditGroupDropdownUL).find("li:not(.RESShortcutsEditButtons)").remove();
    if (subreddits2) {
      const $rows = subreddits2.reduce(($collection, subreddit2) => {
        const $thisLI = (0, import_jquery25.default)(`<li><a href="/r/${subreddit2}${suffix}">${subreddit2}<span class="shortcutSuffix">${suffix}</span></a></li>`);
        if (isCurrentSubreddit(subreddit2)) {
          $thisLI.addClass("RESShortcutsCurrentSub");
        }
        return $collection.add($thisLI);
      }, (0, import_jquery25.default)());
      (0, import_jquery25.default)(subredditGroupDropdownUL).prepend($rows);
    }
    const { left } = (0, import_jquery25.default)(obj).offset();
    const { bottom } = document.querySelector("#sr-header-area").getBoundingClientRect();
    $subredditGroupDropdown.css({ top: `${bottom}px`, left: `${left}px` }).show();
  }
  function hideSubredditGroupDropdown() {
    hideSubredditGroupDropdownTimer = void 0;
    if ($subredditGroupDropdown) {
      $subredditGroupDropdown.hide();
    }
  }
  function editSubredditShortcut(ele, event) {
    const subreddit2 = ele.getAttribute("data-subreddit");
    const idx = mySubredditShortcuts.findIndex((shortcut) => shortcut.subreddit === subreddit2);
    if (!$editShortcutDialog) {
      $editShortcutDialog = (0, import_jquery25.default)("<div>", { id: "editShortcutDialog" }).appendTo(document.body);
    }
    const unsortable = !subreddit2.includes("+");
    const thisForm = `
		<form name="editSubredditShortcut">
			<h3>Edit Shortcut</h3>
			<div id="editShortcutClose" class="RESCloseButton RESCloseButtonTopRight"></div>
			<div class="RESFormItem">
				<label for="subreddit">Subreddit:</label>
				<div class="RESFieldItem">
					<input type="text" name="subreddit" value="${subreddit2}" id="shortcut-subreddit" class="${unsortable ? "unsortable" : ""}"><!-- no whitespace
					--><button type="submit" id="sortButton" title="Sort subreddits">A-Z</button>

					<div class="RESDescription">Put a + between subreddits to make a drop-down menu.<br/>Put ?+ to make subreddits after it only show in dropdown.</div>
				</div>
			</div>
			<div class="RESFormItem">
				<label for="displayName">Display Name:</label>
				<div class="RESFieldItem">
					<input type="text" name="displayName" value="${ele.textContent}" id="shortcut-displayname">
				</div>
			</div>
			<input type="hidden" name="idx" value="${idx}">
			<button type="button" name="shortcut-save" id="shortcut-save">save</button>
			<button type="button" name="shortcut-delete" id="shortcut-delete">delete</button>
		</form>
	`;
    $editShortcutDialog.html(thisForm);
    $editShortcutDialog.find("#shortcut-subreddit").on("keyup", throttle_default(({ currentTarget: shortcut }) => {
      if (!shortcut.value.includes("+")) {
        shortcut.classList.add("unsortable");
      } else {
        shortcut.classList.remove("unsortable");
      }
    }, 500));
    const subredditInput = downcast($editShortcutDialog.get(0).querySelector("input[name=subreddit]"), HTMLInputElement);
    const displayNameInput = downcast($editShortcutDialog.get(0).querySelector("input[name=displayName]"), HTMLInputElement);
    $editShortcutDialog.find("FORM").on("submit", (e2) => e2.preventDefault());
    const saveButton = $editShortcutDialog.find("button[name=shortcut-save]").click(() => {
      const idx2 = $editShortcutDialog.find("input[name=idx]").val();
      const subreddit3 = $editShortcutDialog.find("input[name=subreddit]").val();
      const displayName = $editShortcutDialog.find("input[name=displayName]").val();
      saveSubredditShortcut(subreddit3, displayName, idx2);
      $editShortcutDialog.hide();
    }).get(0);
    deleteButton = $editShortcutDialog.find("button[name=shortcut-delete]").get(0);
    deleteButton.addEventListener("click", () => {
      const idx2 = $editShortcutDialog.find("input[name=idx]").val();
      if (confirm("Are you sure you want to delete this shortcut?")) {
        saveSubredditShortcut("", "", idx2);
        $editShortcutDialog.hide();
      }
    });
    $editShortcutDialog.find("#sortButton").click(({ currentTarget }) => {
      const currStr = subredditInput.value;
      const ascArr = currStr.split("+").sort((a2, b2) => a2.localeCompare(b2, void 0, { sensitivity: "base" }));
      const ascStr = ascArr.join("+");
      const descStr = ascArr.reverse().join("+");
      subredditInput.value = currStr === ascStr ? descStr : ascStr;
      currentTarget.textContent = currStr === ascStr ? "A-Z" : "Z-A";
    });
    subredditInput.addEventListener("keydown", (e2) => {
      if (e2.key === NAMED_KEYS.Enter) {
        e2.preventDefault();
        e2.stopPropagation();
      }
    });
    subredditInput.addEventListener("keyup", (e2) => {
      if (e2.key === NAMED_KEYS.Escape) {
        $editShortcutDialog.hide().blur();
      } else if (e2.key === NAMED_KEYS.Enter) {
        click(saveButton);
      }
    });
    displayNameInput.addEventListener("keyup", (e2) => {
      if (e2.key === NAMED_KEYS.Escape) {
        $editShortcutDialog.hide().blur();
      } else if (e2.key === NAMED_KEYS.Enter) {
        click(saveButton);
      }
    });
    $editShortcutDialog.find("#editShortcutClose").click(() => {
      $editShortcutDialog.hide();
    });
    $editShortcutDialog.show();
    const thisLeft = Math.min(event.clientX, window.innerWidth - ($editShortcutDialog.get(0).offsetWidth + 20));
    $editShortcutDialog.css("left", `${thisLeft}px`);
    setTimeout(() => subredditInput.focus(), 200);
  }
  async function saveSubredditShortcut(subreddit2, displayName, idx) {
    if (subreddit2 === "" || displayName === "") {
      subreddit2 = mySubredditShortcuts[idx].subreddit;
      await removeSubredditShortcut(subreddit2);
    } else {
      mySubredditShortcuts[idx] = {
        subreddit: subreddit2,
        displayName,
        addedDate: Date.now()
      };
      saveLatestShortcuts();
    }
    redrawShortcuts();
  }
  function createSubredditBar(_subredditBar) {
    originalShortcuts = Array.from(_subredditBar.querySelectorAll(".sr-list a.choice"));
    subredditBar = _subredditBar;
    subredditBar.innerHTML = `
		<div id="srLeftContainer" class="sr-bar">
			<div id="srDropdown">
					<div id="srDropdownContainer"><a href="javascript:void 0">My Subreddits</a></div>
			</div>
			<div id="RESStaticShortcuts"></div>
			<span class="srSep">|</span>
		</div>
		<div id="RESShortcutsViewport">
			<div id="RESShortcuts" class="sr-bar"></div>
		</div>
		<div id="RESShortcutsEditContainer">
			<div id="RESShortcutsSort" title="sort subreddit shortcuts">\u2191\u2193</div>
			<div id="RESShortcutsRight">&gt;</div>
			<div id="RESShortcutsAdd" class="res-icon" title="add shortcut">\uF139</div>
			<div id="RESShortcutsLeft">&lt;</div>
		</div>
	`;
    subredditBar.querySelector("#srDropdownContainer").addEventListener("click", (e2) => {
      e2.stopImmediatePropagation();
      toggleSubredditDropdown();
    });
    shortcutsContainer = subredditBar.querySelector("#RESShortcuts");
    const shortcutsEditContainer = document.createElement("div");
    shortcutsEditContainer.classList.add("res-sr-edit");
    subredditBar.querySelector("#RESShortcutsSort").addEventListener("click", async ({ currentTarget }) => {
      const menu = sortMenu();
      document.body.append(menu);
      const { bottom, left } = currentTarget.getBoundingClientRect();
      menu.style.top = `${bottom}px`;
      menu.style.left = `${Math.min(document.body.getBoundingClientRect().width - menu.getBoundingClientRect().width, left)}px`;
      await waitForEvent(menu, "mouseleave");
      menu.remove();
    });
    const addButton = subredditBar.querySelector("#RESShortcutsAdd");
    addButton.addEventListener("click", () => {
      toggleShortCutsAddForm();
    });
    const leftButton = subredditBar.querySelector("#RESShortcutsLeft");
    leftButton.addEventListener("click", () => {
      const firstChild = shortcutsContainer.firstChild;
      const containerMargin = parseInt(firstChild.style.marginLeft, 10) || 0;
      const shiftWidth = Math.floor((0, import_jquery25.default)("#RESShortcutsViewport").width()) - 80;
      const marginLeft = containerMargin + shiftWidth;
      if (marginLeft <= 0) {
        firstChild.style.marginLeft = `${marginLeft}px`;
      }
    });
    const rightButton = subredditBar.querySelector("#RESShortcutsRight");
    rightButton.addEventListener("click", () => {
      const firstChild = shortcutsContainer.firstChild;
      let marginLeft = firstChild.style.marginLeft;
      marginLeft = parseInt(marginLeft.replace("px", ""), 10);
      if (isNaN(marginLeft)) marginLeft = 0;
      const shiftWidth = (0, import_jquery25.default)("#RESShortcutsViewport").width() - 80;
      if (shortcutsContainer.offsetWidth > shiftWidth) {
        marginLeft -= shiftWidth;
        firstChild.style.marginLeft = `${marginLeft}px`;
      }
    });
  }
  function fillStaticShortcuts() {
    const myRandom = module37.options.linkMyRandom.value && originalShortcuts.find(({ pathname }) => pathname === "/r/myrandom/");
    const myRandomGold = myRandom && myRandom.classList.contains("gold");
    const users = module37.options.linkUsers.value && originalShortcuts.find(({ pathname }) => pathname === "/users/");
    const originalFrontpage = originalShortcuts.find(({ pathname }) => pathname === "/");
    const originalPopular = originalShortcuts.find(({ pathname }) => pathname === "/r/popular/");
    const originalProfilePosts = originalShortcuts.find(({ pathname }) => pathname === "/r/profileposts/");
    const originalMod = originalShortcuts.find(({ pathname }) => pathname.startsWith("/r/mod"));
    let shortcuts = [
      module37.options.linkDashboard.value && '<a class="subbarlink" href="/r/Dashboard/">Dashboard</a>',
      module37.options.linkFront.value && originalFrontpage && `<a class="subbarlink" href="/">${originalFrontpage.textContent}</a>`,
      module37.options.linkPopular.value && originalPopular && `<a class="subbarlink" href="/r/popular/">${originalPopular.textContent}</a>`,
      module37.options.linkProfilePosts.value && originalProfilePosts && `<a class="subbarlink" href="/r/profileposts/">${originalProfilePosts.textContent}</a>`,
      module37.options.linkAll.value && '<a class="subbarlink" href="/r/all/">All</a>',
      module37.options.linkRandom.value && '<a class="subbarlink" href="/r/random/">Random</a>',
      module37.options.linkMyRandom.value && myRandom && `<a class="subbarlink ${myRandomGold ? "gold" : ""}" href="/r/myrandom/">MyRandom</a>`,
      module37.options.linkUsers.value && users && '<a class="subbarlink" href="/users/">Users</a>',
      module37.options.linkRandNSFW.value && '<a class="over18 subbarlink" href="/r/randnsfw/">RandNSFW</a>',
      isLoggedIn() && [
        module37.options.linkFriends.value && '<a class="subbarlink" href="/r/friends/">Friends</a>',
        originalMod && [
          module37.options.linkMod.value && '<a class="subbarlink" href="/r/mod/">Mod</a>',
          module37.options.linkModqueue.value && '<a class="subbarlink" href="/r/mod/about/modqueue">Modqueue</a>'
        ],
        module37.options.linkSaved.value && '<a class="subbarlink" href="/user/me/saved">Saved</a>'
      ],
      module37.options.buttonEdit.value && makeUrlHashLink(module37.moduleID, "", "edit", "subbarlink res-sr-options-link")
    ].flat(3).filter(Boolean).join('<span class="separator">-</span>');
    if (shortcuts) shortcuts = `<span class="separator">-</span>${shortcuts}`;
    const container2 = downcast(subredditBar.querySelector("#RESStaticShortcuts"), HTMLElement);
    container2.innerHTML = shortcuts;
    const choice = [...container2.querySelectorAll(".subbarlink:not(.res-sr-options-link)")].find((link) => link instanceof HTMLAnchorElement && fullLocation(link.pathname) === fullLocation());
    if (choice) choice.classList.add("RESShortcutsCurrentSub");
  }
  var trashBin = once_default(() => {
    const $title = (0, import_jquery25.default)("<div>", { class: "res-shortcut-trash-title" });
    const $trashZone = (0, import_jquery25.default)("<div>", { id: "res-shortcut-trash-zone", class: "res-icon" });
    const shortCutsTrash = $trashZone.get(0);
    shortCutsTrash.addEventListener("dragenter", () => {
      shortCutsTrash.style.borderColor = "rgb(200, 50, 50)";
    });
    shortCutsTrash.addEventListener("dragleave", () => {
      shortCutsTrash.style.borderColor = "";
    });
    shortCutsTrash.addEventListener("dragover", (e2) => {
      e2.preventDefault();
      e2.dataTransfer.dropEffect = "move";
    });
    shortCutsTrash.addEventListener("drop", () => {
      const srcSubreddit = dragSrc.dataset.subreddit;
      removeSubredditShortcut(srcSubreddit);
    });
    const $wrapper = (0, import_jquery25.default)("<div>", { id: "res-shortcut-trash" }).append(
      $title,
      $trashZone,
      (0, import_jquery25.default)("<div>", {
        id: "res-dragDrop-tip",
        text: "Did you know? You can arrange shortcuts by dragging them left & right along the top bar."
      })
    );
    return {
      $wrapper,
      $trashZone,
      $title
    };
  });
  function toggleShortCutsAddForm() {
    let shortCutsAddFormContainer = document.querySelector("#RESShortcutsAddFormContainer");
    const close3 = () => shortCutsAddFormContainer.remove();
    if (shortCutsAddFormContainer) {
      close3();
      return;
    }
    shortCutsAddFormContainer = document.createElement("div");
    shortCutsAddFormContainer.setAttribute("id", "RESShortcutsAddFormContainer");
    shortCutsAddFormContainer.append(string_exports.html`
		<form id="shortCutsAddForm">
			<div><strong>Add Shortcut</strong></div>
			<div class="res-shortcuts-add-tip">Put a &plus; between subreddits to make a multireddit.</div>
			<div><label for="newShortcut">Subreddit:</label><input type="text" id="newShortcut"></div>
			<div><label for="displayName">Display Name:</label><input type="text" id="displayName"></div>
			<input type="submit" name="submit" value="add" id="addSubreddit">
			<div class="res-shortcuts-add-footer">
				<a href="/subreddits/">manage subscribed</a>
				|
				<a class="res-trash-open" href="javascript: void 0" title="Choose which shortcuts to remove"><span class="res-icon">&#xF155;</span> remove shortcuts...</a>
			</div>
		</form>
	`);
    const shortCutsAddFormField = shortCutsAddFormContainer.querySelector("#newShortcut");
    const shortCutsAddFormFieldDisplayName = shortCutsAddFormContainer.querySelector("#displayName");
    shortCutsAddFormContainer.querySelector(".res-trash-open").addEventListener("click", () => {
      addTrashBin();
    });
    shortCutsAddFormField.addEventListener("keyup", (e2) => {
      if (e2.key === NAMED_KEYS.Escape) close3();
    });
    shortCutsAddFormFieldDisplayName.addEventListener("keyup", (e2) => {
      if (e2.key === NAMED_KEYS.Escape) close3();
    });
    const shortCutsAddForm = shortCutsAddFormContainer.querySelector("#shortCutsAddForm");
    shortCutsAddForm.addEventListener("submit", (e2) => {
      e2.preventDefault();
      let subreddit2 = shortCutsAddFormField.value;
      let displayname = shortCutsAddFormFieldDisplayName.value;
      if (displayname === "") displayname = subreddit2;
      subreddit2 = subreddit2.replace(/^\/?r\//i, "");
      if (subreddit2) {
        addSubredditShortcut(subreddit2, displayname);
      }
      close3();
    });
    document.body.append(shortCutsAddFormContainer);
    shortCutsAddFormField.focus();
  }
  var $pageOverlay = once_default(() => {
    const srHeaderArea = document.querySelector("#sr-header-area");
    return (0, import_jquery25.default)("<div>", { id: "res-trash-overlay" }).css({ top: `${srHeaderArea.offsetHeight}px` }).click(() => removeTrashBin());
  });
  function addTrashBin(shortcut) {
    if ($subredditGroupDropdown) {
      $subredditGroupDropdown.hide();
    }
    if (shortcut) {
      trashBin().$title.html(string_exports.escape`Drop here to delete shortcut <strong>${(0, import_jquery25.default)(shortcut).text()}</strong>`);
    } else {
      trashBin().$title.text("Drag and drop shortcuts to delete them");
    }
    trashBin().$wrapper.appendTo(document.body).show();
    $pageOverlay().appendTo(document.body).show();
  }
  function removeTrashBin() {
    $pageOverlay().hide();
    trashBin().$wrapper.hide();
    trashBin().$trashZone.removeClass("srOver");
  }
  var sortMenu = once_default(() => {
    const element = string_exports.html`
	<div id="sort-menu" style="display: block" class="drop-choices">
		<p>&nbsp;sort by:</p>
		<a class="choice" data-field="displayName" href="javascript:void 0">display name</a>
		<a class="choice" data-field="addedDate" href="javascript:void 0">added date</a>
	</div>`;
    let lastField;
    (0, import_jquery25.default)(element).find("a").click(({ currentTarget }) => {
      const field = currentTarget.dataset.field;
      const sameField = lastField === field;
      lastField = field;
      sortShortcuts(sameField ? null : field, sameField);
    });
    return element;
  });
  function sortShortcuts(field, reverse) {
    if (field) mySubredditShortcuts.sort((a2, b2) => String(a2[field]).localeCompare(String(b2[field]), void 0, { numeric: true, sensitivity: "base" }));
    if (reverse) mySubredditShortcuts.reverse();
    redrawShortcuts();
    saveLatestShortcuts();
  }
  var srList = once_default(() => {
    const element = document.createElement("div");
    element.id = "srList";
    const user = loggedInUser();
    if (!user) {
      element.append(string_exports.html`<div>Error: You must be logged in to load your own list of subreddits.</div>`);
      return element;
    }
    element.append(string_exports.html`<div>Loading subreddits ... (may take a a few seconds)</div>`);
    getMySubredditsTable(user).then((table2) => {
      empty(element);
      element.append(string_exports.html`<a style="float: right;" href="/subreddits/">View all &raquo;</a>`, table2);
    }).catch((e2) => {
      console.error(e2);
      element.append(string_exports.html`<span>There was an error getting your subreddits. You may have third party cookies disabled by your browser. For this function to work, you\'ll need to add an exception for cookies from reddit.com'</span>`);
    });
    return element;
  });
  async function toggleSubredditDropdown(e2) {
    const ele = await srList();
    if (ele && e2 && (ele.contains(e2.target) || !document.contains(e2.target))) return;
    if (document.body.contains(ele)) {
      ele.remove();
      document.body.removeEventListener("click", toggleSubredditDropdown);
    } else {
      document.body.append(ele);
      waitForDescendant(ele, "input").then((e3) => {
        e3.focus();
      });
      document.body.addEventListener("click", toggleSubredditDropdown);
    }
  }
  async function getMySubredditsTable(user) {
    const headers = {
      subreddit: "subreddit",
      ...module37.options.storeSubredditVisit.value ? { lastVisited: "last visited" } : {},
      shortcutToggle: ""
    };
    const mySubreddits = /* @__PURE__ */ new Map();
    let after = "";
    do {
      const { data: data3 } = await ajax({
        // eslint-disable-line no-await-in-loop
        url: "/subreddits/mine.json",
        query: {
          after,
          limit: 100,
          user
          // for the cache
        },
        type: "json",
        cacheFor: DAY
      });
      if (data3 && data3.children) {
        for (const { data: sub } of data3.children) mySubreddits.set(sub.display_name, sub);
        after = data3.after;
      } else if (!after) {
        throw new Error("No subreddits feched?");
      }
    } while (after);
    const subredditsLastViewed = await subredditsLastViewedStorage.get();
    const getRow = ({ display_name: displayName, url }) => {
      const lv = subredditsLastViewed[displayName.toLowerCase()];
      const ts = lv && parseInt(lv.last_visited, 10);
      const theLV = document.createElement("span");
      if (ts) {
        const dateVisited = new Date(ts);
        theLV.textContent = formatRelativeTime(dateVisited);
        theLV.setAttribute("title", formatDate(dateVisited));
        theLV.setAttribute("sort-value", String(Number.MAX_SAFE_INTEGER - dateVisited.getTime()));
      } else {
        theLV.textContent = "N/A";
      }
      const shortcutToggle = createShortcutToggleButton(displayName);
      shortcutToggle.style.cursor = "pointer";
      shortcutToggle.className = "";
      return {
        subreddit: string_exports.html`<a href="${url}">${displayName}</a>`,
        lastVisited: theLV,
        shortcutToggle
      };
    };
    const data2 = [...mySubreddits.values()];
    const table2 = new table_exports.RESTable(headers, data2, getRow, { pageSize: Infinity, sortBy: "subreddit" });
    const ele = document.createElement("div");
    ele.append(
      table2.createSearchElement(({ display_name: displayName }) => displayName, i18n("subredditManagerFilterPlaceholder")),
      table2.element
    );
    return ele;
  }
  async function getMultiCounts(displayName) {
    if (!module37.options.displayMultiCounts.value) return "";
    const user = loggedInUser();
    if (!user) return "";
    const multis = await ajax({
      url: `/api/multi/user/${user}`,
      type: "json",
      cacheFor: DAY
    });
    const count = multis.filter((multi) => multi.data.subreddits.some((sr) => sr.name === displayName)).length;
    if (count) return string_exports.escape`<span class="multi-count" title="${i18n("subredditManagerMultiCountTitle", displayName, count)}">${count}</span>`;
    else return "";
  }
  function saveLatestShortcuts() {
    subredditShortcutsStorage.set(mySubredditShortcuts || []);
  }
  async function addSubredditShortcut(subreddit2, displayname) {
    await loadShortcuts();
    const idx = mySubredditShortcuts.findIndex(
      (shortcut) => shortcut.subreddit.toLowerCase() === subreddit2.toLowerCase()
    );
    if (idx !== -1) {
      alert_exports.open("Whoops, you already have a shortcut for that subreddit");
    } else {
      displayname = displayname || subreddit2;
      const subredditObj = {
        subreddit: subreddit2,
        displayName: displayname.toLowerCase(),
        addedDate: Date.now()
      };
      mySubredditShortcuts.push(subredditObj);
      saveLatestShortcuts();
      redrawShortcuts();
      showNotification({
        moduleID: "subredditManager",
        message: "Subreddit shortcut added. You can edit by double clicking the shortcut."
      });
    }
  }
  async function removeSubredditShortcut(subreddit2) {
    await loadShortcuts();
    const idx = mySubredditShortcuts.findIndex(
      (shortcut) => shortcut.subreddit.toLowerCase() === subreddit2.toLowerCase()
    );
    if (idx !== -1) {
      mySubredditShortcuts.splice(idx, 1);
      saveLatestShortcuts();
      redrawShortcuts();
    }
  }
  function setLastViewtime(subreddit2) {
    if (!module37.options.storeSubredditVisit.value) return;
    if (!module37.options.storeSubredditVisitIncognito.value && isPrivateBrowsing()) return;
    subredditsLastViewedStorage.patch({ [subreddit2.toLowerCase()]: { last_visited: Date.now() } });
  }
  function subscribeToSubreddit(subredditName, subscribe2 = true) {
    return ajax({
      method: "POST",
      url: "/api/subscribe",
      data: {
        sr: subredditName,
        action: subscribe2 ? "sub" : "unsub"
      }
    });
  }
  async function lastUpdate() {
    const mySubredditList = (0, import_jquery25.default)(".drop-choices.srdrop a").map(function() {
      return this.textContent;
    }).toArray().join();
    const mySubredditListCachedObject = await session_exports.get("RESmodules.subredditManager.mySubredditList") || {};
    const mySubredditListCached = mySubredditListCachedObject[loggedInUser() || "null"];
    let _lastUpdate;
    if (mySubredditListCached && mySubredditListCached.list === mySubredditList) {
      _lastUpdate = parseInt(((/* @__PURE__ */ new Date()).getTime() - mySubredditListCached.time) / 6e4, 10);
      if (_lastUpdate > 31) {
        _lastUpdate = false;
        mySubredditListCached.time = (/* @__PURE__ */ new Date()).getTime() - 32 * 6e4;
      } else {
        _lastUpdate += _lastUpdate > 1 ? " minutes ago" : " minute ago";
      }
    } else {
      mySubredditListCachedObject[loggedInUser() || "null"] = {
        list: mySubredditList,
        time: (/* @__PURE__ */ new Date()).getTime()
      };
      _lastUpdate = "just now";
    }
    if (_lastUpdate !== false && mySubredditListCached) {
      (0, import_jquery25.default)(".listing-chooser a:first .description").after(`<br /><span class="description"><b>last update:</b><br />${_lastUpdate}</span>`);
    }
    const inactiveThreshold = (/* @__PURE__ */ new Date()).getTime() - 2592e6;
    for (const [user, cachedObject] of Object.entries(mySubredditListCachedObject)) {
      if (cachedObject.time < inactiveThreshold) {
        delete mySubredditListCachedObject[user];
      }
    }
    session_exports.set("RESmodules.subredditManager.mySubredditList", mySubredditListCachedObject);
  }

  // lib/modules/betteReddit.js
  var module38 = new Module("betteReddit");
  module38.moduleName = "betteRedditName";
  module38.category = "appearanceCategory";
  module38.description = "betteRedditDesc";
  module38.options = {
    commentsLinksNewTabs: {
      type: "boolean",
      value: false,
      description: "betteRedditCommentsLinksNewTabDesc",
      title: "betteRedditCommentsLinksNewTabTitle"
    },
    fixHideLinks: {
      type: "boolean",
      value: true,
      description: "betteRedditFixHideLinksDesc",
      title: "betteRedditFixHideLinksTitle"
    },
    hideLinkInstant: {
      type: "boolean",
      value: false,
      description: "betteRedditHideLinkInstantDesc",
      title: "betteRedditHideLinkInstantTitle",
      dependsOn: (options6) => options6.fixHideLinks.value
    },
    hideLinkFadeDelay: {
      type: "text",
      value: "5000",
      description: "betteRedditHideLinkFadeDelayDesc",
      title: "betteRedditHideLinkFadeDelayTitle",
      advanced: true,
      dependsOn: (options6) => options6.fixHideLinks.value && !options6.hideLinkInstant.value
    },
    videoTimes: {
      type: "boolean",
      value: true,
      description: "betteRedditVideoTimesDesc",
      title: "betteRedditVideoTimesTitle",
      advanced: true
    },
    videoUploaded: {
      type: "boolean",
      value: false,
      description: "betteRedditVideoUploadedDesc",
      title: "betteRedditVideoUploadedTitle",
      advanced: true
    },
    videoViewed: {
      type: "boolean",
      value: false,
      description: "betteRedditVideoViewedDesc",
      title: "betteRedditVideoViewedTitle",
      advanced: true
    },
    pinHeader: {
      type: "enum",
      values: [{
        name: "None",
        value: "none"
      }, {
        name: "Subreddit Bar only",
        value: "sub"
      }, {
        name: "User Bar",
        value: "userbar"
      }, {
        name: "Subreddit Bar and User bar",
        value: "subanduser"
      }, {
        name: "Full Header",
        value: "header"
      }],
      value: "none",
      description: "betteRedditPinHeaderDesc",
      title: "betteRedditPinHeaderTitle",
      bodyClass: "pinHeader"
    },
    permanentVerticalScrollbar: {
      type: "boolean",
      value: true,
      description: "betteRedditPermanentVerticalScrollbarDesc",
      title: "betteRedditPermanentVerticalScrollbarTitle",
      bodyClass: true
    },
    showLastEditedTimestamp: {
      type: "boolean",
      value: true,
      description: "betteRedditShowLastEditedTimestampDesc",
      title: "betteRedditShowLastEditedTimestampTitle",
      bodyClass: true
    },
    scoreHiddenTimeLeft: {
      type: "boolean",
      value: true,
      description: "betteRedditScoreHiddenTimeLeftDesc",
      title: "betteRedditScoreHiddenTimeLeftTitle"
    },
    showTimestampPosts: {
      type: "boolean",
      value: false,
      description: "betteRedditShowTimestampPostsDesc",
      title: "betteRedditShowTimestampPostsTitle",
      bodyClass: true
    },
    showTimestampComments: {
      type: "boolean",
      value: false,
      description: "betteRedditShowTimestampCommentsDesc",
      title: "betteRedditShowTimestampCommentsTitle",
      bodyClass: true
    },
    showTimestampSidebar: {
      type: "boolean",
      value: false,
      description: "betteRedditShowTimestampSidebarDesc",
      title: "betteRedditShowTimestampSidebarTitle",
      bodyClass: true
    },
    showTimestampWiki: {
      type: "boolean",
      value: false,
      description: "betteRedditShowTimestampWikiDesc",
      title: "betteRedditShowTimestampWikiTitle",
      bodyClass: true
    },
    showTimestampModerationLog: {
      type: "boolean",
      value: false,
      description: "betteRedditShowTimestampModerationLogDesc",
      title: "betteRedditShowTimestampModerationLogTitle",
      bodyClass: true
    },
    restoreSavedTab: {
      type: "boolean",
      value: false,
      description: "betteRedditRestoreSavedTabDesc",
      title: "betteRedditRestoreSavedTabTitle"
    },
    doNoCtrlF: {
      type: "boolean",
      value: false,
      description: "betteRedditDoNoCtrlFDesc",
      title: "betteRedditDoNoCtrlFTitle"
    },
    showHiddenSortOptions: {
      type: "boolean",
      value: false,
      description: "betteRedditShowHiddenSortOptionsDesc",
      title: "betteRedditShowHiddenSortOptionsTitle",
      bodyClass: true
    },
    truncateLongLinks: {
      type: "boolean",
      value: false,
      description: "betteRedditTruncateLongLinksDesc",
      title: "betteRedditTruncateLongLinksTitle",
      bodyClass: true
    },
    commentCollapseInInbox: {
      type: "boolean",
      value: false,
      description: "betteRedditCommentCollapseInInboxDesc",
      title: "betteRedditCommentCollapseInInboxTitle",
      bodyClass: true
    },
    blankPageUntilMeaningfulContent: {
      type: "boolean",
      value: false,
      description: "betteRedditBlankPageUntilMeaningfulContentDesc",
      title: "betteRedditBlankPageUntilMeaningfulContentTitle"
    },
    restrictScrollEvents: {
      type: "boolean",
      value: false,
      description: "betteRedditRestrictScrollEventsDesc",
      title: "betteRedditRestrictScrollEventsTitle",
      advanced: true
    }
  };
  module38.exclude = [
    "d2x"
  ];
  module38.beforeLoad = () => {
    if (module38.options.blankPageUntilMeaningfulContent.value) {
      document.documentElement.classList.add("res-hide-body");
    }
    if (module38.options.commentsLinksNewTabs.value) {
      watchForThings(["comment"], (comment) => {
        const body = comment.getTextBody();
        if (body) for (const link of body.querySelectorAll("a")) commentsLinksNewTabs(link);
      });
    }
    if (module38.options.fixHideLinks.value) {
      watchForThings(["post"], fixHideLinks);
    }
    if (module38.options.doNoCtrlF.value) {
      watchForElements(["page"], ".side a.reddit-comment-link", applyNoCtrlF);
      watchForThings(null, (thing) => {
        for (const link of thing.entry.querySelectorAll("ul.flat-list.buttons li a")) applyNoCtrlF(link);
      });
    }
    if (module38.options.videoTimes.value || module38.options.videoUploaded.value || module38.options.videoViewed.value) {
      watchForThings(["post"], showVideoData, { immediate: true });
    }
    switch (module38.options.pinHeader.value) {
      case "userbar":
        _addHeaderId("header-bottom-right", true);
        break;
      case "sub":
        _addHeaderId("sr-header-area");
        break;
      case "subanduser":
        _addHeaderId("sr-header-area");
        _addHeaderId("header-bottom-right", true);
        break;
      case "header":
        _addHeaderId("header");
        break;
      case "none":
      default:
        break;
    }
    if (module38.options.restrictScrollEvents.value) {
      const scr = document.createElement("script");
      scr.innerHTML = `{
			// Prevents overzealous Reddit scroll listeners from constantly mutating the DOM while scrolling
			let debounce, lastEvent;
			window.addEventListener('scroll', e => {
				// Note that '_.debounce' uses Reddit's instance of Lodash
				if (!debounce) debounce = _.debounce(e => window.dispatchEvent(e), 300);
				if (e === lastEvent) return;
				lastEvent = e;
				debounce(e);
				e.stopImmediatePropagation();
			}, true);
		}`;
      document.documentElement.append(scr);
    }
  };
  module38.contentStart = () => {
    if (module38.options.blankPageUntilMeaningfulContent.value) {
      document.documentElement.classList.remove("res-hide-body");
    }
    if (module38.options.scoreHiddenTimeLeft.value && isPageType("comments", "commentsLinklist")) {
      (0, import_jquery26.default)(document.body).on("mouseenter", ".score-hidden", function() {
        const timeNode = (0, import_jquery26.default)(this).siblings("time").get(0);
        if (timeNode) {
          if (!this.getAttribute("title").includes("revealed")) {
            const scoreHiddenDuration = parseInt(this.getAttribute("title").match(/[0-9]+/)[0], 10);
            const postTime = new Date(timeNode.getAttribute("datetime")).getTime();
            const minutesLeft = Math.ceil((postTime + scoreHiddenDuration * 6e4 - (/* @__PURE__ */ new Date()).getTime()) / 6e4);
            if (minutesLeft >= 1) {
              this.setAttribute("title", `score will be revealed in ${minutesLeft} minute${minutesLeft > 1 ? "s" : ""}`);
            } else {
              this.setAttribute("title", "reload page to reveal score");
            }
          }
        }
      });
    }
    const user = loggedInUser();
    if (module38.options.restoreSavedTab.value && user && document.querySelector(".with-listing-chooser:not(.profile-page)")) {
      restoreSavedTab(user);
    }
    switch (module38.options.pinHeader.value) {
      case "header":
        pinHeader();
        break;
      case "sub":
        pinSubredditBar();
        break;
      case "subanduser":
        pinSubredditBar();
        pinUserBar();
        break;
      case "userbar":
        pinUserBar();
        break;
      default:
        break;
    }
  };
  function commentsLinksNewTabs(link) {
    link.target = "_blank";
    link.rel = "noopener noreferer";
  }
  function fixHideLinks(thing) {
    const orig = thing.getHideElement();
    if (!orig) return;
    const a2 = document.createElement("a");
    a2.className = "noCtrlF";
    a2.href = "javascript:void 0";
    a2.dataset.eventAction = orig.dataset.eventAction;
    a2.dataset.text = i18n(
      orig.dataset.eventAction === "hide" ? "betteRedditHideLinkLabel" : "betteRedditUnhideLinkLabel"
    );
    a2.addEventListener("click", () => hideLink2(a2));
    orig.replaceWith(a2);
  }
  var hideTimer = /* @__PURE__ */ new Map();
  async function hideLink2(clickedLink, action = clickedLink.dataset.eventAction) {
    const timeout = module38.options.hideLinkInstant.value ? null : parseInt(module38.options.hideLinkFadeDelay.value, 10);
    const thing = Thing.checkedFrom(clickedLink);
    if (action === "hide") {
      const expando2 = Expando.getEntryExpandoFrom(thing);
      if (expando2 && expando2.types.includes("native")) expando2.collapse();
      if (timeout === null) {
        if (!isPageType("comments")) (0, import_jquery26.default)(thing.element).hide();
      } else {
        hideTimer.set(clickedLink, setTimeout(() => {
          if (clickedLink.dataset.eventAction === action) return;
          (0, import_jquery26.default)(thing.element).fadeOut(300);
        }, timeout));
      }
    }
    try {
      if (action === "hide") await hide2(thing);
      else await unhide(thing);
    } catch (e2) {
      alert_exports.open(i18n(action === "hide" ? "betteRedditHideSubmissionError" : "betteRedditUnhideSubmissionError"));
      (0, import_jquery26.default)(thing.element).show();
      throw e2;
    }
  }
  async function showVideoData(thing) {
    const url = new URL(thing.getPostUrl(), location.origin);
    if (!youtube_default.domains.some((domain) => url.hostname.endsWith(domain))) return;
    const [id2] = youtube_default.detect(url) || [];
    const data2 = id2 && await (youtube_default.getVideoData && youtube_default.getVideoData(id2));
    if (!data2) return;
    const { title, duration, publishedAt, viewCount } = data2;
    const link = thing.getPostLink();
    const info = [];
    if (module38.options.videoUploaded.value) {
      const uploaded = new Date(publishedAt);
      const dt = `${uploaded.toDateString()} ${uploaded.toTimeString()}`;
      const timeAgo = i18n("submitHelperTimeAgo", formatDateDiff(uploaded));
      info.push(`[<time title="${dt}" datetime="${publishedAt}" class="live-timestamp">${timeAgo}</time>]`);
    }
    if (module38.options.videoViewed.value && viewCount) {
      info.push(i18n("betteRedditVideoViewed", viewCount));
    }
    const titleHasTimeRegex = /[\[|\(][0-9]*:[0-9]*[\]|\)]/;
    const getYoutubeStartTimeRegex = /\/?[&|\?]?(?:t|time_continue)=([\w\-][a-z0-9]*)/i;
    const timeMatch = getYoutubeStartTimeRegex.exec(link.href);
    const titleMatch = titleHasTimeRegex.test(link.textContent);
    let startTime;
    if (timeMatch && !titleMatch) {
      const seconds = fromYoutubeTimecodeToSeconds(timeMatch[1]);
      startTime = fromSecondsToTime(seconds);
    }
    if (info.length) {
      link.appendChild(string_exports.html`<span class="gray pay-link">${string_exports.safe(info.join(" "))}</span>`);
    }
    link.setAttribute("title", i18n("betteRedditVideoYouTubeTitle", title));
    if (module38.options.videoTimes.value) {
      const thumbnail = thing.element.querySelector("a.thumbnail");
      if (thumbnail) {
        thumbnail.appendChild(string_exports.html`<div class="duration-overlay">${duration}${startTime ? ` (@${startTime})` : ""}</div>`);
      }
    }
  }
  function fromYoutubeTimecodeToSeconds(tc) {
    let timeSeconds = Number(tc);
    if (Number.isNaN(timeSeconds)) {
      const tcobj = tc.split(/(\d+[hms])/).filter(Boolean).reduce((acc, match) => {
        acc[match.slice(-1)] = Number(match.slice(0, -1));
        return acc;
      }, {});
      timeSeconds = (tcobj.h || 0) * 3600 + (tcobj.m || 0) * 60 + (tcobj.s || 0);
    }
    return timeSeconds;
  }
  function pinSubredditBar() {
    const sm = isRunning(subredditManager_exports);
    const sb = document.getElementById("sr-header-area");
    if (!sb) {
      return;
    }
    const header = document.getElementById("header");
    const spacer = document.createElement("div");
    spacer.style.paddingTop = window.getComputedStyle(sb, null).paddingTop;
    spacer.style.paddingBottom = window.getComputedStyle(sb, null).paddingBottom;
    if (sm) {
      spacer.style.height = `${parseInt(window.getComputedStyle(sb, null).height, 10) / 3 - 3}px`;
    } else {
      spacer.style.height = window.getComputedStyle(sb, null).height;
    }
    header.insertBefore(spacer, sb);
    document.body.insertBefore(sb, header);
    addCSS(`
		#header-bottom-left {
			margin-top: 19px;
		}

		div#sr-header-area {
			position: fixed;
			z-index: 10000 !important;
			left: 0;
			right: 0;
		}
	`);
    pinCommonElements(sm);
  }
  function pinUserBar() {
    const header = document.getElementById("header-bottom-left");
    const userbar2 = document.getElementById("header-bottom-right");
    window.addEventListener("scroll", debounce_default(() => {
      if (header.getBoundingClientRect().top > 0) {
        userbar2.classList.remove("res-floating-userbar");
      } else {
        userbar2.classList.add("res-floating-userbar");
      }
    }, 300));
    pinCommonElements();
  }
  function pinHeader() {
    const sm = isRunning(subredditManager_exports);
    const header = document.getElementById("header");
    if (!header) {
      console.error('No element found with ID "header".');
      return;
    }
    const headerHeight = (0, import_jquery26.default)("#header").outerHeight(true);
    addCSS(`
		#header,
		#RESAccountSwitcherDropdown {
			position: fixed;
		}
	`);
    pinCommonElements(sm);
    addCSS(`
		#header {
			top: 0;
			left: 0;
			right: 0;
			bottom: auto;
		}
	`);
    (0, import_jquery26.default)("<div>", {
      id: "RESPinnedHeaderSpacer",
      height: headerHeight
    }).insertBefore(header);
  }
  function pinCommonElements(sm) {
    if (sm) {
      addCSS(`
			#RESSubredditGroupDropdown,
			#srList,
			#RESShortcutsAddFormContainer,
			#editShortcutDialog {
				position: fixed !important;
			}
		`);
    } else {
      addCSS(`
			#sr-more-link {
				position: fixed;
			}
		`);
    }
  }
  function restoreSavedTab(user) {
    createElement_exports.tabMenuItem({
      text: "saved",
      onChange: () => {
        location.href = `/user/${user}/saved/`;
      }
    });
  }
  function applyNoCtrlF(element) {
    if (element.classList.contains("noCtrlF")) return;
    element.classList.add("noCtrlF");
    element.dataset.text = element.textContent;
    element.textContent = "";
  }

  // lib/modules/commentDepth.js
  var import_jquery27 = __toESM(require_jquery(), 1);
  var module39 = new Module("commentDepth");
  module39.moduleName = "commentDepthName";
  module39.category = "commentsCategory";
  module39.disabledByDefault = true;
  module39.description = "commentDepthDesc";
  module39.options = {
    defaultCommentDepth: {
      type: "text",
      value: "4",
      description: "commentDepthDefaultCommentDepthDesc",
      title: "commentDepthDefaultCommentDepthTitle"
    },
    defaultMinimumComments: {
      type: "text",
      value: "50",
      description: "commentDepthDefaultMinimumCommentsDesc",
      title: "commentDepthDefaultMinimumCommentsTitle"
    },
    commentPermalinks: {
      type: "boolean",
      value: false,
      description: "commentDepthCommentPermaLinksDesc",
      title: "commentDepthCommentPermaLinksTitle"
    },
    commentPermalinksContext: {
      dependsOn: (options6) => options6.commentPermalinks.value,
      type: "boolean",
      value: false,
      description: "commentDepthCommentPermalinksContextDesc",
      title: "commentDepthCommentPermalinksContextTitle"
    },
    subredditCommentDepths: {
      type: "table",
      addRowText: "commentDepthAddSubreddit",
      fields: [{
        key: "subreddits",
        name: "commentDepthSubreddit",
        type: "list",
        listType: "subreddits"
      }, {
        key: "commentDepth",
        name: "commentDepthCommentDepth",
        type: "text",
        value: "4"
      }, {
        key: "minimumComments",
        name: "commentDepthMinimumComments",
        type: "text",
        value: "50"
      }],
      value: [],
      description: "commentDepthSubredditCommentDepthsDesc",
      title: "commentDepthSubredditCommentDepthsTitle"
    }
  };
  module39.contentStart = () => {
    (0, import_jquery27.default)(document.body).on("mousedown", 'a[href*="/comments"]', (e2) => {
      const target = e2.currentTarget;
      const url = new URL(target.href, location.href);
      if (url.searchParams.has("depth")) return;
      if (regexes.commentPermalink.test(url.pathname)) {
        if (!module39.options.commentPermalinks.value) return;
        if (!module39.options.commentPermalinksContext.value && url.searchParams.has("context")) return;
      }
      const matches2 = execRegexes.comments(url.pathname);
      if (!matches2) return;
      const subreddit2 = matches2[1].toLowerCase();
      const [, commentDepth, minimumComments] = module39.options.subredditCommentDepths.value.find(([subreddits2]) => subreddits2.toLowerCase().split(",").includes(subreddit2)) || [null, module39.options.defaultCommentDepth.value, module39.options.defaultMinimumComments.value];
      if (!parseInt(commentDepth, 10)) return;
      const minimumCount = parseInt(minimumComments, 10);
      if (minimumCount) {
        const thing = Thing.from(e2.currentTarget);
        if (thing && thing.isPost() && (thing.getCommentCount() || 0) < minimumCount) return;
      }
      url.searchParams.set("depth", commentDepth);
      target.removeAttribute("data-inbound-url");
      target.href = url.href;
    });
  };

  // lib/modules/commentHidePersistor.js
  var import_jquery28 = __toESM(require_jquery(), 1);
  var module40 = new Module("commentHidePersistor");
  module40.moduleName = "commentHidePerName";
  module40.category = "commentsCategory";
  module40.description = "commentHidePerDesc";
  module40.include = [
    "comments",
    "inbox"
  ];
  var COLLAPSE_REASON = "commentHidePersistor";
  var currentId2 = (execRegexes.comments(location.pathname) || [])[2];
  var entryStorage3 = storage_exports.wrapPrefix("commentHidePersistor.", () => ({
    updateTime: Date.now()
  }));
  var initial2 = currentId2 && entryStorage3.get(currentId2);
  module40.beforeLoad = async () => {
    const { collapsedThings } = await initial2 || {};
    if (!collapsedThings) return;
    watchForThings(["comment"], (thing) => {
      if (collapsedThings.hasOwnProperty(thing.getFullname())) thing.setCommentCollapse(true, COLLAPSE_REASON);
    }, { immediate: true });
  };
  module40.contentStart = () => {
    listenToCommentCollapse();
    maybePruneOldEntries("commentHidePersistor", entryStorage3);
  };
  function listenToCommentCollapse() {
    (0, import_jquery28.default)(document.body).on("click", "a.expand", (e2) => {
      const thing = Thing.checkedFrom(e2.currentTarget);
      const collapsed = thing.isCollapsed();
      if (collapsed) {
        const currentCollapseReason = e2.currentTarget.getAttribute("collapse-reason");
        if (currentCollapseReason && currentCollapseReason !== COLLAPSE_REASON) return;
        entryStorage3.patch(currentId2, { collapsedThings: { [thing.getFullname()]: true }, updateTime: Date.now() });
      } else {
        e2.currentTarget.removeAttribute("collapse-reason");
        entryStorage3.deletePath(currentId2, "collapsedThings", thing.getFullname());
      }
    });
  }

  // lib/modules/commentPreview.js
  var import_jquery29 = __toESM(require_jquery(), 1);
  var module41 = new Module("commentPreview");
  module41.moduleName = "commentPrevName";
  module41.category = "commentsCategory";
  module41.description = "commentPrevDesc";
  module41.options = {
    enableBigEditor: {
      type: "boolean",
      value: true,
      description: "commentPreviewEnableBigEditorDesc",
      title: "commentPreviewEnableBigEditorTitle"
    },
    swapBigEditorLayout: {
      type: "boolean",
      value: false,
      description: "commentPreviewSwapBigEditorLayoutDesc",
      title: "commentPreviewSwapBigEditorLayoutTitle",
      bodyClass: true
    },
    openBigEditor: {
      type: "keycode",
      value: [69, false, true, false, false],
      // control-e
      description: "commentPreviewOpenBigEditorDesc",
      title: "commentPreviewOpenBigEditorTitle"
    },
    draftStyle: {
      type: "boolean",
      value: true,
      description: "commentPreviewDraftStyleDesc",
      title: "commentPreviewDraftStyleTitle",
      advanced: true,
      bodyClass: true
    },
    enableForComments: {
      type: "boolean",
      value: true,
      description: "commentPreviewEnableForCommentsDesc",
      title: "commentPreviewEnableForCommentsTitle",
      advanced: true
    },
    enableForPosts: {
      type: "boolean",
      value: true,
      description: "commentPreviewEnableForPostsDesc",
      title: "commentPreviewEnableForPostsTitle",
      advanced: true
    },
    enableForWiki: {
      type: "boolean",
      value: true,
      description: "commentPreviewEnableForWikiDesc",
      title: "commentPreviewEnableForWikiTitle",
      advanced: true
    },
    enableForSubredditConfig: {
      type: "boolean",
      value: true,
      description: "commentPreviewEnableForSubredditConfigDesc",
      title: "commentPreviewEnableForSubredditConfigTitle",
      advanced: true
    },
    enableForBanMessages: {
      type: "boolean",
      value: true,
      description: "commentPreviewEnableForBanMessagesDesc",
      title: "commentPreviewEnableForBanMessagesTitle",
      advanced: true
    },
    sidebarPreview: {
      type: "boolean",
      value: true,
      description: "commentPreviewSidebarPreviewDesc",
      title: "commentPreviewSidebarPreviewTitle",
      advanced: true
    }
  };
  module41.include = [
    "comments",
    "inbox",
    "submit",
    "profile",
    "modqueue",
    "subredditAbout",
    "wiki"
  ];
  module41.exclude = [
    "d2x",
    /^\/(?:r\/[\-\w\.]+\/)?wiki\/edit\/config\/automoderator\b/i
  ];
  var subredditImages = /* @__PURE__ */ new Map();
  var isWiki;
  var isBan;
  module41.beforeLoad = () => {
    isWiki = isPageType("wiki");
    isBan = /^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/about\/banned/i.test(location.href);
    const subreddit2 = currentSubreddit();
    if (isWiki && subreddit2) initWikiImages(subreddit2);
  };
  module41.contentStart = () => {
    if (module41.options.enableBigEditor.value) {
      if (isRunning(keyboardNav_exports)) {
        (0, import_jquery29.default)(document.body).on("keydown", ".usertext-edit textarea, #wiki_page_content", (e2) => {
          if (checkKeysForEvent(e2, module41.options.openBigEditor.value)) {
            showBigEditor(e2);
          }
        });
      }
    }
    if (isWiki) {
      attachWikiPreview();
      addBigEditorButton(document.querySelector(".markhelp"));
    } else {
      (0, import_jquery29.default)(document.body).on("focus", commentTextareaSelector, (e2) => {
        addBigEditorButton(e2.currentTarget);
        attachPreview(e2.currentTarget);
      });
    }
  };
  async function initWikiImages(subreddit2) {
    const { data: data2 } = await ajax({
      url: `/r/${subreddit2}/about/stylesheet.json`,
      type: "json"
    });
    if (data2 && data2.images) {
      for (const { name: name2, url } of data2.images) {
        subredditImages.set(name2, url);
      }
    }
  }
  function markdownToHTML(md) {
    if (isBan && md.length) {
      md = generateBanMessage(md, currentSubreddit() || "");
    }
    if (!isWiki) {
      return markdown(md);
    } else {
      const $doc = (0, import_jquery29.default)("<body>").html(markdownWiki(md));
      for (const img of $doc.find("img")) {
        const src = img.getAttribute("src");
        const imgKey = src && src.startsWith("%%") && src.endsWith("%%") && src.slice("%%".length, -"%%".length);
        const resolvedSrc = imgKey && subredditImages.get(imgKey);
        if (resolvedSrc) {
          img.src = resolvedSrc;
        } else {
          img.remove();
        }
      }
      const headerIds2 = /* @__PURE__ */ new Map();
      const headers = $doc.find("h1, h2, h3, h4, h5, h6");
      const tocDiv = (0, import_jquery29.default)("<div>").addClass("toc");
      let $parent = (0, import_jquery29.default)("<ul>");
      $parent.data("level", 1);
      tocDiv.append($parent);
      let level = 1;
      let previous2 = 1;
      const prefix = "wiki";
      headers.each(function() {
        const contents = (0, import_jquery29.default)(this).text();
        let aid = (0, import_jquery29.default)("<div>").html(contents).text();
        aid = `${prefix}_${aid.replace(/ /g, "_").toLowerCase()}`;
        aid = aid.replace(/[^\w\.\-]/g, (s) => `.${s.charCodeAt(0).toString(16).toUpperCase()}`);
        const idNum = (headerIds2.get(aid) || 0) + 1;
        headerIds2.set(aid, idNum);
        if (idNum > 1) {
          aid += idNum;
        }
        (0, import_jquery29.default)(this).attr("id", aid);
        const li = (0, import_jquery29.default)("<li>").addClass(aid);
        const a2 = (0, import_jquery29.default)("<a>").attr("href", `#${aid}`).text(contents);
        li.append(a2);
        const thisLevel = +this.tagName.slice(-1);
        if (thisLevel > previous2) {
          const $newUL = (0, import_jquery29.default)("<ul>");
          $newUL.data("level", thisLevel);
          $parent.append($newUL);
          $parent = $newUL;
          level++;
        } else if (thisLevel < previous2) {
          while (level > 1 && $parent.data("level") > thisLevel) {
            $parent = $parent.parent();
            level--;
          }
        }
        previous2 = thisLevel;
        $parent.append(li);
      });
      $doc.prepend(tocDiv);
      return $doc.html();
    }
  }
  var addBigEditorButton = (ele) => {
    if (!module41.options.enableBigEditor.value) return;
    const container2 = ele.closest("#editform, .usertext-edit, #banned");
    if (!container2) return;
    const bigEditorButton = container2.querySelector(".RESBigEditorPop") || string_exports.html`
		<button type="button" class="RESBigEditorPop" tabIndex="3">
			<span class="res-icon res-icon-12">&#xF0A4;</span> big editor
		</button>
	`;
    if (isBan || isWiki) {
      ele.after(bigEditorButton);
    } else {
      const bottom = container2.querySelector(".bottom-area");
      bottom.prepend(bigEditorButton);
    }
    bigEditorButton.addEventListener("click", showBigEditor);
  };
  var attachPreview = (textarea) => {
    if (!module41.options.enableForComments.value && textarea.closest(".commentarea, .message") || !module41.options.enableForPosts.value && (isPageType("submit") || textarea.closest(".link")) || !module41.options.enableForSubredditConfig.value && /^\/r\/[\-\w.]+\/about\/edit/i.test(location.pathname) || !module41.options.enableForBanMessages.value && isBan) {
      return;
    }
    const container2 = textarea.closest(".usertext-edit, #banned");
    if (!container2) return;
    const preview = container2.querySelector(".livePreview") || makePreviewBox();
    const elements = [preview.querySelector(".RESDialogContents")];
    if (module41.options.sidebarPreview.value && textarea.getAttribute("name") === "description") {
      elements.push(document.querySelector(".side .usertext-body .md"));
    }
    (0, import_jquery29.default)(textarea).on("input", debounce_default(() => onTextareaInput(textarea, preview, elements), 100));
    onTextareaInput(textarea, preview, elements);
    (0, import_jquery29.default)(textarea.closest("form")).on("submit", () => {
      preview.remove();
    });
    container2.append(preview);
  };
  function attachWikiPreview() {
    if (!module41.options.enableForWiki.value) return;
    const preview = makePreviewBox();
    preview.querySelector(".md").classList.add("wiki");
    document.querySelector("#editform > br").after(preview);
    const contents = preview.querySelector(".RESDialogContents");
    (0, import_jquery29.default)("#wiki_page_content").on("input focus", debounce_default((e2) => onTextareaInput(e2.currentTarget, preview, [contents]), 100));
  }
  function onTextareaInput(textarea, preview, elements) {
    const markdownText = downcast(textarea, HTMLTextAreaElement).value;
    if (markdownText.length) {
      if (preview) preview.hidden = false;
      for (const ele of elements) ele.innerHTML = markdownToHTML(markdownText);
    } else {
      if (preview) preview.hidden = true;
      for (const ele of elements) empty(ele);
    }
  }
  function makePreviewBox() {
    return string_exports.html`
		<div class="RESDialogSmall livePreview">
			<h3>Live Preview</h3>
			${string_exports.safe(makeUrlHashLink(module41.moduleID, void 0, " ", "gearIcon"))}
			<div class="md RESDialogContents"></div>
		</div>
	`;
  }
  var createBigEditor = once_default(() => {
    const $editor = (0, import_jquery29.default)('<div id="BigEditor">');
    const $left = (0, import_jquery29.default)('<div class="BELeft RESDialogSmall"><h3>Editor</h3></div>');
    const $contents = (0, import_jquery29.default)('<div class="RESDialogContents"><textarea id="BigText" name="text" class=""></textarea></div>');
    const $textarea = $contents.find("textarea");
    const $foot = (0, import_jquery29.default)('<div class="BEFoot">');
    if (!isBan) {
      $foot.append((0, import_jquery29.default)('<button type="button">save</button>').on("click", () => {
        const len = $textarea.val().length;
        const max = $textarea.data("max-length");
        if (len > max) {
          (0, import_jquery29.default)("#BigEditor .errorList .error").hide().filter(".TOO_LONG").text(`this is too long (max: ${max})`).show();
        } else if (len === 0) {
          (0, import_jquery29.default)("#BigEditor .errorList .error").hide().filter(".NO_TEXT").show();
        } else {
          hideBigEditor(true);
        }
      }));
    }
    $foot.append((0, import_jquery29.default)('<button type="button">close</button>').on("click", () => hideBigEditor()));
    $foot.append((0, import_jquery29.default)(`
		<span class="errorList">
			<span style="display: none;" class="error NO_TEXT">we need something here</span>
			<span style="display: none;" class="error TOO_LONG">this is too long (max: 10000)</span>
		</span>
	`));
    $contents.append($foot);
    $left.append($contents);
    const $right = (0, import_jquery29.default)(`
		<div class="BERight RESDialogSmall"><h3>Preview</h3><div class="RESCloseButton RESCloseButtonTopRight"></div>
		<div class="RESDialogContents"><div id="BigPreview" class=" md"></div></div></div>
	`);
    $editor.append($left).append($right);
    $right.find(".RESCloseButton").on("click", () => hideBigEditor());
    const $preview = $right.find("#BigPreview");
    $textarea.on("input", debounce_default(() => onTextareaInput($textarea.get(0), null, [$preview.get(0)]), 100));
    $editor.on("keydown", (e2) => {
      if (e2.key === NAMED_KEYS.Escape) {
        hideBigEditor();
        e2.preventDefault();
        return false;
      }
    });
    return $editor;
  });
  var $bigTextTarget;
  function showBigEditor(e2) {
    e2.preventDefault();
    const $editor = createBigEditor();
    (0, import_jquery29.default)(document.body).append($editor).addClass("RESScrollLock");
    const $textarea = $editor.find("textarea");
    let $baseText;
    if (!isWiki && !isBan) {
      $baseText = (0, import_jquery29.default)(e2.currentTarget).parents(".usertext-edit:first").find("textarea");
      const limit = $baseText.attr("data-limit");
      $textarea.attr("data-limit", limit);
      (0, import_jquery29.default)("#BigPreview").removeClass("wiki");
      (0, import_jquery29.default)(".BERight .RESDialogContents").removeClass("wiki-page-content");
    } else if (isBan) {
      $baseText = (0, import_jquery29.default)("#ban_message");
      const limit = $baseText.attr("data-limit");
      $textarea.attr("data-limit", limit);
      (0, import_jquery29.default)("#BigPreview").removeClass("wiki");
      (0, import_jquery29.default)(".BERight .RESDialogContents").removeClass("wiki-page-content");
    } else {
      $baseText = (0, import_jquery29.default)("#wiki_page_content");
      (0, import_jquery29.default)("#BigPreview").addClass("wiki");
      (0, import_jquery29.default)(".BERight .RESDialogContents").addClass("wiki-page-content");
    }
    const markdown2 = $baseText.val();
    const maxLength = $baseText.data("max-length");
    $textarea.data("max-length", maxLength).val(markdown2).focus();
    $bigTextTarget = $baseText;
    $textarea.get(0).dispatchEvent(new Event("input", { bubbles: true, cancelable: true }));
  }
  function hideBigEditor(save3 = false) {
    if (!$bigTextTarget) throw new Error();
    const $editor = createBigEditor();
    const $textarea = $editor.find("textarea");
    $bigTextTarget.val($textarea.val());
    $bigTextTarget.get(0).dispatchEvent(new Event("input", { bubbles: true, cancelable: true }));
    if (save3) {
      $bigTextTarget.closest("form").find("input[type=submit], button[type=submit]").click();
    } else {
      $bigTextTarget.focus();
    }
    $editor.get(0).remove();
    (0, import_jquery29.default)(document.body).removeClass("RESScrollLock");
    $bigTextTarget = null;
  }
  function generateBanMessage(message, subreddit2) {
    return [
      `you have been banned from posting to [/r/${subreddit2}](/r/${subreddit2}).`,
      "",
      "note from the moderators:",
      "",
      message.replace(/^/gm, "> "),
      "",
      "you can contact the moderators regarding your ban by replying to this message. **warning**: using other accounts to circumvent a subreddit ban is considered a violation of reddit's [site rules](/rules) and can result in being banned from reddit entirely."
    ].join("\r\n");
  }

  // lib/modules/commentQuickCollapse.js
  var import_jquery30 = __toESM(require_jquery(), 1);
  var module42 = new Module("commentQuickCollapse");
  module42.moduleName = "commentQuickCollapseName";
  module42.category = "commentsCategory";
  module42.description = "commentQuickCollapseDesc";
  module42.options = {
    hideCommentsOnHeaderDoubleClick: {
      type: "boolean",
      value: true,
      description: "hideCommentsOnHeaderDoubleClickDesc",
      title: "hideCommentsOnHeaderDoubleClickTitle"
    },
    toggleCommentsOnClickLeftEdge: {
      type: "boolean",
      value: false,
      bodyClass: true,
      description: "toggleCommentsOnClickLeftEdgeDesc",
      title: "toggleCommentsOnClickLeftEdgeTitle"
    },
    leftEdgeColor: {
      dependsOn: (options6) => options6.toggleCommentsOnClickLeftEdge.value,
      type: "color",
      value: "#d1d1d1",
      description: "toggleCommentsLeftEdgeColorDesc",
      title: "toggleCommentsLeftEdgeColorTitle"
    },
    leftEdgeHoverColor: {
      dependsOn: (options6) => options6.toggleCommentsOnClickLeftEdge.value,
      type: "color",
      value: "#b1b1b1",
      description: "toggleCommentsLeftEdgeHoverColorDesc",
      title: "toggleCommentsLeftEdgeHoverColorTitle"
    },
    leftEdgeCollapsedColor: {
      dependsOn: (options6) => options6.toggleCommentsOnClickLeftEdge.value,
      type: "color",
      value: "#b1b1b1",
      description: "toggleCommentsLeftEdgeCollapsedColorDesc",
      title: "toggleCommentsLeftEdgeCollapsedColorTitle"
    },
    leftEdgeWidth: {
      dependsOn: (options6) => options6.toggleCommentsOnClickLeftEdge.value,
      type: "text",
      value: "50",
      description: "toggleCommentsLeftEdgeWidthDesc",
      title: "toggleCommentsLeftEdgeWidthTitle"
    },
    hideCollapseButton: {
      dependsOn: (options6) => options6.toggleCommentsOnClickLeftEdge.value,
      type: "boolean",
      value: false,
      bodyClass: true,
      description: "toggleCommentsLeftEdgeHideButtonDesc",
      title: "toggleCommentsLeftEdgeHideButtonTitle"
    },
    scrollOnCollapse: {
      type: "boolean",
      value: false,
      description: "scrollOnCollapseDesc",
      title: "scrollOnCollapseTitle"
    }
  };
  module42.include = [
    "comments"
  ];
  module42.beforeLoad = () => {
    if (module42.options.toggleCommentsOnClickLeftEdge.value) {
      toggleCommentsOnClickLeftEdge();
    }
  };
  module42.contentStart = () => {
    if (module42.options.hideCommentsOnHeaderDoubleClick.value) {
      hideCommentsOnHeaderDoubleClick();
    }
    if (module42.options.scrollOnCollapse.value) {
      scrollOnCollapse();
    }
  };
  function hideCommentsOnHeaderDoubleClick() {
    (0, import_jquery30.default)(document.body).on("dblclick", ".tagline", (e2) => {
      const thing = Thing.checkedFrom(e2.currentTarget);
      thing.setCommentCollapse(!thing.isCollapsed(), "commentQuickCollapse");
      if (window.getSelection()) {
        window.getSelection().removeAllRanges();
      }
    });
  }
  function toggleCommentsOnClickLeftEdge() {
    const leftEdgeWidth = clamp_default(parseInt(module42.options.leftEdgeWidth.value, 10), 0, parseInt(module42.options.leftEdgeWidth.default, 10)) / 100;
    addCSS(`
		.commentarea .comment {
			padding-left: ${2.5 * leftEdgeWidth}em !important;
		}

		.commentarea .comment > .entry > .tagline > .expand:hover {
			background-color: ${module42.options.leftEdgeHoverColor.value};
		}

		.commentarea .entry > .tagline > .expand {
			width: ${2 * leftEdgeWidth}em !important;
			background-color: ${module42.options.leftEdgeColor.value};
		}

		.commentarea .collapsed > .entry > .tagline > .expand {
			background-color: ${module42.options.leftEdgeCollapsedColor.value};
		}
	`);
  }
  function scrollOnCollapse() {
    (0, import_jquery30.default)(document.body).on("click", ".expand", (event) => {
      if (click.isProgrammaticEvent(event)) return;
      const thing = Thing.checkedFrom(event.target);
      if (thing.element.classList.contains("noncollapsed")) return;
      const target = thing.getClosest(Thing.prototype.getNextSibling, { direction: "down" });
      if (!target) return;
      selectedThing_exports.set(target, { scrollStyle: "adopt", from: thing.entry });
    });
  }

  // lib/modules/commentSortBy.js
  var module43 = new Module("commentSortBy");
  module43.moduleName = "commentSortByTitle";
  module43.category = "commentsCategory";
  module43.description = "commentSortByDesc";
  module43.include = ["d2x"];
  module43.beforeLoad = () => {
    watchForRedditEvents("postModTools", (element, { _: { update: update3 } }) => {
      if (update3) return;
      const _base = document.querySelector("#CommentSort--SortPicker");
      const base = _base && _base.parentElement;
      if (!base || base.querySelector(".sortByPrefLink")) return;
      base.append(string_exports.html`
			<a
				class="sortByPrefLink gearIcon"
				style="opacity: 0.3;"
				title="Go to comment sort preferences"
				href="https://old.reddit.com/prefs/#default_comment_sort"
				target="_blank"
			>${"\xA0"}</a>
		`);
    });
  };

  // lib/modules/commentStyle.js
  var module44 = new Module("commentStyle");
  module44.moduleName = "commentStyleName";
  module44.category = "appearanceCategory";
  module44.description = "commentStyleDesc";
  module44.options = {
    commentBoxes: {
      type: "boolean",
      value: true,
      description: "commentStyleCommentBoxesDesc",
      title: "commentStyleCommentBoxesTitle",
      bodyClass: "res-commentBoxes"
    },
    commentRounded: {
      type: "boolean",
      value: true,
      description: "commentStyleCommentRoundedDesc",
      title: "commentStyleCommentRoundedTitle",
      advanced: true,
      dependsOn: (options6) => options6.commentBoxes.value,
      bodyClass: "res-commentBoxes-rounded"
    },
    commentHoverBorder: {
      type: "boolean",
      value: false,
      description: "commentStyleCommentHoverBorderDesc",
      title: "commentStyleCommentHoverBorderTitle",
      advanced: true,
      dependsOn: (options6) => options6.commentBoxes.value,
      bodyClass: "res-commentHoverBorder"
    },
    commentIndent: {
      type: "text",
      value: "10",
      description: "commentStyleCommentIndentDesc",
      title: "commentStyleCommentIndentTitle",
      advanced: true,
      dependsOn: (options6) => options6.commentBoxes.value
    },
    continuity: {
      type: "boolean",
      value: false,
      description: "commentStyleContinuityDesc",
      title: "commentStyleContinuityTitle",
      advanced: true,
      dependsOn: (options6) => options6.commentBoxes.value,
      bodyClass: "res-continuity"
    }
  };
  module44.include = [
    "comments",
    "commentsLinklist"
  ];
  module44.exclude = [
    "d2x"
  ];
  module44.beforeLoad = () => {
    if (module44.options.commentBoxes.value && module44.options.commentIndent.value) {
      addCSS(`
			.res-commentBoxes .comment {
				margin-left: ${module44.options.commentIndent.value}px !important;
			}
		`);
    }
  };

  // lib/modules/context.js
  var import_jquery31 = __toESM(require_jquery(), 1);
  var module45 = new Module("context");
  module45.moduleName = "contextName";
  module45.category = "commentsCategory";
  module45.description = "contextDesc";
  module45.options = {
    viewFullContext: {
      type: "boolean",
      value: true,
      description: "contextViewFullContextDesc",
      title: "contextViewFullContextTitle"
    },
    defaultContext: {
      type: "text",
      value: "3",
      description: "contextDefaultContextDesc",
      title: "contextDefaultContextTitle"
    }
  };
  module45.include = [
    "comments",
    "commentsLinklist",
    "inbox",
    "profile",
    "modqueue"
  ];
  module45.beforeLoad = () => {
    const [, , , id2] = regexes.commentPermalink.exec(location.pathname) || [];
    if (module45.options.viewFullContext.value && id2) {
      watchForThings(["comment"], once_default((thing) => {
        if (thing.getButtons().querySelectorAll(".bylink").length < 2) return;
        const pInfobar = document.querySelector(".infobar:not(#searchexpando) p");
        if (pInfobar) pInfobar.append("\xA0", string_exports.html`<a href="?context=10000">view the full context</a>`, "\xA0\u2192");
      }));
    }
  };
  module45.contentStart = () => {
    const defaultContextDepth = parseInt(module45.options.defaultContext.value, 10);
    if (isPageType("commentsLinklist", "inbox", "profile", "modqueue") && defaultContextDepth >= 0) {
      (0, import_jquery31.default)(document.body).on("mousedown", "a.bylink", (e2) => {
        const target = e2.currentTarget;
        target.href = target.href.replace(/(\?|&|;)context=\d+\b/, `$1context=${defaultContextDepth}`);
      });
    }
  };

  // lib/modules/contribute.js
  var module46 = new Module("contribute");
  module46.moduleName = "contributeName";
  module46.category = "aboutCategory";
  module46.sort = -9;
  module46.alwaysEnabled = true;
  module46.description = "contributeDesc";
  module46.contentStart = () => {
    addMenuItem(
      () => string_exports.html`<span>${i18n("donateToRES")} &#8679;</span>`,
      () => {
        openNewTab("https://redditenhancementsuite.com/contribute/");
      }
    );
  };

  // lib/modules/dashboard.js
  var dashboard_exports = {};
  __export(dashboard_exports, {
    createSubredditToggleButton: () => createSubredditToggleButton,
    module: () => module47,
    widgets: () => widgets
  });
  var import_jquery32 = __toESM(require_jquery(), 1);
  var module47 = new Module("dashboard");
  module47.moduleName = "dashboardName";
  module47.category = "productivityCategory";
  module47.description = "dashboardDesc";
  module47.options = {
    menuItem: {
      type: "boolean",
      value: true,
      description: "dashboardMenuItemDesc",
      title: "dashboardMenuItemTitle"
    },
    defaultPosts: {
      type: "text",
      value: "3",
      description: "dashboardDefaultPostsDesc",
      title: "dashboardDefaultPostsTitle",
      advanced: true
    },
    defaultSort: {
      type: "enum",
      values: [{
        name: "hot",
        value: "hot"
      }, {
        name: "new",
        value: "new"
      }, {
        name: "rising",
        value: "rising"
      }, {
        name: "controversial",
        value: "controversial"
      }, {
        name: "top",
        value: "top"
      }],
      value: "hot",
      description: "dashboardDefaultSortDesc",
      title: "dashboardDefaultSortTitle"
    },
    defaultSortSearch: {
      type: "enum",
      values: [{
        name: "relevance",
        value: "relevance"
      }, {
        name: "top",
        value: "top"
      }, {
        name: "new",
        value: "new"
      }, {
        name: "comments",
        value: "comments"
      }],
      value: "relevance",
      description: "dashboardDefaultSortSearchDesc",
      title: "dashboardDefaultSortSearchTitle"
    },
    dashboardShortcut: {
      type: "boolean",
      value: true,
      description: "dashboardDashboardShortcutDesc",
      title: "dashboardDashboardShortcutTitle"
    }
  };
  var initialWidgetLoad = once_default(getLatestWidgets);
  module47.beforeLoad = () => {
    if (module47.options.menuItem.value) {
      const dashboardUrl = isAppType("d2x") ? "https://old.reddit.com/r/Dashboard" : "/r/Dashboard";
      addMenuItem(
        () => string_exports.html`<a href="${dashboardUrl}">${i18n("myDashboard")}</a>`,
        void 0,
        -7
      );
    }
  };
  module47.contentStart = () => {
    addDashboardTab("dashboardContents", "My dashboard", module47.moduleID, addDashboardFunctionality3);
    if (module47.options.dashboardShortcut.value) {
      createElement_exports.sidebarSubscribeButtonWrappers().forEach((wrapper) => {
        const button = createSubredditToggleButton(wrapper.getAttribute("subreddit"));
        initialWidgetLoad().then(() => button.dispatchEvent(new CustomEvent("refresh")));
        button.classList.add("RESDashboardToggle");
        wrapper.append(button);
      });
    }
  };
  var MAX_ROWS = 100;
  var dashboardStorage = storage_exports.wrap(() => `RESmodules.dashboard.${loggedInUser() || "null"}`, []);
  var widgets = [];
  async function getLatestWidgets() {
    widgets = (await dashboardStorage.get()).filter(Boolean);
  }
  async function addDashboardFunctionality3(tabPage) {
    await initialWidgetLoad();
    attachAddComponent((0, import_jquery32.default)(tabPage));
    attachEditComponent();
    initUpdateQueue();
  }
  function initUpdateQueue() {
    for (const widget of widgets) {
      if (widget) addWidget(widget);
    }
    sortable_core_esm_default.create(document.querySelector("#RESDashboard"), {
      handle: "div.RESDashboardComponentHeader",
      onChange: () => saveOrder()
    });
  }
  var updateQueue = [];
  var updateQueueTimer;
  function addToUpdateQueue(updateFunction) {
    updateQueue.push(updateFunction);
    if (!updateQueueTimer) {
      updateQueueTimer = setInterval(processUpdateQueue, 2e3);
      setTimeout(processUpdateQueue, 100);
    }
  }
  function processUpdateQueue() {
    const thisUpdate = updateQueue.pop();
    thisUpdate();
    if (updateQueue.length < 1) {
      clearInterval(updateQueueTimer);
      updateQueueTimer = void 0;
    }
  }
  function saveOrder() {
    const data2 = (0, import_jquery32.default)("#siteTable li.RESDashboardComponent").toArray().map((e2) => (0, import_jquery32.default)(e2).attr("id"));
    data2.reverse();
    const newOrder = [];
    for (const widget of widgets) {
      const newIndex2 = data2.indexOf(widget.basePath.replace(/(\/|\+)/g, "_"));
      newOrder[newIndex2] = widget;
    }
    widgets = newOrder;
    dashboardStorage.set(widgets);
  }
  var widgetBeingEdited;
  function attachEditComponent() {
    const $dashboardEditComponent = (0, import_jquery32.default)('<div id="RESDashboardEditComponent" class="RESDashboardComponent" />');
    $dashboardEditComponent.html(`
		<div class="editWidget">Edit widget</div>
		<div id="editRedditFormContainer" class="editRedditForm">
			<form id="editRedditForm">
				<input type="text" id="editReddit" placeholder="subreddit / multireddit">
				<input type="text" id="editRedditDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="updateButton" value="save changes">
				<input type="cancel" class="cancelButton" value="cancel">
			</form>
			<form id="editSearchForm">
				<input type="text" id="editSearch" placeholder="search terms">
				<input type="text" id="editSearchDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="updateButton" value="save changes">
				<input type="cancel" class="cancelButton" value="cancel">
			</form>
		</div>
	`);
    $dashboardEditComponent.find("#editRedditForm").get(0).addEventListener("submit", (e2) => {
      e2.preventDefault();
      let thisBasePath = (0, import_jquery32.default)("#editReddit").val();
      if (thisBasePath !== "") {
        thisBasePath = thisBasePath.replace(/,|\s/g, "+");
        widgetBeingEdited.formerBasePath = widgetBeingEdited.basePath;
        widgetBeingEdited.basePath = `/r/${thisBasePath}`;
        widgetBeingEdited.displayName = (0, import_jquery32.default)("#editRedditDisplayName").val();
        widgetBeingEdited.update();
        (0, import_jquery32.default)("#RESDashboardEditComponent").fadeOut(() => (0, import_jquery32.default)("#editReddit").blur());
        widgetBeingEdited.widgetEle.find(".widgetPath").text(widgetBeingEdited.displayName).attr("title", `/r/${thisBasePath}`);
        updateWidget();
      }
    });
    $dashboardEditComponent.find("#editSearchForm").get(0).addEventListener("submit", (e2) => {
      e2.preventDefault();
      const thisBasePath = (0, import_jquery32.default)("#editSearch").val();
      widgetBeingEdited.formerBasePath = widgetBeingEdited.basePath;
      widgetBeingEdited.basePath = string_exports.encode`/search?q=${thisBasePath}`;
      widgetBeingEdited.displayName = (0, import_jquery32.default)("#editSearchDisplayName").val();
      widgetBeingEdited.update();
      (0, import_jquery32.default)("#RESDashboardEditComponent").fadeOut(() => {
        (0, import_jquery32.default)("#editSearch").val("").blur();
        (0, import_jquery32.default)("#editSearchDisplayName").val("").blur();
      });
      widgetBeingEdited.widgetEle.find(".widgetPath").text(widgetBeingEdited.displayName).attr("title", thisBasePath);
      updateWidget();
    });
    $dashboardEditComponent.find(".cancelButton").click(() => {
      if (widgetBeingEdited.basePath.startsWith("/search?q=")) {
        (0, import_jquery32.default)("#RESDashboardEditComponent").fadeOut(() => (0, import_jquery32.default)("#editSearchDisplayName").val("").blur());
      } else {
        (0, import_jquery32.default)("#RESDashboardEditComponent").fadeOut(() => (0, import_jquery32.default)("#editReddit").blur());
      }
    });
    (0, import_jquery32.default)(document.body).append($dashboardEditComponent);
  }
  function showEditForm() {
    const basePath = widgetBeingEdited.basePath;
    const widgetEle = widgetBeingEdited.widgetEle;
    const eleTop = (0, import_jquery32.default)(widgetEle).position().top;
    const eleWidth = (0, import_jquery32.default)(widgetEle).width();
    (0, import_jquery32.default)("#RESDashboardEditComponent").css("top", `${eleTop}px`).css("left", "5px").css("width", `${eleWidth + 2}px`);
    if (basePath.startsWith("/search?q=")) {
      (0, import_jquery32.default)("#editSearchDisplayName").val(widgetBeingEdited.displayName);
      (0, import_jquery32.default)("#editSearch").val(decodeURIComponent(basePath.substr(10)));
      (0, import_jquery32.default)("#editSearchForm").show();
      (0, import_jquery32.default)("#editRedditForm").hide();
      (0, import_jquery32.default)("#RESDashboardEditComponent").fadeIn("fast");
    } else {
      (0, import_jquery32.default)("#editReddit").val(widgetBeingEdited.basePath.substr(3));
      (0, import_jquery32.default)("#editRedditDisplayName").val(widgetBeingEdited.displayName);
      (0, import_jquery32.default)("#editRedditForm").show();
      (0, import_jquery32.default)("#editSearchForm").hide();
      (0, import_jquery32.default)("#RESDashboardEditComponent").fadeIn("fast");
    }
  }
  var $dashboardUL;
  function attachAddComponent($tabPage) {
    const $dashboardAddComponent = (0, import_jquery32.default)('<div id="RESDashboardAddComponent" class="RESDashboardComponent" />');
    $dashboardAddComponent.html(`
		<div class="addNewWidget">Add a new widget</div>
		<div id="addWidgetButtons">
			<div class="addButton" id="addSearchWidget">+search widget</div>
			<div class="addButton" id="addMailWidget">+mail widget</div>
			<div class="addButton" id="addUserWidget">+user widget</div>
			<div class="addButton" id="addRedditWidget">+subreddit widget</div>
		</div>
		<div id="addSearchFormContainer" class="addSearchForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addSearchForm">
				<input type="text" id="addSearch" placeholder="search terms">
				<input type="text" id="addSearchDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
		<div id="addMailWidgetContainer">
			<div class="backToWidgetTypes">&laquo; back</div>
			<div class="addButton widgetShortcut" widgetPath="/message/inbox/">+inbox</div>
			<div class="addButton widgetShortcut" widgetPath="/message/unread/">+unread</div>
			<div class="addButton widgetShortcut" widgetPath="/message/messages/">+messages</div>
			<div class="addButton widgetShortcut" widgetPath="/message/comments/">+comment replies</div>
			<div class="addButton widgetShortcut" widgetPath="/message/selfreply/">+post replies</div>
			<div class="addButton widgetShortcut" widgetPath="/message/moderator/">+modmail</div>
		</div>
		<div id="addUserFormContainer" class="addUserForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addUserForm">
				<input type="text" id="addUser">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
		<div id="addRedditFormContainer" class="addRedditForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addRedditForm">
				<input type="text" id="addReddit" placeholder="subreddit / multireddit">
				<input type="text" id="addRedditDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
	`);
    $dashboardAddComponent.find(".backToWidgetTypes").click(function() {
      (0, import_jquery32.default)(this).parent().fadeOut(() => (0, import_jquery32.default)("#addWidgetButtons").fadeIn());
    });
    $dashboardAddComponent.find(".widgetShortcut").click(function() {
      const thisBasePath = (0, import_jquery32.default)(this).attr("widgetPath");
      addWidget({
        basePath: thisBasePath
      }, true);
      (0, import_jquery32.default)("#addMailWidgetContainer").fadeOut(() => (0, import_jquery32.default)("#addWidgetButtons").fadeIn());
    });
    $dashboardAddComponent.find("#addRedditWidget").click(() => {
      (0, import_jquery32.default)("#addWidgetButtons").fadeOut(() => {
        (0, import_jquery32.default)("#addRedditFormContainer").fadeIn(() => {
          (0, import_jquery32.default)("#token-input-addReddit").focus();
        });
      });
    });
    $dashboardAddComponent.find("#addMailWidget").click(() => {
      (0, import_jquery32.default)("#addWidgetButtons").fadeOut(() => (0, import_jquery32.default)("#addMailWidgetContainer").fadeIn());
    });
    $dashboardAddComponent.find("#addUserWidget").click(() => {
      (0, import_jquery32.default)("#addWidgetButtons").fadeOut(() => (0, import_jquery32.default)("#addUserFormContainer").fadeIn());
    });
    $dashboardAddComponent.find("#addSearchWidget").click(() => {
      (0, import_jquery32.default)("#addWidgetButtons").fadeOut(() => (0, import_jquery32.default)("#addSearchFormContainer").fadeIn());
    });
    $dashboardAddComponent.find("#addRedditForm").get(0).addEventListener("submit", (e2) => {
      e2.preventDefault();
      let thisBasePath = (0, import_jquery32.default)("#addReddit").val();
      if (thisBasePath !== "") {
        thisBasePath = thisBasePath.replace(/,|\s/g, "+");
        const thisDisplayName = (0, import_jquery32.default)("#addRedditDisplayName").val() ? (0, import_jquery32.default)("#addRedditDisplayName").val() : thisBasePath;
        addWidget({
          basePath: thisBasePath,
          displayName: thisDisplayName
        }, true);
        (0, import_jquery32.default)("#addReddit").val("").blur();
        (0, import_jquery32.default)("#addRedditFormContainer").fadeOut(() => {
          (0, import_jquery32.default)("#addWidgetButtons").fadeIn();
        });
      }
    });
    $dashboardAddComponent.find("#addUserForm").get(0).addEventListener("submit", (e2) => {
      e2.preventDefault();
      const thisBasePath = `/user/${(0, import_jquery32.default)("#addUser").val()}`;
      addWidget({
        basePath: thisBasePath
      }, true);
      (0, import_jquery32.default)("#addUser").val("").blur();
      (0, import_jquery32.default)("#addUserFormContainer").fadeOut(() => (0, import_jquery32.default)("#addWidgetButtons").fadeIn());
    });
    $dashboardAddComponent.find("#addSearchForm").get(0).addEventListener("submit", (e2) => {
      e2.preventDefault();
      const thisBasePath = string_exports.encode`/search?q=${(0, import_jquery32.default)("#addSearch").val()}`;
      const thisDisplayName = (0, import_jquery32.default)("#addSearchDisplayName").val() ? (0, import_jquery32.default)("#addSearchDisplayName").val() : thisBasePath;
      addWidget({
        basePath: thisBasePath,
        displayName: thisDisplayName
      }, true);
      (0, import_jquery32.default)("#addSearch").val("").blur();
      (0, import_jquery32.default)("#addSearchFormContainer").fadeOut(() => (0, import_jquery32.default)("#addWidgetButtons").fadeIn());
    });
    $dashboardUL = (0, import_jquery32.default)('<ul id="RESDashboard"></ul>');
    $tabPage.append($dashboardAddComponent, $dashboardUL);
  }
  function addWidget(optionsObject, isNew) {
    if (!optionsObject.basePath.startsWith("/")) {
      optionsObject.basePath = `/r/${optionsObject.basePath}`;
    }
    const exists = widgets.some((widget) => widget.basePath === optionsObject.basePath);
    setTimeout(() => {
      (0, import_jquery32.default)(`.widgetShortcut[widgetPath="${optionsObject.basePath}"]`).hide();
    }, 1e3);
    if (exists && isNew) {
      alert_exports.open(`A widget for ${optionsObject.basePath} already exists!`);
    } else {
      const thisWidget = new WidgetObject(optionsObject);
      if ($dashboardUL) thisWidget.init();
      saveWidget(thisWidget.optionsObject());
    }
  }
  async function removeWidget(optionsObject) {
    await getLatestWidgets();
    let exists;
    widgets = widgets.filter((widget) => {
      if (widget.basePath === optionsObject.basePath) {
        exists = true;
        (0, import_jquery32.default)(document.getElementById(widget.basePath.replace(/\/|\+/g, "_"))).fadeOut("slow", function() {
          (0, import_jquery32.default)(this).detach();
        });
        setTimeout(() => {
          (0, import_jquery32.default)(`.widgetShortcut[widgetPath="${optionsObject.basePath}"]`).show();
        }, 1e3);
        return false;
      }
      return true;
    });
    if (!exists) {
      showNotification({
        moduleID: "dashboard",
        message: "The widget you just tried to remove does not seem to exist."
      });
    }
    dashboardStorage.set(widgets);
  }
  async function saveWidget(optionsObject) {
    await getLatestWidgets();
    let index2 = widgets.findIndex((widget) => widget.basePath === optionsObject.basePath);
    if (index2 === -1) {
      index2 = widgets.length;
    }
    widgets[index2] = optionsObject;
    dashboardStorage.set(widgets);
  }
  async function updateWidget() {
    await getLatestWidgets();
    widgets = widgets.map((widget) => {
      if (widget.basePath === widgetBeingEdited.formerBasePath) {
        delete widgetBeingEdited.formerBasePath;
        widget = widgetBeingEdited.optionsObject();
      }
      return widget;
    });
    dashboardStorage.set(widgets);
  }
  function WidgetObject(widgetOptions) {
    this.basePath = widgetOptions.basePath;
    if (widgetOptions.displayName === void 0 || widgetOptions.displayName === null) {
      widgetOptions.displayName = this.basePath;
    }
    this.displayName = widgetOptions.displayName;
    this.numPosts = widgetOptions.numPosts || parseInt(module47.options.defaultPosts.value, 10);
    this.sortBy = widgetOptions.sortBy || module47.options.defaultSort.value;
    this.sortSearchBy = widgetOptions.sortSearchBy || module47.options.defaultSortSearch.value;
    this.minimized = widgetOptions.minimized || false;
    this.widgetEle = (0, import_jquery32.default)(`
		<li class="RESDashboardComponent" id="${this.basePath.replace(/\/|\+/g, "_")}">
			<div class="RESDashboardComponentScrim">
				<div class="RESDashboardComponentLoader">
					<span class="dashboardLoader"/><span>querying the server. one moment please.</span>
				</div>
			</div>
		</li>
	`);
    this.header = (0, import_jquery32.default)(`<div class="RESDashboardComponentHeader"><a class="widgetPath" title="${this.basePath}" href="${this.basePath}"></a></div>`);
    this.header.find(".widgetPath").text(this.displayName);
    this.sortControls = (0, import_jquery32.default)('<ul class="widgetSortButtons"><li sort="hot">hot</li><li sort="new">new</li><li sort="rising">rising</li><li sort="controversial">controversial</li><li sort="top">top</li></ul>');
    this.sortSearchControls = (0, import_jquery32.default)('<ul class="widgetSortButtons"><li sort="relevance">relevance</li><li sort="top">top</li><li sort="new">new</li><li sort="comments">comments</li></ul>');
    this.optionsObject = () => ({
      basePath: this.basePath,
      displayName: this.displayName,
      numPosts: this.numPosts,
      sortBy: this.sortBy,
      sortSearchBy: this.sortSearchBy,
      minimized: this.minimized
    });
    (0, import_jquery32.default)(this.sortControls).find(`li[sort=${this.sortBy}]`).addClass("active");
    (0, import_jquery32.default)(this.sortControls).find("li").click((e2) => {
      this.sortChange((0, import_jquery32.default)(e2.currentTarget).attr("sort"));
    });
    (0, import_jquery32.default)(this.sortSearchControls).find(`li[sort=${this.sortSearchBy}]`).addClass("active");
    (0, import_jquery32.default)(this.sortSearchControls).find("li").click((e2) => {
      this.sortChange((0, import_jquery32.default)(e2.currentTarget).attr("sort"));
    });
    (0, import_jquery32.default)(this.header).append(this.sortControls);
    if (!this.basePath.startsWith("/r/") && !this.basePath.startsWith("/user/")) {
      setTimeout(() => (0, import_jquery32.default)(this.sortControls).hide(), 100);
    }
    (0, import_jquery32.default)(this.header).append(this.sortSearchControls);
    if (!this.basePath.startsWith("/search?q=")) {
      setTimeout(() => (0, import_jquery32.default)(this.sortSearchControls).hide(), 100);
    }
    this.stateControls = (0, import_jquery32.default)('<ul class="widgetStateButtons"><li class="updateTime"></li><li action="refresh" class="refresh"><span class="res-icon">&#xF0B0;</span></li><li action="refreshAll" class="refreshAll">Refresh All</li><li action="addRow">+row</li><li action="subRow">-row</li><li action="edit" class="editButton"><span class="res-icon">&#xF139;</span></li><li action="minimize" class="minimize">-</li><li action="delete" class="RESClose">&times;</li></ul>');
    (0, import_jquery32.default)(this.stateControls).find("li").click((e2) => {
      switch ((0, import_jquery32.default)(e2.currentTarget).attr("action")) {
        case "refresh":
          this.update();
          break;
        case "refreshAll":
          (0, import_jquery32.default)('li[action="refresh"]').click();
          break;
        case "addRow":
          if (this.numPosts === MAX_ROWS) break;
          this.numPosts++;
          if (this.numPosts === MAX_ROWS) (0, import_jquery32.default)(this.stateControls).find("li[action=addRow]").addClass("disabled");
          (0, import_jquery32.default)(this.stateControls).find("li[action=subRow]").removeClass("disabled");
          saveWidget(this.optionsObject());
          this.update();
          break;
        case "subRow":
          if (this.numPosts === 0) break;
          this.numPosts--;
          if (this.numPosts === 1) (0, import_jquery32.default)(this.stateControls).find("li[action=subRow]").addClass("disabled");
          (0, import_jquery32.default)(this.stateControls).find("li[action=addRow]").removeClass("disabled");
          saveWidget(this.optionsObject());
          this.update();
          break;
        case "minimize":
          (0, import_jquery32.default)(this.widgetEle).toggleClass("minimized");
          if ((0, import_jquery32.default)(this.widgetEle).hasClass("minimized")) {
            (0, import_jquery32.default)(e2.currentTarget).text("+");
            this.minimized = true;
          } else {
            (0, import_jquery32.default)(e2.currentTarget).text("-");
            this.minimized = false;
            this.update();
          }
          (0, import_jquery32.default)(this.contents).parent().slideToggle();
          saveWidget(this.optionsObject());
          break;
        case "delete":
          removeWidget(this.optionsObject());
          break;
        default:
          break;
      }
    });
    (0, import_jquery32.default)(this.header).append(this.stateControls);
    this.sortChange = (sortBy2) => {
      this.sortBy = sortBy2;
      this.sortSearchBy = sortBy2;
      (0, import_jquery32.default)(this.header).find("ul.widgetSortButtons li").removeClass("active");
      (0, import_jquery32.default)(this.header).find(`ul.widgetSortButtons li[sort=${sortBy2}]`).addClass("active");
      this.update();
      saveWidget(this.optionsObject());
    };
    this.edit = () => {
      widgetBeingEdited = this;
      showEditForm();
    };
    (0, import_jquery32.default)(this.header).find(".editButton").click(this.edit);
    this.update = () => {
      if (this.basePath.includes("/user/")) {
        this.sortPath = this.sortBy === "hot" ? "/" : `?sort=${this.sortBy}`;
      } else if (this.basePath.includes("/r/")) {
        this.sortPath = this.sortBy === "hot" ? "/" : `/${this.sortBy}/`;
      } else if (this.basePath.includes("/search?q=")) {
        this.sortPath = `&sort=${this.sortSearchBy}`;
      } else {
        this.sortPath = "";
      }
      this.url = new URL(`${this.basePath}${this.sortPath}`, location.origin).href;
      (0, import_jquery32.default)(this.contents).fadeTo("fast", 0.25);
      (0, import_jquery32.default)(this.scrim).fadeIn();
      ajax({
        method: "GET",
        url: this.url,
        query: {
          limit: this.numPosts
        }
      }).then(this.populate).catch(this.error);
    };
    this.container = (0, import_jquery32.default)('<div class="RESDashboardComponentContainer"><div class="RESDashboardComponentContents"></div></div>');
    if (this.minimized) {
      (0, import_jquery32.default)(this.container).addClass("minimized");
      (0, import_jquery32.default)(this.stateControls).find("li.minimize").addClass("minimized").text("+");
    }
    this.scrim = (0, import_jquery32.default)(this.widgetEle).find(".RESDashboardComponentScrim");
    this.contents = (0, import_jquery32.default)(this.container).find(".RESDashboardComponentContents");
    this.init = () => {
      this.draw();
      if (!this.minimized) addToUpdateQueue(this.update);
    };
    this.draw = () => {
      (0, import_jquery32.default)(this.widgetEle).append(this.header);
      (0, import_jquery32.default)(this.widgetEle).append(this.container);
      if (this.minimized) (0, import_jquery32.default)(this.widgetEle).addClass("minimized");
      $dashboardUL.prepend(this.widgetEle);
    };
    this.populate = (response) => {
      let $widgetContent = (0, import_jquery32.default)(response).find("#siteTable, .search-result-group>.contents:last");
      const $thisWidgetContents = (0, import_jquery32.default)(this.contents);
      $widgetContent.attr("id", `siteTable_${this.basePath.replace(/\/|\+/g, "_")}`);
      if ($widgetContent.length === 2) $widgetContent = (0, import_jquery32.default)($widgetContent[1]);
      $widgetContent.attr("url", `${this.url}?limit=${this.numPosts}`);
      if ($widgetContent.length > 0 && $widgetContent.html() !== "") {
        $widgetContent.html($widgetContent.html().replace(/<script(.|\s)*?\/script>/g, ""));
        const $noResults = $widgetContent.find("#noresults.error");
        if ($noResults.length) {
          $widgetContent.html('<span class="error">No results found for this widget. Some sort methods, such as rising, may not always have results. Please try a different method.</span>');
        }
        try {
          $thisWidgetContents.empty().append($widgetContent);
        } catch (e2) {
        }
        $thisWidgetContents.fadeTo("fast", 1);
        (0, import_jquery32.default)(this.scrim).fadeOut(function() {
          (0, import_jquery32.default)(this).hide();
        });
      } else {
        if (this.url.includes("/message/")) {
          $thisWidgetContents.html('<div class="widgetNoMail">No messages were found.</div>');
        } else {
          $thisWidgetContents.html('<div class="error">There were no results returned for this widget. If you made a typo, simply close the widget to delete it. If reddit is just under heavy load, try clicking refresh in a few moments.</div>');
        }
        $thisWidgetContents.fadeTo("fast", 1);
        (0, import_jquery32.default)(this.scrim).fadeOut();
      }
      (0, import_jquery32.default)(this.stateControls).find(".updateTime").text(`updated: ${formatDateTime()}`);
      if ($widgetContent[0]) {
        registerPage($widgetContent[0]);
      }
    };
    this.error = (e2) => {
      if (e2.status === 404) {
        (0, import_jquery32.default)(this.contents).html('<div class="error">This widget received a 404 not found error. You may have made a typo when adding it.</div>');
      } else {
        (0, import_jquery32.default)(this.contents).html('<div class="error">There was an error loading data for this widget. Reddit may be under heavy load, or you may have provided an invalid path.</div>');
      }
      (0, import_jquery32.default)(this.scrim).fadeOut();
      (0, import_jquery32.default)(this.contents).fadeTo("fast", 1);
    };
  }
  function createSubredditToggleButton(subreddit2) {
    const basePath = `/r/${subreddit2.toLowerCase()}`;
    return createElement_exports.fancyToggleButton(
      i18n("subredditInfoAddRemoveDashboard"),
      i18n("subredditInfoAddThisSubredditToDashboard"),
      () => widgets.some((widget) => widget && widget.basePath.toLowerCase() === basePath),
      (state) => {
        if (state) {
          addWidget({ basePath });
          showNotification({
            header: "Dashboard Notification",
            moduleID: "dashboard",
            message: `
						Dashboard widget added for ${basePath}
						<p><a class="RESNotificationButtonBlue" href="/r/Dashboard">view the dashboard</a></p>
						<div class="clear"></div>
					`
          });
        } else {
          removeWidget({ basePath });
        }
      }
    );
  }

  // lib/modules/disableChat.js
  var module48 = new Module("disableChat");
  module48.moduleName = "disableChatName";
  module48.category = "productivityCategory";
  module48.description = "disableChatDesc";
  module48.disabledByDefault = true;
  module48.contentStart = () => {
    stopPageContextScript((script) => /^\/_chat/.test(new URL(script.src, location.origin).pathname), document.body, true);
    const icon2 = document.body.querySelector("#chat");
    if (icon2) {
      if (icon2.nextElementSibling) icon2.nextElementSibling.remove();
      icon2.remove();
    }
  };

  // lib/modules/localDate.js
  var import_jquery33 = __toESM(require_jquery(), 1);
  var module49 = new Module("localDate");
  module49.moduleName = "localDateName";
  module49.category = "myAccountCategory";
  module49.description = "localDateDesc";
  module49.contentStart = () => {
    (0, import_jquery33.default)(document.body).on("mouseenter", "time", function() {
      const $this = (0, import_jquery33.default)(this);
      if (!$this.data("originalTitle")) {
        $this.data("originalTitle", $this.attr("title"));
      }
      $this.attr("title", new Date($this.attr("datetime")));
    }).on("mouseleave", "time", function() {
      const $this = (0, import_jquery33.default)(this);
      $this.attr("title", $this.data("originalTitle"));
    });
  };

  // lib/modules/logoLink.js
  var import_jquery34 = __toESM(require_jquery(), 1);
  var module50 = new Module("logoLink");
  module50.moduleName = "logoLinkName";
  module50.category = "browsingCategory";
  module50.description = "logoLinkDesc";
  module50.options = {
    redditLogoDestination: {
      type: "enum",
      value: "frontpage",
      description: "logoLinkRedditLogoDestinationDesc",
      title: "logoLinkRedditLogoDestinationTitle",
      values: [{
        name: "logoLinkFrontpage",
        value: "frontpage"
      }, {
        name: "logoLinkAll",
        value: "all"
      }, {
        name: "logoLinkHot",
        value: "hot"
      }, {
        name: "logoLinkDashboard",
        value: "dashboard"
      }, {
        name: "logoLinkCurrent",
        value: "subreddit"
      }, {
        name: "logoLinkMyUserPage",
        value: "/u/me"
      }, {
        name: "logoLinkInbox",
        value: "/message/inbox"
      }, {
        name: "logoLinkCustom",
        value: "custom"
      }]
    },
    customDestination: {
      dependsOn: (options6) => options6.redditLogoDestination.value === "custom",
      type: "text",
      value: "/",
      description: "logoLinkCustomDestinationDesc",
      title: "logoLinkCustomDestinationTitle"
    }
  };
  module50.contentStart = () => {
    const redditLogoNode = document.getElementById("header-img-a") || document.getElementById("header-img") || document.querySelector('header a[href="/"]');
    if (redditLogoNode) {
      const url = getLogoLinkUrl();
      if (url) {
        redditLogoNode.href = url;
      }
    }
  };
  function getLogoLinkUrl() {
    const destination = module50.options.redditLogoDestination.value;
    switch (destination) {
      case "frontpage":
        return false;
      case "all":
        return "/r/all";
      case "hot":
        return "/hot/";
      case "dashboard":
        return "/r/Dashboard";
      case "subreddit":
        return (0, import_jquery34.default)(".redditname > a").attr("href");
      case "custom":
        return module50.options.customDestination.value;
      default:
        return destination;
    }
  }

  // lib/modules/messageMenu.js
  var module51 = new Module("messageMenu");
  module51.moduleName = "messageMenuName";
  module51.category = "browsingCategory";
  module51.description = "messageMenuDesc";
  module51.options = {
    links: {
      type: "table",
      addRowText: "messageMenuAddShortcut",
      fields: [{
        key: "label",
        name: "messageMenuLabel",
        type: "text"
      }, {
        key: "url",
        name: "messageMenuUrl",
        type: "text"
      }],
      value: [
        ["compose", "/message/compose"],
        ["all", "/message/inbox"],
        ["unread", "/message/unread"],
        ["messages", "/message/messages"],
        ["comment replies", "/message/comments"],
        ["post replies", "/message/selfreply"],
        ["/u/ mentions", "/message/mentions"]
      ],
      description: "messageMenuLinksDesc",
      title: "messageMenuLinksTitle"
    },
    useQuickMessage: {
      type: "boolean",
      description: "messageMenuUseQuickMessageDesc",
      title: "messageMenuUseQuickMessageTitle",
      value: true
    },
    hoverDelay: {
      type: "text",
      value: "1000",
      description: "messageMenuHoverDelayDesc",
      title: "messageMenuHoverDelayTitle",
      advanced: true
    },
    fadeDelay: {
      type: "text",
      value: "200",
      description: "messageMenuFadeDelayDesc",
      title: "messageMenuFadeDelayTitle",
      advanced: true
    },
    fadeSpeed: {
      type: "text",
      value: "0.7",
      description: "messageMenuFadeSpeedDesc",
      title: "messageMenuFadeSpeedTitle",
      advanced: true
    }
  };
  module51.contentStart = () => {
    dropdownList(module51.moduleID).options({
      openDelay: parseFloat(module51.options.hoverDelay.value),
      fadeDelay: parseFloat(module51.options.fadeDelay.value),
      fadeSpeed: parseFloat(module51.options.fadeSpeed.value)
    }).populateWith(() => [getListFragment()]).watch("#mail, .mail-count, #NREMail, #NREMailCount");
  };
  function getListFragment() {
    const fragment = document.createDocumentFragment();
    for (const link of module51.options.links.value) {
      const label = link[0] || "";
      const url = link[1] || "";
      const li = string_exports.html`<li><a href="${url}">${label}</a></li>`;
      li.addEventListener("click", (e2) => {
        if (module51.options.useQuickMessage.value && isRunning(quickMessage_exports) && messageLinkEventHandler(e2)) return;
        dropdownList(module51.moduleID).close();
      });
      if (url.includes("/message/compose")) li.append(string_exports.html`<span class="RESMenuItemButton res-icon">&#xF139;</span>`);
      fragment.append(li);
    }
    fragment.append(string_exports.html`<li><a href=${makeUrlHash(module51.moduleID, "sectionMenu")}>
		<i>${i18n(module51.moduleName)}</i>
		<span class="RESMenuItemButton gearIcon"></span>
	</a></li>`);
    return fragment;
  }

  // lib/modules/modhelper.js
  var import_jquery35 = __toESM(require_jquery(), 1);
  var module52 = new Module("modHelper");
  module52.moduleName = "modhelperName";
  module52.category = "coreCategory";
  module52.description = "modhelperDesc";
  module52.hidden = true;
  module52.alwaysEnabled = true;
  module52.include = ["stylesheet"];
  module52.go = () => {
    doStyleSheetCheck();
  };
  var tips2 = {
    "no-res-styles": "It appears you haven't done any styling specific to RES.  If you are interested in a quick overview on styling for RES users, please see [our wiki article](/r/Enhancement/wiki/subredditstyling)",
    keyNav: "Styling `RES-keyNav-activeElement`? This is the element RES uses for Keyboard Navigation - it indicates the currently selected post, and is crucial to RES functionality. If you don't like the way it looks with your theme, you may style it however you want, as long as Keyboard Navigation remains usable for your visitors.",
    "keyNav-benice": `It appears that you are hiding \`RES-keyNav-activeElement\`. This negatively affects RES users by rendering keyboard navigation unusable. It's understandable that you may not care for the default appearance, but we politely request that you consider styling it to fit your subreddit, perhaps using a particular background color or border. Even just a one-sided border, e.g. \`border-right: 3px solid blue;\` - thank you for your consideration.

 For convenience we've included \`RES-keyNav-activeThing\` which can be used as an alternative to \`RES-keyNav-activeElement\`. It applies to elements with the class \`thing\` as opposed to \`entry\`. If you choose to use this, make sure keyboard navigation is usable when [commentBoxes](${makeUrlHash("styleTweaks", "commentBoxes")}) is turned off.`,
    nightmode: "Want your subreddit to be night mode friendly? Please have a look at [the night mode section of our wiki](/r/Enhancement/wiki/subredditstyling#wiki_res_night_mode_and_your_subreddit)"
  };
  function doStyleSheetCheck() {
    const $stylesheetTextarea = (0, import_jquery35.default)(".stylesheet-customize-container textarea");
    const stylesheet = $stylesheetTextarea.length ? (0, import_jquery35.default)($stylesheetTextarea).val() : "";
    createTipPane();
    if (stylesheet.length) {
      if (!stylesheet.includes(".res") && !stylesheet.includes(".RES")) {
        addTipToPane("no-res-styles");
      }
      if (!stylesheet.includes(".res-nightmode")) {
        addTipToPane("nightmode");
      }
      const keyNavIdx = stylesheet.indexOf(".RES-keyNav-activeElement");
      if (keyNavIdx !== -1) {
        let keyNavRule = "";
        let i2 = keyNavIdx;
        while (i2 < stylesheet.length) {
          const thisChar = stylesheet.charAt(i2);
          keyNavRule += thisChar;
          if (thisChar === "}") {
            i2 = stylesheet.length;
          }
          i2++;
        }
        if ((keyNavRule.includes("transparent") || keyNavRule.includes("background: none") || keyNavRule.includes("background-color: none")) && !keyNavRule.includes("border") && !stylesheet.includes(".RES-keyNav-activeThing")) {
          addTipToPane("keyNav-benice");
        } else {
          addTipToPane("keyNav");
        }
      }
    }
  }
  var $tipPane;
  var $tipPaneHeader;
  var $tipPaneContents;
  var $tipPaneList;
  function createTipPane() {
    const $sheetsDiv = (0, import_jquery35.default)("div.sheets");
    $tipPane = (0, import_jquery35.default)("<div>", { id: "RESStyleSheetTipPane" });
    $tipPaneHeader = (0, import_jquery35.default)("<div>", {
      id: "RESStyleSheetTipPane-header",
      class: "minimized",
      text: "RES specific styling tips",
      click: toggleTipPane
    });
    const $tipPaneCloseButton = (0, import_jquery35.default)("<span>", {
      id: "RESStyleSheetTipPane-close",
      class: "RESCloseButton RESCloseButtonTopRight",
      title: "Close for this session",
      click: hideTipPane
    });
    const $tipPaneHeaderSpan = (0, import_jquery35.default)("<span>", { class: "details", text: "[click for details]" });
    $tipPaneHeader.append($tipPaneCloseButton).append($tipPaneHeaderSpan);
    $tipPaneContents = (0, import_jquery35.default)("<div>", { id: "RESStyleSheetTipPane-contents" });
    $tipPaneList = (0, import_jquery35.default)("<ul>", { id: "RESStyleSheetTipPane-list" });
    $tipPaneContents.append($tipPaneList);
    $tipPane.append($tipPaneHeader).append($tipPaneContents);
    $sheetsDiv.before($tipPane);
  }
  function hideTipPane() {
    sessionStorage.setItem("hideTipPane", "true");
    $tipPane.hide();
  }
  function toggleTipPane() {
    if ($tipPaneHeader.hasClass("minimized")) {
      openTipPaneContents();
    } else {
      closeTipPaneContents();
    }
  }
  function openTipPaneContents() {
    $tipPaneHeader.removeClass("minimized");
    $tipPaneContents.slideDown();
  }
  function closeTipPaneContents() {
    $tipPaneHeader.addClass("minimized");
    $tipPaneContents.slideUp();
  }
  function addTipToPane(key) {
    const tipText = tips2[key];
    const $tip = (0, import_jquery35.default)("<li>", { html: markdown(tipText) });
    if (!sessionStorage.getItem("hideTipPane")) {
      $tipPane.show();
    }
    $tipPaneList.append($tip);
  }

  // lib/modules/multiredditNavbar.js
  var module53 = new Module("multiredditNavbar");
  module53.moduleName = "multiredditNavbarName";
  module53.description = "multiredditNavbarDesc";
  module53.category = "subredditsCategory";
  module53.include = [
    // frontpage, multireddits, /r/all (including /r/all-sub1-sub2),
    // and some other special subreddits (/r/mod)
    // fails gracefully (and cheaply) if we're on a linklist page without the multireddit sidebar
    "linklist"
  ];
  module53.options = {
    sectionMenu: {
      type: "boolean",
      value: true,
      description: "multiredditNavbarSectionMenuDesc",
      title: "multiredditNavbarSectionMenuTitle"
    },
    sectionLinks: {
      dependsOn: (options6) => options6.sectionMenu.value,
      type: "table",
      addRowText: "multiredditNavbarAddShortcut",
      fields: [{
        key: "label",
        name: "multiredditNavbarLabel",
        type: "text"
      }, {
        key: "url",
        name: "multiredditNavbarUrl",
        type: "text"
      }],
      value: [
        ["new", "./new"],
        ["rising", "./rising"],
        ["controversial", "./controversial"],
        ["top", "./top"],
        ["top this month", "./top?t=month"],
        ["gilded", "./gilded"],
        ["promoted", "./ads"]
      ],
      description: "multiredditNavbarSectionLinksDesc",
      title: "multiredditNavbarSectionLinksTitle"
    },
    hoverDelay: {
      dependsOn: (options6) => options6.sectionMenu.value,
      type: "text",
      value: "1000",
      description: "multiredditNavbarHoverDelayDesc",
      title: "multiredditNavbarHoverDelayTitle",
      advanced: true
    },
    fadeDelay: {
      dependsOn: (options6) => options6.sectionMenu.value,
      type: "text",
      value: "200",
      description: "multiredditNavbarFadeDelayDesc",
      title: "multiredditNavbarFadeDelayTitle",
      advanced: true
    },
    fadeSpeed: {
      dependsOn: (options6) => options6.sectionMenu.value,
      type: "text",
      value: "0.7",
      description: "multiredditNavbarFadeSpeedDesc",
      title: "multiredditNavbarFadeSpeedTitle",
      advanced: true
    }
  };
  module53.contentStart = () => {
    if (module53.options.sectionMenu.value) {
      dropdownList(module53.moduleID).options({
        openDelay: penalizedDelay(module53.moduleID, "sectionMenu", module53.options.hoverDelay),
        fadeDelay: parseFloat(module53.options.fadeDelay.value),
        fadeSpeed: parseFloat(module53.options.fadeSpeed.value),
        pin: pin.right,
        offsetWidth: -10,
        offsetHeight: 1,
        bottomPadding: 0
      }).populateWith((card) => [getListFragment2(card.getCheckedTarget().href)]).watch(".listing-chooser .multis li a");
    }
  };
  var getListFragment2 = (baseUrl) => {
    alterFeaturePenalty(module53.moduleID, "sectionMenu", 5);
    const fragment = document.createDocumentFragment();
    for (const link of module53.options.sectionLinks.value) {
      const label = link[0] || "";
      const url = link[1] || "";
      const li = string_exports.html`<li><a href="${baseUrl}${url}">${label}</a></li>`;
      li.addEventListener("click", () => {
        dropdownList(module53.moduleID).close();
        alterFeaturePenalty(module53.moduleID, "sectionMenu", -30);
      });
      fragment.append(li);
    }
    fragment.append(string_exports.html`<li><a href=${makeUrlHash(module53.moduleID, "sectionMenu")}>
		<i>${i18n(module53.moduleName)}</i>
		<span class="RESMenuItemButton gearIcon"></span>
	</a></li>`);
    return fragment;
  };

  // lib/modules/neverEndingComments.js
  var module54 = new Module("neverEndingComments");
  module54.moduleName = "necName";
  module54.category = "commentsCategory";
  module54.description = "necDescription";
  module54.options = {
    loadChildComments: {
      type: "boolean",
      value: false,
      description: "necLoadChildCommentsDesc",
      title: "necLoadChildCommentsTitle"
    }
  };
  module54.include = [
    "comments"
  ];
  module54.afterLoad = () => {
    const context = document.body.querySelector(module54.options.loadChildComments.value ? ".nestedlisting" : ".nestedlisting > .thing.morechildren");
    if (!context) return;
    const visibleLoaders = /* @__PURE__ */ new Set();
    const io = new IntersectionObserver((entries) => {
      for (const { isIntersecting, target } of entries) {
        if (!context.contains(target)) io.unobserve(target);
        if (isIntersecting) visibleLoaders.add(target);
        else visibleLoaders.delete(target);
      }
      if (visibleLoaders.size) {
        window.addEventListener("scroll", loadFirst);
        loadFirst();
      } else {
        window.removeEventListener("scroll", loadFirst);
      }
    }, { rootMargin: "-10% 0px 10% 0px" });
    const loadFirst = frameDebounce(mutex(async () => {
      const loader = Array.from(visibleLoaders.values()).sort((a2, b2) => 3 - (a2.compareDocumentPosition(b2) & 6)).find((e2) => {
        const thing = Thing.from(e2);
        return !selectedThing_exports.current || !thing || selectedThing_exports.current.getDirectionOf(thing) === "down";
      });
      if (loader) {
        loader.click();
        await waitForDetach(
          loader,
          // The load may fail
          new Promise((res) => {
            setTimeout(res, 3e3);
          })
        );
        loadFirst();
      }
    }), 5);
    watchForDescendants(context, ".morecomments a", (ele) => {
      io.observe(ele);
    });
  };

  // lib/modules/onboarding.js
  var import_gt = __toESM(require_gt(), 1);
  var import_diff = __toESM(require_diff(), 1);
  var module55 = new Module("onboarding");
  module55.moduleName = "onboardingName";
  module55.category = "aboutCategory";
  module55.description = "onboardingDesc";
  module55.alwaysEnabled = true;
  module55.options = {
    updateNotification: {
      title: "onboardingUpdateNotificationName",
      description: "onboardingUpdateNotificationDescription",
      type: "enum",
      value: "notification",
      values: [{
        name: "onboardingUpdateNotifictionReleaseNotes",
        value: "releaseNotes"
      }, {
        name: "onboardingUpdateNotifictionNotification",
        value: "notification"
      }, {
        name: "onboardingUpdateNotifictionNothing",
        value: "nothing"
      }]
    },
    patchUpdateNotification: {
      title: "onboardingPatchUpdateNotificationName",
      description: "onboardingPatchUpdateNotificationDescription",
      type: "enum",
      value: "notification",
      values: [{
        name: "onboardingUpdateNotifictionReleaseNotes",
        value: "releaseNotes"
      }, {
        name: "onboardingUpdateNotifictionNotification",
        value: "notification"
      }, {
        name: "onboardingUpdateNotifictionNothing",
        value: "none"
      }]
    },
    betaUpdateNotification: {
      title: "onboardingBetaUpdateNotificationName",
      description: "onboardingBetaUpdateNotificationDescription",
      type: "enum",
      value: "releaseNotes",
      values: [{
        name: "onboardingUpdateNotifictionReleaseNotes",
        value: "releaseNotes"
      }, {
        name: "onboardingUpdateNotifictionNotification",
        value: "notification"
      }, {
        name: "onboardingUpdateNotifictionNothing",
        value: "none"
      }]
    }
  };
  var highestVersionStorage = storage_exports.wrap("highestVersion", null);
  module55.go = async () => {
    const highestVersion = await highestVersionStorage.get();
    if (!highestVersion) {
      highestVersionStorage.set(version3);
      return;
    }
    if (highestVersion === version3 || (0, import_gt.default)(highestVersion, version3)) return;
    const diff = (0, import_diff.default)(version3, highestVersion);
    const infoTypes = filterMap([
      isBeta && "betaUpdateNotification",
      diff === "patch" && "patchUpdateNotification",
      (diff === "major" || diff === "minor") && "updateNotification"
    ], (notificationOption) => notificationOption ? [module55.options[notificationOption].value] : void 0);
    if (infoTypes.includes("releaseNotes")) {
      openNewTab(updatedURL, false);
    } else if (infoTypes.includes("notification")) {
      showNotification({
        moduleID: module55.moduleID,
        notificationID: diff,
        message: `
				${i18n("onboardingUpgradeMessage", version3)}
				<p><a class="RESNotificationButtonBlue" href="${updatedURL}" target="_blank">
					${i18n("onboardingUpgradeCta")}
				</a></p>
			`.trim(),
        closeDelay: 15e3
      });
    } else {
      console.log(`RES upgraded to v${version3}.`);
    }
    highestVersionStorage.set(version3);
  };

  // lib/modules/orangered.js
  var import_jquery36 = __toESM(require_jquery(), 1);
  var import_favico = __toESM(require_favico(), 1);

  // lib/images/legacyFavicon.png
  var legacyFavicon_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAHQElEQVRYR8WXe1BU9xXHP5dld+WxLoKKSEAeGgxqFIVRjAn4BBIVUkzBOoUqDJmojYIZtT7qI2k6VVGZBGOtWlNMpz5wTBFfqIAtAg6klVGCCvHFQ1ieA8qyC3s7966A6JpabZLz1+7vnnvO957f95zf9yfwE5sg5a8RRbGp5cdHMkALMoDSZlFsbmh/cQSCFQprBV2dXSCa+sRRqtTY2gkIVgKGDpGHbfqe5w5ONmYA1xpNYktT74P/FYmVQoG+/SEOjlpUaoHOTpGOdhGlSkB3v5b0r/bSWK9j5uxIJr71Jm0t5lzaAf1eHoC9th/nT2SwOSmOQUNewW/iZPwmvcVY/0mIJpFFEcGorTpxdnbmctE3rN+6h/cWxssg/i8ApDIujoqgtvoewaEh5F3I5m5FGQaDASuFEt+RI8i7lI9CoSB521Z+s24D567UYGNnj7294uU4oFAqMXboCRnnwqpPU4n7MIbGRmiqb6b63g2S4n7B7FnB/HHPXrnkN2/c4FUfH47nlePm6Y2N7SMSvigHbO37UXAxh8VRM8kovMXgIa4YDR1IwAY5K9i9bRc7fvtrzmfn4OHhSUL8Ir6tqCT94hU6jaDpr3w5DgwY2I/NScsoupTLkZx/92G4REylUsHmjxLIOPSl/NtpsCufHczAy8eX9gcvyAEpsEJhLTNcYnzIuOHMjVpI0qa16O4bMHV19TSRVAm1WsH1q9dobW1m5Khx2GnseNCmx0p4rAv+2xzo7mUpcltbF80NOpoadXx3/VvWLI5m484/Exg0HTv7AWgd7bESRPR6gY5282xR29igUIh0dQkYDb0g+8wBKbDEym4zGkEUQaWCu7cqyT17gpyzGdwsLaGtpRHELqwEAZVKjbGzE4OxExs7DV4+owgMmsm0sAhGjhmFSZpNIggCNDe2YG1tzQAnO/lDerqgQi+KNffaOHRgFwW5WTg4DuS92PcZNNiZ1C0byTl9HEetPUFBwQQFB+PrO4phHh5oNBoEQeBBWxu6+nquXb3KxdwccnKyuXWnkjH+gSxb+ykarQPJG1dSUpyPtbWSaW+/y4oNWxnqrjWTsKSuXYwMmkhT7V3CIyKoq60lI/OUXIzAiQGsWr2G0LAwVFI5ntMK8vPZsT2Zo8eOI4omZs2YRmLSCmru32fD+nVoBrnxdV6BGUDc8g3imcO7uVp6Ha1WS3R0NFlZWaSmfk509PznTGnZLf/SJRISElBYW5ObmyvH1+l0uLo4k/zlaTOA4b5+4pK4BSxLTCIyMpIL589TVFyMt7d3b9QbpXDkEEzwh9A5lrPdqYBj6eDnB8Eze3zaHz4kJDSUiooKysrK5K2bGDCeCdMjzQD8Jk0VZ08PZPKUNwkLC6OkpITRo0f3JqmrgdfHINQ1ymviuVMwLaQviEYdjB+HcLfG7HPhTB8QRqMRNzc3wsPD2bF9O06ODvxh3wkzgJS0THHlorkyi+Pj49myZUvf4MUFCAGTe9bE32+CVev7+vzrMsKESb0+H6+HtZv6+Jw5c4Y5c+bg5TEMoZ+WjPwiM4AqURRXxC/nb/tS5DJ5eXn1DW7Qwy/nw+Hj4DsCTp0Gdws+P4+Er0+CpxuczYLhPk9tlcuQwTgM8WTP4ZO4DnMyA7hnMomZ6TmsiouguroaG1tby3ss8cBtGNjYPZuYV4rBwxO0jhZ9Aib4yXu/8uN1dLQ/Ooxud5rEk+kXSIx5m8rKKpycnF6K+d/38shXRxAcEcuyNetkN7kCNx+YxNsVOmaNdeHokUO8+7PIHwTA3Tt38PD05E/H/kHAG2+gVD6mCaWMy3+1gNtXC7l+s9wigJ07dzJlyhT8/f0tPm9paSE1NZUlS5bI/f6kLZgfRU5+MScKrmPo6KK/g6r3ONa3m2TdFjLenQ/ej+ezz1OfChAbG0taWhpRUVHMmDEDby8vlCoVdXV1FBYWcuDAATlxUVGR3OuP28GDacTExLInPZtJQUGWJZmk0fKyc0mInEp83CJ2fbFbPjwet8zMTPbv3y/PitbWVkwmkzyi3d3dmTdvHkuXLn1qZKekpJCYmEjShmTiE5PoVuAWNaG0ePmfeXwYE4Gzo4ZtyTuYGx5useR6vV4+/6WukQ6lJ624uJhVKz/iQnYuG3fsI2rRQpoaDD3SvQfAk3pA42BDQ10DKZ+s5vhf9zPC25OY2BjeeWcOr/n6olarLQKSqlFRXs658+f4Ku0v5OUXEjBlBqt/t5PXxo7q+fLul7/3XiCJEDuNFTdLb3A0bS9Zfz9MfW0Vjg79cXUdiovLUJwGDpQ1gUS+qqpKKquq0dU3YqtxYPLUUKIXfsD4wEC6OpEl2JP2XLJcUjOSen3QauJWeSllJd/wXXkZ1ffu0NLUIMe0te/PK+4euHkMx2f0WEaMfF3W/JKoefwm9EIAul+SRaZKhUoNikfCSbp4dJt09ZL+GwzQoTf20YbPGirP5MAPMoUsBO3hwE95O/4PY9MuHly+U4UAAAAASUVORK5CYII=";

  // lib/modules/orangered.js
  var module56 = new Module("orangered");
  module56.moduleName = "orangeredName";
  module56.category = "myAccountCategory";
  module56.description = "orangeredDesc";
  module56.options = {
    openMailInNewTab: {
      description: "orangeredOpenMailInNewTabDesc",
      title: "orangeredOpenMailInNewTabTitle",
      type: "boolean",
      value: false
    },
    updateCurrentTab: {
      description: "orangeredUpdateCurrentTabDesc",
      title: "orangeredUpdateCurrentTabTitle",
      type: "boolean",
      value: true
    },
    updateOtherTabs: {
      description: "orangeredUpdateOtherTabsDesc",
      keywords: ["favicon", "sync"],
      title: "orangeredUpdateOtherTabsTitle",
      type: "boolean",
      value: true
    },
    showFloatingEnvelope: {
      description: "orangeredShowFloatingEnvelopeDesc",
      title: "orangeredShowFloatingEnvelopeTitle",
      type: "boolean",
      value: true
    },
    retroUnreadCount: {
      description: "orangeredRetroUnreadCountDesc",
      title: "orangeredRetroUnreadCountTitle",
      type: "boolean",
      value: false,
      bodyClass: true
    },
    showUnreadCountInTitle: {
      description: "orangeredShowUnreadCountInTitleDesc",
      title: "orangeredShowUnreadCountInTitleTitle",
      type: "boolean",
      value: false
    },
    faviconUseLegacy: {
      description: "faviconUseLegacyDesc",
      title: "faviconUseLegacyTitle",
      type: "boolean",
      value: false
    },
    showUnreadCountInFavicon: {
      description: "orangeredShowUnreadCountInFaviconDesc",
      title: "orangeredShowUnreadCountInFaviconTitle",
      type: "boolean",
      value: true
    },
    faviconNotificationBGColor: {
      description: "faviconNotificationBGColorDesc",
      title: "faviconNotificationBGColorTitle",
      advanced: true,
      type: "color",
      value: "#5f99cf",
      dependsOn: (options6) => options6.showUnreadCountInFavicon.value
    },
    faviconNotificationTextColor: {
      description: "faviconNotificationTextColorDesc",
      title: "faviconNotificationTextColorTitle",
      advanced: true,
      type: "color",
      value: "#ffffff",
      dependsOn: (options6) => options6.showUnreadCountInFavicon.value
    },
    resetFaviconOnLeave: {
      description: "orangeredResetFaviconOnLeaveDesc",
      title: "orangeredResetFaviconOnLeaveTitle",
      type: "boolean",
      value: true,
      dependsOn: (options6) => options6.showUnreadCountInFavicon.value
    },
    unreadLinksToInbox: {
      description: "orangeredUnreadLinksToInboxDesc",
      title: "orangeredUnreadLinksToInboxTitle",
      type: "boolean",
      value: false,
      advanced: true
    },
    hideEmptyMail: {
      description: "orangeredHideEmptyMailDesc",
      title: "orangeredHideEmptyMailTitle",
      type: "boolean",
      value: false,
      bodyClass: true
    },
    hideModMail: {
      description: "orangeredHideModMailDesc",
      title: "orangeredHideModMailTitle",
      type: "boolean",
      value: false,
      bodyClass: true
    },
    hideEmptyModMail: {
      description: "orangeredHideEmptyModMailDesc",
      title: "orangeredHideEmptyModMailTitle",
      type: "boolean",
      value: false,
      bodyClass: true,
      dependsOn: (options6) => !options6.hideModMail.value
    },
    hideNewModMail: {
      description: "orangeredHideNewModMailDesc",
      title: "orangeredHideNewModMailTitle",
      type: "boolean",
      value: false,
      bodyClass: true
    },
    hideEmptyNewModMail: {
      description: "orangeredHideEmptyNewModMailDesc",
      title: "orangeredHideEmptyNewModMailTitle",
      type: "boolean",
      value: false,
      bodyClass: true,
      dependsOn: (options6) => !options6.hideNewModMail.value
    }
  };
  module56.contentStart = () => {
    if (module56.options.faviconUseLegacy.value) setupFavicon();
    if (!loggedInUser()) {
      return;
    }
    floatingButtons();
    if (module56.options.openMailInNewTab.value) {
      $orangeredElements().attr("target", "_blank").attr("rel", "noopener noreferer");
    }
    updateFromPage();
  };
  async function updateFromPage(doc = document.body) {
    if (!isRunning(module56)) return;
    if (!module56.options.updateCurrentTab.value) return;
    if (!loggedInUser()) return;
    const debuginfoElement = doc.querySelector(".debuginfo");
    const timestampRegex = /(\d{4})-(\d{2})-(\d{2}) (\d{2})\:(\d{2})\:(\d{2})\.(\d+)[+-](\d{2})\:(\d{2})/;
    const [timestamp] = debuginfoElement && timestampRegex.exec(debuginfoElement.textContent) || [];
    if (Date.parse(timestamp)) {
      const lastUpdate2 = await session_exports.get("orangered.last-update");
      session_exports.set("orangered.last-update", timestamp);
      if (lastUpdate2 && new Date(lastUpdate2) >= new Date(timestamp)) return;
    }
    setUnreadCount(getUnreadCount(doc));
  }
  var lastCount = 0;
  var _setUnreadCount = multicast((count) => {
    if (count === lastCount) return;
    lastCount = count;
    updateFaviconBadge(count);
    updateTitle(count);
    updateInboxElements(count);
    updateMailCountElements(count);
    if (count > 0) {
      window.dispatchEvent(new Event("orangered"));
    }
  }, { name: "setUnreadCount", crossContext: false });
  function setUnreadCount(count) {
    if (module56.options.updateOtherTabs.value) {
      _setUnreadCount(count);
    } else {
      _setUnreadCount.local(count);
    }
  }
  function updateTitle(count) {
    if (!module56.options.showUnreadCountInTitle.value) return;
    if (count > 0) {
      document.title = `[${count}] ${document.title.replace(/^\[[\d]+\]\s/, "")}`;
    } else {
      document.title = document.title.replace(/^\[[\d]+\]\s/, "");
    }
  }
  function updateInboxElements(count) {
    const { nativeInboxButton, $floatingInboxButton } = orangeredElements();
    (0, import_jquery36.default)().add($floatingInboxButton).add(nativeInboxButton).attr("title", count ? "new mail!" : "No new mail").toggleClass("havemail", !!count).toggleClass("nohavemail", !count).attr("href", getInboxLink(count));
  }
  function updateMailCountElements(count) {
    const { nativeInboxCount, $floatingInboxCount } = orangeredElements();
    (0, import_jquery36.default)().add($floatingInboxCount).add(nativeInboxCount).css("display", count ? "inline-block" : "none").attr("href", getInboxLink(count)).attr("title", count ? "new mail!" : "No new mail").text(count).addClass("message-count");
  }
  function updateFaviconBadge(count) {
    if (module56.options.showUnreadCountInFavicon.value) {
      setupFavicon().badge(count);
    }
  }
  var setupFavicon = once_default(() => {
    const favicons = Array.from(document.head.querySelectorAll('link[rel="icon"]'));
    const selectedFavicon = favicons.find((f2) => f2.getAttribute("sizes") === "96x96") || favicons.slice(-1)[0];
    for (const f2 of favicons) {
      if (f2 !== selectedFavicon) f2.remove();
    }
    if (module56.options.faviconUseLegacy.value) {
      selectedFavicon.setAttribute("href", legacyFavicon_default);
    }
    const favicon = new import_favico.default({
      bgColor: module56.options.faviconNotificationBGColor.value,
      textColor: module56.options.faviconNotificationTextColor.value
    });
    if (module56.options.resetFaviconOnLeave.value) {
      window.addEventListener("beforeunload", () => favicon.reset());
    }
    return favicon;
  });
  var orangeredElements = () => ({
    ...nativeButtons(),
    ...floatingButtons(),
    modmailButtonSelector: "#modmail"
  });
  var $orangeredElements = () => Object.values(orangeredElements()).reduce(($all, ele) => $all.add(ele), (0, import_jquery36.default)());
  var nativeButtons = once_default(() => {
    const nativeInboxButton = document.querySelector("#header-bottom-right #mail");
    let nativeInboxCount = document.querySelector("#header-bottom-right .message-count");
    if (!nativeInboxCount && (module56.options.updateCurrentTab.value || module56.options.updateOtherTabs.value)) {
      nativeInboxCount = document.createElement("a");
      nativeInboxCount.style.display = "none";
      nativeInboxButton.after(nativeInboxCount);
    }
    return { nativeInboxButton, nativeInboxCount };
  });
  var floatingButtons = once_default(() => {
    if (!module56.options.showFloatingEnvelope.value) {
      return { $floatingInboxButton: void 0, $floatingInboxCount: void 0 };
    }
    let $floatingInboxButton, $floatingInboxCount;
    const pinHeader2 = module38.options.pinHeader.value;
    if (pinHeader2 === "sub" || pinHeader2 === "none") {
      $floatingInboxButton = (0, import_jquery36.default)("<a>", { id: "NREMail", class: "nohavemail" });
      addFloater($floatingInboxButton.get(0));
      $floatingInboxCount = (0, import_jquery36.default)("<a>", { id: "NREMailCount" });
      $floatingInboxCount.css("display", "none");
      $floatingInboxCount.attr("href", getInboxLink(true));
      addFloater($floatingInboxCount.get(0));
    }
    return { $floatingInboxButton, $floatingInboxCount };
  });
  function getInboxLink(havemail) {
    if (havemail && !module56.options.unreadLinksToInbox.value) {
      return "/message/unread/";
    }
    return "/message/inbox/";
  }
  function getUnreadCount(container2) {
    const mailCount = container2.querySelector(".message-count");
    return mailCount && parseInt(mailCount.textContent, 10) || 0;
  }

  // lib/modules/pageNavigator.js
  var import_jquery37 = __toESM(require_jquery(), 1);
  var module57 = new Module("pageNavigator");
  module57.moduleName = "pageNavName";
  module57.category = "browsingCategory";
  module57.description = "pageNavDesc";
  module57.options = {
    toTop: {
      type: "boolean",
      value: true,
      description: "pageNavToTopDesc",
      title: "pageNavToTopTitle"
    },
    toComment: {
      type: "boolean",
      value: true,
      description: "pageNavToCommentDesc",
      title: "pageNavToCommentTitle"
    },
    showLink: {
      type: "boolean",
      value: true,
      description: "pageNavShowLinkDesc",
      title: "pageNavShowLinkTitle"
    },
    showLinkNewTab: {
      type: "boolean",
      value: true,
      description: "pageNavShowLinkNewTabDesc",
      title: "pageNavShowLinkNewTabTitle",
      dependsOn: (options6) => options6.showLink.value
    }
  };
  module57.beforeLoad = () => {
    if (module57.options.showLink.value && isPageType("comments")) {
      watchForThings(["post"], showLinkTitle);
    }
  };
  module57.contentStart = () => {
    if (module57.options.toComment.value && isPageType("comments")) {
      backToNewCommentArea();
    }
    if (module57.options.toTop.value) {
      backToTop();
    }
  };
  function backToTop() {
    const element = string_exports.html`<a class="pageNavigator res-icon" data-id="top" href="#header" title="${i18n("pageNavToTopTitle")}">&#xF148;</a>`;
    element.addEventListener("click", (e2) => {
      e2.preventDefault();
      window.scrollTo(0, 0);
      selectedThing_exports.move("top");
    });
    addFloater(element, { order: 9 });
  }
  var showLinkTitleTemplate = ({ thumbnailSrc, linkId, settingsHash, linkHref, linkNewTab, title, domainHref, domain, time, author, authorHref }) => string_exports.html`
	<div class="res-show-link hide">
		${thumbnailSrc && string_exports._html`
			<span class="res-show-link-thumb"><img src="${thumbnailSrc}" alt="thumbnail" /></span>
		`}
		<a href="#${linkId}" class="res-icon toTop" title="Jump to title">&#xF148;</a>
		<a href="${settingsHash}" class="gearIcon" title="Configure this widget"></a>
		<div class="res-show-link-content">
			<div class="res-show-link-header">
				<a href="${linkHref}" ${linkNewTab && string_exports._html`target="_blank" rel="noopener noreferer"`} class="res-show-link-title">${title}</a>
				<a href="${domainHref}" class="res-show-link-domain">(<span>${domain}</span>)</a>
			</div>
			<div class="res-show-link-tagline">
				Submitted ${time} by
				<a href="${authorHref}" class="res-show-link-author">${author}</a>
			</div>
		</div>
	</div>
`;
  function backToNewCommentArea() {
    const commentArea = document.querySelector(".commentarea > form.usertext textarea:not([disabled])");
    if (!commentArea) return;
    const element = string_exports.html`<a class="pageNavigator res-icon" data-id="addComment" href="#comments" title="${i18n("pageNavToCommentTitle")}">&#xF003;</a>`;
    element.addEventListener("click", (e2) => {
      e2.preventDefault();
      commentArea.focus();
    });
    addFloater(element, { container: "visibleAfterScroll" });
  }
  var showLinkTitle = once_default((submissionThing) => {
    let $widget;
    let belowSubmission = true;
    let baseHeight, hoverHeight;
    function showWidget() {
      $widget.css({ top: getHeaderOffset(true) }).removeClass("hide");
    }
    function hideWidget() {
      $widget.css({ top: -baseHeight }).addClass("hide");
    }
    function renderWidget() {
      return (0, import_jquery37.default)(showLinkTitleTemplate({
        linkId: submissionThing.element.id,
        thumbnailSrc: submissionThing.getPostThumbnailUrl(),
        linkHref: submissionThing.getTitleUrl(),
        linkNewTab: module57.options.showLinkNewTab.value,
        title: submissionThing.getTitle(),
        domainHref: submissionThing.getPostDomainUrl(),
        domain: submissionThing.getPostDomainText(),
        time: submissionThing.getPostTime(),
        authorHref: submissionThing.getAuthorUrl(),
        author: submissionThing.getAuthor(),
        settingsHash: makeUrlHash(module57.moduleID, "showLink")
      }));
    }
    const updateWidget2 = frameThrottle((e2) => {
      const scrollingUp = e2.deltaY < 0;
      if (scrollingUp && belowSubmission) {
        initialize2();
        showWidget();
      } else if ($widget) {
        hideWidget();
      }
    });
    const initialize2 = once_default(() => {
      $widget = renderWidget().on("mouseenter", () => $widget.css({ height: hoverHeight })).on("mouseleave", () => $widget.css({ height: baseHeight })).appendTo(document.body);
      baseHeight = $widget.get(0).getBoundingClientRect().height;
      hoverHeight = $widget.get(0).scrollHeight;
      new IntersectionObserver((entries) => {
        belowSubmission = !entries[0].isIntersecting;
        if (!belowSubmission) hideWidget();
      }, { rootMargin: "100px 0px 0px 0px" }).observe(submissionThing.element);
      window.addEventListener("scroll", () => {
        if (scrollToElement.isProgrammaticEvent()) hideWidget();
      });
    });
    window.addEventListener("wheel", updateWidget2, { passive: true });
  });

  // lib/modules/troubleshooter.js
  var module58 = new Module("troubleshooter");
  module58.moduleName = "troubleshooterName";
  module58.alwaysEnabled = true;
  module58.sort = -7;
  module58.description = "troubleshooterDesc";
  module58.category = "aboutCategory";
  module58.options = {
    clearCache: {
      title: "troubleshooterClearCacheTitle",
      type: "button",
      text: "troubleshooterClearLabel",
      callback: clearCache,
      description: "troubleshooterClearCacheDesc"
    },
    clearTags: {
      title: "troubleshooterClearTagsTitle",
      type: "button",
      text: "troubleshooterClearLabel",
      callback: clearTags,
      description: "troubleshooterClearTagsDesc"
    },
    resetToFactory: {
      title: "troubleshooterResetToFactoryTitle",
      type: "button",
      text: "troubleshooterResetLabel",
      callback: resetToFactory,
      description: "troubleshooterResetToFactoryDesc"
    },
    disableRES: {
      title: "troubleshooterDisableRESTitle",
      type: "button",
      text: "troubleshooterDisableLabel",
      callback() {
        const url = new URL(data.pathname, data.origin);
        url.hash = RES_DISABLED_HASH;
        window.top.location.href = url.href;
      },
      description: "troubleshooterDisableRESDesc"
    },
    breakpoint: {
      title: "troubleshooterBreakpointTitle",
      type: "button",
      text: "troubleshooterBreakpointLabel",
      callback() {
        debugger;
      },
      description: "troubleshooterBreakpointDesc"
    },
    testEnvironment: {
      title: "troubleshooterTestEnvironmentTitle",
      type: "button",
      text: "troubleshooterTestEnvironmentLabel",
      callback: testEnvironment,
      description: "troubleshooterTestEnvironmentDesc"
    },
    testNotifications: {
      title: "troubleshooterTestNotificationsTitle",
      type: "button",
      text: "troubleshooterTestNotificationsLabel",
      callback: testNotifications,
      description: "troubleshooterTestNotificationsDesc"
    }
  };
  function clearCache() {
    xhrCache_exports.clear();
    session_exports.clear();
    localStorage.removeItem(CACHED_LANG_KEY);
    localStorage.removeItem(CACHED_MESSAGES_TOKEN_KEY);
    localStorage.removeItem(CACHED_MESSAGES_KEY);
    showNotification(i18n("troubleshooterCachesCleared"), 2500);
  }
  async function clearTags() {
    const confirm2 = window.confirm(i18n("troubleshooterAreYouPositive"));
    if (confirm2) {
      const toDelete = (await Tag.getStored()).filter(({ text, votesUp = 0, votesDown = 0 }) => !text && votesUp <= 1 && votesDown <= 1);
      for (const tag of toDelete) tag.delete();
      showNotification(i18n("troubleshooterEntriesRemoved", toDelete.length), 2500);
    } else {
      showNotification(i18n("troubleshooterNoActionTaken"), 2500);
    }
  }
  function resetToFactory() {
    const confirm2 = window.prompt(i18n("troubleshooterThisWillKillYourSettings", "trash"));
    if (confirm2 === "trash" || confirm2 === '"trash"') {
      clearCache();
      storage_exports.clear();
      showNotification(i18n("troubleshooterSettingsReset"), 2500);
    } else {
      showNotification(i18n("troubleshooterNoActionTaken"), 2500);
    }
  }
  function testNotifications() {
    showNotification({
      moduleID: module58.moduleID,
      header: "Template test",
      message: "<p>Hello, FakeUsername</p>"
    });
  }
  var testMulticast = multicast((val) => {
    alert_exports.open(`Multicast: ${val}`);
  }, { name: "testMulticast", local: false, crossContext: false });
  async function testEnvironment() {
    const testKey = "__test__";
    const rows = [];
    try {
      let rand;
      rows.push(`Private browsing: ${String(isPrivateBrowsing())}`, "");
      rand = Math.random();
      rows.push(`Sending multicast: ${rand}`, "");
      testMulticast(rand);
      rand = Math.random();
      rows.push(`Storage.set(): ${rand}`);
      storage_exports.set(testKey, rand);
      rows.push(`Storage.get(): ${await storage_exports.get(testKey)}`);
      rows.push(`Storage.has(): ${await storage_exports.has(testKey)}`);
      rows.push("Storage.delete()");
      storage_exports.delete(testKey);
      rows.push(`Storage.get(): ${await storage_exports.get(testKey)}`);
      rows.push(`Storage.has(): ${await storage_exports.has(testKey)}`, "");
      rand = Math.random();
      rows.push(`Session.set(): ${rand}`);
      session_exports.set(testKey, rand);
      rows.push(`Session.get(): ${await session_exports.get(testKey)}`);
      rows.push(`Session.has(): ${await session_exports.has(testKey)}`);
      rows.push("Session.delete()");
      session_exports.delete(testKey);
      rows.push(`Session.get(): ${await session_exports.get(testKey)}`);
      rows.push(`Session.has(): ${await session_exports.has(testKey)}`, "");
      rand = Math.random();
      const wrapped = storage_exports.wrap(testKey, "default");
      rows.push(`wrapped.set(): ${rand}`);
      wrapped.set(rand);
      rows.push(`wrapped.get(): ${await wrapped.get()}`);
      rows.push(`wrapped.has(): ${await wrapped.has()}`);
      rows.push("wrapped.delete()");
      wrapped.delete();
      rows.push(`wrapped.get(): ${await wrapped.get()}`);
      rows.push(`wrapped.has(): ${await wrapped.has()}`, "");
      rand = Math.random();
      const domain = storage_exports.wrapPrefix(testKey, () => "default");
      rows.push(`prefix.set(): ${rand}`);
      domain.set("1", rand);
      rows.push(`prefix.get(): ${await domain.get("1")}`);
      rows.push(`prefix.has(): ${await domain.has("1")}`);
      rows.push("prefix.delete()");
      domain.delete("1");
      rows.push(`prefix.get(): ${await domain.get("1")}`);
      rows.push(`prefix.has(): ${await domain.has("1")}`, "");
      rand = Math.random();
      const blob = storage_exports.wrapBlob(testKey, () => "default");
      rows.push(`blob.set(): ${rand}`);
      blob.set("1", rand);
      rows.push(`blob.get(): ${await blob.get("1")}`);
      rows.push(`blob.has(): ${await blob.has("1")}`);
      rows.push("blob.delete()");
      blob.delete("1");
      rows.push(`blob.get(): ${await blob.get("1")}`);
      rows.push(`blob.has(): ${await blob.has("1")}`, "");
    } catch (e2) {
      rows.push("", `Errored: ${e2}`);
      console.error(e2);
    }
    alert_exports.open(rows.join("<br>"));
  }

  // lib/modules/presets.js
  var module59 = new Module("presets");
  module59.moduleName = "presetsName";
  module59.category = "coreCategory";
  module59.alwaysEnabled = true;
  module59.description = "presetsDesc";
  module59.options = {
    lite: {
      title: "presetsLiteTitle",
      description: "presetsLiteDesc",
      type: "button",
      text: "apply preset",
      callback: confirmPreset(() => toggleModules([
        "notifications",
        "hover",
        "announcements",
        "orangered",
        "onboarding",
        "selectedEntry",
        "showImages",
        "submitHelper",
        "neverEndingReddit",
        "accountSwitcher",
        "filteReddit",
        "quickMessage",
        "subredditInfo",
        "userInfo",
        "userHighlight",
        "searchHelper",
        "betteReddit",
        "styleTweaks",
        "pageNavigator",
        "commandLine",
        "commentHidePersistor",
        "commentTools",
        "commentPreview",
        "localDate",
        "noParticipation"
      ], "*"))
    },
    cleanSlate: {
      title: "presetsCleanSlateTitle",
      description: "presetsCleanSlateDesc",
      type: "button",
      text: "apply preset",
      callback: confirmPreset(() => toggleModules(void 0, "*"))
    },
    noPopups: {
      title: "presetsNoPopupsTitle",
      description: "presetsNoPopupsDesc",
      type: "button",
      text: "apply preset",
      callback: confirmPreset(async () => {
        await toggleModules(void 0, "hover RESTips showParent subredditInfo".split(/[,\s]/));
        await toggleOptions(void 0, "userTagger.hoverInfo".split(/[,\s]/));
      })
    },
    resetToFactory: module58.options.resetToFactory
  };
  function confirmPreset(callback) {
    return async function() {
      const confirmation = prompt(`Are you sure you want to apply the "${i18n(this.title)}" preset? Type "yes" to continue.`);
      if (/^"?yes"?$/.test(confirmation)) {
        await callback();
        const shouldReload = confirm(`Applied preset: ${i18n(this.title)}
You must reload the page to see results.

Would you like to reload now?`);
        if (shouldReload) {
          location.reload();
        }
      } else {
        showNotification({
          moduleID: module59.moduleID,
          header: "Preset cancelled",
          message: 'If you really wanted to apply this preset, make sure to type in "yes" when prompted.'
        });
      }
    };
  }
  function sanitizeModulesList(unsanitized) {
    let sanitized;
    if (unsanitized === "*") {
      sanitized = allModules();
    } else if (typeof unsanitized === "string") {
      sanitized = unsanitized.split(/[,\s]/);
    } else if (unsanitized && unsanitized.length) {
      sanitized = unsanitized;
    }
    return sanitized ? [].concat(sanitized) : [];
  }
  async function toggleModules(requestEnable, requestDisable) {
    let enable = sanitizeModulesList(requestEnable);
    let disable = sanitizeModulesList(requestDisable);
    disable = requestEnable !== "*" ? disable.filter((moduleID) => !enable.includes(moduleID)) : disable;
    enable = requestDisable !== "*" ? enable.filter((moduleID) => !disable.includes(moduleID)) : enable;
    for (const modId of disable) await setEnabled(modId, false);
    for (const modId of enable) await setEnabled(modId, true);
  }
  function allModules() {
    return all().map((mod) => mod.moduleID);
  }
  async function toggleOptions(requestEnable, requestDisable) {
    const enable = requestEnable ? [].concat(requestEnable) : [];
    const disable = requestDisable ? [].concat(requestDisable) : [];
    for (const option2 of enable) await setOptionValue(true, option2);
    for (const option2 of disable) await setOptionValue(false, option2);
  }
  async function setOptionValue(value, path) {
    if (typeof path === "string") {
      path = path.split(".");
    }
    const [id2, optName] = path;
    await set5(id2, optName, value);
  }

  // lib/modules/profileNavigator.js
  var module60 = new Module("profileNavigator");
  module60.moduleName = "profileNavigatorName";
  module60.description = "profileNavigatorDesc";
  module60.category = "myAccountCategory";
  module60.options = {
    sectionMenu: {
      title: "profileNavigatorSectionMenuTitle",
      type: "boolean",
      value: true,
      description: "profileNavigatorSectionMenuDesc"
    },
    sectionLinks: {
      title: "profileNavigatorSectionLinksTitle",
      dependsOn: (options6) => options6.sectionMenu.value,
      description: "profileNavigatorSectionLinksDesc",
      type: "table",
      addRowText: "+add profile section shortcut",
      fields: [{
        key: "label",
        name: "label",
        type: "text"
      }, {
        key: "url",
        name: "url",
        type: "text"
      }],
      value: [
        ["saved", "./saved"],
        ["comments", "./comments"],
        ["submitted", "./submitted"],
        ["gilded", "./gilded"],
        ["upvoted", "./upvoted"],
        ["downvoted", "./downvoted"]
      ]
    },
    hoverDelay: {
      title: "profileNavigatorHoverDelayTitle",
      dependsOn: (options6) => options6.sectionMenu.value,
      type: "text",
      value: "1000",
      description: "profileNavigatorHoverDelayDesc",
      advanced: true
    },
    fadeDelay: {
      title: "profileNavigatorFadeDelayTitle",
      dependsOn: (options6) => options6.sectionMenu.value,
      type: "text",
      value: "200",
      description: "profileNavigatorFadeDelayDesc",
      advanced: true
    },
    fadeSpeed: {
      title: "profileNavigatorFadeSpeedTitle",
      dependsOn: (options6) => options6.sectionMenu.value,
      type: "text",
      value: "0.7",
      description: "profileNavigatorFadeSpeedDesc",
      advanced: true
    }
  };
  module60.contentStart = () => {
    const username = loggedInUser();
    if (module60.options.sectionMenu.value && username) {
      dropdownList(module60.moduleID).options({
        openDelay: penalizedDelay(module60.moduleID, "sectionMenu", module60.options.hoverDelay),
        fadeDelay: parseFloat(module60.options.fadeDelay.value),
        fadeSpeed: parseFloat(module60.options.fadeSpeed.value),
        pin: pin.bottom
      }).populateWith(() => [getListFragment3(username)]).watch("#header .user a");
    }
  };
  var getListFragment3 = (username) => {
    alterFeaturePenalty(module60.moduleID, "sectionMenu", 5);
    const fragment = document.createDocumentFragment();
    for (const link of module60.options.sectionLinks.value) {
      const label = link[0] || "";
      const url = link[1] || "";
      const li = string_exports.html`<li><a href="/user/${username}/${url}">${label}</a></li>`;
      li.addEventListener("click", () => {
        dropdownList(module60.moduleID).close();
        alterFeaturePenalty(module60.moduleID, "sectionMenu", -30);
      });
      fragment.append(li);
    }
    fragment.append(string_exports.html`<li><a href=${makeUrlHash(module60.moduleID, "sectionMenu")}>
		<i>${i18n(module60.moduleName)}</i>
		<span class="RESMenuItemButton gearIcon"></span>
	</a></li>`);
    return fragment;
  };

  // lib/modules/profileRedirect.js
  var module61 = new Module("profileRedirect");
  module61.moduleName = "profileRedirectName";
  module61.category = "usersCategory";
  module61.description = "profileRedirectDesc";
  module61.keywords = ["legacy", "overview"];
  module61.include = [
    "profile",
    "profile2x"
  ];
  module61.options = {
    fromLandingPage: {
      title: "profileRedirectFromLandingPageTitle",
      description: "profileRedirectFromLandingPageDesc",
      keywords: ["legacy", "overview"],
      type: "enum",
      value: "none",
      values: [{
        name: "Do nothing",
        value: "none"
      }, {
        name: "Overview (legacy)",
        value: "overview"
      }, {
        name: "Comments",
        value: "comments"
      }, {
        name: "Submitted (legacy)",
        value: "submitted"
      }, {
        name: "Gilded",
        value: "gilded"
      }, {
        name: "Custom",
        value: "custom"
      }]
    },
    customFromLandingPage: {
      dependsOn: (options6) => options6.fromLandingPage.value === "custom",
      title: "profileRedirectCustomFromLandingPageTitle",
      description: "profileRedirectCustomFromLandingPageDesc",
      type: "text",
      value: ""
    }
  };
  module61.beforeLoad = function() {
    const [, username, currentSection] = regexes.profile2x.exec(location.pathname) || [];
    if (username && !currentSection) {
      if (module61.options.fromLandingPage.value !== "none") {
        const preferredSection = module61.options.fromLandingPage.value === "custom" ? module61.options.customFromLandingPage.value : module61.options.fromLandingPage.value;
        window.location.replace(`/user/${username}/${preferredSection}`);
      } else if (isPageType("profile2x")) {
        const message = string_exports.html`
				<div>
					<p>${i18n("profileRedirectFromLandingPageNotificationText")}</p>
					<p><a class="RESNotificationButtonBlue" href="${makeUrlHash(module61.moduleID, "fromLandingPage")}">${i18n("profileRedirectFromLandingPageNotificationButton")}</a></p>
				</div>
			`;
        const notification = showNotification({
          moduleID: module61.moduleID,
          optionKey: "fromLandingPage",
          header: i18n("profileRedirectFromLandingPageNotificationTitle"),
          message,
          cooldown: WEEK
        });
        message.querySelector(".RESNotificationButtonBlue").addEventListener("click", () => {
          notification.close();
        });
      }
    }
  };

  // lib/modules/quarantineHide.js
  var import_jquery38 = __toESM(require_jquery(), 1);
  var module62 = new Module("quarantineHide");
  module62.moduleName = "quarantineHideName";
  module62.category = "appearanceCategory";
  module62.description = "quarantineHideDesc";
  module62.options = {
    hideFlair: {
      title: "quarantineHideFlairTitle",
      // i18n
      type: "boolean",
      value: false,
      description: "quarantineHideFlairDesc"
      // i18n
    },
    hideQuarantinedInSub: {
      title: "quarantineHideInSubTitle",
      // i18n
      type: "boolean",
      value: false,
      description: "quarantineHideInSubDesc"
      // i18n
    }
  };
  module62.include = ["linklist", "comments", "wiki"];
  module62.contentStart = () => {
    if (module62.options.hideFlair.value) {
      watchForThings(["post"], frameThrottle(() => {
        (0, import_jquery38.default)(".quarantine-stamp").parent().remove();
      }));
    }
    if (inQuarantinedSubreddit() && module62.options.hideQuarantinedInSub.value) {
      bodyClasses_exports.remove("quarantine");
      (0, import_jquery38.default)(".quarantine-notice").hide();
    }
  };

  // lib/modules/redditUserInfo.js
  var module63 = new Module("redditUserInfo");
  module63.moduleName = "redditUserInfoName";
  module63.category = "usersCategory";
  module63.description = "redditUserInfoDesc";
  module63.options = {
    hideAuthorTooltip: {
      type: "boolean",
      value: false,
      description: "redditUserInfoHideDesc",
      title: "redditUserInfoHideTitle",
      bodyClass: true
    }
  };

  // lib/modules/requestPermissions.js
  var module64 = new Module("requestPermissions");
  module64.moduleName = "requestPermissionsName";
  module64.description = "requestPermissionsDesc";
  module64.category = "aboutCategory";
  module64.disabledByDefault = true;
  module64.permissions = {
    get requiredPermissions() {
      return chrome.runtime.getManifest().optional_permissions;
    }
    // eslint-disable-line no-undef
  };

  // lib/modules/search.js
  var import_jquery39 = __toESM(require_jquery(), 1);
  var module65 = new Module("search");
  module65.moduleName = "searchName";
  module65.category = "aboutCategory";
  module65.alwaysEnabled = true;
  module65.sort = -9;
  module65.description = `
	<p>Search for settings within RES.</p>
	<div id="SearchRES-results-container">
		<div id="SearchRES-count"></div>
		<ul id="SearchRES-results"></ul>
		<p id="SearchRES-results-hidden">Some results have been hidden because advanced options are currently hidden. <a href="#">Show advanced options.</a></p>
	</div>
	<div id="SearchRES-boilerplate">
		<p>You can search for RES options by module name, option name, and description. For example, try searching for "daily trick" in one of the following ways:</p>
		<ul>
			<li>type <code>daily trick</code> in the search box to the left and click the magnifying glass button</li>
			<li>press <code>.</code> to open the RES console, type in <code>search <em>daily trick</em></code>, and press Enter</li>
		</ul>
	</div>
`;
  module65.descriptionRaw = true;
  var searchDomain = once_default(() => {
    const results = [];
    for (const mod of all()) {
      if (mod === module65) continue;
      if (mod.hidden) continue;
      const moduleName = i18n(mod.moduleName);
      const category = i18n(mod.category);
      results.push({
        getRank: rankModule,
        context: {
          title: moduleName,
          description: mod.descriptionRaw ? mod.description : markdown(i18n(mod.description)),
          category,
          moduleID: mod.moduleID,
          moduleName,
          keywords: mod.keywords
        }
      });
      if (isEmpty_default(mod.options)) continue;
      for (const [optionKey, option2] of Object.entries(mod.options)) {
        if (option2.noconfig) continue;
        const optionName = i18n(option2.title);
        results.push({
          getRank: rankOption,
          context: {
            title: optionName,
            description: markdown(i18n(option2.description).split("\n")[0]),
            advanced: option2.advanced,
            category,
            moduleID: mod.moduleID,
            moduleName,
            optionKey,
            optionName,
            keywords: option2.keywords || []
          }
        });
      }
    }
    return results;
  });
  function rankString(queryTerms, string) {
    if (!queryTerms || !queryTerms.length || !string) {
      return Infinity;
    }
    const indexes = indexesOfSearchTermsInString(queryTerms, sanitizeString(string, false));
    const weighted = indexes.map((item) => 100 - item.value * (Math.log(item.matchedIndex + 1) / Math.log(5) + 1));
    return weighted.length ? weighted.reduce((a2, b2) => a2 + b2, 0) : Infinity;
  }
  function rankModule(queryTerms, context) {
    const string = [
      context.moduleID,
      context.moduleName,
      context.category,
      context.description,
      ...context.keywords
    ].join("~");
    return rankString(queryTerms, string) * 0.9;
  }
  function rankOption(queryTerms, context) {
    const string = [
      // option-related strings
      context.optionKey,
      context.title,
      context.description,
      ...context.keywords,
      // module-related strings
      context.moduleID,
      context.moduleName,
      context.category
    ].join("~");
    return rankString(queryTerms, string);
  }
  function indexesOfSearchTermsInString(needles, haystack) {
    if (!haystack || !haystack.length) return [];
    return needles.map((needle, i2) => ({
      matchedIndex: i2,
      value: haystack.indexOf(needle)
    })).filter((item) => item.value !== -1);
  }
  function sanitizeString(text, preserveSpaces) {
    if (text === void 0 || text === null) {
      return "";
    }
    const replaceSpacesWith = preserveSpaces ? " " : "";
    return text.toString().toLowerCase().replace(/[,\/\s]+/g, replaceSpacesWith);
  }
  var input = once_default(() => downcast(string_exports.html`<input id="SearchRES-input" type="text" placeholder="${i18n("searchRESSettings")}">`, HTMLInputElement));
  var searchResultTemplate = ({ title, category, description, moduleName, moduleID, optionName, optionKey }) => string_exports.html`
	<div>
		<div class="SearchRES-result-header">
			<span class="SearchRES-result-title">${title}</span>
			<span class="SearchRES-breadcrumb">${i18n("RESSettingsConsole")}
				 ${category}
				 ${moduleName} (${moduleID})
				${optionName && optionKey ? ` \u2192 ${optionName} (${optionKey})` : optionKey && ` \u2192 ${optionKey}`}
			</span>
		</div>
		<div class="SearchRES-result-description">
			${string_exports.safe(description)}
		</div>
	</div>
`;
  var drawSearchResultItem = memoize_default((result) => {
    const element = document.createElement("li");
    element.classList.add("SearchRES-result-item");
    if (result.advanced) {
      element.classList.add("advanced");
    }
    element.setAttribute("data-module-id", result.moduleID);
    if (result.optionKey) {
      element.setAttribute("data-option-key", result.optionKey);
    }
    element.appendChild(searchResultTemplate(result));
    const copybutton = createElement_exports.icon(
      61785,
      "span",
      "SearchRES-result-copybutton res-icon",
      i18n("searchCopyResultForComment")
    );
    element.insertBefore(copybutton, element.firstChild);
    return element;
  });

  // lib/modules/searchHelper.js
  var import_jquery40 = __toESM(require_jquery(), 1);
  var module66 = new Module("searchHelper");
  module66.moduleName = "searchHelperName";
  module66.category = "browsingCategory";
  module66.description = "searchHelperDesc";
  module66.options = {
    addSearchOptions: {
      title: "searchHelperAddSearchOptionsTitle",
      type: "boolean",
      value: true,
      description: "searchHelperAddSearchOptionsDesc"
    },
    defaultSortOption: {
      title: "searchHelperDefaultSortOptionTitle",
      type: "enum",
      value: "none",
      values: [{
        name: "none",
        value: "none"
      }, {
        name: "relevance",
        value: "relevance"
      }, {
        name: "new",
        value: "new"
      }, {
        name: "hot",
        value: "hot"
      }, {
        name: "top",
        value: "top"
      }, {
        name: "comments",
        value: "comments"
      }],
      description: "searchHelperDefaultSortOptionDesc",
      dependsOn: (options6) => options6.addSearchOptions.value,
      advanced: true
    },
    defaultTimeOption: {
      title: "searchHelperDefaultTimeOptionTitle",
      type: "enum",
      value: "none",
      values: [{
        name: "none",
        value: "none"
      }, {
        name: "all",
        value: "all"
      }, {
        name: "hour",
        value: "hour"
      }, {
        name: "day",
        value: "day"
      }, {
        name: "week",
        value: "week"
      }, {
        name: "month",
        value: "month"
      }, {
        name: "year",
        value: "year"
      }],
      description: "searchHelperDefaultTimeOptionDesc",
      dependsOn: (options6) => options6.addSearchOptions.value,
      advanced: true
    },
    legacySearch: {
      title: "searchHelperLegacySearchTitle",
      type: "boolean",
      value: false,
      description: "searchHelperLegacySearchDesc"
    },
    toggleSearchOptions: {
      title: "searchHelperToggleSearchOptionsTitle",
      type: "boolean",
      value: true,
      description: "searchHelperToggleSearchOptionsDesc",
      advanced: true,
      dependsOn: (options6) => options6.legacySearch.value
    },
    hideSearchOptions: {
      title: "searchHelperHideSearchOptionsTitle",
      type: "boolean",
      value: false,
      description: "searchHelperHideSearchOptionsDesc",
      advanced: true,
      dependsOn: (options6) => options6.legacySearch.value
    },
    userFilterBySubreddit: {
      title: "searchHelperUserFilterBySubredditTitle",
      type: "boolean",
      value: false,
      description: "searchHelperUserFilterBySubredditDesc"
    },
    searchByFlair: {
      title: "searchHelperSearchByFlairTitle",
      type: "boolean",
      value: true,
      description: "searchHelperSearchByFlairDesc"
    },
    searchPageTabs: {
      title: "searchHelperSearchPageTabsTitle",
      type: "boolean",
      value: true,
      description: "searchHelperSearchPageTabsDesc",
      bodyClass: true
    },
    defaultSearchTab: {
      title: "searchHelperDefaultSearchTabTitle",
      type: "enum",
      value: "subreddits",
      values: [{
        name: "none",
        value: "none"
      }, {
        name: "subreddits",
        value: "subreddits"
      }, {
        name: "limit to subreddit",
        value: "facets"
      }, {
        name: "refine",
        value: "options"
      }],
      description: "searchHelperDefaultSearchTabDesc",
      dependsOn: (options6) => options6.searchPageTabs.value,
      advanced: true
    },
    transitionSearchTabs: {
      title: "searchHelperTransitionSearchTabsTitle",
      type: "boolean",
      value: true,
      description: "searchHelperTransitionSearchTabsDesc",
      dependsOn: (options6) => options6.searchPageTabs.value,
      advanced: true
    },
    searchBySubreddit: {
      title: "searchHelperSearchBySubredditTitle",
      type: "enum",
      value: "default",
      values: [{
        name: "default (let reddit manage it)",
        value: "default"
      }, {
        name: "always",
        value: "always"
      }, {
        name: "never",
        value: "never"
      }],
      description: "searchHelperSearchBySubredditDesc"
    }
  };
  module66.contentStart = () => {
    if (module66.options.addSearchOptions.value) {
      const searchExpando = document.getElementById("searchexpando");
      if (searchExpando) {
        let searchOptionsHtml = '<label>Sort:<select name="sort"><option value="relevance">relevance</option><option value="new">new</option><option value="hot">hot</option><option value="top">top</option><option value="comments">comments</option></select></label> <label>Time:<select name="t"><option value="all">all time</option><option value="hour">this hour</option><option value="day">today</option><option value="week">this week</option><option value="month">this month</option><option value="year">this year</option></select></label>';
        if ((0, import_jquery40.default)(searchExpando).find("input[name=restrict_sr]").length) {
          searchOptionsHtml = `<br />${searchOptionsHtml}`;
        }
        if (module66.options.defaultSortOption.value !== "none") {
          const defaultValue = module66.options.defaultSortOption.value;
          searchOptionsHtml = searchOptionsHtml.replace(`value="${defaultValue}"`, `value="${defaultValue}" selected`);
        }
        if (module66.options.defaultTimeOption.value !== "none") {
          const defaultValue = module66.options.defaultTimeOption.value;
          searchOptionsHtml = searchOptionsHtml.replace(`value="${defaultValue}"`, `value="${defaultValue}" selected`);
        }
        (0, import_jquery40.default)(searchExpando).find("#moresearchinfo").before(searchOptionsHtml);
      }
    }
    if (module66.options.legacySearch.value) {
      (0, import_jquery40.default)("form#search").append('<input type="hidden" name="feature" value="legacy_search" />');
    }
    if (module66.options.userFilterBySubreddit.value) {
      const [, userProfile] = location.pathname.match(regexes.profile) || [];
      if (userProfile && document.referrer) {
        const referrer = new URL(document.referrer);
        let match, previousPage;
        if (match = referrer.pathname.match(regexes.subreddit)) {
          previousPage = `r/${match[1]}`;
        } else if (match = referrer.pathname.match(regexes.multireddit)) {
          previousPage = match[1];
        }
        if (previousPage) {
          (0, import_jquery40.default)(".content[role=main]").prepend(`<div class="infobar"><a href="/${previousPage}/search?q=author:${userProfile} nsfw:no&restrict_sr=on">Search post of ${userProfile} on /${previousPage}</a></div>`);
        }
      }
    }
    const isLegacySearch = document.querySelector("#siteTable");
    if (module66.options.toggleSearchOptions.value && isPageType("search") && isLegacySearch) {
      if (module66.options.hideSearchOptions.value || location.hash === "#res-hide-options") {
        bodyClasses_exports.add("res-hide-options");
      }
      (0, import_jquery40.default)(".content .searchpane").append('<a href="#res-hide-options" class="searchpane-toggle-hide">hide search options</a>');
      (0, import_jquery40.default)(".content .searchpane ~ .menuarea").prepend('<a href="#res-show-options" class="searchpane-toggle-show">show search options</a>');
      (0, import_jquery40.default)(".searchpane-toggle-hide").on("click", () => bodyClasses_exports.add("res-hide-options"));
      (0, import_jquery40.default)(".searchpane-toggle-show").on("click", () => bodyClasses_exports.remove("res-hide-options"));
    }
    if (module66.options.searchByFlair.value) {
      (0, import_jquery40.default)("#siteTable").on("mouseenter", ".linkflairlabel:not(.res-flairSearch)", (e2) => {
        const subreddit2 = Thing.checkedFrom(e2.currentTarget).getSubreddit();
        const flair = e2.currentTarget.title.replace(/\s/g, "+");
        if (flair) {
          e2.currentTarget.classList.add("res-flairSearch");
          e2.currentTarget.appendChild(string_exports.html`<a href="${string_exports.encode`/r/${subreddit2}/search?sort=new&restrict_sr=on&q=flair%3A${flair}`}"></a>`);
        }
      });
    }
    if (module66.options.searchPageTabs.value && !isLegacySearch) {
      const $searchTabsEle = (0, import_jquery40.default)("<ul>", { class: "res-search-tabs" });
      const searchHeader = document.querySelector("#previoussearch");
      const searchForm = document.querySelector(".content form#search");
      const moreSearchInfo = document.querySelector("#moresearchinfo");
      const searchFacets = document.querySelector("body.search-page .searchfacets");
      const $searchOptions = (0, import_jquery40.default)("<div>", { class: "res-search-options" });
      if (!searchForm) {
        return;
      }
      searchForm.removeChild(searchForm.querySelector("#moresearchinfo + p"));
      $searchTabsEle.appendTo(searchHeader);
      const subredditResultListing = document.querySelectorAll(".search-result-listing");
      if (subredditResultListing.length > 1) {
        subredditResultListing[0].classList.add("res-search-subreddits");
      }
      if (moreSearchInfo) {
        $searchOptions.appendTo(searchHeader);
        (0, import_jquery40.default)(moreSearchInfo).children().appendTo($searchOptions);
      }
      if (searchFacets) {
        (0, import_jquery40.default)(searchFacets).appendTo(searchHeader);
      }
      if ((0, import_jquery40.default)(".res-search-subreddits").length) {
        (0, import_jquery40.default)(".res-search-subreddits").appendTo(searchHeader);
      }
      const searchTabs = {
        subreddits: {
          label: "subreddits",
          id: "subs",
          target: ".res-search-subreddits",
          exists: (0, import_jquery40.default)(".res-search-subreddits").length
        },
        facets: {
          label: "limit to subreddit",
          id: "facets",
          target: ".searchfacets",
          exists: searchFacets
        },
        options: {
          label: "refine",
          id: "options",
          target: ".res-search-options",
          exists: $searchOptions.get(0)
        }
      };
      for (const searchTab of Object.values(searchTabs)) {
        if (searchTab.exists) {
          (0, import_jquery40.default)(searchTab.target).addClass("res-search-pane").slideUp(0);
          const $searchTabLi = (0, import_jquery40.default)("<li>").attr({ class: `res-search-tab-${searchTab.id}` }).appendTo($searchTabsEle);
          (0, import_jquery40.default)("<a>").attr({ href: "#" }).text(searchTab.label).appendTo($searchTabLi).click((e2) => searchTabToggle(searchTab.id, searchTab.target, e2.currentTarget));
        }
      }
      if (module66.options.defaultSearchTab.value !== "none" && searchTabs[module66.options.defaultSearchTab.value].exists) {
        searchTabToggle(
          searchTabs[module66.options.defaultSearchTab.value].id,
          searchTabs[module66.options.defaultSearchTab.value].target,
          null
        );
      }
    }
  };
  module66.afterLoad = () => {
    if (module66.options.searchBySubreddit.value !== "default" && !isPageType("search")) {
      const restrictSearch = document.querySelector("input[name=restrict_sr]");
      if (restrictSearch) {
        restrictSearch.checked = module66.options.searchBySubreddit.value === "always";
      }
    }
  };
  function searchTabToggle(tabID, target, source) {
    const transitionSpd = module66.options.transitionSearchTabs.value ? 200 : 0;
    const sourceParent = source ? downcast(source.parentNode, HTMLElement) : null;
    const tab = sourceParent || document.querySelector(`.res-search-tabs .res-search-tab-${tabID}`);
    const activeClass = "res-search-tab-active";
    const openClass = "res-search-pane-open";
    if (tab.classList.contains(activeClass)) {
      (0, import_jquery40.default)(target).removeClass(openClass).slideUp(transitionSpd);
      tab.classList.remove(activeClass);
    } else {
      (0, import_jquery40.default)(".res-search-pane").addClass(openClass).slideUp(transitionSpd);
      (0, import_jquery40.default)(".res-search-tabs li").removeClass(activeClass);
      (0, import_jquery40.default)(".res-search-pane").removeClass(openClass);
      tab.classList.add(activeClass);
      const speed = sourceParent ? transitionSpd : 0;
      (0, import_jquery40.default)(target).addClass(openClass).slideDown(speed);
    }
    return false;
  }

  // lib/modules/selectedEntry.js
  var import_jquery41 = __toESM(require_jquery(), 1);
  var module67 = new Module("selectedEntry");
  module67.moduleName = "selectedEntryName";
  module67.category = "browsingCategory";
  module67.include = ["comments", "linklist", "commentsLinklist", "modqueue", "profile", "inbox", "search"];
  module67.description = "selectedEntryDesc";
  module67.options = {
    autoSelectOnScroll: {
      title: "selectedEntryAutoSelectOnScrollTitle",
      type: "boolean",
      value: false,
      description: "selectedEntryAutoSelectOnScrollDesc"
    },
    scrollToSelectedThingOnLoad: {
      title: "selectedEntryScrollToSelectedThingOnLoadTitle",
      type: "boolean",
      value: false,
      advanced: true,
      description: "selectedEntryScrollToSelectedThingOnLoadDesc"
    },
    addLine: {
      title: "selectedEntryAddLineTitle",
      type: "boolean",
      value: false,
      description: "selectedEntryAddLineDesc"
    },
    setColors: {
      title: "selectedEntrySetColorsTitle",
      type: "boolean",
      value: true,
      description: "selectedEntrySetColorsDesc"
    },
    backgroundColor: {
      title: "selectedEntryBackgroundColorTitle",
      type: "color",
      value: "#f0f3fc",
      description: "selectedEntryBackgroundColorDesc",
      advanced: true,
      dependsOn: (options6) => options6.setColors.value
    },
    backgroundColorNight: {
      title: "selectedEntryBackgroundColorNightTitle",
      type: "color",
      value: "#373737",
      description: "selectedEntryBackgroundColorNightDesc",
      advanced: true,
      dependsOn: (options6) => options6.setColors.value
    },
    textColorNight: {
      title: "selectedEntryTextColorNightTitle",
      type: "color",
      value: "#dddddd",
      description: "selectedEntryTextColorNightDesc",
      advanced: true,
      dependsOn: (options6) => options6.setColors.value
    },
    outlineStyle: {
      title: "selectedEntryOutlineStyleTitle",
      type: "text",
      value: "",
      description: "selectedEntryOutlineStyleDesc",
      advanced: true
    },
    outlineStyleNight: {
      title: "selectedEntryOutlineStyleNightTitle",
      type: "text",
      value: "",
      description: "selectedEntryOutlineStyleNightDesc",
      advanced: true
    }
  };
  module67.beforeLoad = () => {
    if (module67.options.addLine.value) styleLine();
    if (module67.options.setColors.value) styleColor();
    styleOutline();
    selectedThing_exports.setScrollToSelectedThingOnLoad(module67.options.scrollToSelectedThingOnLoad.value);
  };
  module67.contentStart = () => {
    (0, import_jquery41.default)(document.body).on("mouseup", Thing.thingSelector, throttle_default((e2) => {
      if (click.isProgrammaticEvent(e2)) return;
      const thing = Thing.from(e2.currentTarget);
      if (thing) selectedThing_exports.set(thing);
    }, 50, { leading: true, trailing: false }));
    if (module67.options.autoSelectOnScroll.value) {
      window.addEventListener("scroll", () => {
        selectedThing_exports.selectClosestInView();
      });
    }
  };
  module67.afterLoad = () => {
    if (!selectedThing_exports.current || !selectedThing_exports.current.isVisible()) selectedThing_exports.selectClosestInView();
  };
  function styleLine() {
    addCSS(`
		.entry.res-selected { box-shadow: 3px 0 0 -1px #c2d2e0 !important; }
		.res-nightmode .entry.res-selected { box-shadow: 3px 0 0 -1px grey !important; }
	`);
  }
  function styleColor() {
    selectedThing_exports.addListener((current2, previous2) => {
      if (previous2) {
        previous2.entry.classList.remove("RES-keyNav-activeElement");
        previous2.element.classList.remove("RES-keyNav-activeThing");
      }
      if (current2) {
        current2.entry.classList.add("RES-keyNav-activeElement");
        current2.element.classList.add("RES-keyNav-activeThing");
      }
    }, "instantly");
    const backgroundColor = module67.options.backgroundColor.value ? `
		.entry.res-selected,
		.entry.res-selected .md-container {
			background-color: ${module67.options.backgroundColor.value} !important;
		}` : "";
    const backgroundColorNight = module67.options.backgroundColorNight.value ? `
		.res-nightmode .entry.res-selected,
		.res-nightmode .entry.res-selected .md-container {
			background-color: ${module67.options.backgroundColorNight.value} !important;
		}` : "";
    const textColorNight = module67.options.textColorNight.value ? `
		.res-nightmode .entry.res-selected > .tagline,
		.res-nightmode .entry.res-selected .md-container > .md,
		.res-nightmode .entry.res-selected .md-container > .md p {
			color: ${module67.options.textColorNight.value} !important;
		}` : "";
    addCSS(backgroundColor + backgroundColorNight + textColorNight);
  }
  function styleOutline() {
    const outlineStyle = module67.options.outlineStyle.value ? `
		.entry.res-selected {
			outline: ${module67.options.outlineStyle.value};
		}` : "";
    const outlineStyleNight = module67.options.outlineStyleNight.value ? `
		.res-nightmode .entry.res-selected {
			outline: ${module67.options.outlineStyleNight.value};
		}
	` : "";
    const style = outlineStyle + outlineStyleNight;
    if (style) {
      addCSS(style);
    }
  }

  // lib/modules/showKarma.js
  var module68 = new Module("showKarma");
  module68.moduleName = "showKarmaName";
  module68.category = "myAccountCategory";
  module68.description = "showKarmaDesc";
  module68.options = {
    showCommentKarma: {
      title: "showKarmaShowCommentKarmaTitle",
      type: "boolean",
      value: true,
      description: "showKarmaShowCommentKarmaDesc"
    },
    separator: {
      title: "showKarmaSeparatorTitle",
      type: "text",
      value: "\xB7",
      description: "showKarmaSeparatorDesc",
      advanced: true
    },
    useCommas: {
      title: "showKarmaUseCommasTitle",
      type: "boolean",
      value: true,
      description: "showKarmaUseCommasDesc"
    },
    showGold: {
      title: "showKarmaShowGoldTitle",
      type: "boolean",
      value: false,
      description: "showKarmaShowGoldDesc"
    }
  };
  module68.contentStart = async () => {
    if (!loggedInUser()) return;
    const { data: data2 } = await getUserInfo();
    updateKarmaDiv(data2);
    if (module68.options.showGold.value && data2.is_gold) {
      displayGold(data2.gold_expiration);
    }
  };
  function updateKarmaDiv(data2) {
    const karmaDiv = document.querySelector("#header-bottom-right .userkarma");
    if (!karmaDiv) return;
    karmaDiv.title = "";
    empty(karmaDiv);
    karmaDiv.append(string_exports.html`<a title="post karma" href="/user/me/submitted/">${module68.options.useCommas.value ? formatNumber(data2.link_karma) : data2.link_karma}</a>`);
    if (module68.options.showCommentKarma.value) {
      karmaDiv.append(
        module68.options.separator.value,
        string_exports.html`<a title="comment karma" href="/user/me/comments/">${module68.options.useCommas.value ? formatNumber(data2.comment_karma) : data2.comment_karma}</a>`
      );
    }
  }
  function displayGold(expires) {
    const userSpan = document.querySelector("#header-bottom-right .user");
    if (!userSpan) return;
    const today = /* @__PURE__ */ new Date();
    const expDate = new Date(expires * 1e3);
    const title = expDate > today ? `Until ${formatDate(expDate)} (${formatDateDiff(today, expDate)})` : "";
    userSpan.prepend(string_exports.html`<span title="${title}" class="gilded-icon"></span>`);
  }

  // lib/modules/sourceSnudown.js
  var import_jquery42 = __toESM(require_jquery(), 1);
  var module69 = new Module("sourceSnudown");
  module69.moduleName = "sourceSnudownName";
  module69.description = "sourceSnudownDesc";
  module69.category = "commentsCategory";
  module69.beforeLoad = () => {
    watchForThings(["post", "comment", "message"], attachViewSourceButton);
  };
  var sourceButton = /* @__PURE__ */ ((e2) => () => preventCloning(e2().cloneNode(true)))(once_default(() => {
    (0, import_jquery42.default)(document.body).on("click", "li.viewSource a", function(e2) {
      e2.preventDefault();
      viewSource(this);
    }).on("click", ".usertext-edit.viewSource .cancel", function() {
      (0, import_jquery42.default)(this).parents(".usertext-edit.viewSource").hide();
    });
    return string_exports.html`
		<li class="viewSource">
			<a class="noCtrlF" href="javascript:void 0" data-text="source"></a>
		</li>
	`;
  }));
  function attachViewSourceButton(thing) {
    if (thing.isLinkPost()) return;
    const buttons = (
      // .first is the first button after NSFW/spoiler stamps
      thing.entry.querySelector(".flat-list.buttons > li.first") || // but some pages (inbox) don't have the .first class
      thing.entry.querySelector(".flat-list.buttons > li")
    );
    if (buttons) buttons.after(sourceButton());
  }
  var viewSource = keyedMutex(async (button) => {
    const $button = (0, import_jquery42.default)(button);
    const $buttonList = $button.closest("ul");
    if ($button.data("source-open")) {
      $button.closest(".thing").find(".usertext-edit.viewSource:first").toggle();
    } else {
      const path = $buttonList.find("a.bylink, .first a").get(0).pathname;
      const response = await ajax({
        url: `${path}.json`,
        query: { raw_json: 1 },
        type: "json"
      });
      const $userTextForm = (0, import_jquery42.default)('<div class="usertext-edit viewSource"><div><textarea rows="1" cols="1" name="text" readonly></textarea></div><div class="bottom-area"><div class="usertext-buttons"><button type="button" class="cancel">hide</button></div></div></div>');
      $userTextForm.find("textarea").one("dblclick", () => $userTextForm.removeAttr("readonly"));
      let sourceText;
      if (regexes.commentPermalink.test(path)) {
        sourceText = response[1].data.children[0].data.body;
      } else if (regexes.comments.test(path)) {
        sourceText = response[0].data.children[0].data.selftext;
      } else {
        const postId = /\/(\w*)\/?$/.exec(path)[1];
        const data2 = response.data.children[0].data;
        if (data2.id === postId) {
          sourceText = data2.body;
        } else {
          sourceText = data2.replies.data.children.find(({ data: { id: id2 } }) => id2 === postId).data.body;
        }
      }
      $userTextForm.find("textarea[name=text]").text(sourceText);
      $buttonList.before($userTextForm);
      (0, import_jquery42.default)(button).data("source-open", true);
    }
  });

  // lib/modules/spamButton.js
  var module70 = new Module("spamButton");
  module70.moduleName = "spamButtonName";
  module70.category = "submissionsCategory";
  module70.disabledByDefault = true;
  module70.description = "spamButtonDesc";
  module70.beforeLoad = () => {
    watchForThings(["post", "comment"], addSpamButton);
  };
  function addSpamButton(thing) {
    const spam = document.createElement("li");
    const buttons = thing.getButtons();
    if (buttons.lastElementChild) buttons.lastElementChild.before(spam);
    else buttons.append(spam);
    const a2 = document.createElement("a");
    a2.setAttribute("class", "option noCtrlF");
    a2.setAttribute("title", "Report this user as a spammer");
    a2.href = "https://reddit.com/report";
    a2.target = "_blank";
    a2.rel = "noopener noreferer";
    a2.dataset.text = "rts";
    spam.appendChild(a2);
  }

  // lib/modules/spoilerTags.js
  var module71 = new Module("spoilerTags");
  module71.moduleName = "spoilerTagsName";
  module71.category = "appearanceCategory";
  module71.description = "spoilerTagsDesc";
  module71.include = [
    "profile"
  ];
  module71.bodyClass = true;
  module71.options = {
    transition: {
      title: "spoilerTagsTransitionTitle",
      type: "boolean",
      value: true,
      description: "spoilerTagsTransitionDesc",
      bodyClass: true
    }
  };

  // lib/modules/styleTweaks.js
  var module72 = new Module("styleTweaks");
  module72.moduleName = "styleTweaksName";
  module72.category = "appearanceCategory";
  module72.description = "styleTweaksDesc";
  module72.options = {
    navTop: {
      title: "styleTweaksNavTopTitle",
      type: "boolean",
      value: true,
      description: "styleTweaksNavTopDesc",
      bodyClass: "res-navTop"
    },
    disableAnimations: {
      title: "styleTweaksDisableAnimationsTitle",
      type: "boolean",
      value: false,
      description: "styleTweaksDisableAnimationsDesc",
      bodyClass: true
    },
    visitedStyle: {
      title: "styleTweaksVisitedStyleTitle",
      type: "boolean",
      value: false,
      description: "styleTweaksVisitedStyleDesc",
      bodyClass: true
    },
    showExpandos: {
      title: "styleTweaksShowExpandosTitle",
      type: "boolean",
      value: true,
      description: "styleTweaksShowExpandosDesc",
      advanced: true,
      bodyClass: true
    },
    hideUnvotable: {
      title: "styleTweaksHideUnvotableTitle",
      type: "boolean",
      value: true,
      description: "styleTweaksHideUnvotableDesc",
      bodyClass: true
    },
    showFullLinkFlair: {
      title: "styleTweaksShowFullLinkFlairTitle",
      type: "enum",
      values: [{
        name: "Never",
        value: "never"
      }, {
        name: "On hover",
        value: "hover"
      }, {
        name: "Always",
        value: "always"
      }],
      value: "never",
      description: "styleTweaksShowFullLinkFlairDesc",
      bodyClass: true
    },
    highlightEditedTime: {
      title: "styleTweaksHighlightEditedTimeTitle",
      type: "boolean",
      value: false,
      description: "styleTweaksHighlightEditedTimeDesc",
      bodyClass: true
    },
    colorBlindFriendly: {
      title: "styleTweaksColorBlindFriendlyTitle",
      type: "boolean",
      value: false,
      description: "styleTweaksColorBlindFriendlyDesc",
      advanced: true,
      bodyClass: "res-colorblind"
    },
    scrollSubredditDropdown: {
      title: "styleTweaksScrollSubredditDropdownTitle",
      type: "boolean",
      value: true,
      description: "styleTweaksScrollSubredditDropdownDesc",
      advanced: true,
      bodyClass: true
    },
    highlightTopLevel: {
      title: "styleTweaksHighlightTopLevelTitle",
      type: "boolean",
      value: false,
      description: "styleTweaksHighlightTopLevelDesc"
    },
    highlightTopLevelColor: {
      title: "styleTweaksHighlightTopLevelColorTitle",
      type: "color",
      dependsOn: (options6) => options6.highlightTopLevel.value,
      description: "styleTweaksHighlightTopLevelColorDesc",
      value: "#8b0000"
    },
    highlightTopLevelSize: {
      title: "styleTweaksHighlightTopLevelSizeTitle",
      type: "text",
      dependsOn: (options6) => options6.highlightTopLevel.value,
      description: "styleTweaksHighlightTopLevelSizeDesc",
      value: "2"
    },
    floatingSideBar: {
      title: "styleTweaksFloatingSideBarTitle",
      type: "boolean",
      value: false,
      description: "styleTweaksFloatingSideBarDesc",
      advanced: true,
      bodyClass: true
    },
    postTitleCapitalization: {
      title: "styleTweaksPostTitleCapitalizationTitle",
      description: "styleTweaksPostTitleCapitalizationDesc",
      type: "enum",
      value: "none",
      values: [{
        name: "do nothing",
        value: "none"
      }, {
        name: "Title Case",
        value: "title"
      }, {
        name: "Sentence case",
        value: "sentence"
      }, {
        name: "lowercase",
        value: "lowercase"
      }],
      bodyClass: true
    },
    hideDomainLink: {
      title: "styleTweaksHideDomainLink",
      type: "boolean",
      value: false,
      description: "styleTweaksHideDomainLinkDesc",
      bodyClass: true
    },
    flairEmojiAsText: {
      title: "styleTweaksFlairEmojiAsText",
      description: "styleTweaksFlairEmojiAsTextDesc",
      type: "enum",
      value: "never",
      values: [{
        name: "styleTweaksFlairEmojiAsTextNever",
        value: "never"
      }, {
        name: "styleTweaksFlairEmojiAsTextNoSubStyle",
        value: "nosubstyle"
      }, {
        name: "styleTweaksFlairEmojiAsTextAlways",
        value: "always"
      }],
      bodyClass: true
    }
  };
  module72.beforeLoad = () => {
    if (module72.options.highlightTopLevel.value) {
      const highlightTopLevelColor = module72.options.highlightTopLevelColor.value || module72.options.highlightTopLevelColor.default;
      const highlightTopLevelSize = parseInt(module72.options.highlightTopLevelSize.value || module72.options.highlightTopLevelSize.default, 10);
      addCSS(`
			.nestedlisting > .comment + .clearleft {
				height: ${highlightTopLevelSize}px !important;
				margin-bottom: 5px;
				background: ${highlightTopLevelColor} !important;
			}
			.Comment.top-level {
				border-top: ${highlightTopLevelSize}px solid ${highlightTopLevelColor};
			}
		`);
    }
  };

  // lib/modules/stylesheet.js
  var import_jquery43 = __toESM(require_jquery(), 1);
  var module73 = new Module("stylesheet");
  module73.moduleName = "stylesheetName";
  module73.description = "stylesheetDesc";
  module73.category = "appearanceCategory";
  module73.exclude = [
    "prefs",
    "account",
    "stylesheet",
    "subredditAbout"
  ];
  module73.options = {
    redditThemes: {
      title: "stylesheetRedditThemesTitle",
      description: "stylesheetRedditThemesDesc",
      type: "button",
      text: "learn more",
      callback() {
        window.location.href = "https://www.reddit.com/r/Enhancement/wiki/faq/srstyle#reddit_themes";
      }
    },
    loadStylesheets: {
      title: "stylesheetLoadStylesheetsTitle",
      type: "table",
      description: "stylesheetLoadStylesheetsDesc",
      value: [
        // loading stylesheets is expensive for reddit (#4302), so this should not have a default value
      ],
      fields: [{
        key: "urlOrSubreddit",
        name: "url or subreddit",
        type: "text"
      }, {
        key: "applyTo",
        name: "applyTo",
        type: "select",
        values: [{
          name: "Everywhere",
          value: "everywhere"
        }, {
          name: "Everywhere but:",
          value: "exclude"
        }, {
          name: "Only on:",
          value: "include"
        }],
        value: "everywhere"
      }, {
        key: "applyToSubreddits",
        name: "applyToSubreddits",
        type: "list",
        listType: "subreddits"
      }, {
        key: "customToggle",
        name: "customToggle",
        type: "select",
        get values() {
          return getToggles2();
        },
        value: ""
      }]
    },
    snippets: {
      title: "stylesheetSnippetsTitle",
      type: "table",
      description: "stylesheetSnippetsDesc",
      value: [],
      fields: [{
        key: "snippet",
        name: "snippet",
        type: "textarea"
      }, {
        key: "applyTo",
        name: "applyTo",
        type: "select",
        values: [{
          name: "Everywhere",
          value: "everywhere"
        }, {
          name: "Everywhere but:",
          value: "exclude"
        }, {
          name: "Only on:",
          value: "include"
        }],
        value: "everywhere"
      }, {
        key: "applyToSubreddits",
        name: "applyToSubreddits",
        type: "list",
        listType: "subreddits"
      }, {
        key: "customToggle",
        name: "customToggle",
        type: "select",
        get values() {
          return getToggles2();
        },
        value: ""
      }]
    },
    bodyClasses: {
      title: "stylesheetBodyClassesTitle",
      type: "table",
      description: "stylesheetBodyClassesDesc",
      value: [],
      fields: [{
        key: "classes",
        name: "classes",
        type: "text"
      }, {
        key: "applyTo",
        name: "applyTo",
        type: "select",
        values: [{
          name: "Everywhere",
          value: "everywhere"
        }, {
          name: "Everywhere but:",
          value: "exclude"
        }, {
          name: "Only on:",
          value: "include"
        }],
        value: "everywhere"
      }, {
        key: "applyToSubreddits",
        name: "applyToSubreddits",
        type: "list",
        listType: "subreddits"
      }, {
        key: "customToggle",
        name: "customToggle",
        type: "select",
        get values() {
          return getToggles2();
        },
        value: ""
      }]
    },
    subredditClass: {
      title: "stylesheetSubredditClassTitle",
      type: "boolean",
      value: true,
      description: "stylesheetSubredditClassDesc"
    },
    multiredditClass: {
      title: "stylesheetMultiredditClassTitle",
      type: "boolean",
      value: true,
      description: "stylesheetMultiredditClassDesc"
    },
    usernameClass: {
      title: "stylesheetUsernameClassTitle",
      type: "boolean",
      value: true,
      description: "stylesheetUsernameClassDesc"
    },
    loggedInUserClass: {
      title: "stylesheetLoggedInUserClassTitle",
      type: "boolean",
      value: false,
      description: "stylesheetLoggedInUserClassDesc"
    }
  };
  module73.beforeLoad = () => {
    if (module73.options.subredditClass.value) {
      applySubredditClass();
    }
    if (module73.options.usernameClass.value) {
      applyUsernameClass();
    }
    if (module73.options.multiredditClass.value) {
      applyMultiredditClass();
    }
    (0, import_jquery43.default)(module10).on("toggle", applyStyles);
    applyStyles();
    function applyStyles() {
      applyBodyClasses();
      loadStylesheets();
      applyCssSnippets();
    }
  };
  module73.contentStart = () => {
    if (module73.options.loggedInUserClass.value) {
      applyLoggedInUserClass();
    }
  };
  function applySubredditClass() {
    let name2 = currentSubreddit();
    if (name2) {
      name2 = name2.toLowerCase();
      bodyClasses_exports.add(`res-r-${name2}`);
    }
  }
  function applyMultiredditClass() {
    let name2 = currentMultireddit();
    if (name2) {
      name2 = name2.toLowerCase().replace(/\//g, "-");
      bodyClasses_exports.add(`res-${name2}`);
    }
  }
  function applyUsernameClass() {
    let name2 = currentUserProfile();
    if (name2) {
      name2 = name2.toLowerCase();
      bodyClasses_exports.add(`res-user-${name2}`);
    }
  }
  function applyLoggedInUserClass() {
    let name2 = loggedInUser();
    if (name2) {
      name2 = name2.toLowerCase();
      bodyClasses_exports.add(`res-me-${name2}`);
    }
  }
  function applyBodyClasses() {
    const addClasses = module73.options.bodyClasses.value.filter((row) => shouldApply(row[3], row[1], row[2])).map((row) => (row[0] || "").split(/[\s,]/)).reduce((a2, b2) => a2.concat(b2), []);
    const removeClasses = module73.options.bodyClasses.value.filter((row) => !shouldApply(row[3], row[1], row[2])).map((row) => (row[0] || "").split(/[\s,]/)).reduce((a2, b2) => a2.concat(b2), []);
    bodyClasses_exports.add(...addClasses);
    bodyClasses_exports.remove(...removeClasses);
  }
  var subredditNameRegexp = /^(?:\/?r\/)?([\w_]+)\/?$/;
  var urlRegexp = /^(?:https?:\/\/[\w\.]+)?\/\w+/;
  var sanitizeStylesheetUrls = filterMap(([url]) => {
    const subredditMatch = subredditNameRegexp.exec(url);
    if (subredditMatch) {
      return [`/r/${subredditMatch[1]}/stylesheet.css`];
    } else if (urlRegexp.test(url)) {
      return [url];
    }
  });
  function loadStylesheets() {
    const stylesheetUrls = sanitizeStylesheetUrls(
      module73.options.loadStylesheets.value.filter((row) => shouldApply(row[3], row[1], row[2]))
    );
    stylesheetManager.sync(stylesheetUrls);
  }
  var stylesheetManager = stylesheetElementManager((url) => string_exports.html`<link rel="stylesheet" href="${url}">`);
  function applyCssSnippets() {
    const snippets = module73.options.snippets.value.filter((row) => shouldApply(row[3], row[1], row[2])).map(([css3]) => css3);
    snippetManager.sync(snippets);
  }
  var snippetManager = stylesheetElementManager((css3) => {
    const style = document.createElement("style");
    style.textContent = css3;
    return style;
  });
  function stylesheetElementManager(generateElement) {
    const current2 = /* @__PURE__ */ new Map();
    function sync(wantedKeys) {
      const currentKeys = Array.from(current2.keys());
      difference_default(wantedKeys, currentKeys).forEach((x) => {
        const ele = generateElement(x);
        current2.set(x, ele);
        (document.head || document.documentElement).append(ele);
      });
      difference_default(currentKeys, wantedKeys).forEach((x) => {
        const ele = current2.get(x);
        current2.delete(x);
        if (ele) ele.remove();
      });
    }
    return { sync };
  }
  function shouldApply(toggle7, applyTo, applyList) {
    if (toggle7 && !toggleActive(toggle7)) return false;
    let subreddit2 = currentSubreddit();
    if (!subreddit2) {
      return applyTo !== "include";
    }
    subreddit2 = subreddit2.toLowerCase();
    applyList = typeof applyList === "string" ? applyList.toLowerCase().split(",") : [];
    switch (applyTo) {
      case "exclude":
        return !(applyList.includes(subreddit2) || applyList.includes("all"));
      case "include":
        return applyList.includes(subreddit2) || applyList.includes("all");
      default:
        return true;
    }
  }
  function getToggles2() {
    return [
      { name: "No toggle needed", value: "" },
      ...getToggles().map(({ key, text }) => ({ name: text, value: key }))
    ];
  }

  // lib/modules/submitHelper.js
  var import_jquery44 = __toESM(require_jquery(), 1);
  var module74 = new Module("submitHelper");
  module74.moduleName = "submitHelperName";
  module74.category = "submissionsCategory";
  module74.description = "submitHelperDesc";
  module74.options = {
    warnAlreadySubmitted: {
      title: "submitHelperWarnAlreadySubmittedTitle",
      type: "boolean",
      value: true,
      description: "submitHelperWarnAlreadySubmittedDesc"
    },
    uncheckSendRepliesToInbox: {
      title: "submitHelperUncheckSendRepliesToInboxTitle",
      type: "boolean",
      value: false,
      description: "submitHelperUncheckSendRepliesToInboxDesc"
    },
    focusFormOnLoad: {
      title: "submitHelperFocusFormOnLoadTitle",
      type: "boolean",
      value: true,
      description: "submitHelperFocusFormOnLoadDesc"
    }
  };
  var $repostWarning = once_default(() => (0, import_jquery44.default)(string_exports.html`
	<div class="spacer" style="display: none">
		<div class="roundfield info-notice">
			<a style="float: right" class="gearIcon" href="${makeUrlHash(module74.moduleID, "warnAlreadySubmitted")}"></a>
			<p>This link was submitted to <a class="subredditLink" href="#"></a>:<span class="time"></span><a class="seeMore" href="#" target="_blank" rel="noopener noreferer">(see more)</a></p>
		</div>
	</div>
`));
  var urlField;
  var srField;
  module74.go = () => {
    implementOptions();
    if (!isPageType("submit")) {
      registerCommandLine4();
    }
  };
  async function implementOptions() {
    if (isAppType("d2x")) {
      waitForEvent(document, "reddit.urlChanged").then(implementOptions);
    }
    if (!isPageType("submit")) {
      return;
    }
    if (module74.options.warnAlreadySubmitted.value) {
      const urlFieldDiv = document.querySelector("#url-field");
      if (urlFieldDiv) {
        (0, import_jquery44.default)(urlFieldDiv).parent().after($repostWarning());
        urlField = urlFieldDiv.querySelector("#url");
        srField = document.querySelector("#sr-autocomplete");
        (0, import_jquery44.default)([srField, urlField]).on("input keydown", debounce_default(updateRepostWarning, 300));
        (0, import_jquery44.default)("#suggested-reddits a, #sr-drop-down").on("click", updateRepostWarning);
        const linkButton = document.querySelector("a.link-button");
        const textButton = document.querySelector("a.text-button");
        if (linkButton && textButton) {
          linkButton.addEventListener("click", () => {
            updateRepostWarning();
          });
          textButton.addEventListener("click", () => {
            $repostWarning().hide();
          });
        }
      }
    }
    if (module74.options.uncheckSendRepliesToInbox.value) {
      const selector = isAppType("d2x") ? '[aria-labelledby="send-replies"]' : "#sendreplies";
      const sendReplies = await waitForDescendant(document.documentElement, selector);
      if (sendReplies) {
        sendReplies.click();
      }
    }
    if (module74.options.focusFormOnLoad.value) {
      if (isAppType("d2x")) {
        (0, import_jquery44.default)("textarea").filter(":visible").first().focus();
      } else {
        (0, import_jquery44.default)("form.submit [name=url], form.submit [name=title]").filter(":visible").first().focus();
      }
    }
  }
  function registerCommandLine4() {
    const trailingUrl = /(?:\s+(\w+:\/\/.+))$/;
    const cliParams = /^(?:(?:\/?r\/)?(\w+))?(?:\s+(.*))?$/;
    function commandLineParameters(val) {
      const urlResult = trailingUrl.exec(val);
      const result = cliParams.exec(urlResult ? val.slice(0, val.length - urlResult[0].length) : val);
      return result ? result.slice(1).concat(urlResult ? urlResult[1] : void 0) : [];
    }
    registerCommand(
      /^p(?:ost)?$/,
      "post [subreddit] [title] [url] - submit a post to a subreddit",
      (command, val) => {
        const [subreddit2, title, url] = commandLineParameters(val);
        if (!subreddit2) {
        } else if (url) {
          return `Post ${url} to /r/${subreddit2}: ${title || ""}`;
        } else if (title) {
          return `Post to /r/${subreddit2}: ${title}`;
        } else if (subreddit2) {
          return `Post to /r/${subreddit2}`;
        }
      },
      (command, val) => {
        const [subreddit2, title, url] = commandLineParameters(val);
        const redirect = subreddit2 ? string_exports.encode`/r/${subreddit2}/submit?title=${title || ""}&url=${url || ""}` : "/submit";
        window.location = redirect;
      }
    );
  }
  function showRepostWarning(sr, url, date) {
    $repostWarning().find(".subredditLink").attr("href", `/r/${sr}`).text(`/r/${sr}`).end().find(".seeMore").attr("href", string_exports.encode`/r/${sr}/search?restrict_sr=on&sort=relevance&q=url%3A${url}`).end().find(".time").text(` ${i18n("submitHelperTimeAgo", formatDateDiff(date))} `).end().fadeIn(300);
  }
  function hideRepostWarning() {
    $repostWarning().fadeOut(300);
  }
  async function updateRepostWarning() {
    if (!urlField.value) return;
    const stripUrlRe = /^(?:https?:\/\/)?(?:(?:www|i|m)\.)?(.+?)\/?(?:\.\w+)?(?:#[^\/]*)?$/i;
    const subreddit2 = srField.value;
    const match = stripUrlRe.exec(urlField.value);
    if (subreddit2 && match) {
      const [, userUrl] = match;
      try {
        const { data: data2 } = await ajax({
          url: string_exports.encode`/r/${subreddit2}/search.json`,
          query: {
            restrict_sr: "on",
            sort: "relevance",
            limit: 1,
            q: `url:${userUrl}`
          },
          type: "json"
        });
        if (data2 && data2.children.length && data2.children[0].data.url.match(stripUrlRe)[1] === userUrl) {
          showRepostWarning(subreddit2, userUrl, new Date(data2.children[0].data.created_utc * 1e3));
        } else {
          hideRepostWarning();
        }
      } catch (e2) {
        hideRepostWarning();
        throw e2;
      }
    } else {
      hideRepostWarning();
    }
  }

  // lib/modules/subredditInfo.js
  var import_jquery45 = __toESM(require_jquery(), 1);
  var module75 = new Module("subredditInfo");
  module75.moduleName = "subredditInfoName";
  module75.category = "subredditsCategory";
  module75.description = "subredditInfoDesc";
  module75.options = {
    requireDirectLink: {
      title: "subredditInfoRequireDirectLinkTitle",
      type: "boolean",
      value: true,
      description: "subredditInfoRequireDirectLinkDesc"
    },
    hoverDelay: {
      title: "subredditInfoHoverDelayTitle",
      type: "text",
      value: "800",
      description: "subredditInfoHoverDelayDesc",
      advanced: true
    },
    fadeDelay: {
      title: "subredditInfoFadeDelayTitle",
      type: "text",
      value: "200",
      description: "subredditInfoFadeDelayDesc",
      advanced: true
    },
    fadeSpeed: {
      title: "subredditInfoFadeSpeedTitle",
      type: "text",
      value: "0.7",
      description: "subredditInfoFadeSpeedDesc",
      advanced: true
    }
  };
  module75.contentStart = () => {
    const linkSelector = [
      "a.subreddit",
      "a.search-subreddit-link",
      '.md a[href^="/r/"]',
      '.Post a[href^="/r/"]:not([href*="/comments/"])',
      '.Comment a[href^="/r/"]:not([href*="/comments/"])',
      'a[data-click-id="subreddit"]',
      !module75.options.requireDirectLink.value && '.md a[href*="reddit.com/r/"]'
    ].filter((x) => x).join(", ");
    infocard(module75.moduleID).options({
      width: 450,
      openDelay: parseFloat(module75.options.hoverDelay.value),
      fadeDelay: parseFloat(module75.options.fadeDelay.value),
      fadeSpeed: parseFloat(module75.options.fadeSpeed.value)
    }).populateWith(showSubredditInfo).watch(linkSelector);
  };
  async function showSubredditInfo(card) {
    const match = regexes.subreddit.exec(card.getCheckedTarget().pathname);
    const [, subreddit2] = match || [];
    if (!subreddit2 || isFakeSubreddit(subreddit2)) return;
    const header = string_exports.html`<div><a href="/r/${subreddit2}">/r/${subreddit2}</a></div>`;
    const url = `/r/${subreddit2.toLowerCase()}/about.json`;
    let jsonData;
    try {
      jsonData = await ajax({ url, type: "json", cacheFor: HOUR });
    } catch (e2) {
      return [null, i18n("subredditInfoErrorLoadingSubredditInfo")];
    }
    if (jsonData.kind !== "t5") {
      return [null, i18n("subredditInfoSubredditNotFound")];
    }
    if (loggedInUser()) {
      const button = createElement_exports.fancyToggleButton(
        i18n("subredditInfoSubscribe"),
        "",
        () => !!jsonData.data.user_is_subscriber,
        (state) => {
          subscribeToSubreddit(jsonData.data.name, state);
          ajax.invalidate({ url });
        }
      );
      button.style.marginLeft = "12px";
      header.appendChild(button);
      if (isEnabled(subredditManager_exports)) {
        getMultiCounts(jsonData.data.display_name).then((v) => (0, import_jquery45.default)(button).after(v));
      }
    }
    const d = new Date(jsonData.data.created_utc * 1e3);
    const $newBody = (0, import_jquery45.default)(string_exports.html`
		<div class="subredditInfoToolTip">
			<div class="subredditLabel">${i18n("subredditInfoSubredditCreated")}</div> <div class="subredditDetail">${formatDate(d)} (${formatDateDiff(d)})</div>
			<div class="subredditLabel">${i18n("subredditInfoSubscribers")}</div> <div class="subredditDetail">${formatNumber(jsonData.data.subscribers)}</div>
			<div class="subredditLabel">${i18n("subredditInfoTitle")}</div> <div class="subredditDetail">${jsonData.data.title}</div>
			<div class="subredditLabel">${i18n("subredditInfoOver18")}</div> <div class="subredditDetail">${jsonData.data.over18 ? i18n("yes") : i18n("no")}</div>
			<div class="clear"></div>
			<div id="subTooltipButtons" class="bottomButtons">
				<div class="clear"></div>
			</div>
		</div>
	`);
    if (isRunning(subredditManager_exports)) {
      $newBody.find("#subTooltipButtons").append(createShortcutToggleButton(subreddit2));
    }
    if (isEnabled(dashboard_exports)) {
      $newBody.find("#subTooltipButtons").append(createSubredditToggleButton(subreddit2));
    }
    if (isEnabled(filteReddit_exports)) {
      const button = createElement_exports.fancyToggleButton(
        i18n("subredditInfoAddRemoveFilter"),
        i18n("subredditInfoFilterFromAllAndDomain"),
        () => listFilters.subreddits.includesString(subreddit2),
        (state) => listFilters.subreddits.toggleString(subreddit2, state)
      );
      $newBody.find("#subTooltipButtons").append(button);
    }
    return [header, $newBody];
  }

  // lib/modules/subredditStyleToggle.js
  var module76 = new Module("subredditStyleToggle");
  module76.moduleName = "subredditStyleToggleName";
  module76.category = "appearanceCategory";
  module76.description = "subredditStyleToggleDesc";
  module76.alwaysEnabled = true;
  module76.options = {
    browserToolbarButton: {
      title: "subredditStyleToggleBrowserToolbarButtonTitle",
      type: "boolean",
      value: true,
      description: "subredditStyleToggleBrowserToolbarButtonDesc",
      keywords: ["css"],
      // can't be disabled in Chrome since Chrome 49
      noconfig: false
    },
    checkbox: {
      title: "subredditStyleToggleCheckboxTitle",
      type: "boolean",
      value: true,
      description: "subredditStyleToggleCheckboxDesc",
      keywords: ["css"]
    }
  };
  var ignoredStorage = storage_exports.wrap("RESmodules.subredditStyleToggle.ignored", []);
  var toggle6;
  var toggleIsAvailable;
  var toggleAvailablePromise = new Promise((res) => {
    toggleIsAvailable = res;
  });
  var allowRefresh;
  module76.onInit = () => {
    pageAction_exports.hide();
    allowRefresh = Promise.all([
      shouldDisable(),
      hasToggleableElements()
    ]).then(([disable, has5]) => {
      if (has5) {
        bodyClasses_exports.add("res-srstyle-enabled");
        createToggle();
        refresh2(disable);
      }
    });
    onUpdate.push(refresh2);
  };
  module76.beforeLoad = () => {
    toggleAvailablePromise.then(makeInteractable);
  };
  async function refresh2(disable) {
    await allowRefresh;
    if (!toggle6) return;
    if (typeof disable !== "boolean") disable = await shouldDisable();
    toggle6.toggle("autoLocal", !disable);
  }
  function createToggle() {
    const subreddit2 = (currentSubreddit() || "").toLowerCase();
    if (toggle6 || !subreddit2) return;
    toggle6 = new Toggle(`${module76.moduleID}.${subreddit2}`, "Custom subreddit style", true);
    toggle6.onToggle((type) => {
      if (type !== "manual") return;
      allowRefresh = (async () => {
        await toggledSubredditStyle(toggle6.enabled);
        const ignoredSubreddits = new Set(await ignoredStorage.get());
        if (toggle6.enabled) {
          ignoredSubreddits.delete(subreddit2);
        } else if (compatibleSubredditStyle) {
          ignoredSubreddits.add(subreddit2);
        }
        await ignoredStorage.set(Array.from(ignoredSubreddits));
      })();
    });
    toggle6.onStateChange(() => {
      toggleElements(toggle6.enabled);
      bodyClasses_exports.toggle(toggle6.enabled, "res-srstyle-enabled");
      bodyClasses_exports.toggle(!toggle6.enabled, "res-srstyle-disabled");
    });
    toggleIsAvailable();
  }
  function makeInteractable() {
    if (module76.options.checkbox.value) {
      pagePhases_exports.contentStart.then(() => {
        const place = document.body.querySelector(".titlebox h1.redditname");
        if (place) insertCheckbox(place);
      });
    }
    if (module76.options.browserToolbarButton.value) {
      pageAction_exports.show(toggle6.enabled);
      toggle6.onStateChange(() => {
        pageAction_exports.show(toggle6.enabled);
      });
      pageAction_exports.onClick(() => {
        toggle6.toggle("manual");
      });
    }
    toggle6.addCLI("srstyle");
  }
  function insertCheckbox(place) {
    const container2 = string_exports.html`
		<form class="toggle res-sr-style-toggle">
			<label for="res-style-checkbox">${i18n("subredditStyleToggleUse")}</label>
		</form>
	`;
    const checkbox = toggle6.buildCheckbox();
    checkbox.setAttribute("id", "res-style-checkbox");
    checkbox.setAttribute("name", "res-style-checkbox");
    container2.prepend(checkbox);
    place.after(container2);
  }
  var shouldDisable = () => asyncSome([
    // subreddit style ignored by this module
    async () => (await ignoredStorage.get()).includes((currentSubreddit() || "").toLowerCase()),
    // subreddit style incompatible with nightmode
    async () => !await compatibleSubredditStyle
  ], (f2) => f2());
  var hasToggleableElements = () => asyncSome([
    getStylesheet,
    async () => !!(await getHeaderImg()).headerImg
  ], (f2) => f2());
  var getStylesheet = once_default(async () => {
    const query = () => (document.head || document.documentElement).querySelector("link[title=applied_subreddit_stylesheet]");
    return (
      // parsing has started
      // the stylesheet element may or may not be in the DOM
      query() || // <body> parsing has started (i.e. the entire <head> is parsed)
      // if there is a stylesheet, the element will be in the DOM
      await pagePhases_exports.bodyStart.then(query) || // subreddit styles disabled natively; no stylesheet element
      null
    );
  });
  var getHeaderImg = once_default(async () => {
    const imgWrapper = await pagePhases_exports.bodyStart.then(() => document.getElementById("header-img-a")) || await waitForChild(document.body, "#header").then((e2) => waitForDescendant(e2, "#header-img-a"));
    return { imgWrapper, headerImg: imgWrapper && document.getElementById("header-img") };
  });
  var toggleElements = (() => {
    const toggleStylesheet = mutex(async (shouldRestore) => {
      const subredditStylesheet = await getStylesheet();
      if (!subredditStylesheet) return;
      if (shouldRestore) {
        if (!subredditStylesheet.parentNode) {
          document.head.appendChild(subredditStylesheet);
        }
      } else {
        if (subredditStylesheet.parentNode) {
          subredditStylesheet.remove();
        }
      }
    });
    const toggleHeaderImg = mutex(async (shouldRestore) => {
      const { imgWrapper, headerImg } = await getHeaderImg();
      if (!imgWrapper || !headerImg) return;
      if (shouldRestore) {
        if (!headerImg.parentNode) {
          imgWrapper.id = "header-img-a";
          imgWrapper.classList.remove("default-header");
          imgWrapper.appendChild(headerImg);
        }
      } else {
        if (headerImg.parentNode) {
          headerImg.remove();
          imgWrapper.id = "header-img";
          imgWrapper.classList.add("default-header");
        }
      }
    });
    return (shouldRestore) => Promise.all([
      toggleStylesheet(shouldRestore),
      toggleHeaderImg(shouldRestore)
    ]);
  })();

  // lib/modules/subredditTagger.js
  var import_jquery46 = __toESM(require_jquery(), 1);
  var module77 = new Module("subRedditTagger");
  module77.moduleName = "subredditTaggerName";
  module77.category = "subredditsCategory";
  module77.description = "subredditTaggerDesc";
  module77.options = {
    subReddits: {
      title: "subRedditTaggerSubRedditsTitle",
      type: "table",
      addRowText: "+add tag",
      fields: [{
        key: "subreddit",
        name: "subreddit",
        type: "text"
      }, {
        key: "doesntContain",
        name: "doesntContain",
        type: "text"
      }, {
        key: "tag",
        name: "tag",
        type: "text"
      }],
      value: [],
      description: "subRedditTaggerSubRedditsDesc"
    }
  };
  var SRTDoesntContain = /* @__PURE__ */ new Map();
  var SRTTagWith = /* @__PURE__ */ new Map();
  module77.beforeLoad = () => {
    if (!module77.options.subReddits.value.length) return;
    for (const [subreddit2, doesntContain, tagWith] of module77.options.subReddits.value) {
      SRTDoesntContain.set(subreddit2.toLowerCase(), doesntContain);
      SRTTagWith.set(subreddit2.toLowerCase(), tagWith);
    }
    watchForThings(["post"], scanTitle);
  };
  function scanTitle(thing) {
    const tagToAdd = getTag2(thing);
    if (tagToAdd !== void 0) {
      const tagText = (0, import_jquery46.default)("<span>").append(escapeHTML(tagToAdd)).append("&nbsp;");
      (0, import_jquery46.default)(thing.getTitleElement()).parent().prepend(tagText);
    }
  }
  function getTag2(thing) {
    let hasTag = false;
    const thisSubReddit = (thing.getSubreddit() || "").toLowerCase();
    if (thisSubReddit && SRTTagWith.has(thisSubReddit)) {
      let thisString = SRTDoesntContain.get(thisSubReddit);
      if (thisString === void 0 || thisString === "") {
        thisString = `[${thisSubReddit}]`;
        SRTDoesntContain.set(thisSubReddit, thisString);
      }
      hasTag = thing.getTitle().includes(thisString) || thing.getPostFlairText().includes(thisString);
    }
    if (!hasTag) {
      return SRTTagWith.get(thisSubReddit);
    }
  }

  // lib/modules/tableTools.js
  var import_jquery47 = __toESM(require_jquery(), 1);
  var module78 = new Module("tableTools");
  module78.moduleName = "tableToolsName";
  module78.category = "productivityCategory";
  module78.description = "tableToolsDesc";
  module78.options = {
    sort: {
      title: "tableToolsSortTitle",
      type: "boolean",
      value: true,
      description: "tableToolsSortDesc",
      bodyClass: true
    }
  };
  module78.contentStart = () => {
    if (module78.options.sort.value) {
      (0, import_jquery47.default)(document.body).on("click", ".md th, .Comment th, .Post th", table_exports.sortByColumn);
    }
  };

  // lib/modules/temporaryDropdownLinks.js
  var module79 = new Module("temporaryDropdownLinks");
  module79.moduleName = "temporaryDropdownLinksName";
  module79.category = "browsingCategory";
  module79.description = "temporaryDropdownLinksDesc";
  module79.options = {
    always: {
      type: "boolean",
      value: false,
      description: "temporaryDropdownLinksAlwaysDesc",
      title: "temporaryDropdownLinksAlwaysTitle"
    }
  };
  module79.include = [
    /\/(?:top|controversial)\/$/
  ];
  module79.contentStart = () => {
    setupMenu();
  };
  function setupMenu() {
    const mutateChoice = module79.options.always.value ? removeListener : appendTemporaryButton;
    for (const choice of document.querySelectorAll(".menuarea .drop-choices a.choice")) {
      const form = choice.closest("form");
      if (!form) continue;
      const { name: name2, value } = downcast(form.querySelector("input"), HTMLInputElement);
      if (name2 && value) {
        mutateChoice(choice, name2, value);
      }
    }
  }
  function removeListener(choice, name2, value) {
    choice.search = `?${name2}=${value}`;
    choice.removeAttribute("onclick");
  }
  function appendTemporaryButton(choice, name2, value) {
    const url = new URL(choice.href);
    url.searchParams.set(name2, value);
    const link = string_exports.html`
		<a class="RES-dropdown-button" href="${url.href}">${i18n("temporaryDropdownLinksTemporarily")}</a>
	`;
    link.addEventListener("click", (e2) => e2.stopPropagation());
    choice.appendChild(link);
  }

  // lib/modules/userbarHider.js
  var import_jquery48 = __toESM(require_jquery(), 1);
  var module80 = new Module("userbarHider");
  module80.moduleName = "userbarHiderName";
  module80.description = "userbarHiderDesc";
  module80.category = "myAccountCategory";
  module80.disabledByDefault = true;
  module80.options = {
    userbarState: {
      title: "userbarHiderUserbarStateTitle",
      type: "enum",
      values: [{
        name: "Visible",
        value: "visible"
      }, {
        name: "Hidden",
        value: "hidden"
      }],
      value: "visible",
      description: "userbarHiderUserbarStateDesc"
    },
    toggleButtonState: {
      title: "userbarHiderToggleButtonStateTitle",
      type: "enum",
      values: [{
        name: "Visible",
        value: "visible"
      }, {
        name: "Hidden",
        value: "hidden"
      }],
      value: "visible",
      description: "userbarHiderToggleButtonStateDesc",
      advanced: true
    }
  };
  var userbar;
  var $userbarToggle;
  module80.contentStart = () => {
    userbarHider();
  };
  function userbarHider() {
    userbar = document.getElementById("header-bottom-right");
    if (userbar) {
      if (module80.options.toggleButtonState.value === "visible" || module80.options.userbarState.value === "hidden") {
        addToggleButton();
      }
      if (module80.options.userbarState.value === "hidden") {
        updateUserBar();
        showNotification({
          moduleID: module80.moduleID,
          optionKey: "userbarState",
          cooldown: 24 * 60 * 60 * 1e3,
          header: i18n("userbarHiderUserBarHidden"),
          message: i18n("userbarHiderContentHiddenNotification", "\xAB")
        });
      }
    }
  }
  function toggleUserBar() {
    module80.options.userbarState.value = module80.options.userbarState.value === "hidden" ? "visible" : "hidden";
    save2(module80.options.userbarState);
    updateUserBar();
  }
  function updateUserBar() {
    const userbarHidden = module80.options.userbarState.value === "hidden";
    updateToggleButton(userbarHidden);
    toggleUserbarElementsDisplay(userbarHidden);
  }
  function addToggleButton() {
    $userbarToggle = (0, import_jquery48.default)("<div>", {
      id: "userbarToggle",
      title: i18n("userbarHiderToggleUserbar"),
      click: () => toggleUserBar()
    }).prependTo(userbar);
    document.querySelector("#header-bottom-right").classList.add("res-userbar-toggle");
    updateToggleButton(false);
  }
  function updateToggleButton(userbarHidden) {
    $userbarToggle.toggleClass("userbarHide", !userbarHidden).toggleClass("userbarShow", userbarHidden).html(userbarHidden ? "&laquo;" : "&raquo;");
  }
  function toggleUserbarElementsDisplay(userbarHidden) {
    bodyClasses_exports.toggle(userbarHidden, "res-hide-userbar");
  }

  // lib/modules/version.js
  var import_jquery49 = __toESM(require_jquery(), 1);
  var module81 = new Module("version");
  module81.moduleName = "versionName";
  module81.category = "aboutCategory";
  module81.description = "versionDesc";
  module81.alwaysEnabled = true;
  module81.hidden = true;
  var concurrentInstallWiki = "/r/Enhancement/wiki/tutorials/concurrent_installs";
  module81.beforeLoad = () => {
    addVersionClasses();
  };
  module81.go = () => {
    reportVersion();
  };
  module81.afterLoad = () => {
    avoidConcurrentInstalls();
  };
  function addVersionClasses() {
    bodyClasses_exports.add("res");
    const versionComponents = version3.split(".");
    for (const i2 of range(0, versionComponents.length)) {
      bodyClasses_exports.add(`res-v${versionComponents.slice(0, i2 + 1).join("-")}`);
    }
  }
  function reportVersion() {
    (0, import_jquery49.default)("<div>", {
      id: "RESConsoleVersion",
      style: "display: none;",
      text: version3,
      "data-id": getExtensionId()
    }).appendTo(document.body);
  }
  function avoidConcurrentInstalls() {
    const installs = Array.from(document.querySelectorAll("#RESConsoleVersion"));
    const concurrentInstalls = uniqBy_default(installs, (e2) => e2.getAttribute("data-id") || Math.random()).map((e2) => e2.textContent);
    if (concurrentInstalls.length > 1) {
      bodyClasses_exports.add("res-concurrent-installs");
      document.body.appendChild(string_exports.html`
			<div id="res-concurrent-installs">
				<p>You have enabled multiple versions of Reddit Enhancement Suite:</p>
				<ul>
					${concurrentInstalls.map((v) => string_exports._html`
						<li>${v}</li>
					`)}
				</ul>
				<p>You should enable only one. <a href="${concurrentInstallWiki}">Find out how!</a>
			</div>
		`);
    }
  }

  // lib/modules/voteEnhancements.js
  var module82 = new Module("voteEnhancements");
  module82.moduleName = "voteEnhancementsName";
  module82.category = "appearanceCategory";
  module82.description = "voteEnhancementsDesc";
  module82.options = {
    highlightScores: {
      title: "voteEnhancementsHighlightScoresTitle",
      type: "boolean",
      value: true,
      description: "voteEnhancementsHighlightScoresDesc",
      bodyClass: true
    },
    colorLinkScore: {
      title: "voteEnhancementsColorLinkScoreTitle",
      type: "enum",
      values: [{
        name: "No coloration",
        value: "none"
      }, {
        name: "Automatic coloration",
        value: "automatic"
      }, {
        name: "User-defined coloration",
        value: "user"
      }],
      value: "none",
      description: "voteEnhancementsColorLinkScoreDesc",
      bodyClass: true
    },
    userDefinedLinkColoration: {
      title: "voteEnhancementsUserDefinedLinkColorationTitle",
      dependsOn: (options6) => options6.colorLinkScore.value === "user",
      type: "table",
      addRowText: "+add threshold",
      fields: [{
        key: "score",
        name: "score",
        type: "text"
      }, {
        key: "color",
        name: "color",
        type: "color"
      }],
      value: [
        [0, "#5f99cf"],
        [10, "#f2b035"],
        [50, "#ff4500"],
        [100, "#d92b2b"]
      ],
      description: "voteEnhancementsUserDefinedLinkColorationDesc",
      sort([a2], [b2]) {
        return a2 - b2 || String(a2).localeCompare(b2, void 0, { numeric: true });
      }
    },
    colorCommentScore: {
      title: "voteEnhancementsColorCommentScoreTitle",
      type: "enum",
      values: [{
        name: "No coloration",
        value: "none"
      }, {
        name: "Automatic coloration",
        value: "automatic"
      }, {
        name: "Reddit Classic",
        value: "simple"
      }, {
        name: "User-defined coloration",
        value: "user"
      }],
      value: "none",
      description: "voteEnhancementsColorCommentScoreDesc"
    },
    userDefinedCommentColoration: {
      title: "voteEnhancementsUserDefinedCommentColorationTitle",
      dependsOn: (options6) => options6.colorCommentScore.value === "user",
      type: "table",
      addRowText: "+add threshold",
      fields: [{
        key: "score",
        name: "score",
        type: "text"
      }, {
        key: "color",
        name: "color",
        type: "color"
      }],
      value: [
        [0, "#5f99cf"],
        [10, "#f2b035"],
        [50, "#ff4500"],
        [100, "#d92b2b"]
      ],
      description: "voteEnhancementsUserDefinedCommentColorationDesc",
      sort([a2], [b2]) {
        return a2 - b2 || String(a2).localeCompare(b2, void 0, { numeric: true });
      }
    },
    interpolateScoreColor: {
      title: "voteEnhancementsInterpolateScoreColorTitle",
      type: "boolean",
      value: true,
      description: "voteEnhancementsInterpolateScoreColorDesc",
      advanced: true
    },
    highlightControversial: {
      title: "voteEnhancementsHighlightControversialTitle",
      type: "boolean",
      value: true,
      description: "voteEnhancementsHighlightControversialDesc"
    },
    highlightControversialColor: {
      title: "voteEnhancementsHighlightControversialColorTitle",
      dependsOn: (options6) => options6.highlightControversial.value,
      advanced: true,
      type: "color",
      value: "#cc0000",
      description: "voteEnhancementsHighlightControversialColorDesc"
    }
  };
  module82.include = ["comments", "commentsLinklist", "linklist", "modqueue", "profile", "inbox"];
  module82.beforeLoad = () => {
    if (module82.options.colorLinkScore.value !== "none") {
      watchForThings(["post"], applyLinkScoreColor);
    }
    if (module82.options.colorCommentScore.value !== "none") {
      watchForThings(["comment"], applyCommentScoreColor);
    }
    if (module82.options.highlightControversial.value) {
      highlightControversial();
    }
  };
  function interpolateScoreColor(score, colors, defaultColor) {
    if (!colors.length) return defaultColor;
    const augmented = [
      [-Infinity, colors[0][1]],
      ...colors,
      [Infinity, colors.slice(-1)[0][1]]
    ];
    for (const [[lowBound, lowColor], [highBound, highColor]] of zip2(augmented.slice(0, -1), augmented.slice(1))) {
      if (score >= lowBound && score < highBound) {
        if (module82.options.interpolateScoreColor.value) {
          return colorFromArray(
            zipWith_default(
              colorToArray(lowColor),
              colorToArray(highColor),
              (lowVal, highVal) => Math.round(projectInto(lowBound, highBound, lowVal, highVal, score))
            )
          );
        } else {
          return score < 0 ? highColor : lowColor;
        }
      }
    }
    return defaultColor;
  }
  function getLinkScoreColor(score) {
    if (module82.options.colorLinkScore.value === "automatic") {
      return `hsl(${180 + 360 * (1 - 100 / (150 + score))}, 75%,50%)`;
    } else {
      return interpolateScoreColor(score, module82.options.userDefinedLinkColoration.value, "#c6c6c6");
    }
  }
  function getCommentScoreColor(score) {
    if (module82.options.colorCommentScore.value === "automatic") {
      return `hsl(${180 + 360 * (1 - 50 / (100 + score))}, 75%,50%)`;
    } else {
      let colors;
      if (module82.options.colorCommentScore.value === "user") {
        colors = module82.options.userDefinedCommentColoration.value;
      } else if (module82.options.colorCommentScore.value === "simple") {
        colors = [
          [0, "#9494ff"],
          [1, "#888"],
          [2, "#ff8b60"]
        ];
      } else {
        return false;
      }
      return interpolateScoreColor(score, colors, "#888");
    }
  }
  function applyLinkScoreColor(thing) {
    const score = thing.getScore();
    const rankEle = thing.getRankElement();
    const color = typeof score === "number" && getLinkScoreColor(score);
    if (rankEle && color) {
      rankEle.style.background = color;
    }
  }
  function applyCommentScoreColor(thing) {
    for (const [scoreEle, score] of thing.getAllScoreElements()) {
      const color = getCommentScoreColor(score);
      if (color) {
        scoreEle.style.color = color;
      }
    }
  }
  function highlightControversial() {
    const color = module82.options.highlightControversialColor.value || module82.options.highlightControversialColor.default;
    addCSS(`
		.comment.controversial > .entry .score::after {
			color: ${color};
		}
	`);
  }

  // lib/modules/xPostLinks.js
  var import_jquery50 = __toESM(require_jquery(), 1);
  var module83 = new Module("xPostLinks");
  module83.moduleName = "xPostLinksName";
  module83.category = "submissionsCategory";
  module83.description = "xPostLinksDesc";
  module83.include = [
    "linklist",
    "modqueue",
    "comments",
    "profile",
    "search"
  ];
  module83.exclude = [
    "d2x"
  ];
  module83.beforeLoad = () => {
    watchForThings(["post"], createLinks);
  };
  var xpostRe = /(?:x|cross)[\s-]?post\S*(.+)/i;
  var xpostFromRe = /^(?:\s+\S+)?\s+\/?(\w{2,20}\b)(?:[\)\]}]|\S*$)/i;
  var subredditRe = /r\/(\w{2,20}\b)/i;
  function parseSubreddit(title) {
    const [, xpostString] = xpostRe.exec(title) || [];
    if (!xpostString) return false;
    const [, sub] = subredditRe.exec(xpostString) || // found something like r/games
    xpostFromRe.exec(xpostString) || // use the last of one or two words before end of string of closing bracket
    [];
    return sub;
  }
  function appendToTagline(sub, thing) {
    (0, import_jquery50.default)().add((0, import_jquery50.default)(thing.getSubredditLink()).prev()).add(thing.getUserattrsElement() || "").first().after(
      string_exports.escape` ${i18n("xPostLinksXpostedFrom")} `,
      (0, import_jquery50.default)("<a>", {
        class: "subreddit hover",
        href: `/r/${sub}`,
        text: `/r/${sub}`
      })
    );
  }
  function createLinks(thing) {
    const sub = parseSubreddit(thing.getTitle());
    if (sub) appendToTagline(sub, thing);
  }

  // lib/core/modules/storage.js
  var storage2 = wrapBlob(
    "RES.modulePrefs",
    () => {
      throw new Error("Default module enabled state should never be accessed");
    }
  );
  function setEnabled(moduleId, enable) {
    return storage2.set(moduleId, enable);
  }

  // lib/core/modules/modules.js
  var enabled = /* @__PURE__ */ new Map();
  var modules = new Map(
    Object.values(modules_exports2).map((module84) => [module84.moduleID, downcast(module84, Module)])
    // ensure that all modules are instances of `Module`
  );
  if (false) {
    window.modules = modules;
  }
  var allowedModules = [];
  async function _loadModulePrefs() {
    const storedPrefs = await storage2.getAll();
    for (const [id2, module84] of modules) {
      if (module84.alwaysEnabled) {
        enabled.set(id2, true);
      } else if (storedPrefs.hasOwnProperty(id2)) {
        enabled.set(id2, storedPrefs[id2]);
      } else {
        enabled.set(id2, !module84.disabledByDefault);
      }
    }
  }
  var ERRORED_KEY = Symbol("errored");
  async function _runModuleStage(stage, { skipEnabledCheck = false } = {}) {
    await Promise.all(
      all().filter((module84) => module84[stage] && !module84[ERRORED_KEY] && (skipEnabledCheck || isRunning(module84))).map(async (module84) => {
        const tag = markStart();
        try {
          const fn = module84[stage];
          await fn();
        } catch (e2) {
          module84[ERRORED_KEY] = true;
          console.error("Error in module:", module84.moduleID, "during:", stage);
          console.error(e2);
        }
        markEnd(tag, `${module84.moduleID} (${stage})`);
      })
    );
  }
  function all() {
    return Array.from(modules.values());
  }
  function isEnabled(opaqueId) {
    return !!enabled.get(get4(opaqueId).moduleID);
  }
  function isRunning(opaqueId) {
    const module84 = get4(opaqueId);
    return (!allowedModules.length || allowedModules.includes(module84.moduleID)) && isEnabled(module84) && matchesPageLocation(module84.include, module84.exclude) && module84.shouldRun();
  }
  function get4(opaqueId) {
    return _get2(getModuleId(opaqueId));
  }
  function _get2(id2) {
    const mod = getUnchecked(id2);
    if (!mod) throw new Error(`Module "${id2}" not found.`);
    return mod;
  }
  function getUnchecked(id2) {
    return modules.get(id2);
  }

  // lib/core/options/options.js
  function _loadModuleOptions() {
    const shouldPrunePromise = shouldPrune("RESoptions");
    return Promise.all(all().map(async (module84) => {
      if (!Object.values(module84.options).some((v) => v.hasOwnProperty("value"))) return;
      const storedOptions = await storage.get(module84.moduleID);
      for (const opt of Object.values(module84.options)) {
        opt.default = opt.value;
      }
      if (!storedOptions) {
        return;
      }
      for (const [key, storedValue] of Object.entries(storedOptions)) {
        if (!storedValue) continue;
        if (storedValue.value === void 0) {
          console.error(`Option ${module84.moduleID} ${key}'s value is \`undefined\`. Ignoring.`);
          continue;
        }
        if (!module84.options[key]) continue;
        module84.options[key].value = storedValue.value;
      }
      shouldPrunePromise.then((should) => {
        if (should) prune(module84, storedOptions);
      });
    }));
  }
  function prune(module84, storedOptions) {
    if (!storedOptions || !Object.entries(storedOptions).length) {
      storage.delete(module84.moduleID);
      return;
    }
    for (const [key, { value }] of Object.entries(storedOptions)) {
      const option2 = module84.options[key];
      if (!module84.options[key]) {
        console.warn("Could not find option", module84.moduleID, key);
        storage.deletePath(module84.moduleID, key);
        continue;
      }
      if (isEqual_default(option2.default, value)) {
        console.warn("Stored option", module84.moduleID, key, "has the default value. Deleting.");
        storage.deletePath(module84.moduleID, key);
        continue;
      }
    }
  }
  var modifiedOptions = /* @__PURE__ */ new Set();
  var notifyModified = multicast(
    batch((keys3) => {
      for (const key of keys3) modifiedOptions.add(key);
    }, { size: Infinity }),
    { name: "modifiedOptions", local: false }
  );
  function save2(option2) {
    for (const module84 of all()) {
      for (const [key, _option] of Object.entries(module84.options)) {
        if (option2 === _option) {
          if (option2.value === void 0) {
            throw new Error("Option type can not be saved");
          }
          if (option2.type === "list" || option2.type === "builder" || option2.type === "table") {
            const id2 = `${module84.moduleID}-${key}`;
            if (modifiedOptions.has(id2)) {
              console.warn("Overwriting option", module84.moduleID, key, "saved in another tab");
            }
            notifyModified(id2);
          }
          if (option2.onChange) {
            option2.onChange();
          }
          return set5(module84.moduleID, key, option2.value);
        }
      }
    }
    throw new Error("Option not found in module");
  }

  // lib/core/modules/bodyClasses.js
  function _addModuleBodyClasses() {
    for (const module84 of all()) {
      if (!isRunning(module84)) continue;
      if (module84.bodyClass) bodyClasses_exports.add(`res-${module84.moduleID}`);
      for (const [optId, opt] of Object.entries(module84.options)) {
        if (!(opt.bodyClass && opt.value)) continue;
        opt;
        if (opt.dependsOn && !opt.dependsOn(module84.options)) continue;
        let cls = typeof opt.bodyClass === "string" ? opt.bodyClass : `res-${module84.moduleID}-${optId}`;
        if (opt.type === "enum") {
          cls += `-${opt.value.replace(/\s/g, "_")}`;
        }
        bodyClasses_exports.add(cls);
      }
    }
  }

  // lib/core/init.js
  var _init;
  function init() {
    _init();
  }
  var start = new Promise((resolve) => {
    _init = resolve;
  });
  var loadI18n = start.then(() => _loadI18n());
  var onInit = start.then(() => _runModuleStage("onInit", { skipEnabledCheck: true }));
  var loadOptions = onInit.then(() => Promise.all([
    _loadModuleOptions(),
    _loadModulePrefs()
  ]));
  var addModuleBodyClasses = loadOptions.then(() => _addModuleBodyClasses());
  var always2 = Promise.all([loadI18n, loadOptions]).then(() => _runModuleStage("always", { skipEnabledCheck: true }));
  var beforeLoad = Promise.all([loadI18n, loadOptions]).then(() => _runModuleStage("beforeLoad"));
  var contentStart2 = Promise.all([beforeLoad, pagePhases_exports.contentStart]).then(() => Promise.all([
    _runModuleStage("contentStart"),
    isAppType("r2") ? r2WatcherContentStart() : void 0
  ]));
  var go = Promise.all([beforeLoad, pagePhases_exports.contentStart]).then(() => {
    const run = once_default(() => Promise.all([
      isAppType("d2x") ? initD2xWatcher() : r2WatcherContentLoaded(),
      _runModuleStage("go")
    ]));
    window.addEventListener("DOMContentLoaded", run, true);
    return pagePhases_exports.contentLoaded.then(run);
  });
  var afterLoad = Promise.all([go, pagePhases_exports.loadComplete]).then(() => _runModuleStage("afterLoad"));
  Promise.all([onInit, pagePhases_exports.bodyStart]).then(bodyClasses_exports.addMissing);

  // lib/foreground.entry.js
  var blockers = [];
  if (location.hash === RES_DISABLED_HASH) {
    blockers.push(`Hash ${RES_DISABLED_HASH} disables RES.`);
  } else {
    window.addEventListener("hashchange", () => {
      if (location.hash === RES_DISABLED_HASH) location.reload();
    });
  }
  if (location.hash.startsWith(RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH)) {
    location.href = getURL(`options.html${location.hash.replace(RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH, RES_SETTINGS_HASH)}`);
    blockers.push("Redirecting to the options page.");
  }
  if (document.documentElement && document.documentElement.classList.contains("res")) {
    document.documentElement.setAttribute("res-warning", "This page must be reloaded for Reddit Enhancement Suite to function correctly");
    blockers.push("RES is previously loaded on this page.");
  }
  if (window !== window.parent && new URL(location.href).searchParams.get("embedded") !== "true") {
    blockers.push("Conditions for running on an embedded page are not met.");
  }
  if (blockers.length) {
    console.warn("Preventing initalization of RES:", blockers);
  } else {
    init();
  }
})();
/*! Bundled license information:

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

dompurify/dist/purify.js:
  (*! @license DOMPurify 3.1.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.6/LICENSE *)

favico.js/favico.js:
  (**
   * @license MIT
   * @fileOverview Favico animations
   * @author Miroslav Magda, http://blog.ejci.net
   * @version 0.3.10
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

sortablejs/modular/sortable.core.esm.js:
  (**!
   * Sortable 1.15.3
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=foreground.entry.js.map
