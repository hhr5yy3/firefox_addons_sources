var license=function(){"use strict";var be=Object.defineProperty;var _e=(T,b,k)=>b in T?be(T,b,{enumerable:!0,configurable:!0,writable:!0,value:k}):T[b]=k;var A=(T,b,k)=>_e(T,typeof b!="symbol"?b+"":b,k);var B,J,Z,ee;function T(a){return a}const b=((J=(B=globalThis.browser)==null?void 0:B.runtime)==null?void 0:J.id)==null?globalThis.chrome:globalThis.browser,k="https://uw.wtf",G=["normal","upscale","stretch"];G.map(a=>({value:a,label:b.i18n.getMessage(`mode_${a}`),disabled:!1}));const x={activity:!0,mode:G[1],scaleX:1,scaleY:1,helpers:[],booster:!1};var Q=Object.prototype.hasOwnProperty;function R(a,e){var t,r;if(a===e)return!0;if(a&&e&&(t=a.constructor)===e.constructor){if(t===Date)return a.getTime()===e.getTime();if(t===RegExp)return a.toString()===e.toString();if(t===Array){if((r=a.length)===e.length)for(;r--&&R(a[r],e[r]););return r===-1}if(!t||typeof a=="object"){r=0;for(t in a)if(Q.call(a,t)&&++r&&!Q.call(e,t)||!(t in e)||!R(a[t],e[t]))return!1;return Object.keys(e).length===r}}return a!==a&&e!==e}const se=new Error("request for lock canceled");var ie=function(a,e,t,r){function l(u){return u instanceof t?u:new t(function(h){h(u)})}return new(t||(t=Promise))(function(u,h){function v(y){try{_(r.next(y))}catch(I){h(I)}}function V(y){try{_(r.throw(y))}catch(I){h(I)}}function _(y){y.done?u(y.value):l(y.value).then(v,V)}_((r=r.apply(a,e||[])).next())})};class ae{constructor(e,t=se){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((r,l)=>{const u={resolve:r,reject:l,weight:e,priority:t},h=X(this._queue,v=>t<=v.priority);h===-1&&e<=this._value?this._dispatchItem(u):this._queue.splice(h+1,0,u)})}runExclusive(e){return ie(this,arguments,void 0,function*(t,r=1,l=0){const[u,h]=yield this.acquire(r,l);try{return yield t(u)}finally{h()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(r=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),oe(this._weightedWaiters[e-1],{resolve:r,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(r=>r.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const r=this._weightedWaiters[t-1];if(!r)continue;const l=r.findIndex(u=>u.priority<=e);(l===-1?r:r.splice(0,l)).forEach(u=>u.resolve())}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function oe(a,e){const t=X(a,r=>e.priority<=r.priority);a.splice(t+1,0,e)}function X(a,e){for(let t=a.length-1;t>=0;t--)if(e(a[t]))return t;return-1}var ce=function(a,e,t,r){function l(u){return u instanceof t?u:new t(function(h){h(u)})}return new(t||(t=Promise))(function(u,h){function v(y){try{_(r.next(y))}catch(I){h(I)}}function V(y){try{_(r.throw(y))}catch(I){h(I)}}function _(y){y.done?u(y.value):l(y.value).then(v,V)}_((r=r.apply(a,e||[])).next())})};class le{constructor(e){this._semaphore=new ae(1,e)}acquire(){return ce(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const L=((ee=(Z=globalThis.browser)==null?void 0:Z.runtime)==null?void 0:ee.id)==null?globalThis.chrome:globalThis.browser,K=ue();function ue(){const a={local:O("local"),session:O("session"),sync:O("sync"),managed:O("managed")},e=o=>{const s=a[o];if(s==null){const n=Object.keys(a).join(", ");throw Error(`Invalid area "${o}". Options: ${n}`)}return s},t=o=>{const s=o.indexOf(":"),n=o.substring(0,s),i=o.substring(s+1);if(i==null)throw Error(`Storage key should be in the form of "area:key", but received "${o}"`);return{driverArea:n,driverKey:i,driver:e(n)}},r=o=>o+"$",l=(o,s)=>{const n={...o};return Object.entries(s).forEach(([i,c])=>{c==null?delete n[i]:n[i]=c}),n},u=(o,s)=>o??s??null,h=o=>typeof o=="object"&&!Array.isArray(o)?o:{},v=async(o,s,n)=>{const i=await o.getItem(s);return u(i,(n==null?void 0:n.fallback)??(n==null?void 0:n.defaultValue))},V=async(o,s)=>{const n=r(s),i=await o.getItem(n);return h(i)},_=async(o,s,n)=>{await o.setItem(s,n??null)},y=async(o,s,n)=>{const i=r(s),c=h(await o.getItem(i));await o.setItem(i,l(c,n))},I=async(o,s,n)=>{if(await o.removeItem(s),n!=null&&n.removeMeta){const i=r(s);await o.removeItem(i)}},te=async(o,s,n)=>{const i=r(s);if(n==null)await o.removeItem(i);else{const c=h(await o.getItem(i));[n].flat().forEach(d=>delete c[d]),await o.setItem(i,c)}},re=(o,s,n)=>o.watch(s,n);return{getItem:async(o,s)=>{const{driver:n,driverKey:i}=t(o);return await v(n,i,s)},getItems:async o=>{const s=new Map,n=new Map,i=[];o.forEach(d=>{let f,m;typeof d=="string"?f=d:"getValue"in d?(f=d.key,m={fallback:d.fallback}):(f=d.key,m=d.options),i.push(f);const{driverArea:E,driverKey:g}=t(f),p=s.get(E)??[];s.set(E,p.concat(g)),n.set(f,m)});const c=new Map;return await Promise.all(Array.from(s.entries()).map(async([d,f])=>{(await a[d].getItems(f)).forEach(E=>{const g=`${d}:${E.key}`,p=n.get(g),w=u(E.value,(p==null?void 0:p.fallback)??(p==null?void 0:p.defaultValue));c.set(g,w)})})),i.map(d=>({key:d,value:c.get(d)}))},getMeta:async o=>{const{driver:s,driverKey:n}=t(o);return await V(s,n)},getMetas:async o=>{const s=o.map(c=>{const d=typeof c=="string"?c:c.key,{driverArea:f,driverKey:m}=t(d);return{key:d,driverArea:f,driverKey:m,driverMetaKey:r(m)}}),n=s.reduce((c,d)=>{var f;return c[f=d.driverArea]??(c[f]=[]),c[d.driverArea].push(d),c},{}),i={};return await Promise.all(Object.entries(n).map(async([c,d])=>{const f=await L.storage[c].get(d.map(m=>m.driverMetaKey));d.forEach(m=>{i[m.key]=f[m.driverMetaKey]??{}})})),s.map(c=>({key:c.key,meta:i[c.key]}))},setItem:async(o,s)=>{const{driver:n,driverKey:i}=t(o);await _(n,i,s)},setItems:async o=>{const s={};o.forEach(n=>{const{driverArea:i,driverKey:c}=t("key"in n?n.key:n.item.key);s[i]??(s[i]=[]),s[i].push({key:c,value:n.value})}),await Promise.all(Object.entries(s).map(async([n,i])=>{await e(n).setItems(i)}))},setMeta:async(o,s)=>{const{driver:n,driverKey:i}=t(o);await y(n,i,s)},setMetas:async o=>{const s={};o.forEach(n=>{const{driverArea:i,driverKey:c}=t("key"in n?n.key:n.item.key);s[i]??(s[i]=[]),s[i].push({key:c,properties:n.meta})}),await Promise.all(Object.entries(s).map(async([n,i])=>{const c=e(n),d=i.map(({key:g})=>r(g));console.log(n,d);const f=await c.getItems(d),m=Object.fromEntries(f.map(({key:g,value:p})=>[g,h(p)])),E=i.map(({key:g,properties:p})=>{const w=r(g);return{key:w,value:l(m[w]??{},p)}});await c.setItems(E)}))},removeItem:async(o,s)=>{const{driver:n,driverKey:i}=t(o);await I(n,i,s)},removeItems:async o=>{const s={};o.forEach(n=>{let i,c;typeof n=="string"?i=n:"getValue"in n?i=n.key:"item"in n?(i=n.item.key,c=n.options):(i=n.key,c=n.options);const{driverArea:d,driverKey:f}=t(i);s[d]??(s[d]=[]),s[d].push(f),c!=null&&c.removeMeta&&s[d].push(r(f))}),await Promise.all(Object.entries(s).map(async([n,i])=>{await e(n).removeItems(i)}))},removeMeta:async(o,s)=>{const{driver:n,driverKey:i}=t(o);await te(n,i,s)},snapshot:async(o,s)=>{var c;const i=await e(o).snapshot();return(c=s==null?void 0:s.excludeKeys)==null||c.forEach(d=>{delete i[d],delete i[r(d)]}),i},restoreSnapshot:async(o,s)=>{await e(o).restoreSnapshot(s)},watch:(o,s)=>{const{driver:n,driverKey:i}=t(o);return re(n,i,s)},unwatch(){Object.values(a).forEach(o=>{o.unwatch()})},defineItem:(o,s)=>{const{driver:n,driverKey:i}=t(o),{version:c=1,migrations:d={}}=s??{};if(c<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const f=async()=>{var ne;const w=r(i),[{value:S},{value:$}]=await n.getItems([i,w]);if(S==null)return;const F=($==null?void 0:$.v)??1;if(F>c)throw Error(`Version downgrade detected (v${F} -> v${c}) for "${o}"`);console.debug(`[@wxt-dev/storage] Running storage migration for ${o}: v${F} -> v${c}`);const pe=Array.from({length:c-F},(Y,H)=>F+H+1);let P=S;for(const Y of pe)try{P=await((ne=d==null?void 0:d[Y])==null?void 0:ne.call(d,P))??P}catch(H){throw Error(`v${Y} migration failed for "${o}"`,{cause:H})}await n.setItems([{key:i,value:P},{key:w,value:{...$,v:c}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${o} v${c}`,{migratedValue:P})},m=(s==null?void 0:s.migrations)==null?Promise.resolve():f().catch(w=>{console.error(`[@wxt-dev/storage] Migration failed for ${o}`,w)}),E=new le,g=()=>(s==null?void 0:s.fallback)??(s==null?void 0:s.defaultValue)??null,p=()=>E.runExclusive(async()=>{const w=await n.getItem(i);if(w!=null||(s==null?void 0:s.init)==null)return w;const S=await s.init();return await n.setItem(i,S),S});return m.then(p),{key:o,get defaultValue(){return g()},get fallback(){return g()},getValue:async()=>(await m,s!=null&&s.init?await p():await v(n,i,s)),getMeta:async()=>(await m,await V(n,i)),setValue:async w=>(await m,await _(n,i,w)),setMeta:async w=>(await m,await y(n,i,w)),removeValue:async w=>(await m,await I(n,i,w)),removeMeta:async w=>(await m,await te(n,i,w)),watch:w=>re(n,i,(S,$)=>w(S??g(),$??g())),migrate:f}}}}function O(a){const e=()=>{if(L.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(L.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const r=L.storage[a];if(r==null)throw Error(`"browser.storage.${a}" is undefined`);return r},t=new Set;return{getItem:async r=>(await e().get(r))[r],getItems:async r=>{const l=await e().get(r);return r.map(u=>({key:u,value:l[u]??null}))},setItem:async(r,l)=>{l==null?await e().remove(r):await e().set({[r]:l})},setItems:async r=>{const l=r.reduce((u,{key:h,value:v})=>(u[h]=v,u),{});await e().set(l)},removeItem:async r=>{await e().remove(r)},removeItems:async r=>{await e().remove(r)},snapshot:async()=>await e().get(),restoreSnapshot:async r=>{await e().set(r)},watch(r,l){const u=h=>{const v=h[r];v!=null&&(R(v.newValue,v.oldValue)||l(v.newValue??null,v.oldValue??null))};return e().onChanged.addListener(u),t.add(u),()=>{e().onChanged.removeListener(u),t.delete(u)}},unwatch(){t.forEach(r=>{e().onChanged.removeListener(r)}),t.clear()}}}function M(a,e="local"){return`${e}:${a}`}K.defineItem(M("activity"),{fallback:x.activity}),K.defineItem(M("mode"),{fallback:x.mode}),K.defineItem(M("scaleX"),{fallback:x.scaleX}),K.defineItem(M("scaleY"),{fallback:x.scaleY});const z=K.defineItem(M("license"));K.defineItem(M("helpers"),{fallback:x.helpers}),K.defineItem(M("tabsInFullscreen"),{fallback:[]}),K.defineItem(M("booster"),{fallback:x.booster});function de(a){return{send(e){window.postMessage({from:"uw:ext",...e},a)},receive(e){window.addEventListener("message",t=>{t.origin!==a||t.data.from!=="uw:web"||e(t.data)})}}}const he={matches:["https://uw.wtf/*"],async main(){const{send:a,receive:e}=de(k);e(async t=>{if("ready"in t&&t.ready){const r=await z.getValue();a({ready:!0,license:r})}"license"in t&&await z.setValue(t.license)}),b.runtime.onMessage.addListener(t=>{"version"in t&&window.sessionStorage.setItem("uw:version",t.version)})}};function j(a,...e){}const fe={debug:(...a)=>j(console.debug,...a),log:(...a)=>j(console.log,...a),warn:(...a)=>j(console.warn,...a),error:(...a)=>j(console.error,...a)},U=class U extends Event{constructor(e,t){super(U.EVENT_NAME,{}),this.newUrl=e,this.oldUrl=t}};A(U,"EVENT_NAME",W("wxt:locationchange"));let C=U;function W(a){var e;return`${(e=b==null?void 0:b.runtime)==null?void 0:e.id}:license:${a}`}function me(a){let e,t;return{run(){e==null&&(t=new URL(location.href),e=a.setInterval(()=>{let r=new URL(location.href);r.href!==t.href&&(window.dispatchEvent(new C(r,t)),t=r)},1e3))}}}const q=class q{constructor(e,t){A(this,"isTopFrame",window.self===window.top);A(this,"abortController");A(this,"locationWatcher",me(this));this.contentScriptName=e,this.options=t,this.abortController=new AbortController,this.isTopFrame?(this.listenForNewerScripts({ignoreFirstEvent:!0}),this.stopOldScripts()):this.listenForNewerScripts()}get signal(){return this.abortController.signal}abort(e){return this.abortController.abort(e)}get isInvalid(){return b.runtime.id==null&&this.notifyInvalidated(),this.signal.aborted}get isValid(){return!this.isInvalid}onInvalidated(e){return this.signal.addEventListener("abort",e),()=>this.signal.removeEventListener("abort",e)}block(){return new Promise(()=>{})}setInterval(e,t){const r=setInterval(()=>{this.isValid&&e()},t);return this.onInvalidated(()=>clearInterval(r)),r}setTimeout(e,t){const r=setTimeout(()=>{this.isValid&&e()},t);return this.onInvalidated(()=>clearTimeout(r)),r}requestAnimationFrame(e){const t=requestAnimationFrame((...r)=>{this.isValid&&e(...r)});return this.onInvalidated(()=>cancelAnimationFrame(t)),t}requestIdleCallback(e,t){const r=requestIdleCallback((...l)=>{this.signal.aborted||e(...l)},t);return this.onInvalidated(()=>cancelIdleCallback(r)),r}addEventListener(e,t,r,l){var u;t==="wxt:locationchange"&&this.isValid&&this.locationWatcher.run(),(u=e.addEventListener)==null||u.call(e,t.startsWith("wxt:")?W(t):t,r,{...l,signal:this.signal})}notifyInvalidated(){this.abort("Content script context invalidated"),fe.debug(`Content script "${this.contentScriptName}" context invalidated`)}stopOldScripts(){window.postMessage({type:q.SCRIPT_STARTED_MESSAGE_TYPE,contentScriptName:this.contentScriptName},"*")}listenForNewerScripts(e){let t=!0;const r=l=>{var u,h;if(((u=l.data)==null?void 0:u.type)===q.SCRIPT_STARTED_MESSAGE_TYPE&&((h=l.data)==null?void 0:h.contentScriptName)===this.contentScriptName){const v=t;if(t=!1,v&&(e!=null&&e.ignoreFirstEvent))return;this.notifyInvalidated()}};addEventListener("message",r),this.onInvalidated(()=>removeEventListener("message",r))}};A(q,"SCRIPT_STARTED_MESSAGE_TYPE",W("wxt:content-script-started"));let D=q;const we=Symbol("null");let ve=0;class ye extends Map{constructor(){super(),this._objectHashes=new WeakMap,this._symbolHashes=new Map,this._publicKeys=new Map;const[e]=arguments;if(e!=null){if(typeof e[Symbol.iterator]!="function")throw new TypeError(typeof e+" is not iterable (cannot read property Symbol(Symbol.iterator))");for(const[t,r]of e)this.set(t,r)}}_getPublicKeys(e,t=!1){if(!Array.isArray(e))throw new TypeError("The keys parameter must be an array");const r=this._getPrivateKey(e,t);let l;return r&&this._publicKeys.has(r)?l=this._publicKeys.get(r):t&&(l=[...e],this._publicKeys.set(r,l)),{privateKey:r,publicKey:l}}_getPrivateKey(e,t=!1){const r=[];for(let l of e){l===null&&(l=we);const u=typeof l=="object"||typeof l=="function"?"_objectHashes":typeof l=="symbol"?"_symbolHashes":!1;if(!u)r.push(l);else if(this[u].has(l))r.push(this[u].get(l));else if(t){const h=`@@mkm-ref-${ve++}@@`;this[u].set(l,h),r.push(h)}else return!1}return JSON.stringify(r)}set(e,t){const{publicKey:r}=this._getPublicKeys(e,!0);return super.set(r,t)}get(e){const{publicKey:t}=this._getPublicKeys(e);return super.get(t)}has(e){const{publicKey:t}=this._getPublicKeys(e);return super.has(t)}delete(e){const{publicKey:t,privateKey:r}=this._getPublicKeys(e);return!!(t&&super.delete(t)&&this._publicKeys.delete(r))}clear(){super.clear(),this._symbolHashes.clear(),this._publicKeys.clear()}get[Symbol.toStringTag](){return"ManyKeysMap"}get size(){return super.size}}new ye;function Ie(){}function N(a,...e){}const ge={debug:(...a)=>N(console.debug,...a),log:(...a)=>N(console.log,...a),warn:(...a)=>N(console.warn,...a),error:(...a)=>N(console.error,...a)};return(async()=>{try{const{main:a,...e}=he,t=new D("license",e);return await a(t)}catch(a){throw ge.error('The content script "license" crashed on startup!',a),a}})()}();
license;
