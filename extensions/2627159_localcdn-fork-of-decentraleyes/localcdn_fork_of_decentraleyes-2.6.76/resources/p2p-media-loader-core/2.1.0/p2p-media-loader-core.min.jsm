var Pn = Object.defineProperty;
var qn = (i, t, e) => t in i ? Pn(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var d = (i, t, e) => qn(i, typeof t != "symbol" ? t + "" : t, e);
class x extends Error {
  constructor(e, n) {
    super(n);
    d(this, "timestamp");
    this.type = e, this.timestamp = performance.now();
  }
}
class oe extends Error {
  constructor(t) {
    super(), this.type = t;
  }
}
class Bn {
  constructor(t, e, n) {
    d(this, "requestControls");
    d(this, "abortController", new AbortController());
    d(this, "expectedBytesLength");
    d(this, "requestByteRange");
    d(this, "onChunkDownloaded");
    this.request = t, this.httpConfig = e, this.onChunkDownloaded = n.getEventDispatcher("onChunkDownloaded");
    const { byteRange: s } = this.request.segment;
    s && (this.requestByteRange = { ...s }), t.loadedBytes !== 0 && (this.requestByteRange = this.requestByteRange ?? { start: 0 }, this.requestByteRange.start = this.requestByteRange.start + t.loadedBytes), this.request.totalBytes && (this.expectedBytesLength = this.request.totalBytes - this.request.loadedBytes), this.requestControls = this.request.start({ downloadSource: "http" }, { abort: () => this.abortController.abort("abort"), notReceivingBytesTimeoutMs: this.httpConfig.httpNotReceivingBytesTimeoutMs }), this.fetch();
  }
  async fetch() {
    var e, n;
    const { segment: t } = this.request;
    try {
      let s = await ((n = (e = this.httpConfig).httpRequestSetup) == null ? void 0 : n.call(e, t.url, t.byteRange, this.abortController.signal, this.requestByteRange));
      if (!s) {
        const h = new Headers(this.requestByteRange ? { Range: `bytes=${this.requestByteRange.start}-${this.requestByteRange.end ?? ""}` } : void 0);
        s = new Request(t.url, { headers: h, signal: this.abortController.signal });
      }
      if (this.abortController.signal.aborted) throw new DOMException("Request aborted before request fetch", "AbortError");
      const r = await window.fetch(s);
      if (this.handleResponseHeaders(r), !r.body) return;
      const { requestControls: o } = this;
      o.firstBytesReceived();
      const a = r.body.getReader();
      for await (const h of async function* (u) {
        for (; ; ) {
          const { done: c, value: l } = await u.read();
          if (c) break;
          yield l;
        }
      }(a)) this.requestControls.addLoadedChunk(h), this.onChunkDownloaded(h.byteLength, "http");
      o.completeOnSuccess();
    } catch (s) {
      this.handleError(s);
    }
  }
  handleResponseHeaders(t) {
    if (!t.ok) throw t.status === 406 ? (this.request.clearLoadedBytes(), new x("http-bytes-mismatch", t.statusText)) : new x("http-error", t.statusText);
    const { requestByteRange: e } = this;
    if (e) if (t.status === 200) {
      if (this.request.segment.byteRange) throw new x("http-unexpected-status-code");
      this.request.clearLoadedBytes();
    } else {
      if (t.status !== 206) throw new x("http-unexpected-status-code", t.statusText);
      const n = t.headers.get("Content-Length");
      if (n && this.expectedBytesLength !== void 0 && this.expectedBytesLength !== +n) throw this.request.clearLoadedBytes(), new x("http-bytes-mismatch", t.statusText);
      const s = t.headers.get("Content-Range"), r = s ? function(o) {
        const a = On.exec(o.trim());
        if (!a) return;
        const [, h, u, c] = a;
        return { from: h ? parseInt(h) : void 0, to: u ? parseInt(u) : void 0, total: c ? parseInt(c) : void 0 };
      }(s) : void 0;
      if (r) {
        const { from: o, to: a, total: h } = r;
        if (h !== void 0 && this.request.totalBytes !== h || o !== void 0 && e.start !== o || a !== void 0 && e.end !== void 0 && e.end !== a) throw this.request.clearLoadedBytes(), new x("http-bytes-mismatch", t.statusText);
      }
    }
    if (t.status === 200 && this.request.totalBytes === void 0) {
      const n = t.headers.get("Content-Length");
      n && this.request.setTotalBytes(+n);
    }
  }
  handleError(t) {
    if (t instanceof Error) {
      if (t.name !== "abort") return;
      const e = t instanceof x ? t : new x("http-error", t.message);
      this.requestControls.abortOnError(e);
    }
  }
}
const On = /^bytes (?:(?:(\d+)|)-(?:(\d+)|)|\*)\/(?:(\d+)|\*)$/;
function Dn(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var E, P, je = { exports: {} }, _ = je.exports = {};
function Ft() {
  throw new Error("setTimeout has not been defined");
}
function Ht() {
  throw new Error("clearTimeout has not been defined");
}
function We(i) {
  if (E === setTimeout) return setTimeout(i, 0);
  if ((E === Ft || !E) && setTimeout) return E = setTimeout, setTimeout(i, 0);
  try {
    return E(i, 0);
  } catch {
    try {
      return E.call(null, i, 0);
    } catch {
      return E.call(this, i, 0);
    }
  }
}
(function() {
  try {
    E = typeof setTimeout == "function" ? setTimeout : Ft;
  } catch {
    E = Ft;
  }
  try {
    P = typeof clearTimeout == "function" ? clearTimeout : Ht;
  } catch {
    P = Ht;
  }
})();
var j, q = [], z = !1, pt = -1;
function Mn() {
  z && j && (z = !1, j.length ? q = j.concat(q) : pt = -1, q.length && Qe());
}
function Qe() {
  if (!z) {
    var i = We(Mn);
    z = !0;
    for (var t = q.length; t; ) {
      for (j = q, q = []; ++pt < t; ) j && j[pt].run();
      pt = -1, t = q.length;
    }
    j = null, z = !1, function(e) {
      if (P === clearTimeout) return clearTimeout(e);
      if ((P === Ht || !P) && clearTimeout) return P = clearTimeout, clearTimeout(e);
      try {
        return P(e);
      } catch {
        try {
          return P.call(null, e);
        } catch {
          return P.call(this, e);
        }
      }
    }(i);
  }
}
function ae(i, t) {
  this.fun = i, this.array = t;
}
function R() {
}
_.nextTick = function(i) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
  q.push(new ae(i, t)), q.length !== 1 || z || We(Qe);
}, ae.prototype.run = function() {
  this.fun.apply(null, this.array);
}, _.title = "browser", _.browser = !0, _.env = {}, _.argv = [], _.version = "", _.versions = {}, _.on = R, _.addListener = R, _.once = R, _.off = R, _.removeListener = R, _.removeAllListeners = R, _.emit = R, _.prependListener = R, _.prependOnceListener = R, _.listeners = function(i) {
  return [];
}, _.binding = function(i) {
  throw new Error("process.binding is not supported");
}, _.cwd = function() {
  return "/";
}, _.chdir = function(i) {
  throw new Error("process.chdir is not supported");
}, _.umask = function() {
  return 0;
};
const ft = Dn(je.exports);
var Nn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function W(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var he, ce, $t = { exports: {} };
function Un() {
  if (ce) return he;
  ce = 1;
  var i = 1e3, t = 60 * i, e = 60 * t, n = 24 * e, s = 7 * n, r = 365.25 * n;
  function o(a, h, u, c) {
    var l = h >= 1.5 * u;
    return Math.round(a / u) + " " + c + (l ? "s" : "");
  }
  return he = function(a, h) {
    h = h || {};
    var u = typeof a;
    if (u === "string" && a.length > 0) return function(c) {
      if (!((c = String(c)).length > 100)) {
        var l = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(c);
        if (l) {
          var g = parseFloat(l[1]);
          switch ((l[2] || "ms").toLowerCase()) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return g * r;
            case "weeks":
            case "week":
            case "w":
              return g * s;
            case "days":
            case "day":
            case "d":
              return g * n;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return g * e;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return g * t;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return g * i;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return g;
            default:
              return;
          }
        }
      }
    }(a);
    if (u === "number" && isFinite(a)) return h.long ? function(c) {
      var l = Math.abs(c);
      return l >= n ? o(c, l, n, "day") : l >= e ? o(c, l, e, "hour") : l >= t ? o(c, l, t, "minute") : l >= i ? o(c, l, i, "second") : c + " ms";
    }(a) : function(c) {
      var l = Math.abs(c);
      return l >= n ? Math.round(c / n) + "d" : l >= e ? Math.round(c / e) + "h" : l >= t ? Math.round(c / t) + "m" : l >= i ? Math.round(c / i) + "s" : c + "ms";
    }(a);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(a));
  };
}
var Fn = function(i) {
  function t(s) {
    let r, o, a, h = null;
    function u(...c) {
      if (!u.enabled) return;
      const l = u, g = Number(/* @__PURE__ */ new Date()), m = g - (r || g);
      l.diff = m, l.prev = r, l.curr = g, r = g, c[0] = t.coerce(c[0]), typeof c[0] != "string" && c.unshift("%O");
      let f = 0;
      c[0] = c[0].replace(/%([a-zA-Z%])/g, (v, H) => {
        if (v === "%%") return "%";
        f++;
        const D = t.formatters[H];
        if (typeof D == "function") {
          const Et = c[f];
          v = D.call(l, Et), c.splice(f, 1), f--;
        }
        return v;
      }), t.formatArgs.call(l, c), (l.log || t.log).apply(l, c);
    }
    return u.namespace = s, u.useColors = t.useColors(), u.color = t.selectColor(s), u.extend = e, u.destroy = t.destroy, Object.defineProperty(u, "enabled", { enumerable: !0, configurable: !1, get: () => h !== null ? h : (o !== t.namespaces && (o = t.namespaces, a = t.enabled(s)), a), set: (c) => {
      h = c;
    } }), typeof t.init == "function" && t.init(u), u;
  }
  function e(s, r) {
    const o = t(this.namespace + (r === void 0 ? ":" : r) + s);
    return o.log = this.log, o;
  }
  function n(s) {
    return s.toString().substring(2, s.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  return t.debug = t, t.default = t, t.coerce = function(s) {
    return s instanceof Error ? s.stack || s.message : s;
  }, t.disable = function() {
    const s = [...t.names.map(n), ...t.skips.map(n).map((r) => "-" + r)].join(",");
    return t.enable(""), s;
  }, t.enable = function(s) {
    let r;
    t.save(s), t.namespaces = s, t.names = [], t.skips = [];
    const o = (typeof s == "string" ? s : "").split(/[\s,]+/), a = o.length;
    for (r = 0; r < a; r++) o[r] && ((s = o[r].replace(/\*/g, ".*?"))[0] === "-" ? t.skips.push(new RegExp("^" + s.slice(1) + "$")) : t.names.push(new RegExp("^" + s + "$")));
  }, t.enabled = function(s) {
    if (s[s.length - 1] === "*") return !0;
    let r, o;
    for (r = 0, o = t.skips.length; r < o; r++) if (t.skips[r].test(s)) return !1;
    for (r = 0, o = t.names.length; r < o; r++) if (t.names[r].test(s)) return !0;
    return !1;
  }, t.humanize = Un(), t.destroy = function() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }, Object.keys(i).forEach((s) => {
    t[s] = i[s];
  }), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function(s) {
    let r = 0;
    for (let o = 0; o < s.length; o++) r = (r << 5) - r + s.charCodeAt(o), r |= 0;
    return t.colors[Math.abs(r) % t.colors.length];
  }, t.enable(t.load()), t;
};
(function(i, t) {
  t.formatArgs = function(n) {
    if (n[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + n[0] + (this.useColors ? "%c " : " ") + "+" + i.exports.humanize(this.diff), !this.useColors) return;
    const s = "color: " + this.color;
    n.splice(1, 0, s, "color: inherit");
    let r = 0, o = 0;
    n[0].replace(/%[a-zA-Z%]/g, (a) => {
      a !== "%%" && (r++, a === "%c" && (o = r));
    }), n.splice(o, 0, s);
  }, t.save = function(n) {
    try {
      n ? t.storage.setItem("debug", n) : t.storage.removeItem("debug");
    } catch {
    }
  }, t.load = function() {
    let n;
    try {
      n = t.storage.getItem("debug");
    } catch {
    }
    return !n && ft !== void 0 && "env" in ft && (n = ft.env.DEBUG), n;
  }, t.useColors = function() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
    let n;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (n = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(n[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }, t.storage = function() {
    try {
      return localStorage;
    } catch {
    }
  }(), t.destroy = /* @__PURE__ */ (() => {
    let n = !1;
    return () => {
      n || (n = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => {
  }), i.exports = Fn(t);
  const { formatters: e } = i.exports;
  e.j = function(n) {
    try {
      return JSON.stringify(n);
    } catch (s) {
      return "[UnexpectedJSONParseError]: " + s.message;
    }
  };
})($t, $t.exports);
var ze = $t.exports;
const L = W(ze);
var Ge, jt = { exports: {} }, G = typeof Reflect == "object" ? Reflect : null, de = G && typeof G.apply == "function" ? G.apply : function(i, t, e) {
  return Function.prototype.apply.call(i, t, e);
};
Ge = G && typeof G.ownKeys == "function" ? G.ownKeys : Object.getOwnPropertySymbols ? function(i) {
  return Object.getOwnPropertyNames(i).concat(Object.getOwnPropertySymbols(i));
} : function(i) {
  return Object.getOwnPropertyNames(i);
};
var le = Number.isNaN || function(i) {
  return i != i;
};
function p() {
  p.init.call(this);
}
jt.exports = p, jt.exports.once = function(i, t) {
  return new Promise(function(e, n) {
    function s(o) {
      i.removeListener(t, r), n(o);
    }
    function r() {
      typeof i.removeListener == "function" && i.removeListener("error", s), e([].slice.call(arguments));
    }
    ye(i, t, r, { once: !0 }), t !== "error" && function(o, a, h) {
      typeof o.on == "function" && ye(o, "error", a, h);
    }(i, s, { once: !0 });
  });
}, p.EventEmitter = p, p.prototype._events = void 0, p.prototype._eventsCount = 0, p.prototype._maxListeners = void 0;
var ue = 10;
function yt(i) {
  if (typeof i != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof i);
}
function Je(i) {
  return i._maxListeners === void 0 ? p.defaultMaxListeners : i._maxListeners;
}
function ge(i, t, e, n) {
  var s, r, o, a;
  if (yt(e), (r = i._events) === void 0 ? (r = i._events = /* @__PURE__ */ Object.create(null), i._eventsCount = 0) : (r.newListener !== void 0 && (i.emit("newListener", t, e.listener ? e.listener : e), r = i._events), o = r[t]), o === void 0) o = r[t] = e, ++i._eventsCount;
  else if (typeof o == "function" ? o = r[t] = n ? [e, o] : [o, e] : n ? o.unshift(e) : o.push(e), (s = Je(i)) > 0 && o.length > s && !o.warned) {
    o.warned = !0;
    var h = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h.name = "MaxListenersExceededWarning", h.emitter = i, h.type = t, h.count = o.length, a = h, console && console.warn && console.warn(a);
  }
  return i;
}
function Hn() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function me(i, t, e) {
  var n = { fired: !1, wrapFn: void 0, target: i, type: t, listener: e }, s = Hn.bind(n);
  return s.listener = e, n.wrapFn = s, s;
}
function pe(i, t, e) {
  var n = i._events;
  if (n === void 0) return [];
  var s = n[t];
  return s === void 0 ? [] : typeof s == "function" ? e ? [s.listener || s] : [s] : e ? function(r) {
    for (var o = new Array(r.length), a = 0; a < o.length; ++a) o[a] = r[a].listener || r[a];
    return o;
  }(s) : Ve(s, s.length);
}
function fe(i) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[i];
    if (typeof e == "function") return 1;
    if (e !== void 0) return e.length;
  }
  return 0;
}
function Ve(i, t) {
  for (var e = new Array(t), n = 0; n < t; ++n) e[n] = i[n];
  return e;
}
function ye(i, t, e, n) {
  if (typeof i.on == "function") n.once ? i.once(t, e) : i.on(t, e);
  else {
    if (typeof i.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof i);
    i.addEventListener(t, function s(r) {
      n.once && i.removeEventListener(t, s), e(r);
    });
  }
}
Object.defineProperty(p, "defaultMaxListeners", { enumerable: !0, get: function() {
  return ue;
}, set: function(i) {
  if (typeof i != "number" || i < 0 || le(i)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + i + ".");
  ue = i;
} }), p.init = function() {
  this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, p.prototype.setMaxListeners = function(i) {
  if (typeof i != "number" || i < 0 || le(i)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + i + ".");
  return this._maxListeners = i, this;
}, p.prototype.getMaxListeners = function() {
  return Je(this);
}, p.prototype.emit = function(i) {
  for (var t = [], e = 1; e < arguments.length; e++) t.push(arguments[e]);
  var n = i === "error", s = this._events;
  if (s !== void 0) n = n && s.error === void 0;
  else if (!n) return !1;
  if (n) {
    var r;
    if (t.length > 0 && (r = t[0]), r instanceof Error) throw r;
    var o = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw o.context = r, o;
  }
  var a = s[i];
  if (a === void 0) return !1;
  if (typeof a == "function") de(a, this, t);
  else {
    var h = a.length, u = Ve(a, h);
    for (e = 0; e < h; ++e) de(u[e], this, t);
  }
  return !0;
}, p.prototype.addListener = function(i, t) {
  return ge(this, i, t, !1);
}, p.prototype.on = p.prototype.addListener, p.prototype.prependListener = function(i, t) {
  return ge(this, i, t, !0);
}, p.prototype.once = function(i, t) {
  return yt(t), this.on(i, me(this, i, t)), this;
}, p.prototype.prependOnceListener = function(i, t) {
  return yt(t), this.prependListener(i, me(this, i, t)), this;
}, p.prototype.removeListener = function(i, t) {
  var e, n, s, r, o;
  if (yt(t), (n = this._events) === void 0) return this;
  if ((e = n[i]) === void 0) return this;
  if (e === t || e.listener === t) --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete n[i], n.removeListener && this.emit("removeListener", i, e.listener || t));
  else if (typeof e != "function") {
    for (s = -1, r = e.length - 1; r >= 0; r--) if (e[r] === t || e[r].listener === t) {
      o = e[r].listener, s = r;
      break;
    }
    if (s < 0) return this;
    s === 0 ? e.shift() : function(a, h) {
      for (; h + 1 < a.length; h++) a[h] = a[h + 1];
      a.pop();
    }(e, s), e.length === 1 && (n[i] = e[0]), n.removeListener !== void 0 && this.emit("removeListener", i, o || t);
  }
  return this;
}, p.prototype.off = p.prototype.removeListener, p.prototype.removeAllListeners = function(i) {
  var t, e, n;
  if ((e = this._events) === void 0) return this;
  if (e.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : e[i] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete e[i]), this;
  if (arguments.length === 0) {
    var s, r = Object.keys(e);
    for (n = 0; n < r.length; ++n) (s = r[n]) !== "removeListener" && this.removeAllListeners(s);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (typeof (t = e[i]) == "function") this.removeListener(i, t);
  else if (t !== void 0) for (n = t.length - 1; n >= 0; n--) this.removeListener(i, t[n]);
  return this;
}, p.prototype.listeners = function(i) {
  return pe(this, i, !0);
}, p.prototype.rawListeners = function(i) {
  return pe(this, i, !1);
}, p.listenerCount = function(i, t) {
  return typeof i.listenerCount == "function" ? i.listenerCount(t) : fe.call(i, t);
}, p.prototype.listenerCount = fe, p.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Ge(this._events) : [];
};
var Ye = jt.exports;
const Ke = W(Ye);
var Wt = { exports: {} }, $n = function i(t, e) {
  if (t && e) return i(t)(e);
  if (typeof t != "function") throw new TypeError("need wrapper function");
  return Object.keys(t).forEach(function(s) {
    n[s] = t[s];
  }), n;
  function n() {
    for (var s = new Array(arguments.length), r = 0; r < s.length; r++) s[r] = arguments[r];
    var o = t.apply(this, s), a = s[s.length - 1];
    return typeof o == "function" && o !== a && Object.keys(a).forEach(function(h) {
      o[h] = a[h];
    }), o;
  }
}, _e = $n;
function rt(i) {
  var t = function() {
    return t.called ? t.value : (t.called = !0, t.value = i.apply(this, arguments));
  };
  return t.called = !1, t;
}
function Se(i) {
  var t = function() {
    if (t.called) throw new Error(t.onceError);
    return t.called = !0, t.value = i.apply(this, arguments);
  }, e = i.name || "Function wrapped with `once`";
  return t.onceError = e + " shouldn't be called more than once", t.called = !1, t;
}
Wt.exports = _e(rt), Wt.exports.strict = _e(Se), rt.proto = rt(function() {
  Object.defineProperty(Function.prototype, "once", { value: function() {
    return rt(this);
  }, configurable: !0 }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
    return Se(this);
  }, configurable: !0 });
});
const jn = W(Wt.exports);
let we;
var Ze = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : Nn) : (i) => (we || (we = Promise.resolve())).then(i).catch((t) => setTimeout(() => {
  throw t;
}, 0));
const Qt = W(Ze);
var Wn = function(i, t) {
  let e, n, s, r = !0;
  Array.isArray(i) ? (e = [], n = i.length) : (s = Object.keys(i), e = {}, n = s.length);
  function o(h) {
    function u() {
      t && t(h, e), t = null;
    }
    r ? Qn(u) : u();
  }
  function a(h, u, c) {
    e[h] = c, (--n == 0 || u) && o(u);
  }
  n ? s ? s.forEach(function(h) {
    i[h](function(u, c) {
      a(h, u, c);
    });
  }) : i.forEach(function(h, u) {
    h(function(c, l) {
      a(u, c, l);
    });
  }) : o(null), r = !1;
};
const Qn = Ze, zn = W(Wn), O = typeof window < "u" ? window : self, zt = O.RTCPeerConnection || O.mozRTCPeerConnection || O.webkitRTCPeerConnection, Gn = O.RTCSessionDescription || O.mozRTCSessionDescription || O.webkitRTCSessionDescription, Jn = O.RTCIceCandidate || O.mozRTCIceCandidate || O.webkitRTCIceCandidate;
var Vn = typeof queueMicrotask == "function" ? queueMicrotask : (i) => Promise.resolve().then(i);
const be = class {
  constructor(i) {
    if (!(i > 0) || i - 1 & i) throw new Error("Max size for a FixedFIFO should be a power of two");
    this.buffer = new Array(i), this.mask = i - 1, this.top = 0, this.btm = 0, this.next = null;
  }
  clear() {
    this.top = this.btm = 0, this.next = null, this.buffer.fill(void 0);
  }
  push(i) {
    return this.buffer[this.top] === void 0 && (this.buffer[this.top] = i, this.top = this.top + 1 & this.mask, !0);
  }
  shift() {
    const i = this.buffer[this.btm];
    if (i !== void 0) return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, i;
  }
  peek() {
    return this.buffer[this.btm];
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var Xe = class {
  constructor(i) {
    this.decoder = new TextDecoder(i === "utf16le" ? "utf16-le" : i);
  }
  get remaining() {
    return -1;
  }
  decode(i) {
    return this.decoder.decode(i, { stream: !0 });
  }
  flush() {
    return this.decoder.decode(new Uint8Array(0));
  }
};
const Yn = Xe, Kn = Xe, { EventEmitter: Zn } = Ye, ie = new Error("Stream was destroyed"), tn = (new Error("Premature close"), Vn), en = class {
  constructor(i) {
    this.hwm = i || 16, this.head = new be(this.hwm), this.tail = this.head, this.length = 0;
  }
  clear() {
    this.head = this.tail, this.head.clear(), this.length = 0;
  }
  push(i) {
    if (this.length++, !this.head.push(i)) {
      const t = this.head;
      this.head = t.next = new be(2 * this.head.buffer.length), this.head.push(i);
    }
  }
  shift() {
    this.length !== 0 && this.length--;
    const i = this.tail.shift();
    if (i === void 0 && this.tail.next) {
      const t = this.tail.next;
      return this.tail.next = null, this.tail = t, this.tail.shift();
    }
    return i;
  }
  peek() {
    const i = this.tail.peek();
    return i === void 0 && this.tail.next ? this.tail.next.peek() : i;
  }
  isEmpty() {
    return this.length === 0;
  }
}, Xn = class {
  constructor(i = "utf8") {
    switch (this.encoding = function(t) {
      switch (t = t.toLowerCase()) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return t;
        default:
          throw new Error("Unknown encoding: " + t);
      }
    }(i), this.encoding) {
      case "utf8":
        this.decoder = new Kn();
        break;
      case "utf16le":
      case "base64":
        throw new Error("Unsupported encoding: " + this.encoding);
      default:
        this.decoder = new Yn(this.encoding);
    }
  }
  get remaining() {
    return this.decoder.remaining;
  }
  push(i) {
    return typeof i == "string" ? i : this.decoder.decode(i);
  }
  write(i) {
    return this.push(i);
  }
  end(i) {
    let t = "";
    return i && (t = this.push(i)), t += this.decoder.flush(), t;
  }
}, it = 536870911, nn = 1 ^ it, ts = 2 ^ it, sn = 64, Pt = 128, rn = 256, es = 1024, Ce = 2048, ns = 4096, ss = 8192, St = 16384, qt = 32768, Gt = 131072, is = 131328, rs = 16 ^ it, ve = 536805375, ke = 768 ^ it, on = 536838143, os = 32 ^ it, an = 536739839, as = 1 << 18, wt = 2 << 18, hn = 4 << 18, Te = 8 << 18, hs = 16 << 18, cn = 32 << 18, Jt = 64 << 18, Bt = 128 << 18, xe = 512 << 18, cs = 1024 << 18, ds = 535822335, dn = 503316479, ls = 268435455, bt = 262160, us = 536608751, ln = 8404992, nt = 14, gs = 15, un = 8405006, gn = 33587200, mn = 33587215, ms = 2359296, Ae = 270794767, ot = Symbol.asyncIterator || Symbol("asyncIterator");
class ps {
  constructor(t, { highWaterMark: e = 16384, map: n = null, mapWritable: s, byteLength: r, byteLengthWritable: o } = {}) {
    this.stream = t, this.queue = new en(), this.highWaterMark = e, this.buffered = 0, this.error = null, this.pipeline = null, this.drains = null, this.byteLength = o || r || _n, this.map = s || n, this.afterWrite = ws.bind(this), this.afterUpdateNextTick = vs.bind(this);
  }
  get ended() {
    return !!(this.stream._duplexState & cn);
  }
  push(t) {
    return !(142606350 & this.stream._duplexState) && (this.map !== null && (t = this.map(t)), this.buffered += this.byteLength(t), this.queue.push(t), this.buffered < this.highWaterMark ? (this.stream._duplexState |= Te, !0) : (this.stream._duplexState |= 6291456, !1));
  }
  shift() {
    const t = this.queue.shift();
    return this.buffered -= this.byteLength(t), this.buffered === 0 && (this.stream._duplexState &= 534773759), t;
  }
  end(t) {
    typeof t == "function" ? this.stream.once("finish", t) : t != null && this.push(t), this.stream._duplexState = (this.stream._duplexState | xe) & ds;
  }
  autoBatch(t, e) {
    const n = [], s = this.stream;
    for (n.push(t); (s._duplexState & Ae) === ms; ) n.push(s._writableState.shift());
    if (s._duplexState & gs) return e(null);
    s._writev(n, e);
  }
  update() {
    const t = this.stream;
    t._duplexState |= wt;
    do {
      for (; (t._duplexState & Ae) === Te; ) {
        const e = this.shift();
        t._duplexState |= 67371008, t._write(e, this.afterWrite);
      }
      1310720 & t._duplexState || this.updateNonPrimary();
    } while (this.continueUpdate() === !0);
    t._duplexState &= 536346623;
  }
  updateNonPrimary() {
    const t = this.stream;
    if ((144965647 & t._duplexState) === xe) return t._duplexState = t._duplexState | as, void t._final(Ss.bind(this));
    (t._duplexState & nt) != 4 ? (t._duplexState & mn) == 1 && (t._duplexState = (t._duplexState | bt) & nn, t._open(fn.bind(this))) : t._duplexState & gn || (t._duplexState |= bt, t._destroy(pn.bind(this)));
  }
  continueUpdate() {
    return !!(this.stream._duplexState & Bt) && (this.stream._duplexState &= dn, !0);
  }
  updateCallback() {
    (35127311 & this.stream._duplexState) === hn ? this.update() : this.updateNextTick();
  }
  updateNextTick() {
    this.stream._duplexState & Bt || (this.stream._duplexState |= Bt, this.stream._duplexState & wt || tn(this.afterUpdateNextTick));
  }
}
class fs {
  constructor(t, { highWaterMark: e = 16384, map: n = null, mapReadable: s, byteLength: r, byteLengthReadable: o } = {}) {
    this.stream = t, this.queue = new en(), this.highWaterMark = e === 0 ? 1 : e, this.buffered = 0, this.readAhead = e > 0, this.error = null, this.pipeline = null, this.byteLength = o || r || _n, this.map = s || n, this.pipeTo = null, this.afterRead = bs.bind(this), this.afterUpdateNextTick = Cs.bind(this);
  }
  get ended() {
    return !!(this.stream._duplexState & St);
  }
  pipe(t, e) {
    if (this.pipeTo !== null) throw new Error("Can only pipe to one destination");
    if (typeof e != "function" && (e = null), this.stream._duplexState |= 512, this.pipeTo = t, this.pipeline = new ys(this.stream, t, e), e && this.stream.on("error", Le), yn(t)) t._writableState.pipeline = this.pipeline, e && t.on("error", Le), t.on("finish", this.pipeline.finished.bind(this.pipeline));
    else {
      const n = this.pipeline.done.bind(this.pipeline, t), s = this.pipeline.done.bind(this.pipeline, t, null);
      t.on("error", n), t.on("close", s), t.on("finish", this.pipeline.finished.bind(this.pipeline));
    }
    t.on("drain", _s.bind(this)), this.stream.emit("piping", t), t.emit("pipe", this.stream);
  }
  push(t) {
    const e = this.stream;
    return t === null ? (this.highWaterMark = 0, e._duplexState = 536805311 & e._duplexState | 1024, !1) : this.map !== null && (t = this.map(t)) === null ? (e._duplexState &= ve, this.buffered < this.highWaterMark) : (this.buffered += this.byteLength(t), this.queue.push(t), e._duplexState = (e._duplexState | Pt) & ve, this.buffered < this.highWaterMark);
  }
  shift() {
    const t = this.queue.shift();
    return this.buffered -= this.byteLength(t), this.buffered === 0 && (this.stream._duplexState &= 536862591), t;
  }
  unshift(t) {
    const e = [this.map !== null ? this.map(t) : t];
    for (; this.buffered > 0; ) e.push(this.shift());
    for (let n = 0; n < e.length - 1; n++) {
      const s = e[n];
      this.buffered += this.byteLength(s), this.queue.push(s);
    }
    this.push(e[e.length - 1]);
  }
  read() {
    const t = this.stream;
    if ((16527 & t._duplexState) === Pt) {
      const e = this.shift();
      return this.pipeTo !== null && this.pipeTo.write(e) === !1 && (t._duplexState &= ke), t._duplexState & Ce && t.emit("data", e), e;
    }
    return this.readAhead === !1 && (t._duplexState |= Gt, this.updateNextTick()), null;
  }
  drain() {
    const t = this.stream;
    for (; (16527 & t._duplexState) === Pt && 768 & t._duplexState; ) {
      const e = this.shift();
      this.pipeTo !== null && this.pipeTo.write(e) === !1 && (t._duplexState &= ke), t._duplexState & Ce && t.emit("data", e);
    }
  }
  update() {
    const t = this.stream;
    t._duplexState |= 32;
    do {
      for (this.drain(); this.buffered < this.highWaterMark && (214047 & t._duplexState) === Gt; ) t._duplexState |= 65552, t._read(this.afterRead), this.drain();
      (12431 & t._duplexState) == 4224 && (t._duplexState |= ss, t.emit("readable")), 80 & t._duplexState || this.updateNonPrimary();
    } while (this.continueUpdate() === !0);
    t._duplexState &= os;
  }
  updateNonPrimary() {
    const t = this.stream;
    (1167 & t._duplexState) === es && (t._duplexState = 536869887 & t._duplexState | 16384, t.emit("end"), (t._duplexState & un) === ln && (t._duplexState |= 4), this.pipeTo !== null && this.pipeTo.end()), (t._duplexState & nt) != 4 ? (t._duplexState & mn) == 1 && (t._duplexState = (t._duplexState | bt) & nn, t._open(fn.bind(this))) : t._duplexState & gn || (t._duplexState |= bt, t._destroy(pn.bind(this)));
  }
  continueUpdate() {
    return !!(this.stream._duplexState & qt) && (this.stream._duplexState &= on, !0);
  }
  updateCallback() {
    (32879 & this.stream._duplexState) === sn ? this.update() : this.updateNextTick();
  }
  updateNextTick() {
    this.stream._duplexState & qt || (this.stream._duplexState |= qt, 32 & this.stream._duplexState || tn(this.afterUpdateNextTick));
  }
}
class ys {
  constructor(t, e, n) {
    this.from = t, this.to = e, this.afterPipe = n, this.error = null, this.pipeToFinished = !1;
  }
  finished() {
    this.pipeToFinished = !0;
  }
  done(t, e) {
    e && (this.error = e), t !== this.to || (this.to = null, this.from === null) ? t !== this.from || (this.from = null, this.to === null) ? (this.afterPipe !== null && this.afterPipe(this.error), this.to = this.from = this.afterPipe = null) : t._duplexState & St || this.to.destroy(this.error || new Error("Readable stream closed before ending")) : this.from._duplexState & St && this.pipeToFinished || this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
  }
}
function _s() {
  this.stream._duplexState |= 512, this.updateCallback();
}
function Ss(i) {
  const t = this.stream;
  i && t.destroy(i), t._duplexState & nt || (t._duplexState |= cn, t.emit("finish")), (t._duplexState & un) === ln && (t._duplexState |= 4), t._duplexState &= 402391039, t._duplexState & wt ? this.updateNextTick() : this.update();
}
function pn(i) {
  const t = this.stream;
  i || this.error === ie || (i = this.error), i && t.emit("error", i), t._duplexState |= 8, t.emit("close");
  const e = t._readableState, n = t._writableState;
  if (e !== null && e.pipeline !== null && e.pipeline.done(t, i), n !== null) {
    for (; n.drains !== null && n.drains.length > 0; ) n.drains.shift().resolve(!1);
    n.pipeline !== null && n.pipeline.done(t, i);
  }
}
function ws(i) {
  const t = this.stream;
  i && t.destroy(i), t._duplexState &= 469499903, this.drains !== null && function(e) {
    for (let n = 0; n < e.length; n++) --e[n].writes == 0 && (e.shift().resolve(!0), n--);
  }(this.drains), (6553615 & t._duplexState) === hs && (t._duplexState &= 532676607, (t._duplexState & Jt) === Jt && t.emit("drain")), this.updateCallback();
}
function bs(i) {
  i && this.stream.destroy(i), this.stream._duplexState &= rs, this.readAhead !== !1 || this.stream._duplexState & rn || (this.stream._duplexState &= an), this.updateCallback();
}
function Cs() {
  32 & this.stream._duplexState || (this.stream._duplexState &= on, this.update());
}
function vs() {
  this.stream._duplexState & wt || (this.stream._duplexState &= dn, this.update());
}
function fn(i) {
  const t = this.stream;
  i && t.destroy(i), 4 & t._duplexState || (17423 & t._duplexState || (t._duplexState |= sn), 142606351 & t._duplexState || (t._duplexState |= hn), t.emit("open")), t._duplexState &= us, t._writableState !== null && t._writableState.updateCallback(), t._readableState !== null && t._readableState.updateCallback();
}
function ks(i) {
  this._readableState !== null && (i === "data" && (this._duplexState |= 133376, this._readableState.updateNextTick()), i === "readable" && (this._duplexState |= ns, this._readableState.updateNextTick())), this._writableState !== null && i === "drain" && (this._duplexState |= Jt, this._writableState.updateNextTick());
}
class Ts extends Zn {
  constructor(t) {
    super(), this._duplexState = 0, this._readableState = null, this._writableState = null, t && (t.open && (this._open = t.open), t.destroy && (this._destroy = t.destroy), t.predestroy && (this._predestroy = t.predestroy), t.signal && t.signal.addEventListener("abort", Rs.bind(this))), this.on("newListener", ks);
  }
  _open(t) {
    t(null);
  }
  _destroy(t) {
    t(null);
  }
  _predestroy() {
  }
  get readable() {
    return this._readableState !== null || void 0;
  }
  get writable() {
    return this._writableState !== null || void 0;
  }
  get destroyed() {
    return !!(8 & this._duplexState);
  }
  get destroying() {
    return !!(this._duplexState & nt);
  }
  destroy(t) {
    this._duplexState & nt || (t || (t = ie), this._duplexState = 535822271 & this._duplexState | 4, this._readableState !== null && (this._readableState.highWaterMark = 0, this._readableState.error = t), this._writableState !== null && (this._writableState.highWaterMark = 0, this._writableState.error = t), this._duplexState |= 2, this._predestroy(), this._duplexState &= ts, this._readableState !== null && this._readableState.updateNextTick(), this._writableState !== null && this._writableState.updateNextTick());
  }
}
class Ct extends Ts {
  constructor(t) {
    super(t), this._duplexState |= 8519681, this._readableState = new fs(this, t), t && (this._readableState.readAhead === !1 && (this._duplexState &= an), t.read && (this._read = t.read), t.eagerOpen && this._readableState.updateNextTick(), t.encoding && this.setEncoding(t.encoding));
  }
  setEncoding(t) {
    const e = new Xn(t), n = this._readableState.map || As;
    return this._readableState.map = function(s) {
      const r = e.push(s);
      return r === "" && (s.byteLength !== 0 || e.remaining > 0) ? null : n(r);
    }, this;
  }
  _read(t) {
    t(null);
  }
  pipe(t, e) {
    return this._readableState.updateNextTick(), this._readableState.pipe(t, e), t;
  }
  read() {
    return this._readableState.updateNextTick(), this._readableState.read();
  }
  push(t) {
    return this._readableState.updateNextTick(), this._readableState.push(t);
  }
  unshift(t) {
    return this._readableState.updateNextTick(), this._readableState.unshift(t);
  }
  resume() {
    return this._duplexState |= is, this._readableState.updateNextTick(), this;
  }
  pause() {
    return this._duplexState &= this._readableState.readAhead === !1 ? 536739583 : 536870655, this;
  }
  static _fromAsyncIterator(t, e) {
    let n;
    const s = new Ct({ ...e, read(o) {
      t.next().then(r).then(o.bind(null, null)).catch(o);
    }, predestroy() {
      n = t.return();
    }, destroy(o) {
      if (!n) return o(null);
      n.then(o.bind(null, null)).catch(o);
    } });
    return s;
    function r(o) {
      o.done ? s.push(null) : s.push(o.value);
    }
  }
  static from(t, e) {
    if (yn(n = t) && n.readable) return t;
    var n;
    if (t[ot]) return this._fromAsyncIterator(t[ot](), e);
    Array.isArray(t) || (t = t === void 0 ? [] : [t]);
    let s = 0;
    return new Ct({ ...e, read(r) {
      this.push(s === t.length ? null : t[s++]), r(null);
    } });
  }
  static isBackpressured(t) {
    return !!(17422 & t._duplexState) || t._readableState.buffered >= t._readableState.highWaterMark;
  }
  static isPaused(t) {
    return !(t._duplexState & rn);
  }
  [ot]() {
    const t = this;
    let e = null, n = null, s = null;
    return this.on("error", (a) => {
      e = a;
    }), this.on("readable", function() {
      n !== null && r(t.read());
    }), this.on("close", function() {
      n !== null && r(null);
    }), { [ot]() {
      return this;
    }, next: () => new Promise(function(a, h) {
      n = a, s = h;
      const u = t.read();
      u !== null ? r(u) : 8 & t._duplexState && r(null);
    }), return: () => o(null), throw: (a) => o(a) };
    function r(a) {
      s !== null && (e ? s(e) : a !== null || t._duplexState & St ? n({ value: a, done: a === null }) : s(ie), s = n = null);
    }
    function o(a) {
      return t.destroy(a), new Promise((h, u) => {
        if (8 & t._duplexState) return h({ value: void 0, done: !0 });
        t.once("close", function() {
          a ? u(a) : h({ value: void 0, done: !0 });
        });
      });
    }
  }
}
class xs extends Ct {
  constructor(t) {
    super(t), this._duplexState = 1 | this._duplexState & Gt, this._writableState = new ps(this, t), t && (t.writev && (this._writev = t.writev), t.write && (this._write = t.write), t.final && (this._final = t.final));
  }
  cork() {
    this._duplexState |= cs;
  }
  uncork() {
    this._duplexState &= ls, this._writableState.updateNextTick();
  }
  _writev(t, e) {
    e(null);
  }
  _write(t, e) {
    this._writableState.autoBatch(t, e);
  }
  _final(t) {
    t(null);
  }
  write(t) {
    return this._writableState.updateNextTick(), this._writableState.push(t);
  }
  end(t) {
    return this._writableState.updateNextTick(), this._writableState.end(t), this;
  }
}
function As(i) {
  return i;
}
function Ls(i) {
  return !!i._readableState || !!i._writableState;
}
function yn(i) {
  return typeof i._duplexState == "number" && Ls(i);
}
function _n(i) {
  return function(t) {
    return typeof t == "object" && t !== null && typeof t.byteLength == "number";
  }(i) ? i.byteLength : 1024;
}
function Le() {
}
function Rs() {
  this.destroy(new Error("Stream aborted."));
}
var Sn = xs;
function Re(i, t) {
  for (const e in t) Object.defineProperty(i, e, { value: t[e], enumerable: !0, configurable: !0 });
  return i;
}
const y = W(function(i, t, e) {
  if (!i || typeof i == "string") throw new TypeError("Please pass an Error to err-code");
  e || (e = {}), typeof t == "object" && (e = t, t = ""), t && (e.code = t);
  try {
    return Re(i, e);
  } catch {
    e.message = i.message, e.stack = i.stack;
    const s = function() {
    };
    return s.prototype = Object.create(Object.getPrototypeOf(i)), Re(new s(), e);
  }
}), vt = "0123456789abcdef", wn = [], kt = [];
for (let i = 0; i < 256; i++) wn[i] = vt[i >> 4 & 15] + vt[15 & i], i < 16 && (i < 10 ? kt[48 + i] = i : kt[87 + i] = i);
const V = (i) => {
  const t = i.length;
  let e = "", n = 0;
  for (; n < t; ) e += wn[i[n++]];
  return e;
}, Vt = (i) => {
  const t = i.length >> 1, e = t << 1, n = new Uint8Array(t);
  let s = 0, r = 0;
  for (; r < e; ) n[s++] = kt[i.charCodeAt(r++)] << 4 | kt[i.charCodeAt(r++)];
  return n;
};
for (var Is = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Es = typeof Uint8Array > "u" ? [] : new Uint8Array(256), at = 0; at < 64; at++) Es[Is.charCodeAt(at)] = at;
const Ps = new TextDecoder(), bn = (i, t) => Ps.decode(i), qs = new TextEncoder(), re = (i) => qs.encode(i), Q = (i) => {
  let t, e = "", n = 0;
  const s = i.length;
  for (; n < s; ) t = i.charCodeAt(n++), e += vt[t >> 4] + vt[15 & t];
  return e;
}, tt = (i) => {
  const t = Vt(i);
  if (t.length <= 65536) return String.fromCharCode(...t);
  let e = "", n = 0;
  for (; n < t.length; ) e += String.fromCharCode(...t.subarray(n, n += 65536));
  return e;
}, Ie = typeof window < "u" ? window : self, Yt = Ie.crypto || Ie.msCrypto || {};
Yt.subtle || Yt.webkitSubtle;
const Tt = (i) => {
  const t = new Uint8Array(i);
  return Yt.getRandomValues(t);
}, Bs = L("simple-peer"), Ot = 65536;
function Ee(i) {
  return i.replace(/a=ice-options:trickle\s\n/g, "");
}
let et = class Kt extends Sn {
  constructor(e) {
    super(e = Object.assign({ allowHalfOpen: !1 }, e));
    d(this, "_pc");
    if (this.__objectMode = !!e.objectMode, this._id = V(Tt(4)).slice(0, 7), this._debug("new peer %o", e), this.channelName = e.initiator ? e.channelName || V(Tt(20)) : null, this.initiator = e.initiator || !1, this.channelConfig = e.channelConfig || Kt.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, Kt.config, e.config), this.offerOptions = e.offerOptions || {}, this.answerOptions = e.answerOptions || {}, this.sdpTransform = e.sdpTransform || ((n) => n), this.trickle = e.trickle === void 0 || e.trickle, this.allowHalfTrickle = e.allowHalfTrickle !== void 0 && e.allowHalfTrickle, this.iceCompleteTimeout = e.iceCompleteTimeout || 5e3, this._destroying = !1, this._connected = !1, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, !zt) throw y(typeof window > "u" ? new Error("No WebRTC support: Specify `opts.wrtc` option in this environment") : new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
    this._pcReady = !1, this._channelReady = !1, this._iceComplete = !1, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = !1, this._firstNegotiation = !0, this._batchedNegotiation = !1, this._queuedNegotiation = !1, this._sendersAwaitingStable = [], this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
    try {
      this._pc = new zt(this.config);
    } catch (n) {
      return void this.__destroy(y(n, "ERR_PC_CONSTRUCTOR"));
    }
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId == "number", this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange();
    }, this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange();
    }, this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange();
    }, this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange();
    }, this._pc.onicecandidate = (n) => {
      this._onIceCandidate(n);
    }, typeof this._pc.peerIdentity == "object" && this._pc.peerIdentity.catch((n) => {
      this.__destroy(y(n, "ERR_PC_PEER_IDENTITY"));
    }), this.initiator || this.channelNegotiated ? this._setupData({ channel: this._pc.createDataChannel(this.channelName, this.channelConfig) }) : this._pc.ondatachannel = (n) => {
      this._setupData(n);
    }, this._debug("initial negotiation"), this._needsNegotiation(), this._onFinishBound = () => {
      this._onFinish();
    }, this.once("finish", this._onFinishBound);
  }
  get bufferSize() {
    return this._channel && this._channel.bufferedAmount || 0;
  }
  get connected() {
    return this._connected && this._channel.readyState === "open";
  }
  address() {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress };
  }
  signal(e) {
    if (!this._destroying) {
      if (this.destroyed) throw y(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
      if (typeof e == "string") try {
        e = JSON.parse(e);
      } catch {
        e = {};
      }
      this._debug("signal()"), e.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e.transceiverRequest.kind, e.transceiverRequest.init)), e.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e.candidate) : this._pendingCandidates.push(e.candidate)), e.sdp && this._pc.setRemoteDescription(new Gn(e)).then(() => {
        this.destroyed || (this._pendingCandidates.forEach((n) => {
          this._addIceCandidate(n);
        }), this._pendingCandidates = [], this._pc.remoteDescription.type === "offer" && this._createAnswer());
      }).catch((n) => {
        this.__destroy(y(n, "ERR_SET_REMOTE_DESCRIPTION"));
      }), e.sdp || e.candidate || e.renegotiate || e.transceiverRequest || this.__destroy(y(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
    }
  }
  _addIceCandidate(e) {
    const n = new Jn(e);
    this._pc.addIceCandidate(n).catch((s) => {
      var r;
      !n.address || n.address.endsWith(".local") ? (r = "Ignoring unsupported ICE candidate.", console.warn(r)) : this.__destroy(y(s, "ERR_ADD_ICE_CANDIDATE"));
    });
  }
  send(e) {
    if (!this._destroying) {
      if (this.destroyed) throw y(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
      this._channel.send(e);
    }
  }
  _needsNegotiation() {
    this._debug("_needsNegotiation"), this._batchedNegotiation || (this._batchedNegotiation = !0, queueMicrotask(() => {
      this._batchedNegotiation = !1, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = !1;
    }));
  }
  negotiate() {
    if (!this._destroying) {
      if (this.destroyed) throw y(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
      this.initiator ? this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
        this._createOffer();
      }, 0)) : this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", { type: "renegotiate", renegotiate: !0 })), this._isNegotiating = !0;
    }
  }
  _final(e) {
    this._readableState.ended || this.push(null), e(null);
  }
  __destroy(e) {
    this.end(), this._destroy(() => {
    }, e);
  }
  _destroy(e, n) {
    this.destroyed || this._destroying || (this._destroying = !0, this._debug("destroying (error: %s)", n && (n.message || n)), setTimeout(() => {
      if (this._connected = !1, this._pcReady = !1, this._channelReady = !1, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
        try {
          this._channel.close();
        } catch {
        }
        this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
      }
      if (this._pc) {
        try {
          this._pc.close();
        } catch {
        }
        this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
      }
      this._pc = null, this._channel = null, n && this.emit("error", n), e();
    }, 0));
  }
  _setupData(e) {
    if (!e.channel) return this.__destroy(y(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
    this._channel = e.channel, this._channel.binaryType = "arraybuffer", typeof this._channel.bufferedAmountLowThreshold == "number" && (this._channel.bufferedAmountLowThreshold = Ot), this.channelName = this._channel.label, this._channel.onmessage = (s) => {
      this._onChannelMessage(s);
    }, this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow();
    }, this._channel.onopen = () => {
      this._onChannelOpen();
    }, this._channel.onclose = () => {
      this._onChannelClose();
    }, this._channel.onerror = (s) => {
      const r = s.error instanceof Error ? s.error : new Error(`Datachannel error: ${s.message} ${s.filename}:${s.lineno}:${s.colno}`);
      this.__destroy(y(r, "ERR_DATA_CHANNEL"));
    };
    let n = !1;
    this._closingInterval = setInterval(() => {
      this._channel && this._channel.readyState === "closing" ? (n && this._onChannelClose(), n = !0) : n = !1;
    }, 5e3);
  }
  _write(e, n) {
    if (this.destroyed) return n(y(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
    if (this._connected) {
      try {
        this.send(e);
      } catch (s) {
        return this.__destroy(y(s, "ERR_DATA_CHANNEL"));
      }
      this._channel.bufferedAmount > Ot ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = n) : n(null);
    } else this._debug("write before connect"), this._chunk = e, this._cb = n;
  }
  _onFinish() {
    if (this.destroyed) return;
    const e = () => {
      setTimeout(() => this.__destroy(), 1e3);
    };
    this._connected ? e() : this.once("connect", e);
  }
  _startIceCompleteTimeout() {
    this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
      this._iceComplete || (this._iceComplete = !0, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"));
    }, this.iceCompleteTimeout));
  }
  _createOffer() {
    this.destroyed || this._pc.createOffer(this.offerOptions).then((e) => {
      if (this.destroyed) return;
      this.trickle || this.allowHalfTrickle || (e.sdp = Ee(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
      const n = () => {
        if (this.destroyed) return;
        const s = this._pc.localDescription || e;
        this._debug("signal"), this.emit("signal", { type: s.type, sdp: s.sdp });
      };
      this._pc.setLocalDescription(e).then(() => {
        this._debug("createOffer success"), this.destroyed || (this.trickle || this._iceComplete ? n() : this.once("_iceComplete", n));
      }).catch((s) => {
        this.__destroy(y(s, "ERR_SET_LOCAL_DESCRIPTION"));
      });
    }).catch((e) => {
      this.__destroy(y(e, "ERR_CREATE_OFFER"));
    });
  }
  _createAnswer() {
    this.destroyed || this._pc.createAnswer(this.answerOptions).then((e) => {
      if (this.destroyed) return;
      this.trickle || this.allowHalfTrickle || (e.sdp = Ee(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
      const n = () => {
        var r;
        if (this.destroyed) return;
        const s = this._pc.localDescription || e;
        this._debug("signal"), this.emit("signal", { type: s.type, sdp: s.sdp }), this.initiator || ((r = this._requestMissingTransceivers) == null || r.call(this));
      };
      this._pc.setLocalDescription(e).then(() => {
        this.destroyed || (this.trickle || this._iceComplete ? n() : this.once("_iceComplete", n));
      }).catch((s) => {
        this.__destroy(y(s, "ERR_SET_LOCAL_DESCRIPTION"));
      });
    }).catch((e) => {
      this.__destroy(y(e, "ERR_CREATE_ANSWER"));
    });
  }
  _onConnectionStateChange() {
    this.destroyed || this._destroying || this._pc.connectionState === "failed" && this.__destroy(y(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
  }
  _onIceStateChange() {
    if (this.destroyed) return;
    const e = this._pc.iceConnectionState, n = this._pc.iceGatheringState;
    this._debug("iceStateChange (connection: %s) (gathering: %s)", e, n), this.emit("iceStateChange", e, n), e !== "connected" && e !== "completed" || (this._pcReady = !0, this._maybeReady()), e === "failed" && this.__destroy(y(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), e === "closed" && this.__destroy(y(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
  }
  getStats(e) {
    const n = (s) => (Object.prototype.toString.call(s.values) === "[object Array]" && s.values.forEach((r) => {
      Object.assign(s, r);
    }), s);
    this._pc.getStats.length === 0 || this._isReactNativeWebrtc ? this._pc.getStats().then((s) => {
      const r = [];
      s.forEach((o) => {
        r.push(n(o));
      }), e(null, r);
    }, (s) => e(s)) : this._pc.getStats.length > 0 ? this._pc.getStats((s) => {
      if (this.destroyed) return;
      const r = [];
      s.result().forEach((o) => {
        const a = {};
        o.names().forEach((h) => {
          a[h] = o.stat(h);
        }), a.id = o.id, a.type = o.type, a.timestamp = o.timestamp, r.push(n(a));
      }), e(null, r);
    }, (s) => e(s)) : e(null, []);
  }
  _maybeReady() {
    if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady) return;
    this._connecting = !0;
    const e = () => {
      this.destroyed || this._destroying || this.getStats((n, s) => {
        if (this.destroyed || this._destroying) return;
        n && (s = []);
        const r = {}, o = {}, a = {};
        let h = !1;
        s.forEach((c) => {
          c.type !== "remotecandidate" && c.type !== "remote-candidate" || (r[c.id] = c), c.type !== "localcandidate" && c.type !== "local-candidate" || (o[c.id] = c), c.type !== "candidatepair" && c.type !== "candidate-pair" || (a[c.id] = c);
        });
        const u = (c) => {
          h = !0;
          let l = o[c.localCandidateId];
          l && (l.ip || l.address) ? (this.localAddress = l.ip || l.address, this.localPort = Number(l.port)) : l && l.ipAddress ? (this.localAddress = l.ipAddress, this.localPort = Number(l.portNumber)) : typeof c.googLocalAddress == "string" && (l = c.googLocalAddress.split(":"), this.localAddress = l[0], this.localPort = Number(l[1])), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
          let g = r[c.remoteCandidateId];
          g && (g.ip || g.address) ? (this.remoteAddress = g.ip || g.address, this.remotePort = Number(g.port)) : g && g.ipAddress ? (this.remoteAddress = g.ipAddress, this.remotePort = Number(g.portNumber)) : typeof c.googRemoteAddress == "string" && (g = c.googRemoteAddress.split(":"), this.remoteAddress = g[0], this.remotePort = Number(g[1])), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
        };
        if (s.forEach((c) => {
          c.type === "transport" && c.selectedCandidatePairId && u(a[c.selectedCandidatePairId]), (c.type === "googCandidatePair" && c.googActiveConnection === "true" || (c.type === "candidatepair" || c.type === "candidate-pair") && c.selected) && u(c);
        }), h || Object.keys(a).length && !Object.keys(o).length) {
          if (this._connecting = !1, this._connected = !0, this._chunk) {
            try {
              this.send(this._chunk);
            } catch (l) {
              return this.__destroy(y(l, "ERR_DATA_CHANNEL"));
            }
            this._chunk = null, this._debug('sent chunk from "write before connect"');
            const c = this._cb;
            this._cb = null, c(null);
          }
          typeof this._channel.bufferedAmountLowThreshold != "number" && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
        } else setTimeout(e, 100);
      });
    };
    e();
  }
  _onInterval() {
    !this._cb || !this._channel || this._channel.bufferedAmount > Ot || this._onChannelBufferedAmountLow();
  }
  _onSignalingStateChange() {
    this.destroyed || (this._pc.signalingState === "stable" && (this._isNegotiating = !1, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((e) => {
      this._pc.removeTrack(e), this._queuedNegotiation = !0;
    }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = !1, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState));
  }
  _onIceCandidate(e) {
    this.destroyed || (e.candidate && this.trickle ? this.emit("signal", { type: "candidate", candidate: { candidate: e.candidate.candidate, sdpMLineIndex: e.candidate.sdpMLineIndex, sdpMid: e.candidate.sdpMid } }) : e.candidate || this._iceComplete || (this._iceComplete = !0, this.emit("_iceComplete")), e.candidate && this._startIceCompleteTimeout());
  }
  _onChannelMessage(e) {
    if (this.destroyed) return;
    let n = e.data;
    n instanceof ArrayBuffer ? n = new Uint8Array(n) : this.__objectMode === !1 && (n = re(n)), this.push(n);
  }
  _onChannelBufferedAmountLow() {
    if (this.destroyed || !this._cb) return;
    this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
    const e = this._cb;
    this._cb = null, e(null);
  }
  _onChannelOpen() {
    this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = !0, this._maybeReady());
  }
  _onChannelClose() {
    this.destroyed || (this._debug("on channel close"), this.__destroy());
  }
  _debug() {
    const e = [].slice.call(arguments);
    e[0] = "[" + this._id + "] " + e[0], Bs.apply(null, e);
  }
};
et.WEBRTC_SUPPORT = !!zt, et.config = { iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"] }], sdpSemantics: "unified-plan" }, et.channelConfig = {};
const A = {}, Zt = { DEFAULT_ANNOUNCE_PEERS: 50, MAX_ANNOUNCE_PEERS: 82, parseUrl: (i) => {
  const t = new URL(i.replace(/^udp:/, "http:"));
  return i.match(/^udp:/) && Object.defineProperties(t, { href: { value: t.href.replace(/^http/, "udp") }, protocol: { value: t.protocol.replace(/^http/, "udp") }, origin: { value: t.origin.replace(/^http/, "udp") } }), t;
}, ...Object.freeze(Object.defineProperty({ __proto__: null, default: A }, Symbol.toStringTag, { value: "Module" })) }, Os = L("simple-websocket"), Z = typeof A != "function" ? WebSocket : A;
class Cn extends Sn {
  constructor(t = {}) {
    if (typeof t == "string" && (t = { url: t }), super(t = Object.assign({ allowHalfOpen: !1 }, t)), this.__objectMode = !!t.objectMode, t.objectMode != null && delete t.objectMode, t.url == null && t.socket == null) throw new Error("Missing required `url` or `socket` option");
    if (t.url != null && t.socket != null) throw new Error("Must specify either `url` or `socket` option, not both");
    if (this._id = V(Tt(4)).slice(0, 7), this._debug("new websocket: %o", t), this.connected = !1, this._chunk = null, this._cb = null, this._interval = null, t.socket) this.url = t.socket.url, this._ws = t.socket, this.connected = t.socket.readyState === Z.OPEN;
    else {
      this.url = t.url;
      try {
        this._ws = typeof A == "function" ? new Z(t.url, { ...t, encoding: void 0 }) : new Z(t.url);
      } catch (e) {
        return void Qt(() => this.destroy(e));
      }
    }
    this._ws.binaryType = "arraybuffer", t.socket && this.connected ? Qt(() => this._handleOpen()) : this._ws.onopen = () => this._handleOpen(), this._ws.onmessage = (e) => this._handleMessage(e), this._ws.onclose = () => this._handleClose(), this._ws.onerror = (e) => this._handleError(e), this._handleFinishBound = () => this._handleFinish(), this.once("finish", this._handleFinishBound);
  }
  send(t) {
    this._ws.send(t);
  }
  _final(t) {
    this._readableState.ended || this.push(null), t(null);
  }
  _destroy(t) {
    if (!this.destroyed) {
      if (this._writableState.ended || this.end(), this.connected = !1, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._handleFinishBound && this.removeListener("finish", this._handleFinishBound), this._handleFinishBound = null, this._ws) {
        const e = this._ws, n = () => {
          e.onclose = null;
        };
        if (e.readyState === Z.CLOSED) n();
        else try {
          e.onclose = n, e.close();
        } catch {
          n();
        }
        e.onopen = null, e.onmessage = null, e.onerror = () => {
        };
      }
      this._ws = null, t();
    }
  }
  _write(t, e) {
    if (this.destroyed) return e(new Error("cannot write after socket is destroyed"));
    if (this.connected) {
      try {
        this.send(t);
      } catch (n) {
        return this.destroy(n);
      }
      typeof A != "function" && this._ws.bufferedAmount > 65536 ? (this._debug("start backpressure: bufferedAmount %d", this._ws.bufferedAmount), this._cb = e) : e(null);
    } else this._debug("write before connect"), this._chunk = t, this._cb = e;
  }
  _handleOpen() {
    if (!this.connected && !this.destroyed) {
      if (this.connected = !0, this._chunk) {
        try {
          this.send(this._chunk);
        } catch (e) {
          return this.destroy(e);
        }
        this._chunk = null, this._debug('sent chunk from "write before connect"');
        const t = this._cb;
        this._cb = null, t(null);
      }
      typeof A != "function" && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
    }
  }
  _handleMessage(t) {
    if (this.destroyed) return;
    let e = t.data;
    e instanceof ArrayBuffer && (e = new Uint8Array(e)), this.__objectMode === !1 && (e = re(e)), this.push(e);
  }
  _handleClose() {
    this.destroyed || (this._debug("on close"), this.destroy());
  }
  _handleError(t) {
    this.destroy(new Error(`Error connecting to ${this.url}`));
  }
  _handleFinish() {
    if (this.destroyed) return;
    const t = () => {
      setTimeout(() => this.destroy(), 1e3);
    };
    this.connected ? t() : this.once("connect", t);
  }
  _onInterval() {
    if (!this._cb || !this._ws || this._ws.bufferedAmount > 65536) return;
    this._debug("ending backpressure: bufferedAmount %d", this._ws.bufferedAmount);
    const t = this._cb;
    this._cb = null, t(null);
  }
  _debug() {
    const t = [].slice.call(arguments);
    t[0] = "[" + this._id + "] " + t[0], Os.apply(null, t);
  }
}
Cn.WEBSOCKET_SUPPORT = !!Z;
class Ds extends Ke {
  constructor(t, e) {
    super(), this.client = t, this.announceUrl = e, this.interval = null, this.destroyed = !1;
  }
  setInterval(t) {
    t == null && (t = this.DEFAULT_ANNOUNCE_INTERVAL), clearInterval(this.interval), t && (this.interval = setInterval(() => {
      this.announce(this.client._defaultAnnounceOpts());
    }, t), this.interval.unref && this.interval.unref());
  }
}
const T = L("bittorrent-tracker:websocket-tracker"), I = {};
class Xt extends Ds {
  constructor(t, e) {
    super(t, e), T("new websocket tracker %s", e), this.peers = {}, this.socket = null, this.reconnecting = !1, this.retries = 0, this.reconnectTimer = null, this.expectingResponse = !1, this._openSocket();
  }
  announce(t) {
    if (this.destroyed || this.reconnecting) return;
    if (!this.socket.connected) return void this.socket.once("connect", () => {
      this.announce(t);
    });
    const e = Object.assign({}, t, { action: "announce", info_hash: this.client._infoHashBinary, peer_id: this.client._peerIdBinary });
    if (this._trackerId && (e.trackerid = this._trackerId), t.event === "stopped" || t.event === "completed") this._send(e);
    else {
      const n = Math.min(t.numwant, 5);
      this._generateOffers(n, (s) => {
        e.numwant = n, e.offers = s, this._send(e);
      });
    }
  }
  scrape(t) {
    if (this.destroyed || this.reconnecting) return;
    if (!this.socket.connected) return void this.socket.once("connect", () => {
      this.scrape(t);
    });
    const e = { action: "scrape", info_hash: Array.isArray(t.infoHash) && t.infoHash.length > 0 ? t.infoHash.map((n) => tt(n)) : t.infoHash && tt(t.infoHash) || this.client._infoHashBinary };
    this._send(e);
  }
  destroy(t = Pe) {
    if (this.destroyed) return t(null);
    this.destroyed = !0, clearInterval(this.interval), clearTimeout(this.reconnectTimer);
    for (const r in this.peers) {
      const o = this.peers[r];
      clearTimeout(o.trackerTimeout), o.destroy();
    }
    if (this.peers = null, this.socket && (this.socket.removeListener("connect", this._onSocketConnectBound), this.socket.removeListener("data", this._onSocketDataBound), this.socket.removeListener("close", this._onSocketCloseBound), this.socket.removeListener("error", this._onSocketErrorBound), this.socket = null), this._onSocketConnectBound = null, this._onSocketErrorBound = null, this._onSocketDataBound = null, this._onSocketCloseBound = null, I[this.announceUrl] && (I[this.announceUrl].consumers -= 1), I[this.announceUrl].consumers > 0) return t();
    let e, n = I[this.announceUrl];
    if (delete I[this.announceUrl], n.on("error", Pe), n.once("close", t), !this.expectingResponse) return s();
    function s() {
      e && (clearTimeout(e), e = null), n.removeListener("data", s), n.destroy(), n = null;
    }
    e = setTimeout(s, Zt.DESTROY_TIMEOUT), n.once("data", s);
  }
  _openSocket() {
    if (this.destroyed = !1, this.peers || (this.peers = {}), this._onSocketConnectBound = () => {
      this._onSocketConnect();
    }, this._onSocketErrorBound = (t) => {
      this._onSocketError(t);
    }, this._onSocketDataBound = (t) => {
      this._onSocketData(t);
    }, this._onSocketCloseBound = () => {
      this._onSocketClose();
    }, this.socket = I[this.announceUrl], this.socket) I[this.announceUrl].consumers += 1, this.socket.connected && this._onSocketConnectBound();
    else {
      const t = new URL(this.announceUrl);
      let e;
      this.client._proxyOpts && (e = t.protocol === "wss:" ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent, !e && this.client._proxyOpts.socksProxy && (e = this.client._proxyOpts.socksProxy)), this.socket = I[this.announceUrl] = new Cn({ url: this.announceUrl, agent: e }), this.socket.consumers = 1, this.socket.once("connect", this._onSocketConnectBound);
    }
    this.socket.on("data", this._onSocketDataBound), this.socket.once("close", this._onSocketCloseBound), this.socket.once("error", this._onSocketErrorBound);
  }
  _onSocketConnect() {
    this.destroyed || this.reconnecting && (this.reconnecting = !1, this.retries = 0, this.announce(this.client._defaultAnnounceOpts()));
  }
  _onSocketData(t) {
    if (!this.destroyed) {
      this.expectingResponse = !1;
      try {
        t = JSON.parse(bn(t));
      } catch {
        return void this.client.emit("warning", new Error("Invalid tracker response"));
      }
      t.action === "announce" ? this._onAnnounceResponse(t) : t.action === "scrape" ? this._onScrapeResponse(t) : this._onSocketError(new Error(`invalid action in WS response: ${t.action}`));
    }
  }
  _onAnnounceResponse(t) {
    if (t.info_hash !== this.client._infoHashBinary) return void T("ignoring websocket data from %s for %s (looking for %s: reused socket)", this.announceUrl, Q(t.info_hash), this.client.infoHash);
    if (t.peer_id && t.peer_id === this.client._peerIdBinary) return;
    T("received %s from %s for %s", JSON.stringify(t), this.announceUrl, this.client.infoHash);
    const e = t["failure reason"];
    if (e) return this.client.emit("warning", new Error(e));
    const n = t["warning message"];
    n && this.client.emit("warning", new Error(n));
    const s = t.interval || t["min interval"];
    s && this.setInterval(1e3 * s);
    const r = t["tracker id"];
    if (r && (this._trackerId = r), t.complete != null) {
      const a = Object.assign({}, t, { announce: this.announceUrl, infoHash: Q(t.info_hash) });
      this.client.emit("update", a);
    }
    let o;
    if (t.offer && t.peer_id && (T("creating peer (from remote offer)"), o = this._createPeer(), o.id = Q(t.peer_id), o.once("signal", (a) => {
      const h = { action: "announce", info_hash: this.client._infoHashBinary, peer_id: this.client._peerIdBinary, to_peer_id: t.peer_id, answer: a, offer_id: t.offer_id };
      this._trackerId && (h.trackerid = this._trackerId), this._send(h);
    }), this.client.emit("peer", o), o.signal(t.offer)), t.answer && t.peer_id) {
      const a = Q(t.offer_id);
      o = this.peers[a], o ? (o.id = Q(t.peer_id), this.client.emit("peer", o), o.signal(t.answer), clearTimeout(o.trackerTimeout), o.trackerTimeout = null, delete this.peers[a]) : T(`got unexpected answer: ${JSON.stringify(t.answer)}`);
    }
  }
  _onScrapeResponse(t) {
    t = t.files || {};
    const e = Object.keys(t);
    e.length !== 0 ? e.forEach((n) => {
      const s = Object.assign(t[n], { announce: this.announceUrl, infoHash: Q(n) });
      this.client.emit("scrape", s);
    }) : this.client.emit("warning", new Error("invalid scrape response"));
  }
  _onSocketClose() {
    this.destroyed || (this.destroy(), this._startReconnectTimer());
  }
  _onSocketError(t) {
    this.destroyed || (this.destroy(), this.client.emit("warning", t), this._startReconnectTimer());
  }
  _startReconnectTimer() {
    const t = Math.floor(3e5 * Math.random()) + Math.min(1e4 * Math.pow(2, this.retries), 36e5);
    this.reconnecting = !0, clearTimeout(this.reconnectTimer), this.reconnectTimer = setTimeout(() => {
      this.retries++, this._openSocket();
    }, t), this.reconnectTimer.unref && this.reconnectTimer.unref(), T("reconnecting socket in %s ms", t);
  }
  _send(t) {
    if (this.destroyed) return;
    this.expectingResponse = !0;
    const e = JSON.stringify(t);
    T("send %s", e), this.socket.send(e);
  }
  _generateOffers(t, e) {
    const n = this, s = [];
    T("generating %s offers", t);
    for (let a = 0; a < t; ++a) r();
    function r() {
      const a = V(Tt(20));
      T("creating peer (from _generateOffers)");
      const h = n.peers[a] = n._createPeer({ initiator: !0 });
      h.once("signal", (u) => {
        s.push({ offer: u, offer_id: tt(a) }), o();
      }), h.trackerTimeout = setTimeout(() => {
        T("tracker timeout: destroying peer"), h.trackerTimeout = null, delete n.peers[a], h.destroy();
      }, 5e4), h.trackerTimeout.unref && h.trackerTimeout.unref();
    }
    function o() {
      s.length === t && (T("generated %s offers", t), e(s));
    }
    o();
  }
  _createPeer(t) {
    const e = this;
    t = Object.assign({ trickle: !1, config: e.client._rtcConfig, wrtc: e.client._wrtc }, t);
    const n = new et(t);
    return n.once("error", s), n.once("connect", function r() {
      n.removeListener("error", s), n.removeListener("connect", r);
    }), n;
    function s(r) {
      e.client.emit("warning", new Error(`Connection error: ${r.message}`)), n.destroy();
    }
  }
}
function Pe() {
}
Xt.prototype.DEFAULT_ANNOUNCE_INTERVAL = 3e4, Xt._socketPool = I;
const M = L("bittorrent-tracker:client");
class te extends Ke {
  constructor(t = {}) {
    if (super(), !t.peerId) throw new Error("Option `peerId` is required");
    if (!t.infoHash) throw new Error("Option `infoHash` is required");
    if (!t.announce) throw new Error("Option `announce` is required");
    if (!ft.browser && !t.port) throw new Error("Option `port` is required");
    this.peerId = typeof t.peerId == "string" ? t.peerId : V(t.peerId), this._peerIdBuffer = Vt(this.peerId), this._peerIdBinary = tt(this.peerId), this.infoHash = typeof t.infoHash == "string" ? t.infoHash.toLowerCase() : V(t.infoHash), this._infoHashBuffer = Vt(this.infoHash), this._infoHashBinary = tt(this.infoHash), M("new client %s", this.infoHash), this.destroyed = !1, this._port = t.port, this._getAnnounceOpts = t.getAnnounceOpts, this._rtcConfig = t.rtcConfig, this._userAgent = t.userAgent, this._proxyOpts = t.proxyOpts, this._wrtc = typeof t.wrtc == "function" ? t.wrtc() : t.wrtc;
    let e = typeof t.announce == "string" ? [t.announce] : t.announce == null ? [] : t.announce;
    e = e.map((r) => (ArrayBuffer.isView(r) && (r = bn(r)), r[r.length - 1] === "/" && (r = r.substring(0, r.length - 1)), r)), e = Array.from(new Set(e));
    const n = this._wrtc !== !1 && (!!this._wrtc || et.WEBRTC_SUPPORT), s = (r) => {
      Qt(() => {
        this.emit("warning", r);
      });
    };
    this._trackers = e.map((r) => {
      let o;
      try {
        o = Zt.parseUrl(r);
      } catch {
        return s(new Error(`Invalid tracker URL: ${r}`)), null;
      }
      const a = o.port;
      if (a < 0 || a > 65535) return s(new Error(`Invalid tracker port: ${r}`)), null;
      const h = o.protocol;
      return h !== "http:" && h !== "https:" || typeof A != "function" ? h === "udp:" && typeof A == "function" ? new A(this, r) : h !== "ws:" && h !== "wss:" || !n || h === "ws:" && typeof window < "u" && window.location.protocol === "https:" ? (s(new Error(`Unsupported tracker protocol: ${r}`)), null) : new Xt(this, r) : new A(this, r);
    }).filter(Boolean);
  }
  start(t) {
    (t = this._defaultAnnounceOpts(t)).event = "started", M("send `start` %o", t), this._announce(t), this._trackers.forEach((e) => {
      e.setInterval();
    });
  }
  stop(t) {
    (t = this._defaultAnnounceOpts(t)).event = "stopped", M("send `stop` %o", t), this._announce(t);
  }
  complete(t) {
    t || (t = {}), (t = this._defaultAnnounceOpts(t)).event = "completed", M("send `complete` %o", t), this._announce(t);
  }
  update(t) {
    (t = this._defaultAnnounceOpts(t)).event && delete t.event, M("send `update` %o", t), this._announce(t);
  }
  _announce(t) {
    this._trackers.forEach((e) => {
      e.announce(t);
    });
  }
  scrape(t) {
    M("send `scrape`"), t || (t = {}), this._trackers.forEach((e) => {
      e.scrape(t);
    });
  }
  setInterval(t) {
    M("setInterval %d", t), this._trackers.forEach((e) => {
      e.setInterval(t);
    });
  }
  destroy(t) {
    if (this.destroyed) return;
    this.destroyed = !0, M("destroy");
    const e = this._trackers.map((n) => (s) => {
      n.destroy(s);
    });
    zn(e, t), this._trackers = [], this._getAnnounceOpts = null;
  }
  _defaultAnnounceOpts(t = {}) {
    return t.numwant == null && (t.numwant = Zt.DEFAULT_ANNOUNCE_PEERS), t.uploaded == null && (t.uploaded = 0), t.downloaded == null && (t.downloaded = 0), this._getAnnounceOpts && (t = Object.assign({}, t, this._getAnnounceOpts())), t;
  }
}
te.scrape = (i, t) => {
  if (t = jn(t), !i.infoHash) throw new Error("Option `infoHash` is required");
  if (!i.announce) throw new Error("Option `announce` is required");
  const e = Object.assign({}, i, { infoHash: Array.isArray(i.infoHash) ? i.infoHash[0] : i.infoHash, peerId: re("01234567890123456789"), port: 6881 }), n = new te(e);
  n.once("error", t), n.once("warning", t);
  let s = Array.isArray(i.infoHash) ? i.infoHash.length : 1;
  const r = {};
  return n.on("scrape", (o) => {
    if (s -= 1, r[o.infoHash] = o, s === 0) {
      n.destroy();
      const a = Object.keys(r);
      a.length === 1 ? t(null, r[a[0]]) : t(null, r);
    }
  }), n.scrape({ infoHash: i.infoHash }), n;
};
var vn = { exports: {} };
function S(i, t, e, n, s, r, o) {
  var a = i + (t & e | ~t & n) + (s >>> 0) + o;
  return (a << r | a >>> 32 - r) + t;
}
function w(i, t, e, n, s, r, o) {
  var a = i + (t & n | e & ~n) + (s >>> 0) + o;
  return (a << r | a >>> 32 - r) + t;
}
function b(i, t, e, n, s, r, o) {
  var a = i + (t ^ e ^ n) + (s >>> 0) + o;
  return (a << r | a >>> 32 - r) + t;
}
function C(i, t, e, n, s, r, o) {
  var a = i + (e ^ (t | ~n)) + (s >>> 0) + o;
  return (a << r | a >>> 32 - r) + t;
}
function ht(i) {
  return String.fromCharCode(255 & i);
}
function ct(i) {
  return ht(i) + ht(i >>> 8) + ht(i >>> 16) + ht(i >>> 24);
}
var ee = function(i) {
  return unescape(encodeURIComponent(i));
}, Rt = vn.exports = function(i) {
  return Ms(i).toHex();
}, _t = Rt.fromBytes = function(i) {
  for (var t = function(m) {
    for (var f = m.length, v = f << 3, H = new Uint32Array(f + 72 >>> 6 << 4), D = 0, Et = m.length; D < Et; ++D) H[D >>> 2] |= m.charCodeAt(D) << ((3 & D) << 3);
    return H[f >> 2] |= 128 << (31 & v), H[H.length - 2] = v, H;
  }(i), e = 1732584193, n = 4023233417, s = 2562383102, r = 271733878, o = 0, a = t.length; o < a; o += 16) {
    var h = e, u = n, c = s, l = r;
    e = S(e, n, s, r, t[o + 0], 7, 3614090360), r = S(r, e, n, s, t[o + 1], 12, 3905402710), s = S(s, r, e, n, t[o + 2], 17, 606105819), n = S(n, s, r, e, t[o + 3], 22, 3250441966), e = S(e, n, s, r, t[o + 4], 7, 4118548399), r = S(r, e, n, s, t[o + 5], 12, 1200080426), s = S(s, r, e, n, t[o + 6], 17, 2821735955), n = S(n, s, r, e, t[o + 7], 22, 4249261313), e = S(e, n, s, r, t[o + 8], 7, 1770035416), r = S(r, e, n, s, t[o + 9], 12, 2336552879), s = S(s, r, e, n, t[o + 10], 17, 4294925233), n = S(n, s, r, e, t[o + 11], 22, 2304563134), e = S(e, n, s, r, t[o + 12], 7, 1804603682), r = S(r, e, n, s, t[o + 13], 12, 4254626195), s = S(s, r, e, n, t[o + 14], 17, 2792965006), e = w(e, n = S(n, s, r, e, t[o + 15], 22, 1236535329), s, r, t[o + 1], 5, 4129170786), r = w(r, e, n, s, t[o + 6], 9, 3225465664), s = w(s, r, e, n, t[o + 11], 14, 643717713), n = w(n, s, r, e, t[o + 0], 20, 3921069994), e = w(e, n, s, r, t[o + 5], 5, 3593408605), r = w(r, e, n, s, t[o + 10], 9, 38016083), s = w(s, r, e, n, t[o + 15], 14, 3634488961), n = w(n, s, r, e, t[o + 4], 20, 3889429448), e = w(e, n, s, r, t[o + 9], 5, 568446438), r = w(r, e, n, s, t[o + 14], 9, 3275163606), s = w(s, r, e, n, t[o + 3], 14, 4107603335), n = w(n, s, r, e, t[o + 8], 20, 1163531501), e = w(e, n, s, r, t[o + 13], 5, 2850285829), r = w(r, e, n, s, t[o + 2], 9, 4243563512), s = w(s, r, e, n, t[o + 7], 14, 1735328473), e = b(e, n = w(n, s, r, e, t[o + 12], 20, 2368359562), s, r, t[o + 5], 4, 4294588738), r = b(r, e, n, s, t[o + 8], 11, 2272392833), s = b(s, r, e, n, t[o + 11], 16, 1839030562), n = b(n, s, r, e, t[o + 14], 23, 4259657740), e = b(e, n, s, r, t[o + 1], 4, 2763975236), r = b(r, e, n, s, t[o + 4], 11, 1272893353), s = b(s, r, e, n, t[o + 7], 16, 4139469664), n = b(n, s, r, e, t[o + 10], 23, 3200236656), e = b(e, n, s, r, t[o + 13], 4, 681279174), r = b(r, e, n, s, t[o + 0], 11, 3936430074), s = b(s, r, e, n, t[o + 3], 16, 3572445317), n = b(n, s, r, e, t[o + 6], 23, 76029189), e = b(e, n, s, r, t[o + 9], 4, 3654602809), r = b(r, e, n, s, t[o + 12], 11, 3873151461), s = b(s, r, e, n, t[o + 15], 16, 530742520), e = C(e, n = b(n, s, r, e, t[o + 2], 23, 3299628645), s, r, t[o + 0], 6, 4096336452), r = C(r, e, n, s, t[o + 7], 10, 1126891415), s = C(s, r, e, n, t[o + 14], 15, 2878612391), n = C(n, s, r, e, t[o + 5], 21, 4237533241), e = C(e, n, s, r, t[o + 12], 6, 1700485571), r = C(r, e, n, s, t[o + 3], 10, 2399980690), s = C(s, r, e, n, t[o + 10], 15, 4293915773), n = C(n, s, r, e, t[o + 1], 21, 2240044497), e = C(e, n, s, r, t[o + 8], 6, 1873313359), r = C(r, e, n, s, t[o + 15], 10, 4264355552), s = C(s, r, e, n, t[o + 6], 15, 2734768916), n = C(n, s, r, e, t[o + 13], 21, 1309151649), e = C(e, n, s, r, t[o + 4], 6, 4149444226), r = C(r, e, n, s, t[o + 11], 10, 3174756917), s = C(s, r, e, n, t[o + 2], 15, 718787259), n = C(n, s, r, e, t[o + 9], 21, 3951481745), e = e + h >>> 0, n = n + u >>> 0, s = s + c >>> 0, r = r + l >>> 0;
  }
  var g = new String(ct(e) + ct(n) + ct(s) + ct(r));
  return g.toHex = function() {
    for (var m = "", f = 0, v = g.length; f < v; ++f) m += (256 + (255 & g.charCodeAt(f))).toString(16).substr(-2);
    return m;
  }, g;
}, Ms = Rt.fromUtf8 = function(i) {
  return _t(ee(i));
}, kn = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
function qe(i, t) {
  for (var e = ""; --t >= 0; i >>>= 6) e += kn.charAt(63 & i);
  return e;
}
var dt = [0, 6, 12, 1, 7, 13, 2, 8, 14, 3, 9, 15, 4, 10, 5, 11], Ns = Rt.salt = function(i) {
  var t = "";
  i || (i = 8);
  do
    t += kn.charAt(64 * Math.random() >>> 0);
  while (--i);
  return t;
};
Rt.crypt = function(i, t) {
  if (i.length > 64) throw Error("too long key");
  t || (t = "$1$" + Ns()), i = ee(i);
  for (var e = ee(t.replace(/^\$1\$([^$]+)(?:\$.*)?$/, "$1")), n = _t(i + e + i), s = i + "$1$" + e, r = i.length; r > 16; r -= 16) s += n;
  for (s += n.slice(0, r), r = i.length; r; r >>= 1) s += 1 & r ? "\0" : i.charAt(0);
  n = _t(s);
  for (var o = 0; o < 1e3; ++o) n = _t((1 & o ? i : n) + (o % 3 ? e : "") + (o % 7 ? i : "") + (1 & o ? n : i));
  var a = "$1$" + e + "$";
  for (o = 0; o < 15; o += 3) a += qe(n.charCodeAt(dt[o + 0]) << 16 | n.charCodeAt(dt[o + 1]) << 8 | n.charCodeAt(dt[o + 2]), 4);
  return a + qe(n.charCodeAt(dt[15]), 2);
};
const Us = W(vn.exports), Fs = `-PM${function(i) {
  const t = i.split(".");
  return `${t[0].padStart(2, "0")}${t[1].padStart(2, "0")}`;
}("2.1.0")}-`, Hs = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
function F(i) {
  return `${i.type}-${i.index}`;
}
function Be(i) {
  const { externalId: t } = i;
  return `(${F(i.stream)} | ${t})`;
}
function Tn(i, t) {
  t === void 0 && (t = i.reduce((s, r) => s + r.byteLength, 0));
  const e = new Uint8Array(t);
  let n = 0;
  for (const s of i) e.set(s, n), n += s.byteLength;
  return e;
}
function Oe(i) {
  const t = new TextEncoder(), e = new Uint8Array(i.length);
  return t.encodeInto(i, e), e;
}
function* De(i) {
  for (let t = i.length - 1; t >= 0; t--) yield i[t];
}
function xn(i) {
  return !!i && typeof i == "object" && !Array.isArray(i);
}
function U(i) {
  if (function(t) {
    return Array.isArray(t);
  }(i)) return i.map((t) => U(t));
  if (xn(i)) {
    const t = {};
    for (const e of Object.keys(i)) t[e] = U(i[e]);
    return t;
  }
  return i;
}
function K(i, t, e = {}) {
  return typeof i != "object" || i === null || typeof t != "object" || t === null || Object.keys(t).forEach((n) => {
    if (n === "__proto__" || n === "constructor" || n === "prototype") throw new Error(`Attempt to modify restricted property '${String(n)}'`);
    const s = t[n], r = e[n];
    n in i && (i[n] = s === void 0 ? r === void 0 ? void 0 : r : s);
  }), i;
}
function Dt(i) {
  const { defaultConfig: t, baseConfig: e = {}, specificStreamConfig: n = {} } = i, s = U({ ...t, ...e, ...n }), r = Object.keys(t), o = {};
  return r.forEach((a) => {
    a in s && (o[a] = s[a]);
  }), o;
}
var N = ((i) => (i[i.SegmentsAnnouncement = 0] = "SegmentsAnnouncement", i[i.SegmentRequest = 1] = "SegmentRequest", i[i.SegmentData = 2] = "SegmentData", i[i.SegmentDataSendingCompleted = 3] = "SegmentDataSendingCompleted", i[i.SegmentAbsent = 4] = "SegmentAbsent", i[i.CancelSegmentRequest = 5] = "CancelSegmentRequest", i))(N || {}), J = ((i) => (i[i.Min = -1] = "Min", i[i.Int = 0] = "Int", i[i.SimilarIntArray = 1] = "SimilarIntArray", i[i.String = 2] = "String", i[i.Max = 3] = "Max", i))(J || {});
function $s(i) {
  const t = i < 0, e = function(r) {
    const o = r.toString(2), a = r < 0 ? o.length : o.length + 1;
    return Math.ceil(a / 8);
  }(i), n = new Uint8Array(e), s = BigInt(e);
  i = function(r) {
    return r < 0 ? -r : r;
  }(i);
  for (let r = 0; r < e; r++) {
    const o = i >> 8n * (s - 1n - BigInt(r)) & 0xffn;
    n[r] = Number(o);
  }
  return t && (n[0] = 128 | n[0]), n;
}
function js(i) {
  const t = BigInt(i.length), e = (s, r) => {
    const o = 8n * (t - 1n - BigInt(r));
    return BigInt(s) << o;
  };
  let n = e(127 & i[0], 0);
  for (let s = 1; s < t; s++) n = e(i[s], s) | n;
  return (128 & i[0]) >> 7 && (n = -n), n;
}
function Me(i) {
  const t = $s(i), e = 0 | t.length;
  return new Uint8Array([e, ...t]);
}
function An(i) {
  const t = i[0];
  if (t >> 4) throw new Error("Trying to deserialize integer with invalid serialized item code");
  const e = 15 & t, n = 1 + e;
  return { number: js(i.slice(1, n)), byteLength: e + 1 };
}
function Ws(i) {
  const [t, e] = i;
  if (t >> 4 !== 1) throw new Error("Trying to deserialize similar int array with invalid serialized item code");
  let n = 2;
  const s = [];
  for (let r = 0; r < e; r++) {
    const { number: o, byteLength: a } = An(i.slice(n));
    n += a;
    const h = 0xffn & o, u = -256n & o;
    for (let c = 0; c < h; c++) {
      const l = BigInt(i[n]);
      s.push(u | l), n++;
    }
  }
  return { numbers: s, byteLength: n };
}
function Qs(i) {
  const [t, e] = i;
  if (t >> 4 !== 2) throw new Error("Trying to deserialize bytes (sting) with invalid serialized item code.");
  const n = (15 & t) << 8 | e, s = i.slice(2, n + 2);
  return { string: new TextDecoder("utf8").decode(s), byteLength: n + 2 };
}
class X {
  constructor() {
    d(this, "bytes", []);
    d(this, "_length", 0);
  }
  push(t) {
    this.addBytes(t, "end");
  }
  unshift(t) {
    this.addBytes(t, "start");
  }
  addBytes(t, e) {
    let n;
    n = t instanceof Uint8Array ? t : Array.isArray(t) ? new Uint8Array(t) : new Uint8Array([t]), this._length += n.length, this.bytes[e === "start" ? "unshift" : "push"](n);
  }
  getBytesChunks() {
    return this.bytes;
  }
  getBuffer() {
    return Tn(this.bytes, this._length);
  }
  get length() {
    return this._length;
  }
}
const Y = It("cstr", 4), st = It("cend", 4), ne = It("dstr", 4), se = It("dend", 4), zs = [Y, ne], Gs = [st, se], Ne = Y.length + st.length;
function Ln(i) {
  const { length: t } = Y, e = i.slice(-t);
  return zs.some((n) => At(i, n, 4)) && Gs.some((n) => At(e, n, 4));
}
class xt extends Error {
  constructor(t) {
    super(), this.type = t;
  }
}
class Rn {
  constructor(t) {
    d(this, "chunks", new X());
    d(this, "status", "joining");
    this.onComplete = t;
  }
  addCommandChunk(t) {
    if (this.status === "completed") return;
    const e = At(t, Y, 4);
    if (!this.chunks.length && !e) throw new xt("no-first-chunk");
    if (this.chunks.length && e) throw new xt("incomplete-joining");
    this.chunks.push(this.unframeCommandChunk(t)), function(n) {
      return At(n.slice(-4), st, 4);
    }(t) && (this.status = "completed", this.onComplete(this.chunks.getBuffer()));
  }
  unframeCommandChunk(t) {
    return t.slice(4, t.length - 4);
  }
}
class lt {
  constructor(t, e) {
    d(this, "bytes", new X());
    d(this, "resultBuffers", []);
    d(this, "status", "creating");
    this.maxChunkLength = e, this.bytes.push(t);
  }
  addInteger(t, e) {
    this.bytes.push(t.charCodeAt(0));
    const n = Me(BigInt(e));
    this.bytes.push(n);
  }
  addSimilarIntArr(t, e) {
    this.bytes.push(t.charCodeAt(0));
    const n = function(s) {
      const r = /* @__PURE__ */ new Map();
      for (const a of s) {
        const h = -256n & a, u = 0xffn & a, c = r.get(h) ?? new X();
        c.length || r.set(h, c), c.push(Number(u));
      }
      const o = new X();
      o.push([16, r.size]);
      for (const [a, h] of r) {
        const { length: u } = h.getBytesChunks(), c = a | 0xffn & BigInt(u);
        h.unshift(Me(c)), o.push(h.getBuffer());
      }
      return o.getBuffer();
    }(e.map((s) => BigInt(s)));
    this.bytes.push(n);
  }
  addString(t, e) {
    this.bytes.push(t.charCodeAt(0));
    const n = function(s) {
      const { length: r } = s, o = new X();
      return o.push([32 | r >> 8 & 15, 255 & r]), o.push(new TextEncoder().encode(s)), o.getBuffer();
    }(e);
    this.bytes.push(n);
  }
  complete() {
    if (!this.bytes.length) throw new Error("Buffer is empty");
    if (this.status === "completed") return;
    this.status = "completed";
    const t = this.bytes.getBuffer();
    if (t.length + Ne <= this.maxChunkLength) return void this.resultBuffers.push(ut(t, Y, st));
    let e = Math.ceil(t.length / this.maxChunkLength);
    Math.ceil(t.length / e) + Ne > this.maxChunkLength && e++;
    for (const [n, s] of function* (r, o) {
      const a = Math.ceil(r.length / o);
      for (let h = 0; h < o; h++) yield [h, r.slice(h * a, (h + 1) * a)];
    }(t, e)) n === 0 ? this.resultBuffers.push(ut(s, Y, se)) : n === e - 1 ? this.resultBuffers.push(ut(s, ne, st)) : this.resultBuffers.push(ut(s, ne, se));
  }
  getResultBuffers() {
    if (this.status === "creating" || !this.resultBuffers.length) throw new Error("Command is not complete.");
    return this.resultBuffers;
  }
}
function In(i) {
  const [t] = i, e = { c: t };
  let n = 1;
  for (; n < i.length; ) {
    const s = String.fromCharCode(i[n]);
    switch (n++, Js(i[n])) {
      case J.Int:
        {
          const { number: r, byteLength: o } = An(i.slice(n));
          e[s] = Number(r), n += o;
        }
        break;
      case J.SimilarIntArray:
        {
          const { numbers: r, byteLength: o } = Ws(i.slice(n));
          e[s] = r.map((a) => Number(a)), n += o;
        }
        break;
      case J.String: {
        const { string: r, byteLength: o } = Qs(i.slice(n));
        e[s] = r, n += o;
      }
    }
  }
  return e;
}
function Js(i) {
  const t = i >> 4;
  if (t <= J.Min || t >= J.Max) throw new Error("Not existing type");
  return t;
}
function It(i, t) {
  if (i.length !== t) throw new Error("Wrong string length");
  const e = new Uint8Array(t);
  for (let n = 0; n < i.length; n++) e[n] = i.charCodeAt(n);
  return e;
}
function ut(i, t, e) {
  const n = new Uint8Array(i.length + t.length + e.length);
  return n.set(t), n.set(i, t.length), n.set(e, t.length + i.length), n;
}
function At(i, t, e) {
  for (let n = 0; n < e; n++) if (i[n] !== t[n]) return !1;
  return !0;
}
function En(i, t) {
  switch (i.c) {
    case N.CancelSegmentRequest:
    case N.SegmentAbsent:
    case N.SegmentDataSendingCompleted:
      return function(e, n) {
        const s = new lt(e.c, n);
        return s.addInteger("i", e.i), s.addInteger("r", e.r), s.complete(), s.getResultBuffers();
      }(i, t);
    case N.SegmentRequest:
      return function(e, n) {
        const s = new lt(e.c, n);
        return s.addInteger("i", e.i), s.addInteger("r", e.r), e.b && s.addInteger("b", e.b), s.complete(), s.getResultBuffers();
      }(i, t);
    case N.SegmentsAnnouncement:
      return function(e, n) {
        const { c: s, p: r, l: o } = e, a = new lt(s, n);
        return o != null && o.length && a.addSimilarIntArr("l", o), r != null && r.length && a.addSimilarIntArr("p", r), a.complete(), a.getResultBuffers();
      }(i, t);
    case N.SegmentData:
      return function(e, n) {
        const s = new lt(e.c, n);
        return s.addInteger("i", e.i), s.addInteger("s", e.s), s.addInteger("r", e.r), s.complete(), s.getResultBuffers();
      }(i, t);
  }
}
const Vs = Object.freeze(Object.defineProperty({ __proto__: null, BinaryCommandChunksJoiner: Rn, BinaryCommandJoiningError: xt, PeerCommandType: N, deserializeCommand: In, isCommandChunk: Ln, serializePeerCommand: En }, Symbol.toStringTag, { value: "Module" }));
class Ys {
  constructor(t, e, n, s) {
    d(this, "commandChunks");
    d(this, "uploadingContext");
    d(this, "onChunkDownloaded");
    d(this, "onChunkUploaded");
    d(this, "onDataReceived", (t) => {
      Ln(t) ? this.receivingCommandBytes(t) : (this.eventHandlers.onSegmentChunkReceived(t), this.onChunkDownloaded(t.byteLength, "p2p", this.connection.idUtf8));
    });
    this.connection = t, this.peerConfig = e, this.eventHandlers = n, this.onChunkDownloaded = s.getEventDispatcher("onChunkDownloaded"), this.onChunkUploaded = s.getEventDispatcher("onChunkUploaded"), t.on("data", this.onDataReceived);
  }
  sendCommand(t) {
    const e = En(t, this.peerConfig.webRtcMaxMessageSize);
    for (const n of e) this.connection.write(n);
  }
  stopUploadingSegmentData() {
    var t;
    (t = this.uploadingContext) == null || t.stopUploading(), this.uploadingContext = void 0;
  }
  getUploadingRequestId() {
    var t;
    return (t = this.uploadingContext) == null ? void 0 : t.requestId;
  }
  async splitSegmentDataToChunksAndUploadAsync(t, e) {
    if (this.uploadingContext) throw new Error("Some segment data is already uploading.");
    const n = function* (c, l) {
      let g = c.byteLength;
      for (; g > 0; ) {
        const m = g >= l ? l : g, f = c.byteLength - g, v = c.slice(f, f + m);
        g -= m, yield v;
      }
    }(t, this.peerConfig.webRtcMaxMessageSize), { promise: s, resolve: r, reject: o } = function() {
      let c, l;
      return { promise: new Promise((g, m) => {
        c = g, l = m;
      }), resolve: c, reject: l };
    }();
    let a = !1;
    const h = { stopUploading: () => {
      a = !1;
    }, requestId: e };
    this.uploadingContext = h;
    const u = () => {
      if (a) for (; ; ) {
        const c = n.next().value;
        if (!c) {
          r();
          break;
        }
        const l = this.connection.write(c);
        if (this.onChunkUploaded(c.byteLength, this.connection.idUtf8), !l) break;
      }
      else o();
    };
    try {
      this.connection.on("drain", u), a = !0, u(), await s;
    } finally {
      this.connection.off("drain", u), this.uploadingContext === h && (this.uploadingContext = void 0);
    }
  }
  receivingCommandBytes(t) {
    this.commandChunks || (this.commandChunks = new Rn((e) => {
      this.commandChunks = void 0;
      const n = In(e);
      this.eventHandlers.onCommandReceived(n);
    }));
    try {
      this.commandChunks.addCommandChunk(t);
    } catch (e) {
      if (!(e instanceof xt)) return;
      this.commandChunks = void 0;
    }
  }
}
const { PeerCommandType: k } = Vs;
class Lt {
  constructor(t, e, n, s, r) {
    d(this, "id");
    d(this, "peerProtocol");
    d(this, "downloadingContext");
    d(this, "loadedSegments", /* @__PURE__ */ new Set());
    d(this, "httpLoadingSegments", /* @__PURE__ */ new Set());
    d(this, "downloadingErrors", []);
    d(this, "logger", L("p2pml-core:peer"));
    d(this, "onPeerClosed");
    d(this, "onCommandReceived", async (t) => {
      var e, n, s;
      switch (t.c) {
        case k.SegmentsAnnouncement:
          this.loadedSegments = new Set(t.l), this.httpLoadingSegments = new Set(t.p), this.eventHandlers.onSegmentsAnnouncement();
          break;
        case k.SegmentRequest:
          this.peerProtocol.stopUploadingSegmentData(), this.eventHandlers.onSegmentRequested(this, t.i, t.r, t.b);
          break;
        case k.SegmentData:
          {
            if (!this.downloadingContext || this.downloadingContext.isSegmentDataCommandReceived) break;
            const { request: r, controls: o, requestId: a } = this.downloadingContext;
            if (r.segment.externalId !== t.i || a !== t.r) break;
            this.downloadingContext.isSegmentDataCommandReceived = !0, o.firstBytesReceived(), r.totalBytes === void 0 ? r.setTotalBytes(t.s) : r.totalBytes - r.loadedBytes !== t.s && (r.clearLoadedBytes(), this.sendCancelSegmentRequestCommand(r.segment, a), this.cancelSegmentDownloading("peer-response-bytes-length-mismatch"), this.destroy());
          }
          break;
        case k.SegmentDataSendingCompleted: {
          const { downloadingContext: r } = this;
          if (!(r != null && r.isSegmentDataCommandReceived)) return;
          const { request: o, controls: a } = r;
          if (r.request.segment.externalId !== t.i || r.requestId !== t.r) return o.clearLoadedBytes(), this.cancelSegmentDownloading("peer-protocol-violation"), void this.destroy();
          if (o.loadedBytes !== o.totalBytes) return o.clearLoadedBytes(), this.cancelSegmentDownloading("peer-response-bytes-length-mismatch"), void this.destroy();
          const h = await ((n = (e = this.peerConfig).validateP2PSegment) == null ? void 0 : n.call(e, o.segment.url, o.segment.byteRange, o.data)) ?? !0;
          if (this.downloadingContext !== r) return;
          if (!h) return o.clearLoadedBytes(), this.cancelSegmentDownloading("p2p-segment-validation-failed"), void this.destroy();
          this.downloadingErrors = [], a.completeOnSuccess(), this.downloadingContext = void 0;
          break;
        }
        case k.SegmentAbsent:
          ((s = this.downloadingContext) == null ? void 0 : s.request.segment.externalId) === t.i && this.downloadingContext.requestId === t.r && (this.cancelSegmentDownloading("peer-segment-absent"), this.loadedSegments.delete(t.i));
          break;
        case k.CancelSegmentRequest:
          if (this.peerProtocol.getUploadingRequestId() !== t.r) break;
          this.peerProtocol.stopUploadingSegmentData();
          break;
      }
    });
    d(this, "onSegmentChunkReceived", (t) => {
      var s;
      if (!((s = this.downloadingContext) != null && s.isSegmentDataCommandReceived)) return;
      const { request: e, controls: n } = this.downloadingContext;
      if (e.totalBytes !== void 0 && e.loadedBytes + t.byteLength > e.totalBytes) return e.clearLoadedBytes(), this.cancelSegmentDownloading("peer-response-bytes-length-mismatch"), void this.destroy();
      n.addLoadedChunk(t);
    });
    d(this, "onPeerConnectionClosed", () => {
      this.destroy();
    });
    d(this, "onConnectionError", (t) => {
      this.logger(`peer connection error ${this.id} %O`, t), this.eventTarget.getEventDispatcher("onPeerError")({ peerId: this.id, streamType: this.streamType, error: t });
      const { code: e } = t;
      (e === "ERR_DATA_CHANNEL" || e === "ERR_CONNECTION_FAILURE") && this.destroy();
    });
    d(this, "destroy", () => {
      this.cancelSegmentDownloading("peer-closed"), this.connection.destroy(), this.eventHandlers.onPeerClosed(this), this.onPeerClosed({ peerId: this.id, streamType: this.streamType }), this.logger(`peer closed ${this.id}`);
    });
    this.connection = t, this.eventHandlers = e, this.peerConfig = n, this.streamType = s, this.eventTarget = r, this.onPeerClosed = r.getEventDispatcher("onPeerClose"), this.id = Lt.getPeerIdFromConnection(t), this.peerProtocol = new Ys(t, n, { onSegmentChunkReceived: this.onSegmentChunkReceived, onCommandReceived: this.onCommandReceived }, r), r.getEventDispatcher("onPeerConnect")({ peerId: this.id, streamType: s }), t.on("error", this.onConnectionError), t.on("close", this.onPeerConnectionClosed), t.on("end", this.onPeerConnectionClosed), t.on("finish", this.onPeerConnectionClosed);
  }
  get downloadingSegment() {
    var t;
    return (t = this.downloadingContext) == null ? void 0 : t.request.segment;
  }
  getSegmentStatus(t) {
    const { externalId: e } = t;
    return this.loadedSegments.has(e) ? "loaded" : this.httpLoadingSegments.has(e) ? "http-loading" : void 0;
  }
  downloadSegment(t) {
    if (this.downloadingContext) throw new Error("Some segment already is downloading");
    this.downloadingContext = { request: t, requestId: Math.floor(1e3 * Math.random()), isSegmentDataCommandReceived: !1, controls: t.start({ downloadSource: "p2p", peerId: this.id }, { notReceivingBytesTimeoutMs: this.peerConfig.p2pNotReceivingBytesTimeoutMs, abort: (n) => {
      if (!this.downloadingContext) return;
      const { request: s, requestId: r } = this.downloadingContext;
      this.sendCancelSegmentRequestCommand(s.segment, r), this.downloadingErrors.push(n), this.downloadingContext = void 0, this.downloadingErrors.filter((o) => o.type === "bytes-receiving-timeout").length >= this.peerConfig.p2pErrorRetries && this.destroy();
    } }) };
    const e = { c: k.SegmentRequest, r: this.downloadingContext.requestId, i: t.segment.externalId };
    t.loadedBytes && (e.b = t.loadedBytes), this.peerProtocol.sendCommand(e);
  }
  async uploadSegmentData(t, e, n) {
    const { externalId: s } = t;
    this.logger(`send segment ${t.externalId} to ${this.id}`);
    const r = { c: k.SegmentData, i: s, r: e, s: n.byteLength };
    this.peerProtocol.sendCommand(r);
    try {
      await this.peerProtocol.splitSegmentDataToChunksAndUploadAsync(n, e), this.sendSegmentDataSendingCompletedCommand(t, e), this.logger(`segment ${s} has been sent to ${this.id}`);
    } catch {
      this.logger(`cancel segment uploading ${s}`);
    }
  }
  cancelSegmentDownloading(t) {
    if (!this.downloadingContext) return;
    const { request: e, controls: n } = this.downloadingContext, { segment: s } = e;
    this.logger(`cancel segment request ${s.externalId} (${t})`);
    const r = new x(t);
    n.abortOnError(r), this.downloadingContext = void 0, this.downloadingErrors.push(r);
  }
  sendSegmentsAnnouncementCommand(t, e) {
    const n = { c: k.SegmentsAnnouncement, p: e, l: t };
    this.peerProtocol.sendCommand(n);
  }
  sendSegmentAbsentCommand(t, e) {
    this.peerProtocol.sendCommand({ c: k.SegmentAbsent, i: t, r: e });
  }
  sendCancelSegmentRequestCommand(t, e) {
    this.peerProtocol.sendCommand({ c: k.CancelSegmentRequest, i: t.externalId, r: e });
  }
  sendSegmentDataSendingCompletedCommand(t, e) {
    this.peerProtocol.sendCommand({ c: k.SegmentDataSendingCompleted, r: e, i: t.externalId });
  }
  static getPeerIdFromConnection(t) {
    return function(e) {
      const n = new Uint8Array(e.length / 2);
      for (let s = 0; s < e.length; s += 2) n[s / 2] = parseInt(e.slice(s, s + 2), 16);
      return new TextDecoder().decode(n);
    }(t.id);
  }
}
function Ks() {
  const i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), t = /\b(iPad|iPhone|Macintosh).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
  return i || t;
}
class Zs {
  constructor(t, e, n, s, r) {
    d(this, "streamShortId");
    d(this, "client");
    d(this, "_peers", /* @__PURE__ */ new Map());
    d(this, "logger", L("p2pml-core:p2p-tracker-client"));
    d(this, "onReceivePeerConnection", (t) => {
      const e = Lt.getPeerIdFromConnection(t);
      let n = this._peers.get(e);
      n != null && n.peer ? t.destroy() : (n || (n = { potentialConnections: /* @__PURE__ */ new Set() }, t.idUtf8 = e, n.potentialConnections.add(t), this._peers.set(e, n)), t.on("connect", () => {
        if (!n.peer) {
          for (const s of n.potentialConnections) s !== t && s.destroy();
          n.potentialConnections.clear(), n.peer = new Lt(t, { onPeerClosed: this.onPeerClosed, onSegmentRequested: this.eventHandlers.onSegmentRequested, onSegmentsAnnouncement: this.eventHandlers.onSegmentsAnnouncement }, this.config, this.stream.type, this.eventTarget), this.logger(`connected with peer: ${n.peer.id} ${this.streamShortId}`), this.eventHandlers.onPeerConnected(n.peer);
        }
      }));
    });
    d(this, "onTrackerClientWarning", (t) => {
      this.logger(`tracker warning (${this.streamShortId}: ${t})`), this.eventTarget.getEventDispatcher("onTrackerWarning")({ streamType: this.stream.type, warning: t });
    });
    d(this, "onTrackerClientError", (t) => {
      this.logger(`tracker error (${this.streamShortId}: ${t})`), this.eventTarget.getEventDispatcher("onTrackerError")({ streamType: this.stream.type, error: t });
    });
    d(this, "onPeerClosed", (t) => {
      this.logger(`peer closed: ${t.id}`), this._peers.delete(t.id);
    });
    this.stream = e, this.eventHandlers = n, this.config = s, this.eventTarget = r;
    const o = function(h) {
      const u = Us.fromUtf8(h).slice(1);
      return btoa(u);
    }(t);
    this.streamShortId = F(e);
    const a = function(h) {
      const u = [h], c = 20 - h.length;
      for (let l = 0; l < c; l++) u.push(Hs[Math.floor(62 * Math.random())]);
      return u.join("");
    }(s.trackerClientVersionPrefix);
    this.client = new te({ infoHash: Oe(o), peerId: Oe(a), announce: Ks() ? s.announceTrackers.slice(0, 1) : s.announceTrackers, rtcConfig: this.config.rtcConfig }), this.client.on("peer", this.onReceivePeerConnection), this.client.on("warning", this.onTrackerClientWarning), this.client.on("error", this.onTrackerClientError), this.logger(`create new client; 
stream: ${this.streamShortId}; hash: ${o}
peerId: ${a}`);
  }
  start() {
    this.client.start();
  }
  destroy() {
    this.client.destroy();
    for (const { peer: t, potentialConnections: e } of this._peers.values()) {
      t == null || t.destroy();
      for (const n of e) n.destroy();
    }
    this._peers.clear(), this.logger(`destroy client; stream: ${this.streamShortId}`);
  }
  *peers() {
    for (const t of this._peers.values()) t.peer && (yield t.peer);
  }
}
function B(i, t) {
  return `v2-${i}-${function(e) {
    return `${e.type}-${e.index}`;
  }(t)}`;
}
function Ue(i, t) {
  for (const e of i.values()) {
    const n = e.segments.get(t);
    if (n) return n;
  }
}
function Mt(i, t, e, n, s) {
  const { highDemandTimeWindow: r, httpDownloadTimeWindow: o, p2pDownloadTimeWindow: a } = function(h, u) {
    const { highDemandTimeWindow: c, httpDownloadTimeWindow: l, p2pDownloadTimeWindow: g } = h, m = { highDemandTimeWindow: c, httpDownloadTimeWindow: l, p2pDownloadTimeWindow: g };
    return u <= 5 ? (m.httpDownloadTimeWindow = 0, m.p2pDownloadTimeWindow = 0) : u <= 10 && (m.p2pDownloadTimeWindow = m.httpDownloadTimeWindow), m;
  }(e, s);
  return { isHighDemand: Nt(i, t, r), isHttpDownloadable: Nt(i, t, o), isP2PDownloadable: Nt(i, t, a) && n.isSegmentLoadingOrLoadedBySomeone(i) };
}
function Nt(i, t, e) {
  const { startTime: n, endTime: s } = i, { position: r, rate: o } = t;
  return !(r + e * o < n || r > s);
}
class Xs {
  constructor(t, e, n, s, r, o, a) {
    d(this, "trackerClient");
    d(this, "isAnnounceMicrotaskCreated", !1);
    d(this, "onPeerConnected", (t) => {
      if (this.config.isP2PUploadDisabled) return;
      const { httpLoading: e, loaded: n } = this.getSegmentsAnnouncement();
      t.sendSegmentsAnnouncementCommand(n, e);
    });
    d(this, "broadcastAnnouncement", (t = !1) => {
      if (t) return void this.sendSegmentsAnnouncement([], []);
      if (this.isAnnounceMicrotaskCreated || this.config.isP2PUploadDisabled) return;
      const { loaded: e, httpLoading: n } = this.getSegmentsAnnouncement();
      this.sendSegmentsAnnouncement(e, n);
    });
    d(this, "sendSegmentsAnnouncement", (t, e) => {
      this.isAnnounceMicrotaskCreated = !0, queueMicrotask(() => {
        for (const n of this.trackerClient.peers()) n.sendSegmentsAnnouncementCommand(t, e);
        this.isAnnounceMicrotaskCreated = !1;
      });
    });
    d(this, "onSegmentRequested", async (t, e, n, s) => {
      const r = function(u, c) {
        for (const l of u.segments.values()) if (l.externalId === c) return l;
      }(this.stream, e);
      if (!r) return;
      if (this.config.isP2PUploadDisabled) return void t.sendSegmentAbsentCommand(e, n);
      const o = this.config.swarmId ?? this.streamManifestUrl, a = B(o, this.stream), h = await this.segmentStorage.getSegmentData(o, a, r.externalId);
      h ? await t.uploadSegmentData(r, n, s !== void 0 ? h.slice(s) : h) : t.sendSegmentAbsentCommand(e, n);
    });
    this.streamManifestUrl = t, this.stream = e, this.requests = n, this.segmentStorage = s, this.config = r, this.eventTarget = o, this.onSegmentAnnouncement = a;
    const h = B(this.config.swarmId ?? this.streamManifestUrl, this.stream);
    this.trackerClient = new Zs(h, this.stream, { onPeerConnected: this.onPeerConnected, onSegmentRequested: this.onSegmentRequested, onSegmentsAnnouncement: this.onSegmentAnnouncement }, this.config, this.eventTarget), this.eventTarget.addEventListener(`onStorageUpdated-${h}`, this.broadcastAnnouncement), this.segmentStorage.setSegmentChangeCallback((u) => {
      this.eventTarget.dispatchEvent(`onStorageUpdated-${u}`);
    }), this.trackerClient.start();
  }
  downloadSegment(t) {
    const e = [];
    for (const o of this.trackerClient.peers()) o.downloadingSegment || o.getSegmentStatus(t) !== "loaded" || e.push(o);
    if (e.length === 0) return;
    const n = (s = e)[Math.floor(Math.random() * s.length)];
    var s;
    const r = this.requests.getOrCreateRequest(t);
    n.downloadSegment(r);
  }
  isSegmentLoadingOrLoadedBySomeone(t) {
    for (const e of this.trackerClient.peers()) if (e.getSegmentStatus(t)) return !0;
    return !1;
  }
  isSegmentLoadedBySomeone(t) {
    for (const e of this.trackerClient.peers()) if (e.getSegmentStatus(t) === "loaded") return !0;
    return !1;
  }
  get connectedPeerCount() {
    let t = 0;
    for (const e of this.trackerClient.peers()) t++;
    return t;
  }
  getSegmentsAnnouncement() {
    const t = this.config.swarmId ?? this.streamManifestUrl, e = B(t, this.stream), n = this.segmentStorage.getStoredSegmentIds(t, e), s = [];
    for (const r of this.requests.httpRequests()) {
      const o = this.stream.segments.get(r.segment.runtimeId);
      o && s.push(o.externalId);
    }
    return { loaded: n, httpLoading: s };
  }
  destroy() {
    const t = B(this.config.swarmId ?? this.streamManifestUrl, this.stream);
    this.eventTarget.removeEventListener(`onStorageUpdated-${t}`, this.broadcastAnnouncement), this.trackerClient.destroy();
  }
}
class ti {
  constructor(t, e, n, s, r, o, a) {
    d(this, "loaders", /* @__PURE__ */ new Map());
    d(this, "_currentLoaderItem");
    d(this, "logger", L("p2pml-core:p2p-loaders-container"));
    this.streamManifestUrl = t, this.requests = n, this.segmentStorage = s, this.config = r, this.eventTarget = o, this.onSegmentAnnouncement = a, this._currentLoaderItem = this.findOrCreateLoaderForStream(e), this.logger(`set current p2p loader: ${F(e)}`);
  }
  createLoader(t) {
    if (this.loaders.has(t.runtimeId)) throw new Error("Loader for this stream already exists");
    const e = new Xs(this.streamManifestUrl, t, this.requests, this.segmentStorage, this.config, this.eventTarget, () => {
      this._currentLoaderItem.loader === e && this.onSegmentAnnouncement();
    }), n = F(t);
    return this.logger(`created new loader: ${n}`), { loader: e, stream: t, loggerInfo: F(t) };
  }
  findOrCreateLoaderForStream(t) {
    const e = this.loaders.get(t.runtimeId);
    if (e) return clearTimeout(e.destroyTimeoutId), e.destroyTimeoutId = void 0, e;
    {
      const n = this.createLoader(t);
      return this.loaders.set(t.runtimeId, n), n;
    }
  }
  changeCurrentLoader(t) {
    const e = this.config.swarmId ?? this.streamManifestUrl, n = B(e, this._currentLoaderItem.stream);
    this.segmentStorage.getStoredSegmentIds(e, n).length ? this.setLoaderDestroyTimeout(this._currentLoaderItem) : this.destroyAndRemoveLoader(this._currentLoaderItem), this._currentLoaderItem = this.findOrCreateLoaderForStream(t), this.logger(`change current p2p loader: ${F(t)}`);
  }
  setLoaderDestroyTimeout(t) {
    t.destroyTimeoutId = window.setTimeout(() => this.destroyAndRemoveLoader(t), this.config.p2pInactiveLoaderDestroyTimeoutMs);
  }
  destroyAndRemoveLoader(t) {
    t.loader.destroy(), this.loaders.delete(t.stream.runtimeId), this.logger("destroy p2p loader: ", t.loggerInfo);
  }
  get currentLoader() {
    return this._currentLoaderItem.loader;
  }
  destroy() {
    for (const { loader: t, destroyTimeoutId: e } of this.loaders.values()) t.destroy(), clearTimeout(e);
    this.loaders.clear();
  }
}
let ei = class {
  constructor(i, t, e, n, s, r) {
    d(this, "currentAttempt");
    d(this, "_failedAttempts", new ni());
    d(this, "finalData");
    d(this, "bytes", []);
    d(this, "_loadedBytes", 0);
    d(this, "_totalBytes");
    d(this, "_status", "not-started");
    d(this, "progress");
    d(this, "notReceivingBytesTimeout");
    d(this, "_abortRequestCallback");
    d(this, "_logger");
    d(this, "_isHandledByProcessQueue", !1);
    d(this, "onSegmentError");
    d(this, "onSegmentAbort");
    d(this, "onSegmentStart");
    d(this, "onSegmentLoaded");
    d(this, "abortOnTimeout", () => {
      var t;
      if (this.throwErrorIfNotLoadingStatus(), !this.currentAttempt) return;
      this.setStatus("failed");
      const i = new x("bytes-receiving-timeout");
      (t = this._abortRequestCallback) == null || t.call(this, i), this.logger(`${this.downloadSource} ${this.segment.externalId} failed ${i.type}`), this._failedAttempts.add({ ...this.currentAttempt, error: i }), this.onSegmentError({ segment: this.segment, error: i, downloadSource: this.currentAttempt.downloadSource, peerId: this.currentAttempt.downloadSource === "p2p" ? this.currentAttempt.peerId : void 0, streamType: this.segment.stream.type }), this.notReceivingBytesTimeout.clear(), this.manageBandwidthCalculatorsState("stop"), this.requestProcessQueueCallback();
    });
    d(this, "abortOnError", (i) => {
      this.throwErrorIfNotLoadingStatus(), this.currentAttempt && (this.setStatus("failed"), this.logger(`${this.downloadSource} ${this.segment.externalId} failed ${i.type}`), this._failedAttempts.add({ ...this.currentAttempt, error: i }), this.onSegmentError({ segment: this.segment, error: i, downloadSource: this.currentAttempt.downloadSource, peerId: this.currentAttempt.downloadSource === "p2p" ? this.currentAttempt.peerId : void 0, streamType: this.segment.stream.type }), this.notReceivingBytesTimeout.clear(), this.manageBandwidthCalculatorsState("stop"), this.requestProcessQueueCallback());
    });
    d(this, "completeOnSuccess", () => {
      this.throwErrorIfNotLoadingStatus(), this.currentAttempt && (this.manageBandwidthCalculatorsState("stop"), this.notReceivingBytesTimeout.clear(), this.setStatus("succeed"), this._totalBytes = this._loadedBytes, this.onSegmentLoaded({ segmentUrl: this.segment.url, bytesLength: this.data.byteLength, downloadSource: this.currentAttempt.downloadSource, peerId: this.currentAttempt.downloadSource === "p2p" ? this.currentAttempt.peerId : void 0, streamType: this.segment.stream.type }), this.logger(`${this.currentAttempt.downloadSource} ${this.segment.externalId} succeed`), this.requestProcessQueueCallback());
    });
    d(this, "addLoadedChunk", (i) => {
      if (this.throwErrorIfNotLoadingStatus(), !this.currentAttempt || !this.progress) return;
      this.notReceivingBytesTimeout.restart();
      const { byteLength: t } = i, { all: e, http: n } = this.bandwidthCalculators;
      e.addBytes(t), this.currentAttempt.downloadSource === "http" && n.addBytes(t), this.bytes.push(i), this.progress.lastLoadedChunkTimestamp = performance.now(), this.progress.loadedBytes += t, this._loadedBytes += t;
    });
    d(this, "firstBytesReceived", () => {
      this.throwErrorIfNotLoadingStatus(), this.notReceivingBytesTimeout.restart();
    });
    this.segment = i, this.requestProcessQueueCallback = t, this.bandwidthCalculators = e, this.playback = n, this.playbackConfig = s, this.onSegmentError = r.getEventDispatcher("onSegmentError"), this.onSegmentAbort = r.getEventDispatcher("onSegmentAbort"), this.onSegmentStart = r.getEventDispatcher("onSegmentStart"), this.onSegmentLoaded = r.getEventDispatcher("onSegmentLoaded");
    const { byteRange: o } = this.segment;
    if (o) {
      const { end: h, start: u } = o;
      this._totalBytes = h - u + 1;
    }
    this.notReceivingBytesTimeout = new si(this.abortOnTimeout);
    const { type: a } = this.segment.stream;
    this._logger = L(`p2pml-core:request-${a}`);
  }
  clearLoadedBytes() {
    this._loadedBytes = 0, this.bytes = [], this._totalBytes = void 0, this.finalData = void 0;
  }
  get status() {
    return this._status;
  }
  setStatus(i) {
    this._status = i, this._isHandledByProcessQueue = !1;
  }
  get downloadSource() {
    var i;
    return (i = this.currentAttempt) == null ? void 0 : i.downloadSource;
  }
  get loadedBytes() {
    return this._loadedBytes;
  }
  get totalBytes() {
    return this._totalBytes;
  }
  get data() {
    return this.finalData || (this.finalData = Tn(this.bytes)), this.finalData;
  }
  get failedAttempts() {
    return this._failedAttempts;
  }
  get isHandledByProcessQueue() {
    return this._isHandledByProcessQueue;
  }
  markHandledByProcessQueue() {
    this._isHandledByProcessQueue = !0;
  }
  setTotalBytes(i) {
    if (this._totalBytes !== void 0) throw new Error("Request total bytes value is already set");
    this._totalBytes = i;
  }
  start(i, t) {
    if (this._status === "succeed") throw new Error(`Request ${this.segment.externalId} has been already succeed.`);
    if (this._status === "loading") throw new Error(`Request ${this.segment.externalId} has been already started.`);
    this.setStatus("loading"), this.currentAttempt = { ...i }, this.progress = { startFromByte: this._loadedBytes, loadedBytes: 0, startTimestamp: performance.now() }, this.manageBandwidthCalculatorsState("start");
    const { notReceivingBytesTimeoutMs: e, abort: n } = t;
    return this._abortRequestCallback = n, e !== void 0 && this.notReceivingBytesTimeout.start(e), this.logger(`${i.downloadSource} ${this.segment.externalId} started`), this.onSegmentStart({ segment: this.segment, downloadSource: i.downloadSource, peerId: i.downloadSource === "p2p" ? i.peerId : void 0 }), { firstBytesReceived: this.firstBytesReceived, addLoadedChunk: this.addLoadedChunk, completeOnSuccess: this.completeOnSuccess, abortOnError: this.abortOnError };
  }
  abortFromProcessQueue() {
    var i, t, e, n;
    this.throwErrorIfNotLoadingStatus(), this.setStatus("aborted"), this.logger(`${(i = this.currentAttempt) == null ? void 0 : i.downloadSource} ${this.segment.externalId} aborted`), (t = this._abortRequestCallback) == null || t.call(this, new x("abort")), this.onSegmentAbort({ segment: this.segment, downloadSource: (e = this.currentAttempt) == null ? void 0 : e.downloadSource, peerId: ((n = this.currentAttempt) == null ? void 0 : n.downloadSource) === "p2p" ? this.currentAttempt.peerId : void 0, streamType: this.segment.stream.type }), this._abortRequestCallback = void 0, this.manageBandwidthCalculatorsState("stop"), this.notReceivingBytesTimeout.clear();
  }
  throwErrorIfNotLoadingStatus() {
    if (this._status !== "loading") throw new Error(`Request has been already ${this.status}.`);
  }
  logger(i) {
    var t;
    this._logger.color = ((t = this.currentAttempt) == null ? void 0 : t.downloadSource) === "http" ? "green" : "red", this._logger(i), this._logger.color = "";
  }
  manageBandwidthCalculatorsState(i) {
    var s;
    const { all: t, http: e } = this.bandwidthCalculators, n = i === "start" ? "startLoading" : "stopLoading";
    ((s = this.currentAttempt) == null ? void 0 : s.downloadSource) === "http" && e[n](), t[n]();
  }
};
class ni {
  constructor() {
    d(this, "attempts", []);
  }
  add(t) {
    this.attempts.push(t);
  }
  get httpAttemptsCount() {
    return this.attempts.reduce((t, e) => e.downloadSource === "http" ? t + 1 : t, 0);
  }
  get lastAttempt() {
    return this.attempts[this.attempts.length - 1];
  }
  clear() {
    this.attempts = [];
  }
}
class si {
  constructor(t) {
    d(this, "timeoutId");
    d(this, "ms");
    this.action = t;
  }
  start(t) {
    if (this.timeoutId) throw new Error("Timeout is already started.");
    this.ms = t, this.timeoutId = window.setTimeout(this.action, this.ms);
  }
  restart(t) {
    this.timeoutId && clearTimeout(this.timeoutId), t && (this.ms = t), this.ms && (this.timeoutId = window.setTimeout(this.action, this.ms));
  }
  clear() {
    clearTimeout(this.timeoutId), this.timeoutId = void 0;
  }
}
class ii {
  constructor(t, e, n, s, r) {
    d(this, "requests", /* @__PURE__ */ new Map());
    this.requestProcessQueueCallback = t, this.bandwidthCalculators = e, this.playback = n, this.config = s, this.eventTarget = r;
  }
  get executingHttpCount() {
    let t = 0;
    for (const e of this.httpRequests()) e.status === "loading" && t++;
    return t;
  }
  get executingP2PCount() {
    let t = 0;
    for (const e of this.p2pRequests()) e.status === "loading" && t++;
    return t;
  }
  get(t) {
    return this.requests.get(t);
  }
  getOrCreateRequest(t) {
    let e = this.requests.get(t);
    return e || (e = new ei(t, this.requestProcessQueueCallback, this.bandwidthCalculators, this.playback, this.config, this.eventTarget), this.requests.set(t, e)), e;
  }
  remove(t) {
    this.requests.delete(t.segment);
  }
  items() {
    return this.requests.values();
  }
  *httpRequests() {
    for (const t of this.requests.values()) t.downloadSource === "http" && (yield t);
  }
  *p2pRequests() {
    for (const t of this.requests.values()) t.downloadSource === "p2p" && (yield t);
  }
  destroy() {
    for (const t of this.requests.values()) t.status === "loading" && t.abortFromProcessQueue();
    this.requests.clear();
  }
}
class ri {
  constructor(t, e) {
    d(this, "_status", "pending");
    d(this, "_shouldBeStartedImmediately", !1);
    this.segment = t, this.engineCallbacks = e;
  }
  get status() {
    return this._status;
  }
  get shouldBeStartedImmediately() {
    return this._shouldBeStartedImmediately;
  }
  resolve(t, e) {
    this._status === "pending" && (this._status = "succeed", this.engineCallbacks.onSuccess({ data: t, bandwidth: e }));
  }
  reject() {
    this._status === "pending" && (this._status = "failed", this.engineCallbacks.onError(new oe("failed")));
  }
  abort() {
    this._status === "pending" && (this._status = "aborted", this.engineCallbacks.onError(new oe("aborted")));
  }
  markAsShouldBeStartedImmediately() {
    this._shouldBeStartedImmediately = !0;
  }
}
function* Fe(i, t, e, n, s) {
  const { runtimeId: r, stream: o } = i, a = o.segments.get(r);
  if (!a) return;
  const h = o.segments.values();
  let u;
  do {
    const l = h.next();
    if (l.done) return;
    u = l.value;
  } while (u !== a);
  const c = Mt(u, t, e, n, s);
  if (Ut(c)) {
    const l = h.next();
    if (l.done) return;
    const g = l.value, m = Mt(g, t, e, n, s);
    if (Ut(m)) return;
    c.isHighDemand = !0, yield { segment: u, statuses: c }, yield { segment: g, statuses: m };
  } else yield { segment: u, statuses: c };
  for (const l of h) {
    const g = Mt(l, t, e, n, s);
    if (Ut(g)) break;
    yield { segment: l, statuses: g };
  }
}
function Ut(i) {
  const { isHighDemand: t = !1, isHttpDownloadable: e = !1, isP2PDownloadable: n = !1 } = i;
  return !t && !e && !n;
}
class oi {
  constructor(t, e, n, s, r, o, a) {
    d(this, "requests");
    d(this, "engineRequest");
    d(this, "p2pLoaders");
    d(this, "playback");
    d(this, "segmentAvgDuration");
    d(this, "logger");
    d(this, "storageCleanUpIntervalId");
    d(this, "levelChangedTimestamp");
    d(this, "lastQueueProcessingTimeStamp");
    d(this, "randomHttpDownloadInterval");
    d(this, "isProcessQueueMicrotaskCreated", !1);
    d(this, "requestProcessQueueMicrotask", (t = !0) => {
      const e = performance.now();
      !t && this.lastQueueProcessingTimeStamp !== void 0 && e - this.lastQueueProcessingTimeStamp <= 1e3 || this.isProcessQueueMicrotaskCreated || (this.isProcessQueueMicrotaskCreated = !0, queueMicrotask(() => {
        try {
          this.processQueue(), this.lastQueueProcessingTimeStamp = e;
        } finally {
          this.isProcessQueueMicrotaskCreated = !1;
        }
      }));
    });
    this.streamManifestUrl = t, this.lastRequestedSegment = e, this.streamDetails = n, this.config = s, this.bandwidthCalculators = r, this.segmentStorage = o, this.eventTarget = a;
    const h = this.lastRequestedSegment.stream;
    this.playback = { position: this.lastRequestedSegment.startTime, rate: 1 }, this.segmentAvgDuration = function(u) {
      const { segments: c } = u;
      let l = 0;
      const { size: g } = c;
      for (const m of c.values()) l += m.endTime - m.startTime;
      return l / g;
    }(h), this.requests = new ii(this.requestProcessQueueMicrotask, this.bandwidthCalculators, this.playback, this.config, this.eventTarget), this.p2pLoaders = new ti(this.streamManifestUrl, this.lastRequestedSegment.stream, this.requests, this.segmentStorage, this.config, this.eventTarget, this.requestProcessQueueMicrotask), this.logger = L(`p2pml-core:hybrid-loader-${h.type}`), this.logger.color = "coral", this.setIntervalLoading();
  }
  setIntervalLoading() {
    const t = this.p2pLoaders.currentLoader.connectedPeerCount, e = 1e3 * Math.random() * t + 1e3;
    this.randomHttpDownloadInterval = window.setTimeout(() => {
      this.loadRandomThroughHttp(), this.setIntervalLoading();
    }, e);
  }
  async loadSegment(t, e) {
    var a;
    this.logger(`requests: ${Be(t)}`);
    const { stream: n } = t;
    n !== this.lastRequestedSegment.stream && (this.logger(`stream changed to ${F(n)}`), this.p2pLoaders.changeCurrentLoader(n)), this.lastRequestedSegment = t;
    const s = this.config.swarmId ?? this.streamManifestUrl, r = B(s, n);
    this.segmentStorage.onSegmentRequested(s, r, t.externalId, t.startTime, t.endTime, n.type, this.streamDetails.isLive);
    const o = new ri(t, e);
    try {
      if (this.segmentStorage.hasSegment(s, r, t.externalId)) {
        const h = await this.segmentStorage.getSegmentData(s, r, t.externalId);
        if (h) {
          const { queueDownloadRatio: u } = this.generateQueue();
          return void o.resolve(h, this.getBandwidth(u));
        }
      }
      (a = this.engineRequest) == null || a.abort(), this.engineRequest = o;
    } catch {
      o.reject();
    } finally {
      this.requestProcessQueueMicrotask();
    }
  }
  processRequests(t, e) {
    var o;
    const { stream: n } = this.lastRequestedSegment, { httpErrorRetries: s } = this.config, r = performance.now();
    for (const a of this.requests.items()) {
      const { downloadSource: h, status: u, segment: c, isHandledByProcessQueue: l } = a, g = ((o = this.engineRequest) == null ? void 0 : o.segment) === c ? this.engineRequest : void 0;
      switch (u) {
        case "loading":
          t.has(c.runtimeId) || g || (a.abortFromProcessQueue(), this.requests.remove(a));
          break;
        case "succeed": {
          if (!h) break;
          h === "http" && this.p2pLoaders.currentLoader.broadcastAnnouncement(), g && (g.resolve(a.data, this.getBandwidth(e)), this.engineRequest = void 0), this.requests.remove(a);
          const f = this.config.swarmId ?? this.streamManifestUrl, v = B(f, n);
          this.segmentStorage.storeSegment(f, v, c.externalId, a.data, c.startTime, c.endTime, c.stream.type, this.streamDetails.isLive);
          break;
        }
        case "failed":
          h !== "http" || l || this.p2pLoaders.currentLoader.broadcastAnnouncement(), g || n.segments.has(a.segment.runtimeId) || this.requests.remove(a), a.failedAttempts.httpAttemptsCount >= s && g && (this.engineRequest = void 0, g.reject());
          break;
        case "not-started":
        case "aborted":
          this.requests.remove(a);
      }
      a.markHandledByProcessQueue();
      const { lastAttempt: m } = a.failedAttempts;
      m && r - m.error.timestamp > 6e4 && a.failedAttempts.clear();
    }
  }
  processQueue() {
    var a;
    const { queue: t, queueSegmentIds: e, queueDownloadRatio: n } = this.generateQueue();
    this.processRequests(e, n);
    const { simultaneousHttpDownloads: s, simultaneousP2PDownloads: r, httpErrorRetries: o } = this.config;
    if ((a = this.engineRequest) != null && a.shouldBeStartedImmediately && this.engineRequest.status === "pending" && this.requests.executingHttpCount < s) {
      const { segment: h } = this.engineRequest, u = this.requests.get(h);
      (!u || u.status === "not-started" || u.status === "failed" && u.failedAttempts.httpAttemptsCount < this.config.httpErrorRetries) && this.loadThroughHttp(h);
    }
    for (const h of t) {
      const { statuses: u, segment: c } = h, l = this.requests.get(c);
      if (u.isHighDemand) {
        if ((l == null ? void 0 : l.downloadSource) === "http" && l.status === "loading" || (l == null ? void 0 : l.downloadSource) === "http" && l.status === "failed" && l.failedAttempts.httpAttemptsCount >= o) continue;
        const g = (l == null ? void 0 : l.status) === "loading" && l.downloadSource === "p2p";
        if (this.requests.executingHttpCount < s) {
          g && l.abortFromProcessQueue(), this.loadThroughHttp(c);
          continue;
        }
        if (this.abortLastHttpLoadingInQueueAfterItem(t, c) && this.requests.executingHttpCount < s) {
          g && l.abortFromProcessQueue(), this.loadThroughHttp(c);
          continue;
        }
        if (g) continue;
        if (this.requests.executingP2PCount < r) {
          this.loadThroughP2P(c);
          continue;
        }
        if (this.abortLastP2PLoadingInQueueAfterItem(t, c) && this.requests.executingP2PCount < r) {
          this.loadThroughP2P(c);
          continue;
        }
      } else if (u.isP2PDownloadable) {
        if ((l == null ? void 0 : l.status) === "loading") continue;
        (this.requests.executingP2PCount < r || this.p2pLoaders.currentLoader.isSegmentLoadedBySomeone(c) && this.abortLastP2PLoadingInQueueAfterItem(t, c) && this.requests.executingP2PCount < r) && this.loadThroughP2P(c);
      }
    }
  }
  abortSegmentRequest(t) {
    var e;
    ((e = this.engineRequest) == null ? void 0 : e.segment.runtimeId) === t && (this.engineRequest.abort(), this.logger("abort: ", Be(this.engineRequest.segment)), this.engineRequest = void 0, this.requestProcessQueueMicrotask());
  }
  loadThroughHttp(t) {
    const e = this.requests.getOrCreateRequest(t);
    new Bn(e, this.config, this.eventTarget), this.p2pLoaders.currentLoader.broadcastAnnouncement();
  }
  loadThroughP2P(t) {
    this.p2pLoaders.currentLoader.downloadSegment(t);
  }
  loadRandomThroughHttp() {
    const t = this.getAvailableStorageCapacityPercent();
    if (t <= 10) return;
    const { simultaneousHttpDownloads: e, httpErrorRetries: n } = this.config, s = this.p2pLoaders.currentLoader;
    if (this.requests.executingHttpCount >= e || !s.connectedPeerCount) return;
    const r = [];
    for (const { segment: c, statuses: l } of Fe(this.lastRequestedSegment, this.playback, this.config, this.p2pLoaders.currentLoader, t)) {
      const g = this.config.swarmId ?? this.streamManifestUrl, m = B(g, c.stream);
      if (!l.isHttpDownloadable || l.isP2PDownloadable || this.segmentStorage.hasSegment(g, m, c.externalId)) continue;
      const f = this.requests.get(c);
      f && (f.status === "loading" || f.status === "succeed" || f.failedAttempts.httpAttemptsCount >= n) || r.push(c);
    }
    if (!r.length || e - this.requests.executingHttpCount === 0) return;
    const o = s.connectedPeerCount + 1, a = Math.min(r.length, e * o), h = function(c) {
      for (let l = c.length - 1; l > 0; l--) {
        const g = Math.floor(Math.random() * (l + 1));
        [c[l], c[g]] = [c[g], c[l]];
      }
      return c;
    }(Array.from({ length: a }, (c, l) => l));
    let u = a / o;
    for (const c of h) {
      if (this.requests.executingHttpCount >= e) break;
      if (u >= 1 || Math.random() <= u) {
        const l = r[c];
        this.loadThroughHttp(l);
      }
      if (u--, u <= 0) break;
    }
  }
  abortLastHttpLoadingInQueueAfterItem(t, e) {
    for (const { segment: n } of De(t)) {
      if (n === e) break;
      const s = this.requests.get(n);
      if ((s == null ? void 0 : s.downloadSource) === "http" && s.status === "loading") return s.abortFromProcessQueue(), !0;
    }
    return !1;
  }
  abortLastP2PLoadingInQueueAfterItem(t, e) {
    for (const { segment: n } of De(t)) {
      if (n === e) break;
      const s = this.requests.get(n);
      if ((s == null ? void 0 : s.downloadSource) === "p2p" && s.status === "loading") return s.abortFromProcessQueue(), !0;
    }
    return !1;
  }
  getAvailableStorageCapacityPercent() {
    const { totalCapacity: t, usedCapacity: e } = this.segmentStorage.getUsage();
    return 100 - e / t * 100;
  }
  generateQueue() {
    var o;
    const t = [], e = /* @__PURE__ */ new Set();
    let n = 0, s = 0;
    const r = this.getAvailableStorageCapacityPercent();
    for (const a of Fe(this.lastRequestedSegment, this.playback, this.config, this.p2pLoaders.currentLoader, r)) {
      n++;
      const { segment: h } = a, u = this.config.swarmId ?? this.streamManifestUrl, c = B(u, h.stream);
      this.segmentStorage.hasSegment(u, c, h.externalId) || ((o = this.requests.get(h)) == null ? void 0 : o.status) === "succeed" ? s++ : (t.push(a), e.add(h.runtimeId));
    }
    return { queue: t, queueSegmentIds: e, maxPossibleLength: n, alreadyLoadedCount: s, queueDownloadRatio: n !== 0 ? s / n : 0 };
  }
  getBandwidth(t) {
    const { http: e, all: n } = this.bandwidthCalculators, { activeLevelBitrate: s } = this.streamDetails;
    if (this.streamDetails.activeLevelBitrate === 0) return n.getBandwidthLoadingOnly(3);
    const r = Math.max(n.getBandwidth(30, this.levelChangedTimestamp), n.getBandwidth(60, this.levelChangedTimestamp), n.getBandwidth(90, this.levelChangedTimestamp));
    if (t >= 0.8 || r >= 0.9 * s) return Math.max(n.getBandwidthLoadingOnly(1), n.getBandwidthLoadingOnly(3), n.getBandwidthLoadingOnly(5));
    const o = Math.max(e.getBandwidthLoadingOnly(1), e.getBandwidthLoadingOnly(3), e.getBandwidthLoadingOnly(5));
    return Math.max(r, o);
  }
  notifyLevelChanged() {
    this.levelChangedTimestamp = performance.now();
  }
  sendBroadcastAnnouncement(t = !1) {
    this.p2pLoaders.currentLoader.broadcastAnnouncement(t);
  }
  updatePlayback(t, e) {
    var o;
    const n = this.playback.rate !== e, s = this.playback.position !== t;
    if (!n && !s) return;
    const r = Math.abs(t - this.playback.position) / this.segmentAvgDuration > 0.5;
    s && (this.playback.position = t), n && e !== 0 && (this.playback.rate = e), r && (this.logger("position significantly changed"), (o = this.engineRequest) == null || o.markAsShouldBeStartedImmediately()), this.segmentStorage.onPlaybackUpdated(t, e), this.requestProcessQueueMicrotask(r);
  }
  updateStream(t) {
    t === this.lastRequestedSegment.stream && (this.logger(`update stream: ${F(t)}`), this.requestProcessQueueMicrotask());
  }
  destroy() {
    var t;
    clearInterval(this.storageCleanUpIntervalId), clearInterval(this.randomHttpDownloadInterval), this.storageCleanUpIntervalId = void 0, (t = this.engineRequest) == null || t.abort(), this.requests.destroy(), this.p2pLoaders.destroy();
  }
}
class He {
  constructor(t = 2e4) {
    d(this, "loadingsCount", 0);
    d(this, "bytes", []);
    d(this, "loadingOnlyTimestamps", []);
    d(this, "timestamps", []);
    d(this, "noLoadingsTime", 0);
    d(this, "loadingsStoppedAt", 0);
    this.clearThresholdMs = t;
  }
  addBytes(t, e = performance.now()) {
    this.bytes.push(t), this.loadingOnlyTimestamps.push(e - this.noLoadingsTime), this.timestamps.push(e);
  }
  startLoading(t = performance.now()) {
    this.clearStale(), this.loadingsCount === 0 && this.loadingsStoppedAt !== 0 && (this.noLoadingsTime += t - this.loadingsStoppedAt), this.loadingsCount++;
  }
  stopLoading(t = performance.now()) {
    this.loadingsCount > 0 && (this.loadingsCount--, this.loadingsCount === 0 && (this.loadingsStoppedAt = t));
  }
  getBandwidthLoadingOnly(t, e = Number.NEGATIVE_INFINITY) {
    if (!this.loadingOnlyTimestamps.length) return 0;
    const n = 1e3 * t, s = this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1];
    let r = s;
    const o = s - n;
    let a = 0;
    for (let h = this.bytes.length - 1; h >= 0; h--) {
      const u = this.loadingOnlyTimestamps[h];
      if (u < o || this.timestamps[h] < e) break;
      r = u, a += this.bytes[h];
    }
    return 8e3 * a / (s - r);
  }
  getBandwidth(t, e = Number.NEGATIVE_INFINITY, n = performance.now()) {
    if (!this.timestamps.length) return 0;
    const s = n - 1e3 * t;
    let r = n, o = 0;
    for (let a = this.bytes.length - 1; a >= 0; a--) {
      const h = this.timestamps[a];
      if (h < s || h < e) break;
      r = h, o += this.bytes[a];
    }
    return 8e3 * o / (n - r);
  }
  clearStale() {
    if (!this.loadingOnlyTimestamps.length) return;
    const t = this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1] - this.clearThresholdMs;
    let e = 0;
    for (const n of this.loadingOnlyTimestamps) {
      if (n > t) break;
      e++;
    }
    this.bytes.splice(0, e), this.loadingOnlyTimestamps.splice(0, e), this.timestamps.splice(0, e);
  }
}
const gt = (i, t) => `${i}|${t}`, mt = 1048576;
class ai {
  constructor() {
    d(this, "userAgent", navigator.userAgent);
    d(this, "segmentMemoryStorageLimit", 4096);
    d(this, "currentStorageUsage", 0);
    d(this, "cache", /* @__PURE__ */ new Map());
    d(this, "logger");
    d(this, "coreConfig");
    d(this, "mainStreamConfig");
    d(this, "secondaryStreamConfig");
    d(this, "currentPlayback");
    d(this, "lastRequestedSegment");
    d(this, "segmentChangeCallback");
    this.logger = L("p2pml-core:segment-memory-storage"), this.logger.color = "RebeccaPurple";
  }
  async initialize(t, e, n) {
    this.coreConfig = t, this.mainStreamConfig = e, this.secondaryStreamConfig = n, this.setMemoryStorageLimit(), this.logger("initialized");
  }
  onPlaybackUpdated(t, e) {
    this.currentPlayback = { position: t, rate: e };
  }
  onSegmentRequested(t, e, n, s, r, o, a) {
    this.lastRequestedSegment = { streamId: e, segmentId: n, startTime: s, endTime: r, swarmId: t, streamType: o, isLiveStream: a };
  }
  async storeSegment(t, e, n, s, r, o, a, h) {
    this.clear(h, s.byteLength);
    const u = gt(e, n);
    if (this.cache.set(u, { data: s, segmentId: n, streamId: e, startTime: r, endTime: o, streamType: a }), this.increaseStorageUsage(s.byteLength), this.logger(`add segment: ${n} to ${e}`), !this.segmentChangeCallback) throw new Error("dispatchStorageUpdatedEvent is not set");
    this.segmentChangeCallback(e);
  }
  async getSegmentData(t, e, n) {
    const s = gt(e, n), r = this.cache.get(s);
    if (r !== void 0) return r.data;
  }
  getUsage() {
    if (!this.lastRequestedSegment || !this.currentPlayback) return { totalCapacity: this.segmentMemoryStorageLimit, usedCapacity: this.currentStorageUsage };
    const t = this.currentPlayback.position;
    let e = 0;
    for (const { endTime: n, data: s } of this.cache.values()) t > n || (e += s.byteLength);
    return { totalCapacity: this.segmentMemoryStorageLimit, usedCapacity: e / mt };
  }
  hasSegment(t, e, n) {
    const s = gt(e, n);
    return this.cache.get(s) !== void 0;
  }
  getStoredSegmentIds(t, e) {
    const n = [];
    for (const { segmentId: s, streamId: r } of this.cache.values()) r === e && n.push(s);
    return n;
  }
  clear(t, e) {
    if (!(this.currentPlayback && this.mainStreamConfig && this.secondaryStreamConfig && this.coreConfig) || !this.isMemoryLimitReached(e) && !t) return;
    const n = /* @__PURE__ */ new Set(), s = Array.from(this.cache.values()).sort((r, o) => r.startTime - o.startTime);
    for (const r of s) {
      const { streamId: o, segmentId: a, data: h } = r, u = gt(o, a);
      if (this.shouldRemoveSegment(r, t, this.currentPlayback.position) && (this.cache.delete(u), n.add(o), this.decreaseStorageUsage(h.byteLength), this.logger(`Removed segment ${a} from stream ${o}`), !this.isMemoryLimitReached(e) && !t)) break;
    }
    this.sendUpdatesToAffectedStreams(n);
  }
  isMemoryLimitReached(t) {
    return this.currentStorageUsage + t / mt > this.segmentMemoryStorageLimit;
  }
  setSegmentChangeCallback(t) {
    this.segmentChangeCallback = t;
  }
  sendUpdatesToAffectedStreams(t) {
    t.size !== 0 && t.forEach((e) => {
      if (!this.segmentChangeCallback) throw new Error("dispatchStorageUpdatedEvent is not set");
      this.segmentChangeCallback(e);
    });
  }
  shouldRemoveSegment(t, e, n) {
    const { endTime: s, streamType: r } = t, o = this.getStreamTimeWindow(r, "highDemandTimeWindow");
    return !(n <= s) && (!e || n > o + s);
  }
  increaseStorageUsage(t) {
    this.currentStorageUsage += t / mt;
  }
  decreaseStorageUsage(t) {
    this.currentStorageUsage -= t / mt;
  }
  setMemoryStorageLimit() {
    var e;
    var t;
    (e = this.coreConfig) != null && e.segmentMemoryStorageLimit ? this.segmentMemoryStorageLimit = this.coreConfig.segmentMemoryStorageLimit : (t = this.userAgent, /Android/i.test(t) && !/Chrome|Firefox/i.test(t) || ((n) => /iPad|iPhone/i.test(n))(this.userAgent) ? this.segmentMemoryStorageLimit = 1024 : ((n) => /Android/i.test(n))(this.userAgent) && (this.segmentMemoryStorageLimit = 2048));
  }
  getStreamTimeWindow(t, e) {
    const n = t === "main" ? this.mainStreamConfig : this.secondaryStreamConfig;
    return (n == null ? void 0 : n[e]) ?? 0;
  }
  destroy() {
    this.cache.clear();
  }
}
class hi {
  constructor() {
    d(this, "events", /* @__PURE__ */ new Map());
  }
  dispatchEvent(t, ...e) {
    const n = this.events.get(t);
    if (n) for (const s of n) s(...e);
  }
  getEventDispatcher(t) {
    let e = this.events.get(t);
    e || (e = [], this.events.set(t, e));
    const n = e;
    return (...s) => {
      for (const r of n) r(...s);
    };
  }
  addEventListener(t, e) {
    const n = this.events.get(t);
    n ? n.push(e) : this.events.set(t, [e]);
  }
  removeEventListener(t, e) {
    const n = this.events.get(t);
    if (n) {
      const s = n.indexOf(e);
      s !== -1 && n.splice(s, 1);
    }
  }
}
const $ = class $ {
  constructor(t) {
    d(this, "eventTarget", new hi());
    d(this, "manifestResponseUrl");
    d(this, "streams", /* @__PURE__ */ new Map());
    d(this, "mainStreamConfig");
    d(this, "secondaryStreamConfig");
    d(this, "commonCoreConfig");
    d(this, "bandwidthCalculators", { all: new He(), http: new He() });
    d(this, "segmentStorage");
    d(this, "mainStreamLoader");
    d(this, "secondaryStreamLoader");
    d(this, "streamDetails", { isLive: !1, activeLevelBitrate: 0 });
    const e = function n(s) {
      if (xn(s)) {
        const r = {};
        return Object.keys(s).forEach((o) => {
          if (s[o] !== void 0) {
            const a = n(s[o]);
            a !== void 0 && (r[o] = a);
          }
        }), r;
      }
      return s;
    }(t ?? {});
    this.commonCoreConfig = Dt({ defaultConfig: $.DEFAULT_COMMON_CORE_CONFIG, baseConfig: e }), this.mainStreamConfig = Dt({ defaultConfig: $.DEFAULT_STREAM_CONFIG, baseConfig: e, specificStreamConfig: e.mainStream }), this.secondaryStreamConfig = Dt({ defaultConfig: $.DEFAULT_STREAM_CONFIG, baseConfig: e, specificStreamConfig: e.secondaryStream });
  }
  getConfig() {
    return { ...U(this.commonCoreConfig), mainStream: U(this.mainStreamConfig), secondaryStream: U(this.secondaryStreamConfig) };
  }
  applyDynamicConfig(t) {
    const { mainStream: e, secondaryStream: n } = t, s = U(this.mainStreamConfig), r = U(this.secondaryStreamConfig);
    this.overrideAllConfigs(t, e, n), this.processSpecificDynamicConfigParams(s, t, "main"), this.processSpecificDynamicConfigParams(r, t, "secondary");
  }
  processSpecificDynamicConfigParams(t, e, n) {
    const s = this.getUpdatedStreamProperty("isP2PDisabled", e, n);
    s && t.isP2PDisabled !== s && this.destroyStreamLoader(n);
    const r = this.getUpdatedStreamProperty("isP2PUploadDisabled", e, n);
    if (r !== void 0 && t.isP2PUploadDisabled !== r) {
      const o = n === "main" ? this.mainStreamLoader : this.secondaryStreamLoader;
      o == null || o.sendBroadcastAnnouncement(r);
    }
  }
  getUpdatedStreamProperty(t, e, n) {
    const s = n === "main" ? e.mainStream : e.secondaryStream;
    return (s == null ? void 0 : s[t]) ?? e[t];
  }
  addEventListener(t, e) {
    this.eventTarget.addEventListener(t, e);
  }
  removeEventListener(t, e) {
    this.eventTarget.removeEventListener(t, e);
  }
  setManifestResponseUrl(t) {
    this.manifestResponseUrl = t.split("?")[0];
  }
  hasSegment(t) {
    return !!Ue(this.streams, t);
  }
  getStream(t) {
    return this.streams.get(t);
  }
  addStreamIfNoneExists(t) {
    this.streams.has(t.runtimeId) || this.streams.set(t.runtimeId, { ...t, segments: /* @__PURE__ */ new Map() });
  }
  updateStream(t, e, n) {
    var r, o;
    const s = this.streams.get(t);
    if (s) {
      if (e) for (const a of e) s.segments.has(a.runtimeId) || s.segments.set(a.runtimeId, { ...a, stream: s });
      if (n) for (const a of n) s.segments.delete(a);
      (r = this.mainStreamLoader) == null || r.updateStream(s), (o = this.secondaryStreamLoader) == null || o.updateStream(s);
    }
  }
  async loadSegment(t, e) {
    if (!this.manifestResponseUrl) throw new Error("Manifest response url is not defined");
    await this.initializeSegmentStorage();
    const n = this.identifySegment(t);
    this.getStreamHybridLoader(n).loadSegment(n, e);
  }
  abortSegmentLoading(t) {
    var e, n;
    (e = this.mainStreamLoader) == null || e.abortSegmentRequest(t), (n = this.secondaryStreamLoader) == null || n.abortSegmentRequest(t);
  }
  updatePlayback(t, e) {
    var n, s;
    (n = this.mainStreamLoader) == null || n.updatePlayback(t, e), (s = this.secondaryStreamLoader) == null || s.updatePlayback(t, e);
  }
  setActiveLevelBitrate(t) {
    var e, n;
    t !== this.streamDetails.activeLevelBitrate && (this.streamDetails.activeLevelBitrate = t, (e = this.mainStreamLoader) == null || e.notifyLevelChanged(), (n = this.secondaryStreamLoader) == null || n.notifyLevelChanged());
  }
  setIsLive(t) {
    this.streamDetails.isLive = t;
  }
  isSegmentLoadable(t) {
    try {
      const e = this.identifySegment(t);
      return (e.stream.type !== "main" || !this.mainStreamConfig.isP2PDisabled) && (e.stream.type !== "secondary" || !this.secondaryStreamConfig.isP2PDisabled);
    } catch {
      return !1;
    }
  }
  destroy() {
    var t, e, n;
    this.streams.clear(), (t = this.mainStreamLoader) == null || t.destroy(), (e = this.secondaryStreamLoader) == null || e.destroy(), (n = this.segmentStorage) == null || n.destroy(), this.mainStreamLoader = void 0, this.secondaryStreamLoader = void 0, this.segmentStorage = void 0, this.manifestResponseUrl = void 0, this.streamDetails = { isLive: !1, activeLevelBitrate: 0 };
  }
  async initializeSegmentStorage() {
    if (this.segmentStorage) return;
    const { isLive: t } = this.streamDetails, e = this.commonCoreConfig.customSegmentStorageFactory;
    if (e && typeof e != "function") throw new Error("Storage configuration is invalid");
    const n = e ? e(t) : new ai();
    await n.initialize(this.commonCoreConfig, this.mainStreamConfig, this.secondaryStreamConfig), this.segmentStorage = n;
  }
  identifySegment(t) {
    if (!this.manifestResponseUrl) throw new Error("Manifest response url is undefined");
    const e = Ue(this.streams, t);
    if (!e) throw new Error(`Not found segment with id: ${t}`);
    return e;
  }
  overrideAllConfigs(t, e, n) {
    K(this.commonCoreConfig, t), K(this.mainStreamConfig, t), K(this.secondaryStreamConfig, t), e && K(this.mainStreamConfig, e), n && K(this.secondaryStreamConfig, n);
  }
  destroyStreamLoader(t) {
    var e, n;
    t === "main" ? ((e = this.mainStreamLoader) == null || e.destroy(), this.mainStreamLoader = void 0) : ((n = this.secondaryStreamLoader) == null || n.destroy(), this.secondaryStreamLoader = void 0);
  }
  getStreamHybridLoader(t) {
    return t.stream.type === "main" ? (this.mainStreamLoader ?? (this.mainStreamLoader = this.createNewHybridLoader(t)), this.mainStreamLoader) : (this.secondaryStreamLoader ?? (this.secondaryStreamLoader = this.createNewHybridLoader(t)), this.secondaryStreamLoader);
  }
  createNewHybridLoader(t) {
    if (!this.manifestResponseUrl) throw new Error("Manifest response url is not defined");
    if (!this.segmentStorage) throw new Error("Segment storage is not initialized");
    const e = t.stream.type === "main" ? this.mainStreamConfig : this.secondaryStreamConfig;
    return new oi(this.manifestResponseUrl, t, this.streamDetails, e, this.bandwidthCalculators, this.segmentStorage, this.eventTarget);
  }
};
d($, "DEFAULT_COMMON_CORE_CONFIG", { segmentMemoryStorageLimit: void 0, customSegmentStorageFactory: void 0 }), d($, "DEFAULT_STREAM_CONFIG", { isP2PUploadDisabled: !1, isP2PDisabled: !1, simultaneousHttpDownloads: 2, simultaneousP2PDownloads: 3, highDemandTimeWindow: 15, httpDownloadTimeWindow: 3e3, p2pDownloadTimeWindow: 6e3, webRtcMaxMessageSize: 65535, p2pNotReceivingBytesTimeoutMs: 2e3, p2pInactiveLoaderDestroyTimeoutMs: 3e4, httpNotReceivingBytesTimeoutMs: 3e3, httpErrorRetries: 3, p2pErrorRetries: 3, trackerClientVersionPrefix: Fs, announceTrackers: ["wss://tracker.novage.com.ua", "wss://tracker.webtorrent.dev", "wss://tracker.openwebtorrent.com"], rtcConfig: { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:global.stun.twilio.com:3478" }] }, validateP2PSegment: void 0, httpRequestSetup: void 0, swarmId: void 0 });
let $e = $;
const di = ze.debug;
export {
  $e as Core,
  oe as CoreRequestError,
  x as RequestError,
  di as debug
};
//# sourceMappingURL=p2p-media-loader-core.es.min.js.map
